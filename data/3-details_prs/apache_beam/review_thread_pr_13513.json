{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1NDA0ODUx", "number": 13513, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMTo1Mjo0OVrOFF5QXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMzo0OTozOFrOFGgp5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNzI1Mjc3OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMTo1Mjo0OVrOIGoDVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxODozNjoyN1rOIHTl_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgxODU4MQ==", "bodyText": "Why is bytesToWrite not equal to charBytes.length?\nI believe we are trying to check that:\nif (charBytes.length <= buf.remaining() instead of if (bytesToWrite > BUF_SIZE) ?", "url": "https://github.com/apache/beam/pull/13513#discussion_r543818581", "createdAt": "2020-12-16T01:52:49Z", "author": {"login": "aaltay"}, "path": "sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java", "diffHunk": "@@ -281,7 +283,15 @@ private long getFirstOccurenceOfRecordElement(\n               break outer;\n             } else {\n               // Matching was unsuccessful. Reset the buffer to include bytes read for the char.\n-              ByteBuffer newbuf = ByteBuffer.allocate(BUF_SIZE);\n+              int bytesToWrite = buf.remaining() + charBytes.length;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5987fdc021a3a778cb0c3f449012e913ea14a3a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4MzY3OQ==", "bodyText": "charBytes is an array of 4 bytes, we've read from the buffer.\nthis code caused the buffer overflow because that charBytes can be the input from the previous reading from the channel.\n              newbuf.put(charBytes);\n              offsetInFileOfCurrentByte -= charBytes.length;\n              while (buf.hasRemaining()) {\n                newbuf.put(buf.get());\n              }\n\nso when we do the next reading of BUF_SIZE (or BUF_SIZE-n where n <charBytes.length) bytes from the channel to buf and go here, we have more byte to write to the newBuf than it's capacity.", "url": "https://github.com/apache/beam/pull/13513#discussion_r544083679", "createdAt": "2020-12-16T07:53:50Z", "author": {"login": "Romster"}, "path": "sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java", "diffHunk": "@@ -281,7 +283,15 @@ private long getFirstOccurenceOfRecordElement(\n               break outer;\n             } else {\n               // Matching was unsuccessful. Reset the buffer to include bytes read for the char.\n-              ByteBuffer newbuf = ByteBuffer.allocate(BUF_SIZE);\n+              int bytesToWrite = buf.remaining() + charBytes.length;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgxODU4MQ=="}, "originalCommit": {"oid": "c5987fdc021a3a778cb0c3f449012e913ea14a3a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMxNTY2OA==", "bodyText": "It seems to be a pretty rare corner case, so people usually don't face it.\nBut our service deals with lots of big XML files with different formats and we see it several times a week.", "url": "https://github.com/apache/beam/pull/13513#discussion_r544315668", "createdAt": "2020-12-16T13:54:23Z", "author": {"login": "Romster"}, "path": "sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java", "diffHunk": "@@ -281,7 +283,15 @@ private long getFirstOccurenceOfRecordElement(\n               break outer;\n             } else {\n               // Matching was unsuccessful. Reset the buffer to include bytes read for the char.\n-              ByteBuffer newbuf = ByteBuffer.allocate(BUF_SIZE);\n+              int bytesToWrite = buf.remaining() + charBytes.length;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgxODU4MQ=="}, "originalCommit": {"oid": "c5987fdc021a3a778cb0c3f449012e913ea14a3a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDUzMTk2NQ==", "bodyText": "Got it, makes sense. I will resolve this. We can merge it once the other comment is also resolved.", "url": "https://github.com/apache/beam/pull/13513#discussion_r544531965", "createdAt": "2020-12-16T18:36:27Z", "author": {"login": "aaltay"}, "path": "sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java", "diffHunk": "@@ -281,7 +283,15 @@ private long getFirstOccurenceOfRecordElement(\n               break outer;\n             } else {\n               // Matching was unsuccessful. Reset the buffer to include bytes read for the char.\n-              ByteBuffer newbuf = ByteBuffer.allocate(BUF_SIZE);\n+              int bytesToWrite = buf.remaining() + charBytes.length;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgxODU4MQ=="}, "originalCommit": {"oid": "c5987fdc021a3a778cb0c3f449012e913ea14a3a"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNzg5NDMwOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/xml/src/test/java/org/apache/beam/sdk/io/xml/XmlSourceTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNDoxNTowOFrOIGuTtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMzo0Mjo0NVrOIHF4yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkyMTA3OA==", "bodyText": "I think your input here does not conform to the format required by the Xml source that is defined here: https://github.com/apache/beam/blob/master/sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlIO.java#L68\nSpecifically it has to be of the following format.\n<root>\n<record> ... </record>\n<record> ... </record>\n<record> ... </record>\n...\n<record> ... </record>\n</root>\n\nBut you have additional element: <trainTags><trainTag></trainTag> ... <trainTag></trainTag></trainTags>\nWere you able to reproduce the issue when the input conforms to the required format ?", "url": "https://github.com/apache/beam/pull/13513#discussion_r543921078", "createdAt": "2020-12-16T04:15:08Z", "author": {"login": "chamikaramj"}, "path": "sdks/java/io/xml/src/test/java/org/apache/beam/sdk/io/xml/XmlSourceTest.java", "diffHunk": "@@ -873,6 +881,46 @@ public void testSplitAtFractionExhaustiveSingleByte() throws Exception {\n     assertSplitAtFractionExhaustive(source, options);\n   }\n \n+  @Test\n+  public void testNoBufferOverflowThrown() throws IOException {\n+    // The magicNumber was found imperatively and will be different for different xml content.\n+    // Test with the current setup causes BufferOverflow in\n+    // XMLReader#getFirstOccurenceOfRecordElement method,\n+    // if the specific corner case is not handled\n+    final int magicNumber = 183;\n+    StringBuilder sb = new StringBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5987fdc021a3a778cb0c3f449012e913ea14a3a"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4NzM0OQ==", "bodyText": "This is an artificial example, but the main condition is that you have some amount of <recordBlahBlah> tags\nThe real case looks like\n<root>\n <record> \n  <recordSomething>\n  </recordSomething>\n </record>\n <record> \n  <recordSomething>\n  </recordSomething>\n </record>\n...\n <record> \n  <recordSomething>\n  </recordSomething>\n </record>\n</root>\n\nThe behaviour seems to be environment-dependent, so I'm not sure if even my example will be reproduced in another environment (it depends also on how many bytes we are reading  from the channel)", "url": "https://github.com/apache/beam/pull/13513#discussion_r544087349", "createdAt": "2020-12-16T08:01:05Z", "author": {"login": "Romster"}, "path": "sdks/java/io/xml/src/test/java/org/apache/beam/sdk/io/xml/XmlSourceTest.java", "diffHunk": "@@ -873,6 +881,46 @@ public void testSplitAtFractionExhaustiveSingleByte() throws Exception {\n     assertSplitAtFractionExhaustive(source, options);\n   }\n \n+  @Test\n+  public void testNoBufferOverflowThrown() throws IOException {\n+    // The magicNumber was found imperatively and will be different for different xml content.\n+    // Test with the current setup causes BufferOverflow in\n+    // XMLReader#getFirstOccurenceOfRecordElement method,\n+    // if the specific corner case is not handled\n+    final int magicNumber = 183;\n+    StringBuilder sb = new StringBuilder();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkyMTA3OA=="}, "originalCommit": {"oid": "c5987fdc021a3a778cb0c3f449012e913ea14a3a"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyMTY3NQ==", "bodyText": "Here is a piece of XML we deal with in our service:\nfrom the root ONIXMessage we read records Product\n<?xml version='1.0' encoding='ISO-8859-1'?>\n<ONIXMessage xmlns=\"http://ns.editeur.org/onix/3.0/reference\" release=\"3.0\">\n  <Header>\n    <Sender>\n      <SenderIdentifier>\n        <SenderIDType></SenderIDType>\n        <IDValue></IDValue>\n      </SenderIdentifier>\n      <SenderName></SenderName>\n      <EmailAddress></EmailAddress>\n    </Sender>\n    <Addressee>\n      <AddresseeName></AddresseeName>\n    </Addressee>\n    <MessageNumber></MessageNumber>\n    <SentDateTime></SentDateTime>\n  </Header>\n  <Product>\n    <RecordReference></RecordReference>\n    <NotificationType></NotificationType>\n    <RecordSourceType></RecordSourceType>\n    <ProductIdentifier>\n      <ProductIDType></ProductIDType>\n      <IDValue></IDValue>\n    </ProductIdentifier>\n    <ProductIdentifier>\n      <ProductIDType></ProductIDType>\n      <IDValue></IDValue>\n    </ProductIdentifier>\n\nas you can see there are inner tags like ProductIdentifier and ProductIDType.\nBut we also have a structure like\n<root>\n<head>\n</head>\n<record>\n</record>\n...\n</root>\n\nand in most cases, it's not a problem\nWe run it in Google Dataflow, and when it fails with BufferOverflow restarting the job helps - so the issue can't be easily reproduced.", "url": "https://github.com/apache/beam/pull/13513#discussion_r544121675", "createdAt": "2020-12-16T08:57:09Z", "author": {"login": "Romster"}, "path": "sdks/java/io/xml/src/test/java/org/apache/beam/sdk/io/xml/XmlSourceTest.java", "diffHunk": "@@ -873,6 +881,46 @@ public void testSplitAtFractionExhaustiveSingleByte() throws Exception {\n     assertSplitAtFractionExhaustive(source, options);\n   }\n \n+  @Test\n+  public void testNoBufferOverflowThrown() throws IOException {\n+    // The magicNumber was found imperatively and will be different for different xml content.\n+    // Test with the current setup causes BufferOverflow in\n+    // XMLReader#getFirstOccurenceOfRecordElement method,\n+    // if the specific corner case is not handled\n+    final int magicNumber = 183;\n+    StringBuilder sb = new StringBuilder();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkyMTA3OA=="}, "originalCommit": {"oid": "c5987fdc021a3a778cb0c3f449012e913ea14a3a"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMwNzQwMQ==", "bodyText": "I've updated the test - now it uses input like\n<trains>\n    <train>\n        <trainTags>\n            <trainTag>0</trainTag>\n            <trainTag>1</trainTag>\n            <trainTag>2</trainTag>\n            ...\n\nSo the format issue is not the case.\nTo reproduce the error I had to use TestPipeline - so the input was split into bundles\n\nINFO: Splitting filepattern /var/folders/j5/2qx0r7453tvd56zpjbstv6fw4m_zm3/T/junit946409719265813413/trainXMLWithTags into bundles of size 126 took 1 ms and produced 1 files and 20 bundles", "url": "https://github.com/apache/beam/pull/13513#discussion_r544307401", "createdAt": "2020-12-16T13:42:45Z", "author": {"login": "Romster"}, "path": "sdks/java/io/xml/src/test/java/org/apache/beam/sdk/io/xml/XmlSourceTest.java", "diffHunk": "@@ -873,6 +881,46 @@ public void testSplitAtFractionExhaustiveSingleByte() throws Exception {\n     assertSplitAtFractionExhaustive(source, options);\n   }\n \n+  @Test\n+  public void testNoBufferOverflowThrown() throws IOException {\n+    // The magicNumber was found imperatively and will be different for different xml content.\n+    // Test with the current setup causes BufferOverflow in\n+    // XMLReader#getFirstOccurenceOfRecordElement method,\n+    // if the specific corner case is not handled\n+    final int magicNumber = 183;\n+    StringBuilder sb = new StringBuilder();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkyMTA3OA=="}, "originalCommit": {"oid": "c5987fdc021a3a778cb0c3f449012e913ea14a3a"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzcwNTI0OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMzo0ODozM1rOIHja2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODowOToxNFrOIHpUWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc5MTI1OQ==", "bodyText": "Probably expand comment to following.\n\"The number of bytes to push to the buffer might be larger than BUF_SIZE due to additional 'charBytes'.\"", "url": "https://github.com/apache/beam/pull/13513#discussion_r544791259", "createdAt": "2020-12-17T03:48:33Z", "author": {"login": "chamikaramj"}, "path": "sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java", "diffHunk": "@@ -281,7 +283,15 @@ private long getFirstOccurenceOfRecordElement(\n               break outer;\n             } else {\n               // Matching was unsuccessful. Reset the buffer to include bytes read for the char.\n-              ByteBuffer newbuf = ByteBuffer.allocate(BUF_SIZE);\n+              int bytesToWrite = buf.remaining() + charBytes.length;\n+              ByteBuffer newbuf;\n+              if (bytesToWrite > BUF_SIZE) {\n+                // Avoiding buffer overflow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76f78136b537a0f5fec736011fa05a49d576b9fc"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4Nzg5OA==", "bodyText": "done", "url": "https://github.com/apache/beam/pull/13513#discussion_r544887898", "createdAt": "2020-12-17T08:09:14Z", "author": {"login": "Romster"}, "path": "sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java", "diffHunk": "@@ -281,7 +283,15 @@ private long getFirstOccurenceOfRecordElement(\n               break outer;\n             } else {\n               // Matching was unsuccessful. Reset the buffer to include bytes read for the char.\n-              ByteBuffer newbuf = ByteBuffer.allocate(BUF_SIZE);\n+              int bytesToWrite = buf.remaining() + charBytes.length;\n+              ByteBuffer newbuf;\n+              if (bytesToWrite > BUF_SIZE) {\n+                // Avoiding buffer overflow", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc5MTI1OQ=="}, "originalCommit": {"oid": "76f78136b537a0f5fec736011fa05a49d576b9fc"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzcwNzg5OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMzo0OTozOFrOIHjcNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODowOToyMlrOIHpUnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc5MTYwNw==", "bodyText": "Add a comment.\n\"We have to reset the size of the buffer to 'BUF_SIZE' to prevent it from infinitely increasing.\"", "url": "https://github.com/apache/beam/pull/13513#discussion_r544791607", "createdAt": "2020-12-17T03:49:38Z", "author": {"login": "chamikaramj"}, "path": "sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java", "diffHunk": "@@ -320,7 +330,12 @@ private long getFirstOccurenceOfRecordElement(\n             recordStartBytesMatched = true;\n           }\n         }\n-        buf.clear();\n+        if (bufSizeChanged) {\n+          buf = ByteBuffer.allocate(BUF_SIZE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76f78136b537a0f5fec736011fa05a49d576b9fc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4Nzk2NA==", "bodyText": "done", "url": "https://github.com/apache/beam/pull/13513#discussion_r544887964", "createdAt": "2020-12-17T08:09:22Z", "author": {"login": "Romster"}, "path": "sdks/java/io/xml/src/main/java/org/apache/beam/sdk/io/xml/XmlSource.java", "diffHunk": "@@ -320,7 +330,12 @@ private long getFirstOccurenceOfRecordElement(\n             recordStartBytesMatched = true;\n           }\n         }\n-        buf.clear();\n+        if (bufSizeChanged) {\n+          buf = ByteBuffer.allocate(BUF_SIZE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc5MTYwNw=="}, "originalCommit": {"oid": "76f78136b537a0f5fec736011fa05a49d576b9fc"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2542, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}