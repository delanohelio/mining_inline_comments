{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMTI2NzY0", "number": 11963, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDowMToxNVrOENZmRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOToyOToxNlrOERMDVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDg2MzQyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/core.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDowMToxNVrOGwEG3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDowMToxNVrOGwEG3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1MjEyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  beam.Map(lambda v: (expr(v), v)) | GroupByKey()\n          \n          \n            \n                  beam.Map(lambda v: (expr(v), v)) | beam.GroupByKey()", "url": "https://github.com/apache/beam/pull/11963#discussion_r453052127", "createdAt": "2020-07-10T20:01:15Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2248,154 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | GroupByKey()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDg4MjU1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/coders/row_coder.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDowOTowMlrOGwES3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMDowNDozOVrOG1yPyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1NTE5Nw==", "bodyText": "Is this a fallback for when a Row uses types that we don't support in Python schemas?\nI worry about this since it makes it tricky for a user to tell when a PCollection can be used in an ExternalTransform that uses rows. Are there some specific types that we need to add coverage for?", "url": "https://github.com/apache/beam/pull/11963#discussion_r453055197", "createdAt": "2020-07-10T20:09:02Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/coders/row_coder.py", "diffHunk": "@@ -87,7 +87,10 @@ def from_runner_api_parameter(schema, components, unused_context):\n   @staticmethod\n   def from_type_hint(type_hint, registry):\n     if isinstance(type_hint, row_type.RowTypeConstraint):\n-      schema = named_fields_to_schema(type_hint._fields)\n+      try:\n+        schema = named_fields_to_schema(type_hint._fields)\n+      except ValueError:\n+        return typecoders.registry.get_coder(object)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzNzg5OA==", "bodyText": "Well, it's also there to handle the case where we simply don't know what the type is. I'll see if I can re-work this to use named tuples (thanks for the idea about __reduce__).", "url": "https://github.com/apache/beam/pull/11963#discussion_r453137898", "createdAt": "2020-07-11T01:23:54Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/coders/row_coder.py", "diffHunk": "@@ -87,7 +87,10 @@ def from_runner_api_parameter(schema, components, unused_context):\n   @staticmethod\n   def from_type_hint(type_hint, registry):\n     if isinstance(type_hint, row_type.RowTypeConstraint):\n-      schema = named_fields_to_schema(type_hint._fields)\n+      try:\n+        schema = named_fields_to_schema(type_hint._fields)\n+      except ValueError:\n+        return typecoders.registry.get_coder(object)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1NTE5Nw=="}, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1MDk1NQ==", "bodyText": "Ah I see. I'd rather not have this escape hatch if we can avoid it, but I can imagine it would be frustrating for users who don't care about using Rows xlang if we just refuse to make a RowCoder for them. Perhaps we should make named_fields_to_schema wrap unknown type hints in a \"pythonsdk\" logical type that uses fast primitives coder. Then we can give a better error message if/when a xlang issue arises. If you just add a TODO here I can take that action.\nWhen running locally I noticed that this is only needed for your tests because we can't infer a type for sign=x // abs(x) if x else 0 and fallback to Any. Just curious - is it possible to fix the inference for that function? It seems like we should be able to.", "url": "https://github.com/apache/beam/pull/11963#discussion_r459050955", "createdAt": "2020-07-22T20:04:39Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/coders/row_coder.py", "diffHunk": "@@ -87,7 +87,10 @@ def from_runner_api_parameter(schema, components, unused_context):\n   @staticmethod\n   def from_type_hint(type_hint, registry):\n     if isinstance(type_hint, row_type.RowTypeConstraint):\n-      schema = named_fields_to_schema(type_hint._fields)\n+      try:\n+        schema = named_fields_to_schema(type_hint._fields)\n+      except ValueError:\n+        return typecoders.registry.get_coder(object)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1NTE5Nw=="}, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDkwNTQ1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/core.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDoxODowNlrOGwEgrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDoxODowNlrOGwEgrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1ODczNA==", "bodyText": "I had this problem with the NamedTuple used in an external transform's output PCollection, I solved it there by making a custom __reduce__ function that rebuilds from the proto-encoded schema:\n\n  \n    \n      beam/sdks/python/apache_beam/typehints/schemas.py\n    \n    \n        Lines 210 to 225\n      in\n      80de476\n    \n    \n    \n    \n\n        \n          \n           type_name = 'BeamSchema_{}'.format(schema.id.replace('-', '_')) \n        \n\n        \n          \n           user_type = NamedTuple( \n        \n\n        \n          \n               type_name, \n        \n\n        \n          \n               [(field.name, typing_from_runner_api(field.type)) \n        \n\n        \n          \n                for field in schema.fields]) \n        \n\n        \n          \n            \n        \n\n        \n          \n           setattr(user_type, _BEAM_SCHEMA_ID, schema.id) \n        \n\n        \n          \n            \n        \n\n        \n          \n           # Define a reduce function, otherwise these types can't be pickled \n        \n\n        \n          \n           # (See BEAM-9574) \n        \n\n        \n          \n           def __reduce__(self): \n        \n\n        \n          \n             return ( \n        \n\n        \n          \n                 _hydrate_namedtuple_instance, \n        \n\n        \n          \n                 (schema.SerializeToString(), tuple(self))) \n        \n\n        \n          \n            \n        \n\n        \n          \n           setattr(user_type, '__reduce__', __reduce__) \n        \n    \n  \n\n\n(A TODO is fine as well, just wanted to point that out in case it's helpful)", "url": "https://github.com/apache/beam/pull/11963#discussion_r453058734", "createdAt": "2020-07-10T20:18:06Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2248,154 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | GroupByKey()\n+\n+  but provides several conviniences, e.g.\n+\n+      * Several arguments may be provided, as positional or keyword arguments,\n+        resulting in a tuple-like key. For example `GroupBy(a=expr1, b=expr2)`\n+        groups by a key with attributes `a` and `b` computed by applying\n+        `expr1` and `expr2` to each element.\n+\n+      * Strings can be used as a shorthand for accessing an attribute, e.g.\n+        `GroupBy('some_field')` is equivalent to\n+        `GroupBy(lambda v: getattr(v, 'some_field'))`.\n+\n+  The GroupBy operation can be made into an aggregating operation by invoking\n+  its `aggregate_field` method.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      *fields,  # type: typing.Union[str, callable]\n+      **kwargs  # type: typing.Union[str, callable]\n+    ):\n+    if len(fields) == 1 and not kwargs:\n+      self._force_tuple_keys = False\n+      name = fields[0] if isinstance(fields[0], str) else 'key'\n+      key_fields = [(name, _expr_to_callable(fields[0], 0))]\n+    else:\n+      self._force_tuple_keys = True\n+      key_fields = []\n+      for ix, field in enumerate(fields):\n+        name = field if isinstance(field, str) else 'key%d' % ix\n+        key_fields.append((name, _expr_to_callable(field, ix)))\n+      for name, expr in kwargs.items():\n+        key_fields.append((name, _expr_to_callable(expr, name)))\n+    self._key_fields = key_fields\n+    # TODO(robertwb): Pickling of dynamic named tuples.\n+    # self._key_type = typing.NamedTuple(\n+    #     'Key', [name for name, _ in self._key_fields])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDkyMTUwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/core.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDoyNTowM1rOGwEqow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDoyNTowM1rOGwEqow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2MTI4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # TODO(Py3): Use {**a, **b} syntax once Python 2 is gone.\n          \n          \n            \n                # TODO(BEAM-7372): Use {**a, **b} syntax once Python 2 is gone.", "url": "https://github.com/apache/beam/pull/11963#discussion_r453061283", "createdAt": "2020-07-10T20:25:03Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2248,154 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | GroupByKey()\n+\n+  but provides several conviniences, e.g.\n+\n+      * Several arguments may be provided, as positional or keyword arguments,\n+        resulting in a tuple-like key. For example `GroupBy(a=expr1, b=expr2)`\n+        groups by a key with attributes `a` and `b` computed by applying\n+        `expr1` and `expr2` to each element.\n+\n+      * Strings can be used as a shorthand for accessing an attribute, e.g.\n+        `GroupBy('some_field')` is equivalent to\n+        `GroupBy(lambda v: getattr(v, 'some_field'))`.\n+\n+  The GroupBy operation can be made into an aggregating operation by invoking\n+  its `aggregate_field` method.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      *fields,  # type: typing.Union[str, callable]\n+      **kwargs  # type: typing.Union[str, callable]\n+    ):\n+    if len(fields) == 1 and not kwargs:\n+      self._force_tuple_keys = False\n+      name = fields[0] if isinstance(fields[0], str) else 'key'\n+      key_fields = [(name, _expr_to_callable(fields[0], 0))]\n+    else:\n+      self._force_tuple_keys = True\n+      key_fields = []\n+      for ix, field in enumerate(fields):\n+        name = field if isinstance(field, str) else 'key%d' % ix\n+        key_fields.append((name, _expr_to_callable(field, ix)))\n+      for name, expr in kwargs.items():\n+        key_fields.append((name, _expr_to_callable(expr, name)))\n+    self._key_fields = key_fields\n+    # TODO(robertwb): Pickling of dynamic named tuples.\n+    # self._key_type = typing.NamedTuple(\n+    #     'Key', [name for name, _ in self._key_fields])\n+    self._key_type = lambda *values: pvalue.Row(\n+        **{name: value\n+           for (name, _), value in zip(self._key_fields, values)})\n+\n+  def aggregate_field(\n+      self,\n+      field,  # type: typing.Union[str, callable]\n+      combine_fn,  # type: typing.Union[callable, CombineFn]\n+      dest,  # type: str\n+    ):\n+    \"\"\"Returns a grouping operation that also aggregates grouped values.\n+\n+    Args:\n+      field: indicates the field to be aggregated\n+      combine_fn: indicates the aggregation function to be used\n+      dest: indicates the name that will be used for the aggregate in the output\n+\n+    May be called repeatedly to aggregate multiple fields, e.g.\n+\n+        GroupBy('key')\n+            .aggregate_field('some_attr', sum, 'sum_attr')\n+            .aggregate_field(lambda v: ..., MeanCombineFn, 'mean')\n+    \"\"\"\n+    return _GroupAndAggregate(self, ()).aggregate_field(field, combine_fn, dest)\n+\n+  def force_tuple_keys(self, value=True):\n+    \"\"\"Forces the keys to always be tuple-like, even if there is only a single\n+    expression.\n+    \"\"\"\n+    res = copy.copy(self)\n+    res._force_tuple_keys = value\n+    return res\n+\n+  def _key_func(self):\n+    if not self._force_tuple_keys and len(self._key_fields) == 1:\n+      return self._key_fields[0][1]\n+    else:\n+      key_type = self._key_type\n+      key_exprs = [expr for _, expr in self._key_fields]\n+      return lambda element: key_type(*(expr(element) for expr in key_exprs))\n+\n+  def default_label(self):\n+    return 'GroupBy(%s)' % ', '.join(name for name, _ in self._key_fields)\n+\n+  def expand(self, pcoll):\n+    return pcoll | Map(lambda x: (self._key_func()(x), x)) | GroupByKey()\n+\n+\n+class _GroupAndAggregate(PTransform):\n+  def __init__(self, grouping, aggregations):\n+    self._grouping = grouping\n+    self._aggregations = aggregations\n+\n+  def aggregate_field(\n+      self,\n+      field,  # type: typing.Union[str, callable]\n+      combine_fn,  # type: typing.Union[callable, CombineFn]\n+      dest,  # type: str\n+      ):\n+    field = _expr_to_callable(field, 0)\n+    return _GroupAndAggregate(\n+        self._grouping, list(self._aggregations) + [(field, combine_fn, dest)])\n+\n+  def expand(self, pcoll):\n+    from apache_beam.transforms.combiners import TupleCombineFn\n+\n+    # TODO(Py3): Use {**a, **b} syntax once Python 2 is gone.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDkzMDUwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/typehints/native_type_compatibility.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDoyODo0N1rOGwEwLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQwMToyMzoyMlrOGwJVsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2MjcwMQ==", "bodyText": "Will issubclass actually raise an AttributeError? Curious what causes this", "url": "https://github.com/apache/beam/pull/11963#discussion_r453062701", "createdAt": "2020-07-10T20:28:47Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/typehints/native_type_compatibility.py", "diffHunk": "@@ -85,7 +85,7 @@ def _safe_issubclass(derived, parent):\n   \"\"\"\n   try:\n     return issubclass(derived, parent)\n-  except TypeError:\n+  except (TypeError, AttributeError):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzNzg0Mg==", "bodyText": "I'm pretty sure I did see this. (Maybe it was missing __mro__ or something?)", "url": "https://github.com/apache/beam/pull/11963#discussion_r453137842", "createdAt": "2020-07-11T01:23:22Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/typehints/native_type_compatibility.py", "diffHunk": "@@ -85,7 +85,7 @@ def _safe_issubclass(derived, parent):\n   \"\"\"\n   try:\n     return issubclass(derived, parent)\n-  except TypeError:\n+  except (TypeError, AttributeError):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2MjcwMQ=="}, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDU4NzExOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/core.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOToyOToxNlrOG1xFWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOToyOToxNlrOG1xFWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMTg5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              but provides several conviniences, e.g.\n          \n          \n            \n              but provides several conveniences, e.g.", "url": "https://github.com/apache/beam/pull/11963#discussion_r459031897", "createdAt": "2020-07-22T19:29:16Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2249,166 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | beam.GroupByKey()\n+\n+  but provides several conviniences, e.g.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71c758053be2695a1db66d8797c86042a148970f"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3654, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}