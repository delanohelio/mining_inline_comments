{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1Njc1MTgy", "number": 13617, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNjo1NDowMlrOFJkp5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxNjo0MTowOFrOF11h6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NTgyMDU0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai_test.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNjo1NDowMlrOIL9nOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNjo1NDowMlrOIL9nOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNDcxMg==", "bodyText": "you should probably keep this line", "url": "https://github.com/apache/beam/pull/13617#discussion_r549414712", "createdAt": "2020-12-28T16:54:02Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai_test.py", "diffHunk": "@@ -0,0 +1,179 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"Unit tests for Recommendations AI transforms.\"\"\"\n+\n+# TODO: write unit tests for transforms\n+\n+from __future__ import absolute_import\n+\n+import mock\n+import unittest\n+\n+import apache_beam as beam\n+from apache_beam.metrics import MetricsFilter\n+\n+try:\n+    from google.cloud import recommendationengine\n+\n+    from apache_beam.ml.gcp import recommendations_ai\n+except ImportError:\n+    recommendationengine = None\n+    raise ImportError('Google Cloud Recommendation AI not supported for this execution '\n+                      'environment (could not import google.cloud.recommendationengine).')\n+\n+\n+# @unittest.skipIf(recommendationengine is None, \"Recommendations AI dependencies not installed.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc710779af4135aedb2cb976dd4a4f0eec60e0ee"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NTgyMjM0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNjo1NTowMVrOIL9oPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMzozNTowMVrOIQAZDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNDk3NQ==", "bodyText": "it would be good if you could add a more complete writeup with examples on how to use the transforms here. thoughts?", "url": "https://github.com/apache/beam/pull/13617#discussion_r549414975", "createdAt": "2020-12-28T16:55:01Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "diffHunk": "@@ -0,0 +1,472 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"A connector for sending API requests to the GCP Recommendations AI API (https://cloud.google.com/recommendations).\"\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc710779af4135aedb2cb976dd4a4f0eec60e0ee"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNTQxNg==", "bodyText": "(though I see that you have examples further down - so maybe just a writeup will be enough)", "url": "https://github.com/apache/beam/pull/13617#discussion_r549415416", "createdAt": "2020-12-28T16:56:22Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "diffHunk": "@@ -0,0 +1,472 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"A connector for sending API requests to the GCP Recommendations AI API (https://cloud.google.com/recommendations).\"\"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNDk3NQ=="}, "originalCommit": {"oid": "fc710779af4135aedb2cb976dd4a4f0eec60e0ee"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY1NDU0Mg==", "bodyText": "You mean a summary of the things that you can do with the transforms (and refer to the examples for each individual transform below then)?", "url": "https://github.com/apache/beam/pull/13617#discussion_r553654542", "createdAt": "2021-01-07T23:35:01Z", "author": {"login": "matthiasa4"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "diffHunk": "@@ -0,0 +1,472 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"A connector for sending API requests to the GCP Recommendations AI API (https://cloud.google.com/recommendations).\"\"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNDk3NQ=="}, "originalCommit": {"oid": "fc710779af4135aedb2cb976dd4a4f0eec60e0ee"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NTgyNzMwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNjo1NzoxMFrOIL9rIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMzozNDo1N1rOIQAY_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNTcxNA==", "bodyText": "can you add types to the code instead of the comments?", "url": "https://github.com/apache/beam/pull/13617#discussion_r549415714", "createdAt": "2020-12-28T16:57:10Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "diffHunk": "@@ -0,0 +1,472 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"A connector for sending API requests to the GCP Recommendations AI API (https://cloud.google.com/recommendations).\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import itertools\n+from cachetools.func import ttl_cache\n+from google.protobuf.json_format import MessageToDict\n+from typing import Any, Dict, Iterable, List, Tuple, Union\n+\n+from apache_beam import TimeDomain, typehints, pvalue\n+from apache_beam.coders.coders import (IterableCoder, ProtoCoder, StrUtf8Coder, TupleCoder, MapCoder, PickleCoder)\n+from apache_beam.metrics import Metrics\n+from apache_beam.options.pipeline_options import GoogleCloudOptions\n+from apache_beam.transforms import DoFn, ParDo, PTransform\n+from apache_beam.transforms.userstate import BagStateSpec, TimerSpec, on_timer\n+\n+try:\n+    from google.cloud import recommendationengine\n+except ImportError:\n+    raise ImportError('Google Cloud Recommendation AI not supported for this execution '\n+                      'environment (could not import google.cloud.recommendationengine).')\n+\n+__all__ = ['CreateCatalogItem', 'WriteUserEvent', 'ImportCatalogItems', 'ImportUserEvents', 'PredictUserEvent']\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_prediction_client():\n+    \"\"\"Returns a Recommendation AI - Prediction Service client.\"\"\"\n+    _client = recommendationengine.PredictionServiceClient()\n+    return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_catalog_client():\n+    \"\"\"Returns a Recommendation AI - Catalog Service client.\"\"\"\n+    _client = recommendationengine.CatalogServiceClient()\n+    return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_user_event_client():\n+    \"\"\"Returns a Recommendation AI - UserEvent Service client.\"\"\"\n+    _client = recommendationengine.UserEventServiceClient()\n+    return _client\n+\n+\n+class CreateCatalogItem(PTransform):\n+    \"\"\"Creates catalogitem information.\n+    The ``PTranform`` returns a PCollectionTuple with a PCollections of successfully and failed created CatalogItems.\n+    \n+    Example usage: \n+    pipeline | CreateCatalogItem(project='example-gcp-project', catalog_name='my-catalog')\n+    \"\"\"\n+\n+    def __init__(self, project=None, retry=None, timeout=120, metadata=None, catalog_name=\"default_catalog\"):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc710779af4135aedb2cb976dd4a4f0eec60e0ee"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNTc5OA==", "bodyText": "(i mean python type hints :))", "url": "https://github.com/apache/beam/pull/13617#discussion_r549415798", "createdAt": "2020-12-28T16:57:28Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "diffHunk": "@@ -0,0 +1,472 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"A connector for sending API requests to the GCP Recommendations AI API (https://cloud.google.com/recommendations).\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import itertools\n+from cachetools.func import ttl_cache\n+from google.protobuf.json_format import MessageToDict\n+from typing import Any, Dict, Iterable, List, Tuple, Union\n+\n+from apache_beam import TimeDomain, typehints, pvalue\n+from apache_beam.coders.coders import (IterableCoder, ProtoCoder, StrUtf8Coder, TupleCoder, MapCoder, PickleCoder)\n+from apache_beam.metrics import Metrics\n+from apache_beam.options.pipeline_options import GoogleCloudOptions\n+from apache_beam.transforms import DoFn, ParDo, PTransform\n+from apache_beam.transforms.userstate import BagStateSpec, TimerSpec, on_timer\n+\n+try:\n+    from google.cloud import recommendationengine\n+except ImportError:\n+    raise ImportError('Google Cloud Recommendation AI not supported for this execution '\n+                      'environment (could not import google.cloud.recommendationengine).')\n+\n+__all__ = ['CreateCatalogItem', 'WriteUserEvent', 'ImportCatalogItems', 'ImportUserEvents', 'PredictUserEvent']\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_prediction_client():\n+    \"\"\"Returns a Recommendation AI - Prediction Service client.\"\"\"\n+    _client = recommendationengine.PredictionServiceClient()\n+    return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_catalog_client():\n+    \"\"\"Returns a Recommendation AI - Catalog Service client.\"\"\"\n+    _client = recommendationengine.CatalogServiceClient()\n+    return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_user_event_client():\n+    \"\"\"Returns a Recommendation AI - UserEvent Service client.\"\"\"\n+    _client = recommendationengine.UserEventServiceClient()\n+    return _client\n+\n+\n+class CreateCatalogItem(PTransform):\n+    \"\"\"Creates catalogitem information.\n+    The ``PTranform`` returns a PCollectionTuple with a PCollections of successfully and failed created CatalogItems.\n+    \n+    Example usage: \n+    pipeline | CreateCatalogItem(project='example-gcp-project', catalog_name='my-catalog')\n+    \"\"\"\n+\n+    def __init__(self, project=None, retry=None, timeout=120, metadata=None, catalog_name=\"default_catalog\"):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNTcxNA=="}, "originalCommit": {"oid": "fc710779af4135aedb2cb976dd4a4f0eec60e0ee"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY1NDUyNQ==", "bodyText": "Of course! Shall I leave the comments as well or would you suggest deleting them?", "url": "https://github.com/apache/beam/pull/13617#discussion_r553654525", "createdAt": "2021-01-07T23:34:57Z", "author": {"login": "matthiasa4"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "diffHunk": "@@ -0,0 +1,472 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"A connector for sending API requests to the GCP Recommendations AI API (https://cloud.google.com/recommendations).\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import itertools\n+from cachetools.func import ttl_cache\n+from google.protobuf.json_format import MessageToDict\n+from typing import Any, Dict, Iterable, List, Tuple, Union\n+\n+from apache_beam import TimeDomain, typehints, pvalue\n+from apache_beam.coders.coders import (IterableCoder, ProtoCoder, StrUtf8Coder, TupleCoder, MapCoder, PickleCoder)\n+from apache_beam.metrics import Metrics\n+from apache_beam.options.pipeline_options import GoogleCloudOptions\n+from apache_beam.transforms import DoFn, ParDo, PTransform\n+from apache_beam.transforms.userstate import BagStateSpec, TimerSpec, on_timer\n+\n+try:\n+    from google.cloud import recommendationengine\n+except ImportError:\n+    raise ImportError('Google Cloud Recommendation AI not supported for this execution '\n+                      'environment (could not import google.cloud.recommendationengine).')\n+\n+__all__ = ['CreateCatalogItem', 'WriteUserEvent', 'ImportCatalogItems', 'ImportUserEvents', 'PredictUserEvent']\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_prediction_client():\n+    \"\"\"Returns a Recommendation AI - Prediction Service client.\"\"\"\n+    _client = recommendationengine.PredictionServiceClient()\n+    return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_catalog_client():\n+    \"\"\"Returns a Recommendation AI - Catalog Service client.\"\"\"\n+    _client = recommendationengine.CatalogServiceClient()\n+    return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_user_event_client():\n+    \"\"\"Returns a Recommendation AI - UserEvent Service client.\"\"\"\n+    _client = recommendationengine.UserEventServiceClient()\n+    return _client\n+\n+\n+class CreateCatalogItem(PTransform):\n+    \"\"\"Creates catalogitem information.\n+    The ``PTranform`` returns a PCollectionTuple with a PCollections of successfully and failed created CatalogItems.\n+    \n+    Example usage: \n+    pipeline | CreateCatalogItem(project='example-gcp-project', catalog_name='my-catalog')\n+    \"\"\"\n+\n+    def __init__(self, project=None, retry=None, timeout=120, metadata=None, catalog_name=\"default_catalog\"):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxNTcxNA=="}, "originalCommit": {"oid": "fc710779af4135aedb2cb976dd4a4f0eec60e0ee"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwMDkzMDIwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai_test.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQyMDo1NjoxNVrOISU-8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQyMDo1NjoxNVrOISU-8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA4OTA3Mw==", "bodyText": "Avoid raising this ImportError here - when recommendationengine is None, this test will not run. This should fix the import errors on the tests.", "url": "https://github.com/apache/beam/pull/13617#discussion_r556089073", "createdAt": "2021-01-12T20:56:15Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai_test.py", "diffHunk": "@@ -0,0 +1,208 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for Recommendations AI transforms.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import mock\n+import unittest\n+\n+import apache_beam as beam\n+from apache_beam.metrics import MetricsFilter\n+\n+try:\n+  from google.cloud import recommendationengine\n+\n+  from apache_beam.ml.gcp import recommendations_ai\n+except ImportError:\n+  recommendationengine = None\n+  raise ImportError(\n+      'Google Cloud Recommendation AI not supported for this execution '\n+      'environment (could not import google.cloud.recommendationengine).')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41c202b1b6664ef38caaab91513ef45ce3902872"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwMDkzMTI0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai_test_it.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQyMDo1NjozMVrOISU_jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQyMDo1NjozMVrOISU_jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA4OTIyOA==", "bodyText": "Same, avoid raising the importerror", "url": "https://github.com/apache/beam/pull/13617#discussion_r556089228", "createdAt": "2021-01-12T20:56:31Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai_test_it.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Integration tests for Recommendations AI transforms.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import random\n+import unittest\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that, equal_to, is_not_empty, matches_all\n+\n+try:\n+  from google.cloud import recommendationengine\n+\n+  from apache_beam.ml.gcp import recommendations_ai\n+except ImportError:\n+  recommendationengine = None\n+  raise ImportError(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41c202b1b6664ef38caaab91513ef45ce3902872"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgzMDI1Njc5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQyMjo1MDozN1rOJB6hhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQyMjo1MDozN1rOJB6hhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTk4NzIwNw==", "bodyText": "Like in Java, Python also has a GroupIntoBatches transform that also has autosharding:\n\nhttps://beam.apache.org/documentation/transforms/python/aggregation/groupintobatches/\nhttps://beam.apache.org/releases/pydoc/current/apache_beam.transforms.util.html#apache_beam.transforms.util.GroupIntoBatches", "url": "https://github.com/apache/beam/pull/13617#discussion_r605987207", "createdAt": "2021-04-01T22:50:37Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "diffHunk": "@@ -0,0 +1,638 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"A connector for sending API requests to the GCP Recommendations AI\n+API (https://cloud.google.com/recommendations).\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import itertools\n+from typing import Sequence\n+from typing import Tuple\n+\n+from google.api_core.retry import Retry\n+\n+from apache_beam import TimeDomain\n+from apache_beam import pvalue\n+from apache_beam.coders.coders import IterableCoder\n+from apache_beam.coders.coders import PickleCoder\n+from apache_beam.metrics import Metrics\n+from apache_beam.options.pipeline_options import GoogleCloudOptions\n+from apache_beam.transforms import DoFn\n+from apache_beam.transforms import ParDo\n+from apache_beam.transforms import PTransform\n+from apache_beam.transforms.userstate import BagStateSpec\n+from apache_beam.transforms.userstate import TimerSpec\n+from apache_beam.transforms.userstate import on_timer\n+from cachetools.func import ttl_cache\n+\n+# pylint: disable=wrong-import-order, wrong-import-position, ungrouped-imports\n+try:\n+  from google.cloud import recommendationengine\n+except ImportError:\n+  raise ImportError(\n+      'Google Cloud Recommendation AI not supported for this execution '\n+      'environment (could not import google.cloud.recommendationengine).')\n+# pylint: enable=wrong-import-order, wrong-import-position, ungrouped-imports\n+\n+__all__ = [\n+    'CreateCatalogItem',\n+    'WriteUserEvent',\n+    'ImportCatalogItems',\n+    'ImportUserEvents',\n+    'PredictUserEvent'\n+]\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_prediction_client():\n+  \"\"\"Returns a Recommendation AI - Prediction Service client.\"\"\"\n+  _client = recommendationengine.PredictionServiceClient()\n+  return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_catalog_client():\n+  \"\"\"Returns a Recommendation AI - Catalog Service client.\"\"\"\n+  _client = recommendationengine.CatalogServiceClient()\n+  return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_user_event_client():\n+  \"\"\"Returns a Recommendation AI - UserEvent Service client.\"\"\"\n+  _client = recommendationengine.UserEventServiceClient()\n+  return _client\n+\n+\n+class CreateCatalogItem(PTransform):\n+  \"\"\"Creates catalogitem information.\n+    The ``PTranform`` returns a PCollectionTuple with a PCollections of\n+    successfully and failed created CatalogItems.\n+\n+    Example usage:\n+    pipeline | CreateCatalogItem(project='example-gcp-project',\n+      catalog_name='my-catalog')\n+    \"\"\"\n+  def __init__(\n+      self,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = \"default_catalog\"):\n+    \"\"\"Initializes a :class:`CreateCatalogItem` transform.\n+\n+        Args:\n+            project (str): Optional. GCP project name in which the catalog\n+              data will be imported.\n+            retry (google.api_core.retry.Retry): Optional. Designation of what\n+              errors, if any, should be retried.\n+            timeout (float): Optional. The amount of time, in seconds, to wait\n+              for the request to complete.\n+            metadata (Sequence[Tuple[str, str]]): Optional. Strings which\n+              should be sent along with the request as metadata.\n+            catalog_name (str): Optional. Name of the catalog.\n+              Default: 'default_catalog'\n+        \"\"\"\n+    self.project = project\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.catalog_name = catalog_name\n+\n+  def expand(self, pcoll):\n+    if self.project is None:\n+      self.project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    if self.project is None:\n+      raise ValueError(\n+          \"\"\"GCP project name needs to be specified in \"project\" pipeline\n+            option\"\"\")\n+    return pcoll | ParDo(\n+        _CreateCatalogItemFn(\n+            self.project,\n+            self.retry,\n+            self.timeout,\n+            self.metadata,\n+            self.catalog_name))\n+\n+\n+class _CreateCatalogItemFn(DoFn):\n+  FAILED_CATALOG_ITEMS = \"failed_catalog_items\"\n+\n+  def __init__(\n+      self,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = None):\n+    self._client = None\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.parent = f\"projects/{project}/locations/global/catalogs/{catalog_name}\"\n+    self.counter = Metrics.counter(self.__class__, \"api_calls\")\n+\n+  def setup(self):\n+    if self._client is None:\n+      self._client = get_recommendation_catalog_client()\n+\n+  def process(self, element):\n+    catalog_item = recommendationengine.CatalogItem(element)\n+    request = recommendationengine.CreateCatalogItemRequest(\n+        parent=self.parent, catalog_item=catalog_item)\n+\n+    try:\n+      created_catalog_item = self._client.create_catalog_item(\n+          request=request,\n+          retry=self.retry,\n+          timeout=self.timeout,\n+          metadata=self.metadata)\n+\n+      self.counter.inc()\n+      yield recommendationengine.CatalogItem.to_dict(created_catalog_item)\n+    except Exception:\n+      yield pvalue.TaggedOutput(\n+          self.FAILED_CATALOG_ITEMS,\n+          recommendationengine.CatalogItem.to_dict(catalog_item))\n+\n+\n+class _BatchItems(DoFn):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c6e9c280780a15c6a53394a07ed15f69d7d5423"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkxOTk1MjkwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxNjozOToyM1rOJOqjjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxNjozOToyM1rOJOqjjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTM1NzA2OQ==", "bodyText": "consider using autosharding or sharded key", "url": "https://github.com/apache/beam/pull/13617#discussion_r619357069", "createdAt": "2021-04-23T16:39:23Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "diffHunk": "@@ -0,0 +1,587 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"A connector for sending API requests to the GCP Recommendations AI\n+API (https://cloud.google.com/recommendations).\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Sequence\n+from typing import Tuple\n+\n+from google.api_core.retry import Retry\n+\n+from apache_beam import pvalue\n+from apache_beam.metrics import Metrics\n+from apache_beam.options.pipeline_options import GoogleCloudOptions\n+from apache_beam.transforms import DoFn\n+from apache_beam.transforms import ParDo\n+from apache_beam.transforms import PTransform\n+from apache_beam.transforms.util import GroupIntoBatches\n+from cachetools.func import ttl_cache\n+\n+# pylint: disable=wrong-import-order, wrong-import-position, ungrouped-imports\n+try:\n+  from google.cloud import recommendationengine\n+except ImportError:\n+  raise ImportError(\n+      'Google Cloud Recommendation AI not supported for this execution '\n+      'environment (could not import google.cloud.recommendationengine).')\n+# pylint: enable=wrong-import-order, wrong-import-position, ungrouped-imports\n+\n+__all__ = [\n+    'CreateCatalogItem',\n+    'WriteUserEvent',\n+    'ImportCatalogItems',\n+    'ImportUserEvents',\n+    'PredictUserEvent'\n+]\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_prediction_client():\n+  \"\"\"Returns a Recommendation AI - Prediction Service client.\"\"\"\n+  _client = recommendationengine.PredictionServiceClient()\n+  return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_catalog_client():\n+  \"\"\"Returns a Recommendation AI - Catalog Service client.\"\"\"\n+  _client = recommendationengine.CatalogServiceClient()\n+  return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_user_event_client():\n+  \"\"\"Returns a Recommendation AI - UserEvent Service client.\"\"\"\n+  _client = recommendationengine.UserEventServiceClient()\n+  return _client\n+\n+\n+class CreateCatalogItem(PTransform):\n+  \"\"\"Creates catalogitem information.\n+    The ``PTranform`` returns a PCollectionTuple with a PCollections of\n+    successfully and failed created CatalogItems.\n+\n+    Example usage::\n+\n+      pipeline | CreateCatalogItem(\n+        project='example-gcp-project',\n+        catalog_name='my-catalog')\n+    \"\"\"\n+  def __init__(\n+      self,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = \"default_catalog\"):\n+    \"\"\"Initializes a :class:`CreateCatalogItem` transform.\n+\n+        Args:\n+            project (str): Optional. GCP project name in which the catalog\n+              data will be imported.\n+            retry (google.api_core.retry.Retry): Optional. Designation of what\n+              errors, if any, should be retried.\n+            timeout (float): Optional. The amount of time, in seconds, to wait\n+              for the request to complete.\n+            metadata (Sequence[Tuple[str, str]]): Optional. Strings which\n+              should be sent along with the request as metadata.\n+            catalog_name (str): Optional. Name of the catalog.\n+              Default: 'default_catalog'\n+        \"\"\"\n+    self.project = project\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.catalog_name = catalog_name\n+\n+  def expand(self, pcoll):\n+    if self.project is None:\n+      self.project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    if self.project is None:\n+      raise ValueError(\n+          \"\"\"GCP project name needs to be specified in \"project\" pipeline\n+            option\"\"\")\n+    return pcoll | ParDo(\n+        _CreateCatalogItemFn(\n+            self.project,\n+            self.retry,\n+            self.timeout,\n+            self.metadata,\n+            self.catalog_name))\n+\n+\n+class _CreateCatalogItemFn(DoFn):\n+  FAILED_CATALOG_ITEMS = \"failed_catalog_items\"\n+\n+  def __init__(\n+      self,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = None):\n+    self._client = None\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.parent = f\"projects/{project}/locations/global/catalogs/{catalog_name}\"\n+    self.counter = Metrics.counter(self.__class__, \"api_calls\")\n+\n+  def setup(self):\n+    if self._client is None:\n+      self._client = get_recommendation_catalog_client()\n+\n+  def process(self, element):\n+    catalog_item = recommendationengine.CatalogItem(element)\n+    request = recommendationengine.CreateCatalogItemRequest(\n+        parent=self.parent, catalog_item=catalog_item)\n+\n+    try:\n+      created_catalog_item = self._client.create_catalog_item(\n+          request=request,\n+          retry=self.retry,\n+          timeout=self.timeout,\n+          metadata=self.metadata)\n+\n+      self.counter.inc()\n+      yield recommendationengine.CatalogItem.to_dict(created_catalog_item)\n+    except Exception:\n+      yield pvalue.TaggedOutput(\n+          self.FAILED_CATALOG_ITEMS,\n+          recommendationengine.CatalogItem.to_dict(catalog_item))\n+\n+\n+class ImportCatalogItems(PTransform):\n+  \"\"\"Imports catalogitems in bulk.\n+    The `PTransform` returns a PCollectionTuple with PCollections of\n+    successfully and failed imported CatalogItems.\n+\n+    Example usage::\n+\n+      pipeline\n+      | ImportCatalogItems(\n+          project='example-gcp-project',\n+          catalog_name='my-catalog')\n+    \"\"\"\n+  def __init__(\n+      self,\n+      max_batch_size: int = 5000,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = \"default_catalog\"):\n+    \"\"\"Initializes a :class:`ImportCatalogItem` transform\n+\n+        Args:\n+            batch_size (int): Required. Maximum number of catalogitems per\n+              request.\n+            project (str): Optional. GCP project name in which the catalog\n+              data will be imported.\n+            retry (google.api_core.retry.Retry): Optional. Designation of what\n+              errors, if any, should be retried.\n+            timeout (float): Optional. The amount of time, in seconds, to wait\n+            for the request to complete.\n+            metadata (Sequence[Tuple[str, str]]): Optional. Strings which\n+              should be sent along with the request as metadata.\n+            catalog_name (str): Optional. Name of the catalog.\n+              Default: 'default_catalog'\n+        \"\"\"\n+    self.max_batch_size = max_batch_size\n+    self.project = project\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.catalog_name = catalog_name\n+\n+  def expand(self, pcoll):\n+    if self.project is None:\n+      self.project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    if self.project is None:\n+      raise ValueError(\n+          'GCP project name needs to be specified in \"project\" pipeline option')\n+    return (\n+        pcoll | GroupIntoBatches(self.max_batch_size) | ParDo(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f45d0417ab3c0d4d49f23789fc44c3b2eb858a6"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkxOTk1NjAwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxNjo0MDoyMVrOJOqlig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxNjo0MDoyMVrOJOqlig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTM1NzU3OA==", "bodyText": "make this part of a public class", "url": "https://github.com/apache/beam/pull/13617#discussion_r619357578", "createdAt": "2021-04-23T16:40:21Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "diffHunk": "@@ -0,0 +1,587 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"A connector for sending API requests to the GCP Recommendations AI\n+API (https://cloud.google.com/recommendations).\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Sequence\n+from typing import Tuple\n+\n+from google.api_core.retry import Retry\n+\n+from apache_beam import pvalue\n+from apache_beam.metrics import Metrics\n+from apache_beam.options.pipeline_options import GoogleCloudOptions\n+from apache_beam.transforms import DoFn\n+from apache_beam.transforms import ParDo\n+from apache_beam.transforms import PTransform\n+from apache_beam.transforms.util import GroupIntoBatches\n+from cachetools.func import ttl_cache\n+\n+# pylint: disable=wrong-import-order, wrong-import-position, ungrouped-imports\n+try:\n+  from google.cloud import recommendationengine\n+except ImportError:\n+  raise ImportError(\n+      'Google Cloud Recommendation AI not supported for this execution '\n+      'environment (could not import google.cloud.recommendationengine).')\n+# pylint: enable=wrong-import-order, wrong-import-position, ungrouped-imports\n+\n+__all__ = [\n+    'CreateCatalogItem',\n+    'WriteUserEvent',\n+    'ImportCatalogItems',\n+    'ImportUserEvents',\n+    'PredictUserEvent'\n+]\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_prediction_client():\n+  \"\"\"Returns a Recommendation AI - Prediction Service client.\"\"\"\n+  _client = recommendationengine.PredictionServiceClient()\n+  return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_catalog_client():\n+  \"\"\"Returns a Recommendation AI - Catalog Service client.\"\"\"\n+  _client = recommendationengine.CatalogServiceClient()\n+  return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_user_event_client():\n+  \"\"\"Returns a Recommendation AI - UserEvent Service client.\"\"\"\n+  _client = recommendationengine.UserEventServiceClient()\n+  return _client\n+\n+\n+class CreateCatalogItem(PTransform):\n+  \"\"\"Creates catalogitem information.\n+    The ``PTranform`` returns a PCollectionTuple with a PCollections of\n+    successfully and failed created CatalogItems.\n+\n+    Example usage::\n+\n+      pipeline | CreateCatalogItem(\n+        project='example-gcp-project',\n+        catalog_name='my-catalog')\n+    \"\"\"\n+  def __init__(\n+      self,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = \"default_catalog\"):\n+    \"\"\"Initializes a :class:`CreateCatalogItem` transform.\n+\n+        Args:\n+            project (str): Optional. GCP project name in which the catalog\n+              data will be imported.\n+            retry (google.api_core.retry.Retry): Optional. Designation of what\n+              errors, if any, should be retried.\n+            timeout (float): Optional. The amount of time, in seconds, to wait\n+              for the request to complete.\n+            metadata (Sequence[Tuple[str, str]]): Optional. Strings which\n+              should be sent along with the request as metadata.\n+            catalog_name (str): Optional. Name of the catalog.\n+              Default: 'default_catalog'\n+        \"\"\"\n+    self.project = project\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.catalog_name = catalog_name\n+\n+  def expand(self, pcoll):\n+    if self.project is None:\n+      self.project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    if self.project is None:\n+      raise ValueError(\n+          \"\"\"GCP project name needs to be specified in \"project\" pipeline\n+            option\"\"\")\n+    return pcoll | ParDo(\n+        _CreateCatalogItemFn(\n+            self.project,\n+            self.retry,\n+            self.timeout,\n+            self.metadata,\n+            self.catalog_name))\n+\n+\n+class _CreateCatalogItemFn(DoFn):\n+  FAILED_CATALOG_ITEMS = \"failed_catalog_items\"\n+\n+  def __init__(\n+      self,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = None):\n+    self._client = None\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.parent = f\"projects/{project}/locations/global/catalogs/{catalog_name}\"\n+    self.counter = Metrics.counter(self.__class__, \"api_calls\")\n+\n+  def setup(self):\n+    if self._client is None:\n+      self._client = get_recommendation_catalog_client()\n+\n+  def process(self, element):\n+    catalog_item = recommendationengine.CatalogItem(element)\n+    request = recommendationengine.CreateCatalogItemRequest(\n+        parent=self.parent, catalog_item=catalog_item)\n+\n+    try:\n+      created_catalog_item = self._client.create_catalog_item(\n+          request=request,\n+          retry=self.retry,\n+          timeout=self.timeout,\n+          metadata=self.metadata)\n+\n+      self.counter.inc()\n+      yield recommendationengine.CatalogItem.to_dict(created_catalog_item)\n+    except Exception:\n+      yield pvalue.TaggedOutput(\n+          self.FAILED_CATALOG_ITEMS,\n+          recommendationengine.CatalogItem.to_dict(catalog_item))\n+\n+\n+class ImportCatalogItems(PTransform):\n+  \"\"\"Imports catalogitems in bulk.\n+    The `PTransform` returns a PCollectionTuple with PCollections of\n+    successfully and failed imported CatalogItems.\n+\n+    Example usage::\n+\n+      pipeline\n+      | ImportCatalogItems(\n+          project='example-gcp-project',\n+          catalog_name='my-catalog')\n+    \"\"\"\n+  def __init__(\n+      self,\n+      max_batch_size: int = 5000,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = \"default_catalog\"):\n+    \"\"\"Initializes a :class:`ImportCatalogItem` transform\n+\n+        Args:\n+            batch_size (int): Required. Maximum number of catalogitems per\n+              request.\n+            project (str): Optional. GCP project name in which the catalog\n+              data will be imported.\n+            retry (google.api_core.retry.Retry): Optional. Designation of what\n+              errors, if any, should be retried.\n+            timeout (float): Optional. The amount of time, in seconds, to wait\n+            for the request to complete.\n+            metadata (Sequence[Tuple[str, str]]): Optional. Strings which\n+              should be sent along with the request as metadata.\n+            catalog_name (str): Optional. Name of the catalog.\n+              Default: 'default_catalog'\n+        \"\"\"\n+    self.max_batch_size = max_batch_size\n+    self.project = project\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.catalog_name = catalog_name\n+\n+  def expand(self, pcoll):\n+    if self.project is None:\n+      self.project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    if self.project is None:\n+      raise ValueError(\n+          'GCP project name needs to be specified in \"project\" pipeline option')\n+    return (\n+        pcoll | GroupIntoBatches(self.max_batch_size) | ParDo(\n+            _ImportCatalogItemsFn(\n+                self.project,\n+                self.retry,\n+                self.timeout,\n+                self.metadata,\n+                self.catalog_name)))\n+\n+\n+class _ImportCatalogItemsFn(DoFn):\n+  FAILED_CATALOG_ITEMS = \"failed_catalog_items\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f45d0417ab3c0d4d49f23789fc44c3b2eb858a6"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkxOTk1ODgxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxNjo0MTowOFrOJOqnTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxNjo0MTowOFrOJOqnTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTM1ODAzMA==", "bodyText": "make part of public class, or part of the module", "url": "https://github.com/apache/beam/pull/13617#discussion_r619358030", "createdAt": "2021-04-23T16:41:08Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/ml/gcp/recommendations_ai.py", "diffHunk": "@@ -0,0 +1,587 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"A connector for sending API requests to the GCP Recommendations AI\n+API (https://cloud.google.com/recommendations).\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Sequence\n+from typing import Tuple\n+\n+from google.api_core.retry import Retry\n+\n+from apache_beam import pvalue\n+from apache_beam.metrics import Metrics\n+from apache_beam.options.pipeline_options import GoogleCloudOptions\n+from apache_beam.transforms import DoFn\n+from apache_beam.transforms import ParDo\n+from apache_beam.transforms import PTransform\n+from apache_beam.transforms.util import GroupIntoBatches\n+from cachetools.func import ttl_cache\n+\n+# pylint: disable=wrong-import-order, wrong-import-position, ungrouped-imports\n+try:\n+  from google.cloud import recommendationengine\n+except ImportError:\n+  raise ImportError(\n+      'Google Cloud Recommendation AI not supported for this execution '\n+      'environment (could not import google.cloud.recommendationengine).')\n+# pylint: enable=wrong-import-order, wrong-import-position, ungrouped-imports\n+\n+__all__ = [\n+    'CreateCatalogItem',\n+    'WriteUserEvent',\n+    'ImportCatalogItems',\n+    'ImportUserEvents',\n+    'PredictUserEvent'\n+]\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_prediction_client():\n+  \"\"\"Returns a Recommendation AI - Prediction Service client.\"\"\"\n+  _client = recommendationengine.PredictionServiceClient()\n+  return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_catalog_client():\n+  \"\"\"Returns a Recommendation AI - Catalog Service client.\"\"\"\n+  _client = recommendationengine.CatalogServiceClient()\n+  return _client\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_recommendation_user_event_client():\n+  \"\"\"Returns a Recommendation AI - UserEvent Service client.\"\"\"\n+  _client = recommendationengine.UserEventServiceClient()\n+  return _client\n+\n+\n+class CreateCatalogItem(PTransform):\n+  \"\"\"Creates catalogitem information.\n+    The ``PTranform`` returns a PCollectionTuple with a PCollections of\n+    successfully and failed created CatalogItems.\n+\n+    Example usage::\n+\n+      pipeline | CreateCatalogItem(\n+        project='example-gcp-project',\n+        catalog_name='my-catalog')\n+    \"\"\"\n+  def __init__(\n+      self,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = \"default_catalog\"):\n+    \"\"\"Initializes a :class:`CreateCatalogItem` transform.\n+\n+        Args:\n+            project (str): Optional. GCP project name in which the catalog\n+              data will be imported.\n+            retry (google.api_core.retry.Retry): Optional. Designation of what\n+              errors, if any, should be retried.\n+            timeout (float): Optional. The amount of time, in seconds, to wait\n+              for the request to complete.\n+            metadata (Sequence[Tuple[str, str]]): Optional. Strings which\n+              should be sent along with the request as metadata.\n+            catalog_name (str): Optional. Name of the catalog.\n+              Default: 'default_catalog'\n+        \"\"\"\n+    self.project = project\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.catalog_name = catalog_name\n+\n+  def expand(self, pcoll):\n+    if self.project is None:\n+      self.project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    if self.project is None:\n+      raise ValueError(\n+          \"\"\"GCP project name needs to be specified in \"project\" pipeline\n+            option\"\"\")\n+    return pcoll | ParDo(\n+        _CreateCatalogItemFn(\n+            self.project,\n+            self.retry,\n+            self.timeout,\n+            self.metadata,\n+            self.catalog_name))\n+\n+\n+class _CreateCatalogItemFn(DoFn):\n+  FAILED_CATALOG_ITEMS = \"failed_catalog_items\"\n+\n+  def __init__(\n+      self,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = None):\n+    self._client = None\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.parent = f\"projects/{project}/locations/global/catalogs/{catalog_name}\"\n+    self.counter = Metrics.counter(self.__class__, \"api_calls\")\n+\n+  def setup(self):\n+    if self._client is None:\n+      self._client = get_recommendation_catalog_client()\n+\n+  def process(self, element):\n+    catalog_item = recommendationengine.CatalogItem(element)\n+    request = recommendationengine.CreateCatalogItemRequest(\n+        parent=self.parent, catalog_item=catalog_item)\n+\n+    try:\n+      created_catalog_item = self._client.create_catalog_item(\n+          request=request,\n+          retry=self.retry,\n+          timeout=self.timeout,\n+          metadata=self.metadata)\n+\n+      self.counter.inc()\n+      yield recommendationengine.CatalogItem.to_dict(created_catalog_item)\n+    except Exception:\n+      yield pvalue.TaggedOutput(\n+          self.FAILED_CATALOG_ITEMS,\n+          recommendationengine.CatalogItem.to_dict(catalog_item))\n+\n+\n+class ImportCatalogItems(PTransform):\n+  \"\"\"Imports catalogitems in bulk.\n+    The `PTransform` returns a PCollectionTuple with PCollections of\n+    successfully and failed imported CatalogItems.\n+\n+    Example usage::\n+\n+      pipeline\n+      | ImportCatalogItems(\n+          project='example-gcp-project',\n+          catalog_name='my-catalog')\n+    \"\"\"\n+  def __init__(\n+      self,\n+      max_batch_size: int = 5000,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = \"default_catalog\"):\n+    \"\"\"Initializes a :class:`ImportCatalogItem` transform\n+\n+        Args:\n+            batch_size (int): Required. Maximum number of catalogitems per\n+              request.\n+            project (str): Optional. GCP project name in which the catalog\n+              data will be imported.\n+            retry (google.api_core.retry.Retry): Optional. Designation of what\n+              errors, if any, should be retried.\n+            timeout (float): Optional. The amount of time, in seconds, to wait\n+            for the request to complete.\n+            metadata (Sequence[Tuple[str, str]]): Optional. Strings which\n+              should be sent along with the request as metadata.\n+            catalog_name (str): Optional. Name of the catalog.\n+              Default: 'default_catalog'\n+        \"\"\"\n+    self.max_batch_size = max_batch_size\n+    self.project = project\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.catalog_name = catalog_name\n+\n+  def expand(self, pcoll):\n+    if self.project is None:\n+      self.project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    if self.project is None:\n+      raise ValueError(\n+          'GCP project name needs to be specified in \"project\" pipeline option')\n+    return (\n+        pcoll | GroupIntoBatches(self.max_batch_size) | ParDo(\n+            _ImportCatalogItemsFn(\n+                self.project,\n+                self.retry,\n+                self.timeout,\n+                self.metadata,\n+                self.catalog_name)))\n+\n+\n+class _ImportCatalogItemsFn(DoFn):\n+  FAILED_CATALOG_ITEMS = \"failed_catalog_items\"\n+\n+  def __init__(\n+      self,\n+      project=None,\n+      retry=None,\n+      timeout=120,\n+      metadata=None,\n+      catalog_name=None):\n+    self._client = None\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.parent = f\"projects/{project}/locations/global/catalogs/{catalog_name}\"\n+    self.counter = Metrics.counter(self.__class__, \"api_calls\")\n+\n+  def setup(self):\n+    if self._client is None:\n+      self.client = get_recommendation_catalog_client()\n+\n+  def process(self, element):\n+    catalog_items = [recommendationengine.CatalogItem(e) for e in element[1]]\n+    catalog_inline_source = recommendationengine.CatalogInlineSource(\n+        {\"catalog_items\": catalog_items})\n+    input_config = recommendationengine.InputConfig(\n+        catalog_inline_source=catalog_inline_source)\n+\n+    request = recommendationengine.ImportCatalogItemsRequest(\n+        parent=self.parent, input_config=input_config)\n+\n+    try:\n+      operation = self._client.import_catalog_items(\n+          request=request,\n+          retry=self.retry,\n+          timeout=self.timeout,\n+          metadata=self.metadata)\n+      self.counter.inc(len(catalog_items))\n+      yield operation.result()\n+    except Exception:\n+      yield pvalue.TaggedOutput(self.FAILED_CATALOG_ITEMS, catalog_items)\n+\n+\n+class WriteUserEvent(PTransform):\n+  \"\"\"Write user event information.\n+    The `PTransform` returns a PCollectionTuple with PCollections of\n+    successfully and failed written UserEvents.\n+\n+    Example usage::\n+\n+      pipeline\n+      | WriteUserEvent(\n+          project='example-gcp-project',\n+          catalog_name='my-catalog',\n+          event_store='my_event_store')\n+    \"\"\"\n+  def __init__(\n+      self,\n+      project: str = None,\n+      retry: Retry = None,\n+      timeout: float = 120,\n+      metadata: Sequence[Tuple[str, str]] = None,\n+      catalog_name: str = \"default_catalog\",\n+      event_store: str = \"default_event_store\"):\n+    \"\"\"Initializes a :class:`WriteUserEvent` transform.\n+\n+        Args:\n+            project (str): Optional. GCP project name in which the catalog\n+              data will be imported.\n+            retry (google.api_core.retry.Retry): Optional. Designation of what\n+              errors, if any, should be retried.\n+            timeout (float): Optional. The amount of time, in seconds, to wait\n+              for the request to complete.\n+            metadata (Sequence[Tuple[str, str]]): Optional. Strings which\n+              should be sent along with the request as metadata.\n+            catalog_name (str): Optional. Name of the catalog.\n+              Default: 'default_catalog'\n+            event_store (str): Optional. Name of the event store.\n+              Default: 'default_event_store'\n+        \"\"\"\n+    self.project = project\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.metadata = metadata\n+    self.catalog_name = catalog_name\n+    self.event_store = event_store\n+\n+  def expand(self, pcoll):\n+    if self.project is None:\n+      self.project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    if self.project is None:\n+      raise ValueError(\n+          'GCP project name needs to be specified in \"project\" pipeline option')\n+    return pcoll | ParDo(\n+        _WriteUserEventFn(\n+            self.project,\n+            self.retry,\n+            self.timeout,\n+            self.metadata,\n+            self.catalog_name,\n+            self.event_store))\n+\n+\n+class _WriteUserEventFn(DoFn):\n+  FAILED_USER_EVENTS = \"failed_user_events\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f45d0417ab3c0d4d49f23789fc44c3b2eb858a6"}, "originalPosition": 335}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2456, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}