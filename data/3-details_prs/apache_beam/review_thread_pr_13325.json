{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwMjAxMzU5", "number": 13325, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzowMzoyN1rOE4ZJXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzo0OTo1N1rOE4aDQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTY3NzEwOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzowMzoyOFrOHySTXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNjoxNzowN1rOHzIx5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5MDcxNw==", "bodyText": "Please un-export all functions if they aren't required outside of the graphx package. Naturally, keep any existing doc comments. No reason to remove them just because the functions aren't exported.", "url": "https://github.com/apache/beam/pull/13325#discussion_r522490717", "createdAt": "2020-11-12T23:03:28Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "diffHunk": "@@ -16,11 +16,222 @@\n package graphx\n \n import (\n+\t\"fmt\"\n+\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n )\n \n+// MergeExpandedWithPipeline adds expanded components of all ExternalTransforms to the existing pipeline\n+func MergeExpandedWithPipeline(edges []*graph.MultiEdge, p *pipepb.Pipeline) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM4MzI2OA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/13325#discussion_r523383268", "createdAt": "2020-11-14T06:17:07Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "diffHunk": "@@ -16,11 +16,222 @@\n package graphx\n \n import (\n+\t\"fmt\"\n+\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n )\n \n+// MergeExpandedWithPipeline adds expanded components of all ExternalTransforms to the existing pipeline\n+func MergeExpandedWithPipeline(edges []*graph.MultiEdge, p *pipepb.Pipeline) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5MDcxNw=="}, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTcwNDY4OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzoxNDoyNlrOHySjkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNjoxNzoxMVrOHzIx6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NDg2Ng==", "bodyText": "Can this function be unexported now that callers were moved into graphx?", "url": "https://github.com/apache/beam/pull/13325#discussion_r522494866", "createdAt": "2020-11-12T23:14:26Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "diffHunk": "@@ -16,11 +16,222 @@\n package graphx\n \n import (\n+\t\"fmt\"\n+\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n )\n \n+// MergeExpandedWithPipeline adds expanded components of all ExternalTransforms to the existing pipeline\n+func MergeExpandedWithPipeline(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\t// Adding Expanded transforms to their counterparts in the Pipeline\n+\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\texp := e.External.Expanded\n+\t\t\tif exp == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tid := fmt.Sprintf(\"e%v\", e.ID())\n+\n+\t\t\tp.Requirements = append(p.Requirements, exp.Requirements...)\n+\n+\t\t\t// Adding components of the Expanded Transforms to the current Pipeline\n+\t\t\tcomponents, err := ExpandedComponents(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetTransforms() {\n+\t\t\t\tp.Components.Transforms[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetPcollections() {\n+\t\t\t\tp.Components.Pcollections[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetWindowingStrategies() {\n+\t\t\t\tp.Components.WindowingStrategies[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetCoders() {\n+\t\t\t\tp.Components.Coders[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetEnvironments() {\n+\t\t\t\tif k == \"go\" {\n+\t\t\t\t\t// This case is not an anomaly. It is expected to be always\n+\t\t\t\t\t// present. Any initial ExpansionRequest will have a\n+\t\t\t\t\t// component which requires the \"go\" environment. Scoping\n+\t\t\t\t\t// using unique namespace prevents collision.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tp.Components.Environments[k] = v\n+\t\t\t}\n+\n+\t\t\ttransform, err := ExpandedTransform(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tp.Components.Transforms[id] = transform\n+\t\t}\n+\t}\n+}\n+\n+// PurgeOutputInput remaps outputs from edge corresponding to an\n+// ExternalTransform with the correct expanded outputs. All consumers of the\n+// previous outputs are updated with new inputs.\n+func PurgeOutputInput(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\tidxMap := make(map[string]string)\n+\tcomponents := p.GetComponents()\n+\n+\t// Generating map (oldID -> newID) of outputs to be purged\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\tif e.External.Expanded == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor tag, n := range ExternalOutputs(e) {\n+\t\t\t\tnodeID := fmt.Sprintf(\"n%v\", n.ID())\n+\n+\t\t\t\ttransform, err := ExpandedTransform(e.External.Expanded)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tpanic(err)\n+\t\t\t\t}\n+\t\t\t\texpandedOutputs := transform.GetOutputs()\n+\t\t\t\tvar pcolID string\n+\t\t\t\tif tag == graph.UnnamedOutputTag {\n+\t\t\t\t\tfor _, pcolID = range expandedOutputs {\n+\t\t\t\t\t\t// easiest way to access map with one entry (key,value)\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tpcolID = expandedOutputs[tag]\n+\t\t\t\t}\n+\n+\t\t\t\tidxMap[nodeID] = pcolID\n+\t\t\t\tdelete(components.Pcollections, nodeID)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Updating all input ids to reflect the correct sources\n+\tfor _, t := range components.GetTransforms() {\n+\t\tinputs := t.GetInputs()\n+\t\tfor tag, nodeID := range inputs {\n+\t\t\tif pcolID, exists := idxMap[nodeID]; exists {\n+\t\t\t\tinputs[tag] = pcolID\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+}\n+\n+// VerifyNamedOutputs ensures the expanded outputs correspond to the correct and expected named outputs\n+func VerifyNamedOutputs(ext *graph.ExternalTransform) {\n+\ttransform, err := ExpandedTransform(ext.Expanded)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedOutputs := transform.GetOutputs()\n+\n+\tif len(expandedOutputs) != len(ext.OutputsMap) {\n+\t\tpanic(errors.Errorf(\"mismatched number of named outputs:\\nreceived - %v\\nexpected - %v\", len(expandedOutputs), len(ext.OutputsMap)))\n+\t}\n+\n+\tfor tag := range ext.OutputsMap {\n+\t\t_, exists := expandedOutputs[tag]\n+\t\tif tag != graph.UnnamedOutputTag && !exists {\n+\t\t\tpanic(errors.Errorf(\"missing named output in expanded transform: %v is expected in %v\", tag, expandedOutputs))\n+\t\t}\n+\t\tif tag == graph.UnnamedOutputTag && len(expandedOutputs) > 1 {\n+\t\t\tpanic(errors.Errorf(\"mismatched number of unnamed outputs:\\nreceived - %v\\nexpected - 1\", len(expandedOutputs)))\n+\t\t}\n+\t}\n+}\n+\n+// ResolveOutputIsBounded updates each Output node with respect to the received\n+// expanded components to reflect if it is bounded or not\n+func ResolveOutputIsBounded(e *graph.MultiEdge, isBoundedUpdater func(*graph.Node, bool)) {\n+\text := e.External\n+\texp := ext.Expanded\n+\tcomponents, err := ExpandedComponents(exp)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedPCollections := components.GetPcollections()\n+\ttransform, err := ExpandedTransform(exp)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedOutputs := transform.GetOutputs()\n+\n+\tfor tag, node := range ExternalOutputs(e) {\n+\t\tvar id string\n+\t\tisBounded := true\n+\n+\t\tswitch tag {\n+\t\tcase graph.UnnamedOutputTag:\n+\t\t\tfor _, id = range expandedOutputs {\n+\t\t\t\t// easiest way to access map with one entry (key,value)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tid = expandedOutputs[tag]\n+\t\t}\n+\n+\t\tif pcol, exists := expandedPCollections[id]; exists {\n+\t\t\tif pcol.GetIsBounded() == pipepb.IsBounded_UNBOUNDED {\n+\t\t\t\tisBounded = false\n+\t\t\t}\n+\t\t\tisBoundedUpdater(node, isBounded)\n+\t\t} else {\n+\t\t\tpanic(errors.Errorf(\"missing corresponsing pcollection of named output: %v is expected in %v\", id, expandedPCollections))\n+\t\t}\n+\n+\t}\n+}\n+\n+// AddFakeImpulses adds an impulse transform as the producer for each input to\n+// the root transform. Inputs need producers to form a correct pipeline.\n+func AddFakeImpulses(p *pipepb.Pipeline) {\n+\t// For a pipeline consisting of only the external node edge, there will be\n+\t// single root transform which will be the external transform.\n+\t// Adding fake impulses per input to this external transform\n+\ttransforms := p.GetComponents().GetTransforms()\n+\text := transforms[p.GetRootTransformIds()[0]]\n+\n+\tfor tag, id := range ext.GetInputs() {\n+\t\tkey := fmt.Sprintf(\"%s_%s\", \"impulse\", tag)\n+\t\toutput := map[string]string{\"out\": id}\n+\n+\t\timpulse := &pipepb.PTransform{\n+\t\t\tUniqueName: key,\n+\t\t\tSpec: &pipepb.FunctionSpec{\n+\t\t\t\tUrn: URNImpulse,\n+\t\t\t},\n+\t\t\tOutputs: output,\n+\t\t}\n+\n+\t\ttransforms[key] = impulse\n+\t}\n+\n+}\n+\n+// RemoveFakeImpulses removes each fake impulse per input to the the transform.\n+// Multiple producers for one Input cannot be present.\n+func RemoveFakeImpulses(c *pipepb.Components, ext *pipepb.PTransform) {\n+\ttransforms := c.GetTransforms()\n+\tvar impulseIDs []string\n+\n+\tfor tag := range ext.GetInputs() {\n+\t\tid := fmt.Sprintf(\"%s_%s\", \"impulse\", tag)\n+\t\timpulseIDs = append(impulseIDs, id)\n+\t}\n+\n+\tfor _, id := range impulseIDs {\n+\t\tt := transforms[id]\n+\t\tif t.GetSpec().GetUrn() == URNImpulse {\n+\t\t\tdelete(transforms, id)\n+\n+\t\t}\n+\t}\n+}\n+\n // ExpandedComponents type asserts the Components field with interface{} type\n // and returns its pipeline component proto representation\n func ExpandedComponents(exp *graph.ExpandedTransform) (*pipepb.Components, error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM4MzI3NQ==", "bodyText": "This one specifically is still used outside the package (in xlangx.ResolveArtifacts). The ExternalOutputs helper function is also used outside the package. And since some of them are used outside, I feel like all four of these helpers should be exported, just for consistency.", "url": "https://github.com/apache/beam/pull/13325#discussion_r523383275", "createdAt": "2020-11-14T06:17:11Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "diffHunk": "@@ -16,11 +16,222 @@\n package graphx\n \n import (\n+\t\"fmt\"\n+\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n )\n \n+// MergeExpandedWithPipeline adds expanded components of all ExternalTransforms to the existing pipeline\n+func MergeExpandedWithPipeline(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\t// Adding Expanded transforms to their counterparts in the Pipeline\n+\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\texp := e.External.Expanded\n+\t\t\tif exp == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tid := fmt.Sprintf(\"e%v\", e.ID())\n+\n+\t\t\tp.Requirements = append(p.Requirements, exp.Requirements...)\n+\n+\t\t\t// Adding components of the Expanded Transforms to the current Pipeline\n+\t\t\tcomponents, err := ExpandedComponents(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetTransforms() {\n+\t\t\t\tp.Components.Transforms[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetPcollections() {\n+\t\t\t\tp.Components.Pcollections[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetWindowingStrategies() {\n+\t\t\t\tp.Components.WindowingStrategies[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetCoders() {\n+\t\t\t\tp.Components.Coders[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetEnvironments() {\n+\t\t\t\tif k == \"go\" {\n+\t\t\t\t\t// This case is not an anomaly. It is expected to be always\n+\t\t\t\t\t// present. Any initial ExpansionRequest will have a\n+\t\t\t\t\t// component which requires the \"go\" environment. Scoping\n+\t\t\t\t\t// using unique namespace prevents collision.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tp.Components.Environments[k] = v\n+\t\t\t}\n+\n+\t\t\ttransform, err := ExpandedTransform(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tp.Components.Transforms[id] = transform\n+\t\t}\n+\t}\n+}\n+\n+// PurgeOutputInput remaps outputs from edge corresponding to an\n+// ExternalTransform with the correct expanded outputs. All consumers of the\n+// previous outputs are updated with new inputs.\n+func PurgeOutputInput(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\tidxMap := make(map[string]string)\n+\tcomponents := p.GetComponents()\n+\n+\t// Generating map (oldID -> newID) of outputs to be purged\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\tif e.External.Expanded == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor tag, n := range ExternalOutputs(e) {\n+\t\t\t\tnodeID := fmt.Sprintf(\"n%v\", n.ID())\n+\n+\t\t\t\ttransform, err := ExpandedTransform(e.External.Expanded)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tpanic(err)\n+\t\t\t\t}\n+\t\t\t\texpandedOutputs := transform.GetOutputs()\n+\t\t\t\tvar pcolID string\n+\t\t\t\tif tag == graph.UnnamedOutputTag {\n+\t\t\t\t\tfor _, pcolID = range expandedOutputs {\n+\t\t\t\t\t\t// easiest way to access map with one entry (key,value)\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tpcolID = expandedOutputs[tag]\n+\t\t\t\t}\n+\n+\t\t\t\tidxMap[nodeID] = pcolID\n+\t\t\t\tdelete(components.Pcollections, nodeID)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Updating all input ids to reflect the correct sources\n+\tfor _, t := range components.GetTransforms() {\n+\t\tinputs := t.GetInputs()\n+\t\tfor tag, nodeID := range inputs {\n+\t\t\tif pcolID, exists := idxMap[nodeID]; exists {\n+\t\t\t\tinputs[tag] = pcolID\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+}\n+\n+// VerifyNamedOutputs ensures the expanded outputs correspond to the correct and expected named outputs\n+func VerifyNamedOutputs(ext *graph.ExternalTransform) {\n+\ttransform, err := ExpandedTransform(ext.Expanded)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedOutputs := transform.GetOutputs()\n+\n+\tif len(expandedOutputs) != len(ext.OutputsMap) {\n+\t\tpanic(errors.Errorf(\"mismatched number of named outputs:\\nreceived - %v\\nexpected - %v\", len(expandedOutputs), len(ext.OutputsMap)))\n+\t}\n+\n+\tfor tag := range ext.OutputsMap {\n+\t\t_, exists := expandedOutputs[tag]\n+\t\tif tag != graph.UnnamedOutputTag && !exists {\n+\t\t\tpanic(errors.Errorf(\"missing named output in expanded transform: %v is expected in %v\", tag, expandedOutputs))\n+\t\t}\n+\t\tif tag == graph.UnnamedOutputTag && len(expandedOutputs) > 1 {\n+\t\t\tpanic(errors.Errorf(\"mismatched number of unnamed outputs:\\nreceived - %v\\nexpected - 1\", len(expandedOutputs)))\n+\t\t}\n+\t}\n+}\n+\n+// ResolveOutputIsBounded updates each Output node with respect to the received\n+// expanded components to reflect if it is bounded or not\n+func ResolveOutputIsBounded(e *graph.MultiEdge, isBoundedUpdater func(*graph.Node, bool)) {\n+\text := e.External\n+\texp := ext.Expanded\n+\tcomponents, err := ExpandedComponents(exp)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedPCollections := components.GetPcollections()\n+\ttransform, err := ExpandedTransform(exp)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedOutputs := transform.GetOutputs()\n+\n+\tfor tag, node := range ExternalOutputs(e) {\n+\t\tvar id string\n+\t\tisBounded := true\n+\n+\t\tswitch tag {\n+\t\tcase graph.UnnamedOutputTag:\n+\t\t\tfor _, id = range expandedOutputs {\n+\t\t\t\t// easiest way to access map with one entry (key,value)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tid = expandedOutputs[tag]\n+\t\t}\n+\n+\t\tif pcol, exists := expandedPCollections[id]; exists {\n+\t\t\tif pcol.GetIsBounded() == pipepb.IsBounded_UNBOUNDED {\n+\t\t\t\tisBounded = false\n+\t\t\t}\n+\t\t\tisBoundedUpdater(node, isBounded)\n+\t\t} else {\n+\t\t\tpanic(errors.Errorf(\"missing corresponsing pcollection of named output: %v is expected in %v\", id, expandedPCollections))\n+\t\t}\n+\n+\t}\n+}\n+\n+// AddFakeImpulses adds an impulse transform as the producer for each input to\n+// the root transform. Inputs need producers to form a correct pipeline.\n+func AddFakeImpulses(p *pipepb.Pipeline) {\n+\t// For a pipeline consisting of only the external node edge, there will be\n+\t// single root transform which will be the external transform.\n+\t// Adding fake impulses per input to this external transform\n+\ttransforms := p.GetComponents().GetTransforms()\n+\text := transforms[p.GetRootTransformIds()[0]]\n+\n+\tfor tag, id := range ext.GetInputs() {\n+\t\tkey := fmt.Sprintf(\"%s_%s\", \"impulse\", tag)\n+\t\toutput := map[string]string{\"out\": id}\n+\n+\t\timpulse := &pipepb.PTransform{\n+\t\t\tUniqueName: key,\n+\t\t\tSpec: &pipepb.FunctionSpec{\n+\t\t\t\tUrn: URNImpulse,\n+\t\t\t},\n+\t\t\tOutputs: output,\n+\t\t}\n+\n+\t\ttransforms[key] = impulse\n+\t}\n+\n+}\n+\n+// RemoveFakeImpulses removes each fake impulse per input to the the transform.\n+// Multiple producers for one Input cannot be present.\n+func RemoveFakeImpulses(c *pipepb.Components, ext *pipepb.PTransform) {\n+\ttransforms := c.GetTransforms()\n+\tvar impulseIDs []string\n+\n+\tfor tag := range ext.GetInputs() {\n+\t\tid := fmt.Sprintf(\"%s_%s\", \"impulse\", tag)\n+\t\timpulseIDs = append(impulseIDs, id)\n+\t}\n+\n+\tfor _, id := range impulseIDs {\n+\t\tt := transforms[id]\n+\t\tif t.GetSpec().GetUrn() == URNImpulse {\n+\t\t\tdelete(transforms, id)\n+\n+\t\t}\n+\t}\n+}\n+\n // ExpandedComponents type asserts the Components field with interface{} type\n // and returns its pipeline component proto representation\n func ExpandedComponents(exp *graph.ExpandedTransform) (*pipepb.Components, error) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NDg2Ng=="}, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTczNTIyOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzoyNToyMFrOHyS02w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNjoxNzoxNFrOHzIx8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5OTI5MQ==", "bodyText": "Since this is now in the graphx package, we can probably promote the constant in addDefaultEnv to a proper unexported package constant, and refer to it here.", "url": "https://github.com/apache/beam/pull/13325#discussion_r522499291", "createdAt": "2020-11-12T23:25:20Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "diffHunk": "@@ -16,11 +16,222 @@\n package graphx\n \n import (\n+\t\"fmt\"\n+\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n )\n \n+// MergeExpandedWithPipeline adds expanded components of all ExternalTransforms to the existing pipeline\n+func MergeExpandedWithPipeline(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\t// Adding Expanded transforms to their counterparts in the Pipeline\n+\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\texp := e.External.Expanded\n+\t\t\tif exp == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tid := fmt.Sprintf(\"e%v\", e.ID())\n+\n+\t\t\tp.Requirements = append(p.Requirements, exp.Requirements...)\n+\n+\t\t\t// Adding components of the Expanded Transforms to the current Pipeline\n+\t\t\tcomponents, err := ExpandedComponents(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetTransforms() {\n+\t\t\t\tp.Components.Transforms[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetPcollections() {\n+\t\t\t\tp.Components.Pcollections[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetWindowingStrategies() {\n+\t\t\t\tp.Components.WindowingStrategies[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetCoders() {\n+\t\t\t\tp.Components.Coders[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetEnvironments() {\n+\t\t\t\tif k == \"go\" {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM4MzI4Mw==", "bodyText": "Makes sense. Done.", "url": "https://github.com/apache/beam/pull/13325#discussion_r523383283", "createdAt": "2020-11-14T06:17:14Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "diffHunk": "@@ -16,11 +16,222 @@\n package graphx\n \n import (\n+\t\"fmt\"\n+\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n )\n \n+// MergeExpandedWithPipeline adds expanded components of all ExternalTransforms to the existing pipeline\n+func MergeExpandedWithPipeline(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\t// Adding Expanded transforms to their counterparts in the Pipeline\n+\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\texp := e.External.Expanded\n+\t\t\tif exp == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tid := fmt.Sprintf(\"e%v\", e.ID())\n+\n+\t\t\tp.Requirements = append(p.Requirements, exp.Requirements...)\n+\n+\t\t\t// Adding components of the Expanded Transforms to the current Pipeline\n+\t\t\tcomponents, err := ExpandedComponents(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetTransforms() {\n+\t\t\t\tp.Components.Transforms[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetPcollections() {\n+\t\t\t\tp.Components.Pcollections[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetWindowingStrategies() {\n+\t\t\t\tp.Components.WindowingStrategies[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetCoders() {\n+\t\t\t\tp.Components.Coders[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetEnvironments() {\n+\t\t\t\tif k == \"go\" {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5OTI5MQ=="}, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTc0NzcwOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzoyODoyNlrOHyS8xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNjoxNzoxN1rOHzIx_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwMTMxOA==", "bodyText": "rm spare line", "url": "https://github.com/apache/beam/pull/13325#discussion_r522501318", "createdAt": "2020-11-12T23:28:26Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "diffHunk": "@@ -16,11 +16,222 @@\n package graphx\n \n import (\n+\t\"fmt\"\n+\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n )\n \n+// MergeExpandedWithPipeline adds expanded components of all ExternalTransforms to the existing pipeline\n+func MergeExpandedWithPipeline(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\t// Adding Expanded transforms to their counterparts in the Pipeline\n+\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\texp := e.External.Expanded\n+\t\t\tif exp == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tid := fmt.Sprintf(\"e%v\", e.ID())\n+\n+\t\t\tp.Requirements = append(p.Requirements, exp.Requirements...)\n+\n+\t\t\t// Adding components of the Expanded Transforms to the current Pipeline\n+\t\t\tcomponents, err := ExpandedComponents(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetTransforms() {\n+\t\t\t\tp.Components.Transforms[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetPcollections() {\n+\t\t\t\tp.Components.Pcollections[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetWindowingStrategies() {\n+\t\t\t\tp.Components.WindowingStrategies[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetCoders() {\n+\t\t\t\tp.Components.Coders[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetEnvironments() {\n+\t\t\t\tif k == \"go\" {\n+\t\t\t\t\t// This case is not an anomaly. It is expected to be always\n+\t\t\t\t\t// present. Any initial ExpansionRequest will have a\n+\t\t\t\t\t// component which requires the \"go\" environment. Scoping\n+\t\t\t\t\t// using unique namespace prevents collision.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tp.Components.Environments[k] = v\n+\t\t\t}\n+\n+\t\t\ttransform, err := ExpandedTransform(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tp.Components.Transforms[id] = transform\n+\t\t}\n+\t}\n+}\n+\n+// PurgeOutputInput remaps outputs from edge corresponding to an\n+// ExternalTransform with the correct expanded outputs. All consumers of the\n+// previous outputs are updated with new inputs.\n+func PurgeOutputInput(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\tidxMap := make(map[string]string)\n+\tcomponents := p.GetComponents()\n+\n+\t// Generating map (oldID -> newID) of outputs to be purged\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\tif e.External.Expanded == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor tag, n := range ExternalOutputs(e) {\n+\t\t\t\tnodeID := fmt.Sprintf(\"n%v\", n.ID())\n+\n+\t\t\t\ttransform, err := ExpandedTransform(e.External.Expanded)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tpanic(err)\n+\t\t\t\t}\n+\t\t\t\texpandedOutputs := transform.GetOutputs()\n+\t\t\t\tvar pcolID string\n+\t\t\t\tif tag == graph.UnnamedOutputTag {\n+\t\t\t\t\tfor _, pcolID = range expandedOutputs {\n+\t\t\t\t\t\t// easiest way to access map with one entry (key,value)\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tpcolID = expandedOutputs[tag]\n+\t\t\t\t}\n+\n+\t\t\t\tidxMap[nodeID] = pcolID\n+\t\t\t\tdelete(components.Pcollections, nodeID)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Updating all input ids to reflect the correct sources\n+\tfor _, t := range components.GetTransforms() {\n+\t\tinputs := t.GetInputs()\n+\t\tfor tag, nodeID := range inputs {\n+\t\t\tif pcolID, exists := idxMap[nodeID]; exists {\n+\t\t\t\tinputs[tag] = pcolID\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+}\n+\n+// VerifyNamedOutputs ensures the expanded outputs correspond to the correct and expected named outputs\n+func VerifyNamedOutputs(ext *graph.ExternalTransform) {\n+\ttransform, err := ExpandedTransform(ext.Expanded)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedOutputs := transform.GetOutputs()\n+\n+\tif len(expandedOutputs) != len(ext.OutputsMap) {\n+\t\tpanic(errors.Errorf(\"mismatched number of named outputs:\\nreceived - %v\\nexpected - %v\", len(expandedOutputs), len(ext.OutputsMap)))\n+\t}\n+\n+\tfor tag := range ext.OutputsMap {\n+\t\t_, exists := expandedOutputs[tag]\n+\t\tif tag != graph.UnnamedOutputTag && !exists {\n+\t\t\tpanic(errors.Errorf(\"missing named output in expanded transform: %v is expected in %v\", tag, expandedOutputs))\n+\t\t}\n+\t\tif tag == graph.UnnamedOutputTag && len(expandedOutputs) > 1 {\n+\t\t\tpanic(errors.Errorf(\"mismatched number of unnamed outputs:\\nreceived - %v\\nexpected - 1\", len(expandedOutputs)))\n+\t\t}\n+\t}\n+}\n+\n+// ResolveOutputIsBounded updates each Output node with respect to the received\n+// expanded components to reflect if it is bounded or not\n+func ResolveOutputIsBounded(e *graph.MultiEdge, isBoundedUpdater func(*graph.Node, bool)) {\n+\text := e.External\n+\texp := ext.Expanded\n+\tcomponents, err := ExpandedComponents(exp)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedPCollections := components.GetPcollections()\n+\ttransform, err := ExpandedTransform(exp)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedOutputs := transform.GetOutputs()\n+\n+\tfor tag, node := range ExternalOutputs(e) {\n+\t\tvar id string\n+\t\tisBounded := true\n+\n+\t\tswitch tag {\n+\t\tcase graph.UnnamedOutputTag:\n+\t\t\tfor _, id = range expandedOutputs {\n+\t\t\t\t// easiest way to access map with one entry (key,value)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tid = expandedOutputs[tag]\n+\t\t}\n+\n+\t\tif pcol, exists := expandedPCollections[id]; exists {\n+\t\t\tif pcol.GetIsBounded() == pipepb.IsBounded_UNBOUNDED {\n+\t\t\t\tisBounded = false\n+\t\t\t}\n+\t\t\tisBoundedUpdater(node, isBounded)\n+\t\t} else {\n+\t\t\tpanic(errors.Errorf(\"missing corresponsing pcollection of named output: %v is expected in %v\", id, expandedPCollections))\n+\t\t}\n+\n+\t}\n+}\n+\n+// AddFakeImpulses adds an impulse transform as the producer for each input to\n+// the root transform. Inputs need producers to form a correct pipeline.\n+func AddFakeImpulses(p *pipepb.Pipeline) {\n+\t// For a pipeline consisting of only the external node edge, there will be\n+\t// single root transform which will be the external transform.\n+\t// Adding fake impulses per input to this external transform\n+\ttransforms := p.GetComponents().GetTransforms()\n+\text := transforms[p.GetRootTransformIds()[0]]\n+\n+\tfor tag, id := range ext.GetInputs() {\n+\t\tkey := fmt.Sprintf(\"%s_%s\", \"impulse\", tag)\n+\t\toutput := map[string]string{\"out\": id}\n+\n+\t\timpulse := &pipepb.PTransform{\n+\t\t\tUniqueName: key,\n+\t\t\tSpec: &pipepb.FunctionSpec{\n+\t\t\t\tUrn: URNImpulse,\n+\t\t\t},\n+\t\t\tOutputs: output,\n+\t\t}\n+\n+\t\ttransforms[key] = impulse\n+\t}\n+\n+}\n+\n+// RemoveFakeImpulses removes each fake impulse per input to the the transform.\n+// Multiple producers for one Input cannot be present.\n+func RemoveFakeImpulses(c *pipepb.Components, ext *pipepb.PTransform) {\n+\ttransforms := c.GetTransforms()\n+\tvar impulseIDs []string\n+\n+\tfor tag := range ext.GetInputs() {\n+\t\tid := fmt.Sprintf(\"%s_%s\", \"impulse\", tag)\n+\t\timpulseIDs = append(impulseIDs, id)\n+\t}\n+\n+\tfor _, id := range impulseIDs {\n+\t\tt := transforms[id]\n+\t\tif t.GetSpec().GetUrn() == URNImpulse {\n+\t\t\tdelete(transforms, id)\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM4MzI5Mg==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/13325#discussion_r523383292", "createdAt": "2020-11-14T06:17:17Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "diffHunk": "@@ -16,11 +16,222 @@\n package graphx\n \n import (\n+\t\"fmt\"\n+\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n )\n \n+// MergeExpandedWithPipeline adds expanded components of all ExternalTransforms to the existing pipeline\n+func MergeExpandedWithPipeline(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\t// Adding Expanded transforms to their counterparts in the Pipeline\n+\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\texp := e.External.Expanded\n+\t\t\tif exp == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tid := fmt.Sprintf(\"e%v\", e.ID())\n+\n+\t\t\tp.Requirements = append(p.Requirements, exp.Requirements...)\n+\n+\t\t\t// Adding components of the Expanded Transforms to the current Pipeline\n+\t\t\tcomponents, err := ExpandedComponents(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetTransforms() {\n+\t\t\t\tp.Components.Transforms[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetPcollections() {\n+\t\t\t\tp.Components.Pcollections[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetWindowingStrategies() {\n+\t\t\t\tp.Components.WindowingStrategies[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetCoders() {\n+\t\t\t\tp.Components.Coders[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetEnvironments() {\n+\t\t\t\tif k == \"go\" {\n+\t\t\t\t\t// This case is not an anomaly. It is expected to be always\n+\t\t\t\t\t// present. Any initial ExpansionRequest will have a\n+\t\t\t\t\t// component which requires the \"go\" environment. Scoping\n+\t\t\t\t\t// using unique namespace prevents collision.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tp.Components.Environments[k] = v\n+\t\t\t}\n+\n+\t\t\ttransform, err := ExpandedTransform(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tp.Components.Transforms[id] = transform\n+\t\t}\n+\t}\n+}\n+\n+// PurgeOutputInput remaps outputs from edge corresponding to an\n+// ExternalTransform with the correct expanded outputs. All consumers of the\n+// previous outputs are updated with new inputs.\n+func PurgeOutputInput(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\tidxMap := make(map[string]string)\n+\tcomponents := p.GetComponents()\n+\n+\t// Generating map (oldID -> newID) of outputs to be purged\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\tif e.External.Expanded == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor tag, n := range ExternalOutputs(e) {\n+\t\t\t\tnodeID := fmt.Sprintf(\"n%v\", n.ID())\n+\n+\t\t\t\ttransform, err := ExpandedTransform(e.External.Expanded)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tpanic(err)\n+\t\t\t\t}\n+\t\t\t\texpandedOutputs := transform.GetOutputs()\n+\t\t\t\tvar pcolID string\n+\t\t\t\tif tag == graph.UnnamedOutputTag {\n+\t\t\t\t\tfor _, pcolID = range expandedOutputs {\n+\t\t\t\t\t\t// easiest way to access map with one entry (key,value)\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tpcolID = expandedOutputs[tag]\n+\t\t\t\t}\n+\n+\t\t\t\tidxMap[nodeID] = pcolID\n+\t\t\t\tdelete(components.Pcollections, nodeID)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Updating all input ids to reflect the correct sources\n+\tfor _, t := range components.GetTransforms() {\n+\t\tinputs := t.GetInputs()\n+\t\tfor tag, nodeID := range inputs {\n+\t\t\tif pcolID, exists := idxMap[nodeID]; exists {\n+\t\t\t\tinputs[tag] = pcolID\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+}\n+\n+// VerifyNamedOutputs ensures the expanded outputs correspond to the correct and expected named outputs\n+func VerifyNamedOutputs(ext *graph.ExternalTransform) {\n+\ttransform, err := ExpandedTransform(ext.Expanded)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedOutputs := transform.GetOutputs()\n+\n+\tif len(expandedOutputs) != len(ext.OutputsMap) {\n+\t\tpanic(errors.Errorf(\"mismatched number of named outputs:\\nreceived - %v\\nexpected - %v\", len(expandedOutputs), len(ext.OutputsMap)))\n+\t}\n+\n+\tfor tag := range ext.OutputsMap {\n+\t\t_, exists := expandedOutputs[tag]\n+\t\tif tag != graph.UnnamedOutputTag && !exists {\n+\t\t\tpanic(errors.Errorf(\"missing named output in expanded transform: %v is expected in %v\", tag, expandedOutputs))\n+\t\t}\n+\t\tif tag == graph.UnnamedOutputTag && len(expandedOutputs) > 1 {\n+\t\t\tpanic(errors.Errorf(\"mismatched number of unnamed outputs:\\nreceived - %v\\nexpected - 1\", len(expandedOutputs)))\n+\t\t}\n+\t}\n+}\n+\n+// ResolveOutputIsBounded updates each Output node with respect to the received\n+// expanded components to reflect if it is bounded or not\n+func ResolveOutputIsBounded(e *graph.MultiEdge, isBoundedUpdater func(*graph.Node, bool)) {\n+\text := e.External\n+\texp := ext.Expanded\n+\tcomponents, err := ExpandedComponents(exp)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedPCollections := components.GetPcollections()\n+\ttransform, err := ExpandedTransform(exp)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\texpandedOutputs := transform.GetOutputs()\n+\n+\tfor tag, node := range ExternalOutputs(e) {\n+\t\tvar id string\n+\t\tisBounded := true\n+\n+\t\tswitch tag {\n+\t\tcase graph.UnnamedOutputTag:\n+\t\t\tfor _, id = range expandedOutputs {\n+\t\t\t\t// easiest way to access map with one entry (key,value)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tid = expandedOutputs[tag]\n+\t\t}\n+\n+\t\tif pcol, exists := expandedPCollections[id]; exists {\n+\t\t\tif pcol.GetIsBounded() == pipepb.IsBounded_UNBOUNDED {\n+\t\t\t\tisBounded = false\n+\t\t\t}\n+\t\t\tisBoundedUpdater(node, isBounded)\n+\t\t} else {\n+\t\t\tpanic(errors.Errorf(\"missing corresponsing pcollection of named output: %v is expected in %v\", id, expandedPCollections))\n+\t\t}\n+\n+\t}\n+}\n+\n+// AddFakeImpulses adds an impulse transform as the producer for each input to\n+// the root transform. Inputs need producers to form a correct pipeline.\n+func AddFakeImpulses(p *pipepb.Pipeline) {\n+\t// For a pipeline consisting of only the external node edge, there will be\n+\t// single root transform which will be the external transform.\n+\t// Adding fake impulses per input to this external transform\n+\ttransforms := p.GetComponents().GetTransforms()\n+\text := transforms[p.GetRootTransformIds()[0]]\n+\n+\tfor tag, id := range ext.GetInputs() {\n+\t\tkey := fmt.Sprintf(\"%s_%s\", \"impulse\", tag)\n+\t\toutput := map[string]string{\"out\": id}\n+\n+\t\timpulse := &pipepb.PTransform{\n+\t\t\tUniqueName: key,\n+\t\t\tSpec: &pipepb.FunctionSpec{\n+\t\t\t\tUrn: URNImpulse,\n+\t\t\t},\n+\t\t\tOutputs: output,\n+\t\t}\n+\n+\t\ttransforms[key] = impulse\n+\t}\n+\n+}\n+\n+// RemoveFakeImpulses removes each fake impulse per input to the the transform.\n+// Multiple producers for one Input cannot be present.\n+func RemoveFakeImpulses(c *pipepb.Components, ext *pipepb.PTransform) {\n+\ttransforms := c.GetTransforms()\n+\tvar impulseIDs []string\n+\n+\tfor tag := range ext.GetInputs() {\n+\t\tid := fmt.Sprintf(\"%s_%s\", \"impulse\", tag)\n+\t\timpulseIDs = append(impulseIDs, id)\n+\t}\n+\n+\tfor _, id := range impulseIDs {\n+\t\tt := transforms[id]\n+\t\tif t.GetSpec().GetUrn() == URNImpulse {\n+\t\t\tdelete(transforms, id)\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwMTMxOA=="}, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTc3OTg3OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/xlangx/expand.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzozNzoxMFrOHyTRDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNjoxNzoyMlrOHzIx_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNjUwOA==", "bodyText": "Consider making this not exported on the package boundary, if it's not necessary.\nIt's always easier to expand an API than contract it, and invariably exposed API surfaces will eventually be depended on by some user or another.", "url": "https://github.com/apache/beam/pull/13325#discussion_r522506508", "createdAt": "2020-11-12T23:37:10Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/xlangx/expand.go", "diffHunk": "@@ -18,19 +18,79 @@ package xlangx\n import (\n \t\"context\"\n \n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/pipelinex\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n \t\"google.golang.org/grpc\"\n )\n \n-// Expand submits an external transform to be expanded by the expansion service.\n-// The given transform should be the external transform, and the components are\n-// any additional components necessary for the pipeline snippet.\n+// Expand expands an unexpanded graph.ExternalTransform and returns the expanded\n+// transform as a new graph.ExpandedTransform. This requires querying an\n+// expansion service based on the configuration details within the\n+// ExternalTransform.\n+func Expand(edge *graph.MultiEdge, ext *graph.ExternalTransform) (*graph.ExpandedTransform, error) {\n+\t// Build the ExpansionRequest\n+\n+\t// Obtaining the components and transform proto representing this transform\n+\tp, err := graphx.Marshal([]*graph.MultiEdge{edge}, &graphx.Options{})\n+\tif err != nil {\n+\t\treturn nil, errors.Wrapf(err, \"unable to generate proto representation of %v\", ext)\n+\t}\n+\n+\ttransforms := p.GetComponents().GetTransforms()\n+\n+\t// Transforms consist of only External transform and composites. Composites\n+\t// should be removed from proto before submitting expansion request.\n+\textTransformID := p.GetRootTransformIds()[0]\n+\textTransform := transforms[extTransformID]\n+\tfor extTransform.UniqueName != \"External\" {\n+\t\tdelete(transforms, extTransformID)\n+\t\tp, err := pipelinex.Normalize(p)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\textTransformID = p.GetRootTransformIds()[0]\n+\t\textTransform = transforms[extTransformID]\n+\t}\n+\n+\t// Scoping the ExternalTransform with respect to it's unique namespace, thus\n+\t// avoiding future collisions\n+\tAddNamespace(extTransform, p.GetComponents(), ext.Namespace)\n+\n+\tgraphx.AddFakeImpulses(p) // Inputs need to have sources\n+\tdelete(transforms, extTransformID)\n+\n+\t// Querying the expansion service\n+\tres, err := QueryExpansionService(context.Background(), p.GetComponents(), extTransform, ext.Namespace, ext.ExpansionAddr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Handling ExpansionResponse\n+\n+\t// Previously added fake impulses need to be removed to avoid having\n+\t// multiple sources to the same pcollection in the graph\n+\tgraphx.RemoveFakeImpulses(res.GetComponents(), res.GetTransform())\n+\n+\texp := &graph.ExpandedTransform{\n+\t\tComponents:   res.GetComponents(),\n+\t\tTransform:    res.GetTransform(),\n+\t\tRequirements: res.GetRequirements(),\n+\t}\n+\treturn exp, nil\n+}\n+\n+// QueryExpansionService submits an external transform to be expanded by the\n+// expansion service. The given transform should be the external transform, and\n+// the components are any additional components necessary for the pipeline\n+// snippet.\n //\n // Users should generally call beam.CrossLanguage to access foreign transforms\n // rather than calling this function directly.\n-func Expand(\n+func QueryExpansionService(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM4MzI5NQ==", "bodyText": "Yep, good point. I don't see it being necessary outside the package. Done.", "url": "https://github.com/apache/beam/pull/13325#discussion_r523383295", "createdAt": "2020-11-14T06:17:22Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/xlangx/expand.go", "diffHunk": "@@ -18,19 +18,79 @@ package xlangx\n import (\n \t\"context\"\n \n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/pipelinex\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n \t\"google.golang.org/grpc\"\n )\n \n-// Expand submits an external transform to be expanded by the expansion service.\n-// The given transform should be the external transform, and the components are\n-// any additional components necessary for the pipeline snippet.\n+// Expand expands an unexpanded graph.ExternalTransform and returns the expanded\n+// transform as a new graph.ExpandedTransform. This requires querying an\n+// expansion service based on the configuration details within the\n+// ExternalTransform.\n+func Expand(edge *graph.MultiEdge, ext *graph.ExternalTransform) (*graph.ExpandedTransform, error) {\n+\t// Build the ExpansionRequest\n+\n+\t// Obtaining the components and transform proto representing this transform\n+\tp, err := graphx.Marshal([]*graph.MultiEdge{edge}, &graphx.Options{})\n+\tif err != nil {\n+\t\treturn nil, errors.Wrapf(err, \"unable to generate proto representation of %v\", ext)\n+\t}\n+\n+\ttransforms := p.GetComponents().GetTransforms()\n+\n+\t// Transforms consist of only External transform and composites. Composites\n+\t// should be removed from proto before submitting expansion request.\n+\textTransformID := p.GetRootTransformIds()[0]\n+\textTransform := transforms[extTransformID]\n+\tfor extTransform.UniqueName != \"External\" {\n+\t\tdelete(transforms, extTransformID)\n+\t\tp, err := pipelinex.Normalize(p)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\textTransformID = p.GetRootTransformIds()[0]\n+\t\textTransform = transforms[extTransformID]\n+\t}\n+\n+\t// Scoping the ExternalTransform with respect to it's unique namespace, thus\n+\t// avoiding future collisions\n+\tAddNamespace(extTransform, p.GetComponents(), ext.Namespace)\n+\n+\tgraphx.AddFakeImpulses(p) // Inputs need to have sources\n+\tdelete(transforms, extTransformID)\n+\n+\t// Querying the expansion service\n+\tres, err := QueryExpansionService(context.Background(), p.GetComponents(), extTransform, ext.Namespace, ext.ExpansionAddr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Handling ExpansionResponse\n+\n+\t// Previously added fake impulses need to be removed to avoid having\n+\t// multiple sources to the same pcollection in the graph\n+\tgraphx.RemoveFakeImpulses(res.GetComponents(), res.GetTransform())\n+\n+\texp := &graph.ExpandedTransform{\n+\t\tComponents:   res.GetComponents(),\n+\t\tTransform:    res.GetTransform(),\n+\t\tRequirements: res.GetRequirements(),\n+\t}\n+\treturn exp, nil\n+}\n+\n+// QueryExpansionService submits an external transform to be expanded by the\n+// expansion service. The given transform should be the external transform, and\n+// the components are any additional components necessary for the pipeline\n+// snippet.\n //\n // Users should generally call beam.CrossLanguage to access foreign transforms\n // rather than calling this function directly.\n-func Expand(\n+func QueryExpansionService(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNjUwOA=="}, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTc4NTU0OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/xlangx/expand.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzozOTozMVrOHyTUTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNjoxNzo1MFrOHzIyFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNzM0Mg==", "bodyText": "Does addNamespace still need to be exported?", "url": "https://github.com/apache/beam/pull/13325#discussion_r522507342", "createdAt": "2020-11-12T23:39:31Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/xlangx/expand.go", "diffHunk": "@@ -18,19 +18,79 @@ package xlangx\n import (\n \t\"context\"\n \n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/pipelinex\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n \t\"google.golang.org/grpc\"\n )\n \n-// Expand submits an external transform to be expanded by the expansion service.\n-// The given transform should be the external transform, and the components are\n-// any additional components necessary for the pipeline snippet.\n+// Expand expands an unexpanded graph.ExternalTransform and returns the expanded\n+// transform as a new graph.ExpandedTransform. This requires querying an\n+// expansion service based on the configuration details within the\n+// ExternalTransform.\n+func Expand(edge *graph.MultiEdge, ext *graph.ExternalTransform) (*graph.ExpandedTransform, error) {\n+\t// Build the ExpansionRequest\n+\n+\t// Obtaining the components and transform proto representing this transform\n+\tp, err := graphx.Marshal([]*graph.MultiEdge{edge}, &graphx.Options{})\n+\tif err != nil {\n+\t\treturn nil, errors.Wrapf(err, \"unable to generate proto representation of %v\", ext)\n+\t}\n+\n+\ttransforms := p.GetComponents().GetTransforms()\n+\n+\t// Transforms consist of only External transform and composites. Composites\n+\t// should be removed from proto before submitting expansion request.\n+\textTransformID := p.GetRootTransformIds()[0]\n+\textTransform := transforms[extTransformID]\n+\tfor extTransform.UniqueName != \"External\" {\n+\t\tdelete(transforms, extTransformID)\n+\t\tp, err := pipelinex.Normalize(p)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\textTransformID = p.GetRootTransformIds()[0]\n+\t\textTransform = transforms[extTransformID]\n+\t}\n+\n+\t// Scoping the ExternalTransform with respect to it's unique namespace, thus\n+\t// avoiding future collisions\n+\tAddNamespace(extTransform, p.GetComponents(), ext.Namespace)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM4MzMxOQ==", "bodyText": "Doesn't seem like it. Un-exported.", "url": "https://github.com/apache/beam/pull/13325#discussion_r523383319", "createdAt": "2020-11-14T06:17:50Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/xlangx/expand.go", "diffHunk": "@@ -18,19 +18,79 @@ package xlangx\n import (\n \t\"context\"\n \n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/pipelinex\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n \t\"google.golang.org/grpc\"\n )\n \n-// Expand submits an external transform to be expanded by the expansion service.\n-// The given transform should be the external transform, and the components are\n-// any additional components necessary for the pipeline snippet.\n+// Expand expands an unexpanded graph.ExternalTransform and returns the expanded\n+// transform as a new graph.ExpandedTransform. This requires querying an\n+// expansion service based on the configuration details within the\n+// ExternalTransform.\n+func Expand(edge *graph.MultiEdge, ext *graph.ExternalTransform) (*graph.ExpandedTransform, error) {\n+\t// Build the ExpansionRequest\n+\n+\t// Obtaining the components and transform proto representing this transform\n+\tp, err := graphx.Marshal([]*graph.MultiEdge{edge}, &graphx.Options{})\n+\tif err != nil {\n+\t\treturn nil, errors.Wrapf(err, \"unable to generate proto representation of %v\", ext)\n+\t}\n+\n+\ttransforms := p.GetComponents().GetTransforms()\n+\n+\t// Transforms consist of only External transform and composites. Composites\n+\t// should be removed from proto before submitting expansion request.\n+\textTransformID := p.GetRootTransformIds()[0]\n+\textTransform := transforms[extTransformID]\n+\tfor extTransform.UniqueName != \"External\" {\n+\t\tdelete(transforms, extTransformID)\n+\t\tp, err := pipelinex.Normalize(p)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\textTransformID = p.GetRootTransformIds()[0]\n+\t\textTransform = transforms[extTransformID]\n+\t}\n+\n+\t// Scoping the ExternalTransform with respect to it's unique namespace, thus\n+\t// avoiding future collisions\n+\tAddNamespace(extTransform, p.GetComponents(), ext.Namespace)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNzM0Mg=="}, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTc5ODI0OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzo0MzozOVrOHyTcJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNjoxNzo1OFrOHzIyGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwOTM0OA==", "bodyText": "Now that I looked at everything, it seems like this and MergeExpandedWithPipeline may be the only touched function we can un-export, but I only have a small view of the code right now.", "url": "https://github.com/apache/beam/pull/13325#discussion_r522509348", "createdAt": "2020-11-12T23:43:39Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "diffHunk": "@@ -16,11 +16,222 @@\n package graphx\n \n import (\n+\t\"fmt\"\n+\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n )\n \n+// MergeExpandedWithPipeline adds expanded components of all ExternalTransforms to the existing pipeline\n+func MergeExpandedWithPipeline(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\t// Adding Expanded transforms to their counterparts in the Pipeline\n+\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\texp := e.External.Expanded\n+\t\t\tif exp == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tid := fmt.Sprintf(\"e%v\", e.ID())\n+\n+\t\t\tp.Requirements = append(p.Requirements, exp.Requirements...)\n+\n+\t\t\t// Adding components of the Expanded Transforms to the current Pipeline\n+\t\t\tcomponents, err := ExpandedComponents(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetTransforms() {\n+\t\t\t\tp.Components.Transforms[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetPcollections() {\n+\t\t\t\tp.Components.Pcollections[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetWindowingStrategies() {\n+\t\t\t\tp.Components.WindowingStrategies[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetCoders() {\n+\t\t\t\tp.Components.Coders[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetEnvironments() {\n+\t\t\t\tif k == \"go\" {\n+\t\t\t\t\t// This case is not an anomaly. It is expected to be always\n+\t\t\t\t\t// present. Any initial ExpansionRequest will have a\n+\t\t\t\t\t// component which requires the \"go\" environment. Scoping\n+\t\t\t\t\t// using unique namespace prevents collision.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tp.Components.Environments[k] = v\n+\t\t\t}\n+\n+\t\t\ttransform, err := ExpandedTransform(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tp.Components.Transforms[id] = transform\n+\t\t}\n+\t}\n+}\n+\n+// PurgeOutputInput remaps outputs from edge corresponding to an\n+// ExternalTransform with the correct expanded outputs. All consumers of the\n+// previous outputs are updated with new inputs.\n+func PurgeOutputInput(edges []*graph.MultiEdge, p *pipepb.Pipeline) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM4MzMyMg==", "bodyText": "According to IntelliJ, you're right. The others have usages either in the xlangx or beam packages.", "url": "https://github.com/apache/beam/pull/13325#discussion_r523383322", "createdAt": "2020-11-14T06:17:58Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang.go", "diffHunk": "@@ -16,11 +16,222 @@\n package graphx\n \n import (\n+\t\"fmt\"\n+\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n )\n \n+// MergeExpandedWithPipeline adds expanded components of all ExternalTransforms to the existing pipeline\n+func MergeExpandedWithPipeline(edges []*graph.MultiEdge, p *pipepb.Pipeline) {\n+\t// Adding Expanded transforms to their counterparts in the Pipeline\n+\n+\tfor _, e := range edges {\n+\t\tif e.Op == graph.External {\n+\t\t\texp := e.External.Expanded\n+\t\t\tif exp == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tid := fmt.Sprintf(\"e%v\", e.ID())\n+\n+\t\t\tp.Requirements = append(p.Requirements, exp.Requirements...)\n+\n+\t\t\t// Adding components of the Expanded Transforms to the current Pipeline\n+\t\t\tcomponents, err := ExpandedComponents(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetTransforms() {\n+\t\t\t\tp.Components.Transforms[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetPcollections() {\n+\t\t\t\tp.Components.Pcollections[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetWindowingStrategies() {\n+\t\t\t\tp.Components.WindowingStrategies[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetCoders() {\n+\t\t\t\tp.Components.Coders[k] = v\n+\t\t\t}\n+\t\t\tfor k, v := range components.GetEnvironments() {\n+\t\t\t\tif k == \"go\" {\n+\t\t\t\t\t// This case is not an anomaly. It is expected to be always\n+\t\t\t\t\t// present. Any initial ExpansionRequest will have a\n+\t\t\t\t\t// component which requires the \"go\" environment. Scoping\n+\t\t\t\t\t// using unique namespace prevents collision.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tp.Components.Environments[k] = v\n+\t\t\t}\n+\n+\t\t\ttransform, err := ExpandedTransform(exp)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tp.Components.Transforms[id] = transform\n+\t\t}\n+\t}\n+}\n+\n+// PurgeOutputInput remaps outputs from edge corresponding to an\n+// ExternalTransform with the correct expanded outputs. All consumers of the\n+// previous outputs are updated with new inputs.\n+func PurgeOutputInput(edges []*graph.MultiEdge, p *pipepb.Pipeline) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwOTM0OA=="}, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTgyNTMwOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/xlang.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzo0OTo1N1rOHyTtyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNjoxODoyN1rOHzIyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxMzg2Ng==", "bodyText": "What do you think about simply moving this assignment into xlangx.Expand?", "url": "https://github.com/apache/beam/pull/13325#discussion_r522513866", "createdAt": "2020-11-12T23:49:57Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/xlang.go", "diffHunk": "@@ -87,61 +84,16 @@ func TryCrossLanguage(s Scope, ext *graph.ExternalTransform, ins []*graph.Inboun\n \t// unique namespace can be requested.\n \text.Namespace = graph.NewNamespace()\n \n-\t// Build the ExpansionRequest\n-\n-\t// Obtaining the components and transform proto representing this transform\n-\t// TODO(BEAM-11188): Move proto handling code into xlangx or graphx package.\n-\tp, err := graphx.Marshal([]*graph.MultiEdge{edge}, &graphx.Options{})\n+\texpanded, err := xlangx.Expand(edge, ext)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"unable to generate proto representation of %v\", ext)\n-\t}\n-\n-\ttransforms := p.GetComponents().GetTransforms()\n-\n-\t// Transforms consist of only External transform and composites. Composites\n-\t// should be removed from proto before submitting expansion request.\n-\textTransformID := p.GetRootTransformIds()[0]\n-\textTransform := transforms[extTransformID]\n-\tfor extTransform.UniqueName != \"External\" {\n-\t\tdelete(transforms, extTransformID)\n-\t\tp, err := pipelinex.Normalize(p)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\textTransformID = p.GetRootTransformIds()[0]\n-\t\textTransform = transforms[extTransformID]\n-\t}\n-\n-\t// Scoping the ExternalTransform with respect to it's unique namespace, thus\n-\t// avoiding future collisions\n-\txlangx.AddNamespace(extTransform, p.GetComponents(), ext.Namespace)\n-\n-\txlangx.AddFakeImpulses(p) // Inputs need to have sources\n-\tdelete(transforms, extTransformID)\n-\n-\t// Querying the expansion service\n-\tres, err := xlangx.Expand(context.Background(), p.GetComponents(), extTransform, ext.Namespace, ext.ExpansionAddr)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\t// Handling ExpansionResponse\n-\n-\t// Previously added fake impulses need to be removed to avoid having\n-\t// multiple sources to the same pcollection in the graph\n-\txlangx.RemoveFakeImpulses(res.GetComponents(), res.GetTransform())\n-\n-\texp := &graph.ExpandedTransform{\n-\t\tComponents:   res.GetComponents(),\n-\t\tTransform:    res.GetTransform(),\n-\t\tRequirements: res.GetRequirements(),\n+\t\treturn nil, errors.WithContext(err, \"expanding external transform\")\n \t}\n-\text.Expanded = exp\n+\text.Expanded = expanded", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM4MzM0Ng==", "bodyText": "Sounds fine with me. My instinct is usually to prefer returning values over modifying parameters, but Expand has such specific usage that I don't think it matters much here. Done.", "url": "https://github.com/apache/beam/pull/13325#discussion_r523383346", "createdAt": "2020-11-14T06:18:27Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/xlang.go", "diffHunk": "@@ -87,61 +84,16 @@ func TryCrossLanguage(s Scope, ext *graph.ExternalTransform, ins []*graph.Inboun\n \t// unique namespace can be requested.\n \text.Namespace = graph.NewNamespace()\n \n-\t// Build the ExpansionRequest\n-\n-\t// Obtaining the components and transform proto representing this transform\n-\t// TODO(BEAM-11188): Move proto handling code into xlangx or graphx package.\n-\tp, err := graphx.Marshal([]*graph.MultiEdge{edge}, &graphx.Options{})\n+\texpanded, err := xlangx.Expand(edge, ext)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"unable to generate proto representation of %v\", ext)\n-\t}\n-\n-\ttransforms := p.GetComponents().GetTransforms()\n-\n-\t// Transforms consist of only External transform and composites. Composites\n-\t// should be removed from proto before submitting expansion request.\n-\textTransformID := p.GetRootTransformIds()[0]\n-\textTransform := transforms[extTransformID]\n-\tfor extTransform.UniqueName != \"External\" {\n-\t\tdelete(transforms, extTransformID)\n-\t\tp, err := pipelinex.Normalize(p)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\textTransformID = p.GetRootTransformIds()[0]\n-\t\textTransform = transforms[extTransformID]\n-\t}\n-\n-\t// Scoping the ExternalTransform with respect to it's unique namespace, thus\n-\t// avoiding future collisions\n-\txlangx.AddNamespace(extTransform, p.GetComponents(), ext.Namespace)\n-\n-\txlangx.AddFakeImpulses(p) // Inputs need to have sources\n-\tdelete(transforms, extTransformID)\n-\n-\t// Querying the expansion service\n-\tres, err := xlangx.Expand(context.Background(), p.GetComponents(), extTransform, ext.Namespace, ext.ExpansionAddr)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\t// Handling ExpansionResponse\n-\n-\t// Previously added fake impulses need to be removed to avoid having\n-\t// multiple sources to the same pcollection in the graph\n-\txlangx.RemoveFakeImpulses(res.GetComponents(), res.GetTransform())\n-\n-\texp := &graph.ExpandedTransform{\n-\t\tComponents:   res.GetComponents(),\n-\t\tTransform:    res.GetTransform(),\n-\t\tRequirements: res.GetRequirements(),\n+\t\treturn nil, errors.WithContext(err, \"expanding external transform\")\n \t}\n-\text.Expanded = exp\n+\text.Expanded = expanded", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxMzg2Ng=="}, "originalCommit": {"oid": "d021efd0ed33a0df9e74ec1ad60b245fb121a1a4"}, "originalPosition": 68}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2784, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}