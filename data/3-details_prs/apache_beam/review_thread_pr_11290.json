{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3Mzk2Mzg2", "number": 11290, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjozNDozOFrODuCLPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjo0MDozMVrODuCUiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTk2NzMzOnYy", "diffSide": "LEFT", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamSetOperatorRelBase.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjozNDozOFrOF_zpYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNzoxNzowMlrOF_1TFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MDc4Nw==", "bodyText": "Shouldn't we still verify that the schemas have equivalent types without nullability?", "url": "https://github.com/apache/beam/pull/11290#discussion_r402450787", "createdAt": "2020-04-02T16:34:38Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamSetOperatorRelBase.java", "diffHunk": "@@ -63,16 +62,6 @@ public BeamSetOperatorRelBase(BeamRelNode beamRelNode, OpType opType, boolean al\n         inputs);\n     PCollection<Row> leftRows = inputs.get(0);\n     PCollection<Row> rightRows = inputs.get(1);\n-    Schema leftSchema = leftRows.getSchema();\n-    Schema rightSchema = rightRows.getSchema();\n-    if (!leftSchema.typesEqual(rightSchema)) {\n-      throw new IllegalArgumentException(\n-          \"Can't intersect two tables with different schemas.\"\n-              + \"lhsSchema: \"\n-              + leftSchema\n-              + \"  rhsSchema: \"\n-              + rightSchema);\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789664619f034a4cce70a2e1479f9704a13eed26"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1NzcyNg==", "bodyText": "The merge function itself now verifies this.", "url": "https://github.com/apache/beam/pull/11290#discussion_r402457726", "createdAt": "2020-04-02T16:45:00Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamSetOperatorRelBase.java", "diffHunk": "@@ -63,16 +62,6 @@ public BeamSetOperatorRelBase(BeamRelNode beamRelNode, OpType opType, boolean al\n         inputs);\n     PCollection<Row> leftRows = inputs.get(0);\n     PCollection<Row> rightRows = inputs.get(1);\n-    Schema leftSchema = leftRows.getSchema();\n-    Schema rightSchema = rightRows.getSchema();\n-    if (!leftSchema.typesEqual(rightSchema)) {\n-      throw new IllegalArgumentException(\n-          \"Can't intersect two tables with different schemas.\"\n-              + \"lhsSchema: \"\n-              + leftSchema\n-              + \"  rhsSchema: \"\n-              + rightSchema);\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MDc4Nw=="}, "originalCommit": {"oid": "789664619f034a4cce70a2e1479f9704a13eed26"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3MjAwMQ==", "bodyText": "Ah I see. If there aren't any tests verifying this already could you add one?", "url": "https://github.com/apache/beam/pull/11290#discussion_r402472001", "createdAt": "2020-04-02T17:07:17Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamSetOperatorRelBase.java", "diffHunk": "@@ -63,16 +62,6 @@ public BeamSetOperatorRelBase(BeamRelNode beamRelNode, OpType opType, boolean al\n         inputs);\n     PCollection<Row> leftRows = inputs.get(0);\n     PCollection<Row> rightRows = inputs.get(1);\n-    Schema leftSchema = leftRows.getSchema();\n-    Schema rightSchema = rightRows.getSchema();\n-    if (!leftSchema.typesEqual(rightSchema)) {\n-      throw new IllegalArgumentException(\n-          \"Can't intersect two tables with different schemas.\"\n-              + \"lhsSchema: \"\n-              + leftSchema\n-              + \"  rhsSchema: \"\n-              + rightSchema);\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MDc4Nw=="}, "originalCommit": {"oid": "789664619f034a4cce70a2e1479f9704a13eed26"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3MzMzMQ==", "bodyText": "There is a test in CoGroupTest.java that verifies this. Should I add an additional one here?", "url": "https://github.com/apache/beam/pull/11290#discussion_r402473331", "createdAt": "2020-04-02T17:09:36Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamSetOperatorRelBase.java", "diffHunk": "@@ -63,16 +62,6 @@ public BeamSetOperatorRelBase(BeamRelNode beamRelNode, OpType opType, boolean al\n         inputs);\n     PCollection<Row> leftRows = inputs.get(0);\n     PCollection<Row> rightRows = inputs.get(1);\n-    Schema leftSchema = leftRows.getSchema();\n-    Schema rightSchema = rightRows.getSchema();\n-    if (!leftSchema.typesEqual(rightSchema)) {\n-      throw new IllegalArgumentException(\n-          \"Can't intersect two tables with different schemas.\"\n-              + \"lhsSchema: \"\n-              + leftSchema\n-              + \"  rhsSchema: \"\n-              + rightSchema);\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MDc4Nw=="}, "originalCommit": {"oid": "789664619f034a4cce70a2e1479f9704a13eed26"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3Nzg0NQ==", "bodyText": "It could be nice to have something in ZetaSQLDialectSpecTest to verify the set operation just in case we break the logic there and not in CoGroup, but I guess it's fine either way", "url": "https://github.com/apache/beam/pull/11290#discussion_r402477845", "createdAt": "2020-04-02T17:17:02Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamSetOperatorRelBase.java", "diffHunk": "@@ -63,16 +62,6 @@ public BeamSetOperatorRelBase(BeamRelNode beamRelNode, OpType opType, boolean al\n         inputs);\n     PCollection<Row> leftRows = inputs.get(0);\n     PCollection<Row> rightRows = inputs.get(1);\n-    Schema leftSchema = leftRows.getSchema();\n-    Schema rightSchema = rightRows.getSchema();\n-    if (!leftSchema.typesEqual(rightSchema)) {\n-      throw new IllegalArgumentException(\n-          \"Can't intersect two tables with different schemas.\"\n-              + \"lhsSchema: \"\n-              + leftSchema\n-              + \"  rhsSchema: \"\n-              + rightSchema);\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MDc4Nw=="}, "originalCommit": {"oid": "789664619f034a4cce70a2e1479f9704a13eed26"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTk5MTE1OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjo0MDozMVrOF_z4vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjo0NTowM1rOF_0EmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1NDcxOQ==", "bodyText": "Just a general comment: do you think we should add a visitor pattern for this sort of thing?", "url": "https://github.com/apache/beam/pull/11290#discussion_r402454719", "createdAt": "2020-04-02T16:40:31Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaUtils.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas;\n+\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+\n+/** A set of utility functions for schemas. */\n+public class SchemaUtils {\n+  /**\n+   * Given two schema that have matching types, return a nullable-widened schema.\n+   *\n+   * <p>The schemas must have matching types, except for field names which can differ. The returned\n+   * schema will contain the field names in the first schema. All field types will be nullable if\n+   * the corresponding field type is nullable in either of the input schemas.\n+   */\n+  public static Schema mergeWideningNullable(Schema schema1, Schema schema2) {\n+    if (schema1.getFieldCount() != schema2.getFieldCount()) {\n+      throw new IllegalArgumentException(\n+          \"Cannot merge schemas with different numbers of fields. \"\n+              + \"schema1: \"\n+              + schema1\n+              + \" schema2: \"\n+              + schema2);\n+    }\n+    Schema.Builder builder = Schema.builder();\n+    for (int i = 0; i < schema1.getFieldCount(); ++i) {\n+      String name = schema1.getField(i).getName();\n+      builder.addField(\n+          name, widenNullableTypes(schema1.getField(i).getType(), schema2.getField(i).getType()));\n+    }\n+    return builder.build();\n+  }\n+\n+  static FieldType widenNullableTypes(FieldType fieldType1, FieldType fieldType2) {\n+    if (fieldType1.getTypeName() != fieldType2.getTypeName()) {\n+      throw new IllegalArgumentException(\n+          \"Cannot merge two types: \"\n+              + fieldType1.getTypeName()\n+              + \" and \"\n+              + fieldType2.getTypeName());\n+    }\n+\n+    FieldType result;\n+    switch (fieldType1.getTypeName()) {\n+      case ROW:\n+        result =\n+            FieldType.row(\n+                mergeWideningNullable(fieldType1.getRowSchema(), fieldType2.getRowSchema()));\n+        break;\n+      case ARRAY:\n+        FieldType arrayElementType =\n+            widenNullableTypes(\n+                fieldType1.getCollectionElementType(), fieldType2.getCollectionElementType());\n+        result = FieldType.array(arrayElementType);\n+        break;\n+      case ITERABLE:\n+        FieldType iterableElementType =\n+            widenNullableTypes(\n+                fieldType1.getCollectionElementType(), fieldType2.getCollectionElementType());\n+        result = FieldType.iterable(iterableElementType);\n+        break;\n+      case MAP:\n+        FieldType keyType =\n+            widenNullableTypes(fieldType1.getMapKeyType(), fieldType2.getMapKeyType());\n+        FieldType valueType =\n+            widenNullableTypes(fieldType1.getMapValueType(), fieldType2.getMapValueType());\n+        result = FieldType.map(keyType, valueType);\n+        break;\n+      case LOGICAL_TYPE:\n+        if (!fieldType1\n+            .getLogicalType()\n+            .getIdentifier()\n+            .equals(fieldType2.getLogicalType().getIdentifier())) {\n+          throw new IllegalArgumentException(\n+              \"Logical types don't match and cannot be merged: \"\n+                  + fieldType1.getLogicalType().getIdentifier()\n+                  + \".v.s\"\n+                  + fieldType2.getLogicalType().getIdentifier());\n+        }\n+        // fall through\n+      default:\n+        result = fieldType1;\n+    }\n+    return result.withNullable(fieldType1.getNullable() || fieldType2.getNullable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789664619f034a4cce70a2e1479f9704a13eed26"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1Nzc1Mw==", "bodyText": "Maybe? I'm not sure visitor per se, as we don't require double dispatch. However we might consider generalizing the recursive tree walk.", "url": "https://github.com/apache/beam/pull/11290#discussion_r402457753", "createdAt": "2020-04-02T16:45:03Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaUtils.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas;\n+\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+\n+/** A set of utility functions for schemas. */\n+public class SchemaUtils {\n+  /**\n+   * Given two schema that have matching types, return a nullable-widened schema.\n+   *\n+   * <p>The schemas must have matching types, except for field names which can differ. The returned\n+   * schema will contain the field names in the first schema. All field types will be nullable if\n+   * the corresponding field type is nullable in either of the input schemas.\n+   */\n+  public static Schema mergeWideningNullable(Schema schema1, Schema schema2) {\n+    if (schema1.getFieldCount() != schema2.getFieldCount()) {\n+      throw new IllegalArgumentException(\n+          \"Cannot merge schemas with different numbers of fields. \"\n+              + \"schema1: \"\n+              + schema1\n+              + \" schema2: \"\n+              + schema2);\n+    }\n+    Schema.Builder builder = Schema.builder();\n+    for (int i = 0; i < schema1.getFieldCount(); ++i) {\n+      String name = schema1.getField(i).getName();\n+      builder.addField(\n+          name, widenNullableTypes(schema1.getField(i).getType(), schema2.getField(i).getType()));\n+    }\n+    return builder.build();\n+  }\n+\n+  static FieldType widenNullableTypes(FieldType fieldType1, FieldType fieldType2) {\n+    if (fieldType1.getTypeName() != fieldType2.getTypeName()) {\n+      throw new IllegalArgumentException(\n+          \"Cannot merge two types: \"\n+              + fieldType1.getTypeName()\n+              + \" and \"\n+              + fieldType2.getTypeName());\n+    }\n+\n+    FieldType result;\n+    switch (fieldType1.getTypeName()) {\n+      case ROW:\n+        result =\n+            FieldType.row(\n+                mergeWideningNullable(fieldType1.getRowSchema(), fieldType2.getRowSchema()));\n+        break;\n+      case ARRAY:\n+        FieldType arrayElementType =\n+            widenNullableTypes(\n+                fieldType1.getCollectionElementType(), fieldType2.getCollectionElementType());\n+        result = FieldType.array(arrayElementType);\n+        break;\n+      case ITERABLE:\n+        FieldType iterableElementType =\n+            widenNullableTypes(\n+                fieldType1.getCollectionElementType(), fieldType2.getCollectionElementType());\n+        result = FieldType.iterable(iterableElementType);\n+        break;\n+      case MAP:\n+        FieldType keyType =\n+            widenNullableTypes(fieldType1.getMapKeyType(), fieldType2.getMapKeyType());\n+        FieldType valueType =\n+            widenNullableTypes(fieldType1.getMapValueType(), fieldType2.getMapValueType());\n+        result = FieldType.map(keyType, valueType);\n+        break;\n+      case LOGICAL_TYPE:\n+        if (!fieldType1\n+            .getLogicalType()\n+            .getIdentifier()\n+            .equals(fieldType2.getLogicalType().getIdentifier())) {\n+          throw new IllegalArgumentException(\n+              \"Logical types don't match and cannot be merged: \"\n+                  + fieldType1.getLogicalType().getIdentifier()\n+                  + \".v.s\"\n+                  + fieldType2.getLogicalType().getIdentifier());\n+        }\n+        // fall through\n+      default:\n+        result = fieldType1;\n+    }\n+    return result.withNullable(fieldType1.getNullable() || fieldType2.getNullable());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1NDcxOQ=="}, "originalCommit": {"oid": "789664619f034a4cce70a2e1479f9704a13eed26"}, "originalPosition": 99}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1609, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}