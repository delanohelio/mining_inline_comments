{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NzU1Njcw", "number": 11296, "title": "[BEAM-9640] Sketching watermark tracking on FnApiRunner", "bodyText": "r: @robertwb\nThis change adds an initial 'sketch' of watermark tracking to the batch runner. Watermark tracking is done like so:\n\nIf a PCollection has a delayed application, its watermark will be held at MIN_WATERMARK.\nIf a PTransform has a channel split, its input PCollection's watermark will be held at MIN_WATERMARK\nFor timers, an 'input pcollection' node is created for each timer family to be consumed by a transform. If a bundle execution returns a timer set at time X, the input PCollection for that timer family will be held at X. This will hold back the downstream watermarks from the stage.\n\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\nTypescript\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-04-02T18:48:37Z", "url": "https://github.com/apache/beam/pull/11296", "merged": true, "mergeCommit": {"oid": "de29bc5ebfafec583eea0101acf8fc3d14554ec5"}, "closed": true, "closedAt": "2021-06-09T17:58:12Z", "author": {"login": "pabloem"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcUF_f5gBqjMxOTc3MDUyOTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABee2LFlAH2gAyMzk3NzU1NjcwOjcyNDZkZjQ5ODI5ZDRhNTI1MDFlMzEwZWY3NWRlZGM1YmU3MzFmMzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ef9062186f757bfde94501af4b6cc5c72230fd5e", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/ef9062186f757bfde94501af4b6cc5c72230fd5e", "committedDate": "2020-04-02T18:47:07Z", "message": "Sketching watermark support"}, "afterCommit": {"oid": "2797d988cf036e97f21dc123d4220c780e1dda2f", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/2797d988cf036e97f21dc123d4220c780e1dda2f", "committedDate": "2020-04-03T19:22:51Z", "message": "[BEAM-9640] Sketching watermark support for bundle executions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2797d988cf036e97f21dc123d4220c780e1dda2f", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/2797d988cf036e97f21dc123d4220c780e1dda2f", "committedDate": "2020-04-03T19:22:51Z", "message": "[BEAM-9640] Sketching watermark support for bundle executions"}, "afterCommit": {"oid": "694c8e1116c16e793ebbf34bf5b9c4e30d344990", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/694c8e1116c16e793ebbf34bf5b9c4e30d344990", "committedDate": "2020-04-03T19:45:41Z", "message": "[BEAM-9640] Sketching watermark support for bundle executions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "694c8e1116c16e793ebbf34bf5b9c4e30d344990", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/694c8e1116c16e793ebbf34bf5b9c4e30d344990", "committedDate": "2020-04-03T19:45:41Z", "message": "[BEAM-9640] Sketching watermark support for bundle executions"}, "afterCommit": {"oid": "d14c2194bf3fc866260ce8c741ad8c909d93a352", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/d14c2194bf3fc866260ce8c741ad8c909d93a352", "committedDate": "2020-04-22T17:20:44Z", "message": "[BEAM-9640] Sketching watermark tracking on FnApiRunner."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d14c2194bf3fc866260ce8c741ad8c909d93a352", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/d14c2194bf3fc866260ce8c741ad8c909d93a352", "committedDate": "2020-04-22T17:20:44Z", "message": "[BEAM-9640] Sketching watermark tracking on FnApiRunner."}, "afterCommit": {"oid": "94ca0b0d7aa89b54491895433dcf5f010f272c4f", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/94ca0b0d7aa89b54491895433dcf5f010f272c4f", "committedDate": "2020-04-22T21:08:29Z", "message": "[BEAM-9640] Sketching watermark tracking on FnApiRunner."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94ca0b0d7aa89b54491895433dcf5f010f272c4f", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/94ca0b0d7aa89b54491895433dcf5f010f272c4f", "committedDate": "2020-04-22T21:08:29Z", "message": "[BEAM-9640] Sketching watermark tracking on FnApiRunner."}, "afterCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/8a0a4c22e83b1f95680f53a1148439d2ed02286e", "committedDate": "2020-04-22T21:17:31Z", "message": "[BEAM-9640] Sketching watermark tracking on FnApiRunner."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTMwMzEx", "url": "https://github.com/apache/beam/pull/11296#pullrequestreview-406130311", "createdAt": "2020-05-05T20:27:56Z", "commit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDoyNzo1NlrOGQ6S8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToxMzo0M1rOGQ7yzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NTUyMw==", "bodyText": "Different transforms may have different input/output buffers associated with them. Perhaps name this input_transform_to_buffer_id or buffer_id_by_consumer or similar.", "url": "https://github.com/apache/beam/pull/11296#discussion_r420385523", "createdAt": "2020-05-05T20:27:56Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -296,6 +297,12 @@ def __init__(self,\n     self.safe_coders = safe_coders\n     self.data_channel_coders = data_channel_coders\n \n+    self.transform_id_to_buffer_id = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4ODA4OQ==", "bodyText": "Are these fired_timers, or timers_to_fire?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420388089", "createdAt": "2020-05-05T20:32:40Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -363,16 +387,17 @@ def _run_bundle_multiple_times_for_testing(\n       finally:\n         runner_execution_context.state_servicer.restore()\n \n+  @staticmethod\n   def _collect_written_timers_and_add_to_fired_timers(\n-      self,\n       bundle_context_manager,  # type: execution.BundleContextManager\n       fired_timers  # type: Dict[Tuple[str, str], ListBuffer]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5NzAyOQ==", "bodyText": "Set of PCollection ids? Buffer ids?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420397029", "createdAt": "2020-05-05T20:49:13Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -384,13 +409,25 @@ def _collect_written_timers_and_add_to_fired_timers(\n         out = create_OutputStream()\n         for decoded_timer in timers_by_key_and_window.values():\n           timer_coder_impl.encode_to_stream(decoded_timer, out, True)\n+          if (transform_id, timer_family_id) not in timer_watermark_data:\n+            timer_watermark_data[(transform_id,\n+                                  timer_family_id)] = timestamp.MAX_TIMESTAMP\n+          timer_watermark_data[(transform_id, timer_family_id)] = min(\n+              timer_watermark_data[(transform_id, timer_family_id)],\n+              decoded_timer.fire_timestamp)\n         fired_timers[(transform_id, timer_family_id)] = ListBuffer(\n             coder_impl=timer_coder_impl)\n         fired_timers[(transform_id, timer_family_id)].append(out.get())\n         written_timers.clear()\n \n+    return timer_watermark_data\n+\n   def _add_sdk_delayed_applications_to_deferred_inputs(\n       self, bundle_context_manager, bundle_result, deferred_inputs):\n+    # type: (...) -> Set[str]\n+\n+    \"\"\"Returns a set of PCollections with delayed applications.\"\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5OTMyMQ==", "bodyText": "Leftover debugging?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420399321", "createdAt": "2020-05-05T20:53:27Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMDIwOQ==", "bodyText": "list(self.producers) (Also, won't this give double brackets?) Also, '<' is unmatched and not typically for string representations.", "url": "https://github.com/apache/beam/pull/11296#discussion_r420400209", "createdAt": "2020-05-05T20:54:59Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMDgzOQ==", "bodyText": "What about self._watermark = 0?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420400839", "createdAt": "2020-05-05T20:56:03Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMjM5NA==", "bodyText": "Does initializing this hear mean that we never use the watermark of the producers. (I have to admit, I'm not quite understanding why the watermark of a PCollection would ever be different than that of its producers.)", "url": "https://github.com/apache/beam/pull/11296#discussion_r420402394", "createdAt": "2020-05-05T20:58:49Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMjc2MQ==", "bodyText": "side inputs and timers all have this effect, right?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420402761", "createdAt": "2020-05-05T20:59:29Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMzQ3Ng==", "bodyText": "Nit: return min(...)", "url": "https://github.com/apache/beam/pull/11296#discussion_r420403476", "createdAt": "2020-05-05T21:00:39Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNDA0NA==", "bodyText": "I suppose timers are considered an input?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420404044", "createdAt": "2020-05-05T21:01:53Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNTUyMQ==", "bodyText": "This doesn't seem right, the input watermarks should always be an upper bound on the output watermark.", "url": "https://github.com/apache/beam/pull/11296#discussion_r420405521", "createdAt": "2020-05-05T21:04:42Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)\n+      return w\n+\n+    def input_watermark(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNzU0Mg==", "bodyText": "Should we change IMPULSE_BUFFER to conform to the spec of all other buffer ids rather than branching on it? (Or at least push this branch into split_buffer_id)?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420407542", "createdAt": "2020-05-05T21:08:42Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)\n+      return w\n+\n+    def input_watermark(self):\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      # 1. Get stage inputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwOTQ0Ng==", "bodyText": "This doesn't seem to take into account data that's \"in flight.\" E.g. all the input watermarks could be at max-timestamp, but that doesn't mean that all the inputs' data has been consumed.", "url": "https://github.com/apache/beam/pull/11296#discussion_r420409446", "createdAt": "2020-05-05T21:12:27Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxMDA2MA==", "bodyText": "Nit: (here and below): elide unneeded intermediate assignments and just chain.", "url": "https://github.com/apache/beam/pull/11296#discussion_r420410060", "createdAt": "2020-05-05T21:13:43Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)\n+      return w\n+\n+    def input_watermark(self):\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      # 1. Get stage inputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:\n+            pcoll_name = transform.unique_name\n+          else:\n+            _, pcoll_name = split_buffer_id(buffer_id)\n+          if pcoll_name not in self._watermarks_by_name:\n+            self._watermarks_by_name[\n+                pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+          stage_node.inputs.add(self._watermarks_by_name[pcoll_name])\n+\n+      # 2. Get stage timers, and add them as inputs to the stage.\n+      for transform in s.transforms:\n+        if transform.spec.urn in translations.PAR_DO_URNS:\n+          payload = proto_utils.parse_Bytes(\n+              transform.spec.payload, beam_runner_api_pb2.ParDoPayload)\n+          for timer_family_id in payload.timer_family_specs.keys():\n+            timer_pcoll_name = (transform.unique_name, timer_family_id)\n+            self._watermarks_by_name[\n+                timer_pcoll_name] = WatermarkManager.PCollectionNode(\n+                    timer_pcoll_name)\n+            stage_node.inputs.add(self._watermarks_by_name[timer_pcoll_name])\n+\n+      # 3. Get stage outputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add stage as their producer\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_OUTPUT_URN:\n+          buffer_id = transform.spec.payload\n+          _, pcoll_name = split_buffer_id(buffer_id)\n+          if pcoll_name not in self._watermarks_by_name:\n+            self._watermarks_by_name[\n+                pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+          self._watermarks_by_name[pcoll_name].producers.add(stage_node)\n+\n+      # 4. Get stage side inputs, create nodes for them, add to\n+      #    _watermarks_by_name, and add them as side inputs of the stage.\n+      for pcoll_name in s.side_inputs():\n+        if pcoll_name not in self._watermarks_by_name:\n+          self._watermarks_by_name[\n+              pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+        stage_node.side_inputs.add(self._watermarks_by_name[pcoll_name])\n+\n+  def get_node(self, name):\n+    # type: (str) -> WatermarkNode\n+    return self._watermarks_by_name[name]\n+\n+  def get_watermark(self, name):\n+    element = self._watermarks_by_name[name]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 150}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/8a0a4c22e83b1f95680f53a1148439d2ed02286e", "committedDate": "2020-04-22T21:17:31Z", "message": "[BEAM-9640] Sketching watermark tracking on FnApiRunner."}, "afterCommit": {"oid": "212b35a040add45cc808d95e5024e173381e437e", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/212b35a040add45cc808d95e5024e173381e437e", "committedDate": "2021-01-26T22:28:41Z", "message": "[BEAM-9640] Sketching watermark tracking on FnApiRunner."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "212b35a040add45cc808d95e5024e173381e437e", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/212b35a040add45cc808d95e5024e173381e437e", "committedDate": "2021-01-26T22:28:41Z", "message": "[BEAM-9640] Sketching watermark tracking on FnApiRunner."}, "afterCommit": {"oid": "7820b43a39a35bbc044c91be0cdeb4fd99952c2c", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/7820b43a39a35bbc044c91be0cdeb4fd99952c2c", "committedDate": "2021-02-01T23:20:41Z", "message": "Fixups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7820b43a39a35bbc044c91be0cdeb4fd99952c2c", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/7820b43a39a35bbc044c91be0cdeb4fd99952c2c", "committedDate": "2021-02-01T23:20:41Z", "message": "Fixups"}, "afterCommit": {"oid": "a8d8b0802dd4e96abe36011ae6856b776e9f0f13", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/a8d8b0802dd4e96abe36011ae6856b776e9f0f13", "committedDate": "2021-02-02T05:37:29Z", "message": "Fixups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a8d8b0802dd4e96abe36011ae6856b776e9f0f13", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/a8d8b0802dd4e96abe36011ae6856b776e9f0f13", "committedDate": "2021-02-02T05:37:29Z", "message": "Fixups"}, "afterCommit": {"oid": "441a2a885cfbb87939503c8fc2bdbf6833fbf683", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/441a2a885cfbb87939503c8fc2bdbf6833fbf683", "committedDate": "2021-02-02T19:41:47Z", "message": "Fixups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "441a2a885cfbb87939503c8fc2bdbf6833fbf683", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/441a2a885cfbb87939503c8fc2bdbf6833fbf683", "committedDate": "2021-02-02T19:41:47Z", "message": "Fixups"}, "afterCommit": {"oid": "75b713e6050d44c64bb692abf1d2d76352eb4e46", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/75b713e6050d44c64bb692abf1d2d76352eb4e46", "committedDate": "2021-02-02T20:04:49Z", "message": "Fixups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "75b713e6050d44c64bb692abf1d2d76352eb4e46", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/75b713e6050d44c64bb692abf1d2d76352eb4e46", "committedDate": "2021-02-02T20:04:49Z", "message": "Fixups"}, "afterCommit": {"oid": "5c59afdb0b3d6aa8540918bb403883270d03bc8d", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/5c59afdb0b3d6aa8540918bb403883270d03bc8d", "committedDate": "2021-02-03T02:06:08Z", "message": "Fixups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cbd391c65abf1004ae86c66c6622b024a777cb84", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/cbd391c65abf1004ae86c66c6622b024a777cb84", "committedDate": "2021-02-04T20:33:05Z", "message": "Fixing output watermark for stages"}, "afterCommit": {"oid": "47812550c99efe4aa4b620e88760132b91df2871", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/47812550c99efe4aa4b620e88760132b91df2871", "committedDate": "2021-02-04T20:34:59Z", "message": "Fixing output watermark for stages"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "68e0101e0fe37238b6070bb9168e6a07a1d7e931", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/68e0101e0fe37238b6070bb9168e6a07a1d7e931", "committedDate": "2021-02-04T22:59:05Z", "message": "Moving visualization tools to different file"}, "afterCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/aadbef039e830df75473b5925a82897f85f9949b", "committedDate": "2021-02-04T23:49:53Z", "message": "Moving visualization tools to different file"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAxMzAwMDg5", "url": "https://github.com/apache/beam/pull/11296#pullrequestreview-601300089", "createdAt": "2021-03-02T00:30:45Z", "commit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMDozMDo0NVrOIuDGXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMToxMjo0N1rOIuEHUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1NjE4OQ==", "bodyText": "Should this be a return value as well?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585156189", "createdAt": "2021-03-02T00:30:45Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -391,16 +419,22 @@ def _run_bundle_multiple_times_for_testing(\n       finally:\n         runner_execution_context.state_servicer.restore()\n \n-  def _collect_written_timers_and_add_to_fired_timers(\n-      self,\n-      bundle_context_manager,  # type: execution.BundleContextManager\n-      fired_timers  # type: Dict[Tuple[str, str], ListBuffer]\n-  ):\n-    # type: (...) -> None\n-\n+  @staticmethod\n+  def _collect_written_timers(\n+      bundle_context_manager: execution.BundleContextManager,\n+      newly_set_timers: Dict[Tuple[str, str], ListBuffer],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1NjI0MA==", "bodyText": "What does it return?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585156240", "createdAt": "2021-03-02T00:30:53Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -391,16 +419,22 @@ def _run_bundle_multiple_times_for_testing(\n       finally:\n         runner_execution_context.state_servicer.restore()\n \n-  def _collect_written_timers_and_add_to_fired_timers(\n-      self,\n-      bundle_context_manager,  # type: execution.BundleContextManager\n-      fired_timers  # type: Dict[Tuple[str, str], ListBuffer]\n-  ):\n-    # type: (...) -> None\n-\n+  @staticmethod\n+  def _collect_written_timers(\n+      bundle_context_manager: execution.BundleContextManager,\n+      newly_set_timers: Dict[Tuple[str, str], ListBuffer],\n+  ) -> Dict[Tuple[str, str], timestamp.Timestamp]:\n+    \"\"\"Review output buffers, and collect written timers.\n+\n+    This function reviews a stage that has just been run. The stage will have\n+    written timers to its output buffers. The function then takes the timers,\n+    and adds them to the `newly_set_timers` dictionary.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1NzA3NA==", "bodyText": "More flexibly, you could do only_element(transform.values())", "url": "https://github.com/apache/beam/pull/11296#discussion_r585157074", "createdAt": "2021-03-02T00:33:21Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -414,26 +448,50 @@ def _collect_written_timers_and_add_to_fired_timers(\n           # Only add not cleared timer to fired timers.\n           if not decoded_timer.clear_bit:\n             timer_coder_impl.encode_to_stream(decoded_timer, out, True)\n-        fired_timers[(transform_id, timer_family_id)] = ListBuffer(\n+            if (transform_id, timer_family_id) not in timer_watermark_data:\n+              timer_watermark_data[(transform_id,\n+                                    timer_family_id)] = timestamp.MAX_TIMESTAMP\n+            timer_watermark_data[(transform_id, timer_family_id)] = min(\n+                timer_watermark_data[(transform_id, timer_family_id)],\n+                decoded_timer.fire_timestamp)\n+        newly_set_timers[(transform_id, timer_family_id)] = ListBuffer(\n             coder_impl=timer_coder_impl)\n-        fired_timers[(transform_id, timer_family_id)].append(out.get())\n+        newly_set_timers[(transform_id, timer_family_id)].append(out.get())\n         written_timers.clear()\n \n+    return timer_watermark_data\n+\n   def _add_sdk_delayed_applications_to_deferred_inputs(\n       self,\n       bundle_context_manager,  # type: execution.BundleContextManager\n       bundle_result,  # type: beam_fn_api_pb2.InstructionResponse\n       deferred_inputs  # type: MutableMapping[str, execution.PartitionableBuffer]\n   ):\n-    # type: (...) -> None\n+    # type: (...) -> Set[str]\n+\n+    \"\"\"Returns a set of PCollection IDs of PColls having delayed applications.\n+\n+    This transform inspects the bundle_context_manager, and bundle_result\n+    objects, and adds all deferred inputs to the deferred_inputs object.\n+    \"\"\"\n+    pcolls_with_delayed_apps = set()\n     for delayed_application in bundle_result.process_bundle.residual_roots:\n-      name = bundle_context_manager.input_for(\n+      producer_name = bundle_context_manager.input_for(\n           delayed_application.application.transform_id,\n           delayed_application.application.input_id)\n-      if name not in deferred_inputs:\n-        deferred_inputs[name] = ListBuffer(\n-            coder_impl=bundle_context_manager.get_input_coder_impl(name))\n-      deferred_inputs[name].append(delayed_application.application.element)\n+      if producer_name not in deferred_inputs:\n+        deferred_inputs[producer_name] = ListBuffer(\n+            coder_impl=bundle_context_manager.get_input_coder_impl(\n+                producer_name))\n+      deferred_inputs[producer_name].append(\n+          delayed_application.application.element)\n+\n+      transform = bundle_context_manager.process_bundle_descriptor.transforms[\n+          producer_name]\n+      # We take the output with tag 'out' from the producer transform. The\n+      # producer transform is a GRPC read, and it has a single output.\n+      pcolls_with_delayed_apps.add(transform.outputs['out'])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1OTE5OA==", "bodyText": "Any reason not to make this a dependency? (E.g. is it fairly large?)", "url": "https://github.com/apache/beam/pull/11296#discussion_r585159198", "createdAt": "2021-03-02T00:38:44Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/visualization_tools.py", "diffHunk": "@@ -0,0 +1,115 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Set of utilities to visualize a pipeline to be executed by FnApiRunner.\"\"\"\n+from typing import Set\n+from typing import Tuple\n+\n+from apache_beam.runners.portability.fn_api_runner.translations import Stage\n+from apache_beam.runners.portability.fn_api_runner.watermark_manager import WatermarkManager\n+\n+\n+def show_stage(stage: Stage):\n+  try:\n+    import graphviz\n+  except ImportError:\n+    import warnings\n+    warnings.warn('Unable to draw pipeline. graphviz library missing.')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MDM5NQ==", "bodyText": "OK.", "url": "https://github.com/apache/beam/pull/11296#discussion_r585160395", "createdAt": "2021-03-02T00:42:03Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMjc2MQ=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MTE3NA==", "bodyText": "I'm trying to understand when node.watermark() vs. node.upstream_watermark() would be used. It seems we'd always want the output watermark of our predecessors as our input watermark.", "url": "https://github.com/apache/beam/pull/11296#discussion_r585161174", "createdAt": "2021-03-02T00:44:16Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,199 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Any\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no output watermark %s' % self)\n+\n+    def input_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no input watermark %s' % self)\n+\n+    def watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no own watermark %s' % self)\n+\n+    def upstream_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no upstream watermark %s' % self)\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MjU2Mg==", "bodyText": "Didn't we just assert that above?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585162562", "createdAt": "2021-03-02T00:47:44Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,199 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Any\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no output watermark %s' % self)\n+\n+    def input_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no input watermark %s' % self)\n+\n+    def watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no own watermark %s' % self)\n+\n+    def upstream_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no upstream watermark %s' % self)\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name: Dict[Any,\n+                                   Union[\n+                                       WatermarkManager.StageNode,\n+                                       WatermarkManager.PCollectionNode]] = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._watermarks_by_name:\n+          self._watermarks_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._watermarks_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        node = self._watermarks_by_name[pcname]\n+        assert isinstance(node, WatermarkManager.PCollectionNode)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2NDA1Nw==", "bodyText": "OK, well let's at least unify this logic, i.e.\nif buffer_id == translations.IMPULSE_BUFFER\n  pcoll_name = transform.unique_name\nelse:\n  _, pcoll_name = split_buffer_id(buffer_id)\nadd_pcollection(pcoll_name, stage_node)\n\nrather than adding a continue. (We could also inline add_pcollection, for consistency, as it's not used elsewhere.)", "url": "https://github.com/apache/beam/pull/11296#discussion_r585164057", "createdAt": "2021-03-02T00:51:25Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)\n+      return w\n+\n+    def input_watermark(self):\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      # 1. Get stage inputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNzU0Mg=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2NTM1OA==", "bodyText": "get/set watermark is never used on stage nodes, right? Does it make sense to keep them in the same dictionary?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585165358", "createdAt": "2021-03-02T00:55:06Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,199 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Any\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no output watermark %s' % self)\n+\n+    def input_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no input watermark %s' % self)\n+\n+    def watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no own watermark %s' % self)\n+\n+    def upstream_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no upstream watermark %s' % self)\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name: Dict[Any,\n+                                   Union[\n+                                       WatermarkManager.StageNode,\n+                                       WatermarkManager.PCollectionNode]] = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._watermarks_by_name:\n+          self._watermarks_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._watermarks_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        node = self._watermarks_by_name[pcname]\n+        assert isinstance(node, WatermarkManager.PCollectionNode)\n+        return node\n+\n+      # 1. Get stage inputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:\n+            pcoll_name = transform.unique_name\n+            add_pcollection(pcoll_name, stage_node)\n+            continue\n+          else:\n+            _, pcoll_name = split_buffer_id(buffer_id)\n+          add_pcollection(pcoll_name, stage_node)\n+\n+      # 2. Get stage timers, and add them as inputs to the stage.\n+      for transform in s.transforms:\n+        if transform.spec.urn in translations.PAR_DO_URNS:\n+          payload = proto_utils.parse_Bytes(\n+              transform.spec.payload, beam_runner_api_pb2.ParDoPayload)\n+          for timer_family_id in payload.timer_family_specs.keys():\n+            timer_pcoll_name = (transform.unique_name, timer_family_id)\n+            self._watermarks_by_name[\n+                timer_pcoll_name] = WatermarkManager.PCollectionNode(\n+                    timer_pcoll_name)\n+            timer_pcoll_node = self._watermarks_by_name[timer_pcoll_name]\n+            assert isinstance(\n+                timer_pcoll_node, WatermarkManager.PCollectionNode)\n+            stage_node.inputs.add(timer_pcoll_node)\n+\n+      # 3. Get stage outputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add stage as their producer\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_OUTPUT_URN:\n+          buffer_id = transform.spec.payload\n+          _, pcoll_name = split_buffer_id(buffer_id)\n+          if pcoll_name not in self._watermarks_by_name:\n+            self._watermarks_by_name[\n+                pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+          pcoll_node = self._watermarks_by_name[pcoll_name]\n+          assert isinstance(pcoll_node, WatermarkManager.PCollectionNode)\n+          pcoll_node.producers.add(stage_node)\n+          stage_node.outputs.add(pcoll_node)\n+\n+      # 4. Get stage side inputs, create nodes for them, add to\n+      #    _watermarks_by_name, and add them as side inputs of the stage.\n+      for pcoll_name in s.side_inputs():\n+        if pcoll_name not in self._watermarks_by_name:\n+          self._watermarks_by_name[\n+              pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+        pcoll_node = self._watermarks_by_name[pcoll_name]\n+        assert isinstance(pcoll_node, WatermarkManager.PCollectionNode)\n+        stage_node.side_inputs.add(pcoll_node)\n+\n+  def get_node(self, name):\n+    # type: (str) -> Union[PCollectionNode, StageNode]\n+    return self._watermarks_by_name[name]\n+\n+  def get_watermark(self, name) -> timestamp.Timestamp:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE3MDUwNw==", "bodyText": "I'll admit I have a hard time keeping the exact ordering here in my head. E.g. is expected_timers in this set? In which of the loops above could updates[pcoll_id] have been set?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585170507", "createdAt": "2021-03-02T01:07:30Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -570,18 +661,76 @@ def merge_results(last_result):\n \n     return final_result\n \n+  @staticmethod\n+  def _build_watermark_updates(\n+      runner_execution_context,  # type: execution.FnApiRunnerExecutionContext\n+      stage_inputs,  # type: Iterable[str]\n+      expected_timers,  # type: Iterable[translations.TimerFamilyId]\n+      pcolls_with_da,  # type: Set[str]\n+      transforms_w_splits,  # type: Set[str]\n+      watermarks_by_transform_and_timer_family  # type: Dict[translations.TimerFamilyId, timestamp.Timestamp]\n+  ) -> Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]:\n+    \"\"\"Builds a dictionary of PCollection (or TimerFamilyId) to timestamp.\n+\n+    Args:\n+      stage_inputs: represent the set of expected input PCollections for a stage\n+      expected_timers: represent the set of TimerFamilyIds that the stage can\n+        expect to receive as inputs.\n+      pcolls_with_da: represent the set of stage input PCollections that had\n+        delayed applications.\n+      transforms_w_splits: represent the set of transforms in the stage that had\n+        input splits.\n+      watermarks_by_transform_and_timer_family: represent the set of watermark\n+        holds to be added for each timer family.\n+    \"\"\"\n+    updates = {\n+    }  # type: Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]\n+\n+    def get_pcoll_id(transform_id):\n+      buffer_id = runner_execution_context.input_transform_to_buffer_id[\n+          transform_id]\n+      # For IMPULSE-reading transforms, we use the transform name as buffer id.\n+      if buffer_id == translations.IMPULSE_BUFFER:\n+        pcollection_id = transform_id\n+      else:\n+        _, pcollection_id = translations.split_buffer_id(buffer_id)\n+      return pcollection_id\n+\n+    for pcoll in pcolls_with_da:\n+      updates[pcoll] = timestamp.MIN_TIMESTAMP\n+\n+    for tr in transforms_w_splits:\n+      pcoll_id = get_pcoll_id(tr)\n+      updates[pcoll_id] = timestamp.MIN_TIMESTAMP\n+\n+    for timer_pcoll_id, ts in watermarks_by_transform_and_timer_family.items():\n+      if timer_pcoll_id not in updates:\n+        updates[timer_pcoll_id] = timestamp.MAX_TIMESTAMP\n+      updates[timer_pcoll_id] = min(ts, updates[timer_pcoll_id])\n+\n+    for timer_pcoll_id in expected_timers:\n+      if timer_pcoll_id not in updates:\n+        updates[timer_pcoll_id] = timestamp.MAX_TIMESTAMP\n+\n+    for input in stage_inputs:\n+      pcoll_id = get_pcoll_id(input)\n+      if pcoll_id not in updates:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE3MjgxOA==", "bodyText": "It might be simpler to do something like\nfor timer_pcoll_id in expected_timers:\n  updates[timer_pcoll_id] = watermarks_by_transform_and_timer_family.get(\n      timestamp.MAX_TIMESTAMP)\n\nthan these two loops here. Or could timer_pcoll_id be in pcolls_with_da and/or transforms_w_splits?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585172818", "createdAt": "2021-03-02T01:12:47Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -570,18 +661,76 @@ def merge_results(last_result):\n \n     return final_result\n \n+  @staticmethod\n+  def _build_watermark_updates(\n+      runner_execution_context,  # type: execution.FnApiRunnerExecutionContext\n+      stage_inputs,  # type: Iterable[str]\n+      expected_timers,  # type: Iterable[translations.TimerFamilyId]\n+      pcolls_with_da,  # type: Set[str]\n+      transforms_w_splits,  # type: Set[str]\n+      watermarks_by_transform_and_timer_family  # type: Dict[translations.TimerFamilyId, timestamp.Timestamp]\n+  ) -> Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]:\n+    \"\"\"Builds a dictionary of PCollection (or TimerFamilyId) to timestamp.\n+\n+    Args:\n+      stage_inputs: represent the set of expected input PCollections for a stage\n+      expected_timers: represent the set of TimerFamilyIds that the stage can\n+        expect to receive as inputs.\n+      pcolls_with_da: represent the set of stage input PCollections that had\n+        delayed applications.\n+      transforms_w_splits: represent the set of transforms in the stage that had\n+        input splits.\n+      watermarks_by_transform_and_timer_family: represent the set of watermark\n+        holds to be added for each timer family.\n+    \"\"\"\n+    updates = {\n+    }  # type: Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]\n+\n+    def get_pcoll_id(transform_id):\n+      buffer_id = runner_execution_context.input_transform_to_buffer_id[\n+          transform_id]\n+      # For IMPULSE-reading transforms, we use the transform name as buffer id.\n+      if buffer_id == translations.IMPULSE_BUFFER:\n+        pcollection_id = transform_id\n+      else:\n+        _, pcollection_id = translations.split_buffer_id(buffer_id)\n+      return pcollection_id\n+\n+    for pcoll in pcolls_with_da:\n+      updates[pcoll] = timestamp.MIN_TIMESTAMP\n+\n+    for tr in transforms_w_splits:\n+      pcoll_id = get_pcoll_id(tr)\n+      updates[pcoll_id] = timestamp.MIN_TIMESTAMP\n+\n+    for timer_pcoll_id, ts in watermarks_by_transform_and_timer_family.items():", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 310}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d73b4f2780b76ec0c54e76906162f13cf019a317", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/d73b4f2780b76ec0c54e76906162f13cf019a317", "committedDate": "2021-03-02T21:09:28Z", "message": "[BEAM-9640] Sketching watermark tracking on FnApiRunner."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c8d225f74eb342903e4058ab45172af38b1df33", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/9c8d225f74eb342903e4058ab45172af38b1df33", "committedDate": "2021-03-02T21:09:31Z", "message": "Addressing some comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9166a9ba000fb6c1938777293c62bde5508d74d0", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/9166a9ba000fb6c1938777293c62bde5508d74d0", "committedDate": "2021-03-02T21:09:31Z", "message": "Fixups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1835293589fc1e00b786554afe9e82c0e7a3b226", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/1835293589fc1e00b786554afe9e82c0e7a3b226", "committedDate": "2021-03-02T21:09:32Z", "message": "fixing bug with truncation of restrictions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6e4dbcd82b9990e5e4b0581cf1dc040d37c5781", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/d6e4dbcd82b9990e5e4b0581cf1dc040d37c5781", "committedDate": "2021-03-02T21:09:32Z", "message": "Fixing output watermark for stages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b379f9a7c7cf30eab4ee03160b8d32c3d96b0cf5", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/b379f9a7c7cf30eab4ee03160b8d32c3d96b0cf5", "committedDate": "2021-03-02T21:09:32Z", "message": "Moving visualization tools to different file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fba6e70183920dd942b00d5e18dc2868cada7a3d", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/fba6e70183920dd942b00d5e18dc2868cada7a3d", "committedDate": "2021-03-02T21:09:32Z", "message": "Addressing comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "804c769cb26c47cca35a71498d7dbbc18d825d47", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/804c769cb26c47cca35a71498d7dbbc18d825d47", "committedDate": "2021-03-02T21:06:58Z", "message": "Fix lint"}, "afterCommit": {"oid": "7c0e075ce00a2f0e822508137cb1d5e639762082", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/7c0e075ce00a2f0e822508137cb1d5e639762082", "committedDate": "2021-03-02T21:09:32Z", "message": "Fix lint"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7c0e075ce00a2f0e822508137cb1d5e639762082", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/7c0e075ce00a2f0e822508137cb1d5e639762082", "committedDate": "2021-03-02T21:09:32Z", "message": "Fix lint"}, "afterCommit": {"oid": "109f6efc9c83bd1de4ef2f89a448f66121280c5e", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/109f6efc9c83bd1de4ef2f89a448f66121280c5e", "committedDate": "2021-03-02T21:20:21Z", "message": "Fix lint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/e6dd9ed056df91737b117eff4443a09a9054cd7c", "committedDate": "2021-03-02T21:30:12Z", "message": "Fix lint"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "109f6efc9c83bd1de4ef2f89a448f66121280c5e", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/109f6efc9c83bd1de4ef2f89a448f66121280c5e", "committedDate": "2021-03-02T21:20:21Z", "message": "Fix lint"}, "afterCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/e6dd9ed056df91737b117eff4443a09a9054cd7c", "committedDate": "2021-03-02T21:30:12Z", "message": "Fix lint"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2MTAzNjIx", "url": "https://github.com/apache/beam/pull/11296#pullrequestreview-636103621", "createdAt": "2021-04-14T21:40:45Z", "commit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNFQyMTo0MDo0NVrOJJLfYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xOVQxOTozNDo0OFrOJLlQ_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzYwNTIxOQ==", "bodyText": "clean up?", "url": "https://github.com/apache/beam/pull/11296#discussion_r613605219", "createdAt": "2021-04-14T21:40:45Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -588,6 +589,13 @@ def __init__(self,\n     self.safe_coders = safe_coders\n     self.data_channel_coders = data_channel_coders\n \n+    self.input_transform_to_buffer_id = {\n+        t.unique_name: t.spec.payload\n+        for s in stages for t in s.transforms\n+        if t.spec.urn == bundle_processor.DATA_INPUT_URN\n+    }\n+    self.watermark_manager = WatermarkManager(stages)\n+    # self.watermark_manager.show()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzYxMzQxMw==", "bodyText": "output_watermark()?", "url": "https://github.com/apache/beam/pull/11296#discussion_r613613413", "createdAt": "2021-04-14T21:58:05Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -364,10 +368,36 @@ def run_stages(self,\n           bundle_context_manager = execution.BundleContextManager(\n               runner_execution_context, stage, self._num_workers)\n \n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (\n+              'wrong watermark for %s. Expected %s, but got %s.' % (\n+                  runner_execution_context.watermark_manager.get_stage_node(\n+                      bundle_context_manager.stage.name),\n+                  timestamp.MAX_TIMESTAMP,\n+                  runner_execution_context.watermark_manager.get_stage_node(\n+                      bundle_context_manager.stage.name\n+                  ).input_watermark()\n+              )\n+          )\n+\n           stage_results = self._run_stage(\n-              runner_execution_context,\n-              bundle_context_manager,\n+              runner_execution_context, bundle_context_manager)\n+\n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzYxNDA4NQ==", "bodyText": "are the assertions only for batch?", "url": "https://github.com/apache/beam/pull/11296#discussion_r613614085", "createdAt": "2021-04-14T21:59:29Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -364,10 +368,36 @@ def run_stages(self,\n           bundle_context_manager = execution.BundleContextManager(\n               runner_execution_context, stage, self._num_workers)\n \n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjA5NTg1Nw==", "bodyText": "I think this should be decoded_timer.hold_timestamp, currently timers will set hold_timestamp to fire_timestamp but I think for watermark we should still use decoded_timer.hold_timestamp which prevents potential breakage from BEAM-11507.", "url": "https://github.com/apache/beam/pull/11296#discussion_r616095857", "createdAt": "2021-04-19T18:54:41Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -424,26 +466,50 @@ def _collect_written_timers_and_add_to_fired_timers(\n           # Only add not cleared timer to fired timers.\n           if not decoded_timer.clear_bit:\n             timer_coder_impl.encode_to_stream(decoded_timer, out, True)\n-        fired_timers[(transform_id, timer_family_id)] = ListBuffer(\n+            if (transform_id, timer_family_id) not in timer_watermark_data:\n+              timer_watermark_data[(transform_id,\n+                                    timer_family_id)] = timestamp.MAX_TIMESTAMP\n+            timer_watermark_data[(transform_id, timer_family_id)] = min(\n+                timer_watermark_data[(transform_id, timer_family_id)],\n+                decoded_timer.fire_timestamp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjEyMTUwMA==", "bodyText": "Should this function declared outside of the loop?", "url": "https://github.com/apache/beam/pull/11296#discussion_r616121500", "createdAt": "2021-04-19T19:29:07Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,171 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class PCollectionNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(object):\n+    def __init__(self, name):\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.name = name\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._pcollections_by_name: Dict[Union[str, translations.TimerFamilyId],\n+                                     WatermarkManager.PCollectionNode] = {}\n+    self._stages_by_name: Dict[str, WatermarkManager.StageNode] = {}\n+\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._stages_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjEyNDE4NA==", "bodyText": "why do we need these assertions immediately after updating the map?", "url": "https://github.com/apache/beam/pull/11296#discussion_r616124184", "createdAt": "2021-04-19T19:33:58Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,171 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class PCollectionNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(object):\n+    def __init__(self, name):\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.name = name\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._pcollections_by_name: Dict[Union[str, translations.TimerFamilyId],\n+                                     WatermarkManager.PCollectionNode] = {}\n+    self._stages_by_name: Dict[str, WatermarkManager.StageNode] = {}\n+\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._stages_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._pcollections_by_name:\n+          self._pcollections_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._pcollections_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        return pcnode\n+\n+      # 1. Get stage inputs, create nodes for them, add to _stages_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:\n+            pcoll_name = transform.unique_name\n+            add_pcollection(pcoll_name, stage_node)\n+            continue\n+          else:\n+            _, pcoll_name = split_buffer_id(buffer_id)\n+          add_pcollection(pcoll_name, stage_node)\n+\n+      # 2. Get stage timers, and add them as inputs to the stage.\n+      for transform in s.transforms:\n+        if transform.spec.urn in translations.PAR_DO_URNS:\n+          payload = proto_utils.parse_Bytes(\n+              transform.spec.payload, beam_runner_api_pb2.ParDoPayload)\n+          for timer_family_id in payload.timer_family_specs.keys():\n+            timer_pcoll_name = (transform.unique_name, timer_family_id)\n+            self._pcollections_by_name[\n+                timer_pcoll_name] = WatermarkManager.PCollectionNode(\n+                    timer_pcoll_name)\n+            timer_pcoll_node = self._pcollections_by_name[timer_pcoll_name]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjEyNDY3MQ==", "bodyText": "ditto", "url": "https://github.com/apache/beam/pull/11296#discussion_r616124671", "createdAt": "2021-04-19T19:34:48Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,171 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class PCollectionNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(object):\n+    def __init__(self, name):\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.name = name\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._pcollections_by_name: Dict[Union[str, translations.TimerFamilyId],\n+                                     WatermarkManager.PCollectionNode] = {}\n+    self._stages_by_name: Dict[str, WatermarkManager.StageNode] = {}\n+\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._stages_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._pcollections_by_name:\n+          self._pcollections_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._pcollections_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        return pcnode\n+\n+      # 1. Get stage inputs, create nodes for them, add to _stages_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:\n+            pcoll_name = transform.unique_name\n+            add_pcollection(pcoll_name, stage_node)\n+            continue\n+          else:\n+            _, pcoll_name = split_buffer_id(buffer_id)\n+          add_pcollection(pcoll_name, stage_node)\n+\n+      # 2. Get stage timers, and add them as inputs to the stage.\n+      for transform in s.transforms:\n+        if transform.spec.urn in translations.PAR_DO_URNS:\n+          payload = proto_utils.parse_Bytes(\n+              transform.spec.payload, beam_runner_api_pb2.ParDoPayload)\n+          for timer_family_id in payload.timer_family_specs.keys():\n+            timer_pcoll_name = (transform.unique_name, timer_family_id)\n+            self._pcollections_by_name[\n+                timer_pcoll_name] = WatermarkManager.PCollectionNode(\n+                    timer_pcoll_name)\n+            timer_pcoll_node = self._pcollections_by_name[timer_pcoll_name]\n+            assert isinstance(\n+                timer_pcoll_node, WatermarkManager.PCollectionNode)\n+            stage_node.inputs.add(timer_pcoll_node)\n+\n+      # 3. Get stage outputs, create nodes for them, add to\n+      # _pcollections_by_name, and add stage as their producer\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_OUTPUT_URN:\n+          buffer_id = transform.spec.payload\n+          _, pcoll_name = split_buffer_id(buffer_id)\n+          if pcoll_name not in self._pcollections_by_name:\n+            self._pcollections_by_name[\n+                pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+          pcoll_node = self._pcollections_by_name[pcoll_name]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a3b924b27763fcc99dcf40790fcbb19d9f43e06", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/7a3b924b27763fcc99dcf40790fcbb19d9f43e06", "committedDate": "2021-05-06T00:24:45Z", "message": "Addressing comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7246df49829d4a52501e310ef75dedc5be731f39", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/7246df49829d4a52501e310ef75dedc5be731f39", "committedDate": "2021-06-08T21:33:06Z", "message": "Fix log message on assertions"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4402, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}