{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2MTcxODk3", "number": 13272, "title": "[BEAM-11207] Metric Extraction via proto RPC API", "bodyText": "This PR is an implementation of the following proposal: https://s.apache.org/get-metrics-api. The ultimate goal is to offer a way to query user metrics after a job. The API follows the design of existing APIs in Python and Java SDKs.\nHow it works from user's perspective:\nresult, _ := beamx.RunPipelineWithMetrics(ctx, p)\nqueryResult := result.Metrics().Query()\nfmt.Println(queryResult.GetCounters())\nfmt.Println(queryResult.GetDistributions())\nfmt.Println(queryResult.GetGauges())\nAn example of output:\n[{1 1 {fn/read/n2/SplitAndSize0:0  }} {20000 20000 {main.counterOperationFn counter-0 counterOperationFn}} {1 1 {fn/read/n1:0  }}]\n[]\n[]\n\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\nTypescript\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-11-05T16:07:26Z", "url": "https://github.com/apache/beam/pull/13272", "merged": true, "mergeCommit": {"oid": "baae15a6e85033b7d32a38daf12bb03a7cc7fe74"}, "closed": true, "closedAt": "2020-11-16T22:27:46Z", "author": {"login": "kamilwu"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZkXpOgH2gAyNTE2MTcxODk3OmZmYjdlZDc5ZjhhNWQxZDJjOTlkMzMyYzExMjZkYzUzNTliOTAyZDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABddMraVgFqTUzMTgzODg1Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3", "author": {"user": {"login": "kamilwu", "name": "Kamil Wasilewski"}}, "url": "https://github.com/apache/beam/commit/ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3", "committedDate": "2020-11-05T15:47:45Z", "message": "wip: Metric Extraction via proto RPC API"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NjkzNjg0", "url": "https://github.com/apache/beam/pull/13272#pullrequestreview-524693684", "createdAt": "2020-11-05T21:40:04Z", "commit": {"oid": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMTo0MDowNFrOHuXuAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMTo0MDowNFrOHuXuAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NTE1Mw==", "bodyText": "Please file a JIRA (https://issues.apache.org/jira/projects/BEAM/issues) under the sdk-go component for this PRs and followup work. Then add the JIRA [BEAM-#####] as a prefix to the PR title.", "url": "https://github.com/apache/beam/pull/13272#discussion_r518385153", "createdAt": "2020-11-05T21:40:04Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,50 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// MetricResults queries for all metric values that match a given filter.\n+type MetricResults interface {\n+\t// TODO: Implement metrics filtering", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NDM3OTY2", "url": "https://github.com/apache/beam/pull/13272#pullrequestreview-525437966", "createdAt": "2020-11-06T19:36:08Z", "commit": {"oid": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxOTozNjowOVrOHu6-Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMzoyNTowNlrOHvAfYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk2MjcyMg==", "bodyText": "Style nit: Consider changing this to a switch case statement.", "url": "https://github.com/apache/beam/pull/13272#discussion_r518962722", "createdAt": "2020-11-06T19:36:09Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/monitoring_infos.go", "diffHunk": "@@ -0,0 +1,211 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(resultsProto *jobpb.MetricResults) (\n+\t[]CounterResult,\n+\t[]DistributionResult,\n+\t[]GaugeResult) {\n+\tac, ad, ag := groupByType(resultsProto.Attempted)\n+\tcc, cd, cg := groupByType(resultsProto.Committed)\n+\n+\tc := mergeCounters(ac, cc)\n+\td := mergeDistributions(ad, cd)\n+\tg := mergeGauges(ag, cg)\n+\n+\treturn c, d, g\n+}\n+\n+// IsCounter returns true if the monitoring info is a counter metric.\n+func IsCounter(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:sum_int64:v1\"\n+}\n+\n+// IsDistribution returns true if the monitoring info is a distribution metric.\n+func IsDistribution(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:distribution_int64:v1\"\n+}\n+\n+// IsGauge returns true if the monitoring info is a gauge metric.\n+func IsGauge(mi *pipepb.MonitoringInfo) bool {\n+\tswitch mi.GetType() {\n+\tcase\n+\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[MetricKey]int64,\n+\tmap[MetricKey]DistributionValue,\n+\tmap[MetricKey]GaugeValue) {\n+\tcounters := make(map[MetricKey]int64)\n+\tdistributions := make(map[MetricKey]DistributionValue)\n+\tgauges := make(map[MetricKey]GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tif IsCounter(minfo) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk2MzY3OA==", "bodyText": "Style nit: Makes it clearer that the only difference between the two clauses is the value of v.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif v, ok := committed[k]; ok {\n          \n          \n            \n            \t\t\tres = append(res, CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n          \n          \n            \n            \t\t} else {\n          \n          \n            \n            \t\t\tres = append(res, CounterResult{Attempted: attempted[k], Committed: -1, Key: k})\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tv, ok := committed[k] \n          \n          \n            \n            \t\tif !ok {\n          \n          \n            \n            \t\t  v = -1\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tres = append(res, CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n          \n      \n    \n    \n  \n\nIf you make this change, please make the change for distributions and gauges below for consistency,", "url": "https://github.com/apache/beam/pull/13272#discussion_r518963678", "createdAt": "2020-11-06T19:38:22Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/monitoring_infos.go", "diffHunk": "@@ -0,0 +1,211 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(resultsProto *jobpb.MetricResults) (\n+\t[]CounterResult,\n+\t[]DistributionResult,\n+\t[]GaugeResult) {\n+\tac, ad, ag := groupByType(resultsProto.Attempted)\n+\tcc, cd, cg := groupByType(resultsProto.Committed)\n+\n+\tc := mergeCounters(ac, cc)\n+\td := mergeDistributions(ad, cd)\n+\tg := mergeGauges(ag, cg)\n+\n+\treturn c, d, g\n+}\n+\n+// IsCounter returns true if the monitoring info is a counter metric.\n+func IsCounter(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:sum_int64:v1\"\n+}\n+\n+// IsDistribution returns true if the monitoring info is a distribution metric.\n+func IsDistribution(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:distribution_int64:v1\"\n+}\n+\n+// IsGauge returns true if the monitoring info is a gauge metric.\n+func IsGauge(mi *pipepb.MonitoringInfo) bool {\n+\tswitch mi.GetType() {\n+\tcase\n+\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[MetricKey]int64,\n+\tmap[MetricKey]DistributionValue,\n+\tmap[MetricKey]GaugeValue) {\n+\tcounters := make(map[MetricKey]int64)\n+\tdistributions := make(map[MetricKey]DistributionValue)\n+\tgauges := make(map[MetricKey]GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tif IsCounter(minfo) {\n+\t\t\tvalue, err := extractCounterResult(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\t} else if IsDistribution(minfo) {\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\t} else if IsGauge(minfo) {\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\t} else {\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(attempted map[MetricKey]int64, committed map[MetricKey]int64) []CounterResult {\n+\tres := make([]CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tif v, ok := committed[k]; ok {\n+\t\t\tres = append(res, CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t\t} else {\n+\t\t\tres = append(res, CounterResult{Attempted: attempted[k], Committed: -1, Key: k})\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk2NjQ3OQ==", "bodyText": "For consistency and ease of finding related work, also put the same JIRA id here.", "url": "https://github.com/apache/beam/pull/13272#discussion_r518966479", "createdAt": "2020-11-06T19:44:28Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/runners/universal/runnerlib/execute.go", "diffHunk": "@@ -79,15 +81,79 @@ func Execute(ctx context.Context, p *pipepb.Pipeline, endpoint string, opt *JobO\n \n \tjobID, err := Submit(ctx, client, prepID, token)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn presult, err\n \t}\n \n \tlog.Infof(ctx, \"Submitted job: %v\", jobID)\n \n \t// (4) Wait for completion.\n \n \tif async {\n-\t\treturn jobID, nil\n+\t\treturn presult, nil\n \t}\n-\treturn jobID, WaitForCompletion(ctx, client, jobID)\n+\terr = WaitForCompletion(ctx, client, jobID)\n+\n+\tres, err := newUniversalPipelineResult(ctx, jobID, client)\n+\tif err != nil {\n+\t\treturn presult, err\n+\t}\n+\tpresult = res\n+\n+\treturn presult, err\n+}\n+\n+type UniversalPipelineResult struct {\n+\tJobID   string\n+\tmetrics *UniversalMetrics\n+}\n+\n+func newUniversalPipelineResult(ctx context.Context, jobID string, client jobpb.JobServiceClient) (*UniversalPipelineResult, error) {\n+\tmetrics, err := newUniversalMetrics(ctx, jobID, client)\n+\tif err != nil {\n+\t\treturn &UniversalPipelineResult{jobID, nil}, err\n+\t}\n+\treturn &UniversalPipelineResult{jobID, metrics}, err\n+}\n+\n+func (pr UniversalPipelineResult) Metrics() metrics.MetricResults {\n+\treturn pr.metrics\n+}\n+\n+func newUniversalMetrics(ctx context.Context, jobID string, client jobpb.JobServiceClient) (*UniversalMetrics, error) {\n+\trequest := &jobpb.GetJobMetricsRequest{JobId: jobID}\n+\tresponse, err := client.GetJobMetrics(ctx, request)\n+\tif err != nil {\n+\t\treturn nil, errors.Wrap(err, \"failed to get metrics\")\n+\t}\n+\tc, d, g := metrics.FromMonitoringInfos(response.GetMetrics())\n+\treturn &UniversalMetrics{c, d, g}, err\n+}\n+\n+type UniversalMetrics struct {\n+\tcounters      []metrics.CounterResult\n+\tdistributions []metrics.DistributionResult\n+\tgauges        []metrics.GaugeResult\n+}\n+\n+func (um UniversalMetrics) Query() metrics.MetricQueryResults {\n+\t// TODO: Implement metrics filtering", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MjgyNw==", "bodyText": "We should consider changing ptest or at least having a new ptest.RunWithMetrics endpoint that also returns the pipeline results, as metrics are very valuable and convenient to check in testing situations. That can be handled as a TODO (BEAM--####) however, rather than as a part of this PR, since ptest is pervasive.", "url": "https://github.com/apache/beam/pull/13272#discussion_r519052827", "createdAt": "2020-11-06T23:23:51Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/testing/ptest/ptest.go", "diffHunk": "@@ -73,7 +73,8 @@ func Run(p *beam.Pipeline) error {\n \tif *Runner == \"\" {\n \t\t*Runner = defaultRunner\n \t}\n-\treturn beam.Run(context.Background(), *Runner, p)\n+\t_, err := beam.Run(context.Background(), *Runner, p)\n+\treturn err", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MzE1NA==", "bodyText": "I'd omit the \"Pipeline\" as it's already clear from the parameter type, and the other Run function that pipelines are going to be executed.", "url": "https://github.com/apache/beam/pull/13272#discussion_r519053154", "createdAt": "2020-11-06T23:25:06Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/x/beamx/run.go", "diffHunk": "@@ -40,5 +40,13 @@ var runner = flag.String(\"runner\", \"direct\", \"Pipeline runner.\")\n // defaults to the direct runner, but all beam-distributed runners and textio\n // filesystems are implicitly registered.\n func Run(ctx context.Context, p *beam.Pipeline) error {\n+\t_, err := beam.Run(ctx, *runner, p)\n+\treturn err\n+}\n+\n+// RunPipelineWithMetrics invokes beam.Run with the runner supplied by the\n+// flag \"runner\". Returns a beam.PipelineResult objects, which can be\n+// accessed to query the pipeline's metrics.\n+func RunPipelineWithMetrics(ctx context.Context, p *beam.Pipeline) (beam.PipelineResult, error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f16527bcc11f95fe6eaa5d14a8f3f40d91ed60d", "author": {"user": {"login": "kamilwu", "name": "Kamil Wasilewski"}}, "url": "https://github.com/apache/beam/commit/3f16527bcc11f95fe6eaa5d14a8f3f40d91ed60d", "committedDate": "2020-11-09T14:39:23Z", "message": "fix: style fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NTQ3ODk2", "url": "https://github.com/apache/beam/pull/13272#pullrequestreview-526547896", "createdAt": "2020-11-09T18:45:17Z", "commit": {"oid": "9e4968ce09ebbc6f11357f70dcbafda819d047a7"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxODo0NToxN1rOHv8f-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxOToyMzowMVrOHv-IXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNjM0NQ==", "bodyText": "Please move the new package to under beam/core/runtime/monitoring instead of just in raw core. runtime is where code that depends on the protocol buffers tends to live.\nI'm not against a new package for this handling, but I think I'm against moving the code that is harness only being moved out of the harness. That code isn't intended to be part of any external API. There's also nothing relating the code beyond \"they use the MonitoringInfos\". That's not reason enough to put the code into the same package. To match the other convention around protos, perhaps we can call the package \"metricsx\" to go along with runtime/graphx which also handles protocol buffers.\nFurther, WRT Testing, you only seem to be using the encoding functions. Please simply copy those helpers into the test file instead of trying to deduplicate. A little bit of copying is better than a little bit of dependency.", "url": "https://github.com/apache/beam/pull/13272#discussion_r520036345", "createdAt": "2020-11-09T18:45:17Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -13,10 +13,12 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-package harness\n+package monitoring", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4968ce09ebbc6f11357f70dcbafda819d047a7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNzY1Ng==", "bodyText": "Every exported identifier should have a doc comment.\nhttps://golang.org/doc/effective_go.html#commentary\n// ShortIDsToInfos translates a slice shortids from a monitoring request to their fully qualified MonitoringInfos\n// based on the contents of the defaultShortIDCache.", "url": "https://github.com/apache/beam/pull/13272#discussion_r520037656", "createdAt": "2020-11-09T18:47:32Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -199,11 +201,11 @@ func getShortID(l metrics.Labels, urn mUrn) string {\n \treturn defaultShortIDCache.getShortID(l, urn)\n }\n \n-func shortIdsToInfos(shortids []string) map[string]*pipepb.MonitoringInfo {\n+func ShortIdsToInfos(shortids []string) map[string]*pipepb.MonitoringInfo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4968ce09ebbc6f11357f70dcbafda819d047a7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNzY4OA==", "bodyText": "Every exported identifier should have a doc comment.\nhttps://golang.org/doc/effective_go.html#commentary\n// Monitoring extracts and translates metrics from an execution plan into the associated MonitoringInfos and short id mappings.", "url": "https://github.com/apache/beam/pull/13272#discussion_r520037688", "createdAt": "2020-11-09T18:47:35Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -199,11 +201,11 @@ func getShortID(l metrics.Labels, urn mUrn) string {\n \treturn defaultShortIDCache.getShortID(l, urn)\n }\n \n-func shortIdsToInfos(shortids []string) map[string]*pipepb.MonitoringInfo {\n+func ShortIdsToInfos(shortids []string) map[string]*pipepb.MonitoringInfo {\n \treturn defaultShortIDCache.shortIdsToInfos(shortids)\n }\n \n-func monitoring(p *exec.Plan) ([]*pipepb.MonitoringInfo, map[string][]byte) {\n+func Monitoring(p *exec.Plan) ([]*pipepb.MonitoringInfo, map[string][]byte) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4968ce09ebbc6f11357f70dcbafda819d047a7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0NDAxNg==", "bodyText": "Please drop the \"Metric\" prefix when putting things into the metrics package.\nOtherwise users of this type will always be typing metrics.MetricQueryResult.", "url": "https://github.com/apache/beam/pull/13272#discussion_r520044016", "createdAt": "2020-11-09T18:57:48Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,73 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// MetricResults queries for all metric values that match a given filter.\n+type MetricResults struct {\n+\tCounters      []CounterResult\n+\tDistributions []DistributionResult\n+\tGauges        []GaugeResult\n+}\n+\n+// AllMetrics returns all metrics from a MetricResults instance.\n+func (mr MetricResults) AllMetrics() MetricQueryResults {\n+\treturn MetricQueryResults{mr.Counters, mr.Distributions, mr.Gauges}\n+}\n+\n+// TODO: Implement Query(MetricsFilter) and metrics filtering\n+\n+// MetricQueryResults is the results of a query. Allows accessing all of the\n+// metrics that matched the filter.\n+type MetricQueryResults struct {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4968ce09ebbc6f11357f70dcbafda819d047a7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0NDE4NA==", "bodyText": "Please drop the \"Metric\" prefix when putting things into the metrics package.\nOtherwise users of this type will always be typing metrics.MetricResults.", "url": "https://github.com/apache/beam/pull/13272#discussion_r520044184", "createdAt": "2020-11-09T18:58:06Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,73 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// MetricResults queries for all metric values that match a given filter.\n+type MetricResults struct {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4968ce09ebbc6f11357f70dcbafda819d047a7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0NTIyMA==", "bodyText": "Please drop the \"Metric\" prefix when putting things into the metrics package.\nOtherwise users of this type will always be typing metrics.MetricKey\nThere are also metrics that aren't associated with DoFns (eg PCollection specific ones), that may warrant different key types, rather than a \"global\" key.  Maybe DoFnKey or StepKey?\nConsider documenting what this is used for, rather than what it is. \"StepKey uniquely identifies a metric\"", "url": "https://github.com/apache/beam/pull/13272#discussion_r520045220", "createdAt": "2020-11-09T18:59:47Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,73 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// MetricResults queries for all metric values that match a given filter.\n+type MetricResults struct {\n+\tCounters      []CounterResult\n+\tDistributions []DistributionResult\n+\tGauges        []GaugeResult\n+}\n+\n+// AllMetrics returns all metrics from a MetricResults instance.\n+func (mr MetricResults) AllMetrics() MetricQueryResults {\n+\treturn MetricQueryResults{mr.Counters, mr.Distributions, mr.Gauges}\n+}\n+\n+// TODO: Implement Query(MetricsFilter) and metrics filtering\n+\n+// MetricQueryResults is the results of a query. Allows accessing all of the\n+// metrics that matched the filter.\n+type MetricQueryResults struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// GetCounters returns an array of counter metrics.\n+func (qr MetricQueryResults) GetCounters() []CounterResult {\n+\treturn qr.counters\n+}\n+\n+// GetDistributions returns an array of distribution metrics.\n+func (qr MetricQueryResults) GetDistributions() []DistributionResult {\n+\treturn qr.distributions\n+}\n+\n+// GetGauges returns an array of gauges metrics.\n+func (qr MetricQueryResults) GetGauges() []GaugeResult {\n+\treturn qr.gauges\n+}\n+\n+// CounterResult is an attempted and a commited value of a Counter metric plus\n+// key.\n+type CounterResult struct {\n+\tAttempted, Committed int64\n+\tKey                  MetricKey\n+}\n+\n+// DistributionResult is an attempted and a commited value of a Distribution\n+// metric plus key.\n+type DistributionResult struct {\n+\tAttempted, Committed DistributionValue\n+\tKey                  MetricKey\n+}\n+\n+// GaugeResult is an attempted and a commited value of a Gauge metric plus\n+// key.\n+type GaugeResult struct {\n+\tAttempted, Committed GaugeValue\n+\tKey                  MetricKey\n+}\n+\n+// MetricKey includes the namespace and the name of the metric, as well as\n+// the step that reported the metric.\n+type MetricKey struct {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4968ce09ebbc6f11357f70dcbafda819d047a7"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA1NTk1OQ==", "bodyText": "Why not return a metrics.Results instead? Is the intent to force a breaking change if a new class of results is added?\nConversely, by using a metrics.Results, no such breaking change needs to happen, and things can change more gracefully (such as when generics land in Go).", "url": "https://github.com/apache/beam/pull/13272#discussion_r520055959", "createdAt": "2020-11-09T19:11:23Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -341,3 +343,189 @@ func int64Distribution(count, sum, min, max int64) ([]byte, error) {\n \t}\n \treturn buf.Bytes(), nil\n }\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) (\n+\t[]metrics.CounterResult,\n+\t[]metrics.DistributionResult,\n+\t[]metrics.GaugeResult) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4968ce09ebbc6f11357f70dcbafda819d047a7"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MDkxOQ==", "bodyText": "Same comment that I had before about consider changing this if-else ladder into a switch/case statement.", "url": "https://github.com/apache/beam/pull/13272#discussion_r520060919", "createdAt": "2020-11-09T19:19:31Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -341,3 +343,189 @@ func int64Distribution(count, sum, min, max int64) ([]byte, error) {\n \t}\n \treturn buf.Bytes(), nil\n }\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) (\n+\t[]metrics.CounterResult,\n+\t[]metrics.DistributionResult,\n+\t[]metrics.GaugeResult) {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\tc := mergeCounters(ac, cc)\n+\td := mergeDistributions(ad, cd)\n+\tg := mergeGauges(ag, cg)\n+\n+\treturn c, d, g\n+}\n+\n+// IsCounter returns true if the monitoring info is a counter metric.\n+func IsCounter(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:sum_int64:v1\"\n+}\n+\n+// IsDistribution returns true if the monitoring info is a distribution metric.\n+func IsDistribution(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:distribution_int64:v1\"\n+}\n+\n+// IsGauge returns true if the monitoring info is a gauge metric.\n+func IsGauge(mi *pipepb.MonitoringInfo) bool {\n+\tswitch mi.GetType() {\n+\tcase\n+\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.MetricKey]int64,\n+\tmap[metrics.MetricKey]metrics.DistributionValue,\n+\tmap[metrics.MetricKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.MetricKey]int64)\n+\tdistributions := make(map[metrics.MetricKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.MetricKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tif IsCounter(minfo) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4968ce09ebbc6f11357f70dcbafda819d047a7"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MTc1OQ==", "bodyText": "This function doesn't do anything other than serve as a comment. Consider simply calling labels.Transform() directly at the only call site.", "url": "https://github.com/apache/beam/pull/13272#discussion_r520061759", "createdAt": "2020-11-09T19:20:52Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -341,3 +343,189 @@ func int64Distribution(count, sum, min, max int64) ([]byte, error) {\n \t}\n \treturn buf.Bytes(), nil\n }\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) (\n+\t[]metrics.CounterResult,\n+\t[]metrics.DistributionResult,\n+\t[]metrics.GaugeResult) {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\tc := mergeCounters(ac, cc)\n+\td := mergeDistributions(ad, cd)\n+\tg := mergeGauges(ag, cg)\n+\n+\treturn c, d, g\n+}\n+\n+// IsCounter returns true if the monitoring info is a counter metric.\n+func IsCounter(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:sum_int64:v1\"\n+}\n+\n+// IsDistribution returns true if the monitoring info is a distribution metric.\n+func IsDistribution(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:distribution_int64:v1\"\n+}\n+\n+// IsGauge returns true if the monitoring info is a gauge metric.\n+func IsGauge(mi *pipepb.MonitoringInfo) bool {\n+\tswitch mi.GetType() {\n+\tcase\n+\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.MetricKey]int64,\n+\tmap[metrics.MetricKey]metrics.DistributionValue,\n+\tmap[metrics.MetricKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.MetricKey]int64)\n+\tdistributions := make(map[metrics.MetricKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.MetricKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tif IsCounter(minfo) {\n+\t\t\tvalue, err := extractCounterValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\t} else if IsDistribution(minfo) {\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\t} else if IsGauge(minfo) {\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\t} else {\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(\n+\tattempted map[metrics.MetricKey]int64,\n+\tcommitted map[metrics.MetricKey]int64) []metrics.CounterResult {\n+\tres := make([]metrics.CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = -1\n+\t\t}\n+\t\tres = append(res, metrics.CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeDistributions(\n+\tattempted map[metrics.MetricKey]metrics.DistributionValue,\n+\tcommitted map[metrics.MetricKey]metrics.DistributionValue) []metrics.DistributionResult {\n+\tres := make([]metrics.DistributionResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.DistributionValue{}\n+\t\t}\n+\t\tres = append(res, metrics.DistributionResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeGauges(\n+\tattempted map[metrics.MetricKey]metrics.GaugeValue,\n+\tcommitted map[metrics.MetricKey]metrics.GaugeValue) []metrics.GaugeResult {\n+\tres := make([]metrics.GaugeResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.GaugeValue{}\n+\t\t}\n+\t\tres = append(res, metrics.GaugeResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func extractKey(mi *pipepb.MonitoringInfo) (metrics.MetricKey, error) {\n+\tlabels := newLabels(mi.GetLabels())\n+\tstepName := getStepName(labels)\n+\tif stepName == \"\" {\n+\t\treturn metrics.MetricKey{}, fmt.Errorf(\"Failed to deduce Step from MonitoringInfo: %v\", mi)\n+\t}\n+\treturn metrics.MetricKey{Step: stepName, Name: labels.Name(), Namespace: labels.Namespace()}, nil\n+}\n+\n+func extractCounterValue(reader *bytes.Reader) (int64, error) {\n+\tvalue, err := coder.DecodeVarInt(reader)\n+\tif err != nil {\n+\t\treturn -1, err\n+\t}\n+\treturn value, nil\n+}\n+\n+func extractDistributionValue(reader *bytes.Reader) (metrics.DistributionValue, error) {\n+\tvalues, err := decodeMany(reader, 4)\n+\tif err != nil {\n+\t\treturn metrics.DistributionValue{}, err\n+\t}\n+\treturn metrics.DistributionValue{Count: values[0], Sum: values[1], Min: values[2], Max: values[3]}, nil\n+}\n+\n+func extractGaugeValue(reader *bytes.Reader) (metrics.GaugeValue, error) {\n+\tvalues, err := decodeMany(reader, 2)\n+\tif err != nil {\n+\t\treturn metrics.GaugeValue{}, err\n+\t}\n+\treturn metrics.GaugeValue{Timestamp: time.Unix(0, values[0]*int64(time.Millisecond)), Value: values[1]}, nil\n+}\n+\n+func newLabels(miLabels map[string]string) *metrics.Labels {\n+\tlabels := metrics.UserLabels(\n+\t\tmiLabels[\"PTRANSFORM\"],\n+\t\tmiLabels[pipepb.MonitoringInfo_NAMESPACE.String()],\n+\t\tmiLabels[pipepb.MonitoringInfo_NAME.String()])\n+\treturn &labels\n+}\n+\n+func getStepName(labels *metrics.Labels) string {\n+\treturn labels.Transform()\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4968ce09ebbc6f11357f70dcbafda819d047a7"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MzA3MQ==", "bodyText": "Consider just using the constants\"NAMESPACE\" and \"NAME\". Or go the other way, and pull PTRANSFORM from the enum instead. The inconsistency is odd.", "url": "https://github.com/apache/beam/pull/13272#discussion_r520063071", "createdAt": "2020-11-09T19:23:01Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -341,3 +343,189 @@ func int64Distribution(count, sum, min, max int64) ([]byte, error) {\n \t}\n \treturn buf.Bytes(), nil\n }\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) (\n+\t[]metrics.CounterResult,\n+\t[]metrics.DistributionResult,\n+\t[]metrics.GaugeResult) {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\tc := mergeCounters(ac, cc)\n+\td := mergeDistributions(ad, cd)\n+\tg := mergeGauges(ag, cg)\n+\n+\treturn c, d, g\n+}\n+\n+// IsCounter returns true if the monitoring info is a counter metric.\n+func IsCounter(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:sum_int64:v1\"\n+}\n+\n+// IsDistribution returns true if the monitoring info is a distribution metric.\n+func IsDistribution(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:distribution_int64:v1\"\n+}\n+\n+// IsGauge returns true if the monitoring info is a gauge metric.\n+func IsGauge(mi *pipepb.MonitoringInfo) bool {\n+\tswitch mi.GetType() {\n+\tcase\n+\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.MetricKey]int64,\n+\tmap[metrics.MetricKey]metrics.DistributionValue,\n+\tmap[metrics.MetricKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.MetricKey]int64)\n+\tdistributions := make(map[metrics.MetricKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.MetricKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tif IsCounter(minfo) {\n+\t\t\tvalue, err := extractCounterValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\t} else if IsDistribution(minfo) {\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\t} else if IsGauge(minfo) {\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\t} else {\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(\n+\tattempted map[metrics.MetricKey]int64,\n+\tcommitted map[metrics.MetricKey]int64) []metrics.CounterResult {\n+\tres := make([]metrics.CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = -1\n+\t\t}\n+\t\tres = append(res, metrics.CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeDistributions(\n+\tattempted map[metrics.MetricKey]metrics.DistributionValue,\n+\tcommitted map[metrics.MetricKey]metrics.DistributionValue) []metrics.DistributionResult {\n+\tres := make([]metrics.DistributionResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.DistributionValue{}\n+\t\t}\n+\t\tres = append(res, metrics.DistributionResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeGauges(\n+\tattempted map[metrics.MetricKey]metrics.GaugeValue,\n+\tcommitted map[metrics.MetricKey]metrics.GaugeValue) []metrics.GaugeResult {\n+\tres := make([]metrics.GaugeResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.GaugeValue{}\n+\t\t}\n+\t\tres = append(res, metrics.GaugeResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func extractKey(mi *pipepb.MonitoringInfo) (metrics.MetricKey, error) {\n+\tlabels := newLabels(mi.GetLabels())\n+\tstepName := getStepName(labels)\n+\tif stepName == \"\" {\n+\t\treturn metrics.MetricKey{}, fmt.Errorf(\"Failed to deduce Step from MonitoringInfo: %v\", mi)\n+\t}\n+\treturn metrics.MetricKey{Step: stepName, Name: labels.Name(), Namespace: labels.Namespace()}, nil\n+}\n+\n+func extractCounterValue(reader *bytes.Reader) (int64, error) {\n+\tvalue, err := coder.DecodeVarInt(reader)\n+\tif err != nil {\n+\t\treturn -1, err\n+\t}\n+\treturn value, nil\n+}\n+\n+func extractDistributionValue(reader *bytes.Reader) (metrics.DistributionValue, error) {\n+\tvalues, err := decodeMany(reader, 4)\n+\tif err != nil {\n+\t\treturn metrics.DistributionValue{}, err\n+\t}\n+\treturn metrics.DistributionValue{Count: values[0], Sum: values[1], Min: values[2], Max: values[3]}, nil\n+}\n+\n+func extractGaugeValue(reader *bytes.Reader) (metrics.GaugeValue, error) {\n+\tvalues, err := decodeMany(reader, 2)\n+\tif err != nil {\n+\t\treturn metrics.GaugeValue{}, err\n+\t}\n+\treturn metrics.GaugeValue{Timestamp: time.Unix(0, values[0]*int64(time.Millisecond)), Value: values[1]}, nil\n+}\n+\n+func newLabels(miLabels map[string]string) *metrics.Labels {\n+\tlabels := metrics.UserLabels(\n+\t\tmiLabels[\"PTRANSFORM\"],\n+\t\tmiLabels[pipepb.MonitoringInfo_NAMESPACE.String()],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4968ce09ebbc6f11357f70dcbafda819d047a7"}, "originalPosition": 197}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f87a7b96cd08271d00750b8598c4fa96fedb7bd3", "author": {"user": {"login": "kamilwu", "name": "Kamil Wasilewski"}}, "url": "https://github.com/apache/beam/commit/f87a7b96cd08271d00750b8598c4fa96fedb7bd3", "committedDate": "2020-11-10T12:32:08Z", "message": "fix: create metricsx package that exports urn constants and payload encoding helpers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2596fb76edd925c4c54e2d33fc08b453355d5411", "author": {"user": {"login": "kamilwu", "name": "Kamil Wasilewski"}}, "url": "https://github.com/apache/beam/commit/2596fb76edd925c4c54e2d33fc08b453355d5411", "committedDate": "2020-11-10T13:24:07Z", "message": "fix: review changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7", "author": {"user": {"login": "kamilwu", "name": "Kamil Wasilewski"}}, "url": "https://github.com/apache/beam/commit/9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7", "committedDate": "2020-11-10T14:25:44Z", "message": "fix: add jira ticket id"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3Mjk3MDQ3", "url": "https://github.com/apache/beam/pull/13272#pullrequestreview-527297047", "createdAt": "2020-11-10T15:06:16Z", "commit": {"oid": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNTowNjoxNlrOHwg9KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNTowNjoxNlrOHwg9KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMzY0MQ==", "bodyText": "Perhaps we could skip these getters and expose QueryResults's fields directly. We don't need to follow Java API that much. @lostluck What do you think?", "url": "https://github.com/apache/beam/pull/13272#discussion_r520633641", "createdAt": "2020-11-10T15:06:16Z", "author": {"login": "kamilwu"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,73 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// Results represents all metrics gathered during the job's execution.\n+// It allows for querying metrics using a provided filter.\n+type Results struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// AllMetrics returns all metrics from a Results instance.\n+func (mr Results) AllMetrics() QueryResults {\n+\treturn QueryResults{mr.counters, mr.distributions, mr.gauges}\n+}\n+\n+// TODO(BEAM-11217): Implement Query(Filter) and metrics filtering\n+\n+// QueryResults is the result of a query. Allows accessing all of the\n+// metrics that matched the filter.\n+type QueryResults struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// GetCounters returns an array of counter metrics.\n+func (qr QueryResults) GetCounters() []CounterResult {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NjA4Nzc4", "url": "https://github.com/apache/beam/pull/13272#pullrequestreview-528608778", "createdAt": "2020-11-11T23:23:54Z", "commit": {"oid": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMzoyMzo1NFrOHxh_Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMzo1MzoxOVrOHxitOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY5OTE2Ng==", "bodyText": "That would still be idiomatic go. The question is whether we need to \"hide\" this behind an interface or not. I'm leaning no to that.\nThe real \"trick\" is probably copying out the results so users can query/mutate their own copies freely, without worrying about aliasing issues. Slices are not immutable, and are a pointer to a backing array which can be shared by multiple headers. The current method sets have just as many aliasing issues as having raw fields, so the fields aren't helping much.\nIdiomatically BTW if we were keeping these methods, we wouldn't have the Get* prefix which is very much a javaism.", "url": "https://github.com/apache/beam/pull/13272#discussion_r521699166", "createdAt": "2020-11-11T23:23:54Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,73 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// Results represents all metrics gathered during the job's execution.\n+// It allows for querying metrics using a provided filter.\n+type Results struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// AllMetrics returns all metrics from a Results instance.\n+func (mr Results) AllMetrics() QueryResults {\n+\treturn QueryResults{mr.counters, mr.distributions, mr.gauges}\n+}\n+\n+// TODO(BEAM-11217): Implement Query(Filter) and metrics filtering\n+\n+// QueryResults is the result of a query. Allows accessing all of the\n+// metrics that matched the filter.\n+type QueryResults struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// GetCounters returns an array of counter metrics.\n+func (qr QueryResults) GetCounters() []CounterResult {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMzY0MQ=="}, "originalCommit": {"oid": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcwNjc4NQ==", "bodyText": "Consider moving the contents of this file into the new metricx package, which is where I thought it was going to move last time. Any specific reason this code can't go there instead of this metrics package?\nPart of the separation we have is to avoid having the protos dependended on by the same user construction packages, which is why there are x and non-x versions of packages for the most part.\nEg. Graph which is a pure go representation of handling the pipeline graph, and graphx which translates that graph into the proto representation. Similarly, the coder and coderx packages which are the representation of the coders, and the actual execution of the coders.\nThis notionally allows much of the Go SDK front end to be re-used for a non-beam backend without depending on the beam proto structure, and keeps the protos away from pipeline authors, for whome the protos should be implementation details.\nSpecifically, we try to hide the proto details from pipeline authors, not runner authors. Runner authors have to deal with the protos by definition, but pipeline authors  should need a limited subset of those, and certainly not the protos. We try to have most user facing things be part of the beam package, but that's not appropriate for everything (it makes the package too big, too central, and harder to maintain).", "url": "https://github.com/apache/beam/pull/13272#discussion_r521706785", "createdAt": "2020-11-11T23:40:21Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/monitoring_infos.go", "diffHunk": "@@ -0,0 +1,176 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcwNzI0MA==", "bodyText": "Similarly, these tests should be in the metricsx package.", "url": "https://github.com/apache/beam/pull/13272#discussion_r521707240", "createdAt": "2020-11-11T23:41:41Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/monitoring_infos_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/metricsx\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcxMDkwNQ==", "bodyText": "Is it necessary to isolate this part in it's own function? It's only used in the \"newUniversalPipelineResult\" which takes all the same arguments.  If this is tested separately sure, but I don't see a reason to do that separately from the newUniversalPipelineResult for the previous reason.", "url": "https://github.com/apache/beam/pull/13272#discussion_r521710905", "createdAt": "2020-11-11T23:53:19Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/runners/universal/runnerlib/execute.go", "diffHunk": "@@ -79,15 +81,50 @@ func Execute(ctx context.Context, p *pipepb.Pipeline, endpoint string, opt *JobO\n \n \tjobID, err := Submit(ctx, client, prepID, token)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn presult, err\n \t}\n \n \tlog.Infof(ctx, \"Submitted job: %v\", jobID)\n \n \t// (4) Wait for completion.\n \n \tif async {\n-\t\treturn jobID, nil\n+\t\treturn presult, nil\n \t}\n-\treturn jobID, WaitForCompletion(ctx, client, jobID)\n+\terr = WaitForCompletion(ctx, client, jobID)\n+\n+\tres, err := newUniversalPipelineResult(ctx, jobID, client)\n+\tif err != nil {\n+\t\treturn presult, err\n+\t}\n+\tpresult = res\n+\n+\treturn presult, err\n+}\n+\n+type universalPipelineResult struct {\n+\tJobID   string\n+\tmetrics *metrics.Results\n+}\n+\n+func newUniversalPipelineResult(ctx context.Context, jobID string, client jobpb.JobServiceClient) (*universalPipelineResult, error) {\n+\tmetrics, err := getMetrics(ctx, jobID, client)\n+\tif err != nil {\n+\t\treturn &universalPipelineResult{jobID, nil}, err\n+\t}\n+\treturn &universalPipelineResult{jobID, metrics}, err\n+}\n+\n+func (pr universalPipelineResult) Metrics() metrics.Results {\n+\treturn *pr.metrics\n+}\n+\n+func getMetrics(ctx context.Context, jobID string, client jobpb.JobServiceClient) (*metrics.Results, error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "152caca5708ebff7705725c7a9aa1f664d8814b8", "author": {"user": {"login": "kamilwu", "name": "Kamil Wasilewski"}}, "url": "https://github.com/apache/beam/commit/152caca5708ebff7705725c7a9aa1f664d8814b8", "committedDate": "2020-11-12T16:33:26Z", "message": "fix: move monitoring_info content to newly created metricsx package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "author": {"user": {"login": "kamilwu", "name": "Kamil Wasilewski"}}, "url": "https://github.com/apache/beam/commit/cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "committedDate": "2020-11-12T17:21:39Z", "message": "fix: review changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5360538fe54a8cbb3bd8b7f874a56a0323cca789", "author": {"user": {"login": "kamilwu", "name": "Kamil Wasilewski"}}, "url": "https://github.com/apache/beam/commit/5360538fe54a8cbb3bd8b7f874a56a0323cca789", "committedDate": "2020-11-12T17:05:20Z", "message": "fix: review changes"}, "afterCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "author": {"user": {"login": "kamilwu", "name": "Kamil Wasilewski"}}, "url": "https://github.com/apache/beam/commit/cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "committedDate": "2020-11-12T17:21:39Z", "message": "fix: review changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NDA0MTY5", "url": "https://github.com/apache/beam/pull/13272#pullrequestreview-529404169", "createdAt": "2020-11-12T19:06:23Z", "commit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOTowNjoyM1rOHyJjgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDowNDo1MVrOHyMCMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0NzM5NQ==", "bodyText": "In go comments, it's reasonable to call this \"a slice\". In particular, arrays in Go are fixed size and have different implications compared to variable sized slices. Here and below.\nvar slice []int // a slice of ints\nvar array [4]int // an array of ints of length 4\n\nslice = []int{1,2,3,4}\narray = [4]int{1,2,3,4}\narray = [...]int{1,2,3,4}  // Have the compiler determine the array size based on the construction time parameters\n// array =  [2]int{1, 2} // a compiler error\nslice  = array[1:len(array)] // a slice of array, excluding the first element.\n// This is backed by array, which will lead to aliasing issues if care isn't taken...", "url": "https://github.com/apache/beam/pull/13272#discussion_r522347395", "createdAt": "2020-11-12T19:06:23Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,116 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// Results represents all metrics gathered during the job's execution.\n+// It allows for querying metrics using a provided filter.\n+type Results struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// NewResults creates a new Results.\n+func NewResults(\n+\tcounters []CounterResult,\n+\tdistributions []DistributionResult,\n+\tgauges []GaugeResult) *Results {\n+\treturn &Results{counters, distributions, gauges}\n+}\n+\n+// AllMetrics returns all metrics from a Results instance.\n+func (mr Results) AllMetrics() QueryResults {\n+\treturn QueryResults{mr.counters, mr.distributions, mr.gauges}\n+}\n+\n+// TODO(BEAM-11217): Implement Query(Filter) and metrics filtering\n+\n+// QueryResults is the result of a query. Allows accessing all of the\n+// metrics that matched the filter.\n+type QueryResults struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// Counters returns an array of counter metrics.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MDQ4Ng==", "bodyText": "Since this is a  map to values (rather than pointers), v will already be the zero value for the type. In short, this code is identical to simply v := commited[k]\nhttps://golang.org/doc/effective_go.html#maps", "url": "https://github.com/apache/beam/pull/13272#discussion_r522370486", "createdAt": "2020-11-12T19:34:27Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx.go", "diffHunk": "@@ -0,0 +1,181 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+// FromMonitoringInfos extracts metrics from monitored states and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) *metrics.Results {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\treturn metrics.NewResults(mergeCounters(ac, cc), mergeDistributions(ad, cd), mergeGauges(ag, cg))\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.StepKey]int64,\n+\tmap[metrics.StepKey]metrics.DistributionValue,\n+\tmap[metrics.StepKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.StepKey]int64)\n+\tdistributions := make(map[metrics.StepKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.StepKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tswitch minfo.GetType() {\n+\t\tcase \"beam:metrics:sum_int64:v1\":\n+\t\t\tvalue, err := extractCounterValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\tcase \"beam:metrics:distribution_int64:v1\":\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\tcase\n+\t\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\tdefault:\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(\n+\tattempted map[metrics.StepKey]int64,\n+\tcommitted map[metrics.StepKey]int64) []metrics.CounterResult {\n+\tres := make([]metrics.CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = -1\n+\t\t}\n+\t\tres = append(res, metrics.CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeDistributions(\n+\tattempted map[metrics.StepKey]metrics.DistributionValue,\n+\tcommitted map[metrics.StepKey]metrics.DistributionValue) []metrics.DistributionResult {\n+\tres := make([]metrics.DistributionResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.DistributionValue{}\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MTMzMA==", "bodyText": "Is the -1 part of the spec here? Wouldn't a 0 notionally be correct if there are no commited values for a key?", "url": "https://github.com/apache/beam/pull/13272#discussion_r522371330", "createdAt": "2020-11-12T19:35:58Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx.go", "diffHunk": "@@ -0,0 +1,181 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+// FromMonitoringInfos extracts metrics from monitored states and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) *metrics.Results {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\treturn metrics.NewResults(mergeCounters(ac, cc), mergeDistributions(ad, cd), mergeGauges(ag, cg))\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.StepKey]int64,\n+\tmap[metrics.StepKey]metrics.DistributionValue,\n+\tmap[metrics.StepKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.StepKey]int64)\n+\tdistributions := make(map[metrics.StepKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.StepKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tswitch minfo.GetType() {\n+\t\tcase \"beam:metrics:sum_int64:v1\":\n+\t\t\tvalue, err := extractCounterValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\tcase \"beam:metrics:distribution_int64:v1\":\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\tcase\n+\t\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\tdefault:\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(\n+\tattempted map[metrics.StepKey]int64,\n+\tcommitted map[metrics.StepKey]int64) []metrics.CounterResult {\n+\tres := make([]metrics.CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = -1\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MzEyOA==", "bodyText": "In Go, if a non-nil error is returned, conventionally the non-error returns should be ignored. There's no need to have a special marker value for an error, since that's what the error is for. Specifically if the value returned is still valid in some way when an error is returned, that is the exception, and should be documented.\n(As it literally doesn't matter, no change required here, so just pointing it out for teaching purposes.)", "url": "https://github.com/apache/beam/pull/13272#discussion_r522373128", "createdAt": "2020-11-12T19:39:21Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx.go", "diffHunk": "@@ -0,0 +1,181 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+// FromMonitoringInfos extracts metrics from monitored states and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) *metrics.Results {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\treturn metrics.NewResults(mergeCounters(ac, cc), mergeDistributions(ad, cd), mergeGauges(ag, cg))\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.StepKey]int64,\n+\tmap[metrics.StepKey]metrics.DistributionValue,\n+\tmap[metrics.StepKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.StepKey]int64)\n+\tdistributions := make(map[metrics.StepKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.StepKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tswitch minfo.GetType() {\n+\t\tcase \"beam:metrics:sum_int64:v1\":\n+\t\t\tvalue, err := extractCounterValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\tcase \"beam:metrics:distribution_int64:v1\":\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\tcase\n+\t\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\tdefault:\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(\n+\tattempted map[metrics.StepKey]int64,\n+\tcommitted map[metrics.StepKey]int64) []metrics.CounterResult {\n+\tres := make([]metrics.CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = -1\n+\t\t}\n+\t\tres = append(res, metrics.CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeDistributions(\n+\tattempted map[metrics.StepKey]metrics.DistributionValue,\n+\tcommitted map[metrics.StepKey]metrics.DistributionValue) []metrics.DistributionResult {\n+\tres := make([]metrics.DistributionResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.DistributionValue{}\n+\t\t}\n+\t\tres = append(res, metrics.DistributionResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeGauges(\n+\tattempted map[metrics.StepKey]metrics.GaugeValue,\n+\tcommitted map[metrics.StepKey]metrics.GaugeValue) []metrics.GaugeResult {\n+\tres := make([]metrics.GaugeResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.GaugeValue{}\n+\t\t}\n+\t\tres = append(res, metrics.GaugeResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func extractKey(mi *pipepb.MonitoringInfo) (metrics.StepKey, error) {\n+\tlabels := newLabels(mi.GetLabels())\n+\tstepName := labels.Transform()\n+\tif stepName == \"\" {\n+\t\treturn metrics.StepKey{}, fmt.Errorf(\"Failed to deduce Step from MonitoringInfo: %v\", mi)\n+\t}\n+\treturn metrics.StepKey{Step: stepName, Name: labels.Name(), Namespace: labels.Namespace()}, nil\n+}\n+\n+func extractCounterValue(reader *bytes.Reader) (int64, error) {\n+\tvalue, err := coder.DecodeVarInt(reader)\n+\tif err != nil {\n+\t\treturn -1, err", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3NDU5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // StepKey uniquely identifies a metric.\n          \n          \n            \n            // StepKey uniquely identifies a metric within a pipeline graph.", "url": "https://github.com/apache/beam/pull/13272#discussion_r522374597", "createdAt": "2020-11-12T19:42:00Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,116 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// Results represents all metrics gathered during the job's execution.\n+// It allows for querying metrics using a provided filter.\n+type Results struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// NewResults creates a new Results.\n+func NewResults(\n+\tcounters []CounterResult,\n+\tdistributions []DistributionResult,\n+\tgauges []GaugeResult) *Results {\n+\treturn &Results{counters, distributions, gauges}\n+}\n+\n+// AllMetrics returns all metrics from a Results instance.\n+func (mr Results) AllMetrics() QueryResults {\n+\treturn QueryResults{mr.counters, mr.distributions, mr.gauges}\n+}\n+\n+// TODO(BEAM-11217): Implement Query(Filter) and metrics filtering\n+\n+// QueryResults is the result of a query. Allows accessing all of the\n+// metrics that matched the filter.\n+type QueryResults struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// Counters returns an array of counter metrics.\n+func (qr QueryResults) Counters() []CounterResult {\n+\tout := make([]CounterResult, len(qr.counters))\n+\tcopy(out, qr.counters)\n+\treturn out\n+}\n+\n+// Distributions returns an array of distribution metrics.\n+func (qr QueryResults) Distributions() []DistributionResult {\n+\tout := make([]DistributionResult, len(qr.distributions))\n+\tcopy(out, qr.distributions)\n+\treturn out\n+}\n+\n+// Gauges returns an array of gauge metrics.\n+func (qr QueryResults) Gauges() []GaugeResult {\n+\tout := make([]GaugeResult, len(qr.gauges))\n+\tcopy(out, qr.gauges)\n+\treturn out\n+}\n+\n+// CounterResult is an attempted and a commited value of a counter metric plus\n+// key.\n+type CounterResult struct {\n+\tAttempted, Committed int64\n+\tKey                  StepKey\n+}\n+\n+// Result returns committed metrics. Falls back to attempted metrics if committed\n+// are not populated (e.g. due to not being supported on a given runner).\n+func (r CounterResult) Result() int64 {\n+\tif r.Committed != -1 {\n+\t\treturn r.Committed\n+\t}\n+\treturn r.Attempted\n+}\n+\n+// DistributionResult is an attempted and a commited value of a distribution\n+// metric plus key.\n+type DistributionResult struct {\n+\tAttempted, Committed DistributionValue\n+\tKey                  StepKey\n+}\n+\n+// Result returns committed metrics. Falls back to attempted metrics if committed\n+// are not populated (e.g. due to not being supported on a given runner).\n+func (r DistributionResult) Result() DistributionValue {\n+\tempty := DistributionValue{}\n+\tif r.Committed != empty {\n+\t\treturn r.Committed\n+\t}\n+\treturn r.Attempted\n+}\n+\n+// GaugeResult is an attempted and a commited value of a gauge metric plus\n+// key.\n+type GaugeResult struct {\n+\tAttempted, Committed GaugeValue\n+\tKey                  StepKey\n+}\n+\n+// Result returns committed metrics. Falls back to attempted metrics if committed\n+// are not populated (e.g. due to not being supported on a given runner).\n+func (r GaugeResult) Result() GaugeValue {\n+\tempty := GaugeValue{}\n+\tif r.Committed != empty {\n+\t\treturn r.Committed\n+\t}\n+\treturn r.Attempted\n+}\n+\n+// StepKey uniquely identifies a metric.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3ODcxMA==", "bodyText": "Prefer a t.Fatal here instead, and be clear that the encoding the Int64Distribution returned an error.\nAs a rule, never panic if you don't have to. In tests, it's better to clearly explain why you're failing the test run anyway. https://golang.org/doc/effective_go.html#panic", "url": "https://github.com/apache/beam/pull/13272#discussion_r522378710", "createdAt": "2020-11-12T19:48:52Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customCounter\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserSumInt64),\n+\t\tType:    UrnToType(UrnUserSumInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Counters()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, expected: %v\", size, 1)\n+\t}\n+\tif got[0] != want {\n+\t\tt.Fatalf(\"Invalid counter: got: %v, want: %v\",\n+\t\t\tgot[0], want)\n+\t}\n+}\n+\n+func TestDistributionExtraction(t *testing.T) {\n+\tvar count, sum, min, max int64 = 100, 5, -12, 30\n+\n+\twant := metrics.DistributionResult{\n+\t\tAttempted: metrics.DistributionValue{\n+\t\t\tCount: 100,\n+\t\t\tSum:   5,\n+\t\t\tMin:   -12,\n+\t\t\tMax:   30,\n+\t\t},\n+\t\tCommitted: metrics.DistributionValue{},\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customDist\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Distribution(count, sum, min, max)\n+\tif err != nil {\n+\t\tpanic(err)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3OTU1Mw==", "bodyText": "Same comment here, prefer a t.Fatalf here instead of a panic.", "url": "https://github.com/apache/beam/pull/13272#discussion_r522379553", "createdAt": "2020-11-12T19:50:08Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tpanic(err)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3OTYwNg==", "bodyText": "Same comment here, prefer a t.Fatalf here instead of a panic.", "url": "https://github.com/apache/beam/pull/13272#discussion_r522379606", "createdAt": "2020-11-12T19:50:14Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customCounter\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserSumInt64),\n+\t\tType:    UrnToType(UrnUserSumInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Counters()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, expected: %v\", size, 1)\n+\t}\n+\tif got[0] != want {\n+\t\tt.Fatalf(\"Invalid counter: got: %v, want: %v\",\n+\t\t\tgot[0], want)\n+\t}\n+}\n+\n+func TestDistributionExtraction(t *testing.T) {\n+\tvar count, sum, min, max int64 = 100, 5, -12, 30\n+\n+\twant := metrics.DistributionResult{\n+\t\tAttempted: metrics.DistributionValue{\n+\t\t\tCount: 100,\n+\t\t\tSum:   5,\n+\t\t\tMin:   -12,\n+\t\t\tMax:   30,\n+\t\t},\n+\t\tCommitted: metrics.DistributionValue{},\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customDist\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Distribution(count, sum, min, max)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customDist\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserDistInt64),\n+\t\tType:    UrnToType(UrnUserDistInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Distributions()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, expected: %v\", size, 1)\n+\t}\n+\tif got[0] != want {\n+\t\tt.Fatalf(\"Invalid distribution: got: %v, want: %v\",\n+\t\t\tgot[0], want)\n+\t}\n+}\n+\n+func TestGaugeExtraction(t *testing.T) {\n+\tvar value int64 = 100\n+\tloc, _ := time.LoadLocation(\"Local\")\n+\ttm := time.Date(2020, 11, 9, 17, 52, 28, 462*int(time.Millisecond), loc)\n+\n+\twant := metrics.GaugeResult{\n+\t\tAttempted: metrics.GaugeValue{\n+\t\t\tValue:     100,\n+\t\t\tTimestamp: tm,\n+\t\t},\n+\t\tCommitted: metrics.GaugeValue{},\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customGauge\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Latest(tm, value)\n+\tif err != nil {\n+\t\tpanic(err)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4MjQ3MA==", "bodyText": "Do this comparison using the cmp package instead.\n\"github.com/google/go-cmp/cmp\"\nif d := cmp.Diff(want, got[0]); d != \"\" {\n  t.Fatalf(\"Invalid counter: %v\", d)\n}\n\nHere and below.", "url": "https://github.com/apache/beam/pull/13272#discussion_r522382470", "createdAt": "2020-11-12T19:55:11Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customCounter\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserSumInt64),\n+\t\tType:    UrnToType(UrnUserSumInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Counters()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, expected: %v\", size, 1)\n+\t}\n+\tif got[0] != want {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4MzA1OA==", "bodyText": "In go tests, never say \"expected\" when you can simply say \"want\".  Otherwise this test output is excellent. Here and below.", "url": "https://github.com/apache/beam/pull/13272#discussion_r522383058", "createdAt": "2020-11-12T19:56:11Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customCounter\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserSumInt64),\n+\t\tType:    UrnToType(UrnUserSumInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Counters()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, expected: %v\", size, 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4ODAxNg==", "bodyText": "Test names are related to the code as much as possible. In this case, the thing we're properly testing is FromMonitoringInfos, and specifically Counters so func TestFromMonitoringInfos_Counters is an idiomatic test name.\nThere's also an opportunity for subtests... but that's difficult here without generics right now., and that's not until 2022. You can see more here https://gobyexample.com/testing and https://blog.golang.org/subtests", "url": "https://github.com/apache/beam/pull/13272#discussion_r522388016", "createdAt": "2020-11-12T20:04:51Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0b1ffbee05892c87446486f67bf0c03333ecc5f", "author": {"user": {"login": "kamilwu", "name": "Kamil Wasilewski"}}, "url": "https://github.com/apache/beam/commit/b0b1ffbee05892c87446486f67bf0c03333ecc5f", "committedDate": "2020-11-13T11:27:00Z", "message": "fix: many minor improvements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwMjgwODk0", "url": "https://github.com/apache/beam/pull/13272#pullrequestreview-530280894", "createdAt": "2020-11-13T17:51:13Z", "commit": {"oid": "b0b1ffbee05892c87446486f67bf0c03333ecc5f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzo1MToxNFrOHy499w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzo1MToxNFrOHy499w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEyNDIxNQ==", "bodyText": "You'll want to have want before got when using cmp.Diff. Otherwise your diff guidance is wrong.\ncmp.Diff(want, got[0]) means the diff will be (-want,+got) that is saying what is missing from want, and extra in got, which is a useful way to read them. cmp.Diff(got[0],want) means the diff will be (+want,-got), which will be confusing.", "url": "https://github.com/apache/beam/pull/13272#discussion_r523124215", "createdAt": "2020-11-13T17:51:14Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,166 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/google/go-cmp/cmp\"\n+)\n+\n+func TestFromMonitoringInfos_Counters(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to encode Int64Counter: %v\", err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customCounter\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserSumInt64),\n+\t\tType:    UrnToType(UrnUserSumInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Counters()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, want: %v\", size, 1)\n+\t}\n+\tif d := cmp.Diff(got[0], want); d != \"\" {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0b1ffbee05892c87446486f67bf0c03333ecc5f"}, "originalPosition": 64}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "becacbdb7453c1a9695be089e0b31cf0199eb49a", "author": {"user": {"login": "kamilwu", "name": "Kamil Wasilewski"}}, "url": "https://github.com/apache/beam/commit/becacbdb7453c1a9695be089e0b31cf0199eb49a", "committedDate": "2020-11-16T11:11:09Z", "message": "fix: use 0 instead of -1 if there are no committed values, fix cmp.Diff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxODM4ODU2", "url": "https://github.com/apache/beam/pull/13272#pullrequestreview-531838856", "createdAt": "2020-11-16T22:27:19Z", "commit": {"oid": "becacbdb7453c1a9695be089e0b31cf0199eb49a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4700, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}