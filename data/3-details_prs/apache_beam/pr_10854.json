{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MTAyNjQz", "number": 10854, "title": "State timers documentation", "bodyText": "", "createdAt": "2020-02-13T21:43:39Z", "url": "https://github.com/apache/beam/pull/10854", "merged": true, "mergeCommit": {"oid": "94e6978a7ad9338d82b582223ea245ec697c271d"}, "closed": true, "closedAt": "2020-02-27T09:02:51Z", "author": {"login": "reuvenlax"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcEDJjqAFqTM1ODYwNjk0Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIW4yggH2gAyMzc1MTAyNjQzOmJjNTk0ZGI4ODJlNWIzMGY4MzMwYThmZjY5MTA0NTQ3ZTMwM2FmZmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjA2OTQ3", "url": "https://github.com/apache/beam/pull/10854#pullrequestreview-358606947", "createdAt": "2020-02-13T22:46:42Z", "commit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjo0Njo0M1rOFpmOOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMzowMToxN1rOFpmi-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2MjE3MQ==", "bodyText": "This paragraph shouldn't be under ValueState; it should be in the State and Timers section", "url": "https://github.com/apache/beam/pull/10854#discussion_r379162171", "createdAt": "2020-02-13T22:46:43Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2Mjc1Nw==", "bodyText": "Need an intro for what ValueState is", "url": "https://github.com/apache/beam/pull/10854#discussion_r379162757", "createdAt": "2020-02-13T22:48:13Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2MzAzNg==", "bodyText": "s/aggregated/stored/", "url": "https://github.com/apache/beam/pull/10854#discussion_r379163036", "createdAt": "2020-02-13T22:48:57Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<BagState<ValueT>> numElements = StateSpecs.bag();\n+  \n+  @ProcessElement public void process(\n+    @Element KV<String, ValueT> element, \n+    @StateId(\"state\") BagState<ValueT> state) {\n+    // Add the current element to the bag for this key.\n+    state.add(element.getValue());\n+    if (shouldFetch()) {\n+      // Occasionally we fetch and process the values.\n+      Iterable<ValueT> values = state.read();\n+      processValues(values);\n+      state.clear();  // Clear the state for this key.\n+    }\n+  }\n+}));\n+```\n+### 10.2 Deferred state reads {#deferred-state-reads}\n+When a `DoFn` contains multiple state specifications, reading each one in order can be slow. Calling the read() function\n+on a state can cause the runner to perform a blocking read. Performing multiple blocking reads in sequence adds latency\n+to element processing. The readLater method allows the runner to know that the state will be read in the future, \n+allowing multiple state reads to be batched together.\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state1\") private final StateSpec<ValueState<Integer>> state1 = StateSpecs.value();\n+  @StateId(\"state2\") private final StateSpec<ValueState<String>> state2 = StateSpecs.value();\n+  @StateId(\"state3\") private final StateSpec<BagState<ValueT>> state3 = StateSpecs.bag();\n+\n+  @ProcessElement public void process(\n+    @StateId(\"state1\") ValueState<Integer> state1,\n+    @StateId(\"state2\") ValueState<String> state2,\n+    @StateId(\"state3\") BagState<ValueT> state3) {\n+    state1.readLater();\n+    state2.readLater();\n+    state3.readLater();\n+   \n+    // The runner can now batch all three states into a single read, reducing latency.\n+    processState1(state1.read());\n+    processState2(state2.read());\n+    processState3(state3.read());\n+  }\n+}));\n+```\n+\n+### 10.3 Timers {#timers}\n+Beam provides a per-key timer callback API. This allows for delayed processing of data aggregated using the state API.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2MzUyNg==", "bodyText": "Missing a paren.  Would read better as\ntimer.setRelative().offset(Duration.standardSeconds(30))", "url": "https://github.com/apache/beam/pull/10854#discussion_r379163526", "createdAt": "2020-02-13T22:49:57Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<BagState<ValueT>> numElements = StateSpecs.bag();\n+  \n+  @ProcessElement public void process(\n+    @Element KV<String, ValueT> element, \n+    @StateId(\"state\") BagState<ValueT> state) {\n+    // Add the current element to the bag for this key.\n+    state.add(element.getValue());\n+    if (shouldFetch()) {\n+      // Occasionally we fetch and process the values.\n+      Iterable<ValueT> values = state.read();\n+      processValues(values);\n+      state.clear();  // Clear the state for this key.\n+    }\n+  }\n+}));\n+```\n+### 10.2 Deferred state reads {#deferred-state-reads}\n+When a `DoFn` contains multiple state specifications, reading each one in order can be slow. Calling the read() function\n+on a state can cause the runner to perform a blocking read. Performing multiple blocking reads in sequence adds latency\n+to element processing. The readLater method allows the runner to know that the state will be read in the future, \n+allowing multiple state reads to be batched together.\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state1\") private final StateSpec<ValueState<Integer>> state1 = StateSpecs.value();\n+  @StateId(\"state2\") private final StateSpec<ValueState<String>> state2 = StateSpecs.value();\n+  @StateId(\"state3\") private final StateSpec<BagState<ValueT>> state3 = StateSpecs.bag();\n+\n+  @ProcessElement public void process(\n+    @StateId(\"state1\") ValueState<Integer> state1,\n+    @StateId(\"state2\") ValueState<String> state2,\n+    @StateId(\"state3\") BagState<ValueT> state3) {\n+    state1.readLater();\n+    state2.readLater();\n+    state3.readLater();\n+   \n+    // The runner can now batch all three states into a single read, reducing latency.\n+    processState1(state1.read());\n+    processState2(state2.read());\n+    processState3(state3.read());\n+  }\n+}));\n+```\n+\n+### 10.3 Timers {#timers}\n+Beam provides a per-key timer callback API. This allows for delayed processing of data aggregated using the state API.\n+Timers can be set to callback at either an event-time or a processing-time timestamp. Every timer is identified with a\n+TimerId. A given timer for a keycan only be set for a single timestamp. Calling set on a timer overwrites the previous\n+firing time for that key's timer.\n+\n+#### 10.3.1 Event-time timers {#event-time-timers}\n+Event-time timers fire when the input watermark for the DoFn passes the time at which the timer is set, meaning that \n+the runner believes that there are no more elements to be processed with timestamps before the timer timestamp. This\n+allows for event-time aggregations. \n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> state = StateSpecs.value();\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element,\n+      @Timestamp Instant elementTs,\n+      @StateId(\"state\") ValueState<Integer> state, \n+      @TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set an event-time timer to the element timestamp.\n+     timer.set(elementTs);\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+#### 10.3.2 Processing-time timers {#processing-time-timers}\n+Processing-time timers fire when the real wall-clock time passes. This is often used to create larger batches of data\n+before processing. It can also be used to schedule events that should occur at a specific time. Just like with\n+event-time timers, processing-time timers are per key - each key has a separate copy of the timer.\n+\n+While processing-time timers can be set to an absolute timestamp, it is very common to set them to an offset relative \n+to the current time. The `Timer.offset` and `Timer.setRelative` methods can be used to accomplish this.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+  @ProcessElement public void process(@TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set a timer to go off 30 seconds in the future.\n+     timer.offset(Duration.standardSeconds(30).setRelative();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2Mzc3NA==", "bodyText": "s/pipeline/DoFn/", "url": "https://github.com/apache/beam/pull/10854#discussion_r379163774", "createdAt": "2020-02-13T22:50:40Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<BagState<ValueT>> numElements = StateSpecs.bag();\n+  \n+  @ProcessElement public void process(\n+    @Element KV<String, ValueT> element, \n+    @StateId(\"state\") BagState<ValueT> state) {\n+    // Add the current element to the bag for this key.\n+    state.add(element.getValue());\n+    if (shouldFetch()) {\n+      // Occasionally we fetch and process the values.\n+      Iterable<ValueT> values = state.read();\n+      processValues(values);\n+      state.clear();  // Clear the state for this key.\n+    }\n+  }\n+}));\n+```\n+### 10.2 Deferred state reads {#deferred-state-reads}\n+When a `DoFn` contains multiple state specifications, reading each one in order can be slow. Calling the read() function\n+on a state can cause the runner to perform a blocking read. Performing multiple blocking reads in sequence adds latency\n+to element processing. The readLater method allows the runner to know that the state will be read in the future, \n+allowing multiple state reads to be batched together.\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state1\") private final StateSpec<ValueState<Integer>> state1 = StateSpecs.value();\n+  @StateId(\"state2\") private final StateSpec<ValueState<String>> state2 = StateSpecs.value();\n+  @StateId(\"state3\") private final StateSpec<BagState<ValueT>> state3 = StateSpecs.bag();\n+\n+  @ProcessElement public void process(\n+    @StateId(\"state1\") ValueState<Integer> state1,\n+    @StateId(\"state2\") ValueState<String> state2,\n+    @StateId(\"state3\") BagState<ValueT> state3) {\n+    state1.readLater();\n+    state2.readLater();\n+    state3.readLater();\n+   \n+    // The runner can now batch all three states into a single read, reducing latency.\n+    processState1(state1.read());\n+    processState2(state2.read());\n+    processState3(state3.read());\n+  }\n+}));\n+```\n+\n+### 10.3 Timers {#timers}\n+Beam provides a per-key timer callback API. This allows for delayed processing of data aggregated using the state API.\n+Timers can be set to callback at either an event-time or a processing-time timestamp. Every timer is identified with a\n+TimerId. A given timer for a keycan only be set for a single timestamp. Calling set on a timer overwrites the previous\n+firing time for that key's timer.\n+\n+#### 10.3.1 Event-time timers {#event-time-timers}\n+Event-time timers fire when the input watermark for the DoFn passes the time at which the timer is set, meaning that \n+the runner believes that there are no more elements to be processed with timestamps before the timer timestamp. This\n+allows for event-time aggregations. \n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> state = StateSpecs.value();\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element,\n+      @Timestamp Instant elementTs,\n+      @StateId(\"state\") ValueState<Integer> state, \n+      @TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set an event-time timer to the element timestamp.\n+     timer.set(elementTs);\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+#### 10.3.2 Processing-time timers {#processing-time-timers}\n+Processing-time timers fire when the real wall-clock time passes. This is often used to create larger batches of data\n+before processing. It can also be used to schedule events that should occur at a specific time. Just like with\n+event-time timers, processing-time timers are per key - each key has a separate copy of the timer.\n+\n+While processing-time timers can be set to an absolute timestamp, it is very common to set them to an offset relative \n+to the current time. The `Timer.offset` and `Timer.setRelative` methods can be used to accomplish this.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+  @ProcessElement public void process(@TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set a timer to go off 30 seconds in the future.\n+     timer.offset(Duration.standardSeconds(30).setRelative();\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.3 Dynamic timer tags {#dynamic-timer-tags}\n+Beam also supports dynamically setting a timer tag using `TimerMap`. This allows for setting multiple different timers\n+in a `ParDo` and allowing for the timer tags to be dynamically chosen - e.g. based on data in the input elements. A\n+timer with a specific tag can only be set to a single timestamp, so setting the timer again has the effect of\n+overwriting the previous expiration time for the timer with that tag. Each `TimerMap` is identified with a timer family\n+id, and timers in different timer families are independent.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerFamily(\"actionTimers\") private final TimerSpec timer = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @Timestamp Instant elementTs,\n+      @TimerFamily(\"actionTimers\") TimerMap timers) {\n+     timers.set(element.getValue().getActionType(), elementTs);\n+  }\n+  \n+   @OnTimerFamily(\"actionTimers\") public void onTimer(@TimerId String timerId) {\n+     LOG.info(\"Timer fired with id \" + timerId);\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.4 Timer output timestamps {#timer-output-timestamps}\n+By default, event-time timers will hold the output watermark of the `ParDo` to the timestamp of the timer. This means\n+that if a timer is set to 12pm, any windowed aggregations or event-time timers later in the pipeline graph that finish  \n+after 12pm will not expire. The timestamp of the timer is also the default output timestamp for the timer callback. This\n+means that any elements output from the onTimer method will have a timestamp equal to the timestamp of the timer firing.\n+For processing-time timers, the default output timestamp and watermark hold is the value of the input watermark at the\n+time the timer was set.\n+\n+In some cases, a pipeline needs to output timestamps earlier than the timer expiration time, and therefore also needs to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2Mzk0Ng==", "bodyText": "hold its output watermark", "url": "https://github.com/apache/beam/pull/10854#discussion_r379163946", "createdAt": "2020-02-13T22:51:10Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<BagState<ValueT>> numElements = StateSpecs.bag();\n+  \n+  @ProcessElement public void process(\n+    @Element KV<String, ValueT> element, \n+    @StateId(\"state\") BagState<ValueT> state) {\n+    // Add the current element to the bag for this key.\n+    state.add(element.getValue());\n+    if (shouldFetch()) {\n+      // Occasionally we fetch and process the values.\n+      Iterable<ValueT> values = state.read();\n+      processValues(values);\n+      state.clear();  // Clear the state for this key.\n+    }\n+  }\n+}));\n+```\n+### 10.2 Deferred state reads {#deferred-state-reads}\n+When a `DoFn` contains multiple state specifications, reading each one in order can be slow. Calling the read() function\n+on a state can cause the runner to perform a blocking read. Performing multiple blocking reads in sequence adds latency\n+to element processing. The readLater method allows the runner to know that the state will be read in the future, \n+allowing multiple state reads to be batched together.\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state1\") private final StateSpec<ValueState<Integer>> state1 = StateSpecs.value();\n+  @StateId(\"state2\") private final StateSpec<ValueState<String>> state2 = StateSpecs.value();\n+  @StateId(\"state3\") private final StateSpec<BagState<ValueT>> state3 = StateSpecs.bag();\n+\n+  @ProcessElement public void process(\n+    @StateId(\"state1\") ValueState<Integer> state1,\n+    @StateId(\"state2\") ValueState<String> state2,\n+    @StateId(\"state3\") BagState<ValueT> state3) {\n+    state1.readLater();\n+    state2.readLater();\n+    state3.readLater();\n+   \n+    // The runner can now batch all three states into a single read, reducing latency.\n+    processState1(state1.read());\n+    processState2(state2.read());\n+    processState3(state3.read());\n+  }\n+}));\n+```\n+\n+### 10.3 Timers {#timers}\n+Beam provides a per-key timer callback API. This allows for delayed processing of data aggregated using the state API.\n+Timers can be set to callback at either an event-time or a processing-time timestamp. Every timer is identified with a\n+TimerId. A given timer for a keycan only be set for a single timestamp. Calling set on a timer overwrites the previous\n+firing time for that key's timer.\n+\n+#### 10.3.1 Event-time timers {#event-time-timers}\n+Event-time timers fire when the input watermark for the DoFn passes the time at which the timer is set, meaning that \n+the runner believes that there are no more elements to be processed with timestamps before the timer timestamp. This\n+allows for event-time aggregations. \n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> state = StateSpecs.value();\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element,\n+      @Timestamp Instant elementTs,\n+      @StateId(\"state\") ValueState<Integer> state, \n+      @TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set an event-time timer to the element timestamp.\n+     timer.set(elementTs);\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+#### 10.3.2 Processing-time timers {#processing-time-timers}\n+Processing-time timers fire when the real wall-clock time passes. This is often used to create larger batches of data\n+before processing. It can also be used to schedule events that should occur at a specific time. Just like with\n+event-time timers, processing-time timers are per key - each key has a separate copy of the timer.\n+\n+While processing-time timers can be set to an absolute timestamp, it is very common to set them to an offset relative \n+to the current time. The `Timer.offset` and `Timer.setRelative` methods can be used to accomplish this.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+  @ProcessElement public void process(@TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set a timer to go off 30 seconds in the future.\n+     timer.offset(Duration.standardSeconds(30).setRelative();\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.3 Dynamic timer tags {#dynamic-timer-tags}\n+Beam also supports dynamically setting a timer tag using `TimerMap`. This allows for setting multiple different timers\n+in a `ParDo` and allowing for the timer tags to be dynamically chosen - e.g. based on data in the input elements. A\n+timer with a specific tag can only be set to a single timestamp, so setting the timer again has the effect of\n+overwriting the previous expiration time for the timer with that tag. Each `TimerMap` is identified with a timer family\n+id, and timers in different timer families are independent.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerFamily(\"actionTimers\") private final TimerSpec timer = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @Timestamp Instant elementTs,\n+      @TimerFamily(\"actionTimers\") TimerMap timers) {\n+     timers.set(element.getValue().getActionType(), elementTs);\n+  }\n+  \n+   @OnTimerFamily(\"actionTimers\") public void onTimer(@TimerId String timerId) {\n+     LOG.info(\"Timer fired with id \" + timerId);\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.4 Timer output timestamps {#timer-output-timestamps}\n+By default, event-time timers will hold the output watermark of the `ParDo` to the timestamp of the timer. This means\n+that if a timer is set to 12pm, any windowed aggregations or event-time timers later in the pipeline graph that finish  \n+after 12pm will not expire. The timestamp of the timer is also the default output timestamp for the timer callback. This\n+means that any elements output from the onTimer method will have a timestamp equal to the timestamp of the timer firing.\n+For processing-time timers, the default output timestamp and watermark hold is the value of the input watermark at the\n+time the timer was set.\n+\n+In some cases, a pipeline needs to output timestamps earlier than the timer expiration time, and therefore also needs to\n+hold the watermark to those timestamps. For example, consider the following pipeline that temporarily batches records ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NDc0Nw==", "bodyText": "Clarify that the runner must wait for the watermark to pass endOfWindow + allowedLateness", "url": "https://github.com/apache/beam/pull/10854#discussion_r379164747", "createdAt": "2020-02-13T22:53:23Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<BagState<ValueT>> numElements = StateSpecs.bag();\n+  \n+  @ProcessElement public void process(\n+    @Element KV<String, ValueT> element, \n+    @StateId(\"state\") BagState<ValueT> state) {\n+    // Add the current element to the bag for this key.\n+    state.add(element.getValue());\n+    if (shouldFetch()) {\n+      // Occasionally we fetch and process the values.\n+      Iterable<ValueT> values = state.read();\n+      processValues(values);\n+      state.clear();  // Clear the state for this key.\n+    }\n+  }\n+}));\n+```\n+### 10.2 Deferred state reads {#deferred-state-reads}\n+When a `DoFn` contains multiple state specifications, reading each one in order can be slow. Calling the read() function\n+on a state can cause the runner to perform a blocking read. Performing multiple blocking reads in sequence adds latency\n+to element processing. The readLater method allows the runner to know that the state will be read in the future, \n+allowing multiple state reads to be batched together.\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state1\") private final StateSpec<ValueState<Integer>> state1 = StateSpecs.value();\n+  @StateId(\"state2\") private final StateSpec<ValueState<String>> state2 = StateSpecs.value();\n+  @StateId(\"state3\") private final StateSpec<BagState<ValueT>> state3 = StateSpecs.bag();\n+\n+  @ProcessElement public void process(\n+    @StateId(\"state1\") ValueState<Integer> state1,\n+    @StateId(\"state2\") ValueState<String> state2,\n+    @StateId(\"state3\") BagState<ValueT> state3) {\n+    state1.readLater();\n+    state2.readLater();\n+    state3.readLater();\n+   \n+    // The runner can now batch all three states into a single read, reducing latency.\n+    processState1(state1.read());\n+    processState2(state2.read());\n+    processState3(state3.read());\n+  }\n+}));\n+```\n+\n+### 10.3 Timers {#timers}\n+Beam provides a per-key timer callback API. This allows for delayed processing of data aggregated using the state API.\n+Timers can be set to callback at either an event-time or a processing-time timestamp. Every timer is identified with a\n+TimerId. A given timer for a keycan only be set for a single timestamp. Calling set on a timer overwrites the previous\n+firing time for that key's timer.\n+\n+#### 10.3.1 Event-time timers {#event-time-timers}\n+Event-time timers fire when the input watermark for the DoFn passes the time at which the timer is set, meaning that \n+the runner believes that there are no more elements to be processed with timestamps before the timer timestamp. This\n+allows for event-time aggregations. \n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> state = StateSpecs.value();\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element,\n+      @Timestamp Instant elementTs,\n+      @StateId(\"state\") ValueState<Integer> state, \n+      @TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set an event-time timer to the element timestamp.\n+     timer.set(elementTs);\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+#### 10.3.2 Processing-time timers {#processing-time-timers}\n+Processing-time timers fire when the real wall-clock time passes. This is often used to create larger batches of data\n+before processing. It can also be used to schedule events that should occur at a specific time. Just like with\n+event-time timers, processing-time timers are per key - each key has a separate copy of the timer.\n+\n+While processing-time timers can be set to an absolute timestamp, it is very common to set them to an offset relative \n+to the current time. The `Timer.offset` and `Timer.setRelative` methods can be used to accomplish this.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+  @ProcessElement public void process(@TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set a timer to go off 30 seconds in the future.\n+     timer.offset(Duration.standardSeconds(30).setRelative();\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.3 Dynamic timer tags {#dynamic-timer-tags}\n+Beam also supports dynamically setting a timer tag using `TimerMap`. This allows for setting multiple different timers\n+in a `ParDo` and allowing for the timer tags to be dynamically chosen - e.g. based on data in the input elements. A\n+timer with a specific tag can only be set to a single timestamp, so setting the timer again has the effect of\n+overwriting the previous expiration time for the timer with that tag. Each `TimerMap` is identified with a timer family\n+id, and timers in different timer families are independent.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerFamily(\"actionTimers\") private final TimerSpec timer = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @Timestamp Instant elementTs,\n+      @TimerFamily(\"actionTimers\") TimerMap timers) {\n+     timers.set(element.getValue().getActionType(), elementTs);\n+  }\n+  \n+   @OnTimerFamily(\"actionTimers\") public void onTimer(@TimerId String timerId) {\n+     LOG.info(\"Timer fired with id \" + timerId);\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.4 Timer output timestamps {#timer-output-timestamps}\n+By default, event-time timers will hold the output watermark of the `ParDo` to the timestamp of the timer. This means\n+that if a timer is set to 12pm, any windowed aggregations or event-time timers later in the pipeline graph that finish  \n+after 12pm will not expire. The timestamp of the timer is also the default output timestamp for the timer callback. This\n+means that any elements output from the onTimer method will have a timestamp equal to the timestamp of the timer firing.\n+For processing-time timers, the default output timestamp and watermark hold is the value of the input watermark at the\n+time the timer was set.\n+\n+In some cases, a pipeline needs to output timestamps earlier than the timer expiration time, and therefore also needs to\n+hold the watermark to those timestamps. For example, consider the following pipeline that temporarily batches records \n+into state, and sets a timer to drain the state. This code may appear correct, but will not work properly.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"elementBag\") private final StateSpec<BagState<ValueT>> elementBag = StateSpecs.bag();\n+  @StateId(\"timerSet\") private final StateSpec<ValueState<Boolean>> timerSet = StateSpecs.value();\n+  @TimerId(\"outputState\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+  \n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerSet\") ValueState<Boolean> timerSet,\n+      @TimerId(\"outputState\") Timer timer) {\n+    // Add the current element to the bag for this key.\n+    elementBag.add(element.getValue());\n+    if (!MoreObjects.firstNonNull(timerSet.read(), false)) {\n+      // If the timer is not current set, then set it to go off in a minute.\n+      timer.offset(Duration.standardMinutes(1)).setRelative();\n+      timerSet.write(true);\n+    }\n+  }\n+  \n+  @OnTimer(\"outputState\") public void onTimer(\n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerSet\") ValueState<Boolean> timerSet,\n+      OutputReceiver<ValueT> output) {\n+    for (ValueT bufferedElement : elementBag.read()) {\n+      // Output each element.\n+      output.outputWithTimestamp(bufferedElement, bufferedElement.timestamp());\n+    }\n+    elementBag.clear();\n+    // Note that the timer has now fired.\n+    timerSet.clear();\n+  }\n+}));\n+```\n+However the above code will not work properly. The ParDo is buffering elements, but nothing is preventing the watermark\n+from advancing past the timestamp of those elements, causing those elements to all be dropped as late data. In order\n+to prevent this from happening, an output timestamp needs to be set on the timer to prevent the watermark from advancing\n+past the timestamp of the minimum element. The following code demonstrates this.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  // The bag of elements accumulated.\n+  @StateId(\"elementBag\") private final StateSpec<BagState<ValueT>> elementBag = StateSpecs.bag();\n+  // The timestamp of the timer set.\n+  @StateId(\"timerTimestamp\") private final StateSpec<ValueState<Long>> timerTimestamp = StateSpecs.value();\n+  // The minimum timestamp stored in the bag.\n+  @StateId(\"minTimestampInBag\") private final StateSpec<CombiningState<Long, long[], Long>> \n+     minTimestampInBag = StateSpecs.combining(Min.ofLongs());\n+\n+  @TimerId(\"outputState\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+  \n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerTimestamp\") ValueState<Long> timerTimestamp,\n+      @StateId(\"minTimestampInBag\") CombiningState<Long, long[], Long> minTimestamp,\n+      @TimerId(\"outputState\") Timer timer) {\n+    timerTimestamp.readLater();\n+    minTimestamp.readLater();\n+\n+    // Add the current element to the bag for this key.\n+    elementBag.add(element.getValue());\n+    // Keep track of the minimum element timestamp currently stored in the bag.\n+    minTimestamp.add(element.getValue().timestamp());\n+\n+    // If the timer is already set, then reset it at the same time but with an updated output timestamp (otherwise\n+    // we would keep resetting the timer to the future). If there is no timer set, then set one to expire in a minute.\n+    Long timerTimestampMs = timerTimestamp.read();\n+    Instant timerToSet = (timerTimestamp.isEmpty().read())\n+        ? Instant.now().plus(Duration.standardMinutes(1)) : new Instant(timerTimestampMs);\n+    // Setting the outputTimestamp to the minimum timestamp in the bag holds the watermark to that timestamp until the\n+    // timer fires. This allows outputting all the elements with their timestamp.\n+    timer.withOutputTimestamp(minTimestamp.read()).set(timerToSet).\n+    timerTimestamp.write(timerToSet.getMillis());\n+  }\n+  \n+  @OnTimer(\"outputState\") public void onTimer(\n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerSet\") ValueState<Boolean> timerSet,\n+      OutputReceiver<ValueT> output) {\n+    for (ValueT bufferedElement : elementBag.read()) {\n+      // Output each element.\n+      output.outputWithTimestamp(bufferedElement, bufferedElement.timestamp());\n+    }\n+    // Note that the timer has now fired.\n+    timerTimestamp.clear();\n+  }\n+}));\n+```\n+### 10.4 Garbage collecting state {#garbage-collecting-state}\n+Per-key state needs to be garbage collected, or eventually the increasing size of state may negatively impact \n+performance. There are two common strategies for garbage collecting state.\n+\n+##### 10.4.1 Using windows for garbage collection {#using-windows-for-garbage-collection}\n+All state and timers for a key is scoped to the window it is in. This means that depending on the timestamp of the \n+input element the ParDo will see different values for the state depending on the window that element falls into. In\n+addition, once the input watermark passes the end of the window, the runner should garbage collect all state for that\n+window. (note: if allowed lateness is set to a positive value for the window, the runner must wait past the end of the\n+window in order to garbage collect state). This can be used as a garbage-collection strategy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NDgxOA==", "bodyText": "s/give/given/", "url": "https://github.com/apache/beam/pull/10854#discussion_r379164818", "createdAt": "2020-02-13T22:53:35Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<BagState<ValueT>> numElements = StateSpecs.bag();\n+  \n+  @ProcessElement public void process(\n+    @Element KV<String, ValueT> element, \n+    @StateId(\"state\") BagState<ValueT> state) {\n+    // Add the current element to the bag for this key.\n+    state.add(element.getValue());\n+    if (shouldFetch()) {\n+      // Occasionally we fetch and process the values.\n+      Iterable<ValueT> values = state.read();\n+      processValues(values);\n+      state.clear();  // Clear the state for this key.\n+    }\n+  }\n+}));\n+```\n+### 10.2 Deferred state reads {#deferred-state-reads}\n+When a `DoFn` contains multiple state specifications, reading each one in order can be slow. Calling the read() function\n+on a state can cause the runner to perform a blocking read. Performing multiple blocking reads in sequence adds latency\n+to element processing. The readLater method allows the runner to know that the state will be read in the future, \n+allowing multiple state reads to be batched together.\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state1\") private final StateSpec<ValueState<Integer>> state1 = StateSpecs.value();\n+  @StateId(\"state2\") private final StateSpec<ValueState<String>> state2 = StateSpecs.value();\n+  @StateId(\"state3\") private final StateSpec<BagState<ValueT>> state3 = StateSpecs.bag();\n+\n+  @ProcessElement public void process(\n+    @StateId(\"state1\") ValueState<Integer> state1,\n+    @StateId(\"state2\") ValueState<String> state2,\n+    @StateId(\"state3\") BagState<ValueT> state3) {\n+    state1.readLater();\n+    state2.readLater();\n+    state3.readLater();\n+   \n+    // The runner can now batch all three states into a single read, reducing latency.\n+    processState1(state1.read());\n+    processState2(state2.read());\n+    processState3(state3.read());\n+  }\n+}));\n+```\n+\n+### 10.3 Timers {#timers}\n+Beam provides a per-key timer callback API. This allows for delayed processing of data aggregated using the state API.\n+Timers can be set to callback at either an event-time or a processing-time timestamp. Every timer is identified with a\n+TimerId. A given timer for a keycan only be set for a single timestamp. Calling set on a timer overwrites the previous\n+firing time for that key's timer.\n+\n+#### 10.3.1 Event-time timers {#event-time-timers}\n+Event-time timers fire when the input watermark for the DoFn passes the time at which the timer is set, meaning that \n+the runner believes that there are no more elements to be processed with timestamps before the timer timestamp. This\n+allows for event-time aggregations. \n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> state = StateSpecs.value();\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element,\n+      @Timestamp Instant elementTs,\n+      @StateId(\"state\") ValueState<Integer> state, \n+      @TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set an event-time timer to the element timestamp.\n+     timer.set(elementTs);\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+#### 10.3.2 Processing-time timers {#processing-time-timers}\n+Processing-time timers fire when the real wall-clock time passes. This is often used to create larger batches of data\n+before processing. It can also be used to schedule events that should occur at a specific time. Just like with\n+event-time timers, processing-time timers are per key - each key has a separate copy of the timer.\n+\n+While processing-time timers can be set to an absolute timestamp, it is very common to set them to an offset relative \n+to the current time. The `Timer.offset` and `Timer.setRelative` methods can be used to accomplish this.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+  @ProcessElement public void process(@TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set a timer to go off 30 seconds in the future.\n+     timer.offset(Duration.standardSeconds(30).setRelative();\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.3 Dynamic timer tags {#dynamic-timer-tags}\n+Beam also supports dynamically setting a timer tag using `TimerMap`. This allows for setting multiple different timers\n+in a `ParDo` and allowing for the timer tags to be dynamically chosen - e.g. based on data in the input elements. A\n+timer with a specific tag can only be set to a single timestamp, so setting the timer again has the effect of\n+overwriting the previous expiration time for the timer with that tag. Each `TimerMap` is identified with a timer family\n+id, and timers in different timer families are independent.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerFamily(\"actionTimers\") private final TimerSpec timer = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @Timestamp Instant elementTs,\n+      @TimerFamily(\"actionTimers\") TimerMap timers) {\n+     timers.set(element.getValue().getActionType(), elementTs);\n+  }\n+  \n+   @OnTimerFamily(\"actionTimers\") public void onTimer(@TimerId String timerId) {\n+     LOG.info(\"Timer fired with id \" + timerId);\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.4 Timer output timestamps {#timer-output-timestamps}\n+By default, event-time timers will hold the output watermark of the `ParDo` to the timestamp of the timer. This means\n+that if a timer is set to 12pm, any windowed aggregations or event-time timers later in the pipeline graph that finish  \n+after 12pm will not expire. The timestamp of the timer is also the default output timestamp for the timer callback. This\n+means that any elements output from the onTimer method will have a timestamp equal to the timestamp of the timer firing.\n+For processing-time timers, the default output timestamp and watermark hold is the value of the input watermark at the\n+time the timer was set.\n+\n+In some cases, a pipeline needs to output timestamps earlier than the timer expiration time, and therefore also needs to\n+hold the watermark to those timestamps. For example, consider the following pipeline that temporarily batches records \n+into state, and sets a timer to drain the state. This code may appear correct, but will not work properly.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"elementBag\") private final StateSpec<BagState<ValueT>> elementBag = StateSpecs.bag();\n+  @StateId(\"timerSet\") private final StateSpec<ValueState<Boolean>> timerSet = StateSpecs.value();\n+  @TimerId(\"outputState\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+  \n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerSet\") ValueState<Boolean> timerSet,\n+      @TimerId(\"outputState\") Timer timer) {\n+    // Add the current element to the bag for this key.\n+    elementBag.add(element.getValue());\n+    if (!MoreObjects.firstNonNull(timerSet.read(), false)) {\n+      // If the timer is not current set, then set it to go off in a minute.\n+      timer.offset(Duration.standardMinutes(1)).setRelative();\n+      timerSet.write(true);\n+    }\n+  }\n+  \n+  @OnTimer(\"outputState\") public void onTimer(\n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerSet\") ValueState<Boolean> timerSet,\n+      OutputReceiver<ValueT> output) {\n+    for (ValueT bufferedElement : elementBag.read()) {\n+      // Output each element.\n+      output.outputWithTimestamp(bufferedElement, bufferedElement.timestamp());\n+    }\n+    elementBag.clear();\n+    // Note that the timer has now fired.\n+    timerSet.clear();\n+  }\n+}));\n+```\n+However the above code will not work properly. The ParDo is buffering elements, but nothing is preventing the watermark\n+from advancing past the timestamp of those elements, causing those elements to all be dropped as late data. In order\n+to prevent this from happening, an output timestamp needs to be set on the timer to prevent the watermark from advancing\n+past the timestamp of the minimum element. The following code demonstrates this.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  // The bag of elements accumulated.\n+  @StateId(\"elementBag\") private final StateSpec<BagState<ValueT>> elementBag = StateSpecs.bag();\n+  // The timestamp of the timer set.\n+  @StateId(\"timerTimestamp\") private final StateSpec<ValueState<Long>> timerTimestamp = StateSpecs.value();\n+  // The minimum timestamp stored in the bag.\n+  @StateId(\"minTimestampInBag\") private final StateSpec<CombiningState<Long, long[], Long>> \n+     minTimestampInBag = StateSpecs.combining(Min.ofLongs());\n+\n+  @TimerId(\"outputState\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+  \n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerTimestamp\") ValueState<Long> timerTimestamp,\n+      @StateId(\"minTimestampInBag\") CombiningState<Long, long[], Long> minTimestamp,\n+      @TimerId(\"outputState\") Timer timer) {\n+    timerTimestamp.readLater();\n+    minTimestamp.readLater();\n+\n+    // Add the current element to the bag for this key.\n+    elementBag.add(element.getValue());\n+    // Keep track of the minimum element timestamp currently stored in the bag.\n+    minTimestamp.add(element.getValue().timestamp());\n+\n+    // If the timer is already set, then reset it at the same time but with an updated output timestamp (otherwise\n+    // we would keep resetting the timer to the future). If there is no timer set, then set one to expire in a minute.\n+    Long timerTimestampMs = timerTimestamp.read();\n+    Instant timerToSet = (timerTimestamp.isEmpty().read())\n+        ? Instant.now().plus(Duration.standardMinutes(1)) : new Instant(timerTimestampMs);\n+    // Setting the outputTimestamp to the minimum timestamp in the bag holds the watermark to that timestamp until the\n+    // timer fires. This allows outputting all the elements with their timestamp.\n+    timer.withOutputTimestamp(minTimestamp.read()).set(timerToSet).\n+    timerTimestamp.write(timerToSet.getMillis());\n+  }\n+  \n+  @OnTimer(\"outputState\") public void onTimer(\n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerSet\") ValueState<Boolean> timerSet,\n+      OutputReceiver<ValueT> output) {\n+    for (ValueT bufferedElement : elementBag.read()) {\n+      // Output each element.\n+      output.outputWithTimestamp(bufferedElement, bufferedElement.timestamp());\n+    }\n+    // Note that the timer has now fired.\n+    timerTimestamp.clear();\n+  }\n+}));\n+```\n+### 10.4 Garbage collecting state {#garbage-collecting-state}\n+Per-key state needs to be garbage collected, or eventually the increasing size of state may negatively impact \n+performance. There are two common strategies for garbage collecting state.\n+\n+##### 10.4.1 Using windows for garbage collection {#using-windows-for-garbage-collection}\n+All state and timers for a key is scoped to the window it is in. This means that depending on the timestamp of the \n+input element the ParDo will see different values for the state depending on the window that element falls into. In\n+addition, once the input watermark passes the end of the window, the runner should garbage collect all state for that\n+window. (note: if allowed lateness is set to a positive value for the window, the runner must wait past the end of the\n+window in order to garbage collect state). This can be used as a garbage-collection strategy.\n+\n+For example, give the following:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NTE1Mg==", "bodyText": "Might be worth including a link to the GroupIntoBatches transform here", "url": "https://github.com/apache/beam/pull/10854#discussion_r379165152", "createdAt": "2020-02-13T22:54:27Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<BagState<ValueT>> numElements = StateSpecs.bag();\n+  \n+  @ProcessElement public void process(\n+    @Element KV<String, ValueT> element, \n+    @StateId(\"state\") BagState<ValueT> state) {\n+    // Add the current element to the bag for this key.\n+    state.add(element.getValue());\n+    if (shouldFetch()) {\n+      // Occasionally we fetch and process the values.\n+      Iterable<ValueT> values = state.read();\n+      processValues(values);\n+      state.clear();  // Clear the state for this key.\n+    }\n+  }\n+}));\n+```\n+### 10.2 Deferred state reads {#deferred-state-reads}\n+When a `DoFn` contains multiple state specifications, reading each one in order can be slow. Calling the read() function\n+on a state can cause the runner to perform a blocking read. Performing multiple blocking reads in sequence adds latency\n+to element processing. The readLater method allows the runner to know that the state will be read in the future, \n+allowing multiple state reads to be batched together.\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state1\") private final StateSpec<ValueState<Integer>> state1 = StateSpecs.value();\n+  @StateId(\"state2\") private final StateSpec<ValueState<String>> state2 = StateSpecs.value();\n+  @StateId(\"state3\") private final StateSpec<BagState<ValueT>> state3 = StateSpecs.bag();\n+\n+  @ProcessElement public void process(\n+    @StateId(\"state1\") ValueState<Integer> state1,\n+    @StateId(\"state2\") ValueState<String> state2,\n+    @StateId(\"state3\") BagState<ValueT> state3) {\n+    state1.readLater();\n+    state2.readLater();\n+    state3.readLater();\n+   \n+    // The runner can now batch all three states into a single read, reducing latency.\n+    processState1(state1.read());\n+    processState2(state2.read());\n+    processState3(state3.read());\n+  }\n+}));\n+```\n+\n+### 10.3 Timers {#timers}\n+Beam provides a per-key timer callback API. This allows for delayed processing of data aggregated using the state API.\n+Timers can be set to callback at either an event-time or a processing-time timestamp. Every timer is identified with a\n+TimerId. A given timer for a keycan only be set for a single timestamp. Calling set on a timer overwrites the previous\n+firing time for that key's timer.\n+\n+#### 10.3.1 Event-time timers {#event-time-timers}\n+Event-time timers fire when the input watermark for the DoFn passes the time at which the timer is set, meaning that \n+the runner believes that there are no more elements to be processed with timestamps before the timer timestamp. This\n+allows for event-time aggregations. \n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> state = StateSpecs.value();\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element,\n+      @Timestamp Instant elementTs,\n+      @StateId(\"state\") ValueState<Integer> state, \n+      @TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set an event-time timer to the element timestamp.\n+     timer.set(elementTs);\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+#### 10.3.2 Processing-time timers {#processing-time-timers}\n+Processing-time timers fire when the real wall-clock time passes. This is often used to create larger batches of data\n+before processing. It can also be used to schedule events that should occur at a specific time. Just like with\n+event-time timers, processing-time timers are per key - each key has a separate copy of the timer.\n+\n+While processing-time timers can be set to an absolute timestamp, it is very common to set them to an offset relative \n+to the current time. The `Timer.offset` and `Timer.setRelative` methods can be used to accomplish this.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+  @ProcessElement public void process(@TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set a timer to go off 30 seconds in the future.\n+     timer.offset(Duration.standardSeconds(30).setRelative();\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.3 Dynamic timer tags {#dynamic-timer-tags}\n+Beam also supports dynamically setting a timer tag using `TimerMap`. This allows for setting multiple different timers\n+in a `ParDo` and allowing for the timer tags to be dynamically chosen - e.g. based on data in the input elements. A\n+timer with a specific tag can only be set to a single timestamp, so setting the timer again has the effect of\n+overwriting the previous expiration time for the timer with that tag. Each `TimerMap` is identified with a timer family\n+id, and timers in different timer families are independent.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerFamily(\"actionTimers\") private final TimerSpec timer = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @Timestamp Instant elementTs,\n+      @TimerFamily(\"actionTimers\") TimerMap timers) {\n+     timers.set(element.getValue().getActionType(), elementTs);\n+  }\n+  \n+   @OnTimerFamily(\"actionTimers\") public void onTimer(@TimerId String timerId) {\n+     LOG.info(\"Timer fired with id \" + timerId);\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.4 Timer output timestamps {#timer-output-timestamps}\n+By default, event-time timers will hold the output watermark of the `ParDo` to the timestamp of the timer. This means\n+that if a timer is set to 12pm, any windowed aggregations or event-time timers later in the pipeline graph that finish  \n+after 12pm will not expire. The timestamp of the timer is also the default output timestamp for the timer callback. This\n+means that any elements output from the onTimer method will have a timestamp equal to the timestamp of the timer firing.\n+For processing-time timers, the default output timestamp and watermark hold is the value of the input watermark at the\n+time the timer was set.\n+\n+In some cases, a pipeline needs to output timestamps earlier than the timer expiration time, and therefore also needs to\n+hold the watermark to those timestamps. For example, consider the following pipeline that temporarily batches records \n+into state, and sets a timer to drain the state. This code may appear correct, but will not work properly.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"elementBag\") private final StateSpec<BagState<ValueT>> elementBag = StateSpecs.bag();\n+  @StateId(\"timerSet\") private final StateSpec<ValueState<Boolean>> timerSet = StateSpecs.value();\n+  @TimerId(\"outputState\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+  \n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerSet\") ValueState<Boolean> timerSet,\n+      @TimerId(\"outputState\") Timer timer) {\n+    // Add the current element to the bag for this key.\n+    elementBag.add(element.getValue());\n+    if (!MoreObjects.firstNonNull(timerSet.read(), false)) {\n+      // If the timer is not current set, then set it to go off in a minute.\n+      timer.offset(Duration.standardMinutes(1)).setRelative();\n+      timerSet.write(true);\n+    }\n+  }\n+  \n+  @OnTimer(\"outputState\") public void onTimer(\n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerSet\") ValueState<Boolean> timerSet,\n+      OutputReceiver<ValueT> output) {\n+    for (ValueT bufferedElement : elementBag.read()) {\n+      // Output each element.\n+      output.outputWithTimestamp(bufferedElement, bufferedElement.timestamp());\n+    }\n+    elementBag.clear();\n+    // Note that the timer has now fired.\n+    timerSet.clear();\n+  }\n+}));\n+```\n+However the above code will not work properly. The ParDo is buffering elements, but nothing is preventing the watermark\n+from advancing past the timestamp of those elements, causing those elements to all be dropped as late data. In order\n+to prevent this from happening, an output timestamp needs to be set on the timer to prevent the watermark from advancing\n+past the timestamp of the minimum element. The following code demonstrates this.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  // The bag of elements accumulated.\n+  @StateId(\"elementBag\") private final StateSpec<BagState<ValueT>> elementBag = StateSpecs.bag();\n+  // The timestamp of the timer set.\n+  @StateId(\"timerTimestamp\") private final StateSpec<ValueState<Long>> timerTimestamp = StateSpecs.value();\n+  // The minimum timestamp stored in the bag.\n+  @StateId(\"minTimestampInBag\") private final StateSpec<CombiningState<Long, long[], Long>> \n+     minTimestampInBag = StateSpecs.combining(Min.ofLongs());\n+\n+  @TimerId(\"outputState\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+  \n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerTimestamp\") ValueState<Long> timerTimestamp,\n+      @StateId(\"minTimestampInBag\") CombiningState<Long, long[], Long> minTimestamp,\n+      @TimerId(\"outputState\") Timer timer) {\n+    timerTimestamp.readLater();\n+    minTimestamp.readLater();\n+\n+    // Add the current element to the bag for this key.\n+    elementBag.add(element.getValue());\n+    // Keep track of the minimum element timestamp currently stored in the bag.\n+    minTimestamp.add(element.getValue().timestamp());\n+\n+    // If the timer is already set, then reset it at the same time but with an updated output timestamp (otherwise\n+    // we would keep resetting the timer to the future). If there is no timer set, then set one to expire in a minute.\n+    Long timerTimestampMs = timerTimestamp.read();\n+    Instant timerToSet = (timerTimestamp.isEmpty().read())\n+        ? Instant.now().plus(Duration.standardMinutes(1)) : new Instant(timerTimestampMs);\n+    // Setting the outputTimestamp to the minimum timestamp in the bag holds the watermark to that timestamp until the\n+    // timer fires. This allows outputting all the elements with their timestamp.\n+    timer.withOutputTimestamp(minTimestamp.read()).set(timerToSet).\n+    timerTimestamp.write(timerToSet.getMillis());\n+  }\n+  \n+  @OnTimer(\"outputState\") public void onTimer(\n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerSet\") ValueState<Boolean> timerSet,\n+      OutputReceiver<ValueT> output) {\n+    for (ValueT bufferedElement : elementBag.read()) {\n+      // Output each element.\n+      output.outputWithTimestamp(bufferedElement, bufferedElement.timestamp());\n+    }\n+    // Note that the timer has now fired.\n+    timerTimestamp.clear();\n+  }\n+}));\n+```\n+### 10.4 Garbage collecting state {#garbage-collecting-state}\n+Per-key state needs to be garbage collected, or eventually the increasing size of state may negatively impact \n+performance. There are two common strategies for garbage collecting state.\n+\n+##### 10.4.1 Using windows for garbage collection {#using-windows-for-garbage-collection}\n+All state and timers for a key is scoped to the window it is in. This means that depending on the timestamp of the \n+input element the ParDo will see different values for the state depending on the window that element falls into. In\n+addition, once the input watermark passes the end of the window, the runner should garbage collect all state for that\n+window. (note: if allowed lateness is set to a positive value for the window, the runner must wait past the end of the\n+window in order to garbage collect state). This can be used as a garbage-collection strategy.\n+\n+For example, give the following:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(Window.into(CalendarWindows.days(1).withTimeZone(DateTimeZone.forID(\"America/Los_Angeles\"))));\n+       .apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+           @StateId(\"state\") private final StateSpec<ValueState<Integer>> state = StateSpecs.value();\n+                              ...\n+           @ProcessElement public void process(@Timestamp Instant ts, @StateId(\"state\") ValueState<Integer> state) {\n+              // The state is scoped to a calendar day window. That means that if the input timestamp ts is after\n+              // midnight PST, then a new copy of the state will be seen for the next day.\n+           }\n+         }));\n+```\n+\n+This `ParDo` stores state per day. Once the pipeline is done processing data for a given day, all the state for that\n+day is garbage collected.\n+\n+##### 10.4.1 Using timers For garbage collection {#using-timers-for-garbage-collection}\n+In some cases, it is difficult to find a windowing strategy that models the desired garbage-collection strategy. For \n+example, a common desire is to garbage collect state for a key once no activity has been seen on the key for some time.\n+This can be done by updating a timer that garbage collects state. For example\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  // The state for the key.\n+  @StateId(\"state\") private final StateSpec<ValueState<ValueT>> state = StateSpecs.value();\n+\n+  // The maximum element timestamp seen so far.\n+  @StateId(\"maxTimestampSeen\") private final StateSpec<CombiningState<Long, long[], Long>> \n+     maxTimestamp = StateSpecs.combining(Max.ofLongs());\n+\n+  @TimerId(\"gcTimer\") private final TimerSpec gcTimer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element,\n+      @Timestamp Instant ts,\n+      @StateId(\"state\") ValueState<ValueT> state,\n+      @StateId(\"maxTimestampSeen\") CombiningState<Long, long[], Long> maxTimestamp,\n+      @TimerId(\"gcTimer\") gcTimer) { \n+    updateState(state, element);\n+    maxTimestamp.add(ts.getMillis());\n+    \n+    // Set the timer to be one hour after the maximum timestamp seen. This will keep overwriting the same timer, so \n+    // as long as there is activity on this key the state will stay active. Once the key goes inactive for one hour's\n+    // worth of event time (as measured by the watermark), then the gc timer will fire.\n+    Instant expirationTime = new Instant(maxTimestamp.read()).plus(Duration.standardHours(1));\n+    timer.set(expirationTime);\n+  }\n+\n+  @OnTimer(\"gcTimer\") public void onTimer(\n+      @StateId(\"state\") ValueState<ValueT> state,\n+      @StateId(\"maxTimestampSeen\") CombiningState<Long, long[], Long> maxTimestamp) {\n+       // Clear all state for the key.\n+       state.clear();\n+       maxTimestamp.clear();\n+    }\n+ }\n+````\n+\n+### 10.5 State and timers examples {#state-timers-examples}\n+Following are some example uses of state and timers\n+\n+#### 10.5.1. Joining clicks and views {#joining-clicks-and-views}\n+In this example, the pipeline is processing data from an e-commerce site's home page. There are two input streams:\n+a stream of views, representing suggested product links displayed to the user on the home page, and a stream of \n+clicks, representing actual user clicks on these links. The goal of the pipeline is to join click events with view\n+events, outputting a new joined event that contains information from both events. Each link has a unique identifier\n+that is present in both the view event and the join event.\n+\n+Many view events will never be followed up with clicks. This pipeline will wait one hour for a click, after which it \n+will give up on this join. While every click event should have a view event, some small number of view events may be\n+lost and never make it to the Beam pipeline; the pipeline will similarly wait one hour after seeing a click event, and\n+give up if the view event does not arrive in that time. Input events are not ordered - it is possible to see the click \n+event before the view event. The one hour join timeout should be based on event time, not on processing time.\n+\n+```java\n+// Read the event stream and key it by the link id.\n+PCollection<KV<String, Event>> eventsPerLinkId = \n+    readEvents()\n+    .apply(WithKeys.of(Event::getLinkId).withKeyType(TypeDescriptors.strings()));\n+\n+perUser.apply(ParDo.of(new DoFn<KV<String, Event>, JoinedEvent>() {\n+  // Store the view event.\n+  @StateId(\"view\") private final StateSpec<ValueState<Event>> viewState = StateSpecs.value();\n+  // Store the click event.\n+  @StateId(\"click\") private final StateSpec<ValueState<Event>> clickState = StateSpecs.value();\n+\n+  // The maximum element timestamp seen so far.\n+  @StateId(\"maxTimestampSeen\") private final StateSpec<CombiningState<Long, long[], Long>> \n+     maxTimestamp = StateSpecs.combining(Max.ofLongs());\n+\n+  // Timer that fires when an hour goes by with an incomplete join.\n+  @TimerId(\"gcTimer\") private final TimerSpec gcTimer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, Event> element,\n+      @Timestamp Instant ts,\n+      @StateId(\"view\") ValueState<Event> viewState,\n+      @StateId(\"click\") ValueState<Event> clickState,\n+      @StateId(\"maxTimestampSeen\") CombiningState<Long, long[], Long> maxTimestampState,\n+      @TimerId(\"gcTimer\") gcTimer,\n+      OutputReceiver<JoinedEvent> output) { \n+    // For performance, note all the states that will be read in order to allow efficient read batching.\n+    viewState.readLater();\n+    clickState.readLater();\n+    maxTimestampState.readLater();\n+\n+    // Store the event into the correct state variable.\n+    Event event = element.getValue();\n+    ValueState<Event> valueState = event.getType().equals(VIEW) ? viewState : clickState;\n+    valueState.write(event);\n+  \n+    Event view = viewState.read();\n+    Event click = clickState.read();\n+    (if view != null && click != null) {\n+      // We've seen both a view and a click. Output a joined event and clear state.\n+      output.output(JoinedEvent.of(view, click));\n+      clearState(viewState, clickState, maxTimestampState);\n+    } else {\n+       // We've only seen on half of the join.\n+       // Set the timer to be one hour after the maximum timestamp seen. This will keep overwriting the same timer, so \n+       // as long as there is activity on this key the state will stay active. Once the key goes inactive for one hour's\n+       // worth of event time (as measured by the watermark), then the gc timer will fire.\n+        maxTimestampState.add(ts.getMillis());\n+       Instant expirationTime = new Instant(maxTimestampState.read()).plus(Duration.standardHours(1));\n+       timer.set(expirationTime);\n+    }\n+  }\n+\n+  @OnTimer(\"gcTimer\") public void onTimer(\n+      @StateId(\"view\") ValueState<Event> viewState,\n+      @StateId(\"click\") ValueState<Event> clickState,\n+      @StateId(\"maxTimestampSeen\") CombiningState<Long, long[], Long> maxTimestampState) {\n+       // An hour has gone by with an incomplete join. Give up and clear the state.\n+       clearState(viewState, clickState, maxTimestampState);\n+    }\n+   \n+    private void clearState(\n+      @StateId(\"view\") ValueState<Event> viewState,\n+      @StateId(\"click\") ValueState<Event> clickState,\n+      @StateId(\"maxTimestampSeen\") CombiningState<Long, long[], Long> maxTimestampState) {\n+      viewState.clear();\n+      clickState.clear();\n+      maxTimestampState.clear();\n+    }\n+ }\n+````\n+\n+#### 10.5.2 Batching RPCs {#batching-rpcs}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 473}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NTQ2Mw==", "bodyText": "timerSet is a confusing name, use isTimerSet or timerIsSet instead, here and below", "url": "https://github.com/apache/beam/pull/10854#discussion_r379165463", "createdAt": "2020-02-13T22:55:25Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<BagState<ValueT>> numElements = StateSpecs.bag();\n+  \n+  @ProcessElement public void process(\n+    @Element KV<String, ValueT> element, \n+    @StateId(\"state\") BagState<ValueT> state) {\n+    // Add the current element to the bag for this key.\n+    state.add(element.getValue());\n+    if (shouldFetch()) {\n+      // Occasionally we fetch and process the values.\n+      Iterable<ValueT> values = state.read();\n+      processValues(values);\n+      state.clear();  // Clear the state for this key.\n+    }\n+  }\n+}));\n+```\n+### 10.2 Deferred state reads {#deferred-state-reads}\n+When a `DoFn` contains multiple state specifications, reading each one in order can be slow. Calling the read() function\n+on a state can cause the runner to perform a blocking read. Performing multiple blocking reads in sequence adds latency\n+to element processing. The readLater method allows the runner to know that the state will be read in the future, \n+allowing multiple state reads to be batched together.\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state1\") private final StateSpec<ValueState<Integer>> state1 = StateSpecs.value();\n+  @StateId(\"state2\") private final StateSpec<ValueState<String>> state2 = StateSpecs.value();\n+  @StateId(\"state3\") private final StateSpec<BagState<ValueT>> state3 = StateSpecs.bag();\n+\n+  @ProcessElement public void process(\n+    @StateId(\"state1\") ValueState<Integer> state1,\n+    @StateId(\"state2\") ValueState<String> state2,\n+    @StateId(\"state3\") BagState<ValueT> state3) {\n+    state1.readLater();\n+    state2.readLater();\n+    state3.readLater();\n+   \n+    // The runner can now batch all three states into a single read, reducing latency.\n+    processState1(state1.read());\n+    processState2(state2.read());\n+    processState3(state3.read());\n+  }\n+}));\n+```\n+\n+### 10.3 Timers {#timers}\n+Beam provides a per-key timer callback API. This allows for delayed processing of data aggregated using the state API.\n+Timers can be set to callback at either an event-time or a processing-time timestamp. Every timer is identified with a\n+TimerId. A given timer for a keycan only be set for a single timestamp. Calling set on a timer overwrites the previous\n+firing time for that key's timer.\n+\n+#### 10.3.1 Event-time timers {#event-time-timers}\n+Event-time timers fire when the input watermark for the DoFn passes the time at which the timer is set, meaning that \n+the runner believes that there are no more elements to be processed with timestamps before the timer timestamp. This\n+allows for event-time aggregations. \n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> state = StateSpecs.value();\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element,\n+      @Timestamp Instant elementTs,\n+      @StateId(\"state\") ValueState<Integer> state, \n+      @TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set an event-time timer to the element timestamp.\n+     timer.set(elementTs);\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+#### 10.3.2 Processing-time timers {#processing-time-timers}\n+Processing-time timers fire when the real wall-clock time passes. This is often used to create larger batches of data\n+before processing. It can also be used to schedule events that should occur at a specific time. Just like with\n+event-time timers, processing-time timers are per key - each key has a separate copy of the timer.\n+\n+While processing-time timers can be set to an absolute timestamp, it is very common to set them to an offset relative \n+to the current time. The `Timer.offset` and `Timer.setRelative` methods can be used to accomplish this.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+  @ProcessElement public void process(@TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set a timer to go off 30 seconds in the future.\n+     timer.offset(Duration.standardSeconds(30).setRelative();\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.3 Dynamic timer tags {#dynamic-timer-tags}\n+Beam also supports dynamically setting a timer tag using `TimerMap`. This allows for setting multiple different timers\n+in a `ParDo` and allowing for the timer tags to be dynamically chosen - e.g. based on data in the input elements. A\n+timer with a specific tag can only be set to a single timestamp, so setting the timer again has the effect of\n+overwriting the previous expiration time for the timer with that tag. Each `TimerMap` is identified with a timer family\n+id, and timers in different timer families are independent.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerFamily(\"actionTimers\") private final TimerSpec timer = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @Timestamp Instant elementTs,\n+      @TimerFamily(\"actionTimers\") TimerMap timers) {\n+     timers.set(element.getValue().getActionType(), elementTs);\n+  }\n+  \n+   @OnTimerFamily(\"actionTimers\") public void onTimer(@TimerId String timerId) {\n+     LOG.info(\"Timer fired with id \" + timerId);\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.4 Timer output timestamps {#timer-output-timestamps}\n+By default, event-time timers will hold the output watermark of the `ParDo` to the timestamp of the timer. This means\n+that if a timer is set to 12pm, any windowed aggregations or event-time timers later in the pipeline graph that finish  \n+after 12pm will not expire. The timestamp of the timer is also the default output timestamp for the timer callback. This\n+means that any elements output from the onTimer method will have a timestamp equal to the timestamp of the timer firing.\n+For processing-time timers, the default output timestamp and watermark hold is the value of the input watermark at the\n+time the timer was set.\n+\n+In some cases, a pipeline needs to output timestamps earlier than the timer expiration time, and therefore also needs to\n+hold the watermark to those timestamps. For example, consider the following pipeline that temporarily batches records \n+into state, and sets a timer to drain the state. This code may appear correct, but will not work properly.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"elementBag\") private final StateSpec<BagState<ValueT>> elementBag = StateSpecs.bag();\n+  @StateId(\"timerSet\") private final StateSpec<ValueState<Boolean>> timerSet = StateSpecs.value();\n+  @TimerId(\"outputState\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+  \n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element, \n+      @StateId(\"elementBag\") BagState<ValueT> elementBag,\n+      @StateId(\"timerSet\") ValueState<Boolean> timerSet,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NTg5Mg==", "bodyText": "Be consistent between using DoFn vs ParDo; I think DoFn is probably better", "url": "https://github.com/apache/beam/pull/10854#discussion_r379165892", "createdAt": "2020-02-13T22:56:35Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<BagState<ValueT>> numElements = StateSpecs.bag();\n+  \n+  @ProcessElement public void process(\n+    @Element KV<String, ValueT> element, \n+    @StateId(\"state\") BagState<ValueT> state) {\n+    // Add the current element to the bag for this key.\n+    state.add(element.getValue());\n+    if (shouldFetch()) {\n+      // Occasionally we fetch and process the values.\n+      Iterable<ValueT> values = state.read();\n+      processValues(values);\n+      state.clear();  // Clear the state for this key.\n+    }\n+  }\n+}));\n+```\n+### 10.2 Deferred state reads {#deferred-state-reads}\n+When a `DoFn` contains multiple state specifications, reading each one in order can be slow. Calling the read() function\n+on a state can cause the runner to perform a blocking read. Performing multiple blocking reads in sequence adds latency\n+to element processing. The readLater method allows the runner to know that the state will be read in the future, \n+allowing multiple state reads to be batched together.\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state1\") private final StateSpec<ValueState<Integer>> state1 = StateSpecs.value();\n+  @StateId(\"state2\") private final StateSpec<ValueState<String>> state2 = StateSpecs.value();\n+  @StateId(\"state3\") private final StateSpec<BagState<ValueT>> state3 = StateSpecs.bag();\n+\n+  @ProcessElement public void process(\n+    @StateId(\"state1\") ValueState<Integer> state1,\n+    @StateId(\"state2\") ValueState<String> state2,\n+    @StateId(\"state3\") BagState<ValueT> state3) {\n+    state1.readLater();\n+    state2.readLater();\n+    state3.readLater();\n+   \n+    // The runner can now batch all three states into a single read, reducing latency.\n+    processState1(state1.read());\n+    processState2(state2.read());\n+    processState3(state3.read());\n+  }\n+}));\n+```\n+\n+### 10.3 Timers {#timers}\n+Beam provides a per-key timer callback API. This allows for delayed processing of data aggregated using the state API.\n+Timers can be set to callback at either an event-time or a processing-time timestamp. Every timer is identified with a\n+TimerId. A given timer for a keycan only be set for a single timestamp. Calling set on a timer overwrites the previous\n+firing time for that key's timer.\n+\n+#### 10.3.1 Event-time timers {#event-time-timers}\n+Event-time timers fire when the input watermark for the DoFn passes the time at which the timer is set, meaning that \n+the runner believes that there are no more elements to be processed with timestamps before the timer timestamp. This\n+allows for event-time aggregations. \n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> state = StateSpecs.value();\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element,\n+      @Timestamp Instant elementTs,\n+      @StateId(\"state\") ValueState<Integer> state, \n+      @TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set an event-time timer to the element timestamp.\n+     timer.set(elementTs);\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+#### 10.3.2 Processing-time timers {#processing-time-timers}\n+Processing-time timers fire when the real wall-clock time passes. This is often used to create larger batches of data\n+before processing. It can also be used to schedule events that should occur at a specific time. Just like with\n+event-time timers, processing-time timers are per key - each key has a separate copy of the timer.\n+\n+While processing-time timers can be set to an absolute timestamp, it is very common to set them to an offset relative \n+to the current time. The `Timer.offset` and `Timer.setRelative` methods can be used to accomplish this.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+  @ProcessElement public void process(@TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set a timer to go off 30 seconds in the future.\n+     timer.offset(Duration.standardSeconds(30).setRelative();\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+\n+#### 10.3.3 Dynamic timer tags {#dynamic-timer-tags}\n+Beam also supports dynamically setting a timer tag using `TimerMap`. This allows for setting multiple different timers\n+in a `ParDo` and allowing for the timer tags to be dynamically chosen - e.g. based on data in the input elements. A", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NzEwMQ==", "bodyText": "bag collections seems redundant; maybe just \"bags\"?", "url": "https://github.com/apache/beam/pull/10854#discussion_r379167101", "createdAt": "2020-02-13T23:00:06Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NzQ4Mw==", "bodyText": "put code in backticks", "url": "https://github.com/apache/beam/pull/10854#discussion_r379167483", "createdAt": "2020-02-13T23:01:17Z", "author": {"login": "dpmills"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<BagState<ValueT>> numElements = StateSpecs.bag();\n+  \n+  @ProcessElement public void process(\n+    @Element KV<String, ValueT> element, \n+    @StateId(\"state\") BagState<ValueT> state) {\n+    // Add the current element to the bag for this key.\n+    state.add(element.getValue());\n+    if (shouldFetch()) {\n+      // Occasionally we fetch and process the values.\n+      Iterable<ValueT> values = state.read();\n+      processValues(values);\n+      state.clear();  // Clear the state for this key.\n+    }\n+  }\n+}));\n+```\n+### 10.2 Deferred state reads {#deferred-state-reads}\n+When a `DoFn` contains multiple state specifications, reading each one in order can be slow. Calling the read() function", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODA4MDA5", "url": "https://github.com/apache/beam/pull/10854#pullrequestreview-360808009", "createdAt": "2020-02-19T02:35:54Z", "commit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjozNTo1NFrOFrZUNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjo0Njo0N1rOFrZeIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0Nzg2Mw==", "bodyText": "However there are aggregation use cases for which developers may require a higher degree of control...", "url": "https://github.com/apache/beam/pull/10854#discussion_r381047863", "createdAt": "2020-02-19T02:35:54Z", "author": {"login": "rezarokni"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0ODIyMA==", "bodyText": "Also important to point out that you can use different window strategies before the State call. Something which I have seen folks not realise until pointed out.\nFor example Window+Combiner as a reducer before data comes to the state DoFn", "url": "https://github.com/apache/beam/pull/10854#discussion_r381048220", "createdAt": "2020-02-19T02:37:28Z", "author": {"login": "rezarokni"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0ODU3OA==", "bodyText": "Worth explicitly calling out the lack of order? Although it doesnt matter for this use case, ValueState can be misused for other things when not aware of no order", "url": "https://github.com/apache/beam/pull/10854#discussion_r381048578", "createdAt": "2020-02-19T02:38:57Z", "author": {"login": "rezarokni"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1MDQwMQ==", "bodyText": "Worth mentioning expected behaviour if used in batch pipeline. If I recall direct runner doesnt fire process time timers?", "url": "https://github.com/apache/beam/pull/10854#discussion_r381050401", "createdAt": "2020-02-19T02:46:47Z", "author": {"login": "rezarokni"}, "path": "website/src/documentation/programming-guide.md", "diffHunk": "@@ -3121,3 +3121,515 @@ public class MyMetricsDoFn extends DoFn<Integer, Integer> {\n   }\n }\n ```  \n+\n+## 10. State and Timers {#state-and-timers}\n+Beam's windowing and triggering facilities provide a powerful abstraction for grouping and aggregating unbounded input\n+data based on timestamps. However there are aggregation use cases for which Beam's windows and triggers are not the best\n+fit. Beam provides an API for manually managing per-key state, allowing for finer-grained control over aggregations.\n+\n+Beam's state API models state per key. To use the state API, you start out with a keyed `PCollection`, which in Java\n+is modeled as a `PCollection<KV<K, V>>`. A `ParDo` processing this `PCollection` can now declare state variables. Inside\n+the `ParDo` these state variables can be used to write or update state for the current key or to read previous state\n+written for that key. State is always fully scoped only to the current processing key.\n+\n+Windowing can still be used together with stateful processing. All state for a key is scoped to the current window. This\n+means that the first time a key is seen for a given window any state reads will return empty, and that a runner can\n+garbage collect state when a window is completed.  Merging windows are not currently supported when using state and timers.\n+\n+\n+### 10.1 Types of state {#types-of-state}\n+Beam provides several types of state:\n+\n+#### ValueState\n+A DoFn declares states to be accessed by creating final `StateSpec` member variables representing each state. Each\n+state must be named using the `StateId` annotation; this name is unique to a ParDo in the graph and has no relation\n+to other nodes in the graph. A `DoFn` can declare multiple state variables.\n+\n+If the type of the ValueState has a coder registered, then Beam will automatically infer the coder for the state value.\n+For example, the following ParDo creates a single state variable that accumulates the number of elements seen.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> numElements = StateSpecs.value();\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    // Read the number element seen so far for this user key.\n+    // state.read() returns null if it was never set. The below code allows us to have a default value of 0.\n+    int currentValue = MoreObjects.firstNonNull(state.read(), 0);\n+    // Update the state.\n+    state.write(currentValue + 1);\n+  }\n+}));\n+```\n+\n+Beam also allows explicitly specifying a coder for `ValueState` values. For example:\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<MyType>> numElements = StateSpecs.value(new MyTypeCoder());\n+                 ...\n+}));\n+```\n+\n+#### CombiningState\n+`CombiningState` allows you to create a state object that is updated using a Beam combiner. For example, the previous\n+`ValueState` example could be rewritten to use `CombiningState`\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<CombiningState<Integer, int[], Integer>> numElements = \n+      StateSpecs.combining(Sum.ofIntegers());\n+  \n+  @ProcessElement public void process(@StateId(\"state\") ValueState<Integer> state) {\n+    state.add(1);\n+  }\n+}));\n+```\n+\n+#### BagState\n+A common use case for state is to accumulate multiple elements. `BagState` allows for accumulating elements in an \n+unordered manner. This allows for addition of elements to the collection without requiring the reading of the entire\n+collection first, which is an efficiency gain. In addition, runners that support paged reads can allow individual\n+bag collections larger than available memory.\n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<BagState<ValueT>> numElements = StateSpecs.bag();\n+  \n+  @ProcessElement public void process(\n+    @Element KV<String, ValueT> element, \n+    @StateId(\"state\") BagState<ValueT> state) {\n+    // Add the current element to the bag for this key.\n+    state.add(element.getValue());\n+    if (shouldFetch()) {\n+      // Occasionally we fetch and process the values.\n+      Iterable<ValueT> values = state.read();\n+      processValues(values);\n+      state.clear();  // Clear the state for this key.\n+    }\n+  }\n+}));\n+```\n+### 10.2 Deferred state reads {#deferred-state-reads}\n+When a `DoFn` contains multiple state specifications, reading each one in order can be slow. Calling the read() function\n+on a state can cause the runner to perform a blocking read. Performing multiple blocking reads in sequence adds latency\n+to element processing. The readLater method allows the runner to know that the state will be read in the future, \n+allowing multiple state reads to be batched together.\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state1\") private final StateSpec<ValueState<Integer>> state1 = StateSpecs.value();\n+  @StateId(\"state2\") private final StateSpec<ValueState<String>> state2 = StateSpecs.value();\n+  @StateId(\"state3\") private final StateSpec<BagState<ValueT>> state3 = StateSpecs.bag();\n+\n+  @ProcessElement public void process(\n+    @StateId(\"state1\") ValueState<Integer> state1,\n+    @StateId(\"state2\") ValueState<String> state2,\n+    @StateId(\"state3\") BagState<ValueT> state3) {\n+    state1.readLater();\n+    state2.readLater();\n+    state3.readLater();\n+   \n+    // The runner can now batch all three states into a single read, reducing latency.\n+    processState1(state1.read());\n+    processState2(state2.read());\n+    processState3(state3.read());\n+  }\n+}));\n+```\n+\n+### 10.3 Timers {#timers}\n+Beam provides a per-key timer callback API. This allows for delayed processing of data aggregated using the state API.\n+Timers can be set to callback at either an event-time or a processing-time timestamp. Every timer is identified with a\n+TimerId. A given timer for a keycan only be set for a single timestamp. Calling set on a timer overwrites the previous\n+firing time for that key's timer.\n+\n+#### 10.3.1 Event-time timers {#event-time-timers}\n+Event-time timers fire when the input watermark for the DoFn passes the time at which the timer is set, meaning that \n+the runner believes that there are no more elements to be processed with timestamps before the timer timestamp. This\n+allows for event-time aggregations. \n+\n+```java\n+PCollection<KV<String, ValueT>> perUser = readPerUser();\n+perUser.apply(ParDo.of(new DoFn<KV<String, ValueT>, OutputT>() {\n+  @StateId(\"state\") private final StateSpec<ValueState<Integer>> state = StateSpecs.value();\n+  @TimerId(\"timer\") private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  @ProcessElement public void process(\n+      @Element KV<String, ValueT> element,\n+      @Timestamp Instant elementTs,\n+      @StateId(\"state\") ValueState<Integer> state, \n+      @TimerId(\"timer\") Timer timer) {\n+     ...\n+     // Set an event-time timer to the element timestamp.\n+     timer.set(elementTs);\n+  }\n+  \n+   @OnTimer(\"timer\") public void onTimer() {\n+      //Process timer.\n+   }\n+}));\n+\n+```\n+#### 10.3.2 Processing-time timers {#processing-time-timers}\n+Processing-time timers fire when the real wall-clock time passes. This is often used to create larger batches of data", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b"}, "originalPosition": 158}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd8c8c7ffa5d41da5ceb3d95db664535d624b37c", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/dd8c8c7ffa5d41da5ceb3d95db664535d624b37c", "committedDate": "2020-02-24T16:56:54Z", "message": "foo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e728eac7292cf5769d79cb367c197ede12af7f85", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/e728eac7292cf5769d79cb367c197ede12af7f85", "committedDate": "2020-02-24T16:56:54Z", "message": "foo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d625b7a3376ca6e9442f7309a3148f3bca63dcce", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/d625b7a3376ca6e9442f7309a3148f3bca63dcce", "committedDate": "2020-02-24T16:56:54Z", "message": "foo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8450f78124d54f5c82d5b4ad5145994a0747b41", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/c8450f78124d54f5c82d5b4ad5145994a0747b41", "committedDate": "2020-02-24T17:00:32Z", "message": "fix stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "114f298356f1484480a104d60370020312eeb0a4", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/114f298356f1484480a104d60370020312eeb0a4", "committedDate": "2020-02-24T17:00:32Z", "message": "state timers documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff020a57da32225dd095bc50b63883d5b4833ffd", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/ff020a57da32225dd095bc50b63883d5b4833ffd", "committedDate": "2020-02-24T17:02:01Z", "message": "Revert files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9cab46cc6105a4b540f4e3dceed8f7c4898b080", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/f9cab46cc6105a4b540f4e3dceed8f7c4898b080", "committedDate": "2020-02-24T17:02:02Z", "message": "add TOC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4824b19ea74ca9c6c3108c8a108131d5a92446d", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/b4824b19ea74ca9c6c3108c8a108131d5a92446d", "committedDate": "2020-02-24T18:04:54Z", "message": "address CR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6052fb0f17591f13d9f9f8dc2514440673ab0b8b", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/6052fb0f17591f13d9f9f8dc2514440673ab0b8b", "committedDate": "2020-02-13T22:10:46Z", "message": "add TOC"}, "afterCommit": {"oid": "b4824b19ea74ca9c6c3108c8a108131d5a92446d", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/b4824b19ea74ca9c6c3108c8a108131d5a92446d", "committedDate": "2020-02-24T18:04:54Z", "message": "address CR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4593c9fd63a40aa88aadbd67c67684b0139ab64c", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/4593c9fd63a40aa88aadbd67c67684b0139ab64c", "committedDate": "2020-02-24T20:21:45Z", "message": "Undo changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTYyNjcx", "url": "https://github.com/apache/beam/pull/10854#pullrequestreview-364562671", "createdAt": "2020-02-26T01:11:32Z", "commit": {"oid": "4593c9fd63a40aa88aadbd67c67684b0139ab64c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc594db882e5b30f8330a8ff69104547e303affb", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/bc594db882e5b30f8330a8ff69104547e303affb", "committedDate": "2020-02-27T08:17:25Z", "message": "fix some bugs"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3124, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}