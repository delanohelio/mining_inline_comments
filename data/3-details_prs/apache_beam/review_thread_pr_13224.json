{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNTMxMTI4", "number": 13224, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODoyMjowOVrOE0f9Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODozMDo0NFrOE0gIzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDg0OTU1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODoyMjowOVrOHsQkPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODoyMjowOVrOHsQkPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MDgxMw==", "bodyText": "This was intentionally 'plot' for better summarization (e.g. to see that x% of methods that we won't implement are due to them being plotting). A traceback would point to the actual method used. But if we want to be more specific, that's OK too.", "url": "https://github.com/apache/beam/pull/13224#discussion_r516170813", "createdAt": "2020-11-02T18:22:09Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -1391,30 +1397,22 @@ def _is_associative(func):\n       and func.__module__ in ('numpy', 'builtins'))\n \n \n+\n+@populate_not_implemented(pd.core.groupby.generic.DataFrameGroupBy)\n class _DeferredGroupByCols(frame_base.DeferredFrame):\n   # It's not clear that all of these make sense in Pandas either...\n   agg = aggregate = frame_base._elementwise_method('agg')\n   any = frame_base._elementwise_method('any')\n   all = frame_base._elementwise_method('all')\n-  apply = frame_base.not_implemented_method('apply')\n-  backfill = bfill = frame_base.not_implemented_method('backfill')\n   boxplot = frame_base.wont_implement_method('plot')\n-  corr = frame_base.not_implemented_method('corr')\n-  corrwith = frame_base.not_implemented_method('corrwith')\n-  cov = frame_base.not_implemented_method('cov')\n-  cumcount = cummax = cummin = cumprod = cumsum = (\n-      frame_base.not_implemented_method('cum*'))\n   describe = frame_base.wont_implement_method('describe')\n   diff = frame_base._elementwise_method('diff')\n-  dtypes = frame_base.not_implemented_method('dtypes')\n-  expanding = frame_base.not_implemented_method('expanding')\n-  ffill = frame_base.not_implemented_method('ffill')\n   fillna = frame_base._elementwise_method('fillna')\n   filter = frame_base._elementwise_method('filter')\n   first = frame_base.wont_implement_method('order sensitive')\n   get_group = frame_base._elementwise_method('group')\n   head = frame_base.wont_implement_method('order sensitive')\n-  hist = frame_base.wont_implement_method('plot')\n+  hist = frame_base.wont_implement_method('hist')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae399f863e68183bd145ddec902ceb186b63242"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDg3OTQ4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/doctests.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODozMDo0NFrOHsQ2zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODozMDo0NFrOHsQ2zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3NTU2NA==", "bodyText": "Nice cleanup, this is much better.", "url": "https://github.com/apache/beam/pull/13224#discussion_r516175564", "createdAt": "2020-11-02T18:30:44Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/doctests.py", "diffHunk": "@@ -253,27 +251,37 @@ def sort_and_normalize(text):\n \n   @property\n   def _seen_error(self):\n-    return self._seen_wont_implement or self._seen_not_implemented\n+    return self._last_error is not None\n \n   def check_output(self, want, got, optionflags):\n     # When an error occurs check_output is called with want=example.exc_msg,\n     # and got=exc_msg\n-    if got.startswith(WONT_IMPLEMENT) and (want.startswith(WONT_IMPLEMENT) or\n-                                           want.startswith(NOT_IMPLEMENTED)):\n-      self._seen_wont_implement = True\n-      return True\n-    elif got.startswith(NOT_IMPLEMENTED) and want.startswith(NOT_IMPLEMENTED):\n-      self._seen_not_implemented = True\n-      return True\n-    elif got.startswith('NameError') and self._seen_error:\n-      # After raising WontImplementError or NotImplementError,\n-      # ignore a NameError.\n-      # This allows us to gracefully skip tests like\n-      #    >>> res = df.unsupported_operation()\n-      #    >>> check(res)\n-      return True\n-    else:\n-      self.reset()\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4a5d0a65f0a0a98db7777278aa4343c549df016"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2883, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}