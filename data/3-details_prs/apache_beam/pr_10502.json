{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5MTk3MjEy", "number": 10502, "title": "[BEAM-7274] Add DynamicMessage Schema support", "bodyText": "Add DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.\nR: @reuvenlax\n\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-01-04T09:00:16Z", "url": "https://github.com/apache/beam/pull/10502", "merged": true, "mergeCommit": {"oid": "7990bc7547285d64227092e8b30252d215a9050f"}, "closed": true, "closedAt": "2020-02-25T23:40:10Z", "author": {"login": "alexvanboxel"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb3Ha3xgBqjI5MjE5ODQ5MjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcH6reeABqjMwNzE0NDE2MTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e4a6ec64fc66b84a133ba5854056f44a31f5bd31", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/e4a6ec64fc66b84a133ba5854056f44a31f5bd31", "committedDate": "2020-01-04T08:58:28Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "3a6ca71ca00b3545712a2b6f8d38a0f90bc373a5", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/3a6ca71ca00b3545712a2b6f8d38a0f90bc373a5", "committedDate": "2020-01-04T18:39:08Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95fc532a68e5e3ccacc64588e13bbb834f4957a8", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/95fc532a68e5e3ccacc64588e13bbb834f4957a8", "committedDate": "2020-01-06T13:00:27Z", "message": "small fixup"}, "afterCommit": {"oid": "04a8580fb7d9e2874f96e22360072ec46873712a", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/04a8580fb7d9e2874f96e22360072ec46873712a", "committedDate": "2020-01-07T20:57:33Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "04a8580fb7d9e2874f96e22360072ec46873712a", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/04a8580fb7d9e2874f96e22360072ec46873712a", "committedDate": "2020-01-07T20:57:33Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "058a636713473cc67b2440377fcba8e10c4f37e2", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/058a636713473cc67b2440377fcba8e10c4f37e2", "committedDate": "2020-01-08T07:57:48Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "058a636713473cc67b2440377fcba8e10c4f37e2", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/058a636713473cc67b2440377fcba8e10c4f37e2", "committedDate": "2020-01-08T07:57:48Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "97414c64dd4dc617c67c4593ee5d18f058c374d7", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/97414c64dd4dc617c67c4593ee5d18f058c374d7", "committedDate": "2020-01-08T09:32:46Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "97414c64dd4dc617c67c4593ee5d18f058c374d7", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/97414c64dd4dc617c67c4593ee5d18f058c374d7", "committedDate": "2020-01-08T09:32:46Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "e352ff4d0f1914a8da75e641c585e4c84322df7c", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/e352ff4d0f1914a8da75e641c585e4c84322df7c", "committedDate": "2020-01-10T16:06:00Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e352ff4d0f1914a8da75e641c585e4c84322df7c", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/e352ff4d0f1914a8da75e641c585e4c84322df7c", "committedDate": "2020-01-10T16:06:00Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "9145d754ac9f6765343c3f98276701dfc8dbfcc7", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/9145d754ac9f6765343c3f98276701dfc8dbfcc7", "committedDate": "2020-02-06T07:00:48Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9145d754ac9f6765343c3f98276701dfc8dbfcc7", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/9145d754ac9f6765343c3f98276701dfc8dbfcc7", "committedDate": "2020-02-06T07:00:48Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "51f9c9df56fb7f3ffe8960c2ee07a8153926c0fc", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/51f9c9df56fb7f3ffe8960c2ee07a8153926c0fc", "committedDate": "2020-02-08T15:32:08Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51f9c9df56fb7f3ffe8960c2ee07a8153926c0fc", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/51f9c9df56fb7f3ffe8960c2ee07a8153926c0fc", "committedDate": "2020-02-08T15:32:08Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "a83d80349d9eeda6cd7f58386c5ab4308803a3a5", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/a83d80349d9eeda6cd7f58386c5ab4308803a3a5", "committedDate": "2020-02-08T21:40:26Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a83d80349d9eeda6cd7f58386c5ab4308803a3a5", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/a83d80349d9eeda6cd7f58386c5ab4308803a3a5", "committedDate": "2020-02-08T21:40:26Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "602869aeaf884b2ef34835db82f3b5066c75b284", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/602869aeaf884b2ef34835db82f3b5066c75b284", "committedDate": "2020-02-10T19:36:11Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "602869aeaf884b2ef34835db82f3b5066c75b284", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/602869aeaf884b2ef34835db82f3b5066c75b284", "committedDate": "2020-02-10T19:36:11Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "7e57a3995947127ffaaf9fa623c94f453702f864", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/7e57a3995947127ffaaf9fa623c94f453702f864", "committedDate": "2020-02-12T16:36:20Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7e57a3995947127ffaaf9fa623c94f453702f864", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/7e57a3995947127ffaaf9fa623c94f453702f864", "committedDate": "2020-02-12T16:36:20Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "9a13256b40799af257a826ba2a06bed5bd0c7c48", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/9a13256b40799af257a826ba2a06bed5bd0c7c48", "committedDate": "2020-02-18T13:49:27Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a13256b40799af257a826ba2a06bed5bd0c7c48", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/9a13256b40799af257a826ba2a06bed5bd0c7c48", "committedDate": "2020-02-18T13:49:27Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "0edacbb42c74a4cebaa1b454a6897afc3684c0e7", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/0edacbb42c74a4cebaa1b454a6897afc3684c0e7", "committedDate": "2020-02-18T23:47:53Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0edacbb42c74a4cebaa1b454a6897afc3684c0e7", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/0edacbb42c74a4cebaa1b454a6897afc3684c0e7", "committedDate": "2020-02-18T23:47:53Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}, "afterCommit": {"oid": "012c45a8174f61d47ba31b2d47f03deb86c77fa5", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/012c45a8174f61d47ba31b2d47f03deb86c77fa5", "committedDate": "2020-02-20T12:28:46Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMTUyMjI0", "url": "https://github.com/apache/beam/pull/10502#pullrequestreview-363152224", "createdAt": "2020-02-24T02:52:10Z", "commit": {"oid": "012c45a8174f61d47ba31b2d47f03deb86c77fa5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwMjo1MjoxMFrOFtUvYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwMzowMToxNlrOFtUzsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3MDA1MA==", "bodyText": "I think you can replace the lambda with this::indexDescriptor", "url": "https://github.com/apache/beam/pull/10502#discussion_r383070050", "createdAt": "2020-02-24T02:52:10Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/extensions/protobuf/src/main/java/org/apache/beam/sdk/extensions/protobuf/ProtoDomain.java", "diffHunk": "@@ -163,15 +163,15 @@ private void indexDescriptorByName() {\n         .values()\n         .forEach(\n             fileDescriptor -> {\n-              fileDescriptor\n-                  .getMessageTypes()\n-                  .forEach(\n-                      descriptor -> {\n-                        descriptorMap.put(descriptor.getFullName(), descriptor);\n-                      });\n+              fileDescriptor.getMessageTypes().forEach(descriptor -> indexDescriptor(descriptor));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "012c45a8174f61d47ba31b2d47f03deb86c77fa5"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3MDEyNA==", "bodyText": "you can do the same here - forEach(this::indexDescriptor)", "url": "https://github.com/apache/beam/pull/10502#discussion_r383070124", "createdAt": "2020-02-24T02:52:56Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/extensions/protobuf/src/main/java/org/apache/beam/sdk/extensions/protobuf/ProtoDomain.java", "diffHunk": "@@ -163,15 +163,15 @@ private void indexDescriptorByName() {\n         .values()\n         .forEach(\n             fileDescriptor -> {\n-              fileDescriptor\n-                  .getMessageTypes()\n-                  .forEach(\n-                      descriptor -> {\n-                        descriptorMap.put(descriptor.getFullName(), descriptor);\n-                      });\n+              fileDescriptor.getMessageTypes().forEach(descriptor -> indexDescriptor(descriptor));\n             });\n   }\n \n+  private void indexDescriptor(Descriptors.Descriptor descriptor) {\n+    descriptorMap.put(descriptor.getFullName(), descriptor);\n+    descriptor.getNestedTypes().forEach(nested -> indexDescriptor(nested));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "012c45a8174f61d47ba31b2d47f03deb86c77fa5"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3MTE1Mg==", "bodyText": "I don't think we should be storing SchemaCoder objects around here. I think preferable to store schema and to/from row functions separately.", "url": "https://github.com/apache/beam/pull/10502#discussion_r383071152", "createdAt": "2020-02-24T03:01:16Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/extensions/protobuf/src/main/java/org/apache/beam/sdk/extensions/protobuf/ProtoDynamicMessageSchema.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.protobuf;\n+\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getFieldNumber;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMapKeyMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMapValueMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.withFieldNumber;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.withMessageName;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Descriptors;\n+import com.google.protobuf.Descriptors.FieldDescriptor;\n+import com.google.protobuf.DynamicMessage;\n+import com.google.protobuf.Message;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.SchemaCoder;\n+import org.apache.beam.sdk.schemas.logicaltypes.EnumerationType;\n+import org.apache.beam.sdk.schemas.logicaltypes.NanosDuration;\n+import org.apache.beam.sdk.schemas.logicaltypes.NanosInstant;\n+import org.apache.beam.sdk.schemas.logicaltypes.OneOfType;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+\n+@Experimental(Experimental.Kind.SCHEMAS)\n+public class ProtoDynamicMessageSchema<T> implements Serializable {\n+  public static final long serialVersionUID = 1L;\n+\n+  /**\n+   * Context of the schema, the context can be generated from a source schema or descriptors. The\n+   * ability of converting back from Row to proto depends on the type of context.\n+   */\n+  private final Context context;\n+\n+  /** THe SchemaCoder holds the resolved schema and to/fromRow functions. */\n+  private transient SchemaCoder schemaCoder;\n+\n+  /** List of field converters for each field in the row. */\n+  private transient List<Convert> converters;\n+\n+  private ProtoDynamicMessageSchema(String messageName, ProtoDomain domain) {\n+    this.context = new DescriptorContext(messageName, domain);\n+    readResolve();\n+  }\n+\n+  private ProtoDynamicMessageSchema(Context context) {\n+    this.context = context;\n+    readResolve();\n+  }\n+\n+  /**\n+   * Create a new ProtoDynamicMessageSchema from a {@link ProtoDomain} and for a message. The\n+   * message need to be in the domain and needs to be the fully qualified name.\n+   */\n+  public static ProtoDynamicMessageSchema forDescriptor(ProtoDomain domain, String messageName) {\n+    return new ProtoDynamicMessageSchema(messageName, domain);\n+  }\n+\n+  /**\n+   * Create a new ProtoDynamicMessageSchema from a {@link ProtoDomain} and for a descriptor. The\n+   * descriptor is only used for it's name, that name will be used for a search in the domain.\n+   */\n+  public static ProtoDynamicMessageSchema<DynamicMessage> forDescriptor(\n+      ProtoDomain domain, Descriptors.Descriptor descriptor) {\n+    return new ProtoDynamicMessageSchema<>(descriptor.getFullName(), domain);\n+  }\n+\n+  static ProtoDynamicMessageSchema<?> forContext(Context context, Schema.Field field) {\n+    return new ProtoDynamicMessageSchema<>(context.getSubContext(field));\n+  }\n+\n+  static ProtoDynamicMessageSchema<Message> forSchema(Schema schema) {\n+    return new ProtoDynamicMessageSchema<>(new Context(schema, Message.class));\n+  }\n+\n+  /** Initialize the transient fields after deserialization or construction. */\n+  private Object readResolve() {\n+    converters = createConverters(context.getSchema());\n+    schemaCoder =\n+        SchemaCoder.of(\n+            context.getSchema(),\n+            TypeDescriptor.of(context.getBaseClass()),\n+            new MessageToRowFunction(),\n+            new RowToMessageFunction());\n+    return this;\n+  }\n+\n+  Convert createConverter(Schema.Field field) {\n+    Schema.FieldType fieldType = field.getType();\n+    String messageName = getMessageName(fieldType);\n+    if (messageName != null && messageName.length() > 0) {\n+      Schema.Field valueField =\n+          Schema.Field.of(\"value\", withFieldNumber(Schema.FieldType.BOOLEAN, 1));\n+      switch (messageName) {\n+        case \"google.protobuf.StringValue\":\n+        case \"google.protobuf.DoubleValue\":\n+        case \"google.protobuf.FloatValue\":\n+        case \"google.protobuf.BoolValue\":\n+        case \"google.protobuf.Int64Value\":\n+        case \"google.protobuf.Int32Value\":\n+        case \"google.protobuf.UInt64Value\":\n+        case \"google.protobuf.UInt32Value\":\n+          return new WrapperConvert(field, new PrimitiveConvert(valueField));\n+        case \"google.protobuf.BytesValue\":\n+          return new WrapperConvert(field, new BytesConvert(valueField));\n+        case \"google.protobuf.Timestamp\":\n+        case \"google.protobuf.Duration\":\n+          // handled by logical type case\n+          break;\n+      }\n+    }\n+    switch (fieldType.getTypeName()) {\n+      case BYTE:\n+      case INT16:\n+      case INT32:\n+      case INT64:\n+      case FLOAT:\n+      case DOUBLE:\n+      case STRING:\n+      case BOOLEAN:\n+        return new PrimitiveConvert(field);\n+      case BYTES:\n+        return new BytesConvert(field);\n+      case ARRAY:\n+      case ITERABLE:\n+        return new ArrayConvert(this, field);\n+      case MAP:\n+        return new MapConvert(this, field);\n+      case LOGICAL_TYPE:\n+        String identifier = field.getType().getLogicalType().getIdentifier();\n+        switch (identifier) {\n+          case ProtoSchemaLogicalTypes.Fixed32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.Fixed64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SFixed32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SFixed64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SInt32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SInt64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.UInt32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.UInt64.IDENTIFIER:\n+            return new LogicalTypeConvert(field, fieldType.getLogicalType());\n+          case NanosInstant.IDENTIFIER:\n+            return new TimestampConvert(field);\n+          case NanosDuration.IDENTIFIER:\n+            return new DurationConvert(field);\n+          case EnumerationType.IDENTIFIER:\n+            return new EnumConvert(field, fieldType.getLogicalType());\n+          case OneOfType.IDENTIFIER:\n+            return new OneOfConvert(this, field, fieldType.getLogicalType());\n+          default:\n+            throw new IllegalStateException(\"Unexpected logical type : \" + identifier);\n+        }\n+      case ROW:\n+        return new MessageConvert(this, field);\n+      default:\n+        throw new IllegalStateException(\"Unexpected value: \" + fieldType);\n+    }\n+  }\n+\n+  private List<Convert> createConverters(Schema schema) {\n+    List<Convert> fieldOverlays = new ArrayList<>();\n+    for (Schema.Field field : schema.getFields()) {\n+      fieldOverlays.add(createConverter(field));\n+    }\n+    return fieldOverlays;\n+  }\n+\n+  public Schema getSchema() {\n+    return this.schemaCoder.getSchema();\n+  }\n+\n+  public SchemaCoder<T> getSchemaCoder() {\n+    return schemaCoder;\n+  }\n+\n+  public SerializableFunction<T, Row> getToRowFunction() {\n+    return schemaCoder.getToRowFunction();\n+  }\n+\n+  public SerializableFunction<Row, T> getFromRowFunction() {\n+    return schemaCoder.getFromRowFunction();\n+  }\n+\n+  /**\n+   * Context that only has enough information to convert a proto message to a Row. This can be used\n+   * for arbitrary conventions, like decoding messages in proto options.\n+   */\n+  static class Context<T> implements Serializable {\n+    private final Schema schema;\n+\n+    /**\n+     * Base class for the protobuf message. Normally this is DynamicMessage, but as this schema\n+     * class is also used to decode protobuf options this can be normal Message instances.\n+     */\n+    private Class<T> baseClass;\n+\n+    Context(Schema schema, Class<T> baseClass) {\n+      this.schema = schema;\n+      this.baseClass = baseClass;\n+    }\n+\n+    public Schema getSchema() {\n+      return schema;\n+    }\n+\n+    public Class<T> getBaseClass() {\n+      return baseClass;\n+    }\n+\n+    public DynamicMessage.Builder invokeNewBuilder() {\n+      throw new IllegalStateException(\"Should not be calling invokeNewBuilder\");\n+    }\n+\n+    public Context getSubContext(Schema.Field field) {\n+      return new Context(field.getType().getRowSchema(), Message.class);\n+    }\n+  }\n+\n+  /**\n+   * Context the contains the full {@link ProtoDomain} and a reference to the message name. The full\n+   * domain is needed for creating Rows back to the original proto messages.\n+   */\n+  static class DescriptorContext extends Context<DynamicMessage> {\n+    private final String messageName;\n+    private final ProtoDomain domain;\n+    private transient Descriptors.Descriptor descriptor;\n+\n+    DescriptorContext(String messageName, ProtoDomain domain) {\n+      super(\n+          ProtoSchemaTranslator.getSchema(domain.getDescriptor(messageName)), DynamicMessage.class);\n+      this.messageName = messageName;\n+      this.domain = domain;\n+    }\n+\n+    @Override\n+    public DynamicMessage.Builder invokeNewBuilder() {\n+      if (descriptor == null) {\n+        descriptor = domain.getDescriptor(messageName);\n+      }\n+      return DynamicMessage.newBuilder(descriptor);\n+    }\n+\n+    @Override\n+    public Context getSubContext(Schema.Field field) {\n+      String messageName = getMessageName(field.getType());\n+      return new DescriptorContext(messageName, domain);\n+    }\n+  }\n+\n+  /**\n+   * Base converter class for converting from proto values to row values. The converter mainly works\n+   * on fields in proto messages but also has methods to convert individual elements (example, for\n+   * elements in Lists or Maps).\n+   */\n+  abstract static class Convert<ValueT, InT> {\n+    private int number;\n+\n+    Convert(Schema.Field field) {\n+      try {\n+        this.number = getFieldNumber(field.getType());\n+      } catch (NumberFormatException e) {\n+        this.number = -1;\n+      }\n+    }\n+\n+    FieldDescriptor getFieldDescriptor(Message message) {\n+      return message.getDescriptorForType().findFieldByNumber(number);\n+    }\n+\n+    FieldDescriptor getFieldDescriptor(Message.Builder message) {\n+      return message.getDescriptorForType().findFieldByNumber(number);\n+    }\n+\n+    /** Get a proto field and convert it into a row value. */\n+    abstract Object getFromProtoMessage(Message message);\n+\n+    /** Convert a proto value into a row value. */\n+    abstract ValueT convertFromProtoValue(Object object);\n+\n+    /** Convert a row value and set it on a proto message. */\n+    abstract void setOnProtoMessage(Message.Builder object, InT value);\n+\n+    /** Convert a row value into a proto value. */\n+    abstract Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value);\n+  }\n+\n+  /** Converter for primitive proto values. */\n+  static class PrimitiveConvert extends Convert<Object, Object> {\n+    PrimitiveConvert(Schema.Field field) {\n+      super(field);\n+    }\n+\n+    @Override\n+    Object getFromProtoMessage(Message message) {\n+      FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+      return convertFromProtoValue(message.getField(fieldDescriptor));\n+    }\n+\n+    @Override\n+    Object convertFromProtoValue(Object object) {\n+      return object;\n+    }\n+\n+    @Override\n+    void setOnProtoMessage(Message.Builder message, Object value) {\n+      message.setField(getFieldDescriptor(message), value);\n+    }\n+\n+    @Override\n+    Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value) {\n+      return value;\n+    }\n+  }\n+\n+  /**\n+   * Converter for Bytes. Protobuf Bytes are natively represented as ByteStrings that requires\n+   * special handling for byte[] of size 0.\n+   */\n+  static class BytesConvert extends PrimitiveConvert {\n+    BytesConvert(Schema.Field field) {\n+      super(field);\n+    }\n+\n+    @Override\n+    Object convertFromProtoValue(Object object) {\n+      // return object;\n+      return ((ByteString) object).toByteArray();\n+    }\n+\n+    @Override\n+    void setOnProtoMessage(Message.Builder message, Object value) {\n+      if (value != null && ((byte[]) value).length > 0) {\n+        // Protobuf messages BYTES doesn't like empty bytes?!\n+        FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+        message.setField(fieldDescriptor, convertToProtoValue(fieldDescriptor, value));\n+      }\n+    }\n+\n+    @Override\n+    Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value) {\n+      if (value != null) {\n+        return ByteString.copyFrom((byte[]) value);\n+      }\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Specific converter for Proto Wrapper values as they are translated into nullable row values.\n+   */\n+  static class WrapperConvert extends Convert<Object, Object> {\n+    private Convert valueConvert;\n+\n+    WrapperConvert(Schema.Field field, Convert valueConvert) {\n+      super(field);\n+      this.valueConvert = valueConvert;\n+    }\n+\n+    @Override\n+    Object getFromProtoMessage(Message message) {\n+      if (message.hasField(getFieldDescriptor(message))) {\n+        Message wrapper = (Message) message.getField(getFieldDescriptor(message));\n+        return valueConvert.getFromProtoMessage(wrapper);\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    Object convertFromProtoValue(Object object) {\n+      return object;\n+    }\n+\n+    @Override\n+    void setOnProtoMessage(Message.Builder message, Object value) {\n+      if (value != null) {\n+        DynamicMessage.Builder builder =\n+            DynamicMessage.newBuilder(getFieldDescriptor(message).getMessageType());\n+        valueConvert.setOnProtoMessage(builder, value);\n+        message.setField(getFieldDescriptor(message), builder.build());\n+      }\n+    }\n+\n+    @Override\n+    Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value) {\n+      return value;\n+    }\n+  }\n+\n+  static class TimestampConvert extends Convert<Object, Object> {\n+\n+    TimestampConvert(Schema.Field field) {\n+      super(field);\n+    }\n+\n+    @Override\n+    Object getFromProtoMessage(Message message) {\n+      FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+      if (message.hasField(fieldDescriptor)) {\n+        Message wrapper = (Message) message.getField(fieldDescriptor);\n+        return convertFromProtoValue(wrapper);\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    Object convertFromProtoValue(Object object) {\n+      Message timestamp = (Message) object;\n+      Descriptors.Descriptor timestampDescriptor = timestamp.getDescriptorForType();\n+      FieldDescriptor secondField = timestampDescriptor.findFieldByNumber(1);\n+      FieldDescriptor nanoField = timestampDescriptor.findFieldByNumber(2);\n+      long second = (long) timestamp.getField(secondField);\n+      int nano = (int) timestamp.getField(nanoField);\n+      return Instant.ofEpochSecond(second, nano);\n+    }\n+\n+    @Override\n+    void setOnProtoMessage(Message.Builder message, Object value) {\n+      if (value != null) {\n+        FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+        message.setField(fieldDescriptor, convertToProtoValue(fieldDescriptor, value));\n+      }\n+    }\n+\n+    @Override\n+    Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value) {\n+      Row row = (Row) value;\n+      return com.google.protobuf.Timestamp.newBuilder()\n+          .setSeconds(row.getInt64(0))\n+          .setNanos(row.getInt32(1))\n+          .build();\n+    }\n+  }\n+\n+  static class DurationConvert extends Convert<Object, Object> {\n+\n+    DurationConvert(Schema.Field field) {\n+      super(field);\n+    }\n+\n+    @Override\n+    Object getFromProtoMessage(Message message) {\n+      FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+      if (message.hasField(fieldDescriptor)) {\n+        Message wrapper = (Message) message.getField(fieldDescriptor);\n+        return convertFromProtoValue(wrapper);\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    Duration convertFromProtoValue(Object object) {\n+      Message timestamp = (Message) object;\n+      Descriptors.Descriptor timestampDescriptor = timestamp.getDescriptorForType();\n+      FieldDescriptor secondField = timestampDescriptor.findFieldByNumber(1);\n+      FieldDescriptor nanoField = timestampDescriptor.findFieldByNumber(2);\n+      long second = (long) timestamp.getField(secondField);\n+      int nano = (int) timestamp.getField(nanoField);\n+      return Duration.ofSeconds(second, nano);\n+    }\n+\n+    @Override\n+    void setOnProtoMessage(Message.Builder message, Object value) {\n+      if (value != null) {\n+        FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+        message.setField(fieldDescriptor, convertToProtoValue(fieldDescriptor, value));\n+      }\n+    }\n+\n+    @Override\n+    Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value) {\n+      Row row = (Row) value;\n+      return com.google.protobuf.Duration.newBuilder()\n+          .setSeconds(row.getInt64(0))\n+          .setNanos(row.getInt32(1))\n+          .build();\n+    }\n+  }\n+\n+  static class MessageConvert extends Convert<Object, Object> {\n+    private final SerializableFunction fromRowFunction;\n+    private final SerializableFunction toRowFunction;\n+\n+    MessageConvert(ProtoDynamicMessageSchema rootProtoSchema, Schema.Field field) {\n+      super(field);\n+      ProtoDynamicMessageSchema protoSchema =\n+          ProtoDynamicMessageSchema.forContext(rootProtoSchema.context, field);\n+      SchemaCoder<DynamicMessage> schemaCoder = protoSchema.getSchemaCoder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "012c45a8174f61d47ba31b2d47f03deb86c77fa5"}, "originalPosition": 512}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzAwMjE1", "url": "https://github.com/apache/beam/pull/10502#pullrequestreview-364300215", "createdAt": "2020-02-25T17:04:20Z", "commit": {"oid": "036b831635cf0e6ec57338bd081a3684f3c9b566"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNzowNDoyMVrOFuNwsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNzowNDoyMVrOFuNwsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAwNDI3NA==", "bodyText": "I don't see this function being used anywhere. Remove?", "url": "https://github.com/apache/beam/pull/10502#discussion_r384004274", "createdAt": "2020-02-25T17:04:21Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/extensions/protobuf/src/main/java/org/apache/beam/sdk/extensions/protobuf/ProtoDynamicMessageSchema.java", "diffHunk": "@@ -0,0 +1,854 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.protobuf;\n+\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getFieldNumber;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMapKeyMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMapValueMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.withFieldNumber;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.withMessageName;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Descriptors;\n+import com.google.protobuf.Descriptors.FieldDescriptor;\n+import com.google.protobuf.DynamicMessage;\n+import com.google.protobuf.Message;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.SchemaCoder;\n+import org.apache.beam.sdk.schemas.logicaltypes.EnumerationType;\n+import org.apache.beam.sdk.schemas.logicaltypes.NanosDuration;\n+import org.apache.beam.sdk.schemas.logicaltypes.NanosInstant;\n+import org.apache.beam.sdk.schemas.logicaltypes.OneOfType;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+\n+@Experimental(Experimental.Kind.SCHEMAS)\n+public class ProtoDynamicMessageSchema<T> implements Serializable {\n+  public static final long serialVersionUID = 1L;\n+\n+  /**\n+   * Context of the schema, the context can be generated from a source schema or descriptors. The\n+   * ability of converting back from Row to proto depends on the type of context.\n+   */\n+  private final Context context;\n+\n+  /** The toRow function to convert the Message to a Row. */\n+  private transient SerializableFunction<T, Row> toRowFunction;\n+\n+  /** The fromRow function to convert the Row to a Message. */\n+  private transient SerializableFunction<Row, T> fromRowFunction;\n+\n+  /** List of field converters for each field in the row. */\n+  private transient List<Convert> converters;\n+\n+  private ProtoDynamicMessageSchema(String messageName, ProtoDomain domain) {\n+    this.context = new DescriptorContext(messageName, domain);\n+    readResolve();\n+  }\n+\n+  private ProtoDynamicMessageSchema(Context context) {\n+    this.context = context;\n+    readResolve();\n+  }\n+\n+  /**\n+   * Create a new ProtoDynamicMessageSchema from a {@link ProtoDomain} and for a message. The\n+   * message need to be in the domain and needs to be the fully qualified name.\n+   */\n+  public static ProtoDynamicMessageSchema forDescriptor(ProtoDomain domain, String messageName) {\n+    return new ProtoDynamicMessageSchema(messageName, domain);\n+  }\n+\n+  /**\n+   * Create a new ProtoDynamicMessageSchema from a {@link ProtoDomain} and for a descriptor. The\n+   * descriptor is only used for it's name, that name will be used for a search in the domain.\n+   */\n+  public static ProtoDynamicMessageSchema<DynamicMessage> forDescriptor(\n+      ProtoDomain domain, Descriptors.Descriptor descriptor) {\n+    return new ProtoDynamicMessageSchema<>(descriptor.getFullName(), domain);\n+  }\n+\n+  static ProtoDynamicMessageSchema<?> forContext(Context context, Schema.Field field) {\n+    return new ProtoDynamicMessageSchema<>(context.getSubContext(field));\n+  }\n+\n+  static ProtoDynamicMessageSchema<Message> forSchema(Schema schema) {\n+    return new ProtoDynamicMessageSchema<>(new Context(schema, Message.class));\n+  }\n+\n+  /** Initialize the transient fields after deserialization or construction. */\n+  private Object readResolve() {\n+    converters = createConverters(context.getSchema());\n+    toRowFunction = new MessageToRowFunction();\n+    fromRowFunction = new RowToMessageFunction();\n+    return this;\n+  }\n+\n+  Convert createConverter(Schema.Field field) {\n+    Schema.FieldType fieldType = field.getType();\n+    String messageName = getMessageName(fieldType);\n+    if (messageName != null && messageName.length() > 0) {\n+      Schema.Field valueField =\n+          Schema.Field.of(\"value\", withFieldNumber(Schema.FieldType.BOOLEAN, 1));\n+      switch (messageName) {\n+        case \"google.protobuf.StringValue\":\n+        case \"google.protobuf.DoubleValue\":\n+        case \"google.protobuf.FloatValue\":\n+        case \"google.protobuf.BoolValue\":\n+        case \"google.protobuf.Int64Value\":\n+        case \"google.protobuf.Int32Value\":\n+        case \"google.protobuf.UInt64Value\":\n+        case \"google.protobuf.UInt32Value\":\n+          return new WrapperConvert(field, new PrimitiveConvert(valueField));\n+        case \"google.protobuf.BytesValue\":\n+          return new WrapperConvert(field, new BytesConvert(valueField));\n+        case \"google.protobuf.Timestamp\":\n+        case \"google.protobuf.Duration\":\n+          // handled by logical type case\n+          break;\n+      }\n+    }\n+    switch (fieldType.getTypeName()) {\n+      case BYTE:\n+      case INT16:\n+      case INT32:\n+      case INT64:\n+      case FLOAT:\n+      case DOUBLE:\n+      case STRING:\n+      case BOOLEAN:\n+        return new PrimitiveConvert(field);\n+      case BYTES:\n+        return new BytesConvert(field);\n+      case ARRAY:\n+      case ITERABLE:\n+        return new ArrayConvert(this, field);\n+      case MAP:\n+        return new MapConvert(this, field);\n+      case LOGICAL_TYPE:\n+        String identifier = field.getType().getLogicalType().getIdentifier();\n+        switch (identifier) {\n+          case ProtoSchemaLogicalTypes.Fixed32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.Fixed64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SFixed32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SFixed64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SInt32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SInt64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.UInt32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.UInt64.IDENTIFIER:\n+            return new LogicalTypeConvert(field, fieldType.getLogicalType());\n+          case NanosInstant.IDENTIFIER:\n+            return new TimestampConvert(field);\n+          case NanosDuration.IDENTIFIER:\n+            return new DurationConvert(field);\n+          case EnumerationType.IDENTIFIER:\n+            return new EnumConvert(field, fieldType.getLogicalType());\n+          case OneOfType.IDENTIFIER:\n+            return new OneOfConvert(this, field, fieldType.getLogicalType());\n+          default:\n+            throw new IllegalStateException(\"Unexpected logical type : \" + identifier);\n+        }\n+      case ROW:\n+        return new MessageConvert(this, field);\n+      default:\n+        throw new IllegalStateException(\"Unexpected value: \" + fieldType);\n+    }\n+  }\n+\n+  private List<Convert> createConverters(Schema schema) {\n+    List<Convert> fieldOverlays = new ArrayList<>();\n+    for (Schema.Field field : schema.getFields()) {\n+      fieldOverlays.add(createConverter(field));\n+    }\n+    return fieldOverlays;\n+  }\n+\n+  public Schema getSchema() {\n+    return context.getSchema();\n+  }\n+\n+  public SchemaCoder<T> getSchemaCoder() {\n+    return SchemaCoder.of(\n+        context.getSchema(),\n+        TypeDescriptor.of(context.getBaseClass()),\n+        toRowFunction,\n+        fromRowFunction);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "036b831635cf0e6ec57338bd081a3684f3c9b566"}, "originalPosition": 202}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a0fe93b2bd28d96a43583e123b09ccd4d0ca033", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/7a0fe93b2bd28d96a43583e123b09ccd4d0ca033", "committedDate": "2020-02-25T23:24:49Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "036b831635cf0e6ec57338bd081a3684f3c9b566", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/036b831635cf0e6ec57338bd081a3684f3c9b566", "committedDate": "2020-02-25T07:04:25Z", "message": "Remove use of SchemaCoder as container of schema and functions"}, "afterCommit": {"oid": "7a0fe93b2bd28d96a43583e123b09ccd4d0ca033", "author": {"user": {"login": "alexvanboxel", "name": "Alex Van Boxel"}}, "url": "https://github.com/apache/beam/commit/7a0fe93b2bd28d96a43583e123b09ccd4d0ca033", "committedDate": "2020-02-25T23:24:49Z", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3896, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}