{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NzU1Njcw", "number": 11296, "reviewThreads": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDoyNzo1NlrOD5kQBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xOVQxOTozNDo0OFrOFz1R4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjg5MzUxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDoyNzo1NlrOGQ6S8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMToxNzoyOVrOGktgcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NTUyMw==", "bodyText": "Different transforms may have different input/output buffers associated with them. Perhaps name this input_transform_to_buffer_id or buffer_id_by_consumer or similar.", "url": "https://github.com/apache/beam/pull/11296#discussion_r420385523", "createdAt": "2020-05-05T20:27:56Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -296,6 +297,12 @@ def __init__(self,\n     self.safe_coders = safe_coders\n     self.data_channel_coders = data_channel_coders\n \n+    self.transform_id_to_buffer_id = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0NzUwNg==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/11296#discussion_r441147506", "createdAt": "2020-06-16T21:17:29Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -296,6 +297,12 @@ def __init__(self,\n     self.safe_coders = safe_coders\n     self.data_channel_coders = data_channel_coders\n \n+    self.transform_id_to_buffer_id = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NTUyMw=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjkwOTc3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDozMjo0MFrOGQ6c-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMToyMjowOFrOGktpEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4ODA4OQ==", "bodyText": "Are these fired_timers, or timers_to_fire?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420388089", "createdAt": "2020-05-05T20:32:40Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -363,16 +387,17 @@ def _run_bundle_multiple_times_for_testing(\n       finally:\n         runner_execution_context.state_servicer.restore()\n \n+  @staticmethod\n   def _collect_written_timers_and_add_to_fired_timers(\n-      self,\n       bundle_context_manager,  # type: execution.BundleContextManager\n       fired_timers  # type: Dict[Tuple[str, str], ListBuffer]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0OTcxMg==", "bodyText": "Great observation. Fixed.", "url": "https://github.com/apache/beam/pull/11296#discussion_r441149712", "createdAt": "2020-06-16T21:22:08Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -363,16 +387,17 @@ def _run_bundle_multiple_times_for_testing(\n       finally:\n         runner_execution_context.state_servicer.restore()\n \n+  @staticmethod\n   def _collect_written_timers_and_add_to_fired_timers(\n-      self,\n       bundle_context_manager,  # type: execution.BundleContextManager\n       fired_timers  # type: Dict[Tuple[str, str], ListBuffer]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4ODA4OQ=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjk2NjIyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo0OToxM1rOGQ6_5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTozNzo1N1rOGkuFbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5NzAyOQ==", "bodyText": "Set of PCollection ids? Buffer ids?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420397029", "createdAt": "2020-05-05T20:49:13Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -384,13 +409,25 @@ def _collect_written_timers_and_add_to_fired_timers(\n         out = create_OutputStream()\n         for decoded_timer in timers_by_key_and_window.values():\n           timer_coder_impl.encode_to_stream(decoded_timer, out, True)\n+          if (transform_id, timer_family_id) not in timer_watermark_data:\n+            timer_watermark_data[(transform_id,\n+                                  timer_family_id)] = timestamp.MAX_TIMESTAMP\n+          timer_watermark_data[(transform_id, timer_family_id)] = min(\n+              timer_watermark_data[(transform_id, timer_family_id)],\n+              decoded_timer.fire_timestamp)\n         fired_timers[(transform_id, timer_family_id)] = ListBuffer(\n             coder_impl=timer_coder_impl)\n         fired_timers[(transform_id, timer_family_id)].append(out.get())\n         written_timers.clear()\n \n+    return timer_watermark_data\n+\n   def _add_sdk_delayed_applications_to_deferred_inputs(\n       self, bundle_context_manager, bundle_result, deferred_inputs):\n+    # type: (...) -> Set[str]\n+\n+    \"\"\"Returns a set of PCollections with delayed applications.\"\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1Njk3Mg==", "bodyText": "PCollection IDs. Added to Pydoc.", "url": "https://github.com/apache/beam/pull/11296#discussion_r441156972", "createdAt": "2020-06-16T21:37:57Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -384,13 +409,25 @@ def _collect_written_timers_and_add_to_fired_timers(\n         out = create_OutputStream()\n         for decoded_timer in timers_by_key_and_window.values():\n           timer_coder_impl.encode_to_stream(decoded_timer, out, True)\n+          if (transform_id, timer_family_id) not in timer_watermark_data:\n+            timer_watermark_data[(transform_id,\n+                                  timer_family_id)] = timestamp.MAX_TIMESTAMP\n+          timer_watermark_data[(transform_id, timer_family_id)] = min(\n+              timer_watermark_data[(transform_id, timer_family_id)],\n+              decoded_timer.fire_timestamp)\n         fired_timers[(transform_id, timer_family_id)] = ListBuffer(\n             coder_impl=timer_coder_impl)\n         fired_timers[(transform_id, timer_family_id)].append(out.get())\n         written_timers.clear()\n \n+    return timer_watermark_data\n+\n   def _add_sdk_delayed_applications_to_deferred_inputs(\n       self, bundle_context_manager, bundle_result, deferred_inputs):\n+    # type: (...) -> Set[str]\n+\n+    \"\"\"Returns a set of PCollections with delayed applications.\"\"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5NzAyOQ=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjk4MDI5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1MzoyN1rOGQ7I2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1MzoyN1rOGQ7I2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5OTMyMQ==", "bodyText": "Leftover debugging?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420399321", "createdAt": "2020-05-05T20:53:27Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjk4NTgwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1NDo1OVrOGQ7MUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1NDo1OVrOGQ7MUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMDIwOQ==", "bodyText": "list(self.producers) (Also, won't this give double brackets?) Also, '<' is unmatched and not typically for string representations.", "url": "https://github.com/apache/beam/pull/11296#discussion_r420400209", "createdAt": "2020-05-05T20:54:59Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjk4OTk3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1NjowM1rOGQ7Oxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1NjowM1rOGQ7Oxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMDgzOQ==", "bodyText": "What about self._watermark = 0?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420400839", "createdAt": "2020-05-05T20:56:03Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjk5OTYzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1ODo0OVrOGQ7U2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1ODo0OVrOGQ7U2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMjM5NA==", "bodyText": "Does initializing this hear mean that we never use the watermark of the producers. (I have to admit, I'm not quite understanding why the watermark of a PCollection would ever be different than that of its producers.)", "url": "https://github.com/apache/beam/pull/11296#discussion_r420402394", "createdAt": "2020-05-05T20:58:49Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzAwMjAzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1OToyOVrOGQ7WSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMDo0MjowM1rOIuDWyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMjc2MQ==", "bodyText": "side inputs and timers all have this effect, right?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420402761", "createdAt": "2020-05-05T20:59:29Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUyNzUyMg==", "bodyText": "I believe only side inputs have this effect, no? I am considering timers one of the main inputs for a PTransform, and thus they would hold the watermark.", "url": "https://github.com/apache/beam/pull/11296#discussion_r570527522", "createdAt": "2021-02-04T20:37:21Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMjc2MQ=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MDM5NQ==", "bodyText": "OK.", "url": "https://github.com/apache/beam/pull/11296#discussion_r585160395", "createdAt": "2021-03-02T00:42:03Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMjc2MQ=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzAwNjY1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTowMDozOVrOGQ7ZFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTowMDozOVrOGQ7ZFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMzQ3Ng==", "bodyText": "Nit: return min(...)", "url": "https://github.com/apache/beam/pull/11296#discussion_r420403476", "createdAt": "2020-05-05T21:00:39Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzAxMDE5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTowMTo1M1rOGQ7bTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMDo0Mjo0MVrOIgGabw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNDA0NA==", "bodyText": "I suppose timers are considered an input?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420404044", "createdAt": "2020-05-05T21:01:53Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUzMDQxNQ==", "bodyText": "yes, timers are considered an input. I'll resolve this for now, as this relates to output watermarks, which we now calculate differently.", "url": "https://github.com/apache/beam/pull/11296#discussion_r570530415", "createdAt": "2021-02-04T20:42:41Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNDA0NA=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzAxOTcyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTowNDo0MlrOGQ7hEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMDozMzo1NlrOIgGIFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNTUyMQ==", "bodyText": "This doesn't seem right, the input watermarks should always be an upper bound on the output watermark.", "url": "https://github.com/apache/beam/pull/11296#discussion_r420405521", "createdAt": "2020-05-05T21:04:42Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)\n+      return w\n+\n+    def input_watermark(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUyNTcxOQ==", "bodyText": "That makes sense. I've changed the output_watermark to be calculated based on downstream PCollections.", "url": "https://github.com/apache/beam/pull/11296#discussion_r570525719", "createdAt": "2021-02-04T20:33:56Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)\n+      return w\n+\n+    def input_watermark(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNTUyMQ=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzAzMjQ4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTowODo0MlrOGQ7o9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMDo1MToyNVrOIuDlGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNzU0Mg==", "bodyText": "Should we change IMPULSE_BUFFER to conform to the spec of all other buffer ids rather than branching on it? (Or at least push this branch into split_buffer_id)?", "url": "https://github.com/apache/beam/pull/11296#discussion_r420407542", "createdAt": "2020-05-05T21:08:42Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)\n+      return w\n+\n+    def input_watermark(self):\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      # 1. Get stage inputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDQ2NTc5Ng==", "bodyText": "I'd like to make this change on the next step, when we switch from per-stage execution to work-queue-based per-bundle execution. Is that reasonable?", "url": "https://github.com/apache/beam/pull/11296#discussion_r570465796", "createdAt": "2021-02-04T18:52:35Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)\n+      return w\n+\n+    def input_watermark(self):\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      # 1. Get stage inputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNzU0Mg=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2NDA1Nw==", "bodyText": "OK, well let's at least unify this logic, i.e.\nif buffer_id == translations.IMPULSE_BUFFER\n  pcoll_name = transform.unique_name\nelse:\n  _, pcoll_name = split_buffer_id(buffer_id)\nadd_pcollection(pcoll_name, stage_node)\n\nrather than adding a continue. (We could also inline add_pcollection, for consistency, as it's not used elsewhere.)", "url": "https://github.com/apache/beam/pull/11296#discussion_r585164057", "createdAt": "2021-03-02T00:51:25Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)\n+      return w\n+\n+    def input_watermark(self):\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      # 1. Get stage inputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNzU0Mg=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzA0NDgzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToxMjoyN1rOGQ7wZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMDozNDoyNVrOIgGJKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwOTQ0Ng==", "bodyText": "This doesn't seem to take into account data that's \"in flight.\" E.g. all the input watermarks could be at max-timestamp, but that doesn't mean that all the inputs' data has been consumed.", "url": "https://github.com/apache/beam/pull/11296#discussion_r420409446", "createdAt": "2020-05-05T21:12:27Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUyNTk5Mw==", "bodyText": "I've changed this implementation to rely on the watermark from downstream PCollections.", "url": "https://github.com/apache/beam/pull/11296#discussion_r570525993", "createdAt": "2021-02-04T20:34:25Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwOTQ0Ng=="}, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzA0ODgyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToxMzo0M1rOGQ7yzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToxMzo0M1rOGQ7yzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxMDA2MA==", "bodyText": "Nit: (here and below): elide unneeded intermediate assignments and just chain.", "url": "https://github.com/apache/beam/pull/11296#discussion_r420410060", "createdAt": "2020-05-05T21:13:43Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,206 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=[%s]' % ([i for i in self.producers])\n+\n+    def set_watermark(self, wm):\n+      # print('setting watermark for %s to %s' % (self, wm))\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.output_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      if self._watermark:\n+        return self._watermark\n+      else:\n+        return self.upstream_watermark()\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs = set()\n+      self.side_inputs = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=[%s],side_inputs=[%s]' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      w = min(i.watermark() for i in self.inputs)\n+      return w\n+\n+    def input_watermark(self):\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      # 1. Get stage inputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:\n+            pcoll_name = transform.unique_name\n+          else:\n+            _, pcoll_name = split_buffer_id(buffer_id)\n+          if pcoll_name not in self._watermarks_by_name:\n+            self._watermarks_by_name[\n+                pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+          stage_node.inputs.add(self._watermarks_by_name[pcoll_name])\n+\n+      # 2. Get stage timers, and add them as inputs to the stage.\n+      for transform in s.transforms:\n+        if transform.spec.urn in translations.PAR_DO_URNS:\n+          payload = proto_utils.parse_Bytes(\n+              transform.spec.payload, beam_runner_api_pb2.ParDoPayload)\n+          for timer_family_id in payload.timer_family_specs.keys():\n+            timer_pcoll_name = (transform.unique_name, timer_family_id)\n+            self._watermarks_by_name[\n+                timer_pcoll_name] = WatermarkManager.PCollectionNode(\n+                    timer_pcoll_name)\n+            stage_node.inputs.add(self._watermarks_by_name[timer_pcoll_name])\n+\n+      # 3. Get stage outputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add stage as their producer\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_OUTPUT_URN:\n+          buffer_id = transform.spec.payload\n+          _, pcoll_name = split_buffer_id(buffer_id)\n+          if pcoll_name not in self._watermarks_by_name:\n+            self._watermarks_by_name[\n+                pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+          self._watermarks_by_name[pcoll_name].producers.add(stage_node)\n+\n+      # 4. Get stage side inputs, create nodes for them, add to\n+      #    _watermarks_by_name, and add them as side inputs of the stage.\n+      for pcoll_name in s.side_inputs():\n+        if pcoll_name not in self._watermarks_by_name:\n+          self._watermarks_by_name[\n+              pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+        stage_node.side_inputs.add(self._watermarks_by_name[pcoll_name])\n+\n+  def get_node(self, name):\n+    # type: (str) -> WatermarkNode\n+    return self._watermarks_by_name[name]\n+\n+  def get_watermark(self, name):\n+    element = self._watermarks_by_name[name]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a0a4c22e83b1f95680f53a1148439d2ed02286e"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY5MjIwNjUzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMDozMDo0NVrOIuDGXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQyMDo1NjowNlrOIuwrOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1NjE4OQ==", "bodyText": "Should this be a return value as well?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585156189", "createdAt": "2021-03-02T00:30:45Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -391,16 +419,22 @@ def _run_bundle_multiple_times_for_testing(\n       finally:\n         runner_execution_context.state_servicer.restore()\n \n-  def _collect_written_timers_and_add_to_fired_timers(\n-      self,\n-      bundle_context_manager,  # type: execution.BundleContextManager\n-      fired_timers  # type: Dict[Tuple[str, str], ListBuffer]\n-  ):\n-    # type: (...) -> None\n-\n+  @staticmethod\n+  def _collect_written_timers(\n+      bundle_context_manager: execution.BundleContextManager,\n+      newly_set_timers: Dict[Tuple[str, str], ListBuffer],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMjkwNg==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/11296#discussion_r585902906", "createdAt": "2021-03-02T20:56:06Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -391,16 +419,22 @@ def _run_bundle_multiple_times_for_testing(\n       finally:\n         runner_execution_context.state_servicer.restore()\n \n-  def _collect_written_timers_and_add_to_fired_timers(\n-      self,\n-      bundle_context_manager,  # type: execution.BundleContextManager\n-      fired_timers  # type: Dict[Tuple[str, str], ListBuffer]\n-  ):\n-    # type: (...) -> None\n-\n+  @staticmethod\n+  def _collect_written_timers(\n+      bundle_context_manager: execution.BundleContextManager,\n+      newly_set_timers: Dict[Tuple[str, str], ListBuffer],", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1NjE4OQ=="}, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY5MjIwNjkxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMDozMDo1M1rOIuDGkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQyMDo1NjowNVrOIuwrLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1NjI0MA==", "bodyText": "What does it return?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585156240", "createdAt": "2021-03-02T00:30:53Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -391,16 +419,22 @@ def _run_bundle_multiple_times_for_testing(\n       finally:\n         runner_execution_context.state_servicer.restore()\n \n-  def _collect_written_timers_and_add_to_fired_timers(\n-      self,\n-      bundle_context_manager,  # type: execution.BundleContextManager\n-      fired_timers  # type: Dict[Tuple[str, str], ListBuffer]\n-  ):\n-    # type: (...) -> None\n-\n+  @staticmethod\n+  def _collect_written_timers(\n+      bundle_context_manager: execution.BundleContextManager,\n+      newly_set_timers: Dict[Tuple[str, str], ListBuffer],\n+  ) -> Dict[Tuple[str, str], timestamp.Timestamp]:\n+    \"\"\"Review output buffers, and collect written timers.\n+\n+    This function reviews a stage that has just been run. The stage will have\n+    written timers to its output buffers. The function then takes the timers,\n+    and adds them to the `newly_set_timers` dictionary.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMjg5Mw==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/11296#discussion_r585902893", "createdAt": "2021-03-02T20:56:05Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -391,16 +419,22 @@ def _run_bundle_multiple_times_for_testing(\n       finally:\n         runner_execution_context.state_servicer.restore()\n \n-  def _collect_written_timers_and_add_to_fired_timers(\n-      self,\n-      bundle_context_manager,  # type: execution.BundleContextManager\n-      fired_timers  # type: Dict[Tuple[str, str], ListBuffer]\n-  ):\n-    # type: (...) -> None\n-\n+  @staticmethod\n+  def _collect_written_timers(\n+      bundle_context_manager: execution.BundleContextManager,\n+      newly_set_timers: Dict[Tuple[str, str], ListBuffer],\n+  ) -> Dict[Tuple[str, str], timestamp.Timestamp]:\n+    \"\"\"Review output buffers, and collect written timers.\n+\n+    This function reviews a stage that has just been run. The stage will have\n+    written timers to its output buffers. The function then takes the timers,\n+    and adds them to the `newly_set_timers` dictionary.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1NjI0MA=="}, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY5MjIxMjI0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMDozMzoyMVrOIuDJ0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQyMDo1NjowM1rOIuwrHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1NzA3NA==", "bodyText": "More flexibly, you could do only_element(transform.values())", "url": "https://github.com/apache/beam/pull/11296#discussion_r585157074", "createdAt": "2021-03-02T00:33:21Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -414,26 +448,50 @@ def _collect_written_timers_and_add_to_fired_timers(\n           # Only add not cleared timer to fired timers.\n           if not decoded_timer.clear_bit:\n             timer_coder_impl.encode_to_stream(decoded_timer, out, True)\n-        fired_timers[(transform_id, timer_family_id)] = ListBuffer(\n+            if (transform_id, timer_family_id) not in timer_watermark_data:\n+              timer_watermark_data[(transform_id,\n+                                    timer_family_id)] = timestamp.MAX_TIMESTAMP\n+            timer_watermark_data[(transform_id, timer_family_id)] = min(\n+                timer_watermark_data[(transform_id, timer_family_id)],\n+                decoded_timer.fire_timestamp)\n+        newly_set_timers[(transform_id, timer_family_id)] = ListBuffer(\n             coder_impl=timer_coder_impl)\n-        fired_timers[(transform_id, timer_family_id)].append(out.get())\n+        newly_set_timers[(transform_id, timer_family_id)].append(out.get())\n         written_timers.clear()\n \n+    return timer_watermark_data\n+\n   def _add_sdk_delayed_applications_to_deferred_inputs(\n       self,\n       bundle_context_manager,  # type: execution.BundleContextManager\n       bundle_result,  # type: beam_fn_api_pb2.InstructionResponse\n       deferred_inputs  # type: MutableMapping[str, execution.PartitionableBuffer]\n   ):\n-    # type: (...) -> None\n+    # type: (...) -> Set[str]\n+\n+    \"\"\"Returns a set of PCollection IDs of PColls having delayed applications.\n+\n+    This transform inspects the bundle_context_manager, and bundle_result\n+    objects, and adds all deferred inputs to the deferred_inputs object.\n+    \"\"\"\n+    pcolls_with_delayed_apps = set()\n     for delayed_application in bundle_result.process_bundle.residual_roots:\n-      name = bundle_context_manager.input_for(\n+      producer_name = bundle_context_manager.input_for(\n           delayed_application.application.transform_id,\n           delayed_application.application.input_id)\n-      if name not in deferred_inputs:\n-        deferred_inputs[name] = ListBuffer(\n-            coder_impl=bundle_context_manager.get_input_coder_impl(name))\n-      deferred_inputs[name].append(delayed_application.application.element)\n+      if producer_name not in deferred_inputs:\n+        deferred_inputs[producer_name] = ListBuffer(\n+            coder_impl=bundle_context_manager.get_input_coder_impl(\n+                producer_name))\n+      deferred_inputs[producer_name].append(\n+          delayed_application.application.element)\n+\n+      transform = bundle_context_manager.process_bundle_descriptor.transforms[\n+          producer_name]\n+      # We take the output with tag 'out' from the producer transform. The\n+      # producer transform is a GRPC read, and it has a single output.\n+      pcolls_with_delayed_apps.add(transform.outputs['out'])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMjg3Nw==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/11296#discussion_r585902877", "createdAt": "2021-03-02T20:56:03Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -414,26 +448,50 @@ def _collect_written_timers_and_add_to_fired_timers(\n           # Only add not cleared timer to fired timers.\n           if not decoded_timer.clear_bit:\n             timer_coder_impl.encode_to_stream(decoded_timer, out, True)\n-        fired_timers[(transform_id, timer_family_id)] = ListBuffer(\n+            if (transform_id, timer_family_id) not in timer_watermark_data:\n+              timer_watermark_data[(transform_id,\n+                                    timer_family_id)] = timestamp.MAX_TIMESTAMP\n+            timer_watermark_data[(transform_id, timer_family_id)] = min(\n+                timer_watermark_data[(transform_id, timer_family_id)],\n+                decoded_timer.fire_timestamp)\n+        newly_set_timers[(transform_id, timer_family_id)] = ListBuffer(\n             coder_impl=timer_coder_impl)\n-        fired_timers[(transform_id, timer_family_id)].append(out.get())\n+        newly_set_timers[(transform_id, timer_family_id)].append(out.get())\n         written_timers.clear()\n \n+    return timer_watermark_data\n+\n   def _add_sdk_delayed_applications_to_deferred_inputs(\n       self,\n       bundle_context_manager,  # type: execution.BundleContextManager\n       bundle_result,  # type: beam_fn_api_pb2.InstructionResponse\n       deferred_inputs  # type: MutableMapping[str, execution.PartitionableBuffer]\n   ):\n-    # type: (...) -> None\n+    # type: (...) -> Set[str]\n+\n+    \"\"\"Returns a set of PCollection IDs of PColls having delayed applications.\n+\n+    This transform inspects the bundle_context_manager, and bundle_result\n+    objects, and adds all deferred inputs to the deferred_inputs object.\n+    \"\"\"\n+    pcolls_with_delayed_apps = set()\n     for delayed_application in bundle_result.process_bundle.residual_roots:\n-      name = bundle_context_manager.input_for(\n+      producer_name = bundle_context_manager.input_for(\n           delayed_application.application.transform_id,\n           delayed_application.application.input_id)\n-      if name not in deferred_inputs:\n-        deferred_inputs[name] = ListBuffer(\n-            coder_impl=bundle_context_manager.get_input_coder_impl(name))\n-      deferred_inputs[name].append(delayed_application.application.element)\n+      if producer_name not in deferred_inputs:\n+        deferred_inputs[producer_name] = ListBuffer(\n+            coder_impl=bundle_context_manager.get_input_coder_impl(\n+                producer_name))\n+      deferred_inputs[producer_name].append(\n+          delayed_application.application.element)\n+\n+      transform = bundle_context_manager.process_bundle_descriptor.transforms[\n+          producer_name]\n+      # We take the output with tag 'out' from the producer transform. The\n+      # producer transform is a GRPC read, and it has a single output.\n+      pcolls_with_delayed_apps.add(transform.outputs['out'])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1NzA3NA=="}, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY5MjIyNjYyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/visualization_tools.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMDozODo0NFrOIuDSHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQyMDo1NjowMVrOIuwrBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1OTE5OA==", "bodyText": "Any reason not to make this a dependency? (E.g. is it fairly large?)", "url": "https://github.com/apache/beam/pull/11296#discussion_r585159198", "createdAt": "2021-03-02T00:38:44Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/visualization_tools.py", "diffHunk": "@@ -0,0 +1,115 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Set of utilities to visualize a pipeline to be executed by FnApiRunner.\"\"\"\n+from typing import Set\n+from typing import Tuple\n+\n+from apache_beam.runners.portability.fn_api_runner.translations import Stage\n+from apache_beam.runners.portability.fn_api_runner.watermark_manager import WatermarkManager\n+\n+\n+def show_stage(stage: Stage):\n+  try:\n+    import graphviz\n+  except ImportError:\n+    import warnings\n+    warnings.warn('Unable to draw pipeline. graphviz library missing.')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMjg1Mg==", "bodyText": "That's right - since the utilities are only used for internal debugging of the runner, I hesitate to add it as a dependency - it is also large as you point out. I don't think it fits under the test tag dependencies - we may need an extra tag for internal dependencies or something like that. I'm happy to add a new tag, or leave it out. Thoughts?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585902852", "createdAt": "2021-03-02T20:56:01Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/visualization_tools.py", "diffHunk": "@@ -0,0 +1,115 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Set of utilities to visualize a pipeline to be executed by FnApiRunner.\"\"\"\n+from typing import Set\n+from typing import Tuple\n+\n+from apache_beam.runners.portability.fn_api_runner.translations import Stage\n+from apache_beam.runners.portability.fn_api_runner.watermark_manager import WatermarkManager\n+\n+\n+def show_stage(stage: Stage):\n+  try:\n+    import graphviz\n+  except ImportError:\n+    import warnings\n+    warnings.warn('Unable to draw pipeline. graphviz library missing.')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE1OTE5OA=="}, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY5MjIzOTM2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMDo0NDoxNlrOIuDZ1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQyMDo1MjozNFrOIuwitw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MTE3NA==", "bodyText": "I'm trying to understand when node.watermark() vs. node.upstream_watermark() would be used. It seems we'd always want the output watermark of our predecessors as our input watermark.", "url": "https://github.com/apache/beam/pull/11296#discussion_r585161174", "createdAt": "2021-03-02T00:44:16Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,199 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Any\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no output watermark %s' % self)\n+\n+    def input_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no input watermark %s' % self)\n+\n+    def watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no own watermark %s' % self)\n+\n+    def upstream_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no upstream watermark %s' % self)\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMDcyNw==", "bodyText": "Once we switch to streaming, for timer PCollections, we'll mainly use their watermark directly, and we'll set the watermark directly; while for data PCollections we'll mainly use the upstream watermark.\nIn this change we're not seeing these changes, but watermark information will be extracted from splits and delayed applications, and PCollection watermarks will not advance to MAX_TIMESTAMP, they will depend on their producers.\n\nTimers will trigger whenever all inputs to a stage reach their time.\nData PCollection watermarks will advance from the top", "url": "https://github.com/apache/beam/pull/11296#discussion_r585900727", "createdAt": "2021-03-02T20:52:34Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,199 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Any\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no output watermark %s' % self)\n+\n+    def input_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no input watermark %s' % self)\n+\n+    def watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no own watermark %s' % self)\n+\n+    def upstream_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no upstream watermark %s' % self)\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MTE3NA=="}, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY5MjI0OTMwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMDo0Nzo0NFrOIuDfQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQyMDo1NTo1N1rOIuwq6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MjU2Mg==", "bodyText": "Didn't we just assert that above?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585162562", "createdAt": "2021-03-02T00:47:44Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,199 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Any\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no output watermark %s' % self)\n+\n+    def input_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no input watermark %s' % self)\n+\n+    def watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no own watermark %s' % self)\n+\n+    def upstream_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no upstream watermark %s' % self)\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name: Dict[Any,\n+                                   Union[\n+                                       WatermarkManager.StageNode,\n+                                       WatermarkManager.PCollectionNode]] = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._watermarks_by_name:\n+          self._watermarks_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._watermarks_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        node = self._watermarks_by_name[pcname]\n+        assert isinstance(node, WatermarkManager.PCollectionNode)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMjgyNQ==", "bodyText": "true. removed.", "url": "https://github.com/apache/beam/pull/11296#discussion_r585902825", "createdAt": "2021-03-02T20:55:57Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,199 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Any\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no output watermark %s' % self)\n+\n+    def input_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no input watermark %s' % self)\n+\n+    def watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no own watermark %s' % self)\n+\n+    def upstream_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no upstream watermark %s' % self)\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name: Dict[Any,\n+                                   Union[\n+                                       WatermarkManager.StageNode,\n+                                       WatermarkManager.PCollectionNode]] = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._watermarks_by_name:\n+          self._watermarks_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._watermarks_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        node = self._watermarks_by_name[pcname]\n+        assert isinstance(node, WatermarkManager.PCollectionNode)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2MjU2Mg=="}, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY5MjI2NzgzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMDo1NTowNlrOIuDqLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQyMDo1NTo0OFrOIuwqkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2NTM1OA==", "bodyText": "get/set watermark is never used on stage nodes, right? Does it make sense to keep them in the same dictionary?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585165358", "createdAt": "2021-03-02T00:55:06Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,199 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Any\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no output watermark %s' % self)\n+\n+    def input_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no input watermark %s' % self)\n+\n+    def watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no own watermark %s' % self)\n+\n+    def upstream_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no upstream watermark %s' % self)\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name: Dict[Any,\n+                                   Union[\n+                                       WatermarkManager.StageNode,\n+                                       WatermarkManager.PCollectionNode]] = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._watermarks_by_name:\n+          self._watermarks_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._watermarks_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        node = self._watermarks_by_name[pcname]\n+        assert isinstance(node, WatermarkManager.PCollectionNode)\n+        return node\n+\n+      # 1. Get stage inputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:\n+            pcoll_name = transform.unique_name\n+            add_pcollection(pcoll_name, stage_node)\n+            continue\n+          else:\n+            _, pcoll_name = split_buffer_id(buffer_id)\n+          add_pcollection(pcoll_name, stage_node)\n+\n+      # 2. Get stage timers, and add them as inputs to the stage.\n+      for transform in s.transforms:\n+        if transform.spec.urn in translations.PAR_DO_URNS:\n+          payload = proto_utils.parse_Bytes(\n+              transform.spec.payload, beam_runner_api_pb2.ParDoPayload)\n+          for timer_family_id in payload.timer_family_specs.keys():\n+            timer_pcoll_name = (transform.unique_name, timer_family_id)\n+            self._watermarks_by_name[\n+                timer_pcoll_name] = WatermarkManager.PCollectionNode(\n+                    timer_pcoll_name)\n+            timer_pcoll_node = self._watermarks_by_name[timer_pcoll_name]\n+            assert isinstance(\n+                timer_pcoll_node, WatermarkManager.PCollectionNode)\n+            stage_node.inputs.add(timer_pcoll_node)\n+\n+      # 3. Get stage outputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add stage as their producer\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_OUTPUT_URN:\n+          buffer_id = transform.spec.payload\n+          _, pcoll_name = split_buffer_id(buffer_id)\n+          if pcoll_name not in self._watermarks_by_name:\n+            self._watermarks_by_name[\n+                pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+          pcoll_node = self._watermarks_by_name[pcoll_name]\n+          assert isinstance(pcoll_node, WatermarkManager.PCollectionNode)\n+          pcoll_node.producers.add(stage_node)\n+          stage_node.outputs.add(pcoll_node)\n+\n+      # 4. Get stage side inputs, create nodes for them, add to\n+      #    _watermarks_by_name, and add them as side inputs of the stage.\n+      for pcoll_name in s.side_inputs():\n+        if pcoll_name not in self._watermarks_by_name:\n+          self._watermarks_by_name[\n+              pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+        pcoll_node = self._watermarks_by_name[pcoll_name]\n+        assert isinstance(pcoll_node, WatermarkManager.PCollectionNode)\n+        stage_node.side_inputs.add(pcoll_node)\n+\n+  def get_node(self, name):\n+    # type: (str) -> Union[PCollectionNode, StageNode]\n+    return self._watermarks_by_name[name]\n+\n+  def get_watermark(self, name) -> timestamp.Timestamp:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMjczOA==", "bodyText": "yeah, you're right. I was also having that sense when I was jumping hoops to unify the typing. I've separated them. Thanks!", "url": "https://github.com/apache/beam/pull/11296#discussion_r585902738", "createdAt": "2021-03-02T20:55:48Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,199 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Any\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class WatermarkNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no output watermark %s' % self)\n+\n+    def input_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no input watermark %s' % self)\n+\n+    def watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no own watermark %s' % self)\n+\n+    def upstream_watermark(self) -> timestamp.Timestamp:\n+      raise NotImplementedError('Node has no upstream watermark %s' % self)\n+\n+  class PCollectionNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.PCollectionNode, self).__init__(name)\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(WatermarkNode):\n+    def __init__(self, name):\n+      super(WatermarkManager.StageNode, self).__init__(name)\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def set_watermark(self, wm):\n+      raise NotImplementedError('Stages do not have a watermark')\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._watermarks_by_name: Dict[Any,\n+                                   Union[\n+                                       WatermarkManager.StageNode,\n+                                       WatermarkManager.PCollectionNode]] = {}\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._watermarks_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._watermarks_by_name:\n+          self._watermarks_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._watermarks_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        node = self._watermarks_by_name[pcname]\n+        assert isinstance(node, WatermarkManager.PCollectionNode)\n+        return node\n+\n+      # 1. Get stage inputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:\n+            pcoll_name = transform.unique_name\n+            add_pcollection(pcoll_name, stage_node)\n+            continue\n+          else:\n+            _, pcoll_name = split_buffer_id(buffer_id)\n+          add_pcollection(pcoll_name, stage_node)\n+\n+      # 2. Get stage timers, and add them as inputs to the stage.\n+      for transform in s.transforms:\n+        if transform.spec.urn in translations.PAR_DO_URNS:\n+          payload = proto_utils.parse_Bytes(\n+              transform.spec.payload, beam_runner_api_pb2.ParDoPayload)\n+          for timer_family_id in payload.timer_family_specs.keys():\n+            timer_pcoll_name = (transform.unique_name, timer_family_id)\n+            self._watermarks_by_name[\n+                timer_pcoll_name] = WatermarkManager.PCollectionNode(\n+                    timer_pcoll_name)\n+            timer_pcoll_node = self._watermarks_by_name[timer_pcoll_name]\n+            assert isinstance(\n+                timer_pcoll_node, WatermarkManager.PCollectionNode)\n+            stage_node.inputs.add(timer_pcoll_node)\n+\n+      # 3. Get stage outputs, create nodes for them, add to _watermarks_by_name,\n+      #    and add stage as their producer\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_OUTPUT_URN:\n+          buffer_id = transform.spec.payload\n+          _, pcoll_name = split_buffer_id(buffer_id)\n+          if pcoll_name not in self._watermarks_by_name:\n+            self._watermarks_by_name[\n+                pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+          pcoll_node = self._watermarks_by_name[pcoll_name]\n+          assert isinstance(pcoll_node, WatermarkManager.PCollectionNode)\n+          pcoll_node.producers.add(stage_node)\n+          stage_node.outputs.add(pcoll_node)\n+\n+      # 4. Get stage side inputs, create nodes for them, add to\n+      #    _watermarks_by_name, and add them as side inputs of the stage.\n+      for pcoll_name in s.side_inputs():\n+        if pcoll_name not in self._watermarks_by_name:\n+          self._watermarks_by_name[\n+              pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+        pcoll_node = self._watermarks_by_name[pcoll_name]\n+        assert isinstance(pcoll_node, WatermarkManager.PCollectionNode)\n+        stage_node.side_inputs.add(pcoll_node)\n+\n+  def get_node(self, name):\n+    # type: (str) -> Union[PCollectionNode, StageNode]\n+    return self._watermarks_by_name[name]\n+\n+  def get_watermark(self, name) -> timestamp.Timestamp:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE2NTM1OA=="}, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY5MjMwMjA4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMTowNzozMFrOIuD-Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQyMDo1NTo1MVrOIuwqtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE3MDUwNw==", "bodyText": "I'll admit I have a hard time keeping the exact ordering here in my head. E.g. is expected_timers in this set? In which of the loops above could updates[pcoll_id] have been set?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585170507", "createdAt": "2021-03-02T01:07:30Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -570,18 +661,76 @@ def merge_results(last_result):\n \n     return final_result\n \n+  @staticmethod\n+  def _build_watermark_updates(\n+      runner_execution_context,  # type: execution.FnApiRunnerExecutionContext\n+      stage_inputs,  # type: Iterable[str]\n+      expected_timers,  # type: Iterable[translations.TimerFamilyId]\n+      pcolls_with_da,  # type: Set[str]\n+      transforms_w_splits,  # type: Set[str]\n+      watermarks_by_transform_and_timer_family  # type: Dict[translations.TimerFamilyId, timestamp.Timestamp]\n+  ) -> Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]:\n+    \"\"\"Builds a dictionary of PCollection (or TimerFamilyId) to timestamp.\n+\n+    Args:\n+      stage_inputs: represent the set of expected input PCollections for a stage\n+      expected_timers: represent the set of TimerFamilyIds that the stage can\n+        expect to receive as inputs.\n+      pcolls_with_da: represent the set of stage input PCollections that had\n+        delayed applications.\n+      transforms_w_splits: represent the set of transforms in the stage that had\n+        input splits.\n+      watermarks_by_transform_and_timer_family: represent the set of watermark\n+        holds to be added for each timer family.\n+    \"\"\"\n+    updates = {\n+    }  # type: Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]\n+\n+    def get_pcoll_id(transform_id):\n+      buffer_id = runner_execution_context.input_transform_to_buffer_id[\n+          transform_id]\n+      # For IMPULSE-reading transforms, we use the transform name as buffer id.\n+      if buffer_id == translations.IMPULSE_BUFFER:\n+        pcollection_id = transform_id\n+      else:\n+        _, pcollection_id = translations.split_buffer_id(buffer_id)\n+      return pcollection_id\n+\n+    for pcoll in pcolls_with_da:\n+      updates[pcoll] = timestamp.MIN_TIMESTAMP\n+\n+    for tr in transforms_w_splits:\n+      pcoll_id = get_pcoll_id(tr)\n+      updates[pcoll_id] = timestamp.MIN_TIMESTAMP\n+\n+    for timer_pcoll_id, ts in watermarks_by_transform_and_timer_family.items():\n+      if timer_pcoll_id not in updates:\n+        updates[timer_pcoll_id] = timestamp.MAX_TIMESTAMP\n+      updates[timer_pcoll_id] = min(ts, updates[timer_pcoll_id])\n+\n+    for timer_pcoll_id in expected_timers:\n+      if timer_pcoll_id not in updates:\n+        updates[timer_pcoll_id] = timestamp.MAX_TIMESTAMP\n+\n+    for input in stage_inputs:\n+      pcoll_id = get_pcoll_id(input)\n+      if pcoll_id not in updates:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMjc3Mg==", "bodyText": "I've added comments for these sections. LMK if that helps.", "url": "https://github.com/apache/beam/pull/11296#discussion_r585902772", "createdAt": "2021-03-02T20:55:51Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -570,18 +661,76 @@ def merge_results(last_result):\n \n     return final_result\n \n+  @staticmethod\n+  def _build_watermark_updates(\n+      runner_execution_context,  # type: execution.FnApiRunnerExecutionContext\n+      stage_inputs,  # type: Iterable[str]\n+      expected_timers,  # type: Iterable[translations.TimerFamilyId]\n+      pcolls_with_da,  # type: Set[str]\n+      transforms_w_splits,  # type: Set[str]\n+      watermarks_by_transform_and_timer_family  # type: Dict[translations.TimerFamilyId, timestamp.Timestamp]\n+  ) -> Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]:\n+    \"\"\"Builds a dictionary of PCollection (or TimerFamilyId) to timestamp.\n+\n+    Args:\n+      stage_inputs: represent the set of expected input PCollections for a stage\n+      expected_timers: represent the set of TimerFamilyIds that the stage can\n+        expect to receive as inputs.\n+      pcolls_with_da: represent the set of stage input PCollections that had\n+        delayed applications.\n+      transforms_w_splits: represent the set of transforms in the stage that had\n+        input splits.\n+      watermarks_by_transform_and_timer_family: represent the set of watermark\n+        holds to be added for each timer family.\n+    \"\"\"\n+    updates = {\n+    }  # type: Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]\n+\n+    def get_pcoll_id(transform_id):\n+      buffer_id = runner_execution_context.input_transform_to_buffer_id[\n+          transform_id]\n+      # For IMPULSE-reading transforms, we use the transform name as buffer id.\n+      if buffer_id == translations.IMPULSE_BUFFER:\n+        pcollection_id = transform_id\n+      else:\n+        _, pcollection_id = translations.split_buffer_id(buffer_id)\n+      return pcollection_id\n+\n+    for pcoll in pcolls_with_da:\n+      updates[pcoll] = timestamp.MIN_TIMESTAMP\n+\n+    for tr in transforms_w_splits:\n+      pcoll_id = get_pcoll_id(tr)\n+      updates[pcoll_id] = timestamp.MIN_TIMESTAMP\n+\n+    for timer_pcoll_id, ts in watermarks_by_transform_and_timer_family.items():\n+      if timer_pcoll_id not in updates:\n+        updates[timer_pcoll_id] = timestamp.MAX_TIMESTAMP\n+      updates[timer_pcoll_id] = min(ts, updates[timer_pcoll_id])\n+\n+    for timer_pcoll_id in expected_timers:\n+      if timer_pcoll_id not in updates:\n+        updates[timer_pcoll_id] = timestamp.MAX_TIMESTAMP\n+\n+    for input in stage_inputs:\n+      pcoll_id = get_pcoll_id(input)\n+      if pcoll_id not in updates:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE3MDUwNw=="}, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 321}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY5MjMxNjYyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwMToxMjo0N1rOIuEHUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQyMDo1NTo1NFrOIuwqzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE3MjgxOA==", "bodyText": "It might be simpler to do something like\nfor timer_pcoll_id in expected_timers:\n  updates[timer_pcoll_id] = watermarks_by_transform_and_timer_family.get(\n      timestamp.MAX_TIMESTAMP)\n\nthan these two loops here. Or could timer_pcoll_id be in pcolls_with_da and/or transforms_w_splits?", "url": "https://github.com/apache/beam/pull/11296#discussion_r585172818", "createdAt": "2021-03-02T01:12:47Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -570,18 +661,76 @@ def merge_results(last_result):\n \n     return final_result\n \n+  @staticmethod\n+  def _build_watermark_updates(\n+      runner_execution_context,  # type: execution.FnApiRunnerExecutionContext\n+      stage_inputs,  # type: Iterable[str]\n+      expected_timers,  # type: Iterable[translations.TimerFamilyId]\n+      pcolls_with_da,  # type: Set[str]\n+      transforms_w_splits,  # type: Set[str]\n+      watermarks_by_transform_and_timer_family  # type: Dict[translations.TimerFamilyId, timestamp.Timestamp]\n+  ) -> Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]:\n+    \"\"\"Builds a dictionary of PCollection (or TimerFamilyId) to timestamp.\n+\n+    Args:\n+      stage_inputs: represent the set of expected input PCollections for a stage\n+      expected_timers: represent the set of TimerFamilyIds that the stage can\n+        expect to receive as inputs.\n+      pcolls_with_da: represent the set of stage input PCollections that had\n+        delayed applications.\n+      transforms_w_splits: represent the set of transforms in the stage that had\n+        input splits.\n+      watermarks_by_transform_and_timer_family: represent the set of watermark\n+        holds to be added for each timer family.\n+    \"\"\"\n+    updates = {\n+    }  # type: Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]\n+\n+    def get_pcoll_id(transform_id):\n+      buffer_id = runner_execution_context.input_transform_to_buffer_id[\n+          transform_id]\n+      # For IMPULSE-reading transforms, we use the transform name as buffer id.\n+      if buffer_id == translations.IMPULSE_BUFFER:\n+        pcollection_id = transform_id\n+      else:\n+        _, pcollection_id = translations.split_buffer_id(buffer_id)\n+      return pcollection_id\n+\n+    for pcoll in pcolls_with_da:\n+      updates[pcoll] = timestamp.MIN_TIMESTAMP\n+\n+    for tr in transforms_w_splits:\n+      pcoll_id = get_pcoll_id(tr)\n+      updates[pcoll_id] = timestamp.MIN_TIMESTAMP\n+\n+    for timer_pcoll_id, ts in watermarks_by_transform_and_timer_family.items():", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMjc5Ng==", "bodyText": "Done. Much better : )", "url": "https://github.com/apache/beam/pull/11296#discussion_r585902796", "createdAt": "2021-03-02T20:55:54Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -570,18 +661,76 @@ def merge_results(last_result):\n \n     return final_result\n \n+  @staticmethod\n+  def _build_watermark_updates(\n+      runner_execution_context,  # type: execution.FnApiRunnerExecutionContext\n+      stage_inputs,  # type: Iterable[str]\n+      expected_timers,  # type: Iterable[translations.TimerFamilyId]\n+      pcolls_with_da,  # type: Set[str]\n+      transforms_w_splits,  # type: Set[str]\n+      watermarks_by_transform_and_timer_family  # type: Dict[translations.TimerFamilyId, timestamp.Timestamp]\n+  ) -> Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]:\n+    \"\"\"Builds a dictionary of PCollection (or TimerFamilyId) to timestamp.\n+\n+    Args:\n+      stage_inputs: represent the set of expected input PCollections for a stage\n+      expected_timers: represent the set of TimerFamilyIds that the stage can\n+        expect to receive as inputs.\n+      pcolls_with_da: represent the set of stage input PCollections that had\n+        delayed applications.\n+      transforms_w_splits: represent the set of transforms in the stage that had\n+        input splits.\n+      watermarks_by_transform_and_timer_family: represent the set of watermark\n+        holds to be added for each timer family.\n+    \"\"\"\n+    updates = {\n+    }  # type: Dict[Union[str, translations.TimerFamilyId], timestamp.Timestamp]\n+\n+    def get_pcoll_id(transform_id):\n+      buffer_id = runner_execution_context.input_transform_to_buffer_id[\n+          transform_id]\n+      # For IMPULSE-reading transforms, we use the transform name as buffer id.\n+      if buffer_id == translations.IMPULSE_BUFFER:\n+        pcollection_id = transform_id\n+      else:\n+        _, pcollection_id = translations.split_buffer_id(buffer_id)\n+      return pcollection_id\n+\n+    for pcoll in pcolls_with_da:\n+      updates[pcoll] = timestamp.MIN_TIMESTAMP\n+\n+    for tr in transforms_w_splits:\n+      pcoll_id = get_pcoll_id(tr)\n+      updates[pcoll_id] = timestamp.MIN_TIMESTAMP\n+\n+    for timer_pcoll_id, ts in watermarks_by_transform_and_timer_family.items():", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTE3MjgxOA=="}, "originalCommit": {"oid": "aadbef039e830df75473b5925a82897f85f9949b"}, "originalPosition": 310}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg4MjAxMDQyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNFQyMTo0MDo0NVrOJJLfYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wNlQwMDoyNDo1NVrOJV9DJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzYwNTIxOQ==", "bodyText": "clean up?", "url": "https://github.com/apache/beam/pull/11296#discussion_r613605219", "createdAt": "2021-04-14T21:40:45Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -588,6 +589,13 @@ def __init__(self,\n     self.safe_coders = safe_coders\n     self.data_channel_coders = data_channel_coders\n \n+    self.input_transform_to_buffer_id = {\n+        t.unique_name: t.spec.payload\n+        for s in stages for t in s.transforms\n+        if t.spec.urn == bundle_processor.DATA_INPUT_URN\n+    }\n+    self.watermark_manager = WatermarkManager(stages)\n+    # self.watermark_manager.show()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNzAwMDEwMA==", "bodyText": "done.", "url": "https://github.com/apache/beam/pull/11296#discussion_r627000100", "createdAt": "2021-05-06T00:24:55Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -588,6 +589,13 @@ def __init__(self,\n     self.safe_coders = safe_coders\n     self.data_channel_coders = data_channel_coders\n \n+    self.input_transform_to_buffer_id = {\n+        t.unique_name: t.spec.payload\n+        for s in stages for t in s.transforms\n+        if t.spec.urn == bundle_processor.DATA_INPUT_URN\n+    }\n+    self.watermark_manager = WatermarkManager(stages)\n+    # self.watermark_manager.show()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzYwNTIxOQ=="}, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg4MjA2MzgyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNFQyMTo1ODowNVrOJJL_ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0wOFQyMTozMzozOFrOJpzHNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzYxMzQxMw==", "bodyText": "output_watermark()?", "url": "https://github.com/apache/beam/pull/11296#discussion_r613613413", "createdAt": "2021-04-14T21:58:05Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -364,10 +368,36 @@ def run_stages(self,\n           bundle_context_manager = execution.BundleContextManager(\n               runner_execution_context, stage, self._num_workers)\n \n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (\n+              'wrong watermark for %s. Expected %s, but got %s.' % (\n+                  runner_execution_context.watermark_manager.get_stage_node(\n+                      bundle_context_manager.stage.name),\n+                  timestamp.MAX_TIMESTAMP,\n+                  runner_execution_context.watermark_manager.get_stage_node(\n+                      bundle_context_manager.stage.name\n+                  ).input_watermark()\n+              )\n+          )\n+\n           stage_results = self._run_stage(\n-              runner_execution_context,\n-              bundle_context_manager,\n+              runner_execution_context, bundle_context_manager)\n+\n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNzAwMDExMA==", "bodyText": "initially I'm checking the input_watermark. I'll add a more advanced check in a follow-up change that updates the runner to support per-bundle execution (instead of per-stage)", "url": "https://github.com/apache/beam/pull/11296#discussion_r627000110", "createdAt": "2021-05-06T00:24:58Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -364,10 +368,36 @@ def run_stages(self,\n           bundle_context_manager = execution.BundleContextManager(\n               runner_execution_context, stage, self._num_workers)\n \n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (\n+              'wrong watermark for %s. Expected %s, but got %s.' % (\n+                  runner_execution_context.watermark_manager.get_stage_node(\n+                      bundle_context_manager.stage.name),\n+                  timestamp.MAX_TIMESTAMP,\n+                  runner_execution_context.watermark_manager.get_stage_node(\n+                      bundle_context_manager.stage.name\n+                  ).input_watermark()\n+              )\n+          )\n+\n           stage_results = self._run_stage(\n-              runner_execution_context,\n-              bundle_context_manager,\n+              runner_execution_context, bundle_context_manager)\n+\n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzYxMzQxMw=="}, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ1MDM0Nw==", "bodyText": "OK, there is a mismatch between the assertion and the error message so that's why I'm confused.", "url": "https://github.com/apache/beam/pull/11296#discussion_r635450347", "createdAt": "2021-05-19T17:33:59Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -364,10 +368,36 @@ def run_stages(self,\n           bundle_context_manager = execution.BundleContextManager(\n               runner_execution_context, stage, self._num_workers)\n \n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (\n+              'wrong watermark for %s. Expected %s, but got %s.' % (\n+                  runner_execution_context.watermark_manager.get_stage_node(\n+                      bundle_context_manager.stage.name),\n+                  timestamp.MAX_TIMESTAMP,\n+                  runner_execution_context.watermark_manager.get_stage_node(\n+                      bundle_context_manager.stage.name\n+                  ).input_watermark()\n+              )\n+          )\n+\n           stage_results = self._run_stage(\n-              runner_execution_context,\n-              bundle_context_manager,\n+              runner_execution_context, bundle_context_manager)\n+\n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzYxMzQxMw=="}, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0NzgwODgyMg==", "bodyText": "ah thanks for the catch. fixed that.", "url": "https://github.com/apache/beam/pull/11296#discussion_r647808822", "createdAt": "2021-06-08T21:33:38Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -364,10 +368,36 @@ def run_stages(self,\n           bundle_context_manager = execution.BundleContextManager(\n               runner_execution_context, stage, self._num_workers)\n \n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (\n+              'wrong watermark for %s. Expected %s, but got %s.' % (\n+                  runner_execution_context.watermark_manager.get_stage_node(\n+                      bundle_context_manager.stage.name),\n+                  timestamp.MAX_TIMESTAMP,\n+                  runner_execution_context.watermark_manager.get_stage_node(\n+                      bundle_context_manager.stage.name\n+                  ).input_watermark()\n+              )\n+          )\n+\n           stage_results = self._run_stage(\n-              runner_execution_context,\n-              bundle_context_manager,\n+              runner_execution_context, bundle_context_manager)\n+\n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzYxMzQxMw=="}, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg4MjA2ODAxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xNFQyMTo1OToyOVrOJJMCBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wNlQwMDoyNTowMFrOJV9DQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzYxNDA4NQ==", "bodyText": "are the assertions only for batch?", "url": "https://github.com/apache/beam/pull/11296#discussion_r613614085", "createdAt": "2021-04-14T21:59:29Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -364,10 +368,36 @@ def run_stages(self,\n           bundle_context_manager = execution.BundleContextManager(\n               runner_execution_context, stage, self._num_workers)\n \n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNzAwMDEzMA==", "bodyText": "currently only batch is supported. this will be fixed later on.", "url": "https://github.com/apache/beam/pull/11296#discussion_r627000130", "createdAt": "2021-05-06T00:25:00Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -364,10 +368,36 @@ def run_stages(self,\n           bundle_context_manager = execution.BundleContextManager(\n               runner_execution_context, stage, self._num_workers)\n \n+          assert (\n+              runner_execution_context.watermark_manager.get_stage_node(\n+                  bundle_context_manager.stage.name\n+              ).input_watermark() == timestamp.MAX_TIMESTAMP), (", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzYxNDA4NQ=="}, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg5ODc2MzU4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xOVQxODo1NDo0MVrOJLjgcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wNlQwMDoyNTowM1rOJV9DUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjA5NTg1Nw==", "bodyText": "I think this should be decoded_timer.hold_timestamp, currently timers will set hold_timestamp to fire_timestamp but I think for watermark we should still use decoded_timer.hold_timestamp which prevents potential breakage from BEAM-11507.", "url": "https://github.com/apache/beam/pull/11296#discussion_r616095857", "createdAt": "2021-04-19T18:54:41Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -424,26 +466,50 @@ def _collect_written_timers_and_add_to_fired_timers(\n           # Only add not cleared timer to fired timers.\n           if not decoded_timer.clear_bit:\n             timer_coder_impl.encode_to_stream(decoded_timer, out, True)\n-        fired_timers[(transform_id, timer_family_id)] = ListBuffer(\n+            if (transform_id, timer_family_id) not in timer_watermark_data:\n+              timer_watermark_data[(transform_id,\n+                                    timer_family_id)] = timestamp.MAX_TIMESTAMP\n+            timer_watermark_data[(transform_id, timer_family_id)] = min(\n+                timer_watermark_data[(transform_id, timer_family_id)],\n+                decoded_timer.fire_timestamp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNzAwMDE0Ng==", "bodyText": "thanks for the tip! done.", "url": "https://github.com/apache/beam/pull/11296#discussion_r627000146", "createdAt": "2021-05-06T00:25:03Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -424,26 +466,50 @@ def _collect_written_timers_and_add_to_fired_timers(\n           # Only add not cleared timer to fired timers.\n           if not decoded_timer.clear_bit:\n             timer_coder_impl.encode_to_stream(decoded_timer, out, True)\n-        fired_timers[(transform_id, timer_family_id)] = ListBuffer(\n+            if (transform_id, timer_family_id) not in timer_watermark_data:\n+              timer_watermark_data[(transform_id,\n+                                    timer_family_id)] = timestamp.MAX_TIMESTAMP\n+            timer_watermark_data[(transform_id, timer_family_id)] = min(\n+                timer_watermark_data[(transform_id, timer_family_id)],\n+                decoded_timer.fire_timestamp)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjA5NTg1Nw=="}, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg5ODkyNjM0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xOVQxOToyOTowN1rOJLlEnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wNlQwMDoyNTowNlrOJV9DaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjEyMTUwMA==", "bodyText": "Should this function declared outside of the loop?", "url": "https://github.com/apache/beam/pull/11296#discussion_r616121500", "createdAt": "2021-04-19T19:29:07Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,171 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class PCollectionNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(object):\n+    def __init__(self, name):\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.name = name\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._pcollections_by_name: Dict[Union[str, translations.TimerFamilyId],\n+                                     WatermarkManager.PCollectionNode] = {}\n+    self._stages_by_name: Dict[str, WatermarkManager.StageNode] = {}\n+\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._stages_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNzAwMDE2OA==", "bodyText": "done", "url": "https://github.com/apache/beam/pull/11296#discussion_r627000168", "createdAt": "2021-05-06T00:25:06Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,171 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class PCollectionNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(object):\n+    def __init__(self, name):\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.name = name\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._pcollections_by_name: Dict[Union[str, translations.TimerFamilyId],\n+                                     WatermarkManager.PCollectionNode] = {}\n+    self._stages_by_name: Dict[str, WatermarkManager.StageNode] = {}\n+\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._stages_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjEyMTUwMA=="}, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg5ODk0MzE5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xOVQxOTozMzo1OFrOJLlPGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wNlQwMDoyNToyMVrOJV9DuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjEyNDE4NA==", "bodyText": "why do we need these assertions immediately after updating the map?", "url": "https://github.com/apache/beam/pull/11296#discussion_r616124184", "createdAt": "2021-04-19T19:33:58Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,171 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class PCollectionNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(object):\n+    def __init__(self, name):\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.name = name\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._pcollections_by_name: Dict[Union[str, translations.TimerFamilyId],\n+                                     WatermarkManager.PCollectionNode] = {}\n+    self._stages_by_name: Dict[str, WatermarkManager.StageNode] = {}\n+\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._stages_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._pcollections_by_name:\n+          self._pcollections_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._pcollections_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        return pcnode\n+\n+      # 1. Get stage inputs, create nodes for them, add to _stages_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:\n+            pcoll_name = transform.unique_name\n+            add_pcollection(pcoll_name, stage_node)\n+            continue\n+          else:\n+            _, pcoll_name = split_buffer_id(buffer_id)\n+          add_pcollection(pcoll_name, stage_node)\n+\n+      # 2. Get stage timers, and add them as inputs to the stage.\n+      for transform in s.transforms:\n+        if transform.spec.urn in translations.PAR_DO_URNS:\n+          payload = proto_utils.parse_Bytes(\n+              transform.spec.payload, beam_runner_api_pb2.ParDoPayload)\n+          for timer_family_id in payload.timer_family_specs.keys():\n+            timer_pcoll_name = (transform.unique_name, timer_family_id)\n+            self._pcollections_by_name[\n+                timer_pcoll_name] = WatermarkManager.PCollectionNode(\n+                    timer_pcoll_name)\n+            timer_pcoll_node = self._pcollections_by_name[timer_pcoll_name]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNzAwMDI0OQ==", "bodyText": "these are added to fix type checking issues (ensuring the types are what's expected)", "url": "https://github.com/apache/beam/pull/11296#discussion_r627000249", "createdAt": "2021-05-06T00:25:21Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,171 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class PCollectionNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(object):\n+    def __init__(self, name):\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.name = name\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._pcollections_by_name: Dict[Union[str, translations.TimerFamilyId],\n+                                     WatermarkManager.PCollectionNode] = {}\n+    self._stages_by_name: Dict[str, WatermarkManager.StageNode] = {}\n+\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._stages_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._pcollections_by_name:\n+          self._pcollections_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._pcollections_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        return pcnode\n+\n+      # 1. Get stage inputs, create nodes for them, add to _stages_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:\n+            pcoll_name = transform.unique_name\n+            add_pcollection(pcoll_name, stage_node)\n+            continue\n+          else:\n+            _, pcoll_name = split_buffer_id(buffer_id)\n+          add_pcollection(pcoll_name, stage_node)\n+\n+      # 2. Get stage timers, and add them as inputs to the stage.\n+      for transform in s.transforms:\n+        if transform.spec.urn in translations.PAR_DO_URNS:\n+          payload = proto_utils.parse_Bytes(\n+              transform.spec.payload, beam_runner_api_pb2.ParDoPayload)\n+          for timer_family_id in payload.timer_family_specs.keys():\n+            timer_pcoll_name = (transform.unique_name, timer_family_id)\n+            self._pcollections_by_name[\n+                timer_pcoll_name] = WatermarkManager.PCollectionNode(\n+                    timer_pcoll_name)\n+            timer_pcoll_node = self._pcollections_by_name[timer_pcoll_name]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjEyNDE4NA=="}, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg5ODk0NjI2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xOVQxOTozNDo0OFrOJLlQ_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wNlQwMDoyNToyM1rOJV9Dyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjEyNDY3MQ==", "bodyText": "ditto", "url": "https://github.com/apache/beam/pull/11296#discussion_r616124671", "createdAt": "2021-04-19T19:34:48Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,171 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class PCollectionNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(object):\n+    def __init__(self, name):\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.name = name\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._pcollections_by_name: Dict[Union[str, translations.TimerFamilyId],\n+                                     WatermarkManager.PCollectionNode] = {}\n+    self._stages_by_name: Dict[str, WatermarkManager.StageNode] = {}\n+\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._stages_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._pcollections_by_name:\n+          self._pcollections_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._pcollections_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        return pcnode\n+\n+      # 1. Get stage inputs, create nodes for them, add to _stages_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:\n+            pcoll_name = transform.unique_name\n+            add_pcollection(pcoll_name, stage_node)\n+            continue\n+          else:\n+            _, pcoll_name = split_buffer_id(buffer_id)\n+          add_pcollection(pcoll_name, stage_node)\n+\n+      # 2. Get stage timers, and add them as inputs to the stage.\n+      for transform in s.transforms:\n+        if transform.spec.urn in translations.PAR_DO_URNS:\n+          payload = proto_utils.parse_Bytes(\n+              transform.spec.payload, beam_runner_api_pb2.ParDoPayload)\n+          for timer_family_id in payload.timer_family_specs.keys():\n+            timer_pcoll_name = (transform.unique_name, timer_family_id)\n+            self._pcollections_by_name[\n+                timer_pcoll_name] = WatermarkManager.PCollectionNode(\n+                    timer_pcoll_name)\n+            timer_pcoll_node = self._pcollections_by_name[timer_pcoll_name]\n+            assert isinstance(\n+                timer_pcoll_node, WatermarkManager.PCollectionNode)\n+            stage_node.inputs.add(timer_pcoll_node)\n+\n+      # 3. Get stage outputs, create nodes for them, add to\n+      # _pcollections_by_name, and add stage as their producer\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_OUTPUT_URN:\n+          buffer_id = transform.spec.payload\n+          _, pcoll_name = split_buffer_id(buffer_id)\n+          if pcoll_name not in self._pcollections_by_name:\n+            self._pcollections_by_name[\n+                pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+          pcoll_node = self._pcollections_by_name[pcoll_name]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNzAwMDI2Nw==", "bodyText": "these are added to fix type checking issues", "url": "https://github.com/apache/beam/pull/11296#discussion_r627000267", "createdAt": "2021-05-06T00:25:23Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/watermark_manager.py", "diffHunk": "@@ -0,0 +1,171 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities for managing watermarks for a pipeline execution by FnApiRunner.\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+from typing import Union\n+\n+from apache_beam.portability.api import beam_runner_api_pb2\n+from apache_beam.runners.portability.fn_api_runner import translations\n+from apache_beam.runners.portability.fn_api_runner.translations import split_buffer_id\n+from apache_beam.runners.worker import bundle_processor\n+from apache_beam.utils import proto_utils\n+from apache_beam.utils import timestamp\n+\n+\n+class WatermarkManager(object):\n+  \"\"\"Manages the watermarks of a pipeline's stages.\n+    It works by constructing an internal graph representation of the pipeline,\n+    and keeping track of dependencies.\"\"\"\n+  class PCollectionNode(object):\n+    def __init__(self, name):\n+      self.name = name\n+      self._watermark = timestamp.MIN_TIMESTAMP\n+      self.producers: Set[WatermarkManager.StageNode] = set()\n+\n+    def __str__(self):\n+      return 'PCollectionNode<producers=%s>' % list(self.producers)\n+\n+    def set_watermark(self, wm: timestamp.Timestamp):\n+      self._watermark = min(self.upstream_watermark(), wm)\n+\n+    def upstream_watermark(self):\n+      if self.producers:\n+        return min(p.input_watermark() for p in self.producers)\n+      else:\n+        return timestamp.MAX_TIMESTAMP\n+\n+    def watermark(self):\n+      return self._watermark\n+\n+  class StageNode(object):\n+    def __init__(self, name):\n+      # We keep separate inputs and side inputs because side inputs\n+      # should hold back a stage's input watermark, to hold back execution\n+      # for that stage; but they should not be considered when calculating\n+      # the output watermark of the stage, because only the main input\n+      # can actually advance that watermark.\n+      self.name = name\n+      self.inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.side_inputs: Set[WatermarkManager.PCollectionNode] = set()\n+      self.outputs: Set[WatermarkManager.PCollectionNode] = set()\n+\n+    def __str__(self):\n+      return 'StageNode<inputs=%s,side_inputs=%s' % (\n+          [i.name for i in self.inputs], [i.name for i in self.side_inputs])\n+\n+    def output_watermark(self):\n+      if not self.outputs:\n+        return self.input_watermark()\n+      else:\n+        return min(o.watermark() for o in self.outputs)\n+\n+    def input_watermark(self):\n+      if not self.inputs:\n+        return timestamp.MAX_TIMESTAMP\n+      w = min(i.upstream_watermark() for i in self.inputs)\n+\n+      if self.side_inputs:\n+        w = min(w, min(i.upstream_watermark() for i in self.side_inputs))\n+      return w\n+\n+  def __init__(self, stages):\n+    # type: (List[translations.Stage]) -> None\n+    self._pcollections_by_name: Dict[Union[str, translations.TimerFamilyId],\n+                                     WatermarkManager.PCollectionNode] = {}\n+    self._stages_by_name: Dict[str, WatermarkManager.StageNode] = {}\n+\n+    for s in stages:\n+      stage_name = s.name\n+      stage_node = WatermarkManager.StageNode(stage_name)\n+      self._stages_by_name[stage_name] = stage_node\n+\n+      def add_pcollection(\n+          pcname: str, snode: WatermarkManager.StageNode\n+      ) -> WatermarkManager.PCollectionNode:\n+        if pcname not in self._pcollections_by_name:\n+          self._pcollections_by_name[pcname] = WatermarkManager.PCollectionNode(\n+              pcname)\n+        pcnode = self._pcollections_by_name[pcname]\n+        assert isinstance(pcnode, WatermarkManager.PCollectionNode)\n+        snode.inputs.add(pcnode)\n+        return pcnode\n+\n+      # 1. Get stage inputs, create nodes for them, add to _stages_by_name,\n+      #    and add as inputs to stage node.\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          buffer_id = transform.spec.payload\n+          if buffer_id == translations.IMPULSE_BUFFER:\n+            pcoll_name = transform.unique_name\n+            add_pcollection(pcoll_name, stage_node)\n+            continue\n+          else:\n+            _, pcoll_name = split_buffer_id(buffer_id)\n+          add_pcollection(pcoll_name, stage_node)\n+\n+      # 2. Get stage timers, and add them as inputs to the stage.\n+      for transform in s.transforms:\n+        if transform.spec.urn in translations.PAR_DO_URNS:\n+          payload = proto_utils.parse_Bytes(\n+              transform.spec.payload, beam_runner_api_pb2.ParDoPayload)\n+          for timer_family_id in payload.timer_family_specs.keys():\n+            timer_pcoll_name = (transform.unique_name, timer_family_id)\n+            self._pcollections_by_name[\n+                timer_pcoll_name] = WatermarkManager.PCollectionNode(\n+                    timer_pcoll_name)\n+            timer_pcoll_node = self._pcollections_by_name[timer_pcoll_name]\n+            assert isinstance(\n+                timer_pcoll_node, WatermarkManager.PCollectionNode)\n+            stage_node.inputs.add(timer_pcoll_node)\n+\n+      # 3. Get stage outputs, create nodes for them, add to\n+      # _pcollections_by_name, and add stage as their producer\n+      for transform in s.transforms:\n+        if transform.spec.urn == bundle_processor.DATA_OUTPUT_URN:\n+          buffer_id = transform.spec.payload\n+          _, pcoll_name = split_buffer_id(buffer_id)\n+          if pcoll_name not in self._pcollections_by_name:\n+            self._pcollections_by_name[\n+                pcoll_name] = WatermarkManager.PCollectionNode(pcoll_name)\n+          pcoll_node = self._pcollections_by_name[pcoll_name]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjEyNDY3MQ=="}, "originalCommit": {"oid": "e6dd9ed056df91737b117eff4443a09a9054cd7c"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1367, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}