{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzNDk1MDkx", "number": 11821, "title": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.", "bodyText": "This only impacts Dataflow runner v2 since the new expansions are guarded by the experiment \"beam_fn_api\" and \"use_runner_v2\".\nThis currently has little benefit for portable runners since they still treat all views as in memory iterables of values but opens the door for them once we can remove the requirement on the \"use_runner_v2\" experiment. I did the pre-work to fill in the iterable support for non-Dataflow portable runners but it isn't exercised.\nThis builds on prior work for exposing iterable and multimap views to runners in BEAM-3419\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-05-26T22:22:26Z", "url": "https://github.com/apache/beam/pull/11821", "merged": true, "mergeCommit": {"oid": "d1c6ef6c9803536dddc67e064e6da53c04ce0f60"}, "closed": true, "closedAt": "2020-06-17T20:27:47Z", "author": {"login": "lukecwik"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclg-KAABqjMzODAzMTM1NTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcr8GZZgBqjM0NTA5MjU0MjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "32c20bc00fd5d72f231af584326022dea75877f6", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/32c20bc00fd5d72f231af584326022dea75877f6", "committedDate": "2020-05-27T21:21:56Z", "message": "fixup! Attempt to fix Dataflow"}, "afterCommit": {"oid": "d8abc25540a0ed2227de8c549fbd67379007aa50", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/d8abc25540a0ed2227de8c549fbd67379007aa50", "committedDate": "2020-05-27T22:25:54Z", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable Dataflow since it overrides the PTransform expansion PCollection views.\nThis currently has little benefit for other runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d8abc25540a0ed2227de8c549fbd67379007aa50", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/d8abc25540a0ed2227de8c549fbd67379007aa50", "committedDate": "2020-05-27T22:25:54Z", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable Dataflow since it overrides the PTransform expansion PCollection views.\nThis currently has little benefit for other runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions."}, "afterCommit": {"oid": "f71ba818bdbed1c60d20d126730a1447cc38b466", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/f71ba818bdbed1c60d20d126730a1447cc38b466", "committedDate": "2020-05-27T22:43:05Z", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable Dataflow since it overrides the PTransform expansion PCollection views.\nThis currently has little benefit for other runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f71ba818bdbed1c60d20d126730a1447cc38b466", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/f71ba818bdbed1c60d20d126730a1447cc38b466", "committedDate": "2020-05-27T22:43:05Z", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable Dataflow since it overrides the PTransform expansion PCollection views.\nThis currently has little benefit for other runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions."}, "afterCommit": {"oid": "12e1760588da1357421a5968695c1e271d0b39e1", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/12e1760588da1357421a5968695c1e271d0b39e1", "committedDate": "2020-05-28T17:55:09Z", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable Dataflow since it overrides the PTransform expansion PCollection views.\nThis currently has little benefit for other runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd51d857c314bfc3816665fc2d4b246c5584faef", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/dd51d857c314bfc3816665fc2d4b246c5584faef", "committedDate": "2020-05-28T21:33:06Z", "message": "fixup! Fix test to allow for lazy validation that the map doesn't contain duplicates."}, "afterCommit": {"oid": "dadff619b01125ff73c5f85aeea641f5635afe37", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/dadff619b01125ff73c5f85aeea641f5635afe37", "committedDate": "2020-06-01T19:21:08Z", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable runners since the new expansion is guarded by the experiment \"beam_fn_api\".\nThis currently has little benefit for portable runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions.\nThe singleton and iterable views can't be translated except if using the Dataflow runner v2 experiment since runner v1 doesn't support the iterable access pattern."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5OTg1Mjc4", "url": "https://github.com/apache/beam/pull/11821#pullrequestreview-429985278", "createdAt": "2020-06-12T19:22:25Z", "commit": {"oid": "6352f726feec43529c06659c48f0224815d07cbf"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxOToyNzoxM1rOGjPVVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1MDo0OFrOGjUGGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNDU2Nw==", "bodyText": "This is unrelated to your changes, but I'm curious why we would return empty here instead of throwing an error?", "url": "https://github.com/apache/beam/pull/11821#discussion_r439604567", "createdAt": "2020-06-12T19:27:13Z", "author": {"login": "ibzib"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkSideInputReader.java", "diffHunk": "@@ -71,8 +79,23 @@ public FlinkSideInputReader(\n             tag.getId(), new SideInputInitializer<>(view));\n     T result = sideInputs.get(window);\n     if (result == null) {\n-      ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n-      result = viewFn.apply(InMemoryMultimapSideInputView.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352f726feec43529c06659c48f0224815d07cbf"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNzE0Mw==", "bodyText": "Are use_runner_v2 and use_unified_worker synonymous? If so, which is preferred?", "url": "https://github.com/apache/beam/pull/11821#discussion_r439607143", "createdAt": "2020-06-12T19:33:26Z", "author": {"login": "ibzib"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Combine.java", "diffHunk": "@@ -1302,13 +1303,35 @@ private GloballyAsSingletonView(\n \n     @Override\n     public PCollectionView<OutputT> expand(PCollection<InputT> input) {\n+      // TODO(BEAM-10097): Make this the default expansion for all portable runners.\n+      if (hasExperiment(input.getPipeline().getOptions(), \"beam_fn_api\")\n+          && (hasExperiment(input.getPipeline().getOptions(), \"use_runner_v2\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352f726feec43529c06659c48f0224815d07cbf"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNzQ0OQ==", "bodyText": "Is the performance difference dependent on the runner implementation?", "url": "https://github.com/apache/beam/pull/11821#discussion_r439607449", "createdAt": "2020-06-12T19:34:16Z", "author": {"login": "ibzib"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/View.java", "diffHunk": "@@ -157,7 +166,10 @@ private View() {}\n    * PCollectionView} mapping each window to a {@link List} containing all of the elements in the\n    * window.\n    *\n-   * <p>Unlike with {@link #asIterable}, the resulting list is required to fit in memory.\n+   * <p>This view should only be used if random access and/or size of the PCollection is required.\n+   * {@link #asIterable()} will perform significantly better for sequential access.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352f726feec43529c06659c48f0224815d07cbf"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0MTI3OQ==", "bodyText": "I'm not sure these implementation details belong at the javadoc level; consider moving them into the body of the class so it's clearer what it's describing.", "url": "https://github.com/apache/beam/pull/11821#discussion_r439641279", "createdAt": "2020-06-12T21:03:06Z", "author": {"login": "ibzib"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/View.java", "diffHunk": "@@ -219,6 +231,16 @@ private View() {}\n    * <p>Public only so a {@link PipelineRunner} may override its behavior.\n    *\n    * <p>See {@link View#asList()}.\n+   *\n+   * <p>The materialized format uses {@link Materializations#MULTIMAP_MATERIALIZATION_URN multimap}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352f726feec43529c06659c48f0224815d07cbf"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0NTA1Mw==", "bodyText": "Nit: consider a more descriptive naming scheme and/or comments to differentiate these from the originals.", "url": "https://github.com/apache/beam/pull/11821#discussion_r439645053", "createdAt": "2020-06-12T21:14:35Z", "author": {"login": "ibzib"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/PCollectionViews.java", "diffHunk": "@@ -151,13 +279,103 @@\n   }\n \n   /**\n-   * Implementation which is able to adapt a multimap materialization to a {@code T}.\n+   * Implementation which is able to adapt an iterable materialization to a {@code T}.\n    *\n    * <p>For internal use only.\n    *\n    * <p>Instantiate via {@link PCollectionViews#singletonView}.\n    */\n   @Experimental(Kind.CORE_RUNNERS_ONLY)\n+  private static class SingletonViewFn2<T> extends ViewFn<IterableView<T>, T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352f726feec43529c06659c48f0224815d07cbf"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0ODY4Nw==", "bodyText": "Nit: missing a noun here", "url": "https://github.com/apache/beam/pull/11821#discussion_r439648687", "createdAt": "2020-06-12T21:25:40Z", "author": {"login": "ibzib"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/PCollectionViews.java", "diffHunk": "@@ -533,4 +1251,141 @@ public String toString() {\n       return Collections.singletonMap(tag, pCollection);\n     }\n   }\n+\n+  /** A {@link MultimapView} to {@link Map Map<K, V>} adapter. */\n+  private static class MultimapViewToMapAdapter<K, V> extends AbstractMap<K, V> {\n+    private final MultimapView<K, V> primitiveViewT;\n+    private final Supplier<Integer> size;\n+\n+    private MultimapViewToMapAdapter(MultimapView<K, V> primitiveViewT) {\n+      this.primitiveViewT = primitiveViewT;\n+      this.size = Suppliers.memoize(() -> Iterables.size(primitiveViewT.get()));\n+    }\n+\n+    @Override\n+    public boolean containsKey(Object key) {\n+      return primitiveViewT.get((K) key).iterator().hasNext();\n+    }\n+\n+    @Override\n+    public V get(Object key) {\n+      Iterator<V> iterator = primitiveViewT.get((K) key).iterator();\n+      if (!iterator.hasNext()) {\n+        return null;\n+      }\n+      V value = iterator.next();\n+      if (iterator.hasNext()) {\n+        throw new IllegalArgumentException(\"Duplicate values for \" + key);\n+      }\n+      return value;\n+    }\n+\n+    @Override\n+    public int size() {\n+      return size.get();\n+    }\n+\n+    @Override\n+    public Set<Entry<K, V>> entrySet() {\n+      return new AbstractSet<Entry<K, V>>() {\n+        @Override\n+        public Iterator<Entry<K, V>> iterator() {\n+          return FluentIterable.from(primitiveViewT.get())\n+              .<Entry<K, V>>transform((K key) -> new SimpleEntry<>(key, get(key)))\n+              .iterator();\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+          if (!(o instanceof Entry)) {\n+            return false;\n+          }\n+          Entry<?, ?> entry = (Entry<?, ?>) o;\n+          // We treat the absence of the key in the map as a difference in these abstract sets. The\n+          // underlying primitive view represents missing keys as empty iterables so we use this\n+          // to check if the map contains the key first before comparing values.\n+          Iterable<V> value = primitiveViewT.get((K) entry.getKey());\n+          if (value.iterator().hasNext()) {\n+            return false;\n+          }\n+          return Objects.equals(entry.getValue(), value);\n+        }\n+\n+        @Override\n+        public int size() {\n+          return size.get();\n+        }\n+      };\n+    }\n+  }\n+\n+  /** A {@link MultimapView} to {@link Map Map<K, Iterable<V>>} adapter. */\n+  private static class MultimapViewToMultimapAdapter<K, V> extends AbstractMap<K, Iterable<V>> {\n+    private final MultimapView<K, V> primitiveViewT;\n+    private final Supplier<Integer> size;\n+\n+    private MultimapViewToMultimapAdapter(MultimapView<K, V> primitiveViewT) {\n+      this.primitiveViewT = primitiveViewT;\n+      this.size = Suppliers.memoize(() -> Iterables.size(primitiveViewT.get()));\n+    }\n+\n+    @Override\n+    public boolean containsKey(Object key) {\n+      return primitiveViewT.get((K) key).iterator().hasNext();\n+    }\n+\n+    @Override\n+    public Iterable<V> get(Object key) {\n+      Iterable<V> values = primitiveViewT.get((K) key);\n+      // The only was for the values iterable to be empty is for us to have never seen such a key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352f726feec43529c06659c48f0224815d07cbf"}, "originalPosition": 956}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTY1OQ==", "bodyText": "Nit: Can you rename this class? Maybe something like \"ValueOrMetadata\"?", "url": "https://github.com/apache/beam/pull/11821#discussion_r439679659", "createdAt": "2020-06-12T23:32:45Z", "author": {"login": "ibzib"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/PCollectionViews.java", "diffHunk": "@@ -278,6 +528,398 @@ public IterableViewFn(TypeDescriptorSupplier<T> typeDescriptorSupplier) {\n    * <p>Instantiate via {@link PCollectionViews#listView}.\n    */\n   @Experimental(Kind.CORE_RUNNERS_ONLY)\n+  @VisibleForTesting\n+  static class ListViewFn2<T> extends ViewFn<MultimapView<Long, MetaOr<T, OffsetRange>>, List<T>> {\n+    private TypeDescriptorSupplier<T> typeDescriptorSupplier;\n+\n+    public ListViewFn2(TypeDescriptorSupplier<T> typeDescriptorSupplier) {\n+      this.typeDescriptorSupplier = typeDescriptorSupplier;\n+    }\n+\n+    @Override\n+    public Materialization<MultimapView<Long, MetaOr<T, OffsetRange>>> getMaterialization() {\n+      return Materializations.multimap();\n+    }\n+\n+    @Override\n+    public List<T> apply(MultimapView<Long, MetaOr<T, OffsetRange>> primitiveViewT) {\n+      return Collections.unmodifiableList(new ListOverMultimapView<>(primitiveViewT));\n+    }\n+\n+    @Override\n+    public TypeDescriptor<List<T>> getTypeDescriptor() {\n+      return TypeDescriptors.lists(typeDescriptorSupplier.get());\n+    }\n+\n+    /**\n+     * A {@link List} adapter over a {@link MultimapView}.\n+     *\n+     * <p>See {@link View.AsList} for a description of the materialized format and {@code index} to\n+     * {@code (position, sub-position)} mapping details.\n+     */\n+    private static class ListOverMultimapView<T> extends AbstractList<T> implements RandomAccess {\n+      private final MultimapView<Long, MetaOr<T, OffsetRange>> primitiveView;\n+      /**\n+       * A mapping from non over-lapping ranges to the number of elements at each position within\n+       * that range. Ranges not specified in the mapping implicitly have 0 elements at those\n+       * positions.\n+       *\n+       * <p>Used to quickly compute the {@code index} -> {@code (position, sub-position} within the\n+       * map.\n+       */\n+      private final Supplier<SortedMap<OffsetRange, Integer>>\n+          nonOverlappingRangesToNumElementsPerPosition;\n+\n+      private final Supplier<Integer> size;\n+\n+      private ListOverMultimapView(MultimapView<Long, MetaOr<T, OffsetRange>> primitiveView) {\n+        this.primitiveView = primitiveView;\n+        this.nonOverlappingRangesToNumElementsPerPosition =\n+            Suppliers.memoize(\n+                () ->\n+                    computeOverlappingRanges(\n+                        Iterables.transform(\n+                            primitiveView.get(Long.MIN_VALUE), (value) -> value.getMetadata())));\n+        this.size =\n+            Suppliers.memoize(\n+                () -> computeTotalNumElements(nonOverlappingRangesToNumElementsPerPosition.get()));\n+      }\n+\n+      @Override\n+      public T get(int index) {\n+        if (index < 0 || index >= size.get()) {\n+          throw new IndexOutOfBoundsException();\n+        }\n+        KV<Long, Integer> position =\n+            computePositionForIndex(nonOverlappingRangesToNumElementsPerPosition.get(), index);\n+        return Iterables.get(primitiveView.get(position.getKey()), position.getValue()).get();\n+      }\n+\n+      @Override\n+      public int size() {\n+        return size.get();\n+      }\n+\n+      @Override\n+      public Iterator<T> iterator() {\n+        return listIterator();\n+      }\n+\n+      @Override\n+      public ListIterator<T> listIterator() {\n+        return super.listIterator();\n+      }\n+\n+      /** A {@link ListIterator} over {@link MultimapView} adapter. */\n+      private class ListIteratorOverMultimapView implements ListIterator<T> {\n+        private int position;\n+\n+        @Override\n+        public boolean hasNext() {\n+          return position < size();\n+        }\n+\n+        @Override\n+        public T next() {\n+          if (!hasNext()) {\n+            throw new NoSuchElementException();\n+          }\n+          T rval = get(position);\n+          position += 1;\n+          return rval;\n+        }\n+\n+        @Override\n+        public boolean hasPrevious() {\n+          return position > 0;\n+        }\n+\n+        @Override\n+        public T previous() {\n+          if (!hasPrevious()) {\n+            throw new NoSuchElementException();\n+          }\n+          position -= 1;\n+          return get(position);\n+        }\n+\n+        @Override\n+        public int nextIndex() {\n+          return position;\n+        }\n+\n+        @Override\n+        public int previousIndex() {\n+          return position - 1;\n+        }\n+\n+        @Override\n+        public void remove() {\n+          throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void set(T e) {\n+          throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void add(T e) {\n+          throw new UnsupportedOperationException();\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Compares {@link OffsetRange}s such that ranges are ordered by the smallest {@code from} and in\n+   * case of a tie the smallest {@code to}.\n+   */\n+  @VisibleForTesting\n+  static class OffsetRangeComparator implements Comparator<OffsetRange> {\n+    private static final OffsetRangeComparator INSTANCE = new OffsetRangeComparator();\n+\n+    @Override\n+    public int compare(OffsetRange o1, OffsetRange o2) {\n+      int fromComparison = Longs.compare(o1.getFrom(), o2.getFrom());\n+      if (fromComparison != 0) {\n+        return fromComparison;\n+      }\n+      return Longs.compare(o1.getTo(), o2.getTo());\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static SortedMap<OffsetRange, Integer> computeOverlappingRanges(Iterable<OffsetRange> ranges) {\n+    ImmutableSortedMap.Builder<OffsetRange, Integer> rval =\n+        ImmutableSortedMap.orderedBy(OffsetRangeComparator.INSTANCE);\n+    List<OffsetRange> sortedRanges = Lists.newArrayList(ranges);\n+    if (sortedRanges.isEmpty()) {\n+      return rval.build();\n+    }\n+    Collections.sort(sortedRanges, OffsetRangeComparator.INSTANCE);\n+\n+    // Stores ranges in smallest 'from' and then smallest 'to' order\n+    // e.g. [2, 7), [3, 4), [3, 5), [3, 5), [3, 6), [4, 0)\n+    PriorityQueue<OffsetRange> rangesWithSameFrom =\n+        new PriorityQueue<>(OffsetRangeComparator.INSTANCE);\n+    Iterator<OffsetRange> iterator = sortedRanges.iterator();\n+\n+    // Stored in reverse sorted order so that when we iterate and re-add them back to\n+    // overlappingRanges they are stored in sorted order from smallest to largest range.to\n+    List<OffsetRange> rangesToProcess = new ArrayList<>();\n+    while (iterator.hasNext()) {\n+      OffsetRange current = iterator.next();\n+      // Skip empty ranges\n+      if (current.getFrom() == current.getTo()) {\n+        continue;\n+      }\n+\n+      // If the current range has a different 'from' then a prior range then we must produce\n+      // ranges in [rangesWithSameFrom.from, current.from)\n+      while (!rangesWithSameFrom.isEmpty()\n+          && rangesWithSameFrom.peek().getFrom() != current.getFrom()) {\n+        rangesToProcess.addAll(rangesWithSameFrom);\n+        Collections.sort(rangesToProcess, OffsetRangeComparator.INSTANCE);\n+        rangesWithSameFrom.clear();\n+\n+        int i = 0;\n+        long lastTo = rangesToProcess.get(i).getFrom();\n+        // Output all the ranges that are strictly less then current.from\n+        // e.g. current.to := 7 for [3, 4), [3, 5), [3, 5), [3, 6) will produce\n+        // [3, 4) := 4\n+        // [4, 5) := 3\n+        // [5, 6) := 1\n+        for (; i < rangesToProcess.size(); ++i) {\n+          if (rangesToProcess.get(i).getTo() > current.getFrom()) {\n+            break;\n+          }\n+          // Output only the first of any subsequent duplicate ranges\n+          if (i == 0 || rangesToProcess.get(i - 1).getTo() != rangesToProcess.get(i).getTo()) {\n+            rval.put(\n+                new OffsetRange(lastTo, rangesToProcess.get(i).getTo()),\n+                rangesToProcess.size() - i);\n+            lastTo = rangesToProcess.get(i).getTo();\n+          }\n+        }\n+\n+        // We exitted the loop with 'to' > current.from, we must add the range [lastTo,\n+        // current.from) if it is non-empty\n+        if (lastTo < current.getFrom() && i != rangesToProcess.size()) {\n+          rval.put(new OffsetRange(lastTo, current.getFrom()), rangesToProcess.size() - i);\n+        }\n+\n+        // The remaining ranges have a 'to' that is greater then 'current.from' and will overlap\n+        // with current so add them back to rangesWithSameFrom with the updated 'from'\n+        for (; i < rangesToProcess.size(); ++i) {\n+          rangesWithSameFrom.add(\n+              new OffsetRange(current.getFrom(), rangesToProcess.get(i).getTo()));\n+        }\n+\n+        rangesToProcess.clear();\n+      }\n+      rangesWithSameFrom.add(current);\n+    }\n+\n+    // Process the last chunk of overlapping ranges\n+    while (!rangesWithSameFrom.isEmpty()) {\n+      // This range always represents the range with with the smallest 'to'\n+      OffsetRange current = rangesWithSameFrom.remove();\n+\n+      rangesToProcess.addAll(rangesWithSameFrom);\n+      Collections.sort(rangesToProcess, OffsetRangeComparator.INSTANCE);\n+      rangesWithSameFrom.clear();\n+\n+      rval.put(current, rangesToProcess.size() + 1 /* include current */);\n+\n+      // Shorten all the remaining ranges such that they start with current.to\n+      for (OffsetRange rangeWithDifferentFrom : rangesToProcess) {\n+        // Skip any duplicates of current\n+        if (rangeWithDifferentFrom.getTo() > current.getTo()) {\n+          rangesWithSameFrom.add(new OffsetRange(current.getTo(), rangeWithDifferentFrom.getTo()));\n+        }\n+      }\n+      rangesToProcess.clear();\n+    }\n+    return rval.build();\n+  }\n+\n+  @VisibleForTesting\n+  static int computeTotalNumElements(\n+      Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition) {\n+    long sum = 0;\n+    for (Map.Entry<OffsetRange, Integer> range :\n+        nonOverlappingRangesToNumElementsPerPosition.entrySet()) {\n+      sum +=\n+          Math.multiplyExact(\n+              Math.subtractExact(range.getKey().getTo(), range.getKey().getFrom()),\n+              range.getValue());\n+    }\n+    return Ints.checkedCast(sum);\n+  }\n+\n+  @VisibleForTesting\n+  static KV<Long, Integer> computePositionForIndex(\n+      Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition, int index) {\n+    if (index < 0) {\n+      throw new IndexOutOfBoundsException(\n+          String.format(\n+              \"Position %s was out of bounds for ranges %s.\",\n+              index, nonOverlappingRangesToNumElementsPerPosition));\n+    }\n+    for (Map.Entry<OffsetRange, Integer> range :\n+        nonOverlappingRangesToNumElementsPerPosition.entrySet()) {\n+      int numElementsInRange =\n+          Ints.checkedCast(\n+              Math.multiplyExact(\n+                  Math.subtractExact(range.getKey().getTo(), range.getKey().getFrom()),\n+                  range.getValue()));\n+      if (numElementsInRange <= index) {\n+        index -= numElementsInRange;\n+        continue;\n+      }\n+      long position = range.getKey().getFrom() + index / range.getValue();\n+      int subPosition = index % range.getValue();\n+      return KV.of(position, subPosition);\n+    }\n+    throw new IndexOutOfBoundsException(\n+        String.format(\n+            \"Position %s was out of bounds for ranges %s.\",\n+            index, nonOverlappingRangesToNumElementsPerPosition));\n+  }\n+\n+  /** Stores values or metadata about values. */\n+  public static class MetaOr<T, MetaT> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352f726feec43529c06659c48f0224815d07cbf"}, "originalPosition": 682}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTg4Mw==", "bodyText": "Where'd this number come from?", "url": "https://github.com/apache/beam/pull/11821#discussion_r439679883", "createdAt": "2020-06-12T23:34:14Z", "author": {"login": "ibzib"}, "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/values/PCollectionViewsTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.values;\n+\n+import static org.apache.beam.sdk.values.PCollectionViews.computeOverlappingRanges;\n+import static org.apache.beam.sdk.values.PCollectionViews.computePositionForIndex;\n+import static org.apache.beam.sdk.values.PCollectionViews.computeTotalNumElements;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertThrows;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.TreeSet;\n+import java.util.stream.IntStream;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ArrayListMultimap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ListMultimap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Tests for {@link PCollectionViews}. */\n+@RunWith(JUnit4.class)\n+public class PCollectionViewsTest {\n+  @Test\n+  public void testEmpty() {\n+    Iterable<OffsetRange> ranges = Collections.emptyList();\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(nonOverlappingRangesToNumElementsPerPosition, Collections.emptyMap());\n+    assertEquals(0, computeTotalNumElements(nonOverlappingRangesToNumElementsPerPosition));\n+    assertThrows(\n+        IndexOutOfBoundsException.class,\n+        () -> computePositionForIndex(nonOverlappingRangesToNumElementsPerPosition, 0));\n+  }\n+\n+  @Test\n+  public void testNoOverlapping() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 2), range(4, 6));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.of(range(0, 2), 1, range(4, 6), 1),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testOnlyTouchingRanges() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 4), range(4, 8), range(8, 12));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.of(range(0, 4), 1, range(4, 8), 1, range(8, 12), 1),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testRangesWithAtMostOneOverlap() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 6), range(4, 10), range(8, 12));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder()\n+            .put(range(0, 4), 1)\n+            .put(range(4, 6), 2)\n+            .put(range(6, 8), 1)\n+            .put(range(8, 10), 2)\n+            .put(range(10, 12), 1)\n+            .build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testOverlappingFroms() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 4), range(0, 8), range(0, 12));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder().put(range(0, 4), 3).put(range(4, 8), 2).put(range(8, 12), 1).build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testOverlappingTos() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 12), range(4, 12), range(8, 12));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder().put(range(0, 4), 1).put(range(4, 8), 2).put(range(8, 12), 3).build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testOverlappingFromsAndTos() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 4), range(0, 4), range(0, 4));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder().put(range(0, 4), 3).build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testMultipleOverlapsForTheSameRange() {\n+    Iterable<OffsetRange> ranges =\n+        Arrays.asList(\n+            range(0, 4),\n+            range(0, 8),\n+            range(0, 12),\n+            range(0, 12),\n+            range(4, 12),\n+            range(8, 12),\n+            range(0, 4),\n+            range(0, 8),\n+            range(0, 12),\n+            range(0, 12),\n+            range(4, 12),\n+            range(8, 12));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder().put(range(0, 4), 8).put(range(4, 8), 8).put(range(8, 12), 8).build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testIncreasingOverlaps() {\n+    Iterable<OffsetRange> ranges =\n+        Arrays.asList(range(0, 4), range(1, 5), range(2, 6), range(3, 7), range(4, 8), range(5, 9));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder()\n+            .put(range(0, 1), 1)\n+            .put(range(1, 2), 2)\n+            .put(range(2, 3), 3)\n+            .put(range(3, 4), 4)\n+            .put(range(4, 5), 4)\n+            .put(range(5, 6), 4)\n+            .put(range(6, 7), 3)\n+            .put(range(7, 8), 2)\n+            .put(range(8, 9), 1)\n+            .build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testNestedOverlaps() {\n+    Iterable<OffsetRange> ranges =\n+        Arrays.asList(range(0, 8), range(1, 7), range(2, 6), range(3, 5));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder()\n+            .put(range(0, 1), 1)\n+            .put(range(1, 2), 2)\n+            .put(range(2, 3), 3)\n+            .put(range(3, 5), 4)\n+            .put(range(5, 6), 3)\n+            .put(range(6, 7), 2)\n+            .put(range(7, 8), 1)\n+            .build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testRandomRanges() {\n+    Random random = new Random(123892154890L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352f726feec43529c06659c48f0224815d07cbf"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjU4Nw==", "bodyText": "Is this used anywhere?", "url": "https://github.com/apache/beam/pull/11821#discussion_r439682587", "createdAt": "2020-06-12T23:50:48Z", "author": {"login": "ibzib"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/View.java", "diffHunk": "@@ -496,6 +622,22 @@ public void processElement(@Element T element, OutputReceiver<KV<Void, T>> r) {\n     }\n   }\n \n+  /** An identity {@link PTransform}. */\n+  private static class IdentityTransform<T> extends PTransform<PCollection<T>, PCollection<T>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352f726feec43529c06659c48f0224815d07cbf"}, "originalPosition": 273}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMDA1ODcw", "url": "https://github.com/apache/beam/pull/11821#pullrequestreview-431005870", "createdAt": "2020-06-15T21:27:10Z", "commit": {"oid": "8eb07b4bf88bb476e51393f686195f9aa43a2708"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd47e0f914842230d7aadfdfa17bd09c3de36587", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/bd47e0f914842230d7aadfdfa17bd09c3de36587", "committedDate": "2020-06-16T20:53:05Z", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable runners since the new expansion is guarded by the experiment \"beam_fn_api\".\nThis currently has little benefit for portable runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions.\nThe singleton and iterable views can't be translated except if using the Dataflow runner v2 experiment since runner v1 doesn't support the iterable access pattern."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec8769f6163ca8a4daecc2fb29708bc1da430917", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/ec8769f6163ca8a4daecc2fb29708bc1da430917", "committedDate": "2020-06-16T21:25:34Z", "message": "fixup! Fix test after rebase on master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "13f36acb3623f6a4d64169a2ed408a7f4484146a", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/13f36acb3623f6a4d64169a2ed408a7f4484146a", "committedDate": "2020-06-16T20:24:30Z", "message": "fixup! Address PR comments."}, "afterCommit": {"oid": "ec8769f6163ca8a4daecc2fb29708bc1da430917", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/ec8769f6163ca8a4daecc2fb29708bc1da430917", "committedDate": "2020-06-16T21:25:34Z", "message": "fixup! Fix test after rebase on master"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4368, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}