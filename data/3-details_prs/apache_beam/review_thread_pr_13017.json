{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4MjA0NjA5", "number": 13017, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMjoyMjoxM1rOEq8SRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToxMDowMFrOEv-njA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDYzMzY3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMjoyMjoxM1rOHdb-3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjoxNToyMVrOHhnmMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYyOTIxNA==", "bodyText": "Can this be obtained without plumbing to the ctor. I.e. as a pipeline option accessed directly, or constant in this file?", "url": "https://github.com/apache/beam/pull/13017#discussion_r500629214", "createdAt": "2020-10-06T22:22:13Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -1102,7 +1096,7 @@ def __init__(\n       retry_strategy=None,\n       additional_bq_parameters=None,\n       ignore_insert_ids=False,\n-      latency_logging_frequency_sec=None):\n+      streaming_api_logging_frequency_sec=None):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAxMzgwOQ==", "bodyText": "done.", "url": "https://github.com/apache/beam/pull/13017#discussion_r505013809", "createdAt": "2020-10-14T22:15:21Z", "author": {"login": "ihji"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -1102,7 +1096,7 @@ def __init__(\n       retry_strategy=None,\n       additional_bq_parameters=None,\n       ignore_insert_ids=False,\n-      latency_logging_frequency_sec=None):\n+      streaming_api_logging_frequency_sec=None):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYyOTIxNA=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTUyODEwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/metrics/cells.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwMDo1NToyN1rOHeKdTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjoxNjo0OVrOHhnqlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5MDY2OA==", "bodyText": "Might be good to ensure this isn't called. Can we throw not implemented?\nOr if that breaks other code, at least comment why this isn't populated yet.", "url": "https://github.com/apache/beam/pull/13017#discussion_r501390668", "createdAt": "2020-10-08T00:55:27Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/metrics/cells.py", "diffHunk": "@@ -238,6 +250,57 @@ def to_runner_api_monitoring_info(self, name, transform_id):\n         ptransform=transform_id)\n \n \n+class HistogramCell(MetricCell):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  Tracks the current value and delta for a histogram metric.\n+\n+  Each cell tracks the state of a metric independently per context per bundle.\n+  Therefore, each metric has a different cell in each bundle, that is later\n+  aggregated.\n+\n+  This class is thread safe since underlying histogram object is thread safe.\n+  \"\"\"\n+  def __init__(self, bucket_type):\n+    self._bucket_type = bucket_type\n+    self.data = HistogramAggregator(bucket_type).identity_element()\n+\n+  def reset(self):\n+    self.data = HistogramAggregator(self._bucket_type).identity_element()\n+\n+  def combine(self, other):\n+    # type: (HistogramCell) -> HistogramCell\n+    result = HistogramCell(self._bucket_type)\n+    result.data = self.data.combine(other.data)\n+    return result\n+\n+  def update(self, value):\n+    self.data.histogram.record(value)\n+\n+  def get_cumulative(self):\n+    # type: () -> HistogramData\n+    return self.data.get_cumulative()\n+\n+  def to_runner_api_monitoring_info(self, name, transform_id):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAxNDkzNQ==", "bodyText": "done.", "url": "https://github.com/apache/beam/pull/13017#discussion_r505014935", "createdAt": "2020-10-14T22:16:49Z", "author": {"login": "ihji"}, "path": "sdks/python/apache_beam/metrics/cells.py", "diffHunk": "@@ -238,6 +250,57 @@ def to_runner_api_monitoring_info(self, name, transform_id):\n         ptransform=transform_id)\n \n \n+class HistogramCell(MetricCell):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  Tracks the current value and delta for a histogram metric.\n+\n+  Each cell tracks the state of a metric independently per context per bundle.\n+  Therefore, each metric has a different cell in each bundle, that is later\n+  aggregated.\n+\n+  This class is thread safe since underlying histogram object is thread safe.\n+  \"\"\"\n+  def __init__(self, bucket_type):\n+    self._bucket_type = bucket_type\n+    self.data = HistogramAggregator(bucket_type).identity_element()\n+\n+  def reset(self):\n+    self.data = HistogramAggregator(self._bucket_type).identity_element()\n+\n+  def combine(self, other):\n+    # type: (HistogramCell) -> HistogramCell\n+    result = HistogramCell(self._bucket_type)\n+    result.data = self.data.combine(other.data)\n+    return result\n+\n+  def update(self, value):\n+    self.data.histogram.record(value)\n+\n+  def get_cumulative(self):\n+    # type: () -> HistogramData\n+    return self.data.get_cumulative()\n+\n+  def to_runner_api_monitoring_info(self, name, transform_id):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5MDY2OA=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTUzNDkxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/metrics/cells.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwMDo1OTozOVrOHeKhPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDowNDowMlrOHiX-Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5MTY3Nw==", "bodyText": "Is this class necessary? It seems like it completely defers to HistogramCell, regardless of bucket_type or any parameters. Can it be removed. Do any of the other Cell classes have a Factory like this? I didn't notice this elsewhere.", "url": "https://github.com/apache/beam/pull/13017#discussion_r501391677", "createdAt": "2020-10-08T00:59:39Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/metrics/cells.py", "diffHunk": "@@ -238,6 +250,57 @@ def to_runner_api_monitoring_info(self, name, transform_id):\n         ptransform=transform_id)\n \n \n+class HistogramCell(MetricCell):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  Tracks the current value and delta for a histogram metric.\n+\n+  Each cell tracks the state of a metric independently per context per bundle.\n+  Therefore, each metric has a different cell in each bundle, that is later\n+  aggregated.\n+\n+  This class is thread safe since underlying histogram object is thread safe.\n+  \"\"\"\n+  def __init__(self, bucket_type):\n+    self._bucket_type = bucket_type\n+    self.data = HistogramAggregator(bucket_type).identity_element()\n+\n+  def reset(self):\n+    self.data = HistogramAggregator(self._bucket_type).identity_element()\n+\n+  def combine(self, other):\n+    # type: (HistogramCell) -> HistogramCell\n+    result = HistogramCell(self._bucket_type)\n+    result.data = self.data.combine(other.data)\n+    return result\n+\n+  def update(self, value):\n+    self.data.histogram.record(value)\n+\n+  def get_cumulative(self):\n+    # type: () -> HistogramData\n+    return self.data.get_cumulative()\n+\n+  def to_runner_api_monitoring_info(self, name, transform_id):\n+    return None\n+\n+\n+class HistogramCellFactory(MetricCellFactory):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5MjE3NA==", "bodyText": "Additionally, its not clear to me that MetricCellFactory is necessary", "url": "https://github.com/apache/beam/pull/13017#discussion_r501392174", "createdAt": "2020-10-08T01:01:42Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/metrics/cells.py", "diffHunk": "@@ -238,6 +250,57 @@ def to_runner_api_monitoring_info(self, name, transform_id):\n         ptransform=transform_id)\n \n \n+class HistogramCell(MetricCell):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  Tracks the current value and delta for a histogram metric.\n+\n+  Each cell tracks the state of a metric independently per context per bundle.\n+  Therefore, each metric has a different cell in each bundle, that is later\n+  aggregated.\n+\n+  This class is thread safe since underlying histogram object is thread safe.\n+  \"\"\"\n+  def __init__(self, bucket_type):\n+    self._bucket_type = bucket_type\n+    self.data = HistogramAggregator(bucket_type).identity_element()\n+\n+  def reset(self):\n+    self.data = HistogramAggregator(self._bucket_type).identity_element()\n+\n+  def combine(self, other):\n+    # type: (HistogramCell) -> HistogramCell\n+    result = HistogramCell(self._bucket_type)\n+    result.data = self.data.combine(other.data)\n+    return result\n+\n+  def update(self, value):\n+    self.data.histogram.record(value)\n+\n+  def get_cumulative(self):\n+    # type: () -> HistogramData\n+    return self.data.get_cumulative()\n+\n+  def to_runner_api_monitoring_info(self, name, transform_id):\n+    return None\n+\n+\n+class HistogramCellFactory(MetricCellFactory):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5MTY3Nw=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwNjQzNQ==", "bodyText": "MetricCellFactory creates a customized factory instance for creating MetricCell. Currently, MetricCell is created from Type[MetricCell] and cannot be parameterized. HistogramCell needs to support multiple bucket types with their own parameters so creating from singleton type objects didn't work.", "url": "https://github.com/apache/beam/pull/13017#discussion_r505806435", "createdAt": "2020-10-15T20:04:02Z", "author": {"login": "ihji"}, "path": "sdks/python/apache_beam/metrics/cells.py", "diffHunk": "@@ -238,6 +250,57 @@ def to_runner_api_monitoring_info(self, name, transform_id):\n         ptransform=transform_id)\n \n \n+class HistogramCell(MetricCell):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  Tracks the current value and delta for a histogram metric.\n+\n+  Each cell tracks the state of a metric independently per context per bundle.\n+  Therefore, each metric has a different cell in each bundle, that is later\n+  aggregated.\n+\n+  This class is thread safe since underlying histogram object is thread safe.\n+  \"\"\"\n+  def __init__(self, bucket_type):\n+    self._bucket_type = bucket_type\n+    self.data = HistogramAggregator(bucket_type).identity_element()\n+\n+  def reset(self):\n+    self.data = HistogramAggregator(self._bucket_type).identity_element()\n+\n+  def combine(self, other):\n+    # type: (HistogramCell) -> HistogramCell\n+    result = HistogramCell(self._bucket_type)\n+    result.data = self.data.combine(other.data)\n+    return result\n+\n+  def update(self, value):\n+    self.data.histogram.record(value)\n+\n+  def get_cumulative(self):\n+    # type: () -> HistogramData\n+    return self.data.get_cumulative()\n+\n+  def to_runner_api_monitoring_info(self, name, transform_id):\n+    return None\n+\n+\n+class HistogramCellFactory(MetricCellFactory):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5MTY3Nw=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTU2MzY0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/metrics/metric.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwMToxNzoxN1rOHeKxew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTowNzoxOVrOHlRIJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NTgzNQ==", "bodyText": "Can you test that this class works if you change the current metric environment. We should make sure that all instances of the metic on all MetricEnvironments will be logged. AS the DelegatingMetric's value changes based on the MetricEnvironment it is set in. I suspect what you are doing works fine, as long as long as you keep a separate timer for each MetricEnvironment. I.e. imagine two transforms with a metirc in two separate MetricEnvironments. If they are sharing the same time in the same MetricLogger, it may log for one metric environment, but not the other one, when it tries to log.\nNote:\n\nEvery time a new bundle is processed, a new MetricEnvironment is created, which will clear the metrics.\nSeparate transforms, or code running in separate threads will store metrics in separate MetricEnvironments\nDelegatingMetrics always use the current MetricEnvironment to store a metric, or get a metric value (This is a thread local variable which is reset when a new bundle is processed, new transform is executing, etc.).", "url": "https://github.com/apache/beam/pull/13017#discussion_r501395835", "createdAt": "2020-10-08T01:17:17Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/metrics/metric.py", "diffHunk": "@@ -293,3 +339,49 @@ def with_steps(self, steps):\n \n     self._steps.update(steps)\n     return self\n+\n+\n+class MetricLogger(object):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5Mzk0NA==", "bodyText": "Do you know the behaviour here of your change? Like I said, it looks like you will only be logging the state of a metric in the current MetricContainer. Rather then all of the metrics in separate MetricContainers aggregated together into a single value.\nIs there a guarantee that you will log once for every metric container? (I don;'t think so because of the timing logic)", "url": "https://github.com/apache/beam/pull/13017#discussion_r507893944", "createdAt": "2020-10-19T16:35:31Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/metrics/metric.py", "diffHunk": "@@ -293,3 +339,49 @@ def with_steps(self, steps):\n \n     self._steps.update(steps)\n     return self\n+\n+\n+class MetricLogger(object):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NTgzNQ=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzMTA5Mg==", "bodyText": "MetricLogger stores separate metric values from MetricEnvironment for reporting a single aggregated result to the logger. In this PR, it's used for keeping process-wide API latency histogram values and periodically logging it. So I think changing MetricEnvironment doesn't have any effect here.", "url": "https://github.com/apache/beam/pull/13017#discussion_r508831092", "createdAt": "2020-10-20T20:51:20Z", "author": {"login": "ihji"}, "path": "sdks/python/apache_beam/metrics/metric.py", "diffHunk": "@@ -293,3 +339,49 @@ def with_steps(self, steps):\n \n     self._steps.update(steps)\n     return self\n+\n+\n+class MetricLogger(object):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NTgzNQ=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzOTk3NA==", "bodyText": "Oh okay thanks, this clarifies it", "url": "https://github.com/apache/beam/pull/13017#discussion_r508839974", "createdAt": "2020-10-20T21:07:19Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/metrics/metric.py", "diffHunk": "@@ -293,3 +339,49 @@ def with_steps(self, steps):\n \n     self._steps.update(steps)\n     return self\n+\n+\n+class MetricLogger(object):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NTgzNQ=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTU2NjI4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_tools.py", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwMToxODo1OVrOHeKzBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjoxNzoyMFrOHhnsMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NjIzMQ==", "bodyText": "We should make this clear that this isn't fully supported as a user metric type in the SDK, or in any Runners. We may need to relocate this class from Metrics.histogram to somewhere else i.e. InternalMetrics.histogram\n@pabloem any ideas what we ought to do here? This metric isn't fully implement but the API allows us to log the metric locally.", "url": "https://github.com/apache/beam/pull/13017#discussion_r501396231", "createdAt": "2020-10-08T01:18:59Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_tools.py", "diffHunk": "@@ -271,6 +276,11 @@ def __init__(self, client=None):\n     # randomized prefix for row IDs.\n     self._row_id_prefix = '' if client else uuid.uuid4()\n     self._temporary_table_suffix = uuid.uuid4().hex\n+    self._latency_histogram_metric = Metrics.histogram(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk0NDE2Mw==", "bodyText": "I agree with Alex. We have no plans to support this in any way by runners. It may be much simpler to just create a basic  Histogram metric object that does not integrate with the whole user metrics framework.\nI feel that integrating with the user metrics framework will generate confusion for users and developers looking at it in the future, as it is not intended to be a user metric.\n@ihji can you talk about your motivation to integrate with the user metrics framework?", "url": "https://github.com/apache/beam/pull/13017#discussion_r501944163", "createdAt": "2020-10-08T18:56:03Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_tools.py", "diffHunk": "@@ -271,6 +276,11 @@ def __init__(self, client=None):\n     # randomized prefix for row IDs.\n     self._row_id_prefix = '' if client else uuid.uuid4()\n     self._temporary_table_suffix = uuid.uuid4().hex\n+    self._latency_histogram_metric = Metrics.histogram(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NjIzMQ=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk1NDY0MQ==", "bodyText": "We do plan on building a few system metrics for GCP IO API request call latency which use histograms. Though, it doesn't need to use the user metric framework itself, its a reasonable way to implement it to use a lot of the same techniques.\nI asked @ihji to use the metric framework for the logger, as I will be adding a latency histogram metrics for these BigQuery API request calls. The previous PR has written basically a side framework to count the API call latencies into a histogram and log them. But since I will be introducing a metric anyways, I suggested using this approach. So we wouldn't essentially have two code paths to count the latency values for logging, and for the system metric.", "url": "https://github.com/apache/beam/pull/13017#discussion_r501954641", "createdAt": "2020-10-08T19:14:25Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_tools.py", "diffHunk": "@@ -271,6 +276,11 @@ def __init__(self, client=None):\n     # randomized prefix for row IDs.\n     self._row_id_prefix = '' if client else uuid.uuid4()\n     self._temporary_table_suffix = uuid.uuid4().hex\n+    self._latency_histogram_metric = Metrics.histogram(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NjIzMQ=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI4NDE0MA==", "bodyText": "Pablo and I discussed this. A bit more. @ihji Would you mind please moving the Metrics.histogram() into a \"internal\" folder. We don't want to suggest that users use this yet, if we are only using it for system/internal style metrics/monitoring.", "url": "https://github.com/apache/beam/pull/13017#discussion_r504284140", "createdAt": "2020-10-13T22:02:18Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_tools.py", "diffHunk": "@@ -271,6 +276,11 @@ def __init__(self, client=None):\n     # randomized prefix for row IDs.\n     self._row_id_prefix = '' if client else uuid.uuid4()\n     self._temporary_table_suffix = uuid.uuid4().hex\n+    self._latency_histogram_metric = Metrics.histogram(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NjIzMQ=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAxNTM0Ng==", "bodyText": "done.", "url": "https://github.com/apache/beam/pull/13017#discussion_r505015346", "createdAt": "2020-10-14T22:17:20Z", "author": {"login": "ihji"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_tools.py", "diffHunk": "@@ -271,6 +276,11 @@ def __init__(self, client=None):\n     # randomized prefix for row IDs.\n     self._row_id_prefix = '' if client else uuid.uuid4()\n     self._temporary_table_suffix = uuid.uuid4().hex\n+    self._latency_histogram_metric = Metrics.histogram(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5NjIzMQ=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1ODczMTgyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/metrics/metric.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMjowMTo0NlrOHg7DHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjoxNzowMlrOHhnrPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI4MzkzMw==", "bodyText": "Please move histogram related code into a new 'internal' file\nsdks/python/apache_beam/internal/metrics/metric.py\nPlease move DelegatingHistogram to the new file\nadd a Metric class to the new file, and put the histogram definition there.\nIt can share the infrastructure and call things in this file.", "url": "https://github.com/apache/beam/pull/13017#discussion_r504283933", "createdAt": "2020-10-13T22:01:46Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/metrics/metric.py", "diffHunk": "@@ -139,6 +169,22 @@ def __init__(self, metric_name):\n       super(Metrics.DelegatingGauge, self).__init__(metric_name)\n       self.set = MetricUpdater(cells.GaugeCell, metric_name)  # type: ignore[assignment]\n \n+  class DelegatingHistogram(Histogram):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAxNTEwMQ==", "bodyText": "done.", "url": "https://github.com/apache/beam/pull/13017#discussion_r505015101", "createdAt": "2020-10-14T22:17:02Z", "author": {"login": "ihji"}, "path": "sdks/python/apache_beam/metrics/metric.py", "diffHunk": "@@ -139,6 +169,22 @@ def __init__(self, metric_name):\n       super(Metrics.DelegatingGauge, self).__init__(metric_name)\n       self.set = MetricUpdater(cells.GaugeCell, metric_name)  # type: ignore[assignment]\n \n+  class DelegatingHistogram(Histogram):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI4MzkzMw=="}, "originalCommit": {"oid": "6bc49b12c24ca0f0676860fa4b72ed04d90c87a2"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTQwMTg2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/internal/metrics/cells.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNjozMzoyMVrOHkXTVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMDo1MzoyMVrOHlWXkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5MjU2NQ==", "bodyText": "*modified outside the HistogramCell...", "url": "https://github.com/apache/beam/pull/13017#discussion_r507892565", "createdAt": "2020-10-19T16:33:21Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/internal/metrics/cells.py", "diffHunk": "@@ -0,0 +1,190 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+This file contains internal metric cell classes. A metric cell is used to\n+accumulate in-memory changes to a metric. It represents a specific metric\n+in a single context.\n+\n+For internal use only. No backwards compatibility guarantees.\n+\"\"\"\n+\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+from builtins import object\n+from typing import TYPE_CHECKING\n+from typing import Optional\n+\n+from apache_beam.metrics.cells import MetricAggregator\n+from apache_beam.metrics.cells import MetricCell\n+from apache_beam.metrics.cells import MetricCellFactory\n+from apache_beam.utils.histogram import Histogram\n+\n+if TYPE_CHECKING:\n+  from apache_beam.utils.histogram import BucketType\n+\n+\n+class HistogramCell(MetricCell):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  Tracks the current value and delta for a histogram metric.\n+\n+  Each cell tracks the state of a metric independently per context per bundle.\n+  Therefore, each metric has a different cell in each bundle, that is later\n+  aggregated.\n+\n+  This class is thread safe since underlying histogram object is thread safe.\n+  \"\"\"\n+  def __init__(self, bucket_type):\n+    self._bucket_type = bucket_type\n+    self.data = HistogramAggregator(bucket_type).identity_element()\n+\n+  def reset(self):\n+    self.data = HistogramAggregator(self._bucket_type).identity_element()\n+\n+  def combine(self, other):\n+    # type: (HistogramCell) -> HistogramCell\n+    result = HistogramCell(self._bucket_type)\n+    result.data = self.data.combine(other.data)\n+    return result\n+\n+  def update(self, value):\n+    self.data.histogram.record(value)\n+\n+  def get_cumulative(self):\n+    # type: () -> HistogramData\n+    return self.data.get_cumulative()\n+\n+  def to_runner_api_monitoring_info(self, name, transform_id):\n+    # Histogram metric is currently worker-local and internal\n+    # use only. This method should be implemented when runners\n+    # support Histogram metric reporting.\n+    return None\n+\n+\n+class HistogramCellFactory(MetricCellFactory):\n+  def __init__(self, bucket_type):\n+    self._bucket_type = bucket_type\n+\n+  def __call__(self):\n+    return HistogramCell(self._bucket_type)\n+\n+  def __eq__(self, other):\n+    if not isinstance(other, HistogramCellFactory):\n+      return False\n+    return self._bucket_type == other._bucket_type\n+\n+  def __hash__(self):\n+    return hash(self._bucket_type)\n+\n+\n+class HistogramResult(object):\n+  def __init__(self, data):\n+    # type: (HistogramData) -> None\n+    self.data = data\n+\n+  def __eq__(self, other):\n+    if isinstance(other, HistogramResult):\n+      return self.data == other.data\n+    else:\n+      return False\n+\n+  def __hash__(self):\n+    return hash(self.data)\n+\n+  def __ne__(self, other):\n+    # TODO(BEAM-5949): Needed for Python 2 compatibility.\n+    return not self == other\n+\n+  def __repr__(self):\n+    return '<HistogramResult({})>'.format(\n+        self.data.histogram.get_percentile_info())\n+\n+  @property\n+  def p99(self):\n+    return self.data.histogram.p99()\n+\n+  @property\n+  def p95(self):\n+    return self.data.histogram.p95()\n+\n+  @property\n+  def p90(self):\n+    return self.data.histogram.p90()\n+\n+\n+class HistogramData(object):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  The data structure that holds data about a histogram metric.\n+\n+  This object is not thread safe, so it's not supposed to be modified\n+  by other than the HistogramCell that contains it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2847795bfd534cb3d612551642c63b90677221a"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkyNTg0MA==", "bodyText": "done.", "url": "https://github.com/apache/beam/pull/13017#discussion_r508925840", "createdAt": "2020-10-21T00:53:21Z", "author": {"login": "ihji"}, "path": "sdks/python/apache_beam/internal/metrics/cells.py", "diffHunk": "@@ -0,0 +1,190 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+This file contains internal metric cell classes. A metric cell is used to\n+accumulate in-memory changes to a metric. It represents a specific metric\n+in a single context.\n+\n+For internal use only. No backwards compatibility guarantees.\n+\"\"\"\n+\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+from builtins import object\n+from typing import TYPE_CHECKING\n+from typing import Optional\n+\n+from apache_beam.metrics.cells import MetricAggregator\n+from apache_beam.metrics.cells import MetricCell\n+from apache_beam.metrics.cells import MetricCellFactory\n+from apache_beam.utils.histogram import Histogram\n+\n+if TYPE_CHECKING:\n+  from apache_beam.utils.histogram import BucketType\n+\n+\n+class HistogramCell(MetricCell):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  Tracks the current value and delta for a histogram metric.\n+\n+  Each cell tracks the state of a metric independently per context per bundle.\n+  Therefore, each metric has a different cell in each bundle, that is later\n+  aggregated.\n+\n+  This class is thread safe since underlying histogram object is thread safe.\n+  \"\"\"\n+  def __init__(self, bucket_type):\n+    self._bucket_type = bucket_type\n+    self.data = HistogramAggregator(bucket_type).identity_element()\n+\n+  def reset(self):\n+    self.data = HistogramAggregator(self._bucket_type).identity_element()\n+\n+  def combine(self, other):\n+    # type: (HistogramCell) -> HistogramCell\n+    result = HistogramCell(self._bucket_type)\n+    result.data = self.data.combine(other.data)\n+    return result\n+\n+  def update(self, value):\n+    self.data.histogram.record(value)\n+\n+  def get_cumulative(self):\n+    # type: () -> HistogramData\n+    return self.data.get_cumulative()\n+\n+  def to_runner_api_monitoring_info(self, name, transform_id):\n+    # Histogram metric is currently worker-local and internal\n+    # use only. This method should be implemented when runners\n+    # support Histogram metric reporting.\n+    return None\n+\n+\n+class HistogramCellFactory(MetricCellFactory):\n+  def __init__(self, bucket_type):\n+    self._bucket_type = bucket_type\n+\n+  def __call__(self):\n+    return HistogramCell(self._bucket_type)\n+\n+  def __eq__(self, other):\n+    if not isinstance(other, HistogramCellFactory):\n+      return False\n+    return self._bucket_type == other._bucket_type\n+\n+  def __hash__(self):\n+    return hash(self._bucket_type)\n+\n+\n+class HistogramResult(object):\n+  def __init__(self, data):\n+    # type: (HistogramData) -> None\n+    self.data = data\n+\n+  def __eq__(self, other):\n+    if isinstance(other, HistogramResult):\n+      return self.data == other.data\n+    else:\n+      return False\n+\n+  def __hash__(self):\n+    return hash(self.data)\n+\n+  def __ne__(self, other):\n+    # TODO(BEAM-5949): Needed for Python 2 compatibility.\n+    return not self == other\n+\n+  def __repr__(self):\n+    return '<HistogramResult({})>'.format(\n+        self.data.histogram.get_percentile_info())\n+\n+  @property\n+  def p99(self):\n+    return self.data.histogram.p99()\n+\n+  @property\n+  def p95(self):\n+    return self.data.histogram.p95()\n+\n+  @property\n+  def p90(self):\n+    return self.data.histogram.p90()\n+\n+\n+class HistogramData(object):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  The data structure that holds data about a histogram metric.\n+\n+  This object is not thread safe, so it's not supposed to be modified\n+  by other than the HistogramCell that contains it.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5MjU2NQ=="}, "originalCommit": {"oid": "d2847795bfd534cb3d612551642c63b90677221a"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzQ0NDYwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/internal/metrics/metric.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToxMDowMFrOHlRNzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjo1MToyN1rOHlT8jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MTQyMg==", "bodyText": "So justt o confirm, every time the metric is updated, regardless of which environment is set. Thee same cell will be obtained and updated here. Which aggregates everything in the process together.", "url": "https://github.com/apache/beam/pull/13017#discussion_r508841422", "createdAt": "2020-10-20T21:10:00Z", "author": {"login": "ajamato"}, "path": "sdks/python/apache_beam/internal/metrics/metric.py", "diffHunk": "@@ -0,0 +1,138 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Metrics API classes for internal use only.\n+\n+Users should use apache_beam.metrics.metric package instead.\n+\n+For internal use only. No backwards compatibility guarantees.\n+\"\"\"\n+# pytype: skip-file\n+# mypy: disallow-untyped-defs\n+\n+from __future__ import absolute_import\n+\n+import datetime\n+import logging\n+import threading\n+import time\n+from builtins import object\n+from typing import TYPE_CHECKING\n+from typing import Dict\n+from typing import Optional\n+from typing import Type\n+from typing import Union\n+\n+from apache_beam.internal.metrics.cells import HistogramCellFactory\n+from apache_beam.metrics.execution import MetricUpdater\n+from apache_beam.metrics.metric import Metrics as UserMetrics\n+from apache_beam.metrics.metricbase import Histogram\n+from apache_beam.metrics.metricbase import MetricName\n+\n+if TYPE_CHECKING:\n+  from apache_beam.metrics.cells import MetricCell\n+  from apache_beam.metrics.cells import MetricCellFactory\n+  from apache_beam.utils.histogram import BucketType\n+\n+__all__ = ['Metrics']\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+class Metrics(object):\n+  @staticmethod\n+  def histogram(namespace, name, bucket_type, logger=None):\n+    # type: (Union[Type, str], str, BucketType, Optional[MetricLogger]) -> Metrics.DelegatingHistogram\n+\n+    \"\"\"Obtains or creates a Histogram metric.\n+\n+    Args:\n+      namespace: A class or string that gives the namespace to a metric\n+      name: A string that gives a unique name to a metric\n+      bucket_type: A type of bucket used in a histogram. A subclass of\n+        apache_beam.utils.histogram.BucketType\n+      logger: MetricLogger for logging locally aggregated metric\n+\n+    Returns:\n+      A Histogram object.\n+    \"\"\"\n+    namespace = UserMetrics.get_namespace(namespace)\n+    return Metrics.DelegatingHistogram(\n+        MetricName(namespace, name), bucket_type, logger)\n+\n+  class DelegatingHistogram(Histogram):\n+    \"\"\"Metrics Histogram that Delegates functionality to MetricsEnvironment.\"\"\"\n+    def __init__(self, metric_name, bucket_type, logger):\n+      # type: (MetricName, BucketType, Optional[MetricLogger]) -> None\n+      super(Metrics.DelegatingHistogram, self).__init__(metric_name)\n+      self.metric_name = metric_name\n+      self.cell_type = HistogramCellFactory(bucket_type)\n+      self.logger = logger\n+      self.updater = MetricUpdater(self.cell_type, self.metric_name)\n+\n+    def update(self, value):\n+      # type: (object) -> None\n+      self.updater(value)\n+      if self.logger:\n+        self.logger.update(self.cell_type, self.metric_name, value)\n+\n+\n+class MetricLogger(object):\n+  \"\"\"Simple object to locally aggregate and log metrics.\n+\n+  This class is experimental. No backwards-compatibility guarantees.\n+  \"\"\"\n+  def __init__(self):\n+    # type: () -> None\n+    self._metric = dict()  # type: Dict[MetricName, MetricCell]\n+    self._lock = threading.Lock()\n+    self._last_logging_millis = int(time.time() * 1000)\n+    self.minimum_logging_frequency_msec = 180000\n+\n+  def update(self, cell_type, metric_name, value):\n+    # type: (Union[Type[MetricCell], MetricCellFactory], MetricName, object) -> None\n+    cell = self._get_metric_cell(cell_type, metric_name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2847795bfd534cb3d612551642c63b90677221a"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg4NjE1Nw==", "bodyText": "True. The reason was for streaming pipelines the bundle size is too small so that per bundle metrics are not really helpful especially for statistics like histogram percentiles. MetricLogger could be considered as a process-wide shared metric container.", "url": "https://github.com/apache/beam/pull/13017#discussion_r508886157", "createdAt": "2020-10-20T22:51:27Z", "author": {"login": "ihji"}, "path": "sdks/python/apache_beam/internal/metrics/metric.py", "diffHunk": "@@ -0,0 +1,138 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Metrics API classes for internal use only.\n+\n+Users should use apache_beam.metrics.metric package instead.\n+\n+For internal use only. No backwards compatibility guarantees.\n+\"\"\"\n+# pytype: skip-file\n+# mypy: disallow-untyped-defs\n+\n+from __future__ import absolute_import\n+\n+import datetime\n+import logging\n+import threading\n+import time\n+from builtins import object\n+from typing import TYPE_CHECKING\n+from typing import Dict\n+from typing import Optional\n+from typing import Type\n+from typing import Union\n+\n+from apache_beam.internal.metrics.cells import HistogramCellFactory\n+from apache_beam.metrics.execution import MetricUpdater\n+from apache_beam.metrics.metric import Metrics as UserMetrics\n+from apache_beam.metrics.metricbase import Histogram\n+from apache_beam.metrics.metricbase import MetricName\n+\n+if TYPE_CHECKING:\n+  from apache_beam.metrics.cells import MetricCell\n+  from apache_beam.metrics.cells import MetricCellFactory\n+  from apache_beam.utils.histogram import BucketType\n+\n+__all__ = ['Metrics']\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+class Metrics(object):\n+  @staticmethod\n+  def histogram(namespace, name, bucket_type, logger=None):\n+    # type: (Union[Type, str], str, BucketType, Optional[MetricLogger]) -> Metrics.DelegatingHistogram\n+\n+    \"\"\"Obtains or creates a Histogram metric.\n+\n+    Args:\n+      namespace: A class or string that gives the namespace to a metric\n+      name: A string that gives a unique name to a metric\n+      bucket_type: A type of bucket used in a histogram. A subclass of\n+        apache_beam.utils.histogram.BucketType\n+      logger: MetricLogger for logging locally aggregated metric\n+\n+    Returns:\n+      A Histogram object.\n+    \"\"\"\n+    namespace = UserMetrics.get_namespace(namespace)\n+    return Metrics.DelegatingHistogram(\n+        MetricName(namespace, name), bucket_type, logger)\n+\n+  class DelegatingHistogram(Histogram):\n+    \"\"\"Metrics Histogram that Delegates functionality to MetricsEnvironment.\"\"\"\n+    def __init__(self, metric_name, bucket_type, logger):\n+      # type: (MetricName, BucketType, Optional[MetricLogger]) -> None\n+      super(Metrics.DelegatingHistogram, self).__init__(metric_name)\n+      self.metric_name = metric_name\n+      self.cell_type = HistogramCellFactory(bucket_type)\n+      self.logger = logger\n+      self.updater = MetricUpdater(self.cell_type, self.metric_name)\n+\n+    def update(self, value):\n+      # type: (object) -> None\n+      self.updater(value)\n+      if self.logger:\n+        self.logger.update(self.cell_type, self.metric_name, value)\n+\n+\n+class MetricLogger(object):\n+  \"\"\"Simple object to locally aggregate and log metrics.\n+\n+  This class is experimental. No backwards-compatibility guarantees.\n+  \"\"\"\n+  def __init__(self):\n+    # type: () -> None\n+    self._metric = dict()  # type: Dict[MetricName, MetricCell]\n+    self._lock = threading.Lock()\n+    self._last_logging_millis = int(time.time() * 1000)\n+    self.minimum_logging_frequency_msec = 180000\n+\n+  def update(self, cell_type, metric_name, value):\n+    # type: (Union[Type[MetricCell], MetricCellFactory], MetricName, object) -> None\n+    cell = self._get_metric_cell(cell_type, metric_name)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MTQyMg=="}, "originalCommit": {"oid": "d2847795bfd534cb3d612551642c63b90677221a"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3120, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}