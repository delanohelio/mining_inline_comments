{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MDk2NDc2", "number": 13154, "title": "Implementing Python Bounded Source Reader DoFn", "bodyText": "This is valuable for BigQuery repeatedly firing side input. This PR is intended to be used here: #13170\nThis makes the SDF Bounded Source reader available to use. A small change in functionality:\n\nIf no source is provided to the initial restriction in the constructor, then the element is expected to be a source, and it's added to the initial restriction at creation.\n\nr: @boyuanzz\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\nTypescript\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-10-20T21:06:35Z", "url": "https://github.com/apache/beam/pull/13154", "merged": true, "mergeCommit": {"oid": "c3cf90443ccf1c78cea4084061cb3274ca9f5956"}, "closed": true, "closedAt": "2020-11-03T23:28:18Z", "author": {"login": "pabloem"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUf_ksgH2gAyNTA3MDk2NDc2OjBhYjhlYTI1YTliY2EyMjdjNGEyMzEyYzJjMDUwNjNiN2FiM2E5ZjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZAYpoAH2gAyNTA3MDk2NDc2OjA1MGNkNGM0YWM3ZDViYWI0OWI1YTA0MWY5MjRlZDNmODY4NjRiNmQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0ab8ea25a9bca227c4a2312c2c05063b7ab3a9f5", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/0ab8ea25a9bca227c4a2312c2c05063b7ab3a9f5", "committedDate": "2020-10-20T21:52:13Z", "message": "Implementing Python Bounded Source Reader DoFn"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a8a5b08a0456130dd050c7ff9b98af443aee6d9f", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/a8a5b08a0456130dd050c7ff9b98af443aee6d9f", "committedDate": "2020-10-20T21:15:44Z", "message": "fix lint"}, "afterCommit": {"oid": "0ab8ea25a9bca227c4a2312c2c05063b7ab3a9f5", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/0ab8ea25a9bca227c4a2312c2c05063b7ab3a9f5", "committedDate": "2020-10-20T21:52:13Z", "message": "Implementing Python Bounded Source Reader DoFn"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c82f2d14dab6b28a00d60a00fe59d102b45b7dc4", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/c82f2d14dab6b28a00d60a00fe59d102b45b7dc4", "committedDate": "2020-10-22T20:17:02Z", "message": "Adding annotations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjQ2ODQ2", "url": "https://github.com/apache/beam/pull/13154#pullrequestreview-518246846", "createdAt": "2020-10-28T00:36:51Z", "commit": {"oid": "c82f2d14dab6b28a00d60a00fe59d102b45b7dc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDozNjo1MVrOHpV4DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDozNjo1MVrOHpV4DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjA3Ng==", "bodyText": "It seems like the major difference between SDFBoundedSourceWrapper  and SDFBoundedSourceReader  is that SDFBoundedSourceWrapper takes the source as construction param where SDFBoundedSourceReader takes the source as input element. We could change the implementation of SDFBoundedSourceWrapper as well.", "url": "https://github.com/apache/beam/pull/13154#discussion_r513112076", "createdAt": "2020-10-28T00:36:51Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1618,3 +1628,48 @@ def display_data(self):\n         'source': DisplayDataItem(self.source.__class__, label='Read Source'),\n         'source_dd': self.source\n     }\n+\n+\n+class SDFBoundedSourceReader(PTransform):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c82f2d14dab6b28a00d60a00fe59d102b45b7dc4"}, "originalPosition": 321}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7297e0a8e0e3f873afe490f83ec0e0eb3aba3ddf", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/7297e0a8e0e3f873afe490f83ec0e0eb3aba3ddf", "committedDate": "2020-10-28T18:26:24Z", "message": "Wrapping BoundedSource out of a single implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MDgyMDE3", "url": "https://github.com/apache/beam/pull/13154#pullrequestreview-519082017", "createdAt": "2020-10-28T21:03:47Z", "commit": {"oid": "7297e0a8e0e3f873afe490f83ec0e0eb3aba3ddf"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMTowMzo0OFrOHp9WVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMToxNTowNFrOHp9vfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc1ODgwNg==", "bodyText": "I see. I thought we still keep _SDFBoundedSourceWrapper . Thanks for the clarification!", "url": "https://github.com/apache/beam/pull/13154#discussion_r513758806", "createdAt": "2020-10-28T21:03:48Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1618,3 +1628,48 @@ def display_data(self):\n         'source': DisplayDataItem(self.source.__class__, label='Read Source'),\n         'source_dd': self.source\n     }\n+\n+\n+class SDFBoundedSourceReader(PTransform):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjA3Ng=="}, "originalCommit": {"oid": "c82f2d14dab6b28a00d60a00fe59d102b45b7dc4"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc1OTE5NQ==", "bodyText": "We should be able to remote source here?", "url": "https://github.com/apache/beam/pull/13154#discussion_r513759195", "createdAt": "2020-10-28T21:04:23Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1427,185 +1429,189 @@ def with_completed(self, completed):\n         fraction=self._fraction, remaining=self._remaining, completed=completed)\n \n \n-class _SDFBoundedSourceWrapper(ptransform.PTransform):\n-  \"\"\"A ``PTransform`` that uses SDF to read from a ``BoundedSource``.\n+class _SDFBoundedSourceRestriction(object):\n+  \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n+  def __init__(self, source_bundle, range_tracker=None):\n+    self._source_bundle = source_bundle\n+    self._range_tracker = range_tracker\n \n-  NOTE: This transform can only be used with beam_fn_api enabled.\n+  def __reduce__(self):\n+    # The instance of RangeTracker shouldn't be serialized.\n+    return (self.__class__, (self._source_bundle, ))\n+\n+  def range_tracker(self):\n+    if not self._range_tracker:\n+      self._range_tracker = self._source_bundle.source.get_range_tracker(\n+          self._source_bundle.start_position, self._source_bundle.stop_position)\n+    return self._range_tracker\n+\n+  def weight(self):\n+    return self._source_bundle.weight\n+\n+  def source(self):\n+    return self._source_bundle.source\n+\n+  def try_split(self, fraction_of_remainder):\n+    consumed_fraction = self.range_tracker().fraction_consumed()\n+    fraction = (\n+        consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n+    position = self.range_tracker().position_at_fraction(fraction)\n+    # Need to stash current stop_pos before splitting since\n+    # range_tracker.split will update its stop_pos if splits\n+    # successfully.\n+    stop_pos = self._source_bundle.stop_position\n+    split_result = self.range_tracker().try_split(position)\n+    if split_result:\n+      split_pos, split_fraction = split_result\n+      primary_weight = self._source_bundle.weight * split_fraction\n+      residual_weight = self._source_bundle.weight - primary_weight\n+      # Update self to primary weight and end position.\n+      self._source_bundle = SourceBundle(\n+          primary_weight,\n+          self._source_bundle.source,\n+          self._source_bundle.start_position,\n+          split_pos)\n+      return (\n+          self,\n+          _SDFBoundedSourceRestriction(\n+              SourceBundle(\n+                  residual_weight,\n+                  self._source_bundle.source,\n+                  split_pos,\n+                  stop_pos)))\n+\n+\n+class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n+  \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n+  with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n+  wraps SourceBundle and RangeTracker.\n+\n+  Delegated RangeTracker guarantees synchronization safety.\n   \"\"\"\n-  class _SDFBoundedSourceRestriction(object):\n-    \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n-    def __init__(self, source_bundle, range_tracker=None):\n-      self._source_bundle = source_bundle\n-      self._range_tracker = range_tracker\n-\n-    def __reduce__(self):\n-      # The instance of RangeTracker shouldn't be serialized.\n-      return (self.__class__, (self._source_bundle, ))\n-\n-    def range_tracker(self):\n-      if not self._range_tracker:\n-        self._range_tracker = self._source_bundle.source.get_range_tracker(\n-            self._source_bundle.start_position,\n-            self._source_bundle.stop_position)\n-      return self._range_tracker\n-\n-    def weight(self):\n-      return self._source_bundle.weight\n-\n-    def source(self):\n-      return self._source_bundle.source\n-\n-    def try_split(self, fraction_of_remainder):\n-      consumed_fraction = self.range_tracker().fraction_consumed()\n-      fraction = (\n-          consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n-      position = self.range_tracker().position_at_fraction(fraction)\n-      # Need to stash current stop_pos before splitting since\n-      # range_tracker.split will update its stop_pos if splits\n-      # successfully.\n-      stop_pos = self._source_bundle.stop_position\n-      split_result = self.range_tracker().try_split(position)\n-      if split_result:\n-        split_pos, split_fraction = split_result\n-        primary_weight = self._source_bundle.weight * split_fraction\n-        residual_weight = self._source_bundle.weight - primary_weight\n-        # Update self to primary weight and end position.\n-        self._source_bundle = SourceBundle(\n-            primary_weight,\n-            self._source_bundle.source,\n-            self._source_bundle.start_position,\n-            split_pos)\n-        return (\n-            self,\n-            _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-                SourceBundle(\n-                    residual_weight,\n-                    self._source_bundle.source,\n-                    split_pos,\n-                    stop_pos)))\n-\n-  class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n-    \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n-    with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n-    wraps SourceBundle and RangeTracker.\n-\n-    Delegated RangeTracker guarantees synchronization safety.\n-    \"\"\"\n-    def __init__(self, restriction):\n-      if not isinstance(restriction,\n-                        _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction):\n-        raise ValueError(\n-            'Initializing SDFBoundedSourceRestrictionTracker'\n-            ' requires a _SDFBoundedSourceRestriction')\n-      self.restriction = restriction\n-\n-    def current_progress(self):\n-      # type: () -> RestrictionProgress\n-      return RestrictionProgress(\n-          fraction=self.restriction.range_tracker().fraction_consumed())\n-\n-    def current_restriction(self):\n-      self.restriction.range_tracker()\n-      return self.restriction\n-\n-    def start_pos(self):\n-      return self.restriction.range_tracker().start_position()\n-\n-    def stop_pos(self):\n-      return self.restriction.range_tracker().stop_position()\n-\n-    def try_claim(self, position):\n-      return self.restriction.range_tracker().try_claim(position)\n-\n-    def try_split(self, fraction_of_remainder):\n-      return self.restriction.try_split(fraction_of_remainder)\n-\n-    def check_done(self):\n-      return self.restriction.range_tracker().fraction_consumed() >= 1.0\n-\n-    def is_bounded(self):\n-      return True\n-\n-  class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n-    \"\"\"A `RestrictionProvider` that is used by SDF for `BoundedSource`.\"\"\"\n-    def __init__(self, source, desired_chunk_size=None):\n-      self._source = source\n-      self._desired_chunk_size = desired_chunk_size\n-\n-    def initial_restriction(self, element):\n-      # Get initial range_tracker from source\n-      range_tracker = self._source.get_range_tracker(None, None)\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-          SourceBundle(\n-              None,\n-              self._source,\n-              range_tracker.start_position(),\n-              range_tracker.stop_position()))\n-\n-    def create_tracker(self, restriction):\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestrictionTracker(\n-          restriction)\n-\n-    def split(self, element, restriction):\n-      if self._desired_chunk_size is None:\n-        try:\n-          estimated_size = self._source.estimate_size()\n-        except NotImplementedError:\n-          estimated_size = None\n-        self._desired_chunk_size = Read.get_desired_chunk_size(estimated_size)\n-\n-      # Invoke source.split to get initial splitting results.\n-      source_bundles = self._source.split(self._desired_chunk_size)\n-      for source_bundle in source_bundles:\n-        yield _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-            source_bundle)\n-\n-    def restriction_size(self, element, restriction):\n-      return restriction.weight()\n-\n-    def restriction_coder(self):\n-      return coders.DillCoder()\n+  def __init__(self, restriction):\n+    if not isinstance(restriction, _SDFBoundedSourceRestriction):\n+      raise ValueError(\n+          'Initializing SDFBoundedSourceRestrictionTracker'\n+          ' requires a _SDFBoundedSourceRestriction')\n+    self.restriction = restriction\n \n-  def __init__(self, source):\n-    if not isinstance(source, BoundedSource):\n-      raise RuntimeError('SDFBoundedSourceWrapper can only wrap BoundedSource')\n-    super(_SDFBoundedSourceWrapper, self).__init__()\n+  def current_progress(self):\n+    # type: () -> RestrictionProgress\n+    return RestrictionProgress(\n+        fraction=self.restriction.range_tracker().fraction_consumed())\n+\n+  def current_restriction(self):\n+    self.restriction.range_tracker()\n+    return self.restriction\n+\n+  def start_pos(self):\n+    return self.restriction.range_tracker().start_position()\n+\n+  def stop_pos(self):\n+    return self.restriction.range_tracker().stop_position()\n+\n+  def try_claim(self, position):\n+    return self.restriction.range_tracker().try_claim(position)\n+\n+  def try_split(self, fraction_of_remainder):\n+    return self.restriction.try_split(fraction_of_remainder)\n+\n+  def check_done(self):\n+    return self.restriction.range_tracker().fraction_consumed() >= 1.0\n+\n+  def is_bounded(self):\n+    return True\n+\n+\n+class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n+  \"\"\"\n+  A `RestrictionProvider` that is used by SDF for `BoundedSource`.\n+\n+  If source is provided, uses it for initializing restriction. Otherwise\n+  initializes restriction based on input element that is expected to be of\n+  BoundedSource type.\n+  \"\"\"\n+  def __init__(self, source: BoundedSource = None, desired_chunk_size=None):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7297e0a8e0e3f873afe490f83ec0e0eb3aba3ddf"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc2NTI0Nw==", "bodyText": "I'm thinking whether it would be better for SDFBoundedSourceReader  to take data_to_display as constructor instead of source directly if any. What do you think?", "url": "https://github.com/apache/beam/pull/13154#discussion_r513765247", "createdAt": "2020-10-28T21:15:04Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1618,3 +1628,48 @@ def display_data(self):\n         'source': DisplayDataItem(self.source.__class__, label='Read Source'),\n         'source_dd': self.source\n     }\n+\n+\n+class SDFBoundedSourceReader(PTransform):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjA3Ng=="}, "originalCommit": {"oid": "c82f2d14dab6b28a00d60a00fe59d102b45b7dc4"}, "originalPosition": 321}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db7aafd23a307a3824c9bfd8a0d60363a6aca3bd", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/db7aafd23a307a3824c9bfd8a0d60363a6aca3bd", "committedDate": "2020-10-29T00:48:50Z", "message": "Fixup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0a15099de62d1b7a9b08a8378f816e624b816ac", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/d0a15099de62d1b7a9b08a8378f816e624b816ac", "committedDate": "2020-10-29T03:37:21Z", "message": "Fix formatter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5OTE4Njk1", "url": "https://github.com/apache/beam/pull/13154#pullrequestreview-519918695", "createdAt": "2020-10-29T17:39:28Z", "commit": {"oid": "d0a15099de62d1b7a9b08a8378f816e624b816ac"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzozOToyOFrOHqnUQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzo1NjoxMFrOHqn_LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0NjQwMA==", "bodyText": "It seems like we also need to update pydoc here as well.", "url": "https://github.com/apache/beam/pull/13154#discussion_r514446400", "createdAt": "2020-10-29T17:39:28Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1427,194 +1432,184 @@ def with_completed(self, completed):\n         fraction=self._fraction, remaining=self._remaining, completed=completed)\n \n \n-class _SDFBoundedSourceWrapper(ptransform.PTransform):\n-  \"\"\"A ``PTransform`` that uses SDF to read from a ``BoundedSource``.\n+class _SDFBoundedSourceRestriction(object):\n+  \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n+  def __init__(self, source_bundle, range_tracker=None):\n+    self._source_bundle = source_bundle\n+    self._range_tracker = range_tracker\n \n-  NOTE: This transform can only be used with beam_fn_api enabled.\n+  def __reduce__(self):\n+    # The instance of RangeTracker shouldn't be serialized.\n+    return (self.__class__, (self._source_bundle, ))\n+\n+  def range_tracker(self):\n+    if not self._range_tracker:\n+      self._range_tracker = self._source_bundle.source.get_range_tracker(\n+          self._source_bundle.start_position, self._source_bundle.stop_position)\n+    return self._range_tracker\n+\n+  def weight(self):\n+    return self._source_bundle.weight\n+\n+  def source(self):\n+    return self._source_bundle.source\n+\n+  def try_split(self, fraction_of_remainder):\n+    consumed_fraction = self.range_tracker().fraction_consumed()\n+    fraction = (\n+        consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n+    position = self.range_tracker().position_at_fraction(fraction)\n+    # Need to stash current stop_pos before splitting since\n+    # range_tracker.split will update its stop_pos if splits\n+    # successfully.\n+    stop_pos = self._source_bundle.stop_position\n+    split_result = self.range_tracker().try_split(position)\n+    if split_result:\n+      split_pos, split_fraction = split_result\n+      primary_weight = self._source_bundle.weight * split_fraction\n+      residual_weight = self._source_bundle.weight - primary_weight\n+      # Update self to primary weight and end position.\n+      self._source_bundle = SourceBundle(\n+          primary_weight,\n+          self._source_bundle.source,\n+          self._source_bundle.start_position,\n+          split_pos)\n+      return (\n+          self,\n+          _SDFBoundedSourceRestriction(\n+              SourceBundle(\n+                  residual_weight,\n+                  self._source_bundle.source,\n+                  split_pos,\n+                  stop_pos)))\n+\n+\n+class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n+  \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n+  with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n+  wraps SourceBundle and RangeTracker.\n+\n+  Delegated RangeTracker guarantees synchronization safety.\n   \"\"\"\n-  class _SDFBoundedSourceRestriction(object):\n-    \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n-    def __init__(self, source_bundle, range_tracker=None):\n-      self._source_bundle = source_bundle\n-      self._range_tracker = range_tracker\n-\n-    def __reduce__(self):\n-      # The instance of RangeTracker shouldn't be serialized.\n-      return (self.__class__, (self._source_bundle, ))\n-\n-    def range_tracker(self):\n-      if not self._range_tracker:\n-        self._range_tracker = self._source_bundle.source.get_range_tracker(\n-            self._source_bundle.start_position,\n-            self._source_bundle.stop_position)\n-      return self._range_tracker\n-\n-    def weight(self):\n-      return self._source_bundle.weight\n-\n-    def source(self):\n-      return self._source_bundle.source\n-\n-    def try_split(self, fraction_of_remainder):\n-      consumed_fraction = self.range_tracker().fraction_consumed()\n-      fraction = (\n-          consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n-      position = self.range_tracker().position_at_fraction(fraction)\n-      # Need to stash current stop_pos before splitting since\n-      # range_tracker.split will update its stop_pos if splits\n-      # successfully.\n-      stop_pos = self._source_bundle.stop_position\n-      split_result = self.range_tracker().try_split(position)\n-      if split_result:\n-        split_pos, split_fraction = split_result\n-        primary_weight = self._source_bundle.weight * split_fraction\n-        residual_weight = self._source_bundle.weight - primary_weight\n-        # Update self to primary weight and end position.\n-        self._source_bundle = SourceBundle(\n-            primary_weight,\n-            self._source_bundle.source,\n-            self._source_bundle.start_position,\n-            split_pos)\n-        return (\n-            self,\n-            _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-                SourceBundle(\n-                    residual_weight,\n-                    self._source_bundle.source,\n-                    split_pos,\n-                    stop_pos)))\n-\n-  class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n-    \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n-    with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n-    wraps SourceBundle and RangeTracker.\n-\n-    Delegated RangeTracker guarantees synchronization safety.\n-    \"\"\"\n-    def __init__(self, restriction):\n-      if not isinstance(restriction,\n-                        _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction):\n-        raise ValueError(\n-            'Initializing SDFBoundedSourceRestrictionTracker'\n-            ' requires a _SDFBoundedSourceRestriction')\n-      self.restriction = restriction\n-\n-    def current_progress(self):\n-      # type: () -> RestrictionProgress\n-      return RestrictionProgress(\n-          fraction=self.restriction.range_tracker().fraction_consumed())\n-\n-    def current_restriction(self):\n-      self.restriction.range_tracker()\n-      return self.restriction\n-\n-    def start_pos(self):\n-      return self.restriction.range_tracker().start_position()\n-\n-    def stop_pos(self):\n-      return self.restriction.range_tracker().stop_position()\n-\n-    def try_claim(self, position):\n-      return self.restriction.range_tracker().try_claim(position)\n-\n-    def try_split(self, fraction_of_remainder):\n-      return self.restriction.try_split(fraction_of_remainder)\n-\n-    def check_done(self):\n-      return self.restriction.range_tracker().fraction_consumed() >= 1.0\n-\n-    def is_bounded(self):\n-      return True\n-\n-  class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n-    \"\"\"A `RestrictionProvider` that is used by SDF for `BoundedSource`.\"\"\"\n-    def __init__(self, source, desired_chunk_size=None):\n-      self._source = source\n-      self._desired_chunk_size = desired_chunk_size\n-\n-    def initial_restriction(self, element):\n-      # Get initial range_tracker from source\n-      range_tracker = self._source.get_range_tracker(None, None)\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-          SourceBundle(\n-              None,\n-              self._source,\n-              range_tracker.start_position(),\n-              range_tracker.stop_position()))\n-\n-    def create_tracker(self, restriction):\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestrictionTracker(\n-          restriction)\n-\n-    def split(self, element, restriction):\n-      if self._desired_chunk_size is None:\n-        try:\n-          estimated_size = self._source.estimate_size()\n-        except NotImplementedError:\n-          estimated_size = None\n-        self._desired_chunk_size = Read.get_desired_chunk_size(estimated_size)\n-\n-      # Invoke source.split to get initial splitting results.\n-      source_bundles = self._source.split(self._desired_chunk_size)\n-      for source_bundle in source_bundles:\n-        yield _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-            source_bundle)\n-\n-    def restriction_size(self, element, restriction):\n-      return restriction.weight()\n-\n-    def restriction_coder(self):\n-      return coders.DillCoder()\n+  def __init__(self, restriction):\n+    if not isinstance(restriction, _SDFBoundedSourceRestriction):\n+      raise ValueError(\n+          'Initializing SDFBoundedSourceRestrictionTracker'\n+          ' requires a _SDFBoundedSourceRestriction')\n+    self.restriction = restriction\n \n-  def __init__(self, source):\n-    if not isinstance(source, BoundedSource):\n-      raise RuntimeError('SDFBoundedSourceWrapper can only wrap BoundedSource')\n-    super(_SDFBoundedSourceWrapper, self).__init__()\n-    self.source = source\n+  def current_progress(self):\n+    # type: () -> RestrictionProgress\n+    return RestrictionProgress(\n+        fraction=self.restriction.range_tracker().fraction_consumed())\n \n-  def _create_sdf_bounded_source_dofn(self):\n-    source = self.source\n+  def current_restriction(self):\n+    self.restriction.range_tracker()\n+    return self.restriction\n \n-    class SDFBoundedSourceDoFn(core.DoFn):\n-      def __init__(self, read_source):\n-        self.source = read_source\n+  def start_pos(self):\n+    return self.restriction.range_tracker().start_position()\n+\n+  def stop_pos(self):\n+    return self.restriction.range_tracker().stop_position()\n+\n+  def try_claim(self, position):\n+    return self.restriction.range_tracker().try_claim(position)\n \n-      def display_data(self):\n-        return {\n-            'source': DisplayDataItem(\n-                self.source.__class__, label='Read Source'),\n-            'source_dd': self.source\n-        }\n+  def try_split(self, fraction_of_remainder):\n+    return self.restriction.try_split(fraction_of_remainder)\n+\n+  def check_done(self):\n+    return self.restriction.range_tracker().fraction_consumed() >= 1.0\n+\n+  def is_bounded(self):\n+    return True\n+\n+\n+class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n+  \"\"\"\n+  A `RestrictionProvider` that is used by SDF for `BoundedSource`.\n+\n+  If source is provided, uses it for initializing restriction. Otherwise", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0a15099de62d1b7a9b08a8378f816e624b816ac"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NzM4OQ==", "bodyText": "The src cannot be None, right?", "url": "https://github.com/apache/beam/pull/13154#discussion_r514457389", "createdAt": "2020-10-29T17:56:10Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1427,194 +1432,184 @@ def with_completed(self, completed):\n         fraction=self._fraction, remaining=self._remaining, completed=completed)\n \n \n-class _SDFBoundedSourceWrapper(ptransform.PTransform):\n-  \"\"\"A ``PTransform`` that uses SDF to read from a ``BoundedSource``.\n+class _SDFBoundedSourceRestriction(object):\n+  \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n+  def __init__(self, source_bundle, range_tracker=None):\n+    self._source_bundle = source_bundle\n+    self._range_tracker = range_tracker\n \n-  NOTE: This transform can only be used with beam_fn_api enabled.\n+  def __reduce__(self):\n+    # The instance of RangeTracker shouldn't be serialized.\n+    return (self.__class__, (self._source_bundle, ))\n+\n+  def range_tracker(self):\n+    if not self._range_tracker:\n+      self._range_tracker = self._source_bundle.source.get_range_tracker(\n+          self._source_bundle.start_position, self._source_bundle.stop_position)\n+    return self._range_tracker\n+\n+  def weight(self):\n+    return self._source_bundle.weight\n+\n+  def source(self):\n+    return self._source_bundle.source\n+\n+  def try_split(self, fraction_of_remainder):\n+    consumed_fraction = self.range_tracker().fraction_consumed()\n+    fraction = (\n+        consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n+    position = self.range_tracker().position_at_fraction(fraction)\n+    # Need to stash current stop_pos before splitting since\n+    # range_tracker.split will update its stop_pos if splits\n+    # successfully.\n+    stop_pos = self._source_bundle.stop_position\n+    split_result = self.range_tracker().try_split(position)\n+    if split_result:\n+      split_pos, split_fraction = split_result\n+      primary_weight = self._source_bundle.weight * split_fraction\n+      residual_weight = self._source_bundle.weight - primary_weight\n+      # Update self to primary weight and end position.\n+      self._source_bundle = SourceBundle(\n+          primary_weight,\n+          self._source_bundle.source,\n+          self._source_bundle.start_position,\n+          split_pos)\n+      return (\n+          self,\n+          _SDFBoundedSourceRestriction(\n+              SourceBundle(\n+                  residual_weight,\n+                  self._source_bundle.source,\n+                  split_pos,\n+                  stop_pos)))\n+\n+\n+class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n+  \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n+  with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n+  wraps SourceBundle and RangeTracker.\n+\n+  Delegated RangeTracker guarantees synchronization safety.\n   \"\"\"\n-  class _SDFBoundedSourceRestriction(object):\n-    \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n-    def __init__(self, source_bundle, range_tracker=None):\n-      self._source_bundle = source_bundle\n-      self._range_tracker = range_tracker\n-\n-    def __reduce__(self):\n-      # The instance of RangeTracker shouldn't be serialized.\n-      return (self.__class__, (self._source_bundle, ))\n-\n-    def range_tracker(self):\n-      if not self._range_tracker:\n-        self._range_tracker = self._source_bundle.source.get_range_tracker(\n-            self._source_bundle.start_position,\n-            self._source_bundle.stop_position)\n-      return self._range_tracker\n-\n-    def weight(self):\n-      return self._source_bundle.weight\n-\n-    def source(self):\n-      return self._source_bundle.source\n-\n-    def try_split(self, fraction_of_remainder):\n-      consumed_fraction = self.range_tracker().fraction_consumed()\n-      fraction = (\n-          consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n-      position = self.range_tracker().position_at_fraction(fraction)\n-      # Need to stash current stop_pos before splitting since\n-      # range_tracker.split will update its stop_pos if splits\n-      # successfully.\n-      stop_pos = self._source_bundle.stop_position\n-      split_result = self.range_tracker().try_split(position)\n-      if split_result:\n-        split_pos, split_fraction = split_result\n-        primary_weight = self._source_bundle.weight * split_fraction\n-        residual_weight = self._source_bundle.weight - primary_weight\n-        # Update self to primary weight and end position.\n-        self._source_bundle = SourceBundle(\n-            primary_weight,\n-            self._source_bundle.source,\n-            self._source_bundle.start_position,\n-            split_pos)\n-        return (\n-            self,\n-            _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-                SourceBundle(\n-                    residual_weight,\n-                    self._source_bundle.source,\n-                    split_pos,\n-                    stop_pos)))\n-\n-  class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n-    \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n-    with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n-    wraps SourceBundle and RangeTracker.\n-\n-    Delegated RangeTracker guarantees synchronization safety.\n-    \"\"\"\n-    def __init__(self, restriction):\n-      if not isinstance(restriction,\n-                        _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction):\n-        raise ValueError(\n-            'Initializing SDFBoundedSourceRestrictionTracker'\n-            ' requires a _SDFBoundedSourceRestriction')\n-      self.restriction = restriction\n-\n-    def current_progress(self):\n-      # type: () -> RestrictionProgress\n-      return RestrictionProgress(\n-          fraction=self.restriction.range_tracker().fraction_consumed())\n-\n-    def current_restriction(self):\n-      self.restriction.range_tracker()\n-      return self.restriction\n-\n-    def start_pos(self):\n-      return self.restriction.range_tracker().start_position()\n-\n-    def stop_pos(self):\n-      return self.restriction.range_tracker().stop_position()\n-\n-    def try_claim(self, position):\n-      return self.restriction.range_tracker().try_claim(position)\n-\n-    def try_split(self, fraction_of_remainder):\n-      return self.restriction.try_split(fraction_of_remainder)\n-\n-    def check_done(self):\n-      return self.restriction.range_tracker().fraction_consumed() >= 1.0\n-\n-    def is_bounded(self):\n-      return True\n-\n-  class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n-    \"\"\"A `RestrictionProvider` that is used by SDF for `BoundedSource`.\"\"\"\n-    def __init__(self, source, desired_chunk_size=None):\n-      self._source = source\n-      self._desired_chunk_size = desired_chunk_size\n-\n-    def initial_restriction(self, element):\n-      # Get initial range_tracker from source\n-      range_tracker = self._source.get_range_tracker(None, None)\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-          SourceBundle(\n-              None,\n-              self._source,\n-              range_tracker.start_position(),\n-              range_tracker.stop_position()))\n-\n-    def create_tracker(self, restriction):\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestrictionTracker(\n-          restriction)\n-\n-    def split(self, element, restriction):\n-      if self._desired_chunk_size is None:\n-        try:\n-          estimated_size = self._source.estimate_size()\n-        except NotImplementedError:\n-          estimated_size = None\n-        self._desired_chunk_size = Read.get_desired_chunk_size(estimated_size)\n-\n-      # Invoke source.split to get initial splitting results.\n-      source_bundles = self._source.split(self._desired_chunk_size)\n-      for source_bundle in source_bundles:\n-        yield _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-            source_bundle)\n-\n-    def restriction_size(self, element, restriction):\n-      return restriction.weight()\n-\n-    def restriction_coder(self):\n-      return coders.DillCoder()\n+  def __init__(self, restriction):\n+    if not isinstance(restriction, _SDFBoundedSourceRestriction):\n+      raise ValueError(\n+          'Initializing SDFBoundedSourceRestrictionTracker'\n+          ' requires a _SDFBoundedSourceRestriction')\n+    self.restriction = restriction\n \n-  def __init__(self, source):\n-    if not isinstance(source, BoundedSource):\n-      raise RuntimeError('SDFBoundedSourceWrapper can only wrap BoundedSource')\n-    super(_SDFBoundedSourceWrapper, self).__init__()\n-    self.source = source\n+  def current_progress(self):\n+    # type: () -> RestrictionProgress\n+    return RestrictionProgress(\n+        fraction=self.restriction.range_tracker().fraction_consumed())\n \n-  def _create_sdf_bounded_source_dofn(self):\n-    source = self.source\n+  def current_restriction(self):\n+    self.restriction.range_tracker()\n+    return self.restriction\n \n-    class SDFBoundedSourceDoFn(core.DoFn):\n-      def __init__(self, read_source):\n-        self.source = read_source\n+  def start_pos(self):\n+    return self.restriction.range_tracker().start_position()\n+\n+  def stop_pos(self):\n+    return self.restriction.range_tracker().stop_position()\n+\n+  def try_claim(self, position):\n+    return self.restriction.range_tracker().try_claim(position)\n \n-      def display_data(self):\n-        return {\n-            'source': DisplayDataItem(\n-                self.source.__class__, label='Read Source'),\n-            'source_dd': self.source\n-        }\n+  def try_split(self, fraction_of_remainder):\n+    return self.restriction.try_split(fraction_of_remainder)\n+\n+  def check_done(self):\n+    return self.restriction.range_tracker().fraction_consumed() >= 1.0\n+\n+  def is_bounded(self):\n+    return True\n+\n+\n+class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n+  \"\"\"\n+  A `RestrictionProvider` that is used by SDF for `BoundedSource`.\n+\n+  If source is provided, uses it for initializing restriction. Otherwise\n+  initializes restriction based on input element that is expected to be of\n+  BoundedSource type.\n+  \"\"\"\n+  def __init__(self, desired_chunk_size=None):\n+    self._desired_chunk_size = desired_chunk_size\n+\n+  def _check_source(self, src):\n+    if src is not None and not isinstance(src, BoundedSource):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0a15099de62d1b7a9b08a8378f816e624b816ac"}, "originalPosition": 283}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c16e3b355dc873abebc9d16f0b46280ed8e9dd28", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/c16e3b355dc873abebc9d16f0b46280ed8e9dd28", "committedDate": "2020-10-29T18:31:38Z", "message": "fixup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4934da1246b4f0e71f90376be8ab1d9dc41599dc", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/4934da1246b4f0e71f90376be8ab1d9dc41599dc", "committedDate": "2020-11-03T19:50:28Z", "message": "fixup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac09ae07a026ed9c26249984e6a229ad74566459", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/ac09ae07a026ed9c26249984e6a229ad74566459", "committedDate": "2020-11-03T20:35:40Z", "message": "fix formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "050cd4c4ac7d5bab49b5a041f924ed3f86864b6d", "author": {"user": {"login": "pabloem", "name": "Pablo"}}, "url": "https://github.com/apache/beam/commit/050cd4c4ac7d5bab49b5a041f924ed3f86864b6d", "committedDate": "2020-11-03T21:52:16Z", "message": "fixup"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2153, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}