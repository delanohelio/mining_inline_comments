{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzODg2OTA3", "number": 13496, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMTo1MzoxMlrOFCAVkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzoxNToyMlrOFLksCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjQ2OTk0OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMTo1MzoxMlrOIA8ZCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwNjo1OTo1OVrOIQHsIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg2MDM2Mg==", "bodyText": "Didn't add a global window around here as the existing implementation:\n\n  \n    \n      beam/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java\n    \n    \n         Line 281\n      in\n      2462fe9\n    \n    \n    \n    \n\n        \n          \n           \"GlobalWindow\", \n        \n    \n  \n\n\nAccording to the documentation the global window is for correct access to side inputs but it seems to me that up to this point the dynamic destination has been read. @reuvenlax I might be missing something but let me know if I should keep the global window (and if so where?).", "url": "https://github.com/apache/beam/pull/13496#discussion_r537860362", "createdAt": "2020-12-07T21:53:12Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.standardSeconds(10);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5NjU3MQ==", "bodyText": "Hmm good question. I wonder if someone refactored the code at some point to change things? I'm not entirely sure about the global window here.", "url": "https://github.com/apache/beam/pull/13496#discussion_r552396571", "createdAt": "2021-01-06T06:39:19Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.standardSeconds(10);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg2MDM2Mg=="}, "originalCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5Njk4Ng==", "bodyText": "However we probably want to put in global window here anyway as the GroupIntoBatches should logically be in hte global window, right? If the user had tiny windows, we don't want that to result in tiny grouping.", "url": "https://github.com/apache/beam/pull/13496#discussion_r552396986", "createdAt": "2021-01-06T06:40:51Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.standardSeconds(10);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg2MDM2Mg=="}, "originalCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDExNQ==", "bodyText": "Good point! I added a global window right before GroupIntoBatches.", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774115", "createdAt": "2021-01-08T06:59:59Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.standardSeconds(10);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg2MDM2Mg=="}, "originalCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjY3NDk3OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMjo0NDowOVrOIA-NIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwNzowMDowNlrOIQHsUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5MDA4Mw==", "bodyText": "I would make this specified in the BigQueryIO builder instead.", "url": "https://github.com/apache/beam/pull/13496#discussion_r537890083", "createdAt": "2020-12-07T22:44:09Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java", "diffHunk": "@@ -243,61 +243,108 @@ public WriteResult expand(PCollection<KV<TableDestination, ElementT>> input) {\n       AtomicCoder<T> coder,\n       ErrorContainer<T> errorContainer) {\n     BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n-    int numShards = options.getNumStreamingKeys();\n \n     // A naive implementation would be to simply stream data directly to BigQuery.\n     // However, this could occasionally lead to duplicated data, e.g., when\n     // a VM that runs this code is restarted and the code is re-run.\n \n     // The above risk is mitigated in this implementation by relying on\n     // BigQuery built-in best effort de-dup mechanism.\n-\n     // To use this mechanism, each input TableRow is tagged with a generated\n-    // unique id, which is then passed to BigQuery and used to ignore duplicates\n-    // We create 50 keys per BigQuery table to generate output on. This is few enough that we\n-    // get good batching into BigQuery's insert calls, and enough that we can max out the\n-    // streaming insert quota.\n-    PCollection<KV<ShardedKey<String>, TableRowInfo<ElementT>>> tagged =\n-        input\n-            .apply(\"ShardTableWrites\", ParDo.of(new GenerateShardedTable<>(numShards)))\n-            .setCoder(KvCoder.of(ShardedKeyCoder.of(StringUtf8Coder.of()), elementCoder))\n-            .apply(\"TagWithUniqueIds\", ParDo.of(new TagWithUniqueIds<>()))\n-            .setCoder(\n-                KvCoder.of(\n-                    ShardedKeyCoder.of(StringUtf8Coder.of()), TableRowInfoCoder.of(elementCoder)));\n-\n-    TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+    // unique id, which is then passed to BigQuery and used to ignore duplicates.\n \n     // To prevent having the same TableRow processed more than once with regenerated\n     // different unique ids, this implementation relies on \"checkpointing\", which is\n-    // achieved as a side effect of having StreamingWriteFn immediately follow a GBK,\n-    // performed by Reshuffle.\n-    PCollectionTuple tuple =\n-        tagged\n-            .apply(Reshuffle.of())\n-            // Put in the global window to ensure that DynamicDestinations side inputs are accessed\n-            // correctly.\n-            .apply(\n-                \"GlobalWindow\",\n-                Window.<KV<ShardedKey<String>, TableRowInfo<ElementT>>>into(new GlobalWindows())\n-                    .triggering(DefaultTrigger.of())\n-                    .discardingFiredPanes())\n-            .apply(\n-                \"StreamingWrite\",\n-                ParDo.of(\n-                        new StreamingWriteFn<>(\n-                            bigQueryServices,\n-                            retryPolicy,\n-                            failedInsertsTag,\n-                            errorContainer,\n-                            skipInvalidRows,\n-                            ignoreUnknownValues,\n-                            ignoreInsertIds,\n-                            toTableRow,\n-                            toFailsafeTableRow))\n-                    .withOutputTags(mainOutputTag, TupleTagList.of(failedInsertsTag)));\n-    PCollection<T> failedInserts = tuple.get(failedInsertsTag);\n-    failedInserts.setCoder(coder);\n-    return failedInserts;\n+    // achieved as a side effect of having BigQuery insertion immediately follow a GBK.\n+\n+    if (options.getEnableStreamingAutoSharding()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDE2MQ==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774161", "createdAt": "2021-01-08T07:00:06Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java", "diffHunk": "@@ -243,61 +243,108 @@ public WriteResult expand(PCollection<KV<TableDestination, ElementT>> input) {\n       AtomicCoder<T> coder,\n       ErrorContainer<T> errorContainer) {\n     BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n-    int numShards = options.getNumStreamingKeys();\n \n     // A naive implementation would be to simply stream data directly to BigQuery.\n     // However, this could occasionally lead to duplicated data, e.g., when\n     // a VM that runs this code is restarted and the code is re-run.\n \n     // The above risk is mitigated in this implementation by relying on\n     // BigQuery built-in best effort de-dup mechanism.\n-\n     // To use this mechanism, each input TableRow is tagged with a generated\n-    // unique id, which is then passed to BigQuery and used to ignore duplicates\n-    // We create 50 keys per BigQuery table to generate output on. This is few enough that we\n-    // get good batching into BigQuery's insert calls, and enough that we can max out the\n-    // streaming insert quota.\n-    PCollection<KV<ShardedKey<String>, TableRowInfo<ElementT>>> tagged =\n-        input\n-            .apply(\"ShardTableWrites\", ParDo.of(new GenerateShardedTable<>(numShards)))\n-            .setCoder(KvCoder.of(ShardedKeyCoder.of(StringUtf8Coder.of()), elementCoder))\n-            .apply(\"TagWithUniqueIds\", ParDo.of(new TagWithUniqueIds<>()))\n-            .setCoder(\n-                KvCoder.of(\n-                    ShardedKeyCoder.of(StringUtf8Coder.of()), TableRowInfoCoder.of(elementCoder)));\n-\n-    TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+    // unique id, which is then passed to BigQuery and used to ignore duplicates.\n \n     // To prevent having the same TableRow processed more than once with regenerated\n     // different unique ids, this implementation relies on \"checkpointing\", which is\n-    // achieved as a side effect of having StreamingWriteFn immediately follow a GBK,\n-    // performed by Reshuffle.\n-    PCollectionTuple tuple =\n-        tagged\n-            .apply(Reshuffle.of())\n-            // Put in the global window to ensure that DynamicDestinations side inputs are accessed\n-            // correctly.\n-            .apply(\n-                \"GlobalWindow\",\n-                Window.<KV<ShardedKey<String>, TableRowInfo<ElementT>>>into(new GlobalWindows())\n-                    .triggering(DefaultTrigger.of())\n-                    .discardingFiredPanes())\n-            .apply(\n-                \"StreamingWrite\",\n-                ParDo.of(\n-                        new StreamingWriteFn<>(\n-                            bigQueryServices,\n-                            retryPolicy,\n-                            failedInsertsTag,\n-                            errorContainer,\n-                            skipInvalidRows,\n-                            ignoreUnknownValues,\n-                            ignoreInsertIds,\n-                            toTableRow,\n-                            toFailsafeTableRow))\n-                    .withOutputTags(mainOutputTag, TupleTagList.of(failedInsertsTag)));\n-    PCollection<T> failedInserts = tuple.get(failedInsertsTag);\n-    failedInserts.setCoder(coder);\n-    return failedInserts;\n+    // achieved as a side effect of having BigQuery insertion immediately follow a GBK.\n+\n+    if (options.getEnableStreamingAutoSharding()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5MDA4Mw=="}, "originalCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NjA5MTMzOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxODo1ODo1OFrOIL__dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMjo0MToxNFrOIbe3Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1MzY4Nw==", "bodyText": "Not sure about this limit. What would be a proper value? Should we make it configurable?", "url": "https://github.com/apache/beam/pull/13496#discussion_r549453687", "createdAt": "2020-12-28T18:58:58Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY0NjQ5MQ==", "bodyText": "to be hones, I am not sure what's a good duration either. I think this is acceptable for now, until we find out more. Thoughts?", "url": "https://github.com/apache/beam/pull/13496#discussion_r565646491", "createdAt": "2021-01-27T21:28:33Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1MzY4Nw=="}, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4ODEzMA==", "bodyText": "Yeah sounds reasonable to proceed with this for now.", "url": "https://github.com/apache/beam/pull/13496#discussion_r565688130", "createdAt": "2021-01-27T22:41:14Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1MzY4Nw=="}, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 277}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NjU5NTY5OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryOptions.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNToyODo0OVrOIOyb_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxODozOTozMVrOIQdAsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM3NzM0MA==", "bodyText": "I think this should be an option on BigQueryIO.", "url": "https://github.com/apache/beam/pull/13496#discussion_r552377340", "createdAt": "2021-01-06T05:28:49Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryOptions.java", "diffHunk": "@@ -78,4 +79,11 @@\n   Integer getLatencyLoggingFrequency();\n \n   void setLatencyLoggingFrequency(Integer value);\n+\n+  @Experimental\n+  @Description(\"Whether dynamic sharding is enabled for writing to BigQuery in streaming.\")\n+  @Default.Boolean(false)\n+  Boolean getEnableStreamingAutoSharding();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDE4Ng==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774186", "createdAt": "2021-01-08T07:00:10Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryOptions.java", "diffHunk": "@@ -78,4 +79,11 @@\n   Integer getLatencyLoggingFrequency();\n \n   void setLatencyLoggingFrequency(Integer value);\n+\n+  @Experimental\n+  @Description(\"Whether dynamic sharding is enabled for writing to BigQuery in streaming.\")\n+  @Default.Boolean(false)\n+  Boolean getEnableStreamingAutoSharding();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM3NzM0MA=="}, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDEyMzQ0Mg==", "bodyText": "I was thinking that adding the option to BigQueryOptions might be easier for the users to switch on/off the feature. If it is an option of BigQueryIO users would need to update their code (vs. adding a flag) right? It might not be a concern...", "url": "https://github.com/apache/beam/pull/13496#discussion_r554123442", "createdAt": "2021-01-08T18:39:31Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryOptions.java", "diffHunk": "@@ -78,4 +79,11 @@\n   Integer getLatencyLoggingFrequency();\n \n   void setLatencyLoggingFrequency(Integer value);\n+\n+  @Experimental\n+  @Description(\"Whether dynamic sharding is enabled for writing to BigQuery in streaming.\")\n+  @Default.Boolean(false)\n+  Boolean getEnableStreamingAutoSharding();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM3NzM0MA=="}, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NjY0MTA0OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNTo1NDo1NlrOIOy2aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwNzowMDoxOFrOIQHshw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NDEwNA==", "bodyText": "add space", "url": "https://github.com/apache/beam/pull/13496#discussion_r552384104", "createdAt": "2021-01-06T05:54:56Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDIxNQ==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774215", "createdAt": "2021-01-08T07:00:18Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NDEwNA=="}, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NjY0NzQzOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNTo1Nzo1MlrOIOy5yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwNzowMDoyM1rOIQHspQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NDk2OA==", "bodyText": "seems more direct to just call tableRows.computeIfAbsent(tableSpec, ...)", "url": "https://github.com/apache/beam/pull/13496#discussion_r552384968", "createdAt": "2021-01-06T05:57:52Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDI0NQ==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774245", "createdAt": "2021-01-08T07:00:23Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NDk2OA=="}, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NjY4NjE2OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNjoxODoyMlrOIOzPvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwNzowMDoyOVrOIQHsvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MDU4OQ==", "bodyText": "instead add an OutputReceiver parameter to finishBundle.", "url": "https://github.com/apache/beam/pull/13496#discussion_r552390589", "createdAt": "2021-01-06T06:18:22Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDI3MA==", "bodyText": "finishBundle doesn't seems to accept parameters other than FinishBundleContext.", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774270", "createdAt": "2021-01-08T07:00:29Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MDU4OQ=="}, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NjY4OTIxOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNjoxOTo0N1rOIOzRcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwNzowMDozNFrOIQHs0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MTAyNg==", "bodyText": "Why is this \"stateful\"?", "url": "https://github.com/apache/beam/pull/13496#discussion_r552391026", "createdAt": "2021-01-06T06:19:47Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDI4OQ==", "bodyText": "Because input is batched through a stateful DoFn, GroupIntoBatches. Any suggestion on the name?", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774289", "createdAt": "2021-01-08T07:00:34Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MTAyNg=="}, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NjczMzMzOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNjo0MjoxOVrOIOzqgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwNzowMDo0MVrOIQHs8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5NzQ0MQ==", "bodyText": "We are relying on the fact that the GroupIntoBatches produces stable output. Really we should tag this with RequiresStableInput. Can you find out if this is safe to do in Dataflow?", "url": "https://github.com/apache/beam/pull/13496#discussion_r552397441", "createdAt": "2021-01-06T06:42:19Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input\n+              // Group and batch table rows such that each batch has no more than\n+              // getMaxStreamingRowsToBatch rows. Also set a buffering time limit to avoid being\n+              // stuck at a partial batch forever, especially in a global window.\n+              .apply(\n+                  GroupIntoBatches.<String, TableRowInfo<ElementT>>ofSize(\n+                          options.getMaxStreamingRowsToBatch())\n+                      .withMaxBufferingDuration(BATCH_MAX_BUFFERING_DURATION)\n+                      .withShardedKey())\n+              .setCoder(\n+                  KvCoder.of(\n+                      ShardedKey.Coder.of(StringUtf8Coder.of()), IterableCoder.of(valueCoder)))\n+              .apply(\n+                  ParDo.of(new InsertBatchedElements())\n+                      .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  private class InsertBatchedElements", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDMyMg==", "bodyText": "There is a transform override in Dataflow to add a preceding Reshuffle to DoFns marked with RequiresStableInput.\n\n  \n    \n      beam/runners/google-cloud-dataflow-java/src/main/java/org/apache/beam/runners/dataflow/RequiresStableInputParDoOverrides.java\n    \n    \n         Line 73\n      in\n      74ec609\n    \n    \n    \n    \n\n        \n          \n           .apply(\"Materialize input\", Reshuffle.viaRandomKey()) \n        \n    \n  \n\n\nThe override is disabled though. So I guess currently Dataflow does nothing for this tag.\n\n  \n    \n      beam/runners/google-cloud-dataflow-java/src/main/java/org/apache/beam/runners/dataflow/DataflowRunner.java\n    \n    \n         Line 601\n      in\n      df74d74\n    \n    \n    \n    \n\n        \n          \n           /* TODO[Beam-4684]: Support @RequiresStableInput on Dataflow in a more intelligent way \n        \n    \n  \n\n\nAlso my understanding is that dding a Reshuffle before GroupIntoBatches will introduce an extra shuffle as Reshuffle is essentially a GBK + value expansion in Dataflow.", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774322", "createdAt": "2021-01-08T07:00:41Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input\n+              // Group and batch table rows such that each batch has no more than\n+              // getMaxStreamingRowsToBatch rows. Also set a buffering time limit to avoid being\n+              // stuck at a partial batch forever, especially in a global window.\n+              .apply(\n+                  GroupIntoBatches.<String, TableRowInfo<ElementT>>ofSize(\n+                          options.getMaxStreamingRowsToBatch())\n+                      .withMaxBufferingDuration(BATCH_MAX_BUFFERING_DURATION)\n+                      .withShardedKey())\n+              .setCoder(\n+                  KvCoder.of(\n+                      ShardedKey.Coder.of(StringUtf8Coder.of()), IterableCoder.of(valueCoder)))\n+              .apply(\n+                  ParDo.of(new InsertBatchedElements())\n+                      .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  private class InsertBatchedElements", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5NzQ0MQ=="}, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3Njc5NzU1OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzoxNToyMlrOIO0Phw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwNzowMDo0NVrOIQHtCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNjkxOQ==", "bodyText": "use a MultiOutputReceiver instead", "url": "https://github.com/apache/beam/pull/13496#discussion_r552406919", "createdAt": "2021-01-06T07:15:22Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input\n+              // Group and batch table rows such that each batch has no more than\n+              // getMaxStreamingRowsToBatch rows. Also set a buffering time limit to avoid being\n+              // stuck at a partial batch forever, especially in a global window.\n+              .apply(\n+                  GroupIntoBatches.<String, TableRowInfo<ElementT>>ofSize(\n+                          options.getMaxStreamingRowsToBatch())\n+                      .withMaxBufferingDuration(BATCH_MAX_BUFFERING_DURATION)\n+                      .withShardedKey())\n+              .setCoder(\n+                  KvCoder.of(\n+                      ShardedKey.Coder.of(StringUtf8Coder.of()), IterableCoder.of(valueCoder)))\n+              .apply(\n+                  ParDo.of(new InsertBatchedElements())\n+                      .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  private class InsertBatchedElements\n+      extends DoFn<KV<ShardedKey<String>, Iterable<TableRowInfo<ElementT>>>, Void> {\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<ShardedKey<String>, Iterable<TableRowInfo<ElementT>>> input,\n+        BoundedWindow window,\n+        ProcessContext context)\n+        throws InterruptedException {\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> tableRows = new ArrayList<>();\n+      List<String> uniqueIds = new ArrayList<>();\n+      for (TableRowInfo<ElementT> row : input.getValue()) {\n+        TableRow tableRow = toTableRow.apply(row.tableRow);\n+        TableRow failsafeTableRow = toFailsafeTableRow.apply(row.tableRow);\n+        tableRows.add(\n+            FailsafeValueInSingleWindow.of(\n+                tableRow, context.timestamp(), window, context.pane(), failsafeTableRow));\n+        uniqueIds.add(row.uniqueId);\n+      }\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      TableReference tableReference = BigQueryHelpers.parseTableSpec(input.getKey().getKey());\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      flushRows(tableReference, tableRows, uniqueIds, options, failedInserts);\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDM0NQ==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774345", "createdAt": "2021-01-08T07:00:45Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input\n+              // Group and batch table rows such that each batch has no more than\n+              // getMaxStreamingRowsToBatch rows. Also set a buffering time limit to avoid being\n+              // stuck at a partial batch forever, especially in a global window.\n+              .apply(\n+                  GroupIntoBatches.<String, TableRowInfo<ElementT>>ofSize(\n+                          options.getMaxStreamingRowsToBatch())\n+                      .withMaxBufferingDuration(BATCH_MAX_BUFFERING_DURATION)\n+                      .withShardedKey())\n+              .setCoder(\n+                  KvCoder.of(\n+                      ShardedKey.Coder.of(StringUtf8Coder.of()), IterableCoder.of(valueCoder)))\n+              .apply(\n+                  ParDo.of(new InsertBatchedElements())\n+                      .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  private class InsertBatchedElements\n+      extends DoFn<KV<ShardedKey<String>, Iterable<TableRowInfo<ElementT>>>, Void> {\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<ShardedKey<String>, Iterable<TableRowInfo<ElementT>>> input,\n+        BoundedWindow window,\n+        ProcessContext context)\n+        throws InterruptedException {\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> tableRows = new ArrayList<>();\n+      List<String> uniqueIds = new ArrayList<>();\n+      for (TableRowInfo<ElementT> row : input.getValue()) {\n+        TableRow tableRow = toTableRow.apply(row.tableRow);\n+        TableRow failsafeTableRow = toFailsafeTableRow.apply(row.tableRow);\n+        tableRows.add(\n+            FailsafeValueInSingleWindow.of(\n+                tableRow, context.timestamp(), window, context.pane(), failsafeTableRow));\n+        uniqueIds.add(row.uniqueId);\n+      }\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      TableReference tableReference = BigQueryHelpers.parseTableSpec(input.getKey().getKey());\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      flushRows(tableReference, tableRows, uniqueIds, options, failedInserts);\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNjkxOQ=="}, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 346}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2522, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}