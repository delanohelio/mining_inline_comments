{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2Mjc5ODk0", "number": 11665, "title": "[BEAM-9951] Creating a synthetic source for the Go SDK.", "bodyText": "This is just a starting point, and there's a lot more that can be added\non to this class, but this'll do for now. As part of this change, I\ngeneralized the offset range tracker code so it could also be used in\nthe synthetic source.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-05-11T18:48:56Z", "url": "https://github.com/apache/beam/pull/11665", "merged": true, "mergeCommit": {"oid": "10b0f88122e51c6ae0f47539c736652279c0510d"}, "closed": true, "closedAt": "2020-05-15T21:39:58Z", "author": {"login": "youngoli"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgs9erAFqTQxMDQ2NjU1Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcho00ugBqjMzNDI2Mzg4NDM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNDY2NTU3", "url": "https://github.com/apache/beam/pull/11665#pullrequestreview-410466557", "createdAt": "2020-05-12T22:26:44Z", "commit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjoyNjo0NFrOGUbI_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzoyNzo0NFrOGUcaog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2OTM3NA==", "bodyText": "Oh wow. I feel bad for missing this on my initial review. Good catch!", "url": "https://github.com/apache/beam/pull/11665#discussion_r424069374", "createdAt": "2020-05-12T22:26:44Z", "author": {"login": "lostluck"}, "path": "sdks/go/examples/stringsplit/stringsplit.go", "diffHunk": "@@ -112,15 +112,15 @@ func (fn *StringSplitFn) CreateTracker(rest offsetrange.Restriction) *offsetrang\n //\n // Example: If BufSize is 100, then a restriction of 75 to 325 should emit the\n // following substrings: [100, 200], [200, 300], [300, 400]\n-func (fn *StringSplitFn) ProcessElement(rt *offsetrange.Tracker, elem string, emit func(string)) {\n-\tlog.Debugf(context.Background(), \"StringSplit ProcessElement: Tracker = %v\", rt)\n+func (fn *StringSplitFn) ProcessElement(ctx context.Context, rt *offsetrange.Tracker, elem string, emit func(string)) {\n+\tlog.Debugf(ctx, \"StringSplit ProcessElement: Tracker = %v\", rt)\n \ti := rt.Rest.Start\n \tif rem := i % fn.BufSize; rem != 0 {\n \t\ti += fn.BufSize - rem // Skip to next multiple of BufSize.\n \t}\n \tstrEnd := int64(len(elem))\n \n-\tfor ok := rt.TryClaim(i); ok == true; ok = rt.TryClaim(i) {\n+\tfor rt.TryClaim(i) == true {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2OTk0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // tests are not concerned with the correctness of the elements themselves, but\n          \n          \n            \n            // tests is not concerned with the correctness of the elements themselves, but\n          \n      \n    \n    \n  \n\nNit: The subject of the sentences is \"the category of tests\" not \"tests\" so the singular \"is\"  is appropriate.", "url": "https://github.com/apache/beam/pull/11665#discussion_r424069944", "createdAt": "2020-05-12T22:28:10Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MTY0MQ==", "bodyText": "Here and below, this should be sourceFn.", "url": "https://github.com/apache/beam/pull/11665#discussion_r424071641", "createdAt": "2020-05-12T22:32:57Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MjczNA==", "bodyText": "I guess this should be Source()", "url": "https://github.com/apache/beam/pull/11665#discussion_r424072734", "createdAt": "2020-05-12T22:35:58Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NDY2NQ==", "bodyText": "&sourceFn{}\nIt's important to run the code too :)", "url": "https://github.com/apache/beam/pull/11665#discussion_r424074665", "createdAt": "2020-05-12T22:41:25Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NTk5Mg==", "bodyText": "WRT the builder question, forexample, here's where one could have a variadic ...Options parameter if most options are largely independant. Alternatively, having a synthetic.Options{} struct which has the various configurations is also appropriate.\nA options struct is simple, but if the default values can be mistaken for something the user wants, or worse, they aren't naturally useful, this can hurt things.", "url": "https://github.com/apache/beam/pull/11665#discussion_r424075992", "createdAt": "2020-05-12T22:45:09Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NjY2MA==", "bodyText": "Consider doing this in a Setup() instead, since new Random Sources are moderately expensive, and could skew the expense per Bundle.", "url": "https://github.com/apache/beam/pull/11665#discussion_r424076660", "createdAt": "2020-05-12T22:46:58Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sourceFn) RestrictionSize(config SourceConfig, rest offsetrange.Restriction) float64 {\n+\treturn float64(rest.End - rest.Start)\n+}\n+\n+// CreateTracker just creates an offset range restriction tracker for the\n+// restriction.\n+func (fn *sourceFn) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {\n+\treturn offsetrange.NewTracker(rest)\n+}\n+\n+// StartBundle sets up the random number generator.\n+func (fn *sourceFn) StartBundle() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3ODUwMg==", "bodyText": "We may want to consider moving implementations like this onto methods of offsetrange.Restriction\nUsers can always write their own, but making it trivial for users to use the restriction in a few ways probably doesn't hurt, and simplifies testing those implementations.", "url": "https://github.com/apache/beam/pull/11665#discussion_r424078502", "createdAt": "2020-05-12T22:52:03Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3ODk3OQ==", "bodyText": "Same comment here about methods. Not necessary todo in this PR.", "url": "https://github.com/apache/beam/pull/11665#discussion_r424078979", "createdAt": "2020-05-12T22:53:22Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sourceFn) RestrictionSize(config SourceConfig, rest offsetrange.Restriction) float64 {\n+\treturn float64(rest.End - rest.Start)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // form of KV<[]byte, []byte>,\n          \n          \n            \n            // form of KV<[]byte, []byte>.", "url": "https://github.com/apache/beam/pull/11665#discussion_r424079909", "createdAt": "2020-05-12T22:56:12Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sourceFn) RestrictionSize(config SourceConfig, rest offsetrange.Restriction) float64 {\n+\treturn float64(rest.End - rest.Start)\n+}\n+\n+// CreateTracker just creates an offset range restriction tracker for the\n+// restriction.\n+func (fn *sourceFn) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {\n+\treturn offsetrange.NewTracker(rest)\n+}\n+\n+// StartBundle sets up the random number generator.\n+func (fn *sourceFn) StartBundle() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement creates a number of random elements based on the restriction\n+// tracker received. Each element is a random byte slice key and value, in the\n+// form of KV<[]byte, []byte>,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MTMwMA==", "bodyText": "Should this be 1? Is a 0 config valuable?", "url": "https://github.com/apache/beam/pull/11665#discussion_r424081300", "createdAt": "2020-05-12T22:59:53Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sourceFn) RestrictionSize(config SourceConfig, rest offsetrange.Restriction) float64 {\n+\treturn float64(rest.End - rest.Start)\n+}\n+\n+// CreateTracker just creates an offset range restriction tracker for the\n+// restriction.\n+func (fn *sourceFn) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {\n+\treturn offsetrange.NewTracker(rest)\n+}\n+\n+// StartBundle sets up the random number generator.\n+func (fn *sourceFn) StartBundle() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement creates a number of random elements based on the restriction\n+// tracker received. Each element is a random byte slice key and value, in the\n+// form of KV<[]byte, []byte>,\n+func (fn *sourceFn) ProcessElement(rt *offsetrange.Tracker, config SourceConfig, emit func([]byte, []byte)) error {\n+\tfor i := rt.Rest.Start; rt.TryClaim(i) == true; i++ {\n+\t\tkey := make([]byte, 8)\n+\t\tval := make([]byte, 8)\n+\t\tif _, err := fn.rng.Read(key); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := fn.rng.Read(val); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\temit(key, val)\n+\t}\n+\treturn nil\n+}\n+\n+// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n+// fields. SourceConfigs should be initialized with this method.\n+func DefaultSourceConfig() SourceConfig {\n+\treturn SourceConfig{\n+\t\tNumElements:   0, // Number of elements for the synthetic source to produce.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MzM2MA==", "bodyText": "The comments on the fields here seem to  be redundant to the ones on the definition struct fields.\nConsider switching them with the whys for those default values.\nThere's an idiom in go to \"make the zero value useful\". In this case the zero value is SourceConfig{}. WRT the implementation, this is identical to what's being provided by the DefaultSourceConfig() method since InitialSplits is \"default 1\" anyway.\nI do like the declaration that DefaultSourceConfig() is recommended for how to configure initially since it'll set th defaults, especially when new fields are being added, so behavior doesn't unnecessarily change when the new feature is added.", "url": "https://github.com/apache/beam/pull/11665#discussion_r424083360", "createdAt": "2020-05-12T23:06:01Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sourceFn) RestrictionSize(config SourceConfig, rest offsetrange.Restriction) float64 {\n+\treturn float64(rest.End - rest.Start)\n+}\n+\n+// CreateTracker just creates an offset range restriction tracker for the\n+// restriction.\n+func (fn *sourceFn) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {\n+\treturn offsetrange.NewTracker(rest)\n+}\n+\n+// StartBundle sets up the random number generator.\n+func (fn *sourceFn) StartBundle() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement creates a number of random elements based on the restriction\n+// tracker received. Each element is a random byte slice key and value, in the\n+// form of KV<[]byte, []byte>,\n+func (fn *sourceFn) ProcessElement(rt *offsetrange.Tracker, config SourceConfig, emit func([]byte, []byte)) error {\n+\tfor i := rt.Rest.Start; rt.TryClaim(i) == true; i++ {\n+\t\tkey := make([]byte, 8)\n+\t\tval := make([]byte, 8)\n+\t\tif _, err := fn.rng.Read(key); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := fn.rng.Read(val); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\temit(key, val)\n+\t}\n+\treturn nil\n+}\n+\n+// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n+// fields. SourceConfigs should be initialized with this method.\n+func DefaultSourceConfig() SourceConfig {\n+\treturn SourceConfig{\n+\t\tNumElements:   0, // Number of elements for the synthetic source to produce.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjY3MQ==", "bodyText": "Is that how the Python impelmentation works? Neat!", "url": "https://github.com/apache/beam/pull/11665#discussion_r424086671", "createdAt": "2020-05-12T23:16:07Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MDI3NA==", "bodyText": "You may want to consider a small pipeline example snippet that feeds into this using beam.Create and DefaultSourceConfig() or similar, if only to hint folks towards DefaultSourceConfig.\nWRT Builders, I agree that a Builder api for SourceConfigs would be valuable in this case, even if they just return new instances of a SourceConfig. It would be more concise than requiring a new line per field change.\nsynthetic.DefaultSourceConfig().SetNumElements(###).SetInitialSplits(###)\nvs the \"natural\" Go inclination of:\nsynthetic.SourceConfig{NumElements: ###, InitialSplits: ###}\nwhich is a dozen or so characters shorter.\nThe only downside of the latter is introducing new fields that must have a nonzero default to work properly. Do any of the configurations in Java and Python have that property?", "url": "https://github.com/apache/beam/pull/11665#discussion_r424090274", "createdAt": "2020-05-12T23:27:44Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzg0OTky", "url": "https://github.com/apache/beam/pull/11665#pullrequestreview-411384992", "createdAt": "2020-05-14T00:20:43Z", "commit": {"oid": "6a4794d091e737be276624b86e4e9c24f7ca256d"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMDoyMDo0M1rOGVH62w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToyNTo1MVrOGVhp_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMzAzNQ==", "bodyText": "Given the verbosity, it's likely users will end up writing this as.\n//    cfgs := beam.CreateList(s, []synthetic.SourceConfig{{NumElements:1000}, {NumElements:5000: InitialSplits:2}})\n//    src := synthetic.Source(s, cfgs)\n\nBut ones that enjoy breaking code might run into breaks when we add fields with:\n cfgs := beam.CreateList(s, []synthetic.SourceConfig{{1000, 1}, {5000,2}})\n src := synthetic.Source(s, cfgs)\n\n... which is why one should always name one's fields when using struct literals.", "url": "https://github.com/apache/beam/pull/11665#discussion_r424803035", "createdAt": "2020-05-14T00:20:43Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -33,22 +33,30 @@ import (\n // generated KV<[]byte, []byte> elements.\n //\n // This transform accepts a PCollection of SourceConfig, where each SourceConfig\n-// determines the synthetic source's behavior for that element.\n+// determines the synthetic source's behavior for that element and outputs the\n+// randomly generated elements.\n //\n-// This transform outputs a PCollection of randomly generated\n-// KV<byte[], byte[]> elements.\n+// SourceConfigs are recommended to be created via the DefaultSourceConfig and\n+// then sent to a beam.Create transform once modified. Example:\n+//\n+//    cfg1 := synthetic.DefaultSourceConfig()\n+//    cfg1.NumElements = 1000\n+//    cfg2 := synthetic.DefaultSourceConfig()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a4794d091e737be276624b86e4e9c24f7ca256d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyNDcwMw==", "bodyText": "output_records_per_input_record is problematic, but doesn't apply to SourceConfig I would think... (SrcCfg?) That seems like a perDoFn configuration.\nUnless that's the \"NumElements\" you were mentioning?", "url": "https://github.com/apache/beam/pull/11665#discussion_r425224703", "createdAt": "2020-05-14T15:25:51Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MDI3NA=="}, "originalCommit": {"oid": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyOTUyNzg0", "url": "https://github.com/apache/beam/pull/11665#pullrequestreview-412952784", "createdAt": "2020-05-15T20:39:01Z", "commit": {"oid": "6a4794d091e737be276624b86e4e9c24f7ca256d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "176e1f093e2457d4e7f0e092bf509d9873518c22", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/176e1f093e2457d4e7f0e092bf509d9873518c22", "committedDate": "2020-05-15T21:18:58Z", "message": "[BEAM-9951] Creating a synthetic source for the Go SDK.\n\nThis is just a starting point, and there's a lot more that can be added\non to this class, but this'll do for now. As part of this change, I\ngeneralized the offset range tracker code so it could also be used in\nthe synthetic source."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6a4794d091e737be276624b86e4e9c24f7ca256d", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/6a4794d091e737be276624b86e4e9c24f7ca256d", "committedDate": "2020-05-13T03:01:25Z", "message": "fixup"}, "afterCommit": {"oid": "176e1f093e2457d4e7f0e092bf509d9873518c22", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/176e1f093e2457d4e7f0e092bf509d9873518c22", "committedDate": "2020-05-15T21:18:58Z", "message": "[BEAM-9951] Creating a synthetic source for the Go SDK.\n\nThis is just a starting point, and there's a lot more that can be added\non to this class, but this'll do for now. As part of this change, I\ngeneralized the offset range tracker code so it could also be used in\nthe synthetic source."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4942, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}