{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwOTY3NDA2", "number": 11350, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjoxNzo1OFrODwld0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzoyMjowM1rOD9RNfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjcyMDgxOnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/DoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjoxNzo1OFrOGDrTvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjo0Mzo1OVrOGD_mwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwODQ3OQ==", "bodyText": "What do timestamp and timeDomain mean in this context?\nAlso presumably you do want to be able to access the key in onWindowExpiration", "url": "https://github.com/apache/beam/pull/11350#discussion_r406508479", "createdAt": "2020-04-09T22:17:58Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/DoFnRunner.java", "diffHunk": "@@ -52,6 +52,12 @@ void onTimer(\n    */\n   void finishBundle();\n \n+  /**\n+   * Calls a {@link DoFn DoFn's} {@link DoFn.OnWindowExpiration @OnWindowExpiration} method and\n+   * performs additional task, such as extracts a value saved in a state before garbage collection.\n+   */\n+  void onWindowExpiration(BoundedWindow window, Instant timestamp, TimeDomain timeDomain);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3711a4480b493c897eb72cfeb896b1e29f23dc"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg0MTAyNQ==", "bodyText": "@reuvenlax timestamp added to keep the time of outputs from OnWindowExpiration. This would be window.maxTimestamp()\ntimeDomain removed", "url": "https://github.com/apache/beam/pull/11350#discussion_r406841025", "createdAt": "2020-04-10T16:43:59Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/DoFnRunner.java", "diffHunk": "@@ -52,6 +52,12 @@ void onTimer(\n    */\n   void finishBundle();\n \n+  /**\n+   * Calls a {@link DoFn DoFn's} {@link DoFn.OnWindowExpiration @OnWindowExpiration} method and\n+   * performs additional task, such as extracts a value saved in a state before garbage collection.\n+   */\n+  void onWindowExpiration(BoundedWindow window, Instant timestamp, TimeDomain timeDomain);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwODQ3OQ=="}, "originalCommit": {"oid": "cd3711a4480b493c897eb72cfeb896b1e29f23dc"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjcyMTQ2OnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjoxODoyMVrOGDrUKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjo0MDo0NVrOGD_hLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwODU4NQ==", "bodyText": "Why is this based on OnTimerContext?", "url": "https://github.com/apache/beam/pull/11350#discussion_r406508585", "createdAt": "2020-04-09T22:18:21Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -841,6 +847,238 @@ public BundleFinalizer bundleFinalizer() {\n     }\n   }\n \n+  /**\n+   * A concrete implementation of {@link DoFnInvoker.ArgumentProvider} used for running a {@link\n+   * DoFn} on window expiration.\n+   */\n+  private class OnWindowExpirationArgumentProvider extends DoFn<InputT, OutputT>.OnTimerContext", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3711a4480b493c897eb72cfeb896b1e29f23dc"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzOTU5OQ==", "bodyText": "@reuvenlax OnWindowExpirationContext added.", "url": "https://github.com/apache/beam/pull/11350#discussion_r406839599", "createdAt": "2020-04-10T16:40:45Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -841,6 +847,238 @@ public BundleFinalizer bundleFinalizer() {\n     }\n   }\n \n+  /**\n+   * A concrete implementation of {@link DoFnInvoker.ArgumentProvider} used for running a {@link\n+   * DoFn} on window expiration.\n+   */\n+  private class OnWindowExpirationArgumentProvider extends DoFn<InputT, OutputT>.OnTimerContext", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwODU4NQ=="}, "originalCommit": {"oid": "cd3711a4480b493c897eb72cfeb896b1e29f23dc"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjczNDQ0OnYy", "diffSide": "LEFT", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjoyMzo1NlrOGDrb-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoyOTozN1rOGGoKhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxMDU4NQ==", "bodyText": "We also seem to set GC timers in ReduceFnRunner.java. @kennknowles do you know why we have both?", "url": "https://github.com/apache/beam/pull/11350#discussion_r406510585", "createdAt": "2020-04-09T22:23:56Z", "author": {"login": "reuvenlax"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -591,7 +591,7 @@ public void flushState() {\n               timerId,\n               \"\",\n               cleanupTime,\n-              cleanupTime,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3711a4480b493c897eb72cfeb896b1e29f23dc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwMjY5Mg==", "bodyText": "@reuvenlax  added in ReduceFnRunner.java", "url": "https://github.com/apache/beam/pull/11350#discussion_r409602692", "createdAt": "2020-04-16T14:29:37Z", "author": {"login": "rehmanmuradali"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -591,7 +591,7 @@ public void flushState() {\n               timerId,\n               \"\",\n               cleanupTime,\n-              cleanupTime,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxMDU4NQ=="}, "originalCommit": {"oid": "cd3711a4480b493c897eb72cfeb896b1e29f23dc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTYxMTM0OnYy", "diffSide": "RIGHT", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMzozMTozNlrOGEmjog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoyOToxN1rOGGoJhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ3OTIwMg==", "bodyText": "this should be window.maxTimestamp() + allowedLateness I think?  cleanupTime here is passed in as maxTimestamp + allowedLateness + 1ms", "url": "https://github.com/apache/beam/pull/11350#discussion_r407479202", "createdAt": "2020-04-13T13:31:36Z", "author": {"login": "steveniemitz"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -591,7 +591,7 @@ public void flushState() {\n               timerId,\n               \"\",\n               cleanupTime,\n-              cleanupTime,\n+              window.maxTimestamp(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "377cd514c1e8393dc09a9dbf43a1f391f269793f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwMjQzNw==", "bodyText": "@steveniemitz  cleanupTime.minus(1L) added", "url": "https://github.com/apache/beam/pull/11350#discussion_r409602437", "createdAt": "2020-04-16T14:29:17Z", "author": {"login": "rehmanmuradali"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -591,7 +591,7 @@ public void flushState() {\n               timerId,\n               \"\",\n               cleanupTime,\n-              cleanupTime,\n+              window.maxTimestamp(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ3OTIwMg=="}, "originalCommit": {"oid": "377cd514c1e8393dc09a9dbf43a1f391f269793f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzEzMzA3OnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTo0MDoyNVrOGQ8mlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTo0MDoyNVrOGQ8mlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyMzMxNg==", "bodyText": "Wondering if we need to expose timers here, as I don't see how it makes sense to create a new timer in an expired window.", "url": "https://github.com/apache/beam/pull/11350#discussion_r420423316", "createdAt": "2020-05-05T21:40:25Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -857,6 +863,223 @@ public BundleFinalizer bundleFinalizer() {\n     }\n   }\n \n+  /**\n+   * A concrete implementation of {@link DoFnInvoker.ArgumentProvider} used for running a {@link\n+   * DoFn} on window expiration.\n+   */\n+  private class OnWindowExpirationArgumentProvider<KeyT>\n+      extends DoFn<InputT, OutputT>.OnWindowExpirationContext\n+      implements DoFnInvoker.ArgumentProvider<InputT, OutputT> {\n+    private final BoundedWindow window;\n+    private final Instant timestamp;\n+    private final KeyT key;\n+    /** Lazily initialized; should only be accessed via {@link #getNamespace()}. */\n+    private @Nullable StateNamespace namespace;\n+\n+    /**\n+     * The state namespace for this context.\n+     *\n+     * <p>Any call to this method when more than one window is present will crash; this represents a\n+     * bug in the runner or the {@link DoFnSignature}, since values must be in exactly one window\n+     * when state or timers are relevant.\n+     */\n+    private StateNamespace getNamespace() {\n+      if (namespace == null) {\n+        namespace = StateNamespaces.window(windowCoder, window);\n+      }\n+      return namespace;\n+    }\n+\n+    private OnWindowExpirationArgumentProvider(BoundedWindow window, Instant timestamp, KeyT key) {\n+      fn.super();\n+      this.window = window;\n+      this.timestamp = timestamp;\n+      this.key = key;\n+    }\n+\n+    @Override\n+    public BoundedWindow window() {\n+      return window;\n+    }\n+\n+    @Override\n+    public PaneInfo paneInfo(DoFn<InputT, OutputT> doFn) {\n+      throw new UnsupportedOperationException(\n+          \"Cannot access paneInfo outside of @ProcessElement methods.\");\n+    }\n+\n+    @Override\n+    public PipelineOptions pipelineOptions() {\n+      return getPipelineOptions();\n+    }\n+\n+    @Override\n+    public DoFn<InputT, OutputT>.StartBundleContext startBundleContext(DoFn<InputT, OutputT> doFn) {\n+      throw new UnsupportedOperationException(\"StartBundleContext parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public DoFn<InputT, OutputT>.FinishBundleContext finishBundleContext(\n+        DoFn<InputT, OutputT> doFn) {\n+      throw new UnsupportedOperationException(\"FinishBundleContext parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public DoFn<InputT, OutputT>.ProcessContext processContext(DoFn<InputT, OutputT> doFn) {\n+      throw new UnsupportedOperationException(\"ProcessContext parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public InputT element(DoFn<InputT, OutputT> doFn) {\n+      throw new UnsupportedOperationException(\"Element parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public Object sideInput(String tagId) {\n+      throw new UnsupportedOperationException(\"SideInput parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public Object schemaElement(int index) {\n+      throw new UnsupportedOperationException(\"Element parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public Instant timestamp(DoFn<InputT, OutputT> doFn) {\n+      return timestamp;\n+    }\n+\n+    @Override\n+    public String timerId(DoFn<InputT, OutputT> doFn) {\n+      throw new UnsupportedOperationException(\"Timer parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public TimeDomain timeDomain(DoFn<InputT, OutputT> doFn) {\n+      throw new UnsupportedOperationException(\n+          \"Cannot access time domain outside of @ProcessTimer method.\");\n+    }\n+\n+    @Override\n+    public KeyT key() {\n+      return key;\n+    }\n+\n+    @Override\n+    public OutputReceiver<OutputT> outputReceiver(DoFn<InputT, OutputT> doFn) {\n+      return DoFnOutputReceivers.windowedReceiver(this, mainOutputTag);\n+    }\n+\n+    @Override\n+    public OutputReceiver<Row> outputRowReceiver(DoFn<InputT, OutputT> doFn) {\n+      return DoFnOutputReceivers.rowReceiver(this, mainOutputTag, mainOutputSchemaCoder);\n+    }\n+\n+    @Override\n+    public MultiOutputReceiver taggedOutputReceiver(DoFn<InputT, OutputT> doFn) {\n+      return DoFnOutputReceivers.windowedMultiReceiver(this, outputCoders);\n+    }\n+\n+    @Override\n+    public Object restriction() {\n+      throw new UnsupportedOperationException(\"@Restriction parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public DoFn<InputT, OutputT>.OnTimerContext onTimerContext(DoFn<InputT, OutputT> doFn) {\n+      throw new UnsupportedOperationException(\"OnTimerContext parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public RestrictionTracker<?, ?> restrictionTracker() {\n+      throw new UnsupportedOperationException(\"RestrictionTracker parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public Object watermarkEstimatorState() {\n+      throw new UnsupportedOperationException(\n+          \"@WatermarkEstimatorState parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public WatermarkEstimator<?> watermarkEstimator() {\n+      throw new UnsupportedOperationException(\"WatermarkEstimator parameters are not supported.\");\n+    }\n+\n+    @Override\n+    public State state(String stateId, boolean alwaysFetched) {\n+      try {\n+        StateSpec<?> spec =\n+            (StateSpec<?>) signature.stateDeclarations().get(stateId).field().get(fn);\n+        State state =\n+            stepContext\n+                .stateInternals()\n+                .state(getNamespace(), StateTags.tagForSpec(stateId, (StateSpec) spec));\n+        if (alwaysFetched) {\n+          return (State) ((ReadableState) state).readLater();\n+        } else {\n+          return state;\n+        }\n+      } catch (IllegalAccessException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+\n+    @Override\n+    public Timer timer(String timerId) {\n+      try {\n+        TimerSpec spec = (TimerSpec) signature.timerDeclarations().get(timerId).field().get(fn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6342bbeca0920c2849b5747b7c746b0bb2380f2f"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzEzODMxOnYy", "diffSide": "RIGHT", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/SimpleParDoFn.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTo0MjowNlrOGQ8pww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTo0MjowNlrOGQ8pww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyNDEzMQ==", "bodyText": "why did you subtract 1 here?", "url": "https://github.com/apache/beam/pull/11350#discussion_r420424131", "createdAt": "2020-05-05T21:42:06Z", "author": {"login": "reuvenlax"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/SimpleParDoFn.java", "diffHunk": "@@ -387,7 +387,8 @@ private void processSystemTimer(TimerData timer) throws Exception {\n           timer);\n \n       BoundedWindow window = ((WindowNamespace) timer.getNamespace()).getWindow();\n-      Instant targetTime = earliestAllowableCleanupTime(window, fnInfo.getWindowingStrategy());\n+      Instant targetTime =\n+          earliestAllowableCleanupTime(window, fnInfo.getWindowingStrategy()).minus(1L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6342bbeca0920c2849b5747b7c746b0bb2380f2f"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzE0NDAzOnYy", "diffSide": "RIGHT", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillTimerInternals.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTo0NDowOFrOGQ8tNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTo0NDowOFrOGQ8tNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyNTAxMg==", "bodyText": "I think this change is incorrect. Why was it necessary?", "url": "https://github.com/apache/beam/pull/11350#discussion_r420425012", "createdAt": "2020-05-05T21:44:08Z", "author": {"login": "reuvenlax"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillTimerInternals.java", "diffHunk": "@@ -246,8 +246,8 @@ public static boolean isUserTimer(Windmill.Timer timer) {\n       builder.setStateFamily(stateFamily);\n     }\n \n-    builder.setTimestamp(WindmillTimeUtils.harnessToWindmillTimestamp(timerData.getTimestamp()));\n-\n+    builder.setTimestamp(\n+        WindmillTimeUtils.harnessToWindmillTimestamp(timerData.getOutputTimestamp()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaca948d28dc5cfee506db999b5377adc5789333"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTQ1NjEyOnYy", "diffSide": "RIGHT", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/SimpleParDoFn.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzozMjo0OVrOGTmVCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxOTo0Njo0NFrOGTq0Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNDEwNQ==", "bodyText": "@reuvenlax, Can you guide why we are not considering outputTimestamp in WindmillTimerInternals.windmillTimerToTimerData. TimerData is created as follows:\nTimerData.of(id, familyId, namespace, timestamp, timerTypeToTimeDomain(timer.getType()));\nI think this is where we lost outputTimestamp.", "url": "https://github.com/apache/beam/pull/11350#discussion_r423204105", "createdAt": "2020-05-11T17:32:49Z", "author": {"login": "rehmanmuradali"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/SimpleParDoFn.java", "diffHunk": "@@ -397,6 +397,9 @@ private void processSystemTimer(TimerData timer) throws Exception {\n           window,\n           targetTime);\n \n+      fnRunner.onWindowExpiration(\n+          window, timer.getOutputTimestamp(), this.stepContext.stateInternals().getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda33fa7cc37ed80acc0ae6e722b873d52646853"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI3MTU3MA==", "bodyText": "Why do we need the output timestamp in onWindowExpiration?", "url": "https://github.com/apache/beam/pull/11350#discussion_r423271570", "createdAt": "2020-05-11T19:34:48Z", "author": {"login": "reuvenlax"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/SimpleParDoFn.java", "diffHunk": "@@ -397,6 +397,9 @@ private void processSystemTimer(TimerData timer) throws Exception {\n           window,\n           targetTime);\n \n+      fnRunner.onWindowExpiration(\n+          window, timer.getOutputTimestamp(), this.stepContext.stateInternals().getKey());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNDEwNQ=="}, "originalCommit": {"oid": "cda33fa7cc37ed80acc0ae6e722b873d52646853"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI3NzY0Mg==", "bodyText": "I think elements that are output on OnWindowExpiration would have a timestamp equals the output timestamp of the GC timer that's why we need it here. In the case of a window of Instant [0-10), 10 would be GC timer with an output timestamp of 9. So elements that are output from onWindowExpiration would have a timestamp of 9. @reuvenlax", "url": "https://github.com/apache/beam/pull/11350#discussion_r423277642", "createdAt": "2020-05-11T19:46:44Z", "author": {"login": "rehmanmuradali"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/SimpleParDoFn.java", "diffHunk": "@@ -397,6 +397,9 @@ private void processSystemTimer(TimerData timer) throws Exception {\n           window,\n           targetTime);\n \n+      fnRunner.onWindowExpiration(\n+          window, timer.getOutputTimestamp(), this.stepContext.stateInternals().getKey());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNDEwNQ=="}, "originalCommit": {"oid": "cda33fa7cc37ed80acc0ae6e722b873d52646853"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTY5OTMzOnYy", "diffSide": "RIGHT", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzoxNTo1M1rOGWqNGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMzoxNzozNVrOGW2tnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMzMzOA==", "bodyText": "I want to avoid the performance regression of setting a watermark hold if not needed.  Make the outputTimestamp be a parameter to this function, and pass it in only if the DoFn has an onWindowExpiration (SimpleParDoFn has the DoFnSignature so you should be able to tell there).", "url": "https://github.com/apache/beam/pull/11350#discussion_r426413338", "createdAt": "2020-05-18T07:15:53Z", "author": {"login": "reuvenlax"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -591,7 +595,7 @@ public void flushState() {\n               timerId,\n               \"\",\n               cleanupTime,\n-              cleanupTime,\n+              cleanupTime.minus(1L),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcfdd7816d9f71f7faceb7d4950a2f0c3a7d6c7d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYxODI2OQ==", "bodyText": "done", "url": "https://github.com/apache/beam/pull/11350#discussion_r426618269", "createdAt": "2020-05-18T13:17:35Z", "author": {"login": "rehmanmuradali"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -591,7 +595,7 @@ public void flushState() {\n               timerId,\n               \"\",\n               cleanupTime,\n-              cleanupTime,\n+              cleanupTime.minus(1L),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMzMzOA=="}, "originalCommit": {"oid": "bcfdd7816d9f71f7faceb7d4950a2f0c3a7d6c7d"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTcxNzA4OnYy", "diffSide": "RIGHT", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzoyMjowM1rOGWqYMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMzoxNzoxMlrOGW2skQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxNjE3Nw==", "bodyText": "I think we should only do this if there is a hold to delete.", "url": "https://github.com/apache/beam/pull/11350#discussion_r426416177", "createdAt": "2020-05-18T07:22:03Z", "author": {"login": "reuvenlax"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -552,7 +552,11 @@ public void flushState() {\n       if (!cachedFiredTimers.hasNext()) {\n         return null;\n       }\n-      return cachedFiredTimers.next();\n+      TimerData nextTimer = cachedFiredTimers.next();\n+      // system timers ( GC timer) must be explicitly deleted when delivered, to release the implied\n+      // hold.\n+      systemTimerInternals.deleteTimer(nextTimer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcfdd7816d9f71f7faceb7d4950a2f0c3a7d6c7d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYxODAwMQ==", "bodyText": "@reuvenlax done", "url": "https://github.com/apache/beam/pull/11350#discussion_r426618001", "createdAt": "2020-05-18T13:17:12Z", "author": {"login": "rehmanmuradali"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -552,7 +552,11 @@ public void flushState() {\n       if (!cachedFiredTimers.hasNext()) {\n         return null;\n       }\n-      return cachedFiredTimers.next();\n+      TimerData nextTimer = cachedFiredTimers.next();\n+      // system timers ( GC timer) must be explicitly deleted when delivered, to release the implied\n+      // hold.\n+      systemTimerInternals.deleteTimer(nextTimer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxNjE3Nw=="}, "originalCommit": {"oid": "bcfdd7816d9f71f7faceb7d4950a2f0c3a7d6c7d"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1435, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}