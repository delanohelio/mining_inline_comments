{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNzI3MTM0", "number": 13122, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMzowMDozOVrOEutHnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMzoyMDo1MlrOEutTUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDA5MTgwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMzowMDozOVrOHjR6Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNzozNzoyOFrOHkZytA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1NTU5OA==", "bodyText": "You could use _is_null_slice and _is_integer_slice here for clarity.", "url": "https://github.com/apache/beam/pull/13122#discussion_r506755598", "createdAt": "2020-10-16T23:00:39Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -32,9 +32,74 @@ def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  get = frame_base.not_implemented_method('get')\n+\n \n @frame_base.DeferredFrame._register_for(pd.Series)\n class DeferredSeries(DeferredDataFrameOrSeries):\n+  def __getitem__(self, key):\n+    if _is_null_slice(key) or key is Ellipsis:\n+      return self\n+\n+    elif (isinstance(key, int) or _is_integer_slice(key)\n+          ) and self._expr.proxy().index._should_fallback_to_positional():\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    elif isinstance(key, slice) or callable(key):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df: df[key],\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif isinstance(key, DeferredSeries):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df, indexer: df[indexer],\n+              [self._expr, key._expr],\n+              requires_partition_by=partitionings.Index(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif pd.core.series.is_iterator(key) or pd.core.common.is_bool_indexer(key):\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    else:\n+      # We could consider returning a deferred scalar, but that might\n+      # be more surprising than a clear error.\n+      raise frame_base.WontImplementError('non-deferred')\n+\n+    if isinstance(key, frame_base.DeferredBase):\n+      # Fail early if key is a DeferredBase as it interacts surprisingly with\n+      # key in self._expr.proxy().columns\n+      raise NotImplementedError(\n+          \"Indexing with a deferred frame is not yet supported. Consider \"\n+          \"using df.loc[...]\")\n+\n+    if isinstance(key, slice):\n+      types = set([type(key.start), type(key.stop), type(key.step)])\n+      if types == {type(None)}:\n+        # Empty slice is just a copy.\n+        return frame_base.DeferredFrame.wrap(self._expr)\n+      elif types in [{int}, {type(None), int}]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzMzM2NA==", "bodyText": "Ah, yes, I meant to go back and change this. Thanks.", "url": "https://github.com/apache/beam/pull/13122#discussion_r507933364", "createdAt": "2020-10-19T17:37:28Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -32,9 +32,74 @@ def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  get = frame_base.not_implemented_method('get')\n+\n \n @frame_base.DeferredFrame._register_for(pd.Series)\n class DeferredSeries(DeferredDataFrameOrSeries):\n+  def __getitem__(self, key):\n+    if _is_null_slice(key) or key is Ellipsis:\n+      return self\n+\n+    elif (isinstance(key, int) or _is_integer_slice(key)\n+          ) and self._expr.proxy().index._should_fallback_to_positional():\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    elif isinstance(key, slice) or callable(key):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df: df[key],\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif isinstance(key, DeferredSeries):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df, indexer: df[indexer],\n+              [self._expr, key._expr],\n+              requires_partition_by=partitionings.Index(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif pd.core.series.is_iterator(key) or pd.core.common.is_bool_indexer(key):\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    else:\n+      # We could consider returning a deferred scalar, but that might\n+      # be more surprising than a clear error.\n+      raise frame_base.WontImplementError('non-deferred')\n+\n+    if isinstance(key, frame_base.DeferredBase):\n+      # Fail early if key is a DeferredBase as it interacts surprisingly with\n+      # key in self._expr.proxy().columns\n+      raise NotImplementedError(\n+          \"Indexing with a deferred frame is not yet supported. Consider \"\n+          \"using df.loc[...]\")\n+\n+    if isinstance(key, slice):\n+      types = set([type(key.start), type(key.stop), type(key.step)])\n+      if types == {type(None)}:\n+        # Empty slice is just a copy.\n+        return frame_base.DeferredFrame.wrap(self._expr)\n+      elif types in [{int}, {type(None), int}]:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1NTU5OA=="}, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDExNTk3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMzoxNjo1MFrOHjSH2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNzo0MDoyM1rOHkZ7Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTEzMA==", "bodyText": "Doesn't iloc only work for a null slice? I think we should just direct users to loc iff the proxy has an integer index. If it has a non-integer index we could tell the user they're going to have a bad time (maybe eventually it would link to some documentation about the dangers of integer-location based indexing in DataframeTransform).", "url": "https://github.com/apache/beam/pull/13122#discussion_r506759130", "createdAt": "2020-10-16T23:16:50Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -32,9 +32,74 @@ def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  get = frame_base.not_implemented_method('get')\n+\n \n @frame_base.DeferredFrame._register_for(pd.Series)\n class DeferredSeries(DeferredDataFrameOrSeries):\n+  def __getitem__(self, key):\n+    if _is_null_slice(key) or key is Ellipsis:\n+      return self\n+\n+    elif (isinstance(key, int) or _is_integer_slice(key)\n+          ) and self._expr.proxy().index._should_fallback_to_positional():\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    elif isinstance(key, slice) or callable(key):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df: df[key],\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif isinstance(key, DeferredSeries):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df, indexer: df[indexer],\n+              [self._expr, key._expr],\n+              requires_partition_by=partitionings.Index(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif pd.core.series.is_iterator(key) or pd.core.common.is_bool_indexer(key):\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    else:\n+      # We could consider returning a deferred scalar, but that might\n+      # be more surprising than a clear error.\n+      raise frame_base.WontImplementError('non-deferred')\n+\n+    if isinstance(key, frame_base.DeferredBase):\n+      # Fail early if key is a DeferredBase as it interacts surprisingly with\n+      # key in self._expr.proxy().columns\n+      raise NotImplementedError(\n+          \"Indexing with a deferred frame is not yet supported. Consider \"\n+          \"using df.loc[...]\")\n+\n+    if isinstance(key, slice):\n+      types = set([type(key.start), type(key.stop), type(key.step)])\n+      if types == {type(None)}:\n+        # Empty slice is just a copy.\n+        return frame_base.DeferredFrame.wrap(self._expr)\n+      elif types in [{int}, {type(None), int}]:\n+        # This depends on the contents of the index.\n+        raise frame_base.WontImplementError(\n+            'Use iloc or loc with integer slices.')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzNTU4Mg==", "bodyText": "Eventually we may make iloc work for integer indices, but if not they'll get a better error there. The problem with directing users to loc directly is that df.loc[ix] is not a drop in replacement for df[ix] here, in fact it can be quite different, and so we need to force people to think about what they're trying to do.", "url": "https://github.com/apache/beam/pull/13122#discussion_r507935582", "createdAt": "2020-10-19T17:40:23Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -32,9 +32,74 @@ def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  get = frame_base.not_implemented_method('get')\n+\n \n @frame_base.DeferredFrame._register_for(pd.Series)\n class DeferredSeries(DeferredDataFrameOrSeries):\n+  def __getitem__(self, key):\n+    if _is_null_slice(key) or key is Ellipsis:\n+      return self\n+\n+    elif (isinstance(key, int) or _is_integer_slice(key)\n+          ) and self._expr.proxy().index._should_fallback_to_positional():\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    elif isinstance(key, slice) or callable(key):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df: df[key],\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif isinstance(key, DeferredSeries):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df, indexer: df[indexer],\n+              [self._expr, key._expr],\n+              requires_partition_by=partitionings.Index(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif pd.core.series.is_iterator(key) or pd.core.common.is_bool_indexer(key):\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    else:\n+      # We could consider returning a deferred scalar, but that might\n+      # be more surprising than a clear error.\n+      raise frame_base.WontImplementError('non-deferred')\n+\n+    if isinstance(key, frame_base.DeferredBase):\n+      # Fail early if key is a DeferredBase as it interacts surprisingly with\n+      # key in self._expr.proxy().columns\n+      raise NotImplementedError(\n+          \"Indexing with a deferred frame is not yet supported. Consider \"\n+          \"using df.loc[...]\")\n+\n+    if isinstance(key, slice):\n+      types = set([type(key.start), type(key.stop), type(key.step)])\n+      if types == {type(None)}:\n+        # Empty slice is just a copy.\n+        return frame_base.DeferredFrame.wrap(self._expr)\n+      elif types in [{int}, {type(None), int}]:\n+        # This depends on the contents of the index.\n+        raise frame_base.WontImplementError(\n+            'Use iloc or loc with integer slices.')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTEzMA=="}, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDEyMTc4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMzoyMDo1MlrOHjSLJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNzo0NzozNlrOHkaWuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTk3Mw==", "bodyText": "Should we have this logic in DeferredSeries.__getitem__ too?", "url": "https://github.com/apache/beam/pull/13122#discussion_r506759973", "createdAt": "2020-10-16T23:20:52Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -453,17 +518,31 @@ def __getattr__(self, name):\n \n   def __getitem__(self, key):\n     # TODO: Replicate pd.DataFrame.__getitem__ logic\n-    if isinstance(key, frame_base.DeferredBase):\n+    if isinstance(key, DeferredSeries) and key._expr.proxy().dtype == bool:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk0MjU4Nw==", "bodyText": "Ah, yes, done.", "url": "https://github.com/apache/beam/pull/13122#discussion_r507942587", "createdAt": "2020-10-19T17:47:36Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -453,17 +518,31 @@ def __getattr__(self, name):\n \n   def __getitem__(self, key):\n     # TODO: Replicate pd.DataFrame.__getitem__ logic\n-    if isinstance(key, frame_base.DeferredBase):\n+    if isinstance(key, DeferredSeries) and key._expr.proxy().dtype == bool:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTk3Mw=="}, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3001, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}