{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1MDU1NjYz", "number": 13611, "title": "[BEAM-9615] Custom Schema Coder Support", "bodyText": "Adds \"custom schema coder\" support. I believe Python and Java call these providers, but that's not exactly what's happening in the Go SDK.\nThis PR adds the ability to register a factory function for schema coder functions for a given type. This enables overriding the default behavior for Go types in the schema coders with a custom one, for the type itself, or any matching interface.\nTo ensure users can write custom schema coders, a testing utility has been added to validate the factory functions, and ensure the coders encode to a valid schema equivalent type.\nBenchmarks were added to demonstrate the umbrella helper coder functions, using a custom coder function, registering a custom coder function, and comparing to the equivalent we use for JSON encoding at present.\nThere are more details to work on here, but this moves everything closer to having fields of an umbrella type be encoded properly without breaking things, eg. for hanlding proto fields, which aren't encoded as proper JSON.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\nTypescript\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-12-23T22:32:42Z", "url": "https://github.com/apache/beam/pull/13611", "merged": true, "mergeCommit": {"oid": "2ceef2d8955017ac4d5b3f0a069811f05f7131f2"}, "closed": true, "closedAt": "2020-12-28T22:23:31Z", "author": {"login": "lostluck"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdpGoE0AH2gAyNTQ1MDU1NjYzOjZjOGM4MDBkNzk5NGZjNTAzMTRiNTRhNjkxYTM1MTVmYzhkNzFiODk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdqtqKTAH2gAyNTQ1MDU1NjYzOjAzNzA0NjBhYjczNTAzOWEyNTU3NzczOWZhY2Q4NzhjYzU2Njk4Nzg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6c8c800d7994fc50314b54a691a3515fc8d71b89", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/6c8c800d7994fc50314b54a691a3515fc8d71b89", "committedDate": "2020-12-23T22:11:20Z", "message": "[BEAM-9615] Custom Schema Coder Support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4Mjg5MTI0", "url": "https://github.com/apache/beam/pull/13611#pullrequestreview-558289124", "createdAt": "2020-12-24T00:59:52Z", "commit": {"oid": "6c8c800d7994fc50314b54a691a3515fc8d71b89"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDo1OTo1MlrOIK7znw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMjoyNDo0NFrOIK800A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMzNjU0Mw==", "bodyText": "Nit: This seems like a good candidate for a reflectDecodeBytes helper function like the others above.", "url": "https://github.com/apache/beam/pull/13611#discussion_r548336543", "createdAt": "2020-12-24T00:59:52Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/coder/row_decoder.go", "diffHunk": "@@ -0,0 +1,275 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+// RowDecoderBuilder allows one to build Beam Schema row encoders for provided types.\n+type RowDecoderBuilder struct {\n+\tallFuncs   map[reflect.Type]decoderProvider\n+\tifaceFuncs []reflect.Type\n+}\n+\n+type decoderProvider = func(reflect.Type) (func(io.Reader) (interface{}, error), error)\n+\n+// Register accepts a provider to decode schema encoded values\n+// of that type.\n+//\n+// When decoding values, decoder functions produced by this builder will\n+// first check for exact type matches, then interfaces implemented by\n+// the type in recency order of registration, and then finally the\n+// default Beam Schema encoding behavior.\n+//\n+// TODO(BEAM-9615): Add final factory types. This interface is subject to change.\n+// Currently f must be a function  func(reflect.Type) (func(io.Reader) (interface{}, error), error)\n+func (b *RowDecoderBuilder) Register(rt reflect.Type, f interface{}) {\n+\tfd, ok := f.(decoderProvider)\n+\tif !ok {\n+\t\tpanic(fmt.Sprintf(\"%v isn't a supported decoder function type (passed with %T)\", f, rt))\n+\t}\n+\n+\tif rt.Kind() == reflect.Interface && rt.NumMethod() == 0 {\n+\t\tpanic(fmt.Sprintf(\"interface type %v must have methods\", rt))\n+\t}\n+\n+\tif b.allFuncs == nil {\n+\t\tb.allFuncs = make(map[reflect.Type]decoderProvider)\n+\t}\n+\tb.allFuncs[rt] = fd\n+\tif rt.Kind() == reflect.Interface {\n+\t\tb.ifaceFuncs = append(b.ifaceFuncs, rt)\n+\t}\n+}\n+\n+// Build constructs a Beam Schema coder for the given type, using any providers registered for\n+// itself or it's fields.\n+func (b *RowDecoderBuilder) Build(rt reflect.Type) (func(io.Reader) (interface{}, error), error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn b.decoderForType(rt), nil\n+}\n+\n+// decoderForType returns a decoder function for the struct or pointer to struct type.\n+func (b *RowDecoderBuilder) decoderForType(t reflect.Type) func(io.Reader) (interface{}, error) {\n+\t// Check if there are any providers registered for this type, or that this type adheres to any interfaces.\n+\tif f := b.customFunc(t); f != nil {\n+\t\treturn f\n+\t}\n+\n+\tvar isPtr bool\n+\t// Pointers become the value type for decomposition.\n+\tif t.Kind() == reflect.Ptr {\n+\t\tisPtr = true\n+\t\tt = t.Elem()\n+\t}\n+\tdec := b.decoderForStructReflect(t)\n+\n+\tif isPtr {\n+\t\treturn func(r io.Reader) (interface{}, error) {\n+\t\t\trv := reflect.New(t)\n+\t\t\terr := dec(rv.Elem(), r)\n+\t\t\treturn rv.Interface(), err\n+\t\t}\n+\t}\n+\treturn func(r io.Reader) (interface{}, error) {\n+\t\trv := reflect.New(t)\n+\t\terr := dec(rv.Elem(), r)\n+\t\treturn rv.Elem().Interface(), err\n+\t}\n+}\n+\n+// decoderForStructReflect returns a reflection based decoder function for the\n+// given struct type.\n+func (b *RowDecoderBuilder) decoderForStructReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\tvar coder typeDecoderReflect\n+\tfor i := 0; i < t.NumField(); i++ {\n+\t\ti := i // avoid alias issues in the closures.\n+\t\tdec := b.decoderForSingleTypeReflect(t.Field(i).Type)\n+\t\tcoder.fields = append(coder.fields, func(rv reflect.Value, r io.Reader) error {\n+\t\t\treturn dec(rv.Field(i), r)\n+\t\t})\n+\t}\n+\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\tnf, nils, err := ReadRowHeader(r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif nf != len(coder.fields) {\n+\t\t\treturn errors.Errorf(\"schema[%v] changed: got %d fields, want %d fields\", \"TODO\", nf, len(coder.fields))\n+\t\t}\n+\t\tfor i, f := range coder.fields {\n+\t\t\tif IsFieldNil(nils, i) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err := f(rv, r); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t}\n+}\n+\n+func reflectDecodeBool(rv reflect.Value, r io.Reader) error {\n+\tv, err := DecodeBool(r)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"error decoding bool field\")\n+\t}\n+\trv.SetBool(v)\n+\treturn nil\n+}\n+\n+func reflectDecodeByte(rv reflect.Value, r io.Reader) error {\n+\tb, err := DecodeByte(r)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"error decoding single byte field\")\n+\t}\n+\trv.SetUint(uint64(b))\n+\treturn nil\n+}\n+\n+func reflectDecodeString(rv reflect.Value, r io.Reader) error {\n+\tv, err := DecodeStringUTF8(r)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"error decoding string field\")\n+\t}\n+\trv.SetString(v)\n+\treturn nil\n+}\n+\n+func reflectDecodeInt(rv reflect.Value, r io.Reader) error {\n+\tv, err := DecodeVarInt(r)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"error decoding varint field\")\n+\t}\n+\trv.SetInt(v)\n+\treturn nil\n+}\n+\n+func reflectDecodeFloat(rv reflect.Value, r io.Reader) error {\n+\tv, err := DecodeDouble(r)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"error decoding double field\")\n+\t}\n+\trv.SetFloat(v)\n+\treturn nil\n+}\n+\n+// customFunc returns nil if no custom func exists for this.\n+func (b *RowDecoderBuilder) customFunc(t reflect.Type) func(io.Reader) (interface{}, error) {\n+\tif fact, ok := b.allFuncs[t]; ok {\n+\t\tf, err := fact(t)\n+\n+\t\t// TODO handle errors?\n+\t\tif err != nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn f\n+\t}\n+\t// Check satisfaction of interface types in reverse registration order.\n+\tfor i := len(b.ifaceFuncs) - 1; i >= 0; i-- {\n+\t\tit := b.ifaceFuncs[i]\n+\t\tif ok := t.AssignableTo(it); ok {\n+\t\t\tif fact, ok := b.allFuncs[it]; ok {\n+\t\t\t\tf, err := fact(t)\n+\t\t\t\t// TODO handle errors?\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t\treturn f\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// decoderForSingleTypeReflect returns a reflection based decoder function for the\n+// given type.\n+func (b *RowDecoderBuilder) decoderForSingleTypeReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\t// Check if there are any providers registered for this type, or that this type adheres to any interfaces.\n+\tif dec := b.customFunc(t); dec != nil {\n+\t\treturn func(v reflect.Value, r io.Reader) error {\n+\t\t\telm, err := dec(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tv.Set(reflect.ValueOf(elm))\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\tswitch t.Kind() {\n+\tcase reflect.Struct:\n+\t\treturn b.decoderForStructReflect(t)\n+\tcase reflect.Bool:\n+\t\treturn reflectDecodeBool\n+\tcase reflect.Uint8:\n+\t\treturn reflectDecodeByte\n+\tcase reflect.String:\n+\t\treturn reflectDecodeString\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\treturn reflectDecodeInt\n+\tcase reflect.Float32, reflect.Float64:\n+\t\treturn reflectDecodeFloat\n+\tcase reflect.Ptr:\n+\t\tdecf := b.decoderForSingleTypeReflect(t.Elem())\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tnv := reflect.New(t.Elem())\n+\t\t\trv.Set(nv)\n+\t\t\treturn decf(nv.Elem(), r)\n+\t\t}\n+\tcase reflect.Slice:\n+\t\t// Special case handling for byte slices.\n+\t\tif t.Elem().Kind() == reflect.Uint8 {\n+\t\t\treturn func(rv reflect.Value, r io.Reader) error {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c8c800d7994fc50314b54a691a3515fc8d71b89"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMzODExOQ==", "bodyText": "What's the purpose for allFuncs to contain decoderProvider instead of func(io.Reader) (interface{}, error) directly? Is it to allow for interface types? Like the decoderProvider for an interface type would return different decoders by being passed a concrete type?", "url": "https://github.com/apache/beam/pull/13611#discussion_r548338119", "createdAt": "2020-12-24T01:08:06Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/coder/row_decoder.go", "diffHunk": "@@ -0,0 +1,275 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+// RowDecoderBuilder allows one to build Beam Schema row encoders for provided types.\n+type RowDecoderBuilder struct {\n+\tallFuncs   map[reflect.Type]decoderProvider\n+\tifaceFuncs []reflect.Type\n+}\n+\n+type decoderProvider = func(reflect.Type) (func(io.Reader) (interface{}, error), error)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c8c800d7994fc50314b54a691a3515fc8d71b89"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMzODcxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tpanic(fmt.Sprintf(\"%v isn't a supported decoder function type (passed with %T)\", f, rt))\n          \n          \n            \n            \t\tpanic(fmt.Sprintf(\"%v isn't a supported encoder function type (passed with %T)\", f, rt))", "url": "https://github.com/apache/beam/pull/13611#discussion_r548338714", "createdAt": "2020-12-24T01:11:25Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/coder/row_encoder.go", "diffHunk": "@@ -0,0 +1,231 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+type encoderProvider = func(reflect.Type) (func(interface{}, io.Writer) error, error)\n+\n+// RowEncoderBuilder allows one to build Beam Schema row encoders for provided types.\n+type RowEncoderBuilder struct {\n+\tallFuncs   map[reflect.Type]encoderProvider\n+\tifaceFuncs []reflect.Type\n+}\n+\n+// Register accepts a provider for the given type to schema encode values of that type.\n+//\n+// When generating encoding functions, this builder will first check for exact type\n+// matches, then against interfaces with registered factories in recency order of\n+// registration, and then finally use the default Beam Schema encoding behavior.\n+//\n+// TODO(BEAM-9615): Add final factory types. This interface is subject to change.\n+// Currently f must be a function of the type func(reflect.Type) func(T, io.Writer) (error).\n+func (b *RowEncoderBuilder) Register(rt reflect.Type, f interface{}) {\n+\tfe, ok := f.(encoderProvider)\n+\tif !ok {\n+\t\tpanic(fmt.Sprintf(\"%v isn't a supported decoder function type (passed with %T)\", f, rt))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c8c800d7994fc50314b54a691a3515fc8d71b89"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0ODIwMg==", "bodyText": "This line reads like the parameter values shouldn't be a slice, but if I'm reading the code correctly it's supposed to mean that each element in values must be a single struct or pointer to struct. I recommend rephrasing it along these lines:\n\nValues must be either a struct, pointer to struct, or a slice where each element is a struct or pointer to struct.", "url": "https://github.com/apache/beam/pull/13611#discussion_r548348202", "createdAt": "2020-12-24T01:59:27Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/coder/testutil/testutil.go", "diffHunk": "@@ -0,0 +1,136 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package testutil contains helpers to test and validate custom Beam Schema coders.\n+package testutil\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/google/go-cmp/cmp\"\n+)\n+\n+// SchemaCoder helps validate custom schema coders.\n+type SchemaCoder struct {\n+\tencBldUT, encBldSchema coder.RowEncoderBuilder\n+\tdecBldUT, decBldSchema coder.RowDecoderBuilder\n+\n+\t// CmpOptions to pass into the round trip comparison\n+\tCmpOptions cmp.Options\n+}\n+\n+// Register adds additional custom types not under test to both the under test\n+// and default schema coders.\n+func (v *SchemaCoder) Register(rt reflect.Type, encF, decF interface{}) {\n+\tv.encBldUT.Register(rt, encF)\n+\tv.encBldSchema.Register(rt, encF)\n+\tv.decBldUT.Register(rt, decF)\n+\tv.decBldSchema.Register(rt, decF)\n+}\n+\n+// Validate is a test utility to validate custom schema coders generate\n+// beam schema encoded bytes.\n+//\n+// Validate accepts the reflect.Type to register, factory functions for encoding and decoding, an\n+// anonymous struct type equivalent to the encoded format produced and consumed by the factory produced functions\n+// and test values. Values must be a single struct or pointer to struct.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c8c800d7994fc50314b54a691a3515fc8d71b89"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1MTExMg==", "bodyText": "Does reading from the buffer (a few lines above with decSchema) remove those bytes from the buffer (or otherwise prevent those bytes from being cloned)? Because on first read it seems like roundTripBytes below will contain the element's bytes twice, the first copied from initialBytes, and the second from encSchema here.", "url": "https://github.com/apache/beam/pull/13611#discussion_r548351112", "createdAt": "2020-12-24T02:14:12Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/coder/testutil/testutil.go", "diffHunk": "@@ -0,0 +1,136 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package testutil contains helpers to test and validate custom Beam Schema coders.\n+package testutil\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/google/go-cmp/cmp\"\n+)\n+\n+// SchemaCoder helps validate custom schema coders.\n+type SchemaCoder struct {\n+\tencBldUT, encBldSchema coder.RowEncoderBuilder\n+\tdecBldUT, decBldSchema coder.RowDecoderBuilder\n+\n+\t// CmpOptions to pass into the round trip comparison\n+\tCmpOptions cmp.Options\n+}\n+\n+// Register adds additional custom types not under test to both the under test\n+// and default schema coders.\n+func (v *SchemaCoder) Register(rt reflect.Type, encF, decF interface{}) {\n+\tv.encBldUT.Register(rt, encF)\n+\tv.encBldSchema.Register(rt, encF)\n+\tv.decBldUT.Register(rt, decF)\n+\tv.decBldSchema.Register(rt, decF)\n+}\n+\n+// Validate is a test utility to validate custom schema coders generate\n+// beam schema encoded bytes.\n+//\n+// Validate accepts the reflect.Type to register, factory functions for encoding and decoding, an\n+// anonymous struct type equivalent to the encoded format produced and consumed by the factory produced functions\n+// and test values. Values must be a single struct or pointer to struct.\n+//\n+// TODO(lostluck): Improve documentation.\n+// TODO(lostluck): Abstract into a configurable struct, to handle\n+//\n+// Validate will register the under test factories and generate an encoder and decoder function.\n+// These functions will be re-used for all test values. This emulates coders being re-used for all\n+// elements within a bundle.\n+//\n+// Validate mutates the SchemaCoderValidator, so the SchemaCoderValidator may not be used more than once.\n+func (v *SchemaCoder) Validate(t *testing.T, rt reflect.Type, encF, decF, schema interface{}, values interface{}) {\n+\tt.Helper()\n+\ttestValues := reflect.ValueOf(values)\n+\t// Check whether we have a slice type or not.\n+\tif testValues.Type().Kind() != reflect.Slice {\n+\t\tvs := reflect.MakeSlice(reflect.SliceOf(testValues.Type()), 0, 1)\n+\t\ttestValues = reflect.Append(vs, testValues)\n+\t}\n+\tif testValues.Len() == 0 {\n+\t\tt.Fatalf(\"No test values provided for ValidateSchemaCoder(%v)\", rt)\n+\t}\n+\t// We now have non empty slice of test values!\n+\n+\tv.encBldUT.Register(rt, encF)\n+\tv.decBldUT.Register(rt, decF)\n+\n+\ttestRt := testValues.Type().Elem()\n+\tencUT, err := v.encBldUT.Build(testRt)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to build encoder function with given factory: coder.RowEncoderBuilder.Build(%v) = %v, want nil error\", rt, err)\n+\t}\n+\tdecUT, err := v.decBldUT.Build(testRt)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to build decoder function with given factory: coder.RowDecoderBuilder.Build(%v) = %v, want nil error\", rt, err)\n+\t}\n+\n+\tschemaRt := reflect.TypeOf(schema)\n+\tencSchema, err := v.encBldSchema.Build(schemaRt)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to build encoder function for schema equivalent type: coder.RowEncoderBuilder.Build(%v) = %v, want nil error\", rt, err)\n+\t}\n+\tdecSchema, err := v.decBldSchema.Build(schemaRt)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to build decoder function for schema equivalent type: coder.RowDecoderBuilder.Build(%v) = %v, want nil error\", rt, err)\n+\t}\n+\tfor i := 0; i < testValues.Len(); i++ {\n+\t\tt.Run(fmt.Sprintf(\"%v[%d]\", rt, i), func(t *testing.T) {\n+\t\t\tvar buf bytes.Buffer\n+\t\t\twant := testValues.Index(i).Interface()\n+\t\t\tif err := encUT(want, &buf); err != nil {\n+\t\t\t\tt.Fatalf(\"error calling Under Test encoder[%v](%v) = %v\", testRt, want, err)\n+\t\t\t}\n+\t\t\tinitialBytes := clone(buf.Bytes())\n+\n+\t\t\tbufSchema := bytes.NewBuffer(clone(initialBytes))\n+\n+\t\t\tschemaV, err := decSchema(bufSchema)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"error calling Equivalent Schema decoder[%v]() = %v\", schemaRt, err)\n+\t\t\t}\n+\t\t\terr = encSchema(schemaV, bufSchema)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c8c800d7994fc50314b54a691a3515fc8d71b89"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1MTQ4Mg==", "bodyText": "Typo: Unfinished comment.", "url": "https://github.com/apache/beam/pull/13611#discussion_r548351482", "createdAt": "2020-12-24T02:16:02Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/coder/testutil/testutil_test.go", "diffHunk": "@@ -0,0 +1,126 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package testutil\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+)\n+\n+type UserInterface interface {\n+\tmark()\n+}\n+\n+type UserType1 struct {\n+\tA string\n+\tB int\n+\tC string\n+}\n+\n+func (UserType1) mark() {}\n+\n+func ut1EncDropB(val interface{}, w io.Writer) error {\n+\tif err := coder.WriteSimpleRowHeader(2, w); err != nil {\n+\t\treturn err\n+\t}\n+\telm := val.(UserType1)\n+\tif err := coder.EncodeStringUTF8(elm.A, w); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := coder.EncodeStringUTF8(elm.C, w); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func ut1DecDropB(r io.Reader) (interface{}, error) {\n+\tif err := coder.ReadSimpleRowHeader(2, r); err != nil {\n+\t\treturn nil, err\n+\t}\n+\ta, err := coder.DecodeStringUTF8(r)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"decoding string field A: %w\", err)\n+\t}\n+\tc, err := coder.DecodeStringUTF8(r)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"decoding string field C: %v, %w\", c, err)\n+\t}\n+\treturn UserType1{\n+\t\tA: a,\n+\t\tB: 42,\n+\t\tC: c,\n+\t}, nil\n+}\n+\n+// TestValidateCoder_SingleValue checks that the validate coder fun will", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c8c800d7994fc50314b54a691a3515fc8d71b89"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1MzIzMg==", "bodyText": "Suggestion: You could probably add a test for the failure case though you'll need to do some refactoring on the Validate function. Basically just have an inner function that's the current implementation but doesn't use *testing.T and instead returns an error if something went wrong and make the current exported Validate function call that and do t.Fatalf if an error appears. With that refactor, you can add a test that calls the inner function with an element that doesn't have 42 for B, so you can validate that it fails when expected.", "url": "https://github.com/apache/beam/pull/13611#discussion_r548353232", "createdAt": "2020-12-24T02:24:44Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/coder/testutil/testutil_test.go", "diffHunk": "@@ -0,0 +1,126 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package testutil\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+)\n+\n+type UserInterface interface {\n+\tmark()\n+}\n+\n+type UserType1 struct {\n+\tA string\n+\tB int\n+\tC string\n+}\n+\n+func (UserType1) mark() {}\n+\n+func ut1EncDropB(val interface{}, w io.Writer) error {\n+\tif err := coder.WriteSimpleRowHeader(2, w); err != nil {\n+\t\treturn err\n+\t}\n+\telm := val.(UserType1)\n+\tif err := coder.EncodeStringUTF8(elm.A, w); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := coder.EncodeStringUTF8(elm.C, w); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func ut1DecDropB(r io.Reader) (interface{}, error) {\n+\tif err := coder.ReadSimpleRowHeader(2, r); err != nil {\n+\t\treturn nil, err\n+\t}\n+\ta, err := coder.DecodeStringUTF8(r)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"decoding string field A: %w\", err)\n+\t}\n+\tc, err := coder.DecodeStringUTF8(r)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"decoding string field C: %v, %w\", c, err)\n+\t}\n+\treturn UserType1{\n+\t\tA: a,\n+\t\tB: 42,\n+\t\tC: c,\n+\t}, nil\n+}\n+\n+// TestValidateCoder_SingleValue checks that the validate coder fun will\n+func TestValidateCoder(t *testing.T) {\n+\t// Validates a custom UserType1 encoding, which drops encoding the \"B\" field,\n+\t// always setting it to a constant value.\n+\tt.Run(\"SingleValue\", func(t *testing.T) {\n+\t\t(&SchemaCoder{}).Validate(t, reflect.TypeOf((*UserType1)(nil)).Elem(),\n+\t\t\tfunc(reflect.Type) (func(interface{}, io.Writer) error, error) { return ut1EncDropB, nil },\n+\t\t\tfunc(reflect.Type) (func(io.Reader) (interface{}, error), error) { return ut1DecDropB, nil },\n+\t\t\tstruct{ A, C string }{},\n+\t\t\tUserType1{\n+\t\t\t\tA: \"cats\",\n+\t\t\t\tB: 42,\n+\t\t\t\tC: \"pjamas\",\n+\t\t\t},\n+\t\t)\n+\t})\n+\tt.Run(\"SliceOfValues\", func(t *testing.T) {\n+\t\t(&SchemaCoder{}).Validate(t, reflect.TypeOf((*UserType1)(nil)).Elem(),\n+\t\t\tfunc(reflect.Type) (func(interface{}, io.Writer) error, error) { return ut1EncDropB, nil },\n+\t\t\tfunc(reflect.Type) (func(io.Reader) (interface{}, error), error) { return ut1DecDropB, nil },\n+\t\t\tstruct{ A, C string }{},\n+\t\t\t[]UserType1{\n+\t\t\t\t{\n+\t\t\t\t\tA: \"cats\",\n+\t\t\t\t\tB: 42,\n+\t\t\t\t\tC: \"pjamas\",\n+\t\t\t\t}, {\n+\t\t\t\t\tA: \"dogs\",\n+\t\t\t\t\tB: 42,\n+\t\t\t\t\tC: \"breakfast\",\n+\t\t\t\t}, {\n+\t\t\t\t\tA: \"fish\",\n+\t\t\t\t\tB: 42,\n+\t\t\t\t\tC: \"plenty of\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t)\n+\t})\n+\tt.Run(\"InterfaceCoder\", func(t *testing.T) {\n+\t\t(&SchemaCoder{}).Validate(t, reflect.TypeOf((*UserInterface)(nil)).Elem(),\n+\t\t\tfunc(rt reflect.Type) (func(interface{}, io.Writer) error, error) {\n+\t\t\t\treturn ut1EncDropB, nil\n+\t\t\t},\n+\t\t\tfunc(rt reflect.Type) (func(io.Reader) (interface{}, error), error) {\n+\t\t\t\treturn ut1DecDropB, nil\n+\t\t\t},\n+\t\t\tstruct{ A, C string }{},\n+\t\t\tUserType1{\n+\t\t\t\tA: \"cats\",\n+\t\t\t\tB: 42,\n+\t\t\t\tC: \"pjamas\",\n+\t\t\t},\n+\t\t)\n+\t})\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c8c800d7994fc50314b54a691a3515fc8d71b89"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72a92f7317ba6455fe7368426f600f900022af02", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/72a92f7317ba6455fe7368426f600f900022af02", "committedDate": "2020-12-28T21:51:54Z", "message": "!fixup plumb custom errors, verify validator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1b2b2af69c7fa64a1b5090ce3100b769d196cf0", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/a1b2b2af69c7fa64a1b5090ce3100b769d196cf0", "committedDate": "2020-12-28T22:12:48Z", "message": "!fixup remove %w verbs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0370460ab735039a25577739facd878cc5669878", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/0370460ab735039a25577739facd878cc5669878", "committedDate": "2020-12-28T22:13:50Z", "message": "!fixup remove %w verbs"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4259, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}