{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MzAyOTA1", "number": 13141, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOToxOToyMVrOEyg1hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTo1MDoyMFrOEyhvWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDAyMjQ3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOToxOToyMVrOHpMwdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoxOTo0MVrOHp3sQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MjY3Ng==", "bodyText": "Is this safe to implement with elementwise_method? (need to justify this to myself)\nI think it will work for most cases.. the resulting expression will require partitionings.Index since we do that if any arg is a DeferredBase, and other should always be one. That should handle axis='index'. Also all of the join modes should work as intended within Index partitions.\nI think actually for axis='columns' Index partitioning is too restrictive. We could do that without any partitioning. Is that right?\nLooking at the remaining args:\n\ncopy: I think copy=False won't work since we can't predict if the operation is inplace or not, it depends on the data.\nfill_value: Works trivially\nmethod: non-default options are order-sensitive\nlimit: I don't think we can support this correctly right now without Singleton partitioning\nlevel, fill_axis, broadcast_axis: I'm not actually sure what these are doing.\n\nCan we reject the options that won't work?", "url": "https://github.com/apache/beam/pull/13141#discussion_r512962676", "createdAt": "2020-10-27T19:19:21Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -575,6 +575,8 @@ def __setitem__(self, key, value):\n     else:\n       raise NotImplementedError(key)\n \n+  align = frame_base._elementwise_method('align')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NjExNQ==", "bodyText": "Good call. Done.", "url": "https://github.com/apache/beam/pull/13141#discussion_r513666115", "createdAt": "2020-10-28T18:19:41Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -575,6 +575,8 @@ def __setitem__(self, key, value):\n     else:\n       raise NotImplementedError(key)\n \n+  align = frame_base._elementwise_method('align')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MjY3Ng=="}, "originalCommit": {"oid": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDE0MzkyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTo0NTozMlrOHpN82w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoxOTo1MlrOHp3ssA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MjIzNQ==", "bodyText": "It looks like method is actually the only kwarg that overlaps between corr and corrwith. We should probably pass that explicitly, and handle the remaining arg, drop, here.", "url": "https://github.com/apache/beam/pull/13141#discussion_r512982235", "createdAt": "2020-10-27T19:45:32Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -771,6 +773,62 @@ def fill_matrix(*args):\n               requires_partition_by=partitionings.Singleton(),\n               proxy=proxy))\n \n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def corrwith(self, other, axis, **kwargs):\n+    if axis not in (0, 'index'):\n+      raise NotImplementedError('corrwith(axis=%r)' % axis)\n+    if not isinstance(other, frame_base.DeferredFrame):\n+      other = frame_base.DeferredFrame.wrap(\n+          expressions.ConstantExpression(other))\n+\n+    if isinstance(other, DeferredSeries):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      corrs = [self[col].corr(other, **kwargs) for col in proxy.index]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NjIyNA==", "bodyText": "Resolved.", "url": "https://github.com/apache/beam/pull/13141#discussion_r513666224", "createdAt": "2020-10-28T18:19:52Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -771,6 +773,62 @@ def fill_matrix(*args):\n               requires_partition_by=partitionings.Singleton(),\n               proxy=proxy))\n \n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def corrwith(self, other, axis, **kwargs):\n+    if axis not in (0, 'index'):\n+      raise NotImplementedError('corrwith(axis=%r)' % axis)\n+    if not isinstance(other, frame_base.DeferredFrame):\n+      other = frame_base.DeferredFrame.wrap(\n+          expressions.ConstantExpression(other))\n+\n+    if isinstance(other, DeferredSeries):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      corrs = [self[col].corr(other, **kwargs) for col in proxy.index]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MjIzNQ=="}, "originalCommit": {"oid": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDE1NzE0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTo0ODoxNlrOHpOFOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoyMDowNlrOHp3tTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4NDM3Ng==", "bodyText": "nit: The two branches here are almost identical, the only difference is valid_cols vs. proxy.index. You might consider re-working this so the other logic is shared. That might just make it more confusing though... up to you.", "url": "https://github.com/apache/beam/pull/13141#discussion_r512984376", "createdAt": "2020-10-27T19:48:16Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -771,6 +773,62 @@ def fill_matrix(*args):\n               requires_partition_by=partitionings.Singleton(),\n               proxy=proxy))\n \n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def corrwith(self, other, axis, **kwargs):\n+    if axis not in (0, 'index'):\n+      raise NotImplementedError('corrwith(axis=%r)' % axis)\n+    if not isinstance(other, frame_base.DeferredFrame):\n+      other = frame_base.DeferredFrame.wrap(\n+          expressions.ConstantExpression(other))\n+\n+    if isinstance(other, DeferredSeries):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      corrs = [self[col].corr(other, **kwargs) for col in proxy.index]\n+      def fill_dataframe(*args):\n+        result = proxy.copy(deep=True)\n+        for col, value in zip(proxy.index, args):\n+          result[col] = value\n+        return result\n+      with expressions.allow_non_parallel_operations(True):\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+            'fill_dataframe',\n+            fill_dataframe,\n+            [corr._expr for corr in corrs],\n+            requires_partition_by=partitionings.Singleton(),\n+            proxy=proxy))\n+\n+    elif isinstance(other, DeferredDataFrame):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      valid_cols = list(\n+          set(self.columns)\n+          .intersection(other.columns)\n+          .intersection(proxy.index))\n+      corrs = [self[col].corr(other[col], **kwargs) for col in valid_cols]\n+      def fill_dataframe(*args):\n+        result = proxy.copy(deep=True)\n+        for col, value in zip(valid_cols, args):\n+          result[col] = value\n+        return result\n+      with expressions.allow_non_parallel_operations(True):\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+            'fill_dataframe',\n+            fill_dataframe,\n+            [corr._expr for corr in corrs],\n+            requires_partition_by=partitionings.Singleton(),\n+            proxy=proxy))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NjM4Mw==", "bodyText": "I've consolidated them now.", "url": "https://github.com/apache/beam/pull/13141#discussion_r513666383", "createdAt": "2020-10-28T18:20:06Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -771,6 +773,62 @@ def fill_matrix(*args):\n               requires_partition_by=partitionings.Singleton(),\n               proxy=proxy))\n \n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def corrwith(self, other, axis, **kwargs):\n+    if axis not in (0, 'index'):\n+      raise NotImplementedError('corrwith(axis=%r)' % axis)\n+    if not isinstance(other, frame_base.DeferredFrame):\n+      other = frame_base.DeferredFrame.wrap(\n+          expressions.ConstantExpression(other))\n+\n+    if isinstance(other, DeferredSeries):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      corrs = [self[col].corr(other, **kwargs) for col in proxy.index]\n+      def fill_dataframe(*args):\n+        result = proxy.copy(deep=True)\n+        for col, value in zip(proxy.index, args):\n+          result[col] = value\n+        return result\n+      with expressions.allow_non_parallel_operations(True):\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+            'fill_dataframe',\n+            fill_dataframe,\n+            [corr._expr for corr in corrs],\n+            requires_partition_by=partitionings.Singleton(),\n+            proxy=proxy))\n+\n+    elif isinstance(other, DeferredDataFrame):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      valid_cols = list(\n+          set(self.columns)\n+          .intersection(other.columns)\n+          .intersection(proxy.index))\n+      corrs = [self[col].corr(other[col], **kwargs) for col in valid_cols]\n+      def fill_dataframe(*args):\n+        result = proxy.copy(deep=True)\n+        for col, value in zip(valid_cols, args):\n+          result[col] = value\n+        return result\n+      with expressions.allow_non_parallel_operations(True):\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+            'fill_dataframe',\n+            fill_dataframe,\n+            [corr._expr for corr in corrs],\n+            requires_partition_by=partitionings.Singleton(),\n+            proxy=proxy))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4NDM3Ng=="}, "originalCommit": {"oid": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDE3MDQ5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTo1MDoyMFrOHpONkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTo1MDoyMFrOHpONkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4NjUxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  corrs = [self[col].corr(other[col], **kwargs) for col in valid_cols]\n          \n          \n            \n                  def fill_dataframe(*args):\n          \n          \n            \n                  # Generate expressions to compute the actual correlations\n          \n          \n            \n                  corrs = [self[col].corr(other[col], **kwargs) for col in valid_cols]\n          \n          \n            \n                  # Combine the results\n          \n          \n            \n                  def fill_dataframe(*args):\n          \n      \n    \n    \n  \n\nIt took me a while to realize this is what was going on, hopefully this will expedite it for future readers.", "url": "https://github.com/apache/beam/pull/13141#discussion_r512986512", "createdAt": "2020-10-27T19:50:20Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -771,6 +773,62 @@ def fill_matrix(*args):\n               requires_partition_by=partitionings.Singleton(),\n               proxy=proxy))\n \n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def corrwith(self, other, axis, **kwargs):\n+    if axis not in (0, 'index'):\n+      raise NotImplementedError('corrwith(axis=%r)' % axis)\n+    if not isinstance(other, frame_base.DeferredFrame):\n+      other = frame_base.DeferredFrame.wrap(\n+          expressions.ConstantExpression(other))\n+\n+    if isinstance(other, DeferredSeries):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      corrs = [self[col].corr(other, **kwargs) for col in proxy.index]\n+      def fill_dataframe(*args):\n+        result = proxy.copy(deep=True)\n+        for col, value in zip(proxy.index, args):\n+          result[col] = value\n+        return result\n+      with expressions.allow_non_parallel_operations(True):\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+            'fill_dataframe',\n+            fill_dataframe,\n+            [corr._expr for corr in corrs],\n+            requires_partition_by=partitionings.Singleton(),\n+            proxy=proxy))\n+\n+    elif isinstance(other, DeferredDataFrame):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      valid_cols = list(\n+          set(self.columns)\n+          .intersection(other.columns)\n+          .intersection(proxy.index))\n+      corrs = [self[col].corr(other[col], **kwargs) for col in valid_cols]\n+      def fill_dataframe(*args):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3033, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}