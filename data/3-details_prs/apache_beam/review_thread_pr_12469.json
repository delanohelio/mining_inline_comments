{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMDcyNTM2", "number": 12469, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDoxMDowNVrOEXXUSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNzowNzoxMlrOEXt_NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTM0NzI4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDoxMDowNVrOG_Hdnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMDoxNDo1NVrOG_3IeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzNTc0Mw==", "bodyText": "Would it be reasonable to re-order the columns by name when asserting equality?", "url": "https://github.com/apache/beam/pull/12469#discussion_r468835743", "createdAt": "2020-08-11T20:10:05Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames_test.py", "diffHunk": "@@ -80,6 +81,24 @@ def test_loc(self):\n     self._run_test(lambda df: df.loc[df.A > 10], df)\n     self._run_test(lambda df: df.loc[lambda df: df.A > 10], df)\n \n+  def test_series_agg(self):\n+    s = pd.Series(list(range(16)))\n+    self._run_test(lambda s: s.agg('sum'), s)\n+    self._run_test(lambda s: s.agg(['sum']), s)\n+    self._run_test(lambda s: s.agg(['sum', 'mean']), s)\n+    self._run_test(lambda s: s.agg(['mean']), s)\n+    self._run_test(lambda s: s.agg('mean'), s)\n+\n+  @unittest.skipIf(sys.version_info < (3, 6), 'Nondeterministic dict ordering.')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNjc2MQ==", "bodyText": "Column ordering seems to be a fairly fundamental property of dataframes that I'd prefer to check in general, and 3.5 won't be supported for long.", "url": "https://github.com/apache/beam/pull/12469#discussion_r469616761", "createdAt": "2020-08-13T00:14:55Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames_test.py", "diffHunk": "@@ -80,6 +81,24 @@ def test_loc(self):\n     self._run_test(lambda df: df.loc[df.A > 10], df)\n     self._run_test(lambda df: df.loc[lambda df: df.A > 10], df)\n \n+  def test_series_agg(self):\n+    s = pd.Series(list(range(16)))\n+    self._run_test(lambda s: s.agg('sum'), s)\n+    self._run_test(lambda s: s.agg(['sum']), s)\n+    self._run_test(lambda s: s.agg(['sum', 'mean']), s)\n+    self._run_test(lambda s: s.agg(['mean']), s)\n+    self._run_test(lambda s: s.agg('mean'), s)\n+\n+  @unittest.skipIf(sys.version_info < (3, 6), 'Nondeterministic dict ordering.')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzNTc0Mw=="}, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzA0NjMzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/transforms.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNzowMjo0OFrOG_qaEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMDoxNjowN1rOG_3Jog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwODI3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for arg in expr.args():\n          \n          \n            \n                    if arg in inputs:\n          \n          \n            \n                      stage.inputs.add(arg)\n          \n          \n            \n                  # Ensure that any inputs for the overall transform are added in downstream stages\n          \n          \n            \n                  for arg in expr.args():\n          \n          \n            \n                    if arg in inputs:\n          \n          \n            \n                      stage.inputs.add(arg)", "url": "https://github.com/apache/beam/pull/12469#discussion_r469408273", "createdAt": "2020-08-12T17:02:48Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -244,6 +261,9 @@ def expr_to_stages(expr):\n             # It also must be declared as an output of the producing stage.\n             expr_to_stage(arg).outputs.add(arg)\n       stage.ops.append(expr)\n+      for arg in expr.args():\n+        if arg in inputs:\n+          stage.inputs.add(arg)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzA1OA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617058", "createdAt": "2020-08-13T00:16:07Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -244,6 +261,9 @@ def expr_to_stages(expr):\n             # It also must be declared as an output of the producing stage.\n             expr_to_stage(arg).outputs.add(arg)\n       stage.ops.append(expr)\n+      for arg in expr.args():\n+        if arg in inputs:\n+          stage.inputs.add(arg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwODI3Mw=="}, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzA1NTk4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNzowNTozM1rOG_qgMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMDoxNjo1NlrOG_3Kqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwOTg0MQ==", "bodyText": "Could you add some comments describing the case each if is handling? I had a hard time making sense of them all", "url": "https://github.com/apache/beam/pull/12469#discussion_r469409841", "createdAt": "2020-08-12T17:05:33Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -150,35 +164,79 @@ def at(self, *args, **kwargs):\n   def loc(self):\n     return _DeferredLoc(self)\n \n-  @frame_base.args_to_kwargs(pd.DataFrame)\n-  @frame_base.populate_defaults(pd.DataFrame)\n-  def aggregate(self, axis, **kwargs):\n+  def aggregate(self, func, axis=0, *args, **kwargs):\n     if axis is None:\n-      return self.agg(axis=1, **kwargs).agg(axis=0, **kwargs)\n-    return frame_base.DeferredFrame.wrap(\n+      return self.agg(func, *args, **dict(kwargs, axis=1)).agg(\n+          func, *args, **dict(kwargs, axis=0))\n+    elif axis in (1, 'columns'):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'aggregate',\n+              lambda df: df.agg(func, axis=1, *args, **kwargs),\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing()))\n+    elif len(self._expr.proxy().columns) == 0 or args or kwargs:\n+      return frame_base.DeferredFrame.wrap(\n         expressions.ComputedExpression(\n             'aggregate',\n-            lambda df: df.agg(axis=axis, **kwargs),\n+            lambda df: df.agg(func, *args, **kwargs),\n             [self._expr],\n-            # TODO(robertwb): Sub-aggregate when possible.\n             requires_partition_by=partitionings.Singleton()))\n+    else:\n+      if not isinstance(func, dict):\n+        col_names = list(self._expr.proxy().columns)\n+        func = {col: func for col in col_names}\n+      else:\n+        col_names = list(func.keys())\n+      aggregated_cols = []\n+      for col in col_names:\n+        funcs = func[col]\n+        if not isinstance(funcs, list):\n+          funcs = [funcs]\n+        aggregated_cols.append(self[col].agg(funcs, *args, **kwargs))\n+      if any(isinstance(funcs, list) for funcs in func.values()):\n+        return frame_base.DeferredFrame.wrap(\n+            expressions.ComputedExpression(\n+                'join_aggregate',\n+                lambda *cols: pd.DataFrame(\n+                    {col: value for col, value in zip(col_names, cols)}),\n+                [col._expr for col in aggregated_cols]))\n+      else:\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+                lambda *cols: pd.Series(\n+                    {col: value[0] for col, value in zip(col_names, cols)}),\n+              [col._expr for col in aggregated_cols],\n+              proxy=self._expr.proxy().agg(func, *args, **kwargs)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzMyMw==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617323", "createdAt": "2020-08-13T00:16:56Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -150,35 +164,79 @@ def at(self, *args, **kwargs):\n   def loc(self):\n     return _DeferredLoc(self)\n \n-  @frame_base.args_to_kwargs(pd.DataFrame)\n-  @frame_base.populate_defaults(pd.DataFrame)\n-  def aggregate(self, axis, **kwargs):\n+  def aggregate(self, func, axis=0, *args, **kwargs):\n     if axis is None:\n-      return self.agg(axis=1, **kwargs).agg(axis=0, **kwargs)\n-    return frame_base.DeferredFrame.wrap(\n+      return self.agg(func, *args, **dict(kwargs, axis=1)).agg(\n+          func, *args, **dict(kwargs, axis=0))\n+    elif axis in (1, 'columns'):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'aggregate',\n+              lambda df: df.agg(func, axis=1, *args, **kwargs),\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing()))\n+    elif len(self._expr.proxy().columns) == 0 or args or kwargs:\n+      return frame_base.DeferredFrame.wrap(\n         expressions.ComputedExpression(\n             'aggregate',\n-            lambda df: df.agg(axis=axis, **kwargs),\n+            lambda df: df.agg(func, *args, **kwargs),\n             [self._expr],\n-            # TODO(robertwb): Sub-aggregate when possible.\n             requires_partition_by=partitionings.Singleton()))\n+    else:\n+      if not isinstance(func, dict):\n+        col_names = list(self._expr.proxy().columns)\n+        func = {col: func for col in col_names}\n+      else:\n+        col_names = list(func.keys())\n+      aggregated_cols = []\n+      for col in col_names:\n+        funcs = func[col]\n+        if not isinstance(funcs, list):\n+          funcs = [funcs]\n+        aggregated_cols.append(self[col].agg(funcs, *args, **kwargs))\n+      if any(isinstance(funcs, list) for funcs in func.values()):\n+        return frame_base.DeferredFrame.wrap(\n+            expressions.ComputedExpression(\n+                'join_aggregate',\n+                lambda *cols: pd.DataFrame(\n+                    {col: value for col, value in zip(col_names, cols)}),\n+                [col._expr for col in aggregated_cols]))\n+      else:\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+                lambda *cols: pd.Series(\n+                    {col: value[0] for col, value in zip(col_names, cols)}),\n+              [col._expr for col in aggregated_cols],\n+              proxy=self._expr.proxy().agg(func, *args, **kwargs)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwOTg0MQ=="}, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzA1NzgwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNzowNjowMlrOG_qhVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMDoxNzowMFrOG_3K0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDEzNA==", "bodyText": "Here as well", "url": "https://github.com/apache/beam/pull/12469#discussion_r469410134", "createdAt": "2020-08-12T17:06:02Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -35,20 +35,34 @@ def __array__(self, dtype=None):\n   transform = frame_base._elementwise_method(\n       'transform', restrictions={'axis': 0})\n \n-  def agg(self, *args, **kwargs):\n-    return frame_base.DeferredFrame.wrap(\n-        expressions.ComputedExpression(\n-            'agg',\n-            lambda df: df.agg(*args, **kwargs), [self._expr],\n-            preserves_partition_by=partitionings.Singleton(),\n-            requires_partition_by=partitionings.Singleton()))\n-\n-  all = frame_base._associative_agg_method('all')\n-  any = frame_base._associative_agg_method('any')\n-  min = frame_base._associative_agg_method('min')\n-  max = frame_base._associative_agg_method('max')\n-  prod = product = frame_base._associative_agg_method('prod')\n-  sum = frame_base._associative_agg_method('sum')\n+  def agg(self, func, axis=0, *args, **kwargs):\n+    if isinstance(func, list) and len(func) > 1:\n+      rows = [self.agg([f], *args, **kwargs) for f in func]\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+              lambda *rows: pd.concat(rows), [row._expr for row in rows]))\n+    else:\n+      base_func = func[0] if isinstance(func, list) else func\n+      if _is_associative(base_func) and not args and not kwargs:\n+        intermediate = expressions.elementwise_expression(\n+            'pre_agg',\n+            lambda s: s.agg([base_func], *args, **kwargs), [self._expr])\n+      else:\n+        intermediate = self._expr\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'agg',\n+              lambda s: s.agg(func, *args, **kwargs), [intermediate],\n+              preserves_partition_by=partitionings.Singleton(),\n+              requires_partition_by=partitionings.Singleton()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzM2Mg==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617362", "createdAt": "2020-08-13T00:17:00Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -35,20 +35,34 @@ def __array__(self, dtype=None):\n   transform = frame_base._elementwise_method(\n       'transform', restrictions={'axis': 0})\n \n-  def agg(self, *args, **kwargs):\n-    return frame_base.DeferredFrame.wrap(\n-        expressions.ComputedExpression(\n-            'agg',\n-            lambda df: df.agg(*args, **kwargs), [self._expr],\n-            preserves_partition_by=partitionings.Singleton(),\n-            requires_partition_by=partitionings.Singleton()))\n-\n-  all = frame_base._associative_agg_method('all')\n-  any = frame_base._associative_agg_method('any')\n-  min = frame_base._associative_agg_method('min')\n-  max = frame_base._associative_agg_method('max')\n-  prod = product = frame_base._associative_agg_method('prod')\n-  sum = frame_base._associative_agg_method('sum')\n+  def agg(self, func, axis=0, *args, **kwargs):\n+    if isinstance(func, list) and len(func) > 1:\n+      rows = [self.agg([f], *args, **kwargs) for f in func]\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+              lambda *rows: pd.concat(rows), [row._expr for row in rows]))\n+    else:\n+      base_func = func[0] if isinstance(func, list) else func\n+      if _is_associative(base_func) and not args and not kwargs:\n+        intermediate = expressions.elementwise_expression(\n+            'pre_agg',\n+            lambda s: s.agg([base_func], *args, **kwargs), [self._expr])\n+      else:\n+        intermediate = self._expr\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'agg',\n+              lambda s: s.agg(func, *args, **kwargs), [intermediate],\n+              preserves_partition_by=partitionings.Singleton(),\n+              requires_partition_by=partitionings.Singleton()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDEzNA=="}, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzA2MTY1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNzowNzoxMlrOG_qj8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMDoxNjo1MlrOG_3Khg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDgwMA==", "bodyText": "I think we're missing this alias in Series", "url": "https://github.com/apache/beam/pull/12469#discussion_r469410800", "createdAt": "2020-08-12T17:07:12Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -150,35 +164,79 @@ def at(self, *args, **kwargs):\n   def loc(self):\n     return _DeferredLoc(self)\n \n-  @frame_base.args_to_kwargs(pd.DataFrame)\n-  @frame_base.populate_defaults(pd.DataFrame)\n-  def aggregate(self, axis, **kwargs):\n+  def aggregate(self, func, axis=0, *args, **kwargs):\n     if axis is None:\n-      return self.agg(axis=1, **kwargs).agg(axis=0, **kwargs)\n-    return frame_base.DeferredFrame.wrap(\n+      return self.agg(func, *args, **dict(kwargs, axis=1)).agg(\n+          func, *args, **dict(kwargs, axis=0))\n+    elif axis in (1, 'columns'):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'aggregate',\n+              lambda df: df.agg(func, axis=1, *args, **kwargs),\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing()))\n+    elif len(self._expr.proxy().columns) == 0 or args or kwargs:\n+      return frame_base.DeferredFrame.wrap(\n         expressions.ComputedExpression(\n             'aggregate',\n-            lambda df: df.agg(axis=axis, **kwargs),\n+            lambda df: df.agg(func, *args, **kwargs),\n             [self._expr],\n-            # TODO(robertwb): Sub-aggregate when possible.\n             requires_partition_by=partitionings.Singleton()))\n+    else:\n+      if not isinstance(func, dict):\n+        col_names = list(self._expr.proxy().columns)\n+        func = {col: func for col in col_names}\n+      else:\n+        col_names = list(func.keys())\n+      aggregated_cols = []\n+      for col in col_names:\n+        funcs = func[col]\n+        if not isinstance(funcs, list):\n+          funcs = [funcs]\n+        aggregated_cols.append(self[col].agg(funcs, *args, **kwargs))\n+      if any(isinstance(funcs, list) for funcs in func.values()):\n+        return frame_base.DeferredFrame.wrap(\n+            expressions.ComputedExpression(\n+                'join_aggregate',\n+                lambda *cols: pd.DataFrame(\n+                    {col: value for col, value in zip(col_names, cols)}),\n+                [col._expr for col in aggregated_cols]))\n+      else:\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+                lambda *cols: pd.Series(\n+                    {col: value[0] for col, value in zip(col_names, cols)}),\n+              [col._expr for col in aggregated_cols],\n+              proxy=self._expr.proxy().agg(func, *args, **kwargs)))\n \n   agg = aggregate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzI4Ng==", "bodyText": "Good call. Done.", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617286", "createdAt": "2020-08-13T00:16:52Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -150,35 +164,79 @@ def at(self, *args, **kwargs):\n   def loc(self):\n     return _DeferredLoc(self)\n \n-  @frame_base.args_to_kwargs(pd.DataFrame)\n-  @frame_base.populate_defaults(pd.DataFrame)\n-  def aggregate(self, axis, **kwargs):\n+  def aggregate(self, func, axis=0, *args, **kwargs):\n     if axis is None:\n-      return self.agg(axis=1, **kwargs).agg(axis=0, **kwargs)\n-    return frame_base.DeferredFrame.wrap(\n+      return self.agg(func, *args, **dict(kwargs, axis=1)).agg(\n+          func, *args, **dict(kwargs, axis=0))\n+    elif axis in (1, 'columns'):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'aggregate',\n+              lambda df: df.agg(func, axis=1, *args, **kwargs),\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing()))\n+    elif len(self._expr.proxy().columns) == 0 or args or kwargs:\n+      return frame_base.DeferredFrame.wrap(\n         expressions.ComputedExpression(\n             'aggregate',\n-            lambda df: df.agg(axis=axis, **kwargs),\n+            lambda df: df.agg(func, *args, **kwargs),\n             [self._expr],\n-            # TODO(robertwb): Sub-aggregate when possible.\n             requires_partition_by=partitionings.Singleton()))\n+    else:\n+      if not isinstance(func, dict):\n+        col_names = list(self._expr.proxy().columns)\n+        func = {col: func for col in col_names}\n+      else:\n+        col_names = list(func.keys())\n+      aggregated_cols = []\n+      for col in col_names:\n+        funcs = func[col]\n+        if not isinstance(funcs, list):\n+          funcs = [funcs]\n+        aggregated_cols.append(self[col].agg(funcs, *args, **kwargs))\n+      if any(isinstance(funcs, list) for funcs in func.values()):\n+        return frame_base.DeferredFrame.wrap(\n+            expressions.ComputedExpression(\n+                'join_aggregate',\n+                lambda *cols: pd.DataFrame(\n+                    {col: value for col, value in zip(col_names, cols)}),\n+                [col._expr for col in aggregated_cols]))\n+      else:\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+                lambda *cols: pd.Series(\n+                    {col: value[0] for col, value in zip(col_names, cols)}),\n+              [col._expr for col in aggregated_cols],\n+              proxy=self._expr.proxy().agg(func, *args, **kwargs)))\n \n   agg = aggregate", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDgwMA=="}, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 820, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}