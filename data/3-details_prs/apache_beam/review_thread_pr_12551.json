{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2OTM0MDk5", "number": 12551, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo1OTo1MVrOEX8Kvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyOToyNFrOEYeEwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTM4NDk0OnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo1OTo1MlrOHAAWzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODoxMToyNVrOHAAvkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2Nzg4NA==", "bodyText": "This is very expensive in terms of memory.", "url": "https://github.com/apache/beam/pull/12551#discussion_r469767884", "createdAt": "2020-08-13T07:59:52Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1226,7 +1230,7 @@ public TimerInternals timerInternals() {\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final PriorityQueue<Long> outputTimestampQueue;\n+    private final SortedMap<Long, Set<String>> outputTimestamps = new TreeMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72c260af8fff12208308a4e124a35300ab250889"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc3NDIyNQ==", "bodyText": "Agree, that's why I don't generally like this solution and would like to come up with different one.", "url": "https://github.com/apache/beam/pull/12551#discussion_r469774225", "createdAt": "2020-08-13T08:11:25Z", "author": {"login": "je-ik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1226,7 +1230,7 @@ public TimerInternals timerInternals() {\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final PriorityQueue<Long> outputTimestampQueue;\n+    private final SortedMap<Long, Set<String>> outputTimestamps = new TreeMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2Nzg4NA=="}, "originalCommit": {"oid": "72c260af8fff12208308a4e124a35300ab250889"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTM5MjE4OnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODowMTo1N1rOHAAbQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODoxNzo1OVrOHAA-Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2OTAyNQ==", "bodyText": "IMHO there is no need to store the timer id here.", "url": "https://github.com/apache/beam/pull/12551#discussion_r469769025", "createdAt": "2020-08-13T08:01:57Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1277,7 +1280,13 @@ private void onNewEventTimer(TimerData newTimer) {\n           \"Timer with id %s is not an event time timer!\",\n           newTimer.getTimerId());\n       if (timerUsesOutputTimestamp(newTimer)) {\n-        outputTimestampQueue.add(newTimer.getOutputTimestamp().getMillis());\n+        outputTimestamps.compute(\n+            newTimer.getOutputTimestamp().getMillis(),\n+            (k, v) -> {\n+              Set<String> timerIds = v == null ? new HashSet<>() : v;\n+              timerIds.add(getContextTimerId(newTimer.getTimerId(), newTimer.getNamespace()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72c260af8fff12208308a4e124a35300ab250889"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc3NDczNQ==", "bodyText": "It should not. But in some cases, a timer output timestamp seems to appear in the queue twice (for the same timer) and removed only once, which causes the pipeline to get stuck.", "url": "https://github.com/apache/beam/pull/12551#discussion_r469774735", "createdAt": "2020-08-13T08:12:19Z", "author": {"login": "je-ik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1277,7 +1280,13 @@ private void onNewEventTimer(TimerData newTimer) {\n           \"Timer with id %s is not an event time timer!\",\n           newTimer.getTimerId());\n       if (timerUsesOutputTimestamp(newTimer)) {\n-        outputTimestampQueue.add(newTimer.getOutputTimestamp().getMillis());\n+        outputTimestamps.compute(\n+            newTimer.getOutputTimestamp().getMillis(),\n+            (k, v) -> {\n+              Set<String> timerIds = v == null ? new HashSet<>() : v;\n+              timerIds.add(getContextTimerId(newTimer.getTimerId(), newTimer.getNamespace()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2OTAyNQ=="}, "originalCommit": {"oid": "72c260af8fff12208308a4e124a35300ab250889"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc3Nzk2Mw==", "bodyText": "Duplicates are ok. If we have multiple timers set with different ids or even for the same keys, duplicates are expected. We could use a TreeMap instead of a PriorityQueue like we do in FlinkTimerInterals for the WatermarkHoldState, but I don't see anything wrong with the implementation here.\nYou likely have a problem in your application code, i.e. you set a timer output timestamp which holds back the watermark but your fire timestamp has not been reached by the watermark yet. Please investigate that first. Also note #12531 which was a bug in the Python SDK.", "url": "https://github.com/apache/beam/pull/12551#discussion_r469777963", "createdAt": "2020-08-13T08:17:59Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1277,7 +1280,13 @@ private void onNewEventTimer(TimerData newTimer) {\n           \"Timer with id %s is not an event time timer!\",\n           newTimer.getTimerId());\n       if (timerUsesOutputTimestamp(newTimer)) {\n-        outputTimestampQueue.add(newTimer.getOutputTimestamp().getMillis());\n+        outputTimestamps.compute(\n+            newTimer.getOutputTimestamp().getMillis(),\n+            (k, v) -> {\n+              Set<String> timerIds = v == null ? new HashSet<>() : v;\n+              timerIds.add(getContextTimerId(newTimer.getTimerId(), newTimer.getNamespace()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2OTAyNQ=="}, "originalCommit": {"oid": "72c260af8fff12208308a4e124a35300ab250889"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MDk0MDE3OnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyOToyNFrOHA0mAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNDoxNjowOVrOHA2OlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA==", "bodyText": "We could also consider making this even more efficient by using a TreeMap<Long, Integer> where the key is the output timestamp and the value the number of timers which have set it, similar to how it's done in FlinkStateInternals for the watermark holds.\nFurther, we could remove outputTimestamps entirely and simply use stateInternals.addWatermarkHoldUsage(output_timestamp) and stateInternals.removeWatermarkHoldUsage(output_timestamp).", "url": "https://github.com/apache/beam/pull/12551#discussion_r470623744", "createdAt": "2020-08-14T13:29:24Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1226,7 +1227,7 @@ public TimerInternals timerInternals() {\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final PriorityQueue<Long> outputTimestampQueue;\n+    private final TreeMultiset<Long> outputTimestamps = TreeMultiset.create();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d00291a6949b2b5afdbc0e08e58f12f507c1f656"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNzUzNw==", "bodyText": "I don't know the internal details of TreeMultiset, but I'd suppose it to be pretty much the same as Map<Long, Integer> in terms of performance. Removing the outputTimestamps entirely seems to be the best option. I'll try that and let you know.", "url": "https://github.com/apache/beam/pull/12551#discussion_r470627537", "createdAt": "2020-08-14T13:35:59Z", "author": {"login": "je-ik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1226,7 +1227,7 @@ public TimerInternals timerInternals() {\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final PriorityQueue<Long> outputTimestampQueue;\n+    private final TreeMultiset<Long> outputTimestamps = TreeMultiset.create();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}, "originalCommit": {"oid": "d00291a6949b2b5afdbc0e08e58f12f507c1f656"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyOTY2OA==", "bodyText": "Maybe we could replace the TreeMap<Long, Integer> with the TreeMultiset?", "url": "https://github.com/apache/beam/pull/12551#discussion_r470629668", "createdAt": "2020-08-14T13:39:56Z", "author": {"login": "je-ik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1226,7 +1227,7 @@ public TimerInternals timerInternals() {\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final PriorityQueue<Long> outputTimestampQueue;\n+    private final TreeMultiset<Long> outputTimestamps = TreeMultiset.create();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}, "originalCommit": {"oid": "d00291a6949b2b5afdbc0e08e58f12f507c1f656"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMzEyMQ==", "bodyText": "Why would we do this? TreeMap<Long, Integer> seems like the better data structure because it stores the data compacted.", "url": "https://github.com/apache/beam/pull/12551#discussion_r470633121", "createdAt": "2020-08-14T13:46:14Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1226,7 +1227,7 @@ public TimerInternals timerInternals() {\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final PriorityQueue<Long> outputTimestampQueue;\n+    private final TreeMultiset<Long> outputTimestamps = TreeMultiset.create();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}, "originalCommit": {"oid": "d00291a6949b2b5afdbc0e08e58f12f507c1f656"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzNjU2Nw==", "bodyText": "TreeMultiset does the same. And saves some code and performance, the value is stored as array of length 1 and thus adding an already existing item to the set is just get() and in-place increment, while the TreeMap must do get & replace. I think the biggest argument here is that the code is more readable, though. I'll update the PR in a sec, so that you can see.", "url": "https://github.com/apache/beam/pull/12551#discussion_r470636567", "createdAt": "2020-08-14T13:52:11Z", "author": {"login": "je-ik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1226,7 +1227,7 @@ public TimerInternals timerInternals() {\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final PriorityQueue<Long> outputTimestampQueue;\n+    private final TreeMultiset<Long> outputTimestamps = TreeMultiset.create();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}, "originalCommit": {"oid": "d00291a6949b2b5afdbc0e08e58f12f507c1f656"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzODQzMQ==", "bodyText": "Pushed", "url": "https://github.com/apache/beam/pull/12551#discussion_r470638431", "createdAt": "2020-08-14T13:55:08Z", "author": {"login": "je-ik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1226,7 +1227,7 @@ public TimerInternals timerInternals() {\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final PriorityQueue<Long> outputTimestampQueue;\n+    private final TreeMultiset<Long> outputTimestamps = TreeMultiset.create();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}, "originalCommit": {"oid": "d00291a6949b2b5afdbc0e08e58f12f507c1f656"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY1MDUxNw==", "bodyText": "Wasn't familiar with the internals of TreeMultiSet but if that's the case, it sounds excellent! :)", "url": "https://github.com/apache/beam/pull/12551#discussion_r470650517", "createdAt": "2020-08-14T14:16:09Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1226,7 +1227,7 @@ public TimerInternals timerInternals() {\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final PriorityQueue<Long> outputTimestampQueue;\n+    private final TreeMultiset<Long> outputTimestamps = TreeMultiset.create();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}, "originalCommit": {"oid": "d00291a6949b2b5afdbc0e08e58f12f507c1f656"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 656, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}