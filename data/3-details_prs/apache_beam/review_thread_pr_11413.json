{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMjc2MzI1", "number": 11413, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjo0NjoxOVrODxu5Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1Mjo0MVrODx2dhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDc1MDk1OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/datamgr.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjo0NjoxOVrOGFXraw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODo0MDoxN1rOGFb-Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI4NDAxMQ==", "bodyText": "seems like this could still be an if-else?", "url": "https://github.com/apache/beam/pull/11413#discussion_r408284011", "createdAt": "2020-04-14T16:46:19Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/datamgr.go", "diffHunk": "@@ -369,11 +371,14 @@ func (r *dataReader) Read(buf []byte) (int, error) {\n \t\tr.cur = b\n \t}\n \n+\t// We don't need to check for a 0 length copy from r.cur here, since that's\n+\t// checked before buffers are handed to the r.buf channel.\n \tn := copy(buf, r.cur)\n \n-\tif len(r.cur) == n {\n+\tswitch {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1NDM0Mg==", "bodyText": "It could but I like the consistency in handling between the statemgr and datamgr code, hence the no-op/comment only change.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408354342", "createdAt": "2020-04-14T18:40:17Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/harness/datamgr.go", "diffHunk": "@@ -369,11 +371,14 @@ func (r *dataReader) Read(buf []byte) (int, error) {\n \t\tr.cur = b\n \t}\n \n+\t// We don't need to check for a 0 length copy from r.cur here, since that's\n+\t// checked before buffers are handed to the r.buf channel.\n \tn := copy(buf, r.cur)\n \n-\tif len(r.cur) == n {\n+\tswitch {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI4NDAxMQ=="}, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTQ1ODA3OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo1NzozMlrOGFen6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDowNzozOVrOGFe95A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5NzgwMw==", "bodyText": "i, buflen := range test.buflens ?", "url": "https://github.com/apache/beam/pull/11413#discussion_r408397803", "createdAt": "2020-04-14T19:57:32Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMzQyOA==", "bodyText": "Good catch!", "url": "https://github.com/apache/beam/pull/11413#discussion_r408403428", "createdAt": "2020-04-14T20:07:39Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5NzgwMw=="}, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTQ3ODMyOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDowMzoxOVrOGFe0hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoxNjo1OVrOGFi8nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTAzMA==", "bodyText": "Since this doesn't depend on the rest of what is going on in the loop, pulling this up to the top might be a good idea.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408401030", "createdAt": "2020-04-14T20:03:19Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif test.buflens[i] >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, test.buflens[i])\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2ODYzNg==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/11413#discussion_r408468636", "createdAt": "2020-04-14T22:16:59Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif test.buflens[i] >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, test.buflens[i])\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTAzMA=="}, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTQ5NTc2OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDowODoyN1rOGFe_sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoxNjo1N1rOGFi8jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMzg5MA==", "bodyText": "rearranging this so that all the initialization for this variable is together might make it easier to follow:\nvar buf []byte\nif ... {\n  ...\n}\n\n// I can see it making sense to reverse the if-statement here to match the one above,\n// but it there is a case to keep it as-is so that the common case is outside the 'if'.\n// Up to you.\nvar token []byte\nif (not last entry) {\n  // Maybe use fmt.Sprint() here rather than Itoa to avoid needing the strconv package?\n  token = []byte(fmt.Sprint(i))\n}\n\nch.responses[...] <- ...", "url": "https://github.com/apache/beam/pull/11413#discussion_r408403890", "createdAt": "2020-04-14T20:08:27Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif test.buflens[i] >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, test.buflens[i])\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2ODYyMA==", "bodyText": "Great suggestions. Done.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408468620", "createdAt": "2020-04-14T22:16:57Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif test.buflens[i] >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, test.buflens[i])\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMzg5MA=="}, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTU1MDM1OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDoyNDoyM1rOGFfh3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo0NDoxN1rOGFjk9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMjYzOQ==", "bodyText": "Is this a common idiom in beam testing? Inside Google, I don't think I've seen reassignment to want/got for things which are already stored in their own variables. I would expect something like:\nif reads != test.numReads {\n  t.Errorf(\"read %d times, want %d\", reads, test.numReads)\n}\nfor simpler tests I have seen things like:\nif got := sut.CallSomeFn(params); got != tc.want {\n  // ...\n}", "url": "https://github.com/apache/beam/pull/11413#discussion_r408412639", "createdAt": "2020-04-14T20:24:23Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif test.buflens[i] >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, test.buflens[i])\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2ODYwMw==", "bodyText": "No, it's my own personal habit after making mistakes on the ordering one to many times when debugging new tests. Since I've been working on beam for a bit, it's wherever I've been working on it.\nThis way I never need to think of which one is 'got' or 'want', it's entirely unambiguous. It also simplifies copying the boiler plate for many sequential checks, where such leftover mistakes are common, as the variables only need to be updated in a single place, in the if definition scope.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408468603", "createdAt": "2020-04-14T22:16:55Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif test.buflens[i] >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, test.buflens[i])\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMjYzOQ=="}, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3ODk2NQ==", "bodyText": "I'm still not a huge fan, because it introduces another layer of indirection around what is gotten vs. wanted (e.g. in the ==/!= itself and in the error message string)\u2026", "url": "https://github.com/apache/beam/pull/11413#discussion_r408478965", "createdAt": "2020-04-14T22:44:17Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif test.buflens[i] >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, test.buflens[i])\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMjYzOQ=="}, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk2MzQ1OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo0MDoyM1rOGFjfdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxODowMlrOGFlalg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NzU1Ng==", "bodyText": "Nit: This error message could benefit from some escaped quotation marks around the %v, to make it explicit where the quoted error begins and ends. Alternatively, surrounding the quoted error with some newlines and tabs might work well too, like so:\ngot err:\n    <error message>\nwant to contain:\n    <error message>", "url": "https://github.com/apache/beam/pull/11413#discussion_r408477556", "createdAt": "2020-04-14T22:40:23Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i, buflen := range test.buflens {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif buflen >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, buflen)\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {\n+\t\t\t\tt.Errorf(\"read %d times, want %d\", got, want)\n+\t\t\t}\n+\t\t\tif got, want := count, totalBytes; got != want {\n+\t\t\t\tt.Errorf(\"read %v bytes, want %v\", got, want)\n+\t\t\t}\n+\t\t\tif test.closed {\n+\t\t\t\tif got, want := finalerr, errors.New(\"side input closed\"); !contains(got, want) {\n+\t\t\t\t\tt.Errorf(\"got err %v, want to contain %v\", got, want)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afc95c82202bf9bf5c2781d574abe346de33f8da"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3OA==", "bodyText": "I don't like adding newlines to the test formatted output, since it messes with the indentation of the results, possibly making it harder to read. I have used %q which will quote and escape the Error() strings though.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408509078", "createdAt": "2020-04-15T00:18:02Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i, buflen := range test.buflens {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif buflen >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, buflen)\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {\n+\t\t\t\tt.Errorf(\"read %d times, want %d\", got, want)\n+\t\t\t}\n+\t\t\tif got, want := count, totalBytes; got != want {\n+\t\t\t\tt.Errorf(\"read %v bytes, want %v\", got, want)\n+\t\t\t}\n+\t\t\tif test.closed {\n+\t\t\t\tif got, want := finalerr, errors.New(\"side input closed\"); !contains(got, want) {\n+\t\t\t\t\tt.Errorf(\"got err %v, want to contain %v\", got, want)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NzU1Ng=="}, "originalCommit": {"oid": "afc95c82202bf9bf5c2781d574abe346de33f8da"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk2NTI0OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo0MTowN1rOGFjgiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxODowN1rOGFlarQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NzgzMw==", "bodyText": "Nit: Same as above. Could use some way to make it more explicit where the quoted error begins and ends.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408477833", "createdAt": "2020-04-14T22:41:07Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i, buflen := range test.buflens {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif buflen >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, buflen)\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {\n+\t\t\t\tt.Errorf(\"read %d times, want %d\", got, want)\n+\t\t\t}\n+\t\t\tif got, want := count, totalBytes; got != want {\n+\t\t\t\tt.Errorf(\"read %v bytes, want %v\", got, want)\n+\t\t\t}\n+\t\t\tif test.closed {\n+\t\t\t\tif got, want := finalerr, errors.New(\"side input closed\"); !contains(got, want) {\n+\t\t\t\t\tt.Errorf(\"got err %v, want to contain %v\", got, want)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif got, want := finalerr, io.EOF; got != want {\n+\t\t\t\tt.Errorf(\"got err %v, want %v\", got, want)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afc95c82202bf9bf5c2781d574abe346de33f8da"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTEwMQ==", "bodyText": "Ack.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408509101", "createdAt": "2020-04-15T00:18:07Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i, buflen := range test.buflens {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif buflen >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, buflen)\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {\n+\t\t\t\tt.Errorf(\"read %d times, want %d\", got, want)\n+\t\t\t}\n+\t\t\tif got, want := count, totalBytes; got != want {\n+\t\t\t\tt.Errorf(\"read %v bytes, want %v\", got, want)\n+\t\t\t}\n+\t\t\tif test.closed {\n+\t\t\t\tif got, want := finalerr, errors.New(\"side input closed\"); !contains(got, want) {\n+\t\t\t\t\tt.Errorf(\"got err %v, want to contain %v\", got, want)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif got, want := finalerr, io.EOF; got != want {\n+\t\t\t\tt.Errorf(\"got err %v, want %v\", got, want)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NzgzMw=="}, "originalCommit": {"oid": "afc95c82202bf9bf5c2781d574abe346de33f8da"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk3NjY3OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo0NjowOVrOGFjneQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1MToyNVrOGFjuwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3OTYwOQ==", "bodyText": "...for instance, here, I would find\nif want := errors.New(\"side input closed\"); !contains(finalErr, want) {\n  t.Errorf(\"got err %v; want to contain %v, finalErr, want)\n}\neasier to read, since the thing you Got is right there. That being said, I wouldn't block submission on this.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408479609", "createdAt": "2020-04-14T22:46:09Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +260,166 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tif test.noGet {\n+\t\t\t\t\treq := <-ch.requests\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t}\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tfor i, buflen := range test.buflens {\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif buflen >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, buflen)\n+\t\t\t\t\t}\n+\t\t\t\t\ttoken := []byte(fmt.Sprint(i))\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {\n+\t\t\t\tt.Errorf(\"read %d times, want %d\", got, want)\n+\t\t\t}\n+\t\t\tif got, want := count, totalBytes; got != want {\n+\t\t\t\tt.Errorf(\"read %v bytes, want %v\", got, want)\n+\t\t\t}\n+\t\t\tif test.closed {\n+\t\t\t\tif got, want := finalerr, errors.New(\"side input closed\"); !contains(got, want) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9acd8ee186b9cfb782f027ea00049a7d6f287758"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTQ3NA==", "bodyText": "Ack. Not an unreasonable position. I just know I stopped making the trivial but easy to overlook mistakes when I started using this pattern.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408481474", "createdAt": "2020-04-14T22:51:25Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +260,166 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tif test.noGet {\n+\t\t\t\t\treq := <-ch.requests\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t}\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tfor i, buflen := range test.buflens {\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif buflen >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, buflen)\n+\t\t\t\t\t}\n+\t\t\t\t\ttoken := []byte(fmt.Sprint(i))\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {\n+\t\t\t\tt.Errorf(\"read %d times, want %d\", got, want)\n+\t\t\t}\n+\t\t\tif got, want := count, totalBytes; got != want {\n+\t\t\t\tt.Errorf(\"read %v bytes, want %v\", got, want)\n+\t\t\t}\n+\t\t\tif test.closed {\n+\t\t\t\tif got, want := finalerr, errors.New(\"side input closed\"); !contains(got, want) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3OTYwOQ=="}, "originalCommit": {"oid": "9acd8ee186b9cfb782f027ea00049a7d6f287758"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk5MTA5OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1Mjo0MVrOGFjwWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxMjozN1rOGFlUcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTg4MQ==", "bodyText": "Is the number of reads something that needs to be predictable to whatever code uses the reader? To me it seems like one of those implementation details that doesn't need to be unit tested because it's invisible to the caller.\nThe reason this stood out to me is that the numReads in all the test cases below seem a bit inscrutable, and it would cause these tests to fail if the implementation of the stateKeyReader was changed slightly, which is just an annoyance unless it would actually break code.\nOn the other hand, if the number of reads is a detail that users should know, and correctness does rely on it staying consistent, that seems like it should be explicitly documented on stateKeyReader.Read.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408481881", "createdAt": "2020-04-14T22:52:41Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afc95c82202bf9bf5c2781d574abe346de33f8da"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNzUwNw==", "bodyText": "Consider: What kind of change to the stateKeyReader implementation would change the expected number of reads, based on how stateKeyReader gets its data?\nThere are two kinds of unit test. What you've described is black box testing, where the testing code has no knowledge of internal details of the implementation. This is valuable when there are accessible API calls to set the unknown internal state of a struct, and in doing so, there are checkable expectations of how other API calls will behave as a result. As a rule, this is preferable, as it's resilient to implementation changes, but with a broad enough API surface, it can be very very expensive since it's simply checking the same code paths over and over and over again on different tests. Black box testing by necessity ends up having alot of redundancy. We do have black box testing in general for Beam Go, since we use the direct runner to validate large portions of the exec package in a \"pipeline\" context. You can find them via any of the test files that have their package name to include _test.\nThere's also white box testing, where the internal details are known to the test implementer. These tests are an example of the latter.\nThere is no user side API to configure the internal state of stateKeyReader.Read(), and in general for the io.Reader interface, which is how users (AKA other parts of the beam framework), will be using stateKeyReader.\nSince we can't configure things with a user side API, we must manipulate some other internal state, to set the initial conditions, and then from those conditions, check that we understand the code under test.\nFurther, white box testing is the only reasonable option for such a general API like Read(). It gets passed in a buffer, and it's expected to write up to len(buffer) bytes to it, and tell you what it did. It doesn't say anything about the bytes themselves. The implementations vary dramatically depending on the purpose, and only the implementation can check that. The API in this case doesn't dictate the tests, otherwise there could be a \"io.ReaderTester\" that we could instead of running these.\nSo, while numReads in general is inscrutable to the user, it's not inscrutable to us, the implementers of this test case, and the code. We have our own expectations for the code\nIn fact, numReads a deterministic number based on the lengths of the backing buffers vs the lengths of the reads. Since it's something we can check, and know based on the initial conditions, and our understanding of the code, it's fine. numReads is a second order expectation based on the initial conditions, but it's also one that's very easy to check.\nTo be very blunt, numReads is checking that the code behaves the way we think it behaves.\nIn this case, had we been testing that the \"nil\" data buffer case required 1 read to return EOF, we wouldn't have had the bug in question.\nYour underlying concern about a \"change state\" test is valid though. Tests that require a specific implementation in order to pass, can be a nuisance. But that doesn't apply so much to second order expectations like numReads.  If the number of reads changes when the implementation changes, I certainly would like to know about it, because that could be an unexpected side effect of the change being made. Conversely, if a refactorer believes they can change the implementation to reduce the number of calls to Read the test can expect, they can simply adjust the number, and in Test Driven Development style, use that to validate that the changes they're making accomplish the intended goal.\nI'm on the side of I'd rather have tests fail if a dramatic change in behavior occurs, and the change author need to adjust them since then it verifies that they ran the tests, and that the tests are actually working. Having tests that pass after you make a change is a double edged sword. Your code is either still satisfying the old expectations, or it's breaking in ways you aren't testing yet.\nTo answer the question I posed at the top of this comment. I can think of one change I'd make to the implementation (I mention it in the top post for this PR), but to make it, we'd need to validate every use of the io.Reader interface in the Go SDK, but it would only affect one or two of the given test cases for the numReads value, not all of them.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408507507", "createdAt": "2020-04-15T00:12:37Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTg4MQ=="}, "originalCommit": {"oid": "afc95c82202bf9bf5c2781d574abe346de33f8da"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1262, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}