{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MjkwNjMx", "number": 11517, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOToyMTo1OVrOD22znw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo1MjozOVrOD3ZT7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODQ3NjQ3OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOToyMTo1OVrOGMzznw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNDowNTowMlrOGNBldw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4NDg5NQ==", "bodyText": "Note, even if we submit this now-ish, we can still call it experimental until we have testing and some IO usage to bolster confidence.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416084895", "createdAt": "2020-04-27T19:21:59Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "diffHunk": "@@ -13,42 +13,36 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-// Package sdf is experimental, incomplete, and not yet meant for general usage.\n+// Package sdf contains interfaces used specifically for splittable DoFns.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffb8b565be8a3c42b8df805005b19c19bc8cd42c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxMDY0Nw==", "bodyText": "Done, I prefer to call it experimental at the moment.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416310647", "createdAt": "2020-04-28T04:05:02Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "diffHunk": "@@ -13,42 +13,36 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-// Package sdf is experimental, incomplete, and not yet meant for general usage.\n+// Package sdf contains interfaces used specifically for splittable DoFns.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4NDg5NQ=="}, "originalCommit": {"oid": "ffb8b565be8a3c42b8df805005b19c19bc8cd42c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODUwNjY4OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/pardo.go", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOToyOTozNVrOGM0Fog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNDoxMzo0M1rOGNBvtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4OTUwNg==", "bodyText": "I think in this case you mean\nWork can only be split by the initial restriction boundaries.\n\nSince technically the initial split could turn every element into three restrictions or something, but those restrictions are at the \"sub element\" boundaries rather than in every element (eg. Each initial element is a filename, and the Initial split stats each file's size, and just provides restrictions once every 1000 bytes), and handles actually \"empty restrictions\" during processing.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416089506", "createdAt": "2020-04-27T19:29:35Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/pardo.go", "diffHunk": "@@ -222,6 +222,81 @@ func ParDo0(s Scope, dofn interface{}, col PCollection, opts ...Option) {\n // DoFn instance via output PCollections, in the absence of external\n // communication mechanisms written by user code.\n //\n+// Splittable DoFns\n+//\n+// Splittable DoFns are DoFns that are able to split work within an element,\n+// as opposed to only at element boundaries like normal DoFns. This is useful\n+// for DoFns that emit many outputs per input element and can distribute that\n+// work among multiple workers. The most common examples of this are sources.\n+//\n+// In order to split work within an element, splittable DoFns use the concept of\n+// restrictions, which are objects that are associated with an element and\n+// describe a portion of work on that element. For example, a restriction\n+// associated with a filename might describe what byte range within that file to\n+// process. In addition to restrictions, splittable DoFns also rely on\n+// restriction trackers to track progress and perform splits on a restriction\n+// currently being processed. See the `RTracker` interface in core/sdf/sdf.go\n+// for more details.\n+//\n+// Splitting\n+//\n+// Splitting means taking one restriction and splitting into two or more that\n+// cover the entire input space of the original one. In other words, processing\n+// all the split restrictions should produce identical output to processing\n+// the original one.\n+//\n+// Splitting occurs in two stages. The initial splitting occurs before any\n+// restrictions have started processing. This step is used to split large\n+// restrictions into smaller ones that can then be distributed among multiple\n+// workers for processing. Initial splitting is user-defined and optional.\n+//\n+// Dynamic splitting occurs during the processing of a restriction in runners\n+// that have implemented it. If there are available workers, runners may split\n+// the unprocessed portion of work from a busy worker and shard it to available\n+// workers in order to better distribute work. With unsplittable DoFns this can\n+// only occur on element boundaries, but for splittable DoFns this split\n+// can land within a restriction and will require splitting that restriction.\n+//\n+// * Note: The Go SDK currently does not support dynamic splitting for SDFs,\n+//   only initial splitting. Work can only be split at element boundaries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffb8b565be8a3c42b8df805005b19c19bc8cd42c"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2OTczMQ==", "bodyText": "I was actually trying to say that during execution, work is only split along element boundaries. But even that is a bit misleading, because the elements in question are the initially split restrictions. So I'll probably either word it something like \"This means that for runners that support liquid sharding, only the initially split restrictions can be distributed among workers, and stragglers cannot be split into smaller restrictions\". Or maybe I'll keep it simple and just leave the first sentence.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416169731", "createdAt": "2020-04-27T21:42:39Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/pardo.go", "diffHunk": "@@ -222,6 +222,81 @@ func ParDo0(s Scope, dofn interface{}, col PCollection, opts ...Option) {\n // DoFn instance via output PCollections, in the absence of external\n // communication mechanisms written by user code.\n //\n+// Splittable DoFns\n+//\n+// Splittable DoFns are DoFns that are able to split work within an element,\n+// as opposed to only at element boundaries like normal DoFns. This is useful\n+// for DoFns that emit many outputs per input element and can distribute that\n+// work among multiple workers. The most common examples of this are sources.\n+//\n+// In order to split work within an element, splittable DoFns use the concept of\n+// restrictions, which are objects that are associated with an element and\n+// describe a portion of work on that element. For example, a restriction\n+// associated with a filename might describe what byte range within that file to\n+// process. In addition to restrictions, splittable DoFns also rely on\n+// restriction trackers to track progress and perform splits on a restriction\n+// currently being processed. See the `RTracker` interface in core/sdf/sdf.go\n+// for more details.\n+//\n+// Splitting\n+//\n+// Splitting means taking one restriction and splitting into two or more that\n+// cover the entire input space of the original one. In other words, processing\n+// all the split restrictions should produce identical output to processing\n+// the original one.\n+//\n+// Splitting occurs in two stages. The initial splitting occurs before any\n+// restrictions have started processing. This step is used to split large\n+// restrictions into smaller ones that can then be distributed among multiple\n+// workers for processing. Initial splitting is user-defined and optional.\n+//\n+// Dynamic splitting occurs during the processing of a restriction in runners\n+// that have implemented it. If there are available workers, runners may split\n+// the unprocessed portion of work from a busy worker and shard it to available\n+// workers in order to better distribute work. With unsplittable DoFns this can\n+// only occur on element boundaries, but for splittable DoFns this split\n+// can land within a restriction and will require splitting that restriction.\n+//\n+// * Note: The Go SDK currently does not support dynamic splitting for SDFs,\n+//   only initial splitting. Work can only be split at element boundaries.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4OTUwNg=="}, "originalCommit": {"oid": "ffb8b565be8a3c42b8df805005b19c19bc8cd42c"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxMzI2OQ==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416313269", "createdAt": "2020-04-28T04:13:43Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/pardo.go", "diffHunk": "@@ -222,6 +222,81 @@ func ParDo0(s Scope, dofn interface{}, col PCollection, opts ...Option) {\n // DoFn instance via output PCollections, in the absence of external\n // communication mechanisms written by user code.\n //\n+// Splittable DoFns\n+//\n+// Splittable DoFns are DoFns that are able to split work within an element,\n+// as opposed to only at element boundaries like normal DoFns. This is useful\n+// for DoFns that emit many outputs per input element and can distribute that\n+// work among multiple workers. The most common examples of this are sources.\n+//\n+// In order to split work within an element, splittable DoFns use the concept of\n+// restrictions, which are objects that are associated with an element and\n+// describe a portion of work on that element. For example, a restriction\n+// associated with a filename might describe what byte range within that file to\n+// process. In addition to restrictions, splittable DoFns also rely on\n+// restriction trackers to track progress and perform splits on a restriction\n+// currently being processed. See the `RTracker` interface in core/sdf/sdf.go\n+// for more details.\n+//\n+// Splitting\n+//\n+// Splitting means taking one restriction and splitting into two or more that\n+// cover the entire input space of the original one. In other words, processing\n+// all the split restrictions should produce identical output to processing\n+// the original one.\n+//\n+// Splitting occurs in two stages. The initial splitting occurs before any\n+// restrictions have started processing. This step is used to split large\n+// restrictions into smaller ones that can then be distributed among multiple\n+// workers for processing. Initial splitting is user-defined and optional.\n+//\n+// Dynamic splitting occurs during the processing of a restriction in runners\n+// that have implemented it. If there are available workers, runners may split\n+// the unprocessed portion of work from a busy worker and shard it to available\n+// workers in order to better distribute work. With unsplittable DoFns this can\n+// only occur on element boundaries, but for splittable DoFns this split\n+// can land within a restriction and will require splitting that restriction.\n+//\n+// * Note: The Go SDK currently does not support dynamic splitting for SDFs,\n+//   only initial splitting. Work can only be split at element boundaries.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4OTUwNg=="}, "originalCommit": {"oid": "ffb8b565be8a3c42b8df805005b19c19bc8cd42c"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODUxODE4OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/pardo.go", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOTozMjowNlrOGM0MNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNDoxNTozNlrOGNBx4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA5MTE4OA==", "bodyText": "Is this supposed to be a concrete type or the literal sdf.RTracker interface?", "url": "https://github.com/apache/beam/pull/11517#discussion_r416091188", "createdAt": "2020-04-27T19:32:06Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/pardo.go", "diffHunk": "@@ -222,6 +222,81 @@ func ParDo0(s Scope, dofn interface{}, col PCollection, opts ...Option) {\n // DoFn instance via output PCollections, in the absence of external\n // communication mechanisms written by user code.\n //\n+// Splittable DoFns\n+//\n+// Splittable DoFns are DoFns that are able to split work within an element,\n+// as opposed to only at element boundaries like normal DoFns. This is useful\n+// for DoFns that emit many outputs per input element and can distribute that\n+// work among multiple workers. The most common examples of this are sources.\n+//\n+// In order to split work within an element, splittable DoFns use the concept of\n+// restrictions, which are objects that are associated with an element and\n+// describe a portion of work on that element. For example, a restriction\n+// associated with a filename might describe what byte range within that file to\n+// process. In addition to restrictions, splittable DoFns also rely on\n+// restriction trackers to track progress and perform splits on a restriction\n+// currently being processed. See the `RTracker` interface in core/sdf/sdf.go\n+// for more details.\n+//\n+// Splitting\n+//\n+// Splitting means taking one restriction and splitting into two or more that\n+// cover the entire input space of the original one. In other words, processing\n+// all the split restrictions should produce identical output to processing\n+// the original one.\n+//\n+// Splitting occurs in two stages. The initial splitting occurs before any\n+// restrictions have started processing. This step is used to split large\n+// restrictions into smaller ones that can then be distributed among multiple\n+// workers for processing. Initial splitting is user-defined and optional.\n+//\n+// Dynamic splitting occurs during the processing of a restriction in runners\n+// that have implemented it. If there are available workers, runners may split\n+// the unprocessed portion of work from a busy worker and shard it to available\n+// workers in order to better distribute work. With unsplittable DoFns this can\n+// only occur on element boundaries, but for splittable DoFns this split\n+// can land within a restriction and will require splitting that restriction.\n+//\n+// * Note: The Go SDK currently does not support dynamic splitting for SDFs,\n+//   only initial splitting. Work can only be split at element boundaries.\n+//\n+// Splittable DoFn Methods\n+//\n+// Making a splittable DoFn requires the following methods to be implemented on\n+// a DoFn in addition to the usual DoFn requirements. In the following\n+// method signatures `elem` represents the main input elements to the DoFn, and\n+// should match the types used in ProcessElement. `restriction` represents the\n+// user-defined restriction, and can be any type as long as it is consistent\n+// throughout all the splittable DoFn methods:\n+//\n+// * `CreateInitialRestriction(element) restriction`\n+//     CreateInitialRestriction creates an initial restriction encompassing an\n+//     entire element. The restriction created stays associated with the element\n+//     it describes.\n+// * `SplitRestriction(elem, restriction) []restriction`\n+//     SplitRestriction takes an element and its initial restriction, and\n+//     optionally performs an initial split on it, returning a slice of all the\n+//     split restrictions. If no splits are desired, the method returns a slice\n+//     containing only the original restriction. This method will always be\n+//     called on each newly created restriction before they are processed.\n+// * `RestrictionSize(elem, restriction) float64`\n+//     RestrictionSize returns a cheap size estimation for a restriction. This\n+//     size is an abstract scalar value that represents how much work a\n+//     restriction takes compared to other restrictions in the same DoFn. For\n+//     example, a size of 200 represents twice as much work as a size of\n+//     100, but the numbers do not represent anything on their own. Size is\n+//     used by runners to estimate work for liquid sharding.\n+// * `CreateTracker(restriction) sdf.RTracker`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffb8b565be8a3c42b8df805005b19c19bc8cd42c"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE3MDEwNw==", "bodyText": "Ah, good point. It's supposed to be a concrete type implementing the sdf.RTracker interface. I'll update this to mention that explicitly.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416170107", "createdAt": "2020-04-27T21:43:27Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/pardo.go", "diffHunk": "@@ -222,6 +222,81 @@ func ParDo0(s Scope, dofn interface{}, col PCollection, opts ...Option) {\n // DoFn instance via output PCollections, in the absence of external\n // communication mechanisms written by user code.\n //\n+// Splittable DoFns\n+//\n+// Splittable DoFns are DoFns that are able to split work within an element,\n+// as opposed to only at element boundaries like normal DoFns. This is useful\n+// for DoFns that emit many outputs per input element and can distribute that\n+// work among multiple workers. The most common examples of this are sources.\n+//\n+// In order to split work within an element, splittable DoFns use the concept of\n+// restrictions, which are objects that are associated with an element and\n+// describe a portion of work on that element. For example, a restriction\n+// associated with a filename might describe what byte range within that file to\n+// process. In addition to restrictions, splittable DoFns also rely on\n+// restriction trackers to track progress and perform splits on a restriction\n+// currently being processed. See the `RTracker` interface in core/sdf/sdf.go\n+// for more details.\n+//\n+// Splitting\n+//\n+// Splitting means taking one restriction and splitting into two or more that\n+// cover the entire input space of the original one. In other words, processing\n+// all the split restrictions should produce identical output to processing\n+// the original one.\n+//\n+// Splitting occurs in two stages. The initial splitting occurs before any\n+// restrictions have started processing. This step is used to split large\n+// restrictions into smaller ones that can then be distributed among multiple\n+// workers for processing. Initial splitting is user-defined and optional.\n+//\n+// Dynamic splitting occurs during the processing of a restriction in runners\n+// that have implemented it. If there are available workers, runners may split\n+// the unprocessed portion of work from a busy worker and shard it to available\n+// workers in order to better distribute work. With unsplittable DoFns this can\n+// only occur on element boundaries, but for splittable DoFns this split\n+// can land within a restriction and will require splitting that restriction.\n+//\n+// * Note: The Go SDK currently does not support dynamic splitting for SDFs,\n+//   only initial splitting. Work can only be split at element boundaries.\n+//\n+// Splittable DoFn Methods\n+//\n+// Making a splittable DoFn requires the following methods to be implemented on\n+// a DoFn in addition to the usual DoFn requirements. In the following\n+// method signatures `elem` represents the main input elements to the DoFn, and\n+// should match the types used in ProcessElement. `restriction` represents the\n+// user-defined restriction, and can be any type as long as it is consistent\n+// throughout all the splittable DoFn methods:\n+//\n+// * `CreateInitialRestriction(element) restriction`\n+//     CreateInitialRestriction creates an initial restriction encompassing an\n+//     entire element. The restriction created stays associated with the element\n+//     it describes.\n+// * `SplitRestriction(elem, restriction) []restriction`\n+//     SplitRestriction takes an element and its initial restriction, and\n+//     optionally performs an initial split on it, returning a slice of all the\n+//     split restrictions. If no splits are desired, the method returns a slice\n+//     containing only the original restriction. This method will always be\n+//     called on each newly created restriction before they are processed.\n+// * `RestrictionSize(elem, restriction) float64`\n+//     RestrictionSize returns a cheap size estimation for a restriction. This\n+//     size is an abstract scalar value that represents how much work a\n+//     restriction takes compared to other restrictions in the same DoFn. For\n+//     example, a size of 200 represents twice as much work as a size of\n+//     100, but the numbers do not represent anything on their own. Size is\n+//     used by runners to estimate work for liquid sharding.\n+// * `CreateTracker(restriction) sdf.RTracker`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA5MTE4OA=="}, "originalCommit": {"oid": "ffb8b565be8a3c42b8df805005b19c19bc8cd42c"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxMzgyNA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416313824", "createdAt": "2020-04-28T04:15:36Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/pardo.go", "diffHunk": "@@ -222,6 +222,81 @@ func ParDo0(s Scope, dofn interface{}, col PCollection, opts ...Option) {\n // DoFn instance via output PCollections, in the absence of external\n // communication mechanisms written by user code.\n //\n+// Splittable DoFns\n+//\n+// Splittable DoFns are DoFns that are able to split work within an element,\n+// as opposed to only at element boundaries like normal DoFns. This is useful\n+// for DoFns that emit many outputs per input element and can distribute that\n+// work among multiple workers. The most common examples of this are sources.\n+//\n+// In order to split work within an element, splittable DoFns use the concept of\n+// restrictions, which are objects that are associated with an element and\n+// describe a portion of work on that element. For example, a restriction\n+// associated with a filename might describe what byte range within that file to\n+// process. In addition to restrictions, splittable DoFns also rely on\n+// restriction trackers to track progress and perform splits on a restriction\n+// currently being processed. See the `RTracker` interface in core/sdf/sdf.go\n+// for more details.\n+//\n+// Splitting\n+//\n+// Splitting means taking one restriction and splitting into two or more that\n+// cover the entire input space of the original one. In other words, processing\n+// all the split restrictions should produce identical output to processing\n+// the original one.\n+//\n+// Splitting occurs in two stages. The initial splitting occurs before any\n+// restrictions have started processing. This step is used to split large\n+// restrictions into smaller ones that can then be distributed among multiple\n+// workers for processing. Initial splitting is user-defined and optional.\n+//\n+// Dynamic splitting occurs during the processing of a restriction in runners\n+// that have implemented it. If there are available workers, runners may split\n+// the unprocessed portion of work from a busy worker and shard it to available\n+// workers in order to better distribute work. With unsplittable DoFns this can\n+// only occur on element boundaries, but for splittable DoFns this split\n+// can land within a restriction and will require splitting that restriction.\n+//\n+// * Note: The Go SDK currently does not support dynamic splitting for SDFs,\n+//   only initial splitting. Work can only be split at element boundaries.\n+//\n+// Splittable DoFn Methods\n+//\n+// Making a splittable DoFn requires the following methods to be implemented on\n+// a DoFn in addition to the usual DoFn requirements. In the following\n+// method signatures `elem` represents the main input elements to the DoFn, and\n+// should match the types used in ProcessElement. `restriction` represents the\n+// user-defined restriction, and can be any type as long as it is consistent\n+// throughout all the splittable DoFn methods:\n+//\n+// * `CreateInitialRestriction(element) restriction`\n+//     CreateInitialRestriction creates an initial restriction encompassing an\n+//     entire element. The restriction created stays associated with the element\n+//     it describes.\n+// * `SplitRestriction(elem, restriction) []restriction`\n+//     SplitRestriction takes an element and its initial restriction, and\n+//     optionally performs an initial split on it, returning a slice of all the\n+//     split restrictions. If no splits are desired, the method returns a slice\n+//     containing only the original restriction. This method will always be\n+//     called on each newly created restriction before they are processed.\n+// * `RestrictionSize(elem, restriction) float64`\n+//     RestrictionSize returns a cheap size estimation for a restriction. This\n+//     size is an abstract scalar value that represents how much work a\n+//     restriction takes compared to other restrictions in the same DoFn. For\n+//     example, a size of 200 represents twice as much work as a size of\n+//     100, but the numbers do not represent anything on their own. Size is\n+//     used by runners to estimate work for liquid sharding.\n+// * `CreateTracker(restriction) sdf.RTracker`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA5MTE4OA=="}, "originalCommit": {"oid": "ffb8b565be8a3c42b8df805005b19c19bc8cd42c"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDAyODE4OnYy", "diffSide": "RIGHT", "path": "sdks/go/examples/stringsplit/offsetrange/offsetrange.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToyMToyNVrOGNnbKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMTo1MToyN1rOGOXDFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMDYwMA==", "bodyText": "Might be worth documenting this behavior in the comment.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416930600", "createdAt": "2020-04-28T21:21:25Z", "author": {"login": "lostluck"}, "path": "sdks/go/examples/stringsplit/offsetrange/offsetrange.go", "diffHunk": "@@ -89,21 +89,23 @@ func (tracker *Tracker) GetError() error {\n }\n \n // TrySplit splits at the nearest integer greater than the given fraction of the remainder.\n-func (tracker *Tracker) TrySplit(fraction float64) (interface{}, error) {\n+func (tracker *Tracker) TrySplit(fraction float64) (interface{}, interface{}, error) {\n \tif tracker.Stopped || tracker.IsDone() {\n-\t\treturn nil, nil\n+\t\treturn tracker.Rest, nil, nil\n \t}\n-\tif fraction < 0 || fraction > 1 {\n-\t\treturn nil, errors.New(\"fraction must be in range [0, 1]\")\n+\tif fraction < 0 {\n+\t\tfraction = 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcxMDg3MQ==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11517#discussion_r417710871", "createdAt": "2020-04-30T01:51:27Z", "author": {"login": "youngoli"}, "path": "sdks/go/examples/stringsplit/offsetrange/offsetrange.go", "diffHunk": "@@ -89,21 +89,23 @@ func (tracker *Tracker) GetError() error {\n }\n \n // TrySplit splits at the nearest integer greater than the given fraction of the remainder.\n-func (tracker *Tracker) TrySplit(fraction float64) (interface{}, error) {\n+func (tracker *Tracker) TrySplit(fraction float64) (interface{}, interface{}, error) {\n \tif tracker.Stopped || tracker.IsDone() {\n-\t\treturn nil, nil\n+\t\treturn tracker.Rest, nil, nil\n \t}\n-\tif fraction < 0 || fraction > 1 {\n-\t\treturn nil, errors.New(\"fraction must be in range [0, 1]\")\n+\tif fraction < 0 {\n+\t\tfraction = 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMDYwMA=="}, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDAzMzA3OnYy", "diffSide": "RIGHT", "path": "sdks/go/examples/stringsplit/offsetrange/offsetrange.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToyMjo0N1rOGNneCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMTo1MTozMlrOGOXDLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMTMzNg==", "bodyText": "Given this is the example, using named return values (primary, residual ...) is appropriate here for documentation purposes (but not so one can use an empty return.)", "url": "https://github.com/apache/beam/pull/11517#discussion_r416931336", "createdAt": "2020-04-28T21:22:47Z", "author": {"login": "lostluck"}, "path": "sdks/go/examples/stringsplit/offsetrange/offsetrange.go", "diffHunk": "@@ -89,21 +89,23 @@ func (tracker *Tracker) GetError() error {\n }\n \n // TrySplit splits at the nearest integer greater than the given fraction of the remainder.\n-func (tracker *Tracker) TrySplit(fraction float64) (interface{}, error) {\n+func (tracker *Tracker) TrySplit(fraction float64) (interface{}, interface{}, error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcxMDg5NQ==", "bodyText": "Good point, done.", "url": "https://github.com/apache/beam/pull/11517#discussion_r417710895", "createdAt": "2020-04-30T01:51:32Z", "author": {"login": "youngoli"}, "path": "sdks/go/examples/stringsplit/offsetrange/offsetrange.go", "diffHunk": "@@ -89,21 +89,23 @@ func (tracker *Tracker) GetError() error {\n }\n \n // TrySplit splits at the nearest integer greater than the given fraction of the remainder.\n-func (tracker *Tracker) TrySplit(fraction float64) (interface{}, error) {\n+func (tracker *Tracker) TrySplit(fraction float64) (interface{}, interface{}, error) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMTMzNg=="}, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDAzODkzOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToyNDoyOVrOGNnhng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToyNDoyOVrOGNnhng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMjI1NA==", "bodyText": "+1 to this concrete example.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416932254", "createdAt": "2020-04-28T21:24:29Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "diffHunk": "@@ -13,63 +13,64 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-// Package sdf is experimental, incomplete, and not yet meant for general usage.\n+// Package contains interfaces used specifically for splittable DoFns.\n+//\n+// Warning: Splittable DoFns are still experimental, largely untested, and\n+// likely to have bugs.\n package sdf\n \n // RTracker is an interface used to interact with restrictions while processing elements in\n-// SplittableDoFns. Each implementation of RTracker is expected to be used for tracking a single\n-// restriction type, which is the type that should be used to create the RTracker, and output by\n-// TrySplit.\n+// splittable DoFns (specifically, in the ProcessElement method). Each RTracker tracks the progress\n+// of a single restriction.\n type RTracker interface {\n-\t// TryClaim attempts to claim the block of work in the current restriction located at a given\n-\t// position. This method must be used in the ProcessElement method of Splittable DoFns to claim\n-\t// work before performing it. If no work is claimed, the ProcessElement is not allowed to perform\n-\t// work or emit outputs. If the claim is successful, the DoFn must process the entire block. If\n-\t// the claim is unsuccessful the ProcessElement method of the DoFn must return without performing\n-\t// any additional work or emitting any outputs.\n-\t//\n-\t// TryClaim accepts an arbitrary value that can be interpreted as the position of a block, and\n-\t// returns a boolean indicating whether the claim succeeded.\n+\t// TryClaim attempts to claim the block of work located in the given position of the\n+\t// restriction. This method must be called in ProcessElement to claim work before it can be\n+\t// processed. Processing work without claiming it first can lead to incorrect output.\n \t//\n-\t// If the claim fails due to an error, that error can be retrieved with GetError.\n+\t// If the claim is successful, the DoFn must process the entire block. If the claim is\n+\t// unsuccessful ProcessElement method of the DoFn must return without performing\n+\t// any additional work or emitting any outputs.\n \t//\n-\t// For SDFs to work properly, claims must always be monotonically increasing in reference to the\n-\t// restriction's start and end points, and every block of work in a restriction must be claimed.\n+\t// If the claim fails due to an error, that error is stored and will be automatically emitted\n+\t// when the RTracker is validated, or can be manually retrieved with GetError.\n \t//\n \t// This pseudocode example illustrates the typical usage of TryClaim:\n \t//\n-\t// \tpos = position of first block after restriction.start\n+\t// \tpos = position of first block within the restriction\n \t// \tfor TryClaim(pos) == true {\n \t// \t\t// Do all work in the claimed block and emit outputs.\n-\t// \t\tpos = position of next block\n+\t// \t\tpos = position of next block within the restriction\n \t// \t}\n \t// \treturn\n \tTryClaim(pos interface{}) (ok bool)\n \n-\t// GetError returns the error that made this RTracker stop executing, and it returns nil if no\n-\t// error occurred. If IsDone fails while validating this RTracker, this method will be\n-\t// called to log the error.\n+\t// GetError returns the error that made this RTracker stop executing, and returns nil if no\n+\t// error occurred. This is the error that is emitted if automated validation fails.\n \tGetError() error\n \n-\t// TrySplit splits the current restriction into a primary and residual based on a fraction of the\n-\t// work remaining. The split is performed along the first valid split point located after the\n-\t// given fraction of the remainder. This method is called by the SDK harness when receiving a\n-\t// split request by the runner.\n+\t// TrySplit splits the current restriction into a primary (currently executing work) and\n+\t// residual (work to be split off) based on a fraction of work remaining. The split is performed\n+\t// at the first valid split point located after the given fraction of remaining work.\n+\t//\n+\t// For example, a fraction of 0.5 means to split at the halfway point of remaining work only. If\n+\t// 50% of work is done and 50% remaining, then a fraction of 0.5 would split after 75% of work.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDA0NzkyOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/pardo.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToyNjo0OVrOGNnm9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMTo1MTozN1rOGOXDSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMzYyMg==", "bodyText": "Consider being explicit about sdf.RTracker being an interface.\neg... implementing the sdf.RTracker interface.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416933622", "createdAt": "2020-04-28T21:26:49Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/pardo.go", "diffHunk": "@@ -222,6 +222,87 @@ func ParDo0(s Scope, dofn interface{}, col PCollection, opts ...Option) {\n // DoFn instance via output PCollections, in the absence of external\n // communication mechanisms written by user code.\n //\n+// Splittable DoFns (Experimental)\n+//\n+// Warning: Splittable DoFns are still experimental, largely untested, and\n+// likely to have bugs.\n+//\n+// Splittable DoFns are DoFns that are able to split work within an element,\n+// as opposed to only at element boundaries like normal DoFns. This is useful\n+// for DoFns that emit many outputs per input element and can distribute that\n+// work among multiple workers. The most common examples of this are sources.\n+//\n+// In order to split work within an element, splittable DoFns use the concept of\n+// restrictions, which are objects that are associated with an element and\n+// describe a portion of work on that element. For example, a restriction\n+// associated with a filename might describe what byte range within that file to\n+// process. In addition to restrictions, splittable DoFns also rely on\n+// restriction trackers to track progress and perform splits on a restriction\n+// currently being processed. See the `RTracker` interface in core/sdf/sdf.go\n+// for more details.\n+//\n+// Splitting\n+//\n+// Splitting means taking one restriction and splitting into two or more that\n+// cover the entire input space of the original one. In other words, processing\n+// all the split restrictions should produce identical output to processing\n+// the original one.\n+//\n+// Splitting occurs in two stages. The initial splitting occurs before any\n+// restrictions have started processing. This step is used to split large\n+// restrictions into smaller ones that can then be distributed among multiple\n+// workers for processing. Initial splitting is user-defined and optional.\n+//\n+// Dynamic splitting occurs during the processing of a restriction in runners\n+// that have implemented it. If there are available workers, runners may split\n+// the unprocessed portion of work from a busy worker and shard it to available\n+// workers in order to better distribute work. With unsplittable DoFns this can\n+// only occur on element boundaries, but for splittable DoFns this split\n+// can land within a restriction and will require splitting that restriction.\n+//\n+// * Note: The Go SDK currently does not support dynamic splitting for SDFs,\n+//   only initial splitting. Only initially split restrictions can be\n+//   distributed by liquid sharding. Stragglers will not be split during\n+//   execution with dynamic splitting.\n+//\n+// Splittable DoFn Methods\n+//\n+// Making a splittable DoFn requires the following methods to be implemented on\n+// a DoFn in addition to the usual DoFn requirements. In the following\n+// method signatures `elem` represents the main input elements to the DoFn, and\n+// should match the types used in ProcessElement. `restriction` represents the\n+// user-defined restriction, and can be any type as long as it is consistent\n+// throughout all the splittable DoFn methods:\n+//\n+// * `CreateInitialRestriction(element) restriction`\n+//     CreateInitialRestriction creates an initial restriction encompassing an\n+//     entire element. The restriction created stays associated with the element\n+//     it describes.\n+// * `SplitRestriction(elem, restriction) []restriction`\n+//     SplitRestriction takes an element and its initial restriction, and\n+//     optionally performs an initial split on it, returning a slice of all the\n+//     split restrictions. If no splits are desired, the method returns a slice\n+//     containing only the original restriction. This method will always be\n+//     called on each newly created restriction before they are processed.\n+// * `RestrictionSize(elem, restriction) float64`\n+//     RestrictionSize returns a cheap size estimation for a restriction. This\n+//     size is an abstract scalar value that represents how much work a\n+//     restriction takes compared to other restrictions in the same DoFn. For\n+//     example, a size of 200 represents twice as much work as a size of\n+//     100, but the numbers do not represent anything on their own. Size is\n+//     used by runners to estimate work for liquid sharding.\n+// * `CreateTracker(restriction) restrictionTracker`\n+//     CreateTracker creates and returns a restriction tracker (a concrete type\n+//     implementing `sdf.RTracker`) given a restriction. The restriction tracker", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcxMDkyMQ==", "bodyText": "Don't see why not. Done.", "url": "https://github.com/apache/beam/pull/11517#discussion_r417710921", "createdAt": "2020-04-30T01:51:37Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/pardo.go", "diffHunk": "@@ -222,6 +222,87 @@ func ParDo0(s Scope, dofn interface{}, col PCollection, opts ...Option) {\n // DoFn instance via output PCollections, in the absence of external\n // communication mechanisms written by user code.\n //\n+// Splittable DoFns (Experimental)\n+//\n+// Warning: Splittable DoFns are still experimental, largely untested, and\n+// likely to have bugs.\n+//\n+// Splittable DoFns are DoFns that are able to split work within an element,\n+// as opposed to only at element boundaries like normal DoFns. This is useful\n+// for DoFns that emit many outputs per input element and can distribute that\n+// work among multiple workers. The most common examples of this are sources.\n+//\n+// In order to split work within an element, splittable DoFns use the concept of\n+// restrictions, which are objects that are associated with an element and\n+// describe a portion of work on that element. For example, a restriction\n+// associated with a filename might describe what byte range within that file to\n+// process. In addition to restrictions, splittable DoFns also rely on\n+// restriction trackers to track progress and perform splits on a restriction\n+// currently being processed. See the `RTracker` interface in core/sdf/sdf.go\n+// for more details.\n+//\n+// Splitting\n+//\n+// Splitting means taking one restriction and splitting into two or more that\n+// cover the entire input space of the original one. In other words, processing\n+// all the split restrictions should produce identical output to processing\n+// the original one.\n+//\n+// Splitting occurs in two stages. The initial splitting occurs before any\n+// restrictions have started processing. This step is used to split large\n+// restrictions into smaller ones that can then be distributed among multiple\n+// workers for processing. Initial splitting is user-defined and optional.\n+//\n+// Dynamic splitting occurs during the processing of a restriction in runners\n+// that have implemented it. If there are available workers, runners may split\n+// the unprocessed portion of work from a busy worker and shard it to available\n+// workers in order to better distribute work. With unsplittable DoFns this can\n+// only occur on element boundaries, but for splittable DoFns this split\n+// can land within a restriction and will require splitting that restriction.\n+//\n+// * Note: The Go SDK currently does not support dynamic splitting for SDFs,\n+//   only initial splitting. Only initially split restrictions can be\n+//   distributed by liquid sharding. Stragglers will not be split during\n+//   execution with dynamic splitting.\n+//\n+// Splittable DoFn Methods\n+//\n+// Making a splittable DoFn requires the following methods to be implemented on\n+// a DoFn in addition to the usual DoFn requirements. In the following\n+// method signatures `elem` represents the main input elements to the DoFn, and\n+// should match the types used in ProcessElement. `restriction` represents the\n+// user-defined restriction, and can be any type as long as it is consistent\n+// throughout all the splittable DoFn methods:\n+//\n+// * `CreateInitialRestriction(element) restriction`\n+//     CreateInitialRestriction creates an initial restriction encompassing an\n+//     entire element. The restriction created stays associated with the element\n+//     it describes.\n+// * `SplitRestriction(elem, restriction) []restriction`\n+//     SplitRestriction takes an element and its initial restriction, and\n+//     optionally performs an initial split on it, returning a slice of all the\n+//     split restrictions. If no splits are desired, the method returns a slice\n+//     containing only the original restriction. This method will always be\n+//     called on each newly created restriction before they are processed.\n+// * `RestrictionSize(elem, restriction) float64`\n+//     RestrictionSize returns a cheap size estimation for a restriction. This\n+//     size is an abstract scalar value that represents how much work a\n+//     restriction takes compared to other restrictions in the same DoFn. For\n+//     example, a size of 200 represents twice as much work as a size of\n+//     100, but the numbers do not represent anything on their own. Size is\n+//     used by runners to estimate work for liquid sharding.\n+// * `CreateTracker(restriction) restrictionTracker`\n+//     CreateTracker creates and returns a restriction tracker (a concrete type\n+//     implementing `sdf.RTracker`) given a restriction. The restriction tracker", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMzYyMg=="}, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDA1MDg5OnYy", "diffSide": "LEFT", "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToyNzozN1rOGNnouQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMTo1MTo0MFrOGOXDXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNDA3Mw==", "bodyText": "This cleanup is  separate from the rest of the change.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416934073", "createdAt": "2020-04-28T21:27:37Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "diffHunk": "@@ -43,7 +43,7 @@ func Stage(ctx context.Context, id, endpoint, binary, st string) (retrievalToken\n \t\treturn \"\", nil\n \t}\n \n-  return StageViaLegacyApi(ctx, cc, binary, st)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcxMDk0Mg==", "bodyText": "Came bundled in with go fmt but I'll move it to a separate PR.", "url": "https://github.com/apache/beam/pull/11517#discussion_r417710942", "createdAt": "2020-04-30T01:51:40Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "diffHunk": "@@ -43,7 +43,7 @@ func Stage(ctx context.Context, id, endpoint, binary, st string) (retrievalToken\n \t\treturn \"\", nil\n \t}\n \n-  return StageViaLegacyApi(ctx, cc, binary, st)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNDA3Mw=="}, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDExMTkwOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo0NjozMlrOGNoOEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMTo1MTo0NFrOGOXDaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MzYzNQ==", "bodyText": "It would be worth explicitly saying that the position type is related directly to the type of Restriction being handled.\nEg.\nA linear offset restriction could use a single int64 value to represent a position. Similarly a multi dimensional restriction space could use a more complex type to represent the area claimed as a position.", "url": "https://github.com/apache/beam/pull/11517#discussion_r416943635", "createdAt": "2020-04-28T21:46:32Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "diffHunk": "@@ -13,63 +13,64 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-// Package sdf is experimental, incomplete, and not yet meant for general usage.\n+// Package contains interfaces used specifically for splittable DoFns.\n+//\n+// Warning: Splittable DoFns are still experimental, largely untested, and\n+// likely to have bugs.\n package sdf\n \n // RTracker is an interface used to interact with restrictions while processing elements in\n-// SplittableDoFns. Each implementation of RTracker is expected to be used for tracking a single\n-// restriction type, which is the type that should be used to create the RTracker, and output by\n-// TrySplit.\n+// splittable DoFns (specifically, in the ProcessElement method). Each RTracker tracks the progress\n+// of a single restriction.\n type RTracker interface {\n-\t// TryClaim attempts to claim the block of work in the current restriction located at a given\n-\t// position. This method must be used in the ProcessElement method of Splittable DoFns to claim\n-\t// work before performing it. If no work is claimed, the ProcessElement is not allowed to perform\n-\t// work or emit outputs. If the claim is successful, the DoFn must process the entire block. If\n-\t// the claim is unsuccessful the ProcessElement method of the DoFn must return without performing\n-\t// any additional work or emitting any outputs.\n-\t//\n-\t// TryClaim accepts an arbitrary value that can be interpreted as the position of a block, and\n-\t// returns a boolean indicating whether the claim succeeded.\n+\t// TryClaim attempts to claim the block of work located in the given position of the\n+\t// restriction. This method must be called in ProcessElement to claim work before it can be\n+\t// processed. Processing work without claiming it first can lead to incorrect output.\n \t//\n-\t// If the claim fails due to an error, that error can be retrieved with GetError.\n+\t// If the claim is successful, the DoFn must process the entire block. If the claim is\n+\t// unsuccessful ProcessElement method of the DoFn must return without performing\n+\t// any additional work or emitting any outputs.\n \t//\n-\t// For SDFs to work properly, claims must always be monotonically increasing in reference to the\n-\t// restriction's start and end points, and every block of work in a restriction must be claimed.\n+\t// If the claim fails due to an error, that error is stored and will be automatically emitted\n+\t// when the RTracker is validated, or can be manually retrieved with GetError.\n \t//\n \t// This pseudocode example illustrates the typical usage of TryClaim:\n \t//\n-\t// \tpos = position of first block after restriction.start\n+\t// \tpos = position of first block within the restriction\n \t// \tfor TryClaim(pos) == true {\n \t// \t\t// Do all work in the claimed block and emit outputs.\n-\t// \t\tpos = position of next block\n+\t// \t\tpos = position of next block within the restriction\n \t// \t}\n \t// \treturn\n \tTryClaim(pos interface{}) (ok bool)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcxMDk1NQ==", "bodyText": "Good idea, done.", "url": "https://github.com/apache/beam/pull/11517#discussion_r417710955", "createdAt": "2020-04-30T01:51:44Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "diffHunk": "@@ -13,63 +13,64 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-// Package sdf is experimental, incomplete, and not yet meant for general usage.\n+// Package contains interfaces used specifically for splittable DoFns.\n+//\n+// Warning: Splittable DoFns are still experimental, largely untested, and\n+// likely to have bugs.\n package sdf\n \n // RTracker is an interface used to interact with restrictions while processing elements in\n-// SplittableDoFns. Each implementation of RTracker is expected to be used for tracking a single\n-// restriction type, which is the type that should be used to create the RTracker, and output by\n-// TrySplit.\n+// splittable DoFns (specifically, in the ProcessElement method). Each RTracker tracks the progress\n+// of a single restriction.\n type RTracker interface {\n-\t// TryClaim attempts to claim the block of work in the current restriction located at a given\n-\t// position. This method must be used in the ProcessElement method of Splittable DoFns to claim\n-\t// work before performing it. If no work is claimed, the ProcessElement is not allowed to perform\n-\t// work or emit outputs. If the claim is successful, the DoFn must process the entire block. If\n-\t// the claim is unsuccessful the ProcessElement method of the DoFn must return without performing\n-\t// any additional work or emitting any outputs.\n-\t//\n-\t// TryClaim accepts an arbitrary value that can be interpreted as the position of a block, and\n-\t// returns a boolean indicating whether the claim succeeded.\n+\t// TryClaim attempts to claim the block of work located in the given position of the\n+\t// restriction. This method must be called in ProcessElement to claim work before it can be\n+\t// processed. Processing work without claiming it first can lead to incorrect output.\n \t//\n-\t// If the claim fails due to an error, that error can be retrieved with GetError.\n+\t// If the claim is successful, the DoFn must process the entire block. If the claim is\n+\t// unsuccessful ProcessElement method of the DoFn must return without performing\n+\t// any additional work or emitting any outputs.\n \t//\n-\t// For SDFs to work properly, claims must always be monotonically increasing in reference to the\n-\t// restriction's start and end points, and every block of work in a restriction must be claimed.\n+\t// If the claim fails due to an error, that error is stored and will be automatically emitted\n+\t// when the RTracker is validated, or can be manually retrieved with GetError.\n \t//\n \t// This pseudocode example illustrates the typical usage of TryClaim:\n \t//\n-\t// \tpos = position of first block after restriction.start\n+\t// \tpos = position of first block within the restriction\n \t// \tfor TryClaim(pos) == true {\n \t// \t\t// Do all work in the claimed block and emit outputs.\n-\t// \t\tpos = position of next block\n+\t// \t\tpos = position of next block within the restriction\n \t// \t}\n \t// \treturn\n \tTryClaim(pos interface{}) (ok bool)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MzYzNQ=="}, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDEyOTc1OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo1MjozOVrOGNoY7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxODoyMTo1NVrOGQMhDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjQxNA==", "bodyText": "IIRC for dynamic splitting, this is the one that requires the Tracker to be concurrency safe? Do we want to declared ahead of time that implementations of RTracker must be threadsafe?", "url": "https://github.com/apache/beam/pull/11517#discussion_r416946414", "createdAt": "2020-04-28T21:52:39Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "diffHunk": "@@ -13,63 +13,64 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-// Package sdf is experimental, incomplete, and not yet meant for general usage.\n+// Package contains interfaces used specifically for splittable DoFns.\n+//\n+// Warning: Splittable DoFns are still experimental, largely untested, and\n+// likely to have bugs.\n package sdf\n \n // RTracker is an interface used to interact with restrictions while processing elements in\n-// SplittableDoFns. Each implementation of RTracker is expected to be used for tracking a single\n-// restriction type, which is the type that should be used to create the RTracker, and output by\n-// TrySplit.\n+// splittable DoFns (specifically, in the ProcessElement method). Each RTracker tracks the progress\n+// of a single restriction.\n type RTracker interface {\n-\t// TryClaim attempts to claim the block of work in the current restriction located at a given\n-\t// position. This method must be used in the ProcessElement method of Splittable DoFns to claim\n-\t// work before performing it. If no work is claimed, the ProcessElement is not allowed to perform\n-\t// work or emit outputs. If the claim is successful, the DoFn must process the entire block. If\n-\t// the claim is unsuccessful the ProcessElement method of the DoFn must return without performing\n-\t// any additional work or emitting any outputs.\n-\t//\n-\t// TryClaim accepts an arbitrary value that can be interpreted as the position of a block, and\n-\t// returns a boolean indicating whether the claim succeeded.\n+\t// TryClaim attempts to claim the block of work located in the given position of the\n+\t// restriction. This method must be called in ProcessElement to claim work before it can be\n+\t// processed. Processing work without claiming it first can lead to incorrect output.\n \t//\n-\t// If the claim fails due to an error, that error can be retrieved with GetError.\n+\t// If the claim is successful, the DoFn must process the entire block. If the claim is\n+\t// unsuccessful ProcessElement method of the DoFn must return without performing\n+\t// any additional work or emitting any outputs.\n \t//\n-\t// For SDFs to work properly, claims must always be monotonically increasing in reference to the\n-\t// restriction's start and end points, and every block of work in a restriction must be claimed.\n+\t// If the claim fails due to an error, that error is stored and will be automatically emitted\n+\t// when the RTracker is validated, or can be manually retrieved with GetError.\n \t//\n \t// This pseudocode example illustrates the typical usage of TryClaim:\n \t//\n-\t// \tpos = position of first block after restriction.start\n+\t// \tpos = position of first block within the restriction\n \t// \tfor TryClaim(pos) == true {\n \t// \t\t// Do all work in the claimed block and emit outputs.\n-\t// \t\tpos = position of next block\n+\t// \t\tpos = position of next block within the restriction\n \t// \t}\n \t// \treturn\n \tTryClaim(pos interface{}) (ok bool)\n \n-\t// GetError returns the error that made this RTracker stop executing, and it returns nil if no\n-\t// error occurred. If IsDone fails while validating this RTracker, this method will be\n-\t// called to log the error.\n+\t// GetError returns the error that made this RTracker stop executing, and returns nil if no\n+\t// error occurred. This is the error that is emitted if automated validation fails.\n \tGetError() error\n \n-\t// TrySplit splits the current restriction into a primary and residual based on a fraction of the\n-\t// work remaining. The split is performed along the first valid split point located after the\n-\t// given fraction of the remainder. This method is called by the SDK harness when receiving a\n-\t// split request by the runner.\n+\t// TrySplit splits the current restriction into a primary (currently executing work) and\n+\t// residual (work to be split off) based on a fraction of work remaining. The split is performed\n+\t// at the first valid split point located after the given fraction of remaining work.\n+\t//\n+\t// For example, a fraction of 0.5 means to split at the halfway point of remaining work only. If\n+\t// 50% of work is done and 50% remaining, then a fraction of 0.5 would split after 75% of work.\n+\t//\n+\t// This method modifies the underlying restriction in the RTracker to reflect the primary. It\n+\t// then returns a copy of the newly modified restriction as a primary, and returns a new\n+\t// restriction for the residual. If the split would produce an empty residual (i.e. the only\n+\t// split point is the end of the restriction), then the returned residual is nil.\n \t//\n-\t// The current restriction is split into two by modifying the current restriction's endpoint to\n-\t// turn it into the primary, and returning a new restriction tracker representing the residual.\n-\t// If no valid split point exists, this method returns nil instead of a residual, but does not\n-\t// return an error. If this method is unable to split due to some error then it returns nil and\n-\t// an error.\n-\tTrySplit(fraction float64) (residual interface{}, err error)\n+\t// If an error is returned, some catastrophic failure occurred and the entire bundle will fail.\n+\tTrySplit(fraction float64) (primary, residual interface{}, err error)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcxMDk2Mg==", "bodyText": "Hmm, good point. It's definitely something a use should know, especially for writing future-proof SDFs. It would need to be in all the methods I think, except maybe GetError. I'm not completely sure off the top of my head though, I feel like it'll depend on the details of how we do dynamic splitting.\nFor now I'll add a comment saying to make all methods thread-safe. Later we should add the thread-safe wrapper and recommend using that, and if we can dodge mutexes in some methods then we can implement it there.", "url": "https://github.com/apache/beam/pull/11517#discussion_r417710962", "createdAt": "2020-04-30T01:51:47Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "diffHunk": "@@ -13,63 +13,64 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-// Package sdf is experimental, incomplete, and not yet meant for general usage.\n+// Package contains interfaces used specifically for splittable DoFns.\n+//\n+// Warning: Splittable DoFns are still experimental, largely untested, and\n+// likely to have bugs.\n package sdf\n \n // RTracker is an interface used to interact with restrictions while processing elements in\n-// SplittableDoFns. Each implementation of RTracker is expected to be used for tracking a single\n-// restriction type, which is the type that should be used to create the RTracker, and output by\n-// TrySplit.\n+// splittable DoFns (specifically, in the ProcessElement method). Each RTracker tracks the progress\n+// of a single restriction.\n type RTracker interface {\n-\t// TryClaim attempts to claim the block of work in the current restriction located at a given\n-\t// position. This method must be used in the ProcessElement method of Splittable DoFns to claim\n-\t// work before performing it. If no work is claimed, the ProcessElement is not allowed to perform\n-\t// work or emit outputs. If the claim is successful, the DoFn must process the entire block. If\n-\t// the claim is unsuccessful the ProcessElement method of the DoFn must return without performing\n-\t// any additional work or emitting any outputs.\n-\t//\n-\t// TryClaim accepts an arbitrary value that can be interpreted as the position of a block, and\n-\t// returns a boolean indicating whether the claim succeeded.\n+\t// TryClaim attempts to claim the block of work located in the given position of the\n+\t// restriction. This method must be called in ProcessElement to claim work before it can be\n+\t// processed. Processing work without claiming it first can lead to incorrect output.\n \t//\n-\t// If the claim fails due to an error, that error can be retrieved with GetError.\n+\t// If the claim is successful, the DoFn must process the entire block. If the claim is\n+\t// unsuccessful ProcessElement method of the DoFn must return without performing\n+\t// any additional work or emitting any outputs.\n \t//\n-\t// For SDFs to work properly, claims must always be monotonically increasing in reference to the\n-\t// restriction's start and end points, and every block of work in a restriction must be claimed.\n+\t// If the claim fails due to an error, that error is stored and will be automatically emitted\n+\t// when the RTracker is validated, or can be manually retrieved with GetError.\n \t//\n \t// This pseudocode example illustrates the typical usage of TryClaim:\n \t//\n-\t// \tpos = position of first block after restriction.start\n+\t// \tpos = position of first block within the restriction\n \t// \tfor TryClaim(pos) == true {\n \t// \t\t// Do all work in the claimed block and emit outputs.\n-\t// \t\tpos = position of next block\n+\t// \t\tpos = position of next block within the restriction\n \t// \t}\n \t// \treturn\n \tTryClaim(pos interface{}) (ok bool)\n \n-\t// GetError returns the error that made this RTracker stop executing, and it returns nil if no\n-\t// error occurred. If IsDone fails while validating this RTracker, this method will be\n-\t// called to log the error.\n+\t// GetError returns the error that made this RTracker stop executing, and returns nil if no\n+\t// error occurred. This is the error that is emitted if automated validation fails.\n \tGetError() error\n \n-\t// TrySplit splits the current restriction into a primary and residual based on a fraction of the\n-\t// work remaining. The split is performed along the first valid split point located after the\n-\t// given fraction of the remainder. This method is called by the SDK harness when receiving a\n-\t// split request by the runner.\n+\t// TrySplit splits the current restriction into a primary (currently executing work) and\n+\t// residual (work to be split off) based on a fraction of work remaining. The split is performed\n+\t// at the first valid split point located after the given fraction of remaining work.\n+\t//\n+\t// For example, a fraction of 0.5 means to split at the halfway point of remaining work only. If\n+\t// 50% of work is done and 50% remaining, then a fraction of 0.5 would split after 75% of work.\n+\t//\n+\t// This method modifies the underlying restriction in the RTracker to reflect the primary. It\n+\t// then returns a copy of the newly modified restriction as a primary, and returns a new\n+\t// restriction for the residual. If the split would produce an empty residual (i.e. the only\n+\t// split point is the end of the restriction), then the returned residual is nil.\n \t//\n-\t// The current restriction is split into two by modifying the current restriction's endpoint to\n-\t// turn it into the primary, and returning a new restriction tracker representing the residual.\n-\t// If no valid split point exists, this method returns nil instead of a residual, but does not\n-\t// return an error. If this method is unable to split due to some error then it returns nil and\n-\t// an error.\n-\tTrySplit(fraction float64) (residual interface{}, err error)\n+\t// If an error is returned, some catastrophic failure occurred and the entire bundle will fail.\n+\tTrySplit(fraction float64) (primary, residual interface{}, err error)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjQxNA=="}, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNTQ2OQ==", "bodyText": "Technically since GetError is going to be reading from a location that might be concurrently modified, it's required to be thread safe as well.", "url": "https://github.com/apache/beam/pull/11517#discussion_r419635469", "createdAt": "2020-05-04T18:21:55Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/sdf/sdf.go", "diffHunk": "@@ -13,63 +13,64 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-// Package sdf is experimental, incomplete, and not yet meant for general usage.\n+// Package contains interfaces used specifically for splittable DoFns.\n+//\n+// Warning: Splittable DoFns are still experimental, largely untested, and\n+// likely to have bugs.\n package sdf\n \n // RTracker is an interface used to interact with restrictions while processing elements in\n-// SplittableDoFns. Each implementation of RTracker is expected to be used for tracking a single\n-// restriction type, which is the type that should be used to create the RTracker, and output by\n-// TrySplit.\n+// splittable DoFns (specifically, in the ProcessElement method). Each RTracker tracks the progress\n+// of a single restriction.\n type RTracker interface {\n-\t// TryClaim attempts to claim the block of work in the current restriction located at a given\n-\t// position. This method must be used in the ProcessElement method of Splittable DoFns to claim\n-\t// work before performing it. If no work is claimed, the ProcessElement is not allowed to perform\n-\t// work or emit outputs. If the claim is successful, the DoFn must process the entire block. If\n-\t// the claim is unsuccessful the ProcessElement method of the DoFn must return without performing\n-\t// any additional work or emitting any outputs.\n-\t//\n-\t// TryClaim accepts an arbitrary value that can be interpreted as the position of a block, and\n-\t// returns a boolean indicating whether the claim succeeded.\n+\t// TryClaim attempts to claim the block of work located in the given position of the\n+\t// restriction. This method must be called in ProcessElement to claim work before it can be\n+\t// processed. Processing work without claiming it first can lead to incorrect output.\n \t//\n-\t// If the claim fails due to an error, that error can be retrieved with GetError.\n+\t// If the claim is successful, the DoFn must process the entire block. If the claim is\n+\t// unsuccessful ProcessElement method of the DoFn must return without performing\n+\t// any additional work or emitting any outputs.\n \t//\n-\t// For SDFs to work properly, claims must always be monotonically increasing in reference to the\n-\t// restriction's start and end points, and every block of work in a restriction must be claimed.\n+\t// If the claim fails due to an error, that error is stored and will be automatically emitted\n+\t// when the RTracker is validated, or can be manually retrieved with GetError.\n \t//\n \t// This pseudocode example illustrates the typical usage of TryClaim:\n \t//\n-\t// \tpos = position of first block after restriction.start\n+\t// \tpos = position of first block within the restriction\n \t// \tfor TryClaim(pos) == true {\n \t// \t\t// Do all work in the claimed block and emit outputs.\n-\t// \t\tpos = position of next block\n+\t// \t\tpos = position of next block within the restriction\n \t// \t}\n \t// \treturn\n \tTryClaim(pos interface{}) (ok bool)\n \n-\t// GetError returns the error that made this RTracker stop executing, and it returns nil if no\n-\t// error occurred. If IsDone fails while validating this RTracker, this method will be\n-\t// called to log the error.\n+\t// GetError returns the error that made this RTracker stop executing, and returns nil if no\n+\t// error occurred. This is the error that is emitted if automated validation fails.\n \tGetError() error\n \n-\t// TrySplit splits the current restriction into a primary and residual based on a fraction of the\n-\t// work remaining. The split is performed along the first valid split point located after the\n-\t// given fraction of the remainder. This method is called by the SDK harness when receiving a\n-\t// split request by the runner.\n+\t// TrySplit splits the current restriction into a primary (currently executing work) and\n+\t// residual (work to be split off) based on a fraction of work remaining. The split is performed\n+\t// at the first valid split point located after the given fraction of remaining work.\n+\t//\n+\t// For example, a fraction of 0.5 means to split at the halfway point of remaining work only. If\n+\t// 50% of work is done and 50% remaining, then a fraction of 0.5 would split after 75% of work.\n+\t//\n+\t// This method modifies the underlying restriction in the RTracker to reflect the primary. It\n+\t// then returns a copy of the newly modified restriction as a primary, and returns a new\n+\t// restriction for the residual. If the split would produce an empty residual (i.e. the only\n+\t// split point is the end of the restriction), then the returned residual is nil.\n \t//\n-\t// The current restriction is split into two by modifying the current restriction's endpoint to\n-\t// turn it into the primary, and returning a new restriction tracker representing the residual.\n-\t// If no valid split point exists, this method returns nil instead of a residual, but does not\n-\t// return an error. If this method is unable to split due to some error then it returns nil and\n-\t// an error.\n-\tTrySplit(fraction float64) (residual interface{}, err error)\n+\t// If an error is returned, some catastrophic failure occurred and the entire bundle will fail.\n+\tTrySplit(fraction float64) (primary, residual interface{}, err error)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjQxNA=="}, "originalCommit": {"oid": "c75634fa7b3bf652ab3c209183f3faa6cd87d173"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1126, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}