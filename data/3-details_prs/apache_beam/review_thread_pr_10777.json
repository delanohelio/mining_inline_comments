{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNTkzNjU2", "number": 10777, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzowODowM1rODdwvig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwMToxOToxNlrODfY1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTMzODk4OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzowODowM1rOFmjG6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzowODowM1rOFmjG6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk2NTQxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tUrn:    \"beam:metric:user\",\n          \n          \n            \n            \t\t\t\t\tUrn:    \"beam:metric:user_distribution\",", "url": "https://github.com/apache/beam/pull/10777#discussion_r375965416", "createdAt": "2020-02-06T17:08:03Z", "author": {"login": "lukecwik"}, "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "diffHunk": "@@ -0,0 +1,195 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package harness\n+\n+import (\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n+\tfnpb \"github.com/apache/beam/sdks/go/pkg/beam/model/fnexecution_v1\"\n+\tppb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/golang/protobuf/ptypes\"\n+)\n+\n+func monitoring(p *exec.Plan) (*fnpb.Metrics, []*ppb.MonitoringInfo) {\n+\t// Get the legacy style metrics.\n+\ttransforms := make(map[string]*fnpb.Metrics_PTransform)\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_CounterData_{\n+\t\t\t\t\tCounterData: &fnpb.Metrics_User_CounterData{\n+\t\t\t\t\t\tValue: v,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_DistributionData_{\n+\t\t\t\t\tDistributionData: &fnpb.Metrics_User_DistributionData{\n+\t\t\t\t\t\tCount: count,\n+\t\t\t\t\t\tSum:   sum,\n+\t\t\t\t\t\tMin:   min,\n+\t\t\t\t\t\tMax:   max,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tGaugeInt64: func(l metrics.Labels, v int64, t time.Time) {\n+\t\t\tts, err := ptypes.TimestampProto(t)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_GaugeData_{\n+\t\t\t\t\tGaugeData: &fnpb.Metrics_User_GaugeData{\n+\t\t\t\t\t\tValue:     v,\n+\t\t\t\t\t\tTimestamp: ts,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t}.ExtractFrom(p.Store)\n+\n+\t// Get the MonitoringInfo versions.\n+\tvar monitoringInfo []*ppb.MonitoringInfo\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",\n+\t\t\t\t\tType:   \"beam:metrics:sum_int_64\",\n+\t\t\t\t\tLabels: userLabels(l),\n+\t\t\t\t\tData:   int64Counter(v),\n+\t\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bebb5e7be800e0ed2bda7213d83fee5bdbec43b"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTMzOTY0OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzowODoxM1rOFmjHTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzowODoxM1rOFmjHTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk2NTUxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tType:   \"beam:metrics:sum_int_64\",\n          \n          \n            \n            \t\t\t\t\tType:   \"beam:metrics:distribution_int_64\",", "url": "https://github.com/apache/beam/pull/10777#discussion_r375965516", "createdAt": "2020-02-06T17:08:13Z", "author": {"login": "lukecwik"}, "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "diffHunk": "@@ -0,0 +1,195 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package harness\n+\n+import (\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n+\tfnpb \"github.com/apache/beam/sdks/go/pkg/beam/model/fnexecution_v1\"\n+\tppb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/golang/protobuf/ptypes\"\n+)\n+\n+func monitoring(p *exec.Plan) (*fnpb.Metrics, []*ppb.MonitoringInfo) {\n+\t// Get the legacy style metrics.\n+\ttransforms := make(map[string]*fnpb.Metrics_PTransform)\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_CounterData_{\n+\t\t\t\t\tCounterData: &fnpb.Metrics_User_CounterData{\n+\t\t\t\t\t\tValue: v,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_DistributionData_{\n+\t\t\t\t\tDistributionData: &fnpb.Metrics_User_DistributionData{\n+\t\t\t\t\t\tCount: count,\n+\t\t\t\t\t\tSum:   sum,\n+\t\t\t\t\t\tMin:   min,\n+\t\t\t\t\t\tMax:   max,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tGaugeInt64: func(l metrics.Labels, v int64, t time.Time) {\n+\t\t\tts, err := ptypes.TimestampProto(t)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_GaugeData_{\n+\t\t\t\t\tGaugeData: &fnpb.Metrics_User_GaugeData{\n+\t\t\t\t\t\tValue:     v,\n+\t\t\t\t\t\tTimestamp: ts,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t}.ExtractFrom(p.Store)\n+\n+\t// Get the MonitoringInfo versions.\n+\tvar monitoringInfo []*ppb.MonitoringInfo\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",\n+\t\t\t\t\tType:   \"beam:metrics:sum_int_64\",\n+\t\t\t\t\tLabels: userLabels(l),\n+\t\t\t\t\tData:   int64Counter(v),\n+\t\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",\n+\t\t\t\t\tType:   \"beam:metrics:sum_int_64\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bebb5e7be800e0ed2bda7213d83fee5bdbec43b"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTM4MDU3OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzoyMDoyMVrOFmjhBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzoyMDoyMVrOFmjhBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3MjEwMQ==", "bodyText": "this needs a URN, its likely that it should be beam:metric:user", "url": "https://github.com/apache/beam/pull/10777#discussion_r375972101", "createdAt": "2020-02-06T17:20:21Z", "author": {"login": "lukecwik"}, "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "diffHunk": "@@ -0,0 +1,195 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package harness\n+\n+import (\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n+\tfnpb \"github.com/apache/beam/sdks/go/pkg/beam/model/fnexecution_v1\"\n+\tppb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/golang/protobuf/ptypes\"\n+)\n+\n+func monitoring(p *exec.Plan) (*fnpb.Metrics, []*ppb.MonitoringInfo) {\n+\t// Get the legacy style metrics.\n+\ttransforms := make(map[string]*fnpb.Metrics_PTransform)\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_CounterData_{\n+\t\t\t\t\tCounterData: &fnpb.Metrics_User_CounterData{\n+\t\t\t\t\t\tValue: v,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_DistributionData_{\n+\t\t\t\t\tDistributionData: &fnpb.Metrics_User_DistributionData{\n+\t\t\t\t\t\tCount: count,\n+\t\t\t\t\t\tSum:   sum,\n+\t\t\t\t\t\tMin:   min,\n+\t\t\t\t\t\tMax:   max,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tGaugeInt64: func(l metrics.Labels, v int64, t time.Time) {\n+\t\t\tts, err := ptypes.TimestampProto(t)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_GaugeData_{\n+\t\t\t\t\tGaugeData: &fnpb.Metrics_User_GaugeData{\n+\t\t\t\t\t\tValue:     v,\n+\t\t\t\t\t\tTimestamp: ts,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t}.ExtractFrom(p.Store)\n+\n+\t// Get the MonitoringInfo versions.\n+\tvar monitoringInfo []*ppb.MonitoringInfo\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",\n+\t\t\t\t\tType:   \"beam:metrics:sum_int_64\",\n+\t\t\t\t\tLabels: userLabels(l),\n+\t\t\t\t\tData:   int64Counter(v),\n+\t\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",\n+\t\t\t\t\tType:   \"beam:metrics:sum_int_64\",\n+\t\t\t\t\tLabels: userLabels(l),\n+\t\t\t\t\tData:   int64Distribution(count, sum, min, max),\n+\t\t\t\t})\n+\t\t},\n+\t\tGaugeInt64: func(l metrics.Labels, v int64, t time.Time) {\n+\t\t\tts, err := ptypes.TimestampProto(t)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tType:      \"beam:metrics:latest_int_64\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bebb5e7be800e0ed2bda7213d83fee5bdbec43b"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTM5MTM5OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzoyMzoyOVrOFmjnwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMjowNDo1OFrOFmr1EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3MzgyNA==", "bodyText": "This should be the PCollection id", "url": "https://github.com/apache/beam/pull/10777#discussion_r375973824", "createdAt": "2020-02-06T17:23:29Z", "author": {"login": "lukecwik"}, "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "diffHunk": "@@ -0,0 +1,195 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package harness\n+\n+import (\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n+\tfnpb \"github.com/apache/beam/sdks/go/pkg/beam/model/fnexecution_v1\"\n+\tppb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/golang/protobuf/ptypes\"\n+)\n+\n+func monitoring(p *exec.Plan) (*fnpb.Metrics, []*ppb.MonitoringInfo) {\n+\t// Get the legacy style metrics.\n+\ttransforms := make(map[string]*fnpb.Metrics_PTransform)\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_CounterData_{\n+\t\t\t\t\tCounterData: &fnpb.Metrics_User_CounterData{\n+\t\t\t\t\t\tValue: v,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_DistributionData_{\n+\t\t\t\t\tDistributionData: &fnpb.Metrics_User_DistributionData{\n+\t\t\t\t\t\tCount: count,\n+\t\t\t\t\t\tSum:   sum,\n+\t\t\t\t\t\tMin:   min,\n+\t\t\t\t\t\tMax:   max,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tGaugeInt64: func(l metrics.Labels, v int64, t time.Time) {\n+\t\t\tts, err := ptypes.TimestampProto(t)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_GaugeData_{\n+\t\t\t\t\tGaugeData: &fnpb.Metrics_User_GaugeData{\n+\t\t\t\t\t\tValue:     v,\n+\t\t\t\t\t\tTimestamp: ts,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t}.ExtractFrom(p.Store)\n+\n+\t// Get the MonitoringInfo versions.\n+\tvar monitoringInfo []*ppb.MonitoringInfo\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",\n+\t\t\t\t\tType:   \"beam:metrics:sum_int_64\",\n+\t\t\t\t\tLabels: userLabels(l),\n+\t\t\t\t\tData:   int64Counter(v),\n+\t\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",\n+\t\t\t\t\tType:   \"beam:metrics:sum_int_64\",\n+\t\t\t\t\tLabels: userLabels(l),\n+\t\t\t\t\tData:   int64Distribution(count, sum, min, max),\n+\t\t\t\t})\n+\t\t},\n+\t\tGaugeInt64: func(l metrics.Labels, v int64, t time.Time) {\n+\t\t\tts, err := ptypes.TimestampProto(t)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tType:      \"beam:metrics:latest_int_64\",\n+\t\t\t\t\tLabels:    userLabels(l),\n+\t\t\t\t\tData:      int64Counter(v),\n+\t\t\t\t\tTimestamp: ts,\n+\t\t\t\t})\n+\t\t},\n+\t}.ExtractFrom(p.Store)\n+\n+\t// Get the execution monitoring information from the bundle plan.\n+\tif snapshot, ok := p.Progress(); ok {\n+\t\t// Legacy version.\n+\t\ttransforms[snapshot.ID] = &fnpb.Metrics_PTransform{\n+\t\t\tProcessedElements: &fnpb.Metrics_PTransform_ProcessedElements{\n+\t\t\t\tMeasured: &fnpb.Metrics_PTransform_Measured{\n+\t\t\t\t\tOutputElementCounts: map[string]int64{\n+\t\t\t\t\t\tsnapshot.Name: snapshot.Count,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\t// Monitoring info version.\n+\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\tUrn:  \"beam:metric:element_count:v1\",\n+\t\t\t\tType: \"beam:metrics:sum_int_64\",\n+\t\t\t\tLabels: map[string]string{\n+\t\t\t\t\t\"PCOLLECTION\": snapshot.Name,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bebb5e7be800e0ed2bda7213d83fee5bdbec43b"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAyMTAwNg==", "bodyText": "AFAICT There's no \"input\" to the Source transform, so can you confirm that it should be ID of the  Output PCollection?", "url": "https://github.com/apache/beam/pull/10777#discussion_r376021006", "createdAt": "2020-02-06T18:57:38Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "diffHunk": "@@ -0,0 +1,195 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package harness\n+\n+import (\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n+\tfnpb \"github.com/apache/beam/sdks/go/pkg/beam/model/fnexecution_v1\"\n+\tppb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/golang/protobuf/ptypes\"\n+)\n+\n+func monitoring(p *exec.Plan) (*fnpb.Metrics, []*ppb.MonitoringInfo) {\n+\t// Get the legacy style metrics.\n+\ttransforms := make(map[string]*fnpb.Metrics_PTransform)\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_CounterData_{\n+\t\t\t\t\tCounterData: &fnpb.Metrics_User_CounterData{\n+\t\t\t\t\t\tValue: v,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_DistributionData_{\n+\t\t\t\t\tDistributionData: &fnpb.Metrics_User_DistributionData{\n+\t\t\t\t\t\tCount: count,\n+\t\t\t\t\t\tSum:   sum,\n+\t\t\t\t\t\tMin:   min,\n+\t\t\t\t\t\tMax:   max,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tGaugeInt64: func(l metrics.Labels, v int64, t time.Time) {\n+\t\t\tts, err := ptypes.TimestampProto(t)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_GaugeData_{\n+\t\t\t\t\tGaugeData: &fnpb.Metrics_User_GaugeData{\n+\t\t\t\t\t\tValue:     v,\n+\t\t\t\t\t\tTimestamp: ts,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t}.ExtractFrom(p.Store)\n+\n+\t// Get the MonitoringInfo versions.\n+\tvar monitoringInfo []*ppb.MonitoringInfo\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",\n+\t\t\t\t\tType:   \"beam:metrics:sum_int_64\",\n+\t\t\t\t\tLabels: userLabels(l),\n+\t\t\t\t\tData:   int64Counter(v),\n+\t\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",\n+\t\t\t\t\tType:   \"beam:metrics:sum_int_64\",\n+\t\t\t\t\tLabels: userLabels(l),\n+\t\t\t\t\tData:   int64Distribution(count, sum, min, max),\n+\t\t\t\t})\n+\t\t},\n+\t\tGaugeInt64: func(l metrics.Labels, v int64, t time.Time) {\n+\t\t\tts, err := ptypes.TimestampProto(t)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tType:      \"beam:metrics:latest_int_64\",\n+\t\t\t\t\tLabels:    userLabels(l),\n+\t\t\t\t\tData:      int64Counter(v),\n+\t\t\t\t\tTimestamp: ts,\n+\t\t\t\t})\n+\t\t},\n+\t}.ExtractFrom(p.Store)\n+\n+\t// Get the execution monitoring information from the bundle plan.\n+\tif snapshot, ok := p.Progress(); ok {\n+\t\t// Legacy version.\n+\t\ttransforms[snapshot.ID] = &fnpb.Metrics_PTransform{\n+\t\t\tProcessedElements: &fnpb.Metrics_PTransform_ProcessedElements{\n+\t\t\t\tMeasured: &fnpb.Metrics_PTransform_Measured{\n+\t\t\t\t\tOutputElementCounts: map[string]int64{\n+\t\t\t\t\t\tsnapshot.Name: snapshot.Count,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\t// Monitoring info version.\n+\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\tUrn:  \"beam:metric:element_count:v1\",\n+\t\t\t\tType: \"beam:metrics:sum_int_64\",\n+\t\t\t\tLabels: map[string]string{\n+\t\t\t\t\t\"PCOLLECTION\": snapshot.Name,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3MzgyNA=="}, "originalCommit": {"oid": "2bebb5e7be800e0ed2bda7213d83fee5bdbec43b"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEwODMwNQ==", "bodyText": "Chatted offline about this: There's only the output PCollection, and then this streamlines from \"specific progress signal\" to \"ordinary PCollection metrics\". I made TODOs for reminders when adding PCollection and DoFn metrics to the SDK.", "url": "https://github.com/apache/beam/pull/10777#discussion_r376108305", "createdAt": "2020-02-06T22:04:58Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "diffHunk": "@@ -0,0 +1,195 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package harness\n+\n+import (\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n+\tfnpb \"github.com/apache/beam/sdks/go/pkg/beam/model/fnexecution_v1\"\n+\tppb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/golang/protobuf/ptypes\"\n+)\n+\n+func monitoring(p *exec.Plan) (*fnpb.Metrics, []*ppb.MonitoringInfo) {\n+\t// Get the legacy style metrics.\n+\ttransforms := make(map[string]*fnpb.Metrics_PTransform)\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_CounterData_{\n+\t\t\t\t\tCounterData: &fnpb.Metrics_User_CounterData{\n+\t\t\t\t\t\tValue: v,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_DistributionData_{\n+\t\t\t\t\tDistributionData: &fnpb.Metrics_User_DistributionData{\n+\t\t\t\t\t\tCount: count,\n+\t\t\t\t\t\tSum:   sum,\n+\t\t\t\t\t\tMin:   min,\n+\t\t\t\t\t\tMax:   max,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t\tGaugeInt64: func(l metrics.Labels, v int64, t time.Time) {\n+\t\t\tts, err := ptypes.TimestampProto(t)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tpb := getTransform(transforms, l)\n+\t\t\tpb.User = append(pb.User, &fnpb.Metrics_User{\n+\t\t\t\tMetricName: toName(l),\n+\t\t\t\tData: &fnpb.Metrics_User_GaugeData_{\n+\t\t\t\t\tGaugeData: &fnpb.Metrics_User_GaugeData{\n+\t\t\t\t\t\tValue:     v,\n+\t\t\t\t\t\tTimestamp: ts,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t})\n+\t\t},\n+\t}.ExtractFrom(p.Store)\n+\n+\t// Get the MonitoringInfo versions.\n+\tvar monitoringInfo []*ppb.MonitoringInfo\n+\tmetrics.Extractor{\n+\t\tSumInt64: func(l metrics.Labels, v int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",\n+\t\t\t\t\tType:   \"beam:metrics:sum_int_64\",\n+\t\t\t\t\tLabels: userLabels(l),\n+\t\t\t\t\tData:   int64Counter(v),\n+\t\t\t\t})\n+\t\t},\n+\t\tDistributionInt64: func(l metrics.Labels, count, sum, min, max int64) {\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tUrn:    \"beam:metric:user\",\n+\t\t\t\t\tType:   \"beam:metrics:sum_int_64\",\n+\t\t\t\t\tLabels: userLabels(l),\n+\t\t\t\t\tData:   int64Distribution(count, sum, min, max),\n+\t\t\t\t})\n+\t\t},\n+\t\tGaugeInt64: func(l metrics.Labels, v int64, t time.Time) {\n+\t\t\tts, err := ptypes.TimestampProto(t)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\t\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\t\tType:      \"beam:metrics:latest_int_64\",\n+\t\t\t\t\tLabels:    userLabels(l),\n+\t\t\t\t\tData:      int64Counter(v),\n+\t\t\t\t\tTimestamp: ts,\n+\t\t\t\t})\n+\t\t},\n+\t}.ExtractFrom(p.Store)\n+\n+\t// Get the execution monitoring information from the bundle plan.\n+\tif snapshot, ok := p.Progress(); ok {\n+\t\t// Legacy version.\n+\t\ttransforms[snapshot.ID] = &fnpb.Metrics_PTransform{\n+\t\t\tProcessedElements: &fnpb.Metrics_PTransform_ProcessedElements{\n+\t\t\t\tMeasured: &fnpb.Metrics_PTransform_Measured{\n+\t\t\t\t\tOutputElementCounts: map[string]int64{\n+\t\t\t\t\t\tsnapshot.Name: snapshot.Count,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\t// Monitoring info version.\n+\t\tmonitoringInfo = append(monitoringInfo,\n+\t\t\t&ppb.MonitoringInfo{\n+\t\t\t\tUrn:  \"beam:metric:element_count:v1\",\n+\t\t\t\tType: \"beam:metrics:sum_int_64\",\n+\t\t\t\tLabels: map[string]string{\n+\t\t\t\t\t\"PCOLLECTION\": snapshot.Name,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3MzgyNA=="}, "originalCommit": {"oid": "2bebb5e7be800e0ed2bda7213d83fee5bdbec43b"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjM5MjgyOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwMToxOToxNlrOFpEKdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwMjoxNjo0MVrOFpFBEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwNDE1MQ==", "bodyText": "outputPID/PID isn't a great name for PCOllection ids since PID is used as PTrasnformId elsewhere.\nConsider fixing here and elsewhere. Also, this comment should really say that this is the output pcollection id and not an implementation detail like this is the \"index\" since thats an implementation detail elsewhere about the mapping which this code shouldn't care about.", "url": "https://github.com/apache/beam/pull/10777#discussion_r378604151", "createdAt": "2020-02-13T01:19:16Z", "author": {"login": "lukecwik"}, "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -37,11 +37,13 @@ type DataSource struct {\n \tCoder *coder.Coder\n \tOut   Node\n \n-\tsource   DataManager\n-\tstate    StateReader\n-\tindex    int64\n-\tsplitIdx int64\n-\tstart    time.Time\n+\tsource DataManager\n+\tstate  StateReader\n+\t// TODO(lostluck) 2020/02/06: refactor to support more general PCollection metrics on nodes.\n+\toutputPID string // The index is the output count for the PCollection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c7b6cfa5f28b48a25c1b555623bc35971360c1e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxODEzMQ==", "bodyText": "Ack. Good point.\nThis is to support the existing one off, and isn't going to be long term code. I'm already working on the stated TODO to handle metrics for all PCollections in the SDK. As it stands, the legacy metrics and monitoring infos use different identifiers for progress signals, so there's going to be a mess anyway.", "url": "https://github.com/apache/beam/pull/10777#discussion_r378618131", "createdAt": "2020-02-13T02:16:41Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -37,11 +37,13 @@ type DataSource struct {\n \tCoder *coder.Coder\n \tOut   Node\n \n-\tsource   DataManager\n-\tstate    StateReader\n-\tindex    int64\n-\tsplitIdx int64\n-\tstart    time.Time\n+\tsource DataManager\n+\tstate  StateReader\n+\t// TODO(lostluck) 2020/02/06: refactor to support more general PCollection metrics on nodes.\n+\toutputPID string // The index is the output count for the PCollection.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwNDE1MQ=="}, "originalCommit": {"oid": "4c7b6cfa5f28b48a25c1b555623bc35971360c1e"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2163, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}