{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5MTUzMDI1", "number": 10501, "title": "[BEAM-5605] Add support for channel splitting to the gRPC read \"source\" and propagate \"split\" calls to the downstream receiver", "bodyText": "This code mirrors the logic/implementation within Python.\nTo be able to propagate the split call to the downstream receiver, I collapsed all the harness FnDataReceiver types into two existing implementations and one new implementation.\nThe previous hierarchy was:\nelement counting receiver -> time counting receiver -> multiplexing receiver (possibly the original receiver)\n\nThe current implementation combined the element counting, time counting and multiplexing into the MultiplexingMetricTrackingFnDataReceiver while for the singleton case into the MetricTrackingFnDataReceiver.\nTo propagate splits, a SplittingMetricTrackingFnDataReceiver was created that extends the MetricTrackingFnDataReceiver. Note, like in Python, there is currently no support for splitting a multiplexed consumer.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-01-03T23:22:15Z", "url": "https://github.com/apache/beam/pull/10501", "merged": true, "mergeCommit": {"oid": "35bf2bd0f9fd362801035fa2776b8eed815bd01b"}, "closed": true, "closedAt": "2020-01-13T23:27:53Z", "author": {"login": "lukecwik"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb22yilgH2gAyMzU5MTUzMDI1OmQ1NDE1NzMyZmYwNjdlODU4NTJjNGY1NDMzZWZkMDAwMzI2OWY4ODA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6AMpYgH2gAyMzU5MTUzMDI1OjJmYTM1YzQyMDkxNWI0YmU0M2UzYTRhNTY0MjllYzI0N2M3NGVkNTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d5415732ff067e85852c4f5433efd0003269f880", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/d5415732ff067e85852c4f5433efd0003269f880", "committedDate": "2020-01-03T23:16:55Z", "message": "[BEAM-3684] Add support for channel splitting to the gRPC read \"source\" and propagate \"split\" calls to the downstream receiver\n\nThis code mirrors the logic/implementation within https://github.com/apache/beam/blob/16757ef9a6da4d0ac218c6c4d6b19e2a49ccca45/sdks/python/apache_beam/runners/worker/bundle_processor.py#L206\n\nTo be able to propagate the split call to the downstream receiver, I collapsed all the harness FnDataReceiver types into two existing implementations and one new implementations.\nThe previous hierarchy was:\nelement counting receiver -> time counting receiver -> multiplexing receiver (possibly the original receiver)\n\nThe current implementation combined the element counting, time counting and multiplexing into the MultiplexingMetricTrackingFnDataReceiver while for the singleton case into the MetricTrackingFnDataReceiver.\nTo propagate splits, a SplittingMetricTrackingFnDataReceiver was created that extends the MetricTrackingFnDataReceiver. Note, like in Python, there is currently no support for splitting as in https://github.com/apache/beam/blob/c167d8ef99b21148bcab7c37538a6ef2f64864c7/sdks/python/apache_beam/runners/worker/operations.py#L133"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d5415732ff067e85852c4f5433efd0003269f880", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/d5415732ff067e85852c4f5433efd0003269f880", "committedDate": "2020-01-03T23:16:55Z", "message": "[BEAM-3684] Add support for channel splitting to the gRPC read \"source\" and propagate \"split\" calls to the downstream receiver\n\nThis code mirrors the logic/implementation within https://github.com/apache/beam/blob/16757ef9a6da4d0ac218c6c4d6b19e2a49ccca45/sdks/python/apache_beam/runners/worker/bundle_processor.py#L206\n\nTo be able to propagate the split call to the downstream receiver, I collapsed all the harness FnDataReceiver types into two existing implementations and one new implementations.\nThe previous hierarchy was:\nelement counting receiver -> time counting receiver -> multiplexing receiver (possibly the original receiver)\n\nThe current implementation combined the element counting, time counting and multiplexing into the MultiplexingMetricTrackingFnDataReceiver while for the singleton case into the MetricTrackingFnDataReceiver.\nTo propagate splits, a SplittingMetricTrackingFnDataReceiver was created that extends the MetricTrackingFnDataReceiver. Note, like in Python, there is currently no support for splitting as in https://github.com/apache/beam/blob/c167d8ef99b21148bcab7c37538a6ef2f64864c7/sdks/python/apache_beam/runners/worker/operations.py#L133"}, "afterCommit": {"oid": "8b992dbdb087e354eb93201b109b82aaae98a7bc", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/8b992dbdb087e354eb93201b109b82aaae98a7bc", "committedDate": "2020-01-07T00:12:57Z", "message": "[BEAM-9059] Migrate PTransformTranslation to use string constants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8b992dbdb087e354eb93201b109b82aaae98a7bc", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/8b992dbdb087e354eb93201b109b82aaae98a7bc", "committedDate": "2020-01-07T00:12:57Z", "message": "[BEAM-9059] Migrate PTransformTranslation to use string constants"}, "afterCommit": {"oid": "d0eb6dd0cf8305c9b5c0bd53a31783337d9ed939", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/d0eb6dd0cf8305c9b5c0bd53a31783337d9ed939", "committedDate": "2020-01-07T00:17:40Z", "message": "[BEAM-9059] Migrate PTransformTranslation to use string constants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d0eb6dd0cf8305c9b5c0bd53a31783337d9ed939", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/d0eb6dd0cf8305c9b5c0bd53a31783337d9ed939", "committedDate": "2020-01-07T00:17:40Z", "message": "[BEAM-9059] Migrate PTransformTranslation to use string constants"}, "afterCommit": {"oid": "d5415732ff067e85852c4f5433efd0003269f880", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/d5415732ff067e85852c4f5433efd0003269f880", "committedDate": "2020-01-03T23:16:55Z", "message": "[BEAM-3684] Add support for channel splitting to the gRPC read \"source\" and propagate \"split\" calls to the downstream receiver\n\nThis code mirrors the logic/implementation within https://github.com/apache/beam/blob/16757ef9a6da4d0ac218c6c4d6b19e2a49ccca45/sdks/python/apache_beam/runners/worker/bundle_processor.py#L206\n\nTo be able to propagate the split call to the downstream receiver, I collapsed all the harness FnDataReceiver types into two existing implementations and one new implementations.\nThe previous hierarchy was:\nelement counting receiver -> time counting receiver -> multiplexing receiver (possibly the original receiver)\n\nThe current implementation combined the element counting, time counting and multiplexing into the MultiplexingMetricTrackingFnDataReceiver while for the singleton case into the MetricTrackingFnDataReceiver.\nTo propagate splits, a SplittingMetricTrackingFnDataReceiver was created that extends the MetricTrackingFnDataReceiver. Note, like in Python, there is currently no support for splitting as in https://github.com/apache/beam/blob/c167d8ef99b21148bcab7c37538a6ef2f64864c7/sdks/python/apache_beam/runners/worker/operations.py#L133"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/a4f0a05889450257ccabfe78a171bb0a4e3b3d19", "committedDate": "2020-01-07T17:55:50Z", "message": "fixup! Fix spot/find bugs issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNDg1MzAy", "url": "https://github.com/apache/beam/pull/10501#pullrequestreview-341485302", "createdAt": "2020-01-11T00:26:21Z", "commit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMDoyNjoyMVrOFcjIGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMTozNTowOVrOFcjo1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTk2MQ==", "bodyText": "0 based index of the current element being processed(?).", "url": "https://github.com/apache/beam/pull/10501#discussion_r365479961", "createdAt": "2020-01-11T00:26:21Z", "author": {"login": "robertwb"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -131,6 +137,11 @@\n   private final BeamFnDataClient beamFnDataClient;\n   private final Coder<WindowedValue<OutputT>> coder;\n \n+  private final Object splittingLock = new Object();\n+  // 0-based count of the number of elements", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MDA2Mg==", "bodyText": "0-based index of the first element to not process. (Or is this the last element to process?)", "url": "https://github.com/apache/beam/pull/10501#discussion_r365480062", "createdAt": "2020-01-11T00:26:55Z", "author": {"login": "robertwb"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -131,6 +137,11 @@\n   private final BeamFnDataClient beamFnDataClient;\n   private final Coder<WindowedValue<OutputT>> coder;\n \n+  private final Object splittingLock = new Object();\n+  // 0-based count of the number of elements\n+  private long index = -1;\n+  // 0-based count of the number of elements", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MzQwMw==", "bodyText": "Should this be an else clause below?", "url": "https://github.com/apache/beam/pull/10501#discussion_r365483403", "createdAt": "2020-01-11T00:48:51Z", "author": {"login": "robertwb"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -170,7 +181,109 @@ public void registerInputLocation() {\n             apiServiceDescriptor,\n             LogicalEndpoint.of(processBundleInstructionIdSupplier.get(), pTransformId),\n             coder,\n-            consumer);\n+            this::forwardElementToConsumer);\n+  }\n+\n+  public void forwardElementToConsumer(WindowedValue<OutputT> element) throws Exception {\n+    synchronized (splittingLock) {\n+      if (index == stopIndex - 1) {\n+        return;\n+      }\n+      index += 1;\n+    }\n+    consumer.accept(element);\n+  }\n+\n+  public void split(\n+      ProcessBundleSplitRequest request, ProcessBundleSplitResponse.Builder response) {\n+    DesiredSplit desiredSplit = request.getDesiredSplitsMap().get(pTransformId);\n+    if (desiredSplit == null) {\n+      return;\n+    }\n+\n+    long totalBufferSize = desiredSplit.getEstimatedInputElements();\n+\n+    HandlesSplits splittingConsumer = null;\n+    if (consumer instanceof HandlesSplits) {\n+      splittingConsumer = ((HandlesSplits) consumer);\n+    }\n+\n+    synchronized (splittingLock) {\n+      // Since we hold the splittingLock, we guarantee that we will not pass the next element\n+      // to the downstream consumer. We still have a race where the downstream consumer may\n+      // have yet to see the element or has completed processing the element by the time\n+      // we ask it to split (even after we have asked for its progress).\n+\n+      // If the split request we received was delayed and is less then the known number of elements\n+      // then use \"index + 1\" as the total size. Similarly, if we have already split and the\n+      // split request is bounded incorrectly, use the stop index as the upper bound.\n+      if (totalBufferSize < index + 1) {\n+        totalBufferSize = index + 1;\n+      } else if (totalBufferSize > stopIndex) {\n+        totalBufferSize = stopIndex;\n+      }\n+\n+      // In the case where we have yet to process an element, set the current element progress to 1.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4ODM0Mw==", "bodyText": "Compute the number of elements that we should \"keep.\"", "url": "https://github.com/apache/beam/pull/10501#discussion_r365488343", "createdAt": "2020-01-11T01:35:09Z", "author": {"login": "robertwb"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -170,7 +181,109 @@ public void registerInputLocation() {\n             apiServiceDescriptor,\n             LogicalEndpoint.of(processBundleInstructionIdSupplier.get(), pTransformId),\n             coder,\n-            consumer);\n+            this::forwardElementToConsumer);\n+  }\n+\n+  public void forwardElementToConsumer(WindowedValue<OutputT> element) throws Exception {\n+    synchronized (splittingLock) {\n+      if (index == stopIndex - 1) {\n+        return;\n+      }\n+      index += 1;\n+    }\n+    consumer.accept(element);\n+  }\n+\n+  public void split(\n+      ProcessBundleSplitRequest request, ProcessBundleSplitResponse.Builder response) {\n+    DesiredSplit desiredSplit = request.getDesiredSplitsMap().get(pTransformId);\n+    if (desiredSplit == null) {\n+      return;\n+    }\n+\n+    long totalBufferSize = desiredSplit.getEstimatedInputElements();\n+\n+    HandlesSplits splittingConsumer = null;\n+    if (consumer instanceof HandlesSplits) {\n+      splittingConsumer = ((HandlesSplits) consumer);\n+    }\n+\n+    synchronized (splittingLock) {\n+      // Since we hold the splittingLock, we guarantee that we will not pass the next element\n+      // to the downstream consumer. We still have a race where the downstream consumer may\n+      // have yet to see the element or has completed processing the element by the time\n+      // we ask it to split (even after we have asked for its progress).\n+\n+      // If the split request we received was delayed and is less then the known number of elements\n+      // then use \"index + 1\" as the total size. Similarly, if we have already split and the\n+      // split request is bounded incorrectly, use the stop index as the upper bound.\n+      if (totalBufferSize < index + 1) {\n+        totalBufferSize = index + 1;\n+      } else if (totalBufferSize > stopIndex) {\n+        totalBufferSize = stopIndex;\n+      }\n+\n+      // In the case where we have yet to process an element, set the current element progress to 1.\n+      double currentElementProgress = 1;\n+\n+      // If we have started processing at least one element, attempt to get the downstream\n+      // progress defaulting to 0.5 if no progress was able to get fetched.\n+      if (index >= 0) {\n+        if (splittingConsumer != null) {\n+          currentElementProgress = splittingConsumer.getProgress();\n+        } else {\n+          currentElementProgress = 0.5;\n+        }\n+      }\n+\n+      checkArgument(\n+          desiredSplit.getAllowedSplitPointsList().isEmpty(),\n+          \"TODO: BEAM-3836, support split point restrictions.\");\n+\n+      // Now figure out where to split.\n+      //\n+      // The units here (except for keepOfElementRemainder) are all in terms of number or\n+      // (possibly fractional) elements.\n+\n+      // Compute the amount of \"remaining\" work that we know of.\n+      double remainder = totalBufferSize - index - currentElementProgress;\n+      // Compute the fraction of work that we should \"keep\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "originalPosition": 116}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fa35c420915b4be43e3a4a56429ec247c74ed50", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/2fa35c420915b4be43e3a4a56429ec247c74ed50", "committedDate": "2020-01-13T17:56:21Z", "message": "fixup! Address comments."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3891, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}