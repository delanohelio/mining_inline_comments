{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwMTQ4ODA5", "number": 11556, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowMjoyNlrOD3adsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoxMDowOVrOD3alZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDMxODU3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/portable_runner.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowMjoyNlrOGNqIPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowMjoyNlrOGNqIPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDkwOA==", "bodyText": "We prefer the use of Python's with syntax instead of calling wait_until_finish explicitly.", "url": "https://github.com/apache/beam/pull/11556#discussion_r416974908", "createdAt": "2020-04-28T23:02:26Z", "author": {"login": "ibzib"}, "path": "sdks/python/apache_beam/runners/portability/portable_runner.py", "diffHunk": "@@ -433,13 +435,12 @@ def run_pipeline(self, pipeline, options):\n         state_stream,\n         cleanup_callbacks)\n     if cleanup_callbacks:\n-      # We wait here to ensure that we run the cleanup callbacks.\n+      # Register an exit handler to ensure cleanup on exit.\n+      atexit.register(functools.partial(result._cleanup, on_exit=True))\n       _LOGGER.info(\n-          'Waiting until the pipeline has finished because the '\n-          'environment \"%s\" has started a component necessary for the '\n-          'execution.',\n+          'Environment \"%s\" has started a component necessary for the '\n+          'execution. Be sure to call wait_until_finish()',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74b9e613fa93f23384f7fd3d7037dd3e3734cfac"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDMyODk2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/portable_runner.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowNjoyOFrOGNqONQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMTozNDowOVrOGPih9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjQzNw==", "bodyText": "A comment explaining the units for duration (milliseconds?) and that duration=None actually means \"wait forever\" would be helpful. (I find this naming somewhat counter-intuitive, but it's too late to change now.)", "url": "https://github.com/apache/beam/pull/11556#discussion_r416976437", "createdAt": "2020-04-28T23:06:28Z", "author": {"login": "ibzib"}, "path": "sdks/python/apache_beam/runners/portability/portable_runner.py", "diffHunk": "@@ -535,7 +537,7 @@ def _last_error_message(self):\n     else:\n       return 'unknown error'\n \n-  def wait_until_finish(self):\n+  def wait_until_finish(self, duration=None):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74b9e613fa93f23384f7fd3d7037dd3e3734cfac"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NzU3Mw==", "bodyText": "Agree that the parameter name/default is not optimally chosen. Added a docstring.", "url": "https://github.com/apache/beam/pull/11556#discussion_r418947573", "createdAt": "2020-05-02T11:34:09Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/portability/portable_runner.py", "diffHunk": "@@ -535,7 +537,7 @@ def _last_error_message(self):\n     else:\n       return 'unknown error'\n \n-  def wait_until_finish(self):\n+  def wait_until_finish(self, duration=None):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjQzNw=="}, "originalCommit": {"oid": "74b9e613fa93f23384f7fd3d7037dd3e3734cfac"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDMzMDg0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/portable_runner.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowNzoxNVrOGNqPUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowNzoxNVrOGNqPUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjcyMw==", "bodyText": "Please give t and t2 descriptive variable names.", "url": "https://github.com/apache/beam/pull/11556#discussion_r416976723", "createdAt": "2020-04-28T23:07:15Z", "author": {"login": "ibzib"}, "path": "sdks/python/apache_beam/runners/portability/portable_runner.py", "diffHunk": "@@ -557,23 +559,47 @@ def read_messages():\n     t.daemon = True\n     t.start()\n \n+    if duration:\n+      t2 = threading.Thread(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74b9e613fa93f23384f7fd3d7037dd3e3734cfac"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDMzODMwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/portable_runner.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoxMDowOVrOGNqTjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoxMDowOVrOGNqTjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NzgwNw==", "bodyText": "with (see above comment)", "url": "https://github.com/apache/beam/pull/11556#discussion_r416977807", "createdAt": "2020-04-28T23:10:09Z", "author": {"login": "ibzib"}, "path": "sdks/python/apache_beam/runners/portability/portable_runner.py", "diffHunk": "@@ -557,23 +559,47 @@ def read_messages():\n     t.daemon = True\n     t.start()\n \n+    if duration:\n+      t2 = threading.Thread(\n+          target=functools.partial(self._observe, t),\n+          name='wait_until_finish_state_observer')\n+      t2.daemon = True\n+      t2.start()\n+      start_time = time.time()\n+      duration_secs = duration / 1000\n+      while time.time() - start_time < duration_secs and t2.is_alive():\n+        time.sleep(1)\n+    else:\n+      self._observe(t)\n+\n+    if self._runtime_exception:\n+      raise self._runtime_exception\n+\n+    return self._state\n+\n+  def _observe(self, message_thread):\n     try:\n       for state_response in self._state_stream:\n         self._state = self._runner_api_state_to_pipeline_state(\n             state_response.state)\n         if state_response.state in TERMINAL_STATES:\n           # Wait for any last messages.\n-          t.join(10)\n+          message_thread.join(10)\n           break\n       if self._state != runner.PipelineState.DONE:\n-        raise RuntimeError(\n+        self._runtime_exception = RuntimeError(\n             'Pipeline %s failed in state %s: %s' %\n             (self._job_id, self._state, self._last_error_message()))\n-      return self._state\n+    except Exception as e:\n+      self._runtime_exception = e\n     finally:\n       self._cleanup()\n \n-  def _cleanup(self):\n+  def _cleanup(self, on_exit=False):\n+    if on_exit and self._cleanup_callbacks:\n+      _LOGGER.info(\n+          'Running cleanup on exit. If your local pipeline should continue '\n+          'running, be sure to call pipeline.run().wait_until_finish().')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74b9e613fa93f23384f7fd3d7037dd3e3734cfac"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1182, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}