{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NDM3NjI0", "number": 10959, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozMjoxMFrODipeag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzoyNToyOFrODjEwWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjU3NzA2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/visionml.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozMjoxMFrOFuA10A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzoxMTowMVrOFuFc3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MjU5Mg==", "bodyText": "On closer examination, it may be that we need to wait for the return result of the operation anyway, like so: return operation.result() as without it, the function returns a google.api_core.operation.Operation object and then Beam runs into the following error:\nAttributeError: Can't pickle local object 'if_exception_type.<locals>.if_exception_type_predicate' [while running 'Annotate image/ParDo(_AsyncBatchImageAnnotateFn)']", "url": "https://github.com/apache/beam/pull/10959#discussion_r383792592", "createdAt": "2020-02-25T10:32:10Z", "author": {"login": "EDjur"}, "path": "sdks/python/apache_beam/ml/gcp/visionml.py", "diffHunk": "@@ -0,0 +1,526 @@\n+# pylint: skip-file\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+A connector for sending API requests to the GCP Vision API.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Optional\n+from typing import Tuple\n+from typing import Union\n+\n+from future.utils import binary_type\n+from future.utils import text_type\n+\n+from apache_beam import typehints\n+from apache_beam.metrics import Metrics\n+from apache_beam.transforms import DoFn\n+from apache_beam.transforms import ParDo\n+from apache_beam.transforms import PTransform\n+from cachetools.func import ttl_cache\n+\n+try:\n+  from google.cloud import vision\n+except ImportError:\n+  raise ImportError(\n+      'Google Cloud Vision not supported for this execution environment '\n+      '(could not import google.cloud.vision).')\n+\n+__all__ = [\n+    'AnnotateImage',\n+    'AnnotateImageWithContext',\n+    'AsyncBatchAnnotateImage',\n+    'AsyncBatchAnnotateImageWithContext'\n+]\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_vision_client(client_options=None):\n+  \"\"\"Returns a Cloud Vision API client.\"\"\"\n+  _client = vision.ImageAnnotatorClient(client_options=client_options)\n+  return _client\n+\n+\n+class AnnotateImage(PTransform):\n+  \"\"\"A ``PTransform`` for annotating images using the GCP Vision API\n+  ref: https://cloud.google.com/vision/docs/\n+\n+  Sends each element to the GCP Vision API. Element is a\n+  Union[text_type, binary_type] of either an URI (e.g. a GCS URI) or binary_type\n+  base64-encoded image data.\n+  Accepts an `AsDict` side input that maps each image to an image context.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      features,\n+      retry=None,\n+      timeout=120,\n+      client_options=None,\n+      context_side_input=None):\n+    \"\"\"\n+    Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the\n+        Vision API.\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+      context_side_input: (beam.pvalue.AsDict) Optional.\n+        An ``AsDict`` of a PCollection to be passed to the\n+        _ImageAnnotateFn as the image context mapping containing additional\n+        image context and/or feature-specific parameters.\n+        Example usage::\n+\n+          image_contexts =\n+            [(''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),\n+            (''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),]\n+\n+          context_side_input =\n+            (\n+              p\n+              | \"Image contexts\" >> beam.Create(image_contexts)\n+            )\n+\n+          visionml.AnnotateImage(features,\n+            context_side_input=beam.pvalue.AsDict(context_side_input)))\n+    \"\"\"\n+    super(AnnotateImage, self).__init__()\n+    self.features = features\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.client_options = client_options\n+    self.context_side_input = context_side_input\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _ImageAnnotateFn(\n+            features=self.features,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            client_options=self.client_options),\n+        context_side_input=self.context_side_input)\n+\n+\n+@typehints.with_input_types(\n+    Union[text_type, binary_type], Optional[vision.types.ImageContext])\n+class _ImageAnnotateFn(DoFn):\n+  \"\"\"A DoFn that sends each input element to the GCP Vision API\n+  service and outputs an element with the return result of the API\n+  (``google.cloud.vision_v1.types.AnnotateImageResponse``).\n+  \"\"\"\n+  def __init__(self, features, retry, timeout, client_options):\n+    super(_ImageAnnotateFn, self).__init__()\n+    self._client = None\n+    self.features = features\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.client_options = client_options\n+    self.counter = Metrics.counter(self.__class__, \"API Calls\")\n+\n+  def start_bundle(self):\n+    self._client = get_vision_client(self.client_options)\n+\n+  def _annotate_image(self, element, image_context):\n+    if isinstance(element, text_type):\n+      image = vision.types.Image(\n+          source=vision.types.ImageSource(image_uri=element))\n+    else:  # Typehint checks only allows text_type or binary_type\n+      image = vision.types.Image(content=element)\n+\n+    request = vision.types.AnnotateImageRequest(\n+        image=image, features=self.features, image_context=image_context)\n+    response = self._client.annotate_image(\n+        request=request, retry=self.retry, timeout=self.timeout)\n+\n+    return response\n+\n+  def process(self, element, context_side_input=None, *args, **kwargs):\n+    if context_side_input:  # If we have a side input image context, use that\n+      image_context = context_side_input.get(element)\n+    else:\n+      image_context = None\n+    response = self._annotate_image(element, image_context)\n+    self.counter.inc()\n+    yield response\n+\n+\n+class AnnotateImageWithContext(AnnotateImage):\n+  \"\"\"A ``PTransform`` for annotating images using the GCP Vision API\n+  ref: https://cloud.google.com/vision/docs/\n+\n+  Sends each element to the GCP Vision API. Element is a tuple of\n+\n+      (Union[text_type, binary_type],\n+      Optional[``vision.types.ImageContext``])\n+\n+  where the former is either an URI (e.g. a GCS URI) or binary_type\n+  base64-encoded image data.\n+  \"\"\"\n+  def __init__(self, features, retry=None, timeout=120, client_options=None):\n+    \"\"\"\n+     Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the\n+        Vision API\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+    \"\"\"\n+    super(AnnotateImageWithContext, self).__init__(\n+        features=features,\n+        retry=retry,\n+        timeout=timeout,\n+        client_options=client_options)\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _ImageAnnotateFnWithContext(\n+            features=self.features,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            client_options=self.client_options))\n+\n+\n+@typehints.with_input_types(\n+    Tuple[Union[text_type, binary_type], Optional[vision.types.ImageContext]])\n+class _ImageAnnotateFnWithContext(_ImageAnnotateFn):\n+  \"\"\"A DoFn that unpacks each input tuple to element, image_context variables\n+  and sends these to the GCP Vision API service and outputs an element with the\n+  return result of the API\n+  (``google.cloud.vision_v1.types.AnnotateImageResponse``).\n+  \"\"\"\n+  def __init__(self, features, retry, timeout, client_options):\n+    super(_ImageAnnotateFnWithContext, self).__init__(\n+        features=features,\n+        retry=retry,\n+        timeout=timeout,\n+        client_options=client_options)\n+\n+  def process(self, element, *args, **kwargs):\n+    element, image_context = element  # Unpack (image, image_context) tuple\n+    response = self._annotate_image(element, image_context)\n+    self.counter.inc()\n+    yield response\n+\n+\n+class AsyncBatchAnnotateImage(PTransform):\n+  \"\"\"A ``PTransform`` for batch (offline) annotating images using the\n+  GCP Vision API. ref: https://cloud.google.com/vision/docs/\n+\n+  Sends each batch of elements to the GCP Vision API which then stores the\n+  results in GCS.\n+  Element is a Union[text_type, binary_type] of either an URI (e.g. a GCS URI)\n+  or binary_type base64-encoded image data.\n+  Accepts an `AsDict` side input that maps each image to an image context.\n+  \"\"\"\n+\n+  MAX_BATCH_SIZE = 5000\n+\n+  def __init__(\n+      self,\n+      features,\n+      output_config=None,\n+      gcs_destination=None,\n+      retry=None,\n+      timeout=120,\n+      batch_size=None,\n+      client_options=None,\n+      context_side_input=None,\n+      metadata=None):\n+    \"\"\"\n+    Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      output_config:\n+        (Union[dict, ~google.cloud.vision.types.OutputConfig]) Optional.\n+        The desired output location and metadata (e.g. format).\n+        If a dict is provided, it must be of the same form as the protobuf\n+        message :class:`~google.cloud.vision.types.OutputConfig`\n+      gcs_destination: (str) Optional. The desired output location.\n+        Either output_config or gcs_destination needs to be set.\n+        output_config takes precedence.\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the Vision API.\n+        Default is 120 for single-element requests and 300 for batch annotation.\n+      batch_size: (int) Number of images to batch in the same request to the\n+        Vision API. Default is 5000.\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+      context_side_input: (beam.pvalue.AsDict) Optional.\n+        An ``AsDict`` of a PCollection to be passed to the\n+        _ImageAnnotateFn as the image context mapping containing additional\n+        image context and/or feature-specific parameters.\n+        Example usage::\n+\n+          image_contexts =\n+            [(''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),\n+            (''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),]\n+\n+          context_side_input =\n+            (\n+              p\n+              | \"Image contexts\" >> beam.Create(image_contexts)\n+            )\n+\n+          visionml.AsyncBatchAnnotateImage(features, output_config,\n+            context_side_input=beam.pvalue.AsDict(context_side_input)))\n+      metadata: (Optional[Sequence[Tuple[str, str]]]): Optional.\n+        Additional metadata that is provided to the method.\n+\n+    \"\"\"\n+    super(AsyncBatchAnnotateImage, self).__init__()\n+    self.features = features\n+    self.output_config = output_config\n+    if output_config is None and gcs_destination is None:\n+      raise ValueError('output_config or gcs_destination must be specified')\n+    if output_config is None:\n+      self.output_config = self._generate_output_config(gcs_destination)\n+\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.batch_size = batch_size or AsyncBatchAnnotateImage.MAX_BATCH_SIZE\n+    if self.batch_size > AsyncBatchAnnotateImage.MAX_BATCH_SIZE:\n+      raise ValueError(\n+          'Max batch_size exceeded. '\n+          'Batch size needs to be smaller than {}'.format(\n+              AsyncBatchAnnotateImage.MAX_BATCH_SIZE))\n+    self.client_options = client_options\n+    self.context_side_input = context_side_input\n+    self.metadata = metadata\n+\n+  @staticmethod\n+  def _generate_output_config(output_uri):\n+    gcs_destination = {\"uri\": output_uri}\n+    output_config = {\"gcs_destination\": gcs_destination}\n+    return output_config\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _AsyncBatchImageAnnotateFn(\n+            features=self.features,\n+            output_config=self.output_config,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            batch_size=self.batch_size,\n+            client_options=self.client_options,\n+            metadata=self.metadata),\n+        context_side_input=self.context_side_input)\n+\n+\n+class AsyncBatchAnnotateImageWithContext(AsyncBatchAnnotateImage):\n+  \"\"\"A ``PTransform`` for batch (offline) annotating images using the\n+  GCP Vision API. ref: https://cloud.google.com/vision/docs/batch\n+\n+  Sends each batch of elements to the GCP Vision API which then stores the\n+  results in GCS.\n+  Element is a Union[text_type, binary_type] of either an URI (e.g. a GCS URI)\n+  or binary_type base64-encoded image data.\n+  Accepts an `AsDict` side input that maps each image to an image context.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      features,\n+      output_config=None,\n+      gcs_destination=None,\n+      retry=None,\n+      timeout=120,\n+      batch_size=None,\n+      client_options=None,\n+      metadata=None):\n+    \"\"\"\n+    Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      output_config:\n+        (Union[dict, ~google.cloud.vision.types.OutputConfig]) Optional.\n+        The desired output location and metadata (e.g. format).\n+        If a dict is provided, it must be of the same form as the protobuf\n+        message :class:`~google.cloud.vision.types.OutputConfig`\n+      gcs_destination: (str) Optional. The desired output location.\n+        Either output_config or gcs_destination needs to be set.\n+        output_config takes precedence.\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the Vision API.\n+        Default is 120 for single-element requests and 300 for batch annotation.\n+      batch_size: (int) Number of images to batch in the same request to the\n+        Vision API. Default is 5000.\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+      metadata: (Optional[Sequence[Tuple[str, str]]]): Optional.\n+        Additional metadata that is provided to the method.\n+    \"\"\"\n+    super(AsyncBatchAnnotateImageWithContext, self).__init__(\n+        features=features,\n+        output_config=output_config,\n+        gcs_destination=gcs_destination,\n+        retry=retry,\n+        timeout=timeout,\n+        batch_size=batch_size,\n+        client_options=client_options,\n+        metadata=metadata)\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _AsyncBatchImageAnnotateFnWithContext(\n+            features=self.features,\n+            output_config=self.output_config,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            batch_size=self.batch_size,\n+            client_options=self.client_options,\n+            metadata=self.metadata))\n+\n+\n+@typehints.with_input_types(\n+    Union[text_type, binary_type], Optional[vision.types.ImageContext])\n+class _AsyncBatchImageAnnotateFn(DoFn):\n+  \"\"\"A DoFn that sends each input element to the GCP Vision API\n+  service in batches and stores the results in GCS. Returns a\n+  ``google.cloud.vision.types.AsyncBatchAnnotateImagesResponse`` containing the\n+  the output location and metadata from AsyncBatchAnnotateImagesRequest.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      features,\n+      output_config,\n+      retry,\n+      timeout,\n+      client_options,\n+      batch_size,\n+      metadata):\n+\n+    super(_AsyncBatchImageAnnotateFn, self).__init__()\n+    self._client = None\n+    self.features = features\n+    self.output_config = output_config\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.client_options = client_options\n+    self.batch_size = batch_size\n+    self._batch_elements = None\n+    self.metadata = metadata\n+    self.counter = Metrics.counter(self.__class__, \"API Calls\")\n+\n+  def start_bundle(self):\n+    self._client = get_vision_client(self.client_options)\n+    self._batch_elements = []\n+\n+  def finish_bundle(self):\n+    if self._batch_elements:\n+      response = self._flush_batch()\n+      self.counter.inc()\n+      return response\n+\n+  def create_annotate_image_request(self, element, image_context):\n+    if isinstance(element, text_type):\n+      image = vision.types.Image(\n+          source=vision.types.ImageSource(image_uri=element))\n+    else:  # Typehint checks only allows text_type or binary_type\n+      image = vision.types.Image(content=element)\n+\n+    request = vision.types.AnnotateImageRequest(\n+        image=image, features=self.features, image_context=image_context)\n+    return request\n+\n+  def process(self, element, context_side_input=None, *args, **kwargs):\n+    if context_side_input:  # If we have a side input image context, use that\n+      image_context = context_side_input.get(element)\n+    else:\n+      image_context = None\n+\n+    # Evaluate batches\n+    request = self.create_annotate_image_request(element, image_context)\n+    self._batch_elements.append(request)\n+    if len(self._batch_elements) >= self.batch_size or \\\n+            len(self._batch_elements) >= AsyncBatchAnnotateImage.MAX_BATCH_SIZE:\n+      response = self._flush_batch()\n+      self.counter.inc()\n+      yield response\n+\n+  def _flush_batch(self):\n+    operation = self._client.async_batch_annotate_images(\n+        requests=self._batch_elements,\n+        output_config=self.output_config,\n+        retry=self.retry,\n+        timeout=self.timeout,\n+        metadata=self.metadata)\n+    self._batch_elements = []\n+    return operation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3691df25420e719b163effcab36268ff9a761e7e"}, "originalPosition": 487}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwODcxMw==", "bodyText": "That is, if this PTransform should return anything at all.\nPerhaps it makes more sense to not return anything and just send off the Vision API call. The \"downside\" is that this PTransform (AsyncBatchAnnotateImage) would essentially become a sink).\nWould be interested to hear your thoughts on this.", "url": "https://github.com/apache/beam/pull/10959#discussion_r383808713", "createdAt": "2020-02-25T11:01:18Z", "author": {"login": "EDjur"}, "path": "sdks/python/apache_beam/ml/gcp/visionml.py", "diffHunk": "@@ -0,0 +1,526 @@\n+# pylint: skip-file\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+A connector for sending API requests to the GCP Vision API.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Optional\n+from typing import Tuple\n+from typing import Union\n+\n+from future.utils import binary_type\n+from future.utils import text_type\n+\n+from apache_beam import typehints\n+from apache_beam.metrics import Metrics\n+from apache_beam.transforms import DoFn\n+from apache_beam.transforms import ParDo\n+from apache_beam.transforms import PTransform\n+from cachetools.func import ttl_cache\n+\n+try:\n+  from google.cloud import vision\n+except ImportError:\n+  raise ImportError(\n+      'Google Cloud Vision not supported for this execution environment '\n+      '(could not import google.cloud.vision).')\n+\n+__all__ = [\n+    'AnnotateImage',\n+    'AnnotateImageWithContext',\n+    'AsyncBatchAnnotateImage',\n+    'AsyncBatchAnnotateImageWithContext'\n+]\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_vision_client(client_options=None):\n+  \"\"\"Returns a Cloud Vision API client.\"\"\"\n+  _client = vision.ImageAnnotatorClient(client_options=client_options)\n+  return _client\n+\n+\n+class AnnotateImage(PTransform):\n+  \"\"\"A ``PTransform`` for annotating images using the GCP Vision API\n+  ref: https://cloud.google.com/vision/docs/\n+\n+  Sends each element to the GCP Vision API. Element is a\n+  Union[text_type, binary_type] of either an URI (e.g. a GCS URI) or binary_type\n+  base64-encoded image data.\n+  Accepts an `AsDict` side input that maps each image to an image context.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      features,\n+      retry=None,\n+      timeout=120,\n+      client_options=None,\n+      context_side_input=None):\n+    \"\"\"\n+    Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the\n+        Vision API.\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+      context_side_input: (beam.pvalue.AsDict) Optional.\n+        An ``AsDict`` of a PCollection to be passed to the\n+        _ImageAnnotateFn as the image context mapping containing additional\n+        image context and/or feature-specific parameters.\n+        Example usage::\n+\n+          image_contexts =\n+            [(''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),\n+            (''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),]\n+\n+          context_side_input =\n+            (\n+              p\n+              | \"Image contexts\" >> beam.Create(image_contexts)\n+            )\n+\n+          visionml.AnnotateImage(features,\n+            context_side_input=beam.pvalue.AsDict(context_side_input)))\n+    \"\"\"\n+    super(AnnotateImage, self).__init__()\n+    self.features = features\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.client_options = client_options\n+    self.context_side_input = context_side_input\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _ImageAnnotateFn(\n+            features=self.features,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            client_options=self.client_options),\n+        context_side_input=self.context_side_input)\n+\n+\n+@typehints.with_input_types(\n+    Union[text_type, binary_type], Optional[vision.types.ImageContext])\n+class _ImageAnnotateFn(DoFn):\n+  \"\"\"A DoFn that sends each input element to the GCP Vision API\n+  service and outputs an element with the return result of the API\n+  (``google.cloud.vision_v1.types.AnnotateImageResponse``).\n+  \"\"\"\n+  def __init__(self, features, retry, timeout, client_options):\n+    super(_ImageAnnotateFn, self).__init__()\n+    self._client = None\n+    self.features = features\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.client_options = client_options\n+    self.counter = Metrics.counter(self.__class__, \"API Calls\")\n+\n+  def start_bundle(self):\n+    self._client = get_vision_client(self.client_options)\n+\n+  def _annotate_image(self, element, image_context):\n+    if isinstance(element, text_type):\n+      image = vision.types.Image(\n+          source=vision.types.ImageSource(image_uri=element))\n+    else:  # Typehint checks only allows text_type or binary_type\n+      image = vision.types.Image(content=element)\n+\n+    request = vision.types.AnnotateImageRequest(\n+        image=image, features=self.features, image_context=image_context)\n+    response = self._client.annotate_image(\n+        request=request, retry=self.retry, timeout=self.timeout)\n+\n+    return response\n+\n+  def process(self, element, context_side_input=None, *args, **kwargs):\n+    if context_side_input:  # If we have a side input image context, use that\n+      image_context = context_side_input.get(element)\n+    else:\n+      image_context = None\n+    response = self._annotate_image(element, image_context)\n+    self.counter.inc()\n+    yield response\n+\n+\n+class AnnotateImageWithContext(AnnotateImage):\n+  \"\"\"A ``PTransform`` for annotating images using the GCP Vision API\n+  ref: https://cloud.google.com/vision/docs/\n+\n+  Sends each element to the GCP Vision API. Element is a tuple of\n+\n+      (Union[text_type, binary_type],\n+      Optional[``vision.types.ImageContext``])\n+\n+  where the former is either an URI (e.g. a GCS URI) or binary_type\n+  base64-encoded image data.\n+  \"\"\"\n+  def __init__(self, features, retry=None, timeout=120, client_options=None):\n+    \"\"\"\n+     Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the\n+        Vision API\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+    \"\"\"\n+    super(AnnotateImageWithContext, self).__init__(\n+        features=features,\n+        retry=retry,\n+        timeout=timeout,\n+        client_options=client_options)\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _ImageAnnotateFnWithContext(\n+            features=self.features,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            client_options=self.client_options))\n+\n+\n+@typehints.with_input_types(\n+    Tuple[Union[text_type, binary_type], Optional[vision.types.ImageContext]])\n+class _ImageAnnotateFnWithContext(_ImageAnnotateFn):\n+  \"\"\"A DoFn that unpacks each input tuple to element, image_context variables\n+  and sends these to the GCP Vision API service and outputs an element with the\n+  return result of the API\n+  (``google.cloud.vision_v1.types.AnnotateImageResponse``).\n+  \"\"\"\n+  def __init__(self, features, retry, timeout, client_options):\n+    super(_ImageAnnotateFnWithContext, self).__init__(\n+        features=features,\n+        retry=retry,\n+        timeout=timeout,\n+        client_options=client_options)\n+\n+  def process(self, element, *args, **kwargs):\n+    element, image_context = element  # Unpack (image, image_context) tuple\n+    response = self._annotate_image(element, image_context)\n+    self.counter.inc()\n+    yield response\n+\n+\n+class AsyncBatchAnnotateImage(PTransform):\n+  \"\"\"A ``PTransform`` for batch (offline) annotating images using the\n+  GCP Vision API. ref: https://cloud.google.com/vision/docs/\n+\n+  Sends each batch of elements to the GCP Vision API which then stores the\n+  results in GCS.\n+  Element is a Union[text_type, binary_type] of either an URI (e.g. a GCS URI)\n+  or binary_type base64-encoded image data.\n+  Accepts an `AsDict` side input that maps each image to an image context.\n+  \"\"\"\n+\n+  MAX_BATCH_SIZE = 5000\n+\n+  def __init__(\n+      self,\n+      features,\n+      output_config=None,\n+      gcs_destination=None,\n+      retry=None,\n+      timeout=120,\n+      batch_size=None,\n+      client_options=None,\n+      context_side_input=None,\n+      metadata=None):\n+    \"\"\"\n+    Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      output_config:\n+        (Union[dict, ~google.cloud.vision.types.OutputConfig]) Optional.\n+        The desired output location and metadata (e.g. format).\n+        If a dict is provided, it must be of the same form as the protobuf\n+        message :class:`~google.cloud.vision.types.OutputConfig`\n+      gcs_destination: (str) Optional. The desired output location.\n+        Either output_config or gcs_destination needs to be set.\n+        output_config takes precedence.\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the Vision API.\n+        Default is 120 for single-element requests and 300 for batch annotation.\n+      batch_size: (int) Number of images to batch in the same request to the\n+        Vision API. Default is 5000.\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+      context_side_input: (beam.pvalue.AsDict) Optional.\n+        An ``AsDict`` of a PCollection to be passed to the\n+        _ImageAnnotateFn as the image context mapping containing additional\n+        image context and/or feature-specific parameters.\n+        Example usage::\n+\n+          image_contexts =\n+            [(''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),\n+            (''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),]\n+\n+          context_side_input =\n+            (\n+              p\n+              | \"Image contexts\" >> beam.Create(image_contexts)\n+            )\n+\n+          visionml.AsyncBatchAnnotateImage(features, output_config,\n+            context_side_input=beam.pvalue.AsDict(context_side_input)))\n+      metadata: (Optional[Sequence[Tuple[str, str]]]): Optional.\n+        Additional metadata that is provided to the method.\n+\n+    \"\"\"\n+    super(AsyncBatchAnnotateImage, self).__init__()\n+    self.features = features\n+    self.output_config = output_config\n+    if output_config is None and gcs_destination is None:\n+      raise ValueError('output_config or gcs_destination must be specified')\n+    if output_config is None:\n+      self.output_config = self._generate_output_config(gcs_destination)\n+\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.batch_size = batch_size or AsyncBatchAnnotateImage.MAX_BATCH_SIZE\n+    if self.batch_size > AsyncBatchAnnotateImage.MAX_BATCH_SIZE:\n+      raise ValueError(\n+          'Max batch_size exceeded. '\n+          'Batch size needs to be smaller than {}'.format(\n+              AsyncBatchAnnotateImage.MAX_BATCH_SIZE))\n+    self.client_options = client_options\n+    self.context_side_input = context_side_input\n+    self.metadata = metadata\n+\n+  @staticmethod\n+  def _generate_output_config(output_uri):\n+    gcs_destination = {\"uri\": output_uri}\n+    output_config = {\"gcs_destination\": gcs_destination}\n+    return output_config\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _AsyncBatchImageAnnotateFn(\n+            features=self.features,\n+            output_config=self.output_config,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            batch_size=self.batch_size,\n+            client_options=self.client_options,\n+            metadata=self.metadata),\n+        context_side_input=self.context_side_input)\n+\n+\n+class AsyncBatchAnnotateImageWithContext(AsyncBatchAnnotateImage):\n+  \"\"\"A ``PTransform`` for batch (offline) annotating images using the\n+  GCP Vision API. ref: https://cloud.google.com/vision/docs/batch\n+\n+  Sends each batch of elements to the GCP Vision API which then stores the\n+  results in GCS.\n+  Element is a Union[text_type, binary_type] of either an URI (e.g. a GCS URI)\n+  or binary_type base64-encoded image data.\n+  Accepts an `AsDict` side input that maps each image to an image context.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      features,\n+      output_config=None,\n+      gcs_destination=None,\n+      retry=None,\n+      timeout=120,\n+      batch_size=None,\n+      client_options=None,\n+      metadata=None):\n+    \"\"\"\n+    Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      output_config:\n+        (Union[dict, ~google.cloud.vision.types.OutputConfig]) Optional.\n+        The desired output location and metadata (e.g. format).\n+        If a dict is provided, it must be of the same form as the protobuf\n+        message :class:`~google.cloud.vision.types.OutputConfig`\n+      gcs_destination: (str) Optional. The desired output location.\n+        Either output_config or gcs_destination needs to be set.\n+        output_config takes precedence.\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the Vision API.\n+        Default is 120 for single-element requests and 300 for batch annotation.\n+      batch_size: (int) Number of images to batch in the same request to the\n+        Vision API. Default is 5000.\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+      metadata: (Optional[Sequence[Tuple[str, str]]]): Optional.\n+        Additional metadata that is provided to the method.\n+    \"\"\"\n+    super(AsyncBatchAnnotateImageWithContext, self).__init__(\n+        features=features,\n+        output_config=output_config,\n+        gcs_destination=gcs_destination,\n+        retry=retry,\n+        timeout=timeout,\n+        batch_size=batch_size,\n+        client_options=client_options,\n+        metadata=metadata)\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _AsyncBatchImageAnnotateFnWithContext(\n+            features=self.features,\n+            output_config=self.output_config,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            batch_size=self.batch_size,\n+            client_options=self.client_options,\n+            metadata=self.metadata))\n+\n+\n+@typehints.with_input_types(\n+    Union[text_type, binary_type], Optional[vision.types.ImageContext])\n+class _AsyncBatchImageAnnotateFn(DoFn):\n+  \"\"\"A DoFn that sends each input element to the GCP Vision API\n+  service in batches and stores the results in GCS. Returns a\n+  ``google.cloud.vision.types.AsyncBatchAnnotateImagesResponse`` containing the\n+  the output location and metadata from AsyncBatchAnnotateImagesRequest.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      features,\n+      output_config,\n+      retry,\n+      timeout,\n+      client_options,\n+      batch_size,\n+      metadata):\n+\n+    super(_AsyncBatchImageAnnotateFn, self).__init__()\n+    self._client = None\n+    self.features = features\n+    self.output_config = output_config\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.client_options = client_options\n+    self.batch_size = batch_size\n+    self._batch_elements = None\n+    self.metadata = metadata\n+    self.counter = Metrics.counter(self.__class__, \"API Calls\")\n+\n+  def start_bundle(self):\n+    self._client = get_vision_client(self.client_options)\n+    self._batch_elements = []\n+\n+  def finish_bundle(self):\n+    if self._batch_elements:\n+      response = self._flush_batch()\n+      self.counter.inc()\n+      return response\n+\n+  def create_annotate_image_request(self, element, image_context):\n+    if isinstance(element, text_type):\n+      image = vision.types.Image(\n+          source=vision.types.ImageSource(image_uri=element))\n+    else:  # Typehint checks only allows text_type or binary_type\n+      image = vision.types.Image(content=element)\n+\n+    request = vision.types.AnnotateImageRequest(\n+        image=image, features=self.features, image_context=image_context)\n+    return request\n+\n+  def process(self, element, context_side_input=None, *args, **kwargs):\n+    if context_side_input:  # If we have a side input image context, use that\n+      image_context = context_side_input.get(element)\n+    else:\n+      image_context = None\n+\n+    # Evaluate batches\n+    request = self.create_annotate_image_request(element, image_context)\n+    self._batch_elements.append(request)\n+    if len(self._batch_elements) >= self.batch_size or \\\n+            len(self._batch_elements) >= AsyncBatchAnnotateImage.MAX_BATCH_SIZE:\n+      response = self._flush_batch()\n+      self.counter.inc()\n+      yield response\n+\n+  def _flush_batch(self):\n+    operation = self._client.async_batch_annotate_images(\n+        requests=self._batch_elements,\n+        output_config=self.output_config,\n+        retry=self.retry,\n+        timeout=self.timeout,\n+        metadata=self.metadata)\n+    self._batch_elements = []\n+    return operation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MjU5Mg=="}, "originalCommit": {"oid": "3691df25420e719b163effcab36268ff9a761e7e"}, "originalPosition": 487}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2ODEyNA==", "bodyText": "I've answered to this in the main thread.", "url": "https://github.com/apache/beam/pull/10959#discussion_r383868124", "createdAt": "2020-02-25T13:11:01Z", "author": {"login": "kamilwu"}, "path": "sdks/python/apache_beam/ml/gcp/visionml.py", "diffHunk": "@@ -0,0 +1,526 @@\n+# pylint: skip-file\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+A connector for sending API requests to the GCP Vision API.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+from typing import Optional\n+from typing import Tuple\n+from typing import Union\n+\n+from future.utils import binary_type\n+from future.utils import text_type\n+\n+from apache_beam import typehints\n+from apache_beam.metrics import Metrics\n+from apache_beam.transforms import DoFn\n+from apache_beam.transforms import ParDo\n+from apache_beam.transforms import PTransform\n+from cachetools.func import ttl_cache\n+\n+try:\n+  from google.cloud import vision\n+except ImportError:\n+  raise ImportError(\n+      'Google Cloud Vision not supported for this execution environment '\n+      '(could not import google.cloud.vision).')\n+\n+__all__ = [\n+    'AnnotateImage',\n+    'AnnotateImageWithContext',\n+    'AsyncBatchAnnotateImage',\n+    'AsyncBatchAnnotateImageWithContext'\n+]\n+\n+\n+@ttl_cache(maxsize=128, ttl=3600)\n+def get_vision_client(client_options=None):\n+  \"\"\"Returns a Cloud Vision API client.\"\"\"\n+  _client = vision.ImageAnnotatorClient(client_options=client_options)\n+  return _client\n+\n+\n+class AnnotateImage(PTransform):\n+  \"\"\"A ``PTransform`` for annotating images using the GCP Vision API\n+  ref: https://cloud.google.com/vision/docs/\n+\n+  Sends each element to the GCP Vision API. Element is a\n+  Union[text_type, binary_type] of either an URI (e.g. a GCS URI) or binary_type\n+  base64-encoded image data.\n+  Accepts an `AsDict` side input that maps each image to an image context.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      features,\n+      retry=None,\n+      timeout=120,\n+      client_options=None,\n+      context_side_input=None):\n+    \"\"\"\n+    Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the\n+        Vision API.\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+      context_side_input: (beam.pvalue.AsDict) Optional.\n+        An ``AsDict`` of a PCollection to be passed to the\n+        _ImageAnnotateFn as the image context mapping containing additional\n+        image context and/or feature-specific parameters.\n+        Example usage::\n+\n+          image_contexts =\n+            [(''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),\n+            (''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),]\n+\n+          context_side_input =\n+            (\n+              p\n+              | \"Image contexts\" >> beam.Create(image_contexts)\n+            )\n+\n+          visionml.AnnotateImage(features,\n+            context_side_input=beam.pvalue.AsDict(context_side_input)))\n+    \"\"\"\n+    super(AnnotateImage, self).__init__()\n+    self.features = features\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.client_options = client_options\n+    self.context_side_input = context_side_input\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _ImageAnnotateFn(\n+            features=self.features,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            client_options=self.client_options),\n+        context_side_input=self.context_side_input)\n+\n+\n+@typehints.with_input_types(\n+    Union[text_type, binary_type], Optional[vision.types.ImageContext])\n+class _ImageAnnotateFn(DoFn):\n+  \"\"\"A DoFn that sends each input element to the GCP Vision API\n+  service and outputs an element with the return result of the API\n+  (``google.cloud.vision_v1.types.AnnotateImageResponse``).\n+  \"\"\"\n+  def __init__(self, features, retry, timeout, client_options):\n+    super(_ImageAnnotateFn, self).__init__()\n+    self._client = None\n+    self.features = features\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.client_options = client_options\n+    self.counter = Metrics.counter(self.__class__, \"API Calls\")\n+\n+  def start_bundle(self):\n+    self._client = get_vision_client(self.client_options)\n+\n+  def _annotate_image(self, element, image_context):\n+    if isinstance(element, text_type):\n+      image = vision.types.Image(\n+          source=vision.types.ImageSource(image_uri=element))\n+    else:  # Typehint checks only allows text_type or binary_type\n+      image = vision.types.Image(content=element)\n+\n+    request = vision.types.AnnotateImageRequest(\n+        image=image, features=self.features, image_context=image_context)\n+    response = self._client.annotate_image(\n+        request=request, retry=self.retry, timeout=self.timeout)\n+\n+    return response\n+\n+  def process(self, element, context_side_input=None, *args, **kwargs):\n+    if context_side_input:  # If we have a side input image context, use that\n+      image_context = context_side_input.get(element)\n+    else:\n+      image_context = None\n+    response = self._annotate_image(element, image_context)\n+    self.counter.inc()\n+    yield response\n+\n+\n+class AnnotateImageWithContext(AnnotateImage):\n+  \"\"\"A ``PTransform`` for annotating images using the GCP Vision API\n+  ref: https://cloud.google.com/vision/docs/\n+\n+  Sends each element to the GCP Vision API. Element is a tuple of\n+\n+      (Union[text_type, binary_type],\n+      Optional[``vision.types.ImageContext``])\n+\n+  where the former is either an URI (e.g. a GCS URI) or binary_type\n+  base64-encoded image data.\n+  \"\"\"\n+  def __init__(self, features, retry=None, timeout=120, client_options=None):\n+    \"\"\"\n+     Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the\n+        Vision API\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+    \"\"\"\n+    super(AnnotateImageWithContext, self).__init__(\n+        features=features,\n+        retry=retry,\n+        timeout=timeout,\n+        client_options=client_options)\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _ImageAnnotateFnWithContext(\n+            features=self.features,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            client_options=self.client_options))\n+\n+\n+@typehints.with_input_types(\n+    Tuple[Union[text_type, binary_type], Optional[vision.types.ImageContext]])\n+class _ImageAnnotateFnWithContext(_ImageAnnotateFn):\n+  \"\"\"A DoFn that unpacks each input tuple to element, image_context variables\n+  and sends these to the GCP Vision API service and outputs an element with the\n+  return result of the API\n+  (``google.cloud.vision_v1.types.AnnotateImageResponse``).\n+  \"\"\"\n+  def __init__(self, features, retry, timeout, client_options):\n+    super(_ImageAnnotateFnWithContext, self).__init__(\n+        features=features,\n+        retry=retry,\n+        timeout=timeout,\n+        client_options=client_options)\n+\n+  def process(self, element, *args, **kwargs):\n+    element, image_context = element  # Unpack (image, image_context) tuple\n+    response = self._annotate_image(element, image_context)\n+    self.counter.inc()\n+    yield response\n+\n+\n+class AsyncBatchAnnotateImage(PTransform):\n+  \"\"\"A ``PTransform`` for batch (offline) annotating images using the\n+  GCP Vision API. ref: https://cloud.google.com/vision/docs/\n+\n+  Sends each batch of elements to the GCP Vision API which then stores the\n+  results in GCS.\n+  Element is a Union[text_type, binary_type] of either an URI (e.g. a GCS URI)\n+  or binary_type base64-encoded image data.\n+  Accepts an `AsDict` side input that maps each image to an image context.\n+  \"\"\"\n+\n+  MAX_BATCH_SIZE = 5000\n+\n+  def __init__(\n+      self,\n+      features,\n+      output_config=None,\n+      gcs_destination=None,\n+      retry=None,\n+      timeout=120,\n+      batch_size=None,\n+      client_options=None,\n+      context_side_input=None,\n+      metadata=None):\n+    \"\"\"\n+    Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      output_config:\n+        (Union[dict, ~google.cloud.vision.types.OutputConfig]) Optional.\n+        The desired output location and metadata (e.g. format).\n+        If a dict is provided, it must be of the same form as the protobuf\n+        message :class:`~google.cloud.vision.types.OutputConfig`\n+      gcs_destination: (str) Optional. The desired output location.\n+        Either output_config or gcs_destination needs to be set.\n+        output_config takes precedence.\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the Vision API.\n+        Default is 120 for single-element requests and 300 for batch annotation.\n+      batch_size: (int) Number of images to batch in the same request to the\n+        Vision API. Default is 5000.\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+      context_side_input: (beam.pvalue.AsDict) Optional.\n+        An ``AsDict`` of a PCollection to be passed to the\n+        _ImageAnnotateFn as the image context mapping containing additional\n+        image context and/or feature-specific parameters.\n+        Example usage::\n+\n+          image_contexts =\n+            [(''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),\n+            (''gs://cloud-samples-data/vision/ocr/sign.jpg'', Union[dict,\n+            ``vision.types.ImageContext()``]),]\n+\n+          context_side_input =\n+            (\n+              p\n+              | \"Image contexts\" >> beam.Create(image_contexts)\n+            )\n+\n+          visionml.AsyncBatchAnnotateImage(features, output_config,\n+            context_side_input=beam.pvalue.AsDict(context_side_input)))\n+      metadata: (Optional[Sequence[Tuple[str, str]]]): Optional.\n+        Additional metadata that is provided to the method.\n+\n+    \"\"\"\n+    super(AsyncBatchAnnotateImage, self).__init__()\n+    self.features = features\n+    self.output_config = output_config\n+    if output_config is None and gcs_destination is None:\n+      raise ValueError('output_config or gcs_destination must be specified')\n+    if output_config is None:\n+      self.output_config = self._generate_output_config(gcs_destination)\n+\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.batch_size = batch_size or AsyncBatchAnnotateImage.MAX_BATCH_SIZE\n+    if self.batch_size > AsyncBatchAnnotateImage.MAX_BATCH_SIZE:\n+      raise ValueError(\n+          'Max batch_size exceeded. '\n+          'Batch size needs to be smaller than {}'.format(\n+              AsyncBatchAnnotateImage.MAX_BATCH_SIZE))\n+    self.client_options = client_options\n+    self.context_side_input = context_side_input\n+    self.metadata = metadata\n+\n+  @staticmethod\n+  def _generate_output_config(output_uri):\n+    gcs_destination = {\"uri\": output_uri}\n+    output_config = {\"gcs_destination\": gcs_destination}\n+    return output_config\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _AsyncBatchImageAnnotateFn(\n+            features=self.features,\n+            output_config=self.output_config,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            batch_size=self.batch_size,\n+            client_options=self.client_options,\n+            metadata=self.metadata),\n+        context_side_input=self.context_side_input)\n+\n+\n+class AsyncBatchAnnotateImageWithContext(AsyncBatchAnnotateImage):\n+  \"\"\"A ``PTransform`` for batch (offline) annotating images using the\n+  GCP Vision API. ref: https://cloud.google.com/vision/docs/batch\n+\n+  Sends each batch of elements to the GCP Vision API which then stores the\n+  results in GCS.\n+  Element is a Union[text_type, binary_type] of either an URI (e.g. a GCS URI)\n+  or binary_type base64-encoded image data.\n+  Accepts an `AsDict` side input that maps each image to an image context.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      features,\n+      output_config=None,\n+      gcs_destination=None,\n+      retry=None,\n+      timeout=120,\n+      batch_size=None,\n+      client_options=None,\n+      metadata=None):\n+    \"\"\"\n+    Args:\n+      features: (List[``vision.types.Feature.enums.Feature``]) Required.\n+        The Vision API features to detect\n+      output_config:\n+        (Union[dict, ~google.cloud.vision.types.OutputConfig]) Optional.\n+        The desired output location and metadata (e.g. format).\n+        If a dict is provided, it must be of the same form as the protobuf\n+        message :class:`~google.cloud.vision.types.OutputConfig`\n+      gcs_destination: (str) Optional. The desired output location.\n+        Either output_config or gcs_destination needs to be set.\n+        output_config takes precedence.\n+      retry: (google.api_core.retry.Retry) Optional.\n+        A retry object used to retry requests.\n+        If None is specified (default), requests will not be retried.\n+      timeout: (float) Optional.\n+        The time in seconds to wait for the response from the Vision API.\n+        Default is 120 for single-element requests and 300 for batch annotation.\n+      batch_size: (int) Number of images to batch in the same request to the\n+        Vision API. Default is 5000.\n+      client_options: (Union[dict, google.api_core.client_options.ClientOptions])\n+        Client options used to set user options on the client.\n+        API Endpoint should be set through client_options.\n+      metadata: (Optional[Sequence[Tuple[str, str]]]): Optional.\n+        Additional metadata that is provided to the method.\n+    \"\"\"\n+    super(AsyncBatchAnnotateImageWithContext, self).__init__(\n+        features=features,\n+        output_config=output_config,\n+        gcs_destination=gcs_destination,\n+        retry=retry,\n+        timeout=timeout,\n+        batch_size=batch_size,\n+        client_options=client_options,\n+        metadata=metadata)\n+\n+  def expand(self, pvalue):\n+    return pvalue | ParDo(\n+        _AsyncBatchImageAnnotateFnWithContext(\n+            features=self.features,\n+            output_config=self.output_config,\n+            retry=self.retry,\n+            timeout=self.timeout,\n+            batch_size=self.batch_size,\n+            client_options=self.client_options,\n+            metadata=self.metadata))\n+\n+\n+@typehints.with_input_types(\n+    Union[text_type, binary_type], Optional[vision.types.ImageContext])\n+class _AsyncBatchImageAnnotateFn(DoFn):\n+  \"\"\"A DoFn that sends each input element to the GCP Vision API\n+  service in batches and stores the results in GCS. Returns a\n+  ``google.cloud.vision.types.AsyncBatchAnnotateImagesResponse`` containing the\n+  the output location and metadata from AsyncBatchAnnotateImagesRequest.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      features,\n+      output_config,\n+      retry,\n+      timeout,\n+      client_options,\n+      batch_size,\n+      metadata):\n+\n+    super(_AsyncBatchImageAnnotateFn, self).__init__()\n+    self._client = None\n+    self.features = features\n+    self.output_config = output_config\n+    self.retry = retry\n+    self.timeout = timeout\n+    self.client_options = client_options\n+    self.batch_size = batch_size\n+    self._batch_elements = None\n+    self.metadata = metadata\n+    self.counter = Metrics.counter(self.__class__, \"API Calls\")\n+\n+  def start_bundle(self):\n+    self._client = get_vision_client(self.client_options)\n+    self._batch_elements = []\n+\n+  def finish_bundle(self):\n+    if self._batch_elements:\n+      response = self._flush_batch()\n+      self.counter.inc()\n+      return response\n+\n+  def create_annotate_image_request(self, element, image_context):\n+    if isinstance(element, text_type):\n+      image = vision.types.Image(\n+          source=vision.types.ImageSource(image_uri=element))\n+    else:  # Typehint checks only allows text_type or binary_type\n+      image = vision.types.Image(content=element)\n+\n+    request = vision.types.AnnotateImageRequest(\n+        image=image, features=self.features, image_context=image_context)\n+    return request\n+\n+  def process(self, element, context_side_input=None, *args, **kwargs):\n+    if context_side_input:  # If we have a side input image context, use that\n+      image_context = context_side_input.get(element)\n+    else:\n+      image_context = None\n+\n+    # Evaluate batches\n+    request = self.create_annotate_image_request(element, image_context)\n+    self._batch_elements.append(request)\n+    if len(self._batch_elements) >= self.batch_size or \\\n+            len(self._batch_elements) >= AsyncBatchAnnotateImage.MAX_BATCH_SIZE:\n+      response = self._flush_batch()\n+      self.counter.inc()\n+      yield response\n+\n+  def _flush_batch(self):\n+    operation = self._client.async_batch_annotate_images(\n+        requests=self._batch_elements,\n+        output_config=self.output_config,\n+        retry=self.retry,\n+        timeout=self.timeout,\n+        metadata=self.metadata)\n+    self._batch_elements = []\n+    return operation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MjU5Mg=="}, "originalCommit": {"oid": "3691df25420e719b163effcab36268ff9a761e7e"}, "originalPosition": 487}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTAxNTc4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/visionml_test.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzoxNjoxMFrOFurDUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzoxNjoxMFrOFurDUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4NDE3Nw==", "bodyText": "This mock seems to be unused", "url": "https://github.com/apache/beam/pull/10959#discussion_r384484177", "createdAt": "2020-02-26T13:16:10Z", "author": {"login": "kamilwu"}, "path": "sdks/python/apache_beam/ml/gcp/visionml_test.py", "diffHunk": "@@ -0,0 +1,252 @@\n+# pylint: skip-file\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for visionml.\"\"\"\n+\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+from __future__ import unicode_literals\n+\n+import logging\n+import unittest\n+\n+import mock\n+\n+import apache_beam as beam\n+from apache_beam.metrics import MetricsFilter\n+from apache_beam.typehints.decorators import TypeCheckError\n+\n+# Protect against environments where vision lib is not available.\n+try:\n+  from google.cloud.vision import ImageAnnotatorClient\n+  from google.cloud import vision\n+  from apache_beam.ml.gcp import visionml\n+except ImportError:\n+  ImageAnnotatorClient = None\n+\n+\n+@unittest.skipIf(\n+    ImageAnnotatorClient is None, 'Vision dependencies are not installed')\n+class VisionTest(unittest.TestCase):\n+  def setUp(self):\n+    self._mock_client = mock.Mock()\n+    self.m2 = mock.Mock()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54fd6c14e8ac6639fccc74b62cbb8c0e38241111"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTA0NjY3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/ml/gcp/visionml_test.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzoyNToyOFrOFurV8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzoyNToyOFrOFurV8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4ODk0NQ==", "bodyText": "It's safer to use result property rather than committed, because when committed is empty, attempted is being used. See the code:\n\n  \n    \n      beam/sdks/python/apache_beam/metrics/execution.py\n    \n    \n        Lines 129 to 134\n      in\n      f9f3159\n    \n    \n    \n    \n\n        \n          \n             @property \n        \n\n        \n          \n             def result(self): \n        \n\n        \n          \n               \"\"\"Short-hand for falling back to attempted metrics if it seems that \n        \n\n        \n          \n               committed was not populated (e.g. due to not being supported on a given \n        \n\n        \n          \n               runner\"\"\" \n        \n\n        \n          \n               return self.committed if self.committed else self.attempted", "url": "https://github.com/apache/beam/pull/10959#discussion_r384488945", "createdAt": "2020-02-26T13:25:28Z", "author": {"login": "kamilwu"}, "path": "sdks/python/apache_beam/ml/gcp/visionml_test.py", "diffHunk": "@@ -0,0 +1,252 @@\n+# pylint: skip-file\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for visionml.\"\"\"\n+\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+from __future__ import unicode_literals\n+\n+import logging\n+import unittest\n+\n+import mock\n+\n+import apache_beam as beam\n+from apache_beam.metrics import MetricsFilter\n+from apache_beam.typehints.decorators import TypeCheckError\n+\n+# Protect against environments where vision lib is not available.\n+try:\n+  from google.cloud.vision import ImageAnnotatorClient\n+  from google.cloud import vision\n+  from apache_beam.ml.gcp import visionml\n+except ImportError:\n+  ImageAnnotatorClient = None\n+\n+\n+@unittest.skipIf(\n+    ImageAnnotatorClient is None, 'Vision dependencies are not installed')\n+class VisionTest(unittest.TestCase):\n+  def setUp(self):\n+    self._mock_client = mock.Mock()\n+    self.m2 = mock.Mock()\n+    self._mock_client.batch_annotate_images.return_value = None\n+\n+    feature_type = vision.enums.Feature.Type.TEXT_DETECTION\n+    self.features = [\n+        vision.types.Feature(\n+            type=feature_type, max_results=3, model=\"builtin/stable\")\n+    ]\n+    self.img_ctx = vision.types.ImageContext()\n+    self.min_batch_size = 1\n+    self.max_batch_size = 1\n+\n+  def test_AnnotateImage_URIs(self):\n+    images_to_annotate = [\n+        'gs://cloud-samples-data/vision/ocr/sign.jpg',\n+        'gs://cloud-samples-data/vision/ocr/sign.jpg'\n+    ]\n+\n+    expected_counter = len(images_to_annotate)\n+    with mock.patch.object(visionml,\n+                           'get_vision_client',\n+                           return_value=self._mock_client):\n+      p = beam.Pipeline()\n+      _ = (\n+          p\n+          | \"Create data\" >> beam.Create(images_to_annotate)\n+          | \"Annotate image\" >> visionml.AnnotateImage(\n+              self.features,\n+              min_batch_size=self.min_batch_size,\n+              max_batch_size=self.max_batch_size))\n+      result = p.run()\n+      result.wait_until_finish()\n+\n+      read_filter = MetricsFilter().with_name('API Calls')\n+      query_result = result.metrics().query(read_filter)\n+      if query_result['counters']:\n+        read_counter = query_result['counters'][0]\n+        self.assertTrue(read_counter.committed == expected_counter)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54fd6c14e8ac6639fccc74b62cbb8c0e38241111"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1919, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}