{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4MTg2MTU5", "number": 12588, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzowNTo1MlrOEiXTnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0MjowNFrOEiuiXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDY4ODkyOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/graphx/coder.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzowNTo1MlrOHQMpdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNzo0MzowNFrOHS7jPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NjQ4Nw==", "bodyText": "Looks like a debug Println left in.", "url": "https://github.com/apache/beam/pull/12588#discussion_r486746487", "createdAt": "2020-09-11T03:05:52Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/coder.go", "diffHunk": "@@ -249,31 +256,35 @@ func (b *CoderUnmarshaller) makeCoder(c *pipepb.Coder) (*coder.Coder, error) {\n \t\t\treturn nil, err\n \t\t}\n \n-\t\t// No payload means this coder was length prefixed by the runner\n-\t\t// but is likely self describing - AKA a beam coder.\n-\t\tif len(sub.GetSpec().GetPayload()) == 0 {\n-\t\t\treturn b.makeCoder(sub)\n-\t\t}\n \t\t// TODO(lostluck) 2018/10/17: Make this strict again, once dataflow can use\n \t\t// the portable pipeline model directly (BEAM-2885)\n-\t\tif sub.GetSpec().GetUrn() != \"\" && sub.GetSpec().GetUrn() != urnCustomCoder {\n-\t\t\t// TODO(herohde) 11/17/2017: revisit this restriction\n-\t\t\treturn nil, errors.Errorf(\"could not unmarshal length prefix coder from %v, want a custom coder as a sub component but got %v\", c, sub)\n-\t\t}\n-\n-\t\tvar ref v1pb.CustomCoder\n-\t\tif err := protox.DecodeBase64(string(sub.GetSpec().GetPayload()), &ref); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tcustom, err := decodeCustomCoder(&ref)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\tswitch u := sub.GetSpec().GetUrn(); u {\n+\t\tcase \"\", urnCustomCoder:\n+\t\t\tvar ref v1pb.CustomCoder\n+\t\t\tif err := protox.DecodeBase64(string(sub.GetSpec().GetPayload()), &ref); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tcustom, err := decodeCustomCoder(&ref)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tcustom.ID = components[0]\n+\t\t\tt := typex.New(custom.Type)\n+\t\t\tcc := &coder.Coder{Kind: coder.Custom, T: t, Custom: custom}\n+\t\t\tfmt.Println(\"decoded customcoder\", cc)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMjA5Mw==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12588#discussion_r489612093", "createdAt": "2020-09-16T17:43:04Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/coder.go", "diffHunk": "@@ -249,31 +256,35 @@ func (b *CoderUnmarshaller) makeCoder(c *pipepb.Coder) (*coder.Coder, error) {\n \t\t\treturn nil, err\n \t\t}\n \n-\t\t// No payload means this coder was length prefixed by the runner\n-\t\t// but is likely self describing - AKA a beam coder.\n-\t\tif len(sub.GetSpec().GetPayload()) == 0 {\n-\t\t\treturn b.makeCoder(sub)\n-\t\t}\n \t\t// TODO(lostluck) 2018/10/17: Make this strict again, once dataflow can use\n \t\t// the portable pipeline model directly (BEAM-2885)\n-\t\tif sub.GetSpec().GetUrn() != \"\" && sub.GetSpec().GetUrn() != urnCustomCoder {\n-\t\t\t// TODO(herohde) 11/17/2017: revisit this restriction\n-\t\t\treturn nil, errors.Errorf(\"could not unmarshal length prefix coder from %v, want a custom coder as a sub component but got %v\", c, sub)\n-\t\t}\n-\n-\t\tvar ref v1pb.CustomCoder\n-\t\tif err := protox.DecodeBase64(string(sub.GetSpec().GetPayload()), &ref); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tcustom, err := decodeCustomCoder(&ref)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\tswitch u := sub.GetSpec().GetUrn(); u {\n+\t\tcase \"\", urnCustomCoder:\n+\t\t\tvar ref v1pb.CustomCoder\n+\t\t\tif err := protox.DecodeBase64(string(sub.GetSpec().GetPayload()), &ref); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tcustom, err := decodeCustomCoder(&ref)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tcustom.ID = components[0]\n+\t\t\tt := typex.New(custom.Type)\n+\t\t\tcc := &coder.Coder{Kind: coder.Custom, T: t, Custom: custom}\n+\t\t\tfmt.Println(\"decoded customcoder\", cc)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NjQ4Nw=="}, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDgzMzAwOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNDozNDowOFrOHQN8WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMzoyMToxNlrOHSelow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2NzcwNA==", "bodyText": "I don't really understand this comment, or how it relates to the check below.", "url": "https://github.com/apache/beam/pull/12588#discussion_r486767704", "createdAt": "2020-09-11T04:34:08Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -81,24 +82,82 @@ func MakeElementEncoder(c *coder.Coder) ElementEncoder {\n \t\treturn &stringEncoder{}\n \n \tcase coder.Custom:\n-\t\treturn &customEncoder{\n+\t\tenc := &customEncoder{\n \t\t\tt:   c.Custom.Type,\n \t\t\tenc: makeEncoder(c.Custom.Enc.Fn),\n \t\t}\n+\t\tif c.Custom.Name != \"schema\" {\n+\t\t\treturn enc\n+\t\t}\n+\t\t// Custom schema coding is shorthand for using beam infrastructure\n+\t\t// wrapped in a custom coder.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIyMjM4OA==", "bodyText": "\"Custom schema coding uses the beam row coder, but wrapping it in a length prefix and treats it as an opaque coder.\"\nDoes that make more sense?", "url": "https://github.com/apache/beam/pull/12588#discussion_r488222388", "createdAt": "2020-09-14T21:11:02Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -81,24 +82,82 @@ func MakeElementEncoder(c *coder.Coder) ElementEncoder {\n \t\treturn &stringEncoder{}\n \n \tcase coder.Custom:\n-\t\treturn &customEncoder{\n+\t\tenc := &customEncoder{\n \t\t\tt:   c.Custom.Type,\n \t\t\tenc: makeEncoder(c.Custom.Enc.Fn),\n \t\t}\n+\t\tif c.Custom.Name != \"schema\" {\n+\t\t\treturn enc\n+\t\t}\n+\t\t// Custom schema coding is shorthand for using beam infrastructure\n+\t\t// wrapped in a custom coder.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2NzcwNA=="}, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEzNzU3MQ==", "bodyText": "Yeah that makes more sense to me.", "url": "https://github.com/apache/beam/pull/12588#discussion_r489137571", "createdAt": "2020-09-16T03:21:16Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -81,24 +82,82 @@ func MakeElementEncoder(c *coder.Coder) ElementEncoder {\n \t\treturn &stringEncoder{}\n \n \tcase coder.Custom:\n-\t\treturn &customEncoder{\n+\t\tenc := &customEncoder{\n \t\t\tt:   c.Custom.Type,\n \t\t\tenc: makeEncoder(c.Custom.Enc.Fn),\n \t\t}\n+\t\tif c.Custom.Name != \"schema\" {\n+\t\t\treturn enc\n+\t\t}\n+\t\t// Custom schema coding is shorthand for using beam infrastructure\n+\t\t// wrapped in a custom coder.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2NzcwNA=="}, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDg4NTk4OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNTowNToxN1rOHQObDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNTowNToxN1rOHQObDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc3NTU2NA==", "bodyText": "Looks like another debug println.", "url": "https://github.com/apache/beam/pull/12588#discussion_r486775564", "createdAt": "2020-09-11T05:05:17Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -117,17 +176,88 @@ func MakeElementDecoder(c *coder.Coder) ElementDecoder {\n \t\treturn &stringDecoder{}\n \n \tcase coder.Custom:\n-\t\treturn &customDecoder{\n+\t\tdec := &customDecoder{\n \t\t\tt:   c.Custom.Type,\n \t\t\tdec: makeDecoder(c.Custom.Dec.Fn),\n \t\t}\n \n+\t\tfmt.Println(\"getting decoder\", c.Custom)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDkwMzE0OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNToxNDo1OFrOHQOlKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNzozMzo1OFrOHS7PFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc3ODE1NQ==", "bodyText": "Just to confirm, using an arrayDecoder without an arrayEncoder specifically works because the format that iterableEncoder encodes to is also decodable as an array, right? That might be worth mentioning as a comment, because I was wondering why you can decode arrays with an arrayDecoder if they were encoded with an iterableEncoder.", "url": "https://github.com/apache/beam/pull/12588#discussion_r486778155", "createdAt": "2020-09-11T05:14:58Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -117,17 +176,88 @@ func MakeElementDecoder(c *coder.Coder) ElementDecoder {\n \t\treturn &stringDecoder{}\n \n \tcase coder.Custom:\n-\t\treturn &customDecoder{\n+\t\tdec := &customDecoder{\n \t\t\tt:   c.Custom.Type,\n \t\t\tdec: makeDecoder(c.Custom.Dec.Fn),\n \t\t}\n \n+\t\tfmt.Println(\"getting decoder\", c.Custom)\n+\t\tif c.Custom.Name != \"schema\" {\n+\t\t\treturn dec\n+\t\t}\n+\t\t// Custom schema coding is shorthand for using beam infrastructure\n+\t\t// wrapped in a custom coder.\n+\t\tswitch c.T.Type().Kind() {\n+\t\tcase reflect.Slice:\n+\t\t\treturn &lpDecoder{\n+\t\t\t\tdec: &iterableDecoder{\n+\t\t\t\t\tt:   c.Custom.Type,\n+\t\t\t\t\tdec: dec,\n+\t\t\t\t},\n+\t\t\t}\n+\t\tcase reflect.Array:\n+\t\t\treturn &lpDecoder{\n+\t\t\t\tdec: &arrayDecoder{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwNjkzNQ==", "bodyText": "That's right the encoding format for both is the same. I'll put the comment on the array decoder itself rather than here though.", "url": "https://github.com/apache/beam/pull/12588#discussion_r489606935", "createdAt": "2020-09-16T17:33:58Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -117,17 +176,88 @@ func MakeElementDecoder(c *coder.Coder) ElementDecoder {\n \t\treturn &stringDecoder{}\n \n \tcase coder.Custom:\n-\t\treturn &customDecoder{\n+\t\tdec := &customDecoder{\n \t\t\tt:   c.Custom.Type,\n \t\t\tdec: makeDecoder(c.Custom.Dec.Fn),\n \t\t}\n \n+\t\tfmt.Println(\"getting decoder\", c.Custom)\n+\t\tif c.Custom.Name != \"schema\" {\n+\t\t\treturn dec\n+\t\t}\n+\t\t// Custom schema coding is shorthand for using beam infrastructure\n+\t\t// wrapped in a custom coder.\n+\t\tswitch c.T.Type().Kind() {\n+\t\tcase reflect.Slice:\n+\t\t\treturn &lpDecoder{\n+\t\t\t\tdec: &iterableDecoder{\n+\t\t\t\t\tt:   c.Custom.Type,\n+\t\t\t\t\tdec: dec,\n+\t\t\t\t},\n+\t\t\t}\n+\t\tcase reflect.Array:\n+\t\t\treturn &lpDecoder{\n+\t\t\t\tdec: &arrayDecoder{", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc3ODE1NQ=="}, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDkyNjY0OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNToyODoxOVrOHQOzMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNzozNTowMFrOHS7RhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4MTc0Ng==", "bodyText": "Is it necessary to cast n to an int here? Isn't it already an int from line 638?", "url": "https://github.com/apache/beam/pull/12588#discussion_r486781746", "createdAt": "2020-09-11T05:28:19Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -434,6 +600,267 @@ func convertIfNeeded(v interface{}, allocated *FullValue) *FullValue {\n \treturn allocated\n }\n \n+type iterableEncoder struct {\n+\tt   reflect.Type\n+\tenc ElementEncoder\n+}\n+\n+func (c *iterableEncoder) Encode(val *FullValue, w io.Writer) error {\n+\t// Do a reflect, get the length.\n+\trv := reflect.ValueOf(val.Elm)\n+\tsize := rv.Len()\n+\tif err := coder.EncodeInt32((int32)(size), w); err != nil {\n+\t\treturn err\n+\t}\n+\tvar e FullValue\n+\tfor i := 0; i < size; i++ {\n+\t\te.Elm = rv.Index(i).Interface()\n+\t\terr := c.enc.Encode(&e, w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type iterableDecoder struct {\n+\tt   reflect.Type\n+\tdec ElementDecoder\n+}\n+\n+func (c *iterableDecoder) DecodeTo(r io.Reader, fv *FullValue) error {\n+\t// (1) Read count prefixed encoded data\n+\n+\tsize, err := coder.DecodeInt32(r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tn := int(size)\n+\tswitch {\n+\tcase n >= 0:\n+\t\trv, err := c.decodeToSlice(int(n), r)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwNzU1Ng==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12588#discussion_r489607556", "createdAt": "2020-09-16T17:35:00Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -434,6 +600,267 @@ func convertIfNeeded(v interface{}, allocated *FullValue) *FullValue {\n \treturn allocated\n }\n \n+type iterableEncoder struct {\n+\tt   reflect.Type\n+\tenc ElementEncoder\n+}\n+\n+func (c *iterableEncoder) Encode(val *FullValue, w io.Writer) error {\n+\t// Do a reflect, get the length.\n+\trv := reflect.ValueOf(val.Elm)\n+\tsize := rv.Len()\n+\tif err := coder.EncodeInt32((int32)(size), w); err != nil {\n+\t\treturn err\n+\t}\n+\tvar e FullValue\n+\tfor i := 0; i < size; i++ {\n+\t\te.Elm = rv.Index(i).Interface()\n+\t\terr := c.enc.Encode(&e, w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type iterableDecoder struct {\n+\tt   reflect.Type\n+\tdec ElementDecoder\n+}\n+\n+func (c *iterableDecoder) DecodeTo(r io.Reader, fv *FullValue) error {\n+\t// (1) Read count prefixed encoded data\n+\n+\tsize, err := coder.DecodeInt32(r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tn := int(size)\n+\tswitch {\n+\tcase n >= 0:\n+\t\trv, err := c.decodeToSlice(int(n), r)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4MTc0Ng=="}, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 337}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDkzMDc5OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNTozMDozNVrOHQO1lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNzozNTowOFrOHS7Rxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4MjM1OA==", "bodyText": "Likewise, is it necessary to cast n here too?", "url": "https://github.com/apache/beam/pull/12588#discussion_r486782358", "createdAt": "2020-09-11T05:30:35Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -434,6 +600,267 @@ func convertIfNeeded(v interface{}, allocated *FullValue) *FullValue {\n \treturn allocated\n }\n \n+type iterableEncoder struct {\n+\tt   reflect.Type\n+\tenc ElementEncoder\n+}\n+\n+func (c *iterableEncoder) Encode(val *FullValue, w io.Writer) error {\n+\t// Do a reflect, get the length.\n+\trv := reflect.ValueOf(val.Elm)\n+\tsize := rv.Len()\n+\tif err := coder.EncodeInt32((int32)(size), w); err != nil {\n+\t\treturn err\n+\t}\n+\tvar e FullValue\n+\tfor i := 0; i < size; i++ {\n+\t\te.Elm = rv.Index(i).Interface()\n+\t\terr := c.enc.Encode(&e, w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type iterableDecoder struct {\n+\tt   reflect.Type\n+\tdec ElementDecoder\n+}\n+\n+func (c *iterableDecoder) DecodeTo(r io.Reader, fv *FullValue) error {\n+\t// (1) Read count prefixed encoded data\n+\n+\tsize, err := coder.DecodeInt32(r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tn := int(size)\n+\tswitch {\n+\tcase n >= 0:\n+\t\trv, err := c.decodeToSlice(int(n), r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t\treturn nil\n+\tcase n == -1:\n+\t\trv := reflect.MakeSlice(c.t, 0, 0)\n+\t\tchunk, err := coder.DecodeVarInt(r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfor chunk != 0 {\n+\t\t\trvi, err := c.decodeToSlice(int(chunk), r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\trv = reflect.AppendSlice(rv, rvi)\n+\t\t\tchunk, err = coder.DecodeVarInt(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (c *iterableDecoder) decodeToSlice(n int, r io.Reader) (reflect.Value, error) {\n+\tvar e FullValue\n+\trv := reflect.MakeSlice(c.t, n, n)\n+\tfor i := 0; i < int(n); i++ {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwNzYyMg==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12588#discussion_r489607622", "createdAt": "2020-09-16T17:35:08Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -434,6 +600,267 @@ func convertIfNeeded(v interface{}, allocated *FullValue) *FullValue {\n \treturn allocated\n }\n \n+type iterableEncoder struct {\n+\tt   reflect.Type\n+\tenc ElementEncoder\n+}\n+\n+func (c *iterableEncoder) Encode(val *FullValue, w io.Writer) error {\n+\t// Do a reflect, get the length.\n+\trv := reflect.ValueOf(val.Elm)\n+\tsize := rv.Len()\n+\tif err := coder.EncodeInt32((int32)(size), w); err != nil {\n+\t\treturn err\n+\t}\n+\tvar e FullValue\n+\tfor i := 0; i < size; i++ {\n+\t\te.Elm = rv.Index(i).Interface()\n+\t\terr := c.enc.Encode(&e, w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type iterableDecoder struct {\n+\tt   reflect.Type\n+\tdec ElementDecoder\n+}\n+\n+func (c *iterableDecoder) DecodeTo(r io.Reader, fv *FullValue) error {\n+\t// (1) Read count prefixed encoded data\n+\n+\tsize, err := coder.DecodeInt32(r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tn := int(size)\n+\tswitch {\n+\tcase n >= 0:\n+\t\trv, err := c.decodeToSlice(int(n), r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t\treturn nil\n+\tcase n == -1:\n+\t\trv := reflect.MakeSlice(c.t, 0, 0)\n+\t\tchunk, err := coder.DecodeVarInt(r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfor chunk != 0 {\n+\t\t\trvi, err := c.decodeToSlice(int(chunk), r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\trv = reflect.AppendSlice(rv, rvi)\n+\t\t\tchunk, err = coder.DecodeVarInt(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (c *iterableDecoder) decodeToSlice(n int, r io.Reader) (reflect.Value, error) {\n+\tvar e FullValue\n+\trv := reflect.MakeSlice(c.t, n, n)\n+\tfor i := 0; i < int(n); i++ {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4MjM1OA=="}, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 369}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDkzNjEyOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNTozMzozNlrOHQO4vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMzoyNDowNVrOHSeoWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4MzE2NQ==", "bodyText": "I don't get why it's setting the value of the element to e.Windows[0]. Is it a way to pass in nil?", "url": "https://github.com/apache/beam/pull/12588#discussion_r486783165", "createdAt": "2020-09-11T05:33:36Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -434,6 +600,267 @@ func convertIfNeeded(v interface{}, allocated *FullValue) *FullValue {\n \treturn allocated\n }\n \n+type iterableEncoder struct {\n+\tt   reflect.Type\n+\tenc ElementEncoder\n+}\n+\n+func (c *iterableEncoder) Encode(val *FullValue, w io.Writer) error {\n+\t// Do a reflect, get the length.\n+\trv := reflect.ValueOf(val.Elm)\n+\tsize := rv.Len()\n+\tif err := coder.EncodeInt32((int32)(size), w); err != nil {\n+\t\treturn err\n+\t}\n+\tvar e FullValue\n+\tfor i := 0; i < size; i++ {\n+\t\te.Elm = rv.Index(i).Interface()\n+\t\terr := c.enc.Encode(&e, w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type iterableDecoder struct {\n+\tt   reflect.Type\n+\tdec ElementDecoder\n+}\n+\n+func (c *iterableDecoder) DecodeTo(r io.Reader, fv *FullValue) error {\n+\t// (1) Read count prefixed encoded data\n+\n+\tsize, err := coder.DecodeInt32(r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tn := int(size)\n+\tswitch {\n+\tcase n >= 0:\n+\t\trv, err := c.decodeToSlice(int(n), r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t\treturn nil\n+\tcase n == -1:\n+\t\trv := reflect.MakeSlice(c.t, 0, 0)\n+\t\tchunk, err := coder.DecodeVarInt(r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfor chunk != 0 {\n+\t\t\trvi, err := c.decodeToSlice(int(chunk), r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\trv = reflect.AppendSlice(rv, rvi)\n+\t\t\tchunk, err = coder.DecodeVarInt(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (c *iterableDecoder) decodeToSlice(n int, r io.Reader) (reflect.Value, error) {\n+\tvar e FullValue\n+\trv := reflect.MakeSlice(c.t, n, n)\n+\tfor i := 0; i < int(n); i++ {\n+\t\terr := c.dec.DecodeTo(r, &e)\n+\t\tif err != nil {\n+\t\t\treturn reflect.Value{}, err\n+\t\t}\n+\t\tif e.Elm != nil {\n+\t\t\trv.Index(i).Set(reflect.ValueOf(e.Elm))\n+\t\t} else {\n+\t\t\trv.Index(i).Set(reflect.ValueOf(e.Windows[0]))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIyNjIxOA==", "bodyText": "In this case it's to set it to the 0th window element. In this case it's a small hack to support \"window's as element values\" which is only necessary to dramatically simplify the yaml tests which actually test the coder values here.\nDeserves a comment to explain it, as it is a hack.", "url": "https://github.com/apache/beam/pull/12588#discussion_r488226218", "createdAt": "2020-09-14T21:19:19Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -434,6 +600,267 @@ func convertIfNeeded(v interface{}, allocated *FullValue) *FullValue {\n \treturn allocated\n }\n \n+type iterableEncoder struct {\n+\tt   reflect.Type\n+\tenc ElementEncoder\n+}\n+\n+func (c *iterableEncoder) Encode(val *FullValue, w io.Writer) error {\n+\t// Do a reflect, get the length.\n+\trv := reflect.ValueOf(val.Elm)\n+\tsize := rv.Len()\n+\tif err := coder.EncodeInt32((int32)(size), w); err != nil {\n+\t\treturn err\n+\t}\n+\tvar e FullValue\n+\tfor i := 0; i < size; i++ {\n+\t\te.Elm = rv.Index(i).Interface()\n+\t\terr := c.enc.Encode(&e, w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type iterableDecoder struct {\n+\tt   reflect.Type\n+\tdec ElementDecoder\n+}\n+\n+func (c *iterableDecoder) DecodeTo(r io.Reader, fv *FullValue) error {\n+\t// (1) Read count prefixed encoded data\n+\n+\tsize, err := coder.DecodeInt32(r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tn := int(size)\n+\tswitch {\n+\tcase n >= 0:\n+\t\trv, err := c.decodeToSlice(int(n), r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t\treturn nil\n+\tcase n == -1:\n+\t\trv := reflect.MakeSlice(c.t, 0, 0)\n+\t\tchunk, err := coder.DecodeVarInt(r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfor chunk != 0 {\n+\t\t\trvi, err := c.decodeToSlice(int(chunk), r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\trv = reflect.AppendSlice(rv, rvi)\n+\t\t\tchunk, err = coder.DecodeVarInt(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (c *iterableDecoder) decodeToSlice(n int, r io.Reader) (reflect.Value, error) {\n+\tvar e FullValue\n+\trv := reflect.MakeSlice(c.t, n, n)\n+\tfor i := 0; i < int(n); i++ {\n+\t\terr := c.dec.DecodeTo(r, &e)\n+\t\tif err != nil {\n+\t\t\treturn reflect.Value{}, err\n+\t\t}\n+\t\tif e.Elm != nil {\n+\t\t\trv.Index(i).Set(reflect.ValueOf(e.Elm))\n+\t\t} else {\n+\t\t\trv.Index(i).Set(reflect.ValueOf(e.Windows[0]))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4MzE2NQ=="}, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEzODI2NQ==", "bodyText": "Ah that makes sense now. Yeah definitely could use a comment.", "url": "https://github.com/apache/beam/pull/12588#discussion_r489138265", "createdAt": "2020-09-16T03:24:05Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -434,6 +600,267 @@ func convertIfNeeded(v interface{}, allocated *FullValue) *FullValue {\n \treturn allocated\n }\n \n+type iterableEncoder struct {\n+\tt   reflect.Type\n+\tenc ElementEncoder\n+}\n+\n+func (c *iterableEncoder) Encode(val *FullValue, w io.Writer) error {\n+\t// Do a reflect, get the length.\n+\trv := reflect.ValueOf(val.Elm)\n+\tsize := rv.Len()\n+\tif err := coder.EncodeInt32((int32)(size), w); err != nil {\n+\t\treturn err\n+\t}\n+\tvar e FullValue\n+\tfor i := 0; i < size; i++ {\n+\t\te.Elm = rv.Index(i).Interface()\n+\t\terr := c.enc.Encode(&e, w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type iterableDecoder struct {\n+\tt   reflect.Type\n+\tdec ElementDecoder\n+}\n+\n+func (c *iterableDecoder) DecodeTo(r io.Reader, fv *FullValue) error {\n+\t// (1) Read count prefixed encoded data\n+\n+\tsize, err := coder.DecodeInt32(r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tn := int(size)\n+\tswitch {\n+\tcase n >= 0:\n+\t\trv, err := c.decodeToSlice(int(n), r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t\treturn nil\n+\tcase n == -1:\n+\t\trv := reflect.MakeSlice(c.t, 0, 0)\n+\t\tchunk, err := coder.DecodeVarInt(r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfor chunk != 0 {\n+\t\t\trvi, err := c.decodeToSlice(int(chunk), r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\trv = reflect.AppendSlice(rv, rvi)\n+\t\t\tchunk, err = coder.DecodeVarInt(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (c *iterableDecoder) decodeToSlice(n int, r io.Reader) (reflect.Value, error) {\n+\tvar e FullValue\n+\trv := reflect.MakeSlice(c.t, n, n)\n+\tfor i := 0; i < int(n); i++ {\n+\t\terr := c.dec.DecodeTo(r, &e)\n+\t\tif err != nil {\n+\t\t\treturn reflect.Value{}, err\n+\t\t}\n+\t\tif e.Elm != nil {\n+\t\t\trv.Index(i).Set(reflect.ValueOf(e.Elm))\n+\t\t} else {\n+\t\t\trv.Index(i).Set(reflect.ValueOf(e.Windows[0]))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4MzE2NQ=="}, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 377}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODM5MDMyOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMzoyMToyOVrOHQwRxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNzo0MTo0OVrOHS7gjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzMDI0Ng==", "bodyText": "What's the reason to switch from DecodeVarUint64 to DecodeVarInt here?", "url": "https://github.com/apache/beam/pull/12588#discussion_r487330246", "createdAt": "2020-09-11T23:21:29Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -534,26 +1038,34 @@ func (*intervalWindowEncoder) EncodeSingle(elm typex.Window, w io.Writer) error\n \n type intervalWindowDecoder struct{}\n \n-func (*intervalWindowDecoder) Decode(r io.Reader) ([]typex.Window, error) {\n+func (d *intervalWindowDecoder) Decode(r io.Reader) ([]typex.Window, error) {\n \t// Encoding: upper bound and duration\n \n \tn, err := coder.DecodeInt32(r) // #windows\n \n \tret := make([]typex.Window, n, n)\n \tfor i := int32(0); i < n; i++ {\n-\t\tend, err := coder.DecodeEventTime(r)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tduration, err := coder.DecodeVarUint64(r)\n+\t\tw, err := d.DecodeSingle(r)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tret[i] = window.IntervalWindow{Start: mtime.FromMilliseconds(end.Milliseconds() - int64(duration)), End: end}\n+\t\tret[i] = w\n \t}\n \treturn ret, err\n }\n \n+func (*intervalWindowDecoder) DecodeSingle(r io.Reader) (typex.Window, error) {\n+\tend, err := coder.DecodeEventTime(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tduration, err := coder.DecodeVarInt(r)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 709}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMTQwNg==", "bodyText": "Ah no difference TBH. DecodeVarInt basically just does an extra cast from uint64 to int64, which I didn't remove.\nI went back to DecodeVarUint64 since it avoids an extra layer of if checks and a function call.", "url": "https://github.com/apache/beam/pull/12588#discussion_r489611406", "createdAt": "2020-09-16T17:41:49Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -534,26 +1038,34 @@ func (*intervalWindowEncoder) EncodeSingle(elm typex.Window, w io.Writer) error\n \n type intervalWindowDecoder struct{}\n \n-func (*intervalWindowDecoder) Decode(r io.Reader) ([]typex.Window, error) {\n+func (d *intervalWindowDecoder) Decode(r io.Reader) ([]typex.Window, error) {\n \t// Encoding: upper bound and duration\n \n \tn, err := coder.DecodeInt32(r) // #windows\n \n \tret := make([]typex.Window, n, n)\n \tfor i := int32(0); i < n; i++ {\n-\t\tend, err := coder.DecodeEventTime(r)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tduration, err := coder.DecodeVarUint64(r)\n+\t\tw, err := d.DecodeSingle(r)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tret[i] = window.IntervalWindow{Start: mtime.FromMilliseconds(end.Milliseconds() - int64(duration)), End: end}\n+\t\tret[i] = w\n \t}\n \treturn ret, err\n }\n \n+func (*intervalWindowDecoder) DecodeSingle(r io.Reader) (typex.Window, error) {\n+\tend, err := coder.DecodeEventTime(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tduration, err := coder.DecodeVarInt(r)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzMDI0Ng=="}, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 709}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ5NTAzOnYy", "diffSide": "RIGHT", "path": "sdks/go/test/regression/coders/fromyaml/fromyaml.go", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0MjowNFrOHQxKyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMzozMDoxMFrOHSeuZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDg0Mg==", "bodyText": "Is this assumption made specifically based on the yaml file this is meant to be used with? Or is this based on something in the schema spec I'm forgetting?", "url": "https://github.com/apache/beam/pull/12588#discussion_r487344842", "createdAt": "2020-09-12T00:42:04Z", "author": {"login": "youngoli"}, "path": "sdks/go/test/regression/coders/fromyaml/fromyaml.go", "diffHunk": "@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// fromyaml generates a resource file from the standard_coders.yaml\n+// file for use in these coder regression tests.\n+//\n+// It expects to be run in it's test directory, or via it's go test.\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"math\"\n+\t\"reflect\"\n+\t\"runtime/debug\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/mtime\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/window\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"golang.org/x/text/encoding/charmap\"\n+\tyaml \"gopkg.in/yaml.v2\"\n+)\n+\n+var unimplementedCoders = map[string]bool{\n+\t\"beam:coder:param_windowed_value:v1\": true,\n+\t\"beam:coder:timer:v1\":                true,\n+}\n+\n+// Coder is a representation a serialized beam coder.\n+type Coder struct {\n+\tUrn              string  `yaml:\"urn,omitempty\"`\n+\tPayload          string  `yaml:\"payload,omitempty\"`\n+\tComponents       []Coder `yaml:\"components,omitempty\"`\n+\tNonDeterministic bool    `yaml:\"non_deterministic,omitempty\"`\n+}\n+\n+type logger interface {\n+\tErrorf(string, ...interface{})\n+\tLogf(string, ...interface{})\n+}\n+\n+// Spec is a set of conditions that a coder must pass.\n+type Spec struct {\n+\tCoder    Coder         `yaml:\"coder,omitempty\"`\n+\tNested   *bool         `yaml:\"nested,omitempty\"`\n+\tExamples yaml.MapSlice `yaml:\"examples,omitempty\"`\n+\tLog      logger\n+\n+\tid       int // for generating coder ids.\n+\tcoderPBs map[string]*pipepb.Coder\n+}\n+\n+func (s *Spec) nextID() string {\n+\tret := fmt.Sprintf(\"%d\", s.id)\n+\ts.id++\n+\treturn ret\n+}\n+\n+func (s *Spec) testStandardCoder() (err error) {\n+\tif unimplementedCoders[s.Coder.Urn] {\n+\t\tlog.Printf(\"skipping unimplemented coder urn: %v\", s.Coder.Urn)\n+\t\treturn nil\n+\t}\n+\t// Construct the coder proto equivalents.\n+\n+\t// Only nested tests need to be run, since nestedness is a pre-portability\n+\t// concept.\n+\t// For legacy Java reasons, the row coder examples are all marked nested: false\n+\t// so we need to check that before skipping unnested tests.\n+\tif s.Coder.Urn != \"beam:coder:row:v1\" && s.Nested != nil && !*s.Nested {\n+\t\tlog.Printf(\"skipping unnested coder spec: %v\\n\", s.Coder)\n+\t\treturn nil\n+\t}\n+\n+\ts.coderPBs = make(map[string]*pipepb.Coder)\n+\tid := s.parseCoder(s.Coder)\n+\tb := graphx.NewCoderUnmarshaller(s.coderPBs)\n+\tunderTest, err := b.Coder(id)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"unable to create coder: %v\", err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif e := recover(); e != nil {\n+\t\t\terr = fmt.Errorf(\"panicked on coder %v || %v:\\n\\t%v :\\n%s\", underTest, s.Coder, e, debug.Stack())\n+\t\t}\n+\t}()\n+\n+\tvar decFails, encFails int\n+\tfor _, eg := range s.Examples {\n+\n+\t\t// Test Decoding\n+\t\t// Ideally we'd use the beam package coders, but KVs make that complicated.\n+\t\t// This can be cleaned up once a type parametered beam.KV type exists.\n+\t\tdec := exec.MakeElementDecoder(underTest)\n+\t\tencoded := eg.Key.(string)\n+\t\tvar elem exec.FullValue\n+\n+\t\t// What I would have expected.\n+\t\t//\t\tr := charmap.ISO8859_1.NewDecoder().Reader(strings.NewReader(encoded))\n+\t\trecoded, err := charmap.ISO8859_1.NewEncoder().String(encoded)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tr := strings.NewReader(recoded)\n+\t\tif err := dec.DecodeTo(r, &elem); err != nil {\n+\t\t\treturn fmt.Errorf(\"err decoding %q: %v\", encoded, err)\n+\t\t}\n+\t\tif !diff(s.Coder, &elem, eg) {\n+\t\t\tdecFails++\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Test Encoding\n+\t\tif s.Coder.NonDeterministic {\n+\t\t\t// Skip verifying nondeterministic encodings.\n+\t\t\tcontinue\n+\t\t}\n+\t\tenc := exec.MakeElementEncoder(underTest)\n+\t\tvar out bytes.Buffer\n+\t\tif err := enc.Encode(&elem, &out); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif d := cmp.Diff(recoded, string(out.Bytes())); d != \"\" {\n+\t\t\tlog.Printf(\"Encoding error: diff(-want,+got): %v\\n\", d)\n+\t\t}\n+\t}\n+\tif decFails+encFails > 0 {\n+\t\treturn fmt.Errorf(\"failed to decode %v times, and encode %v times\", decFails, encFails)\n+\t}\n+\n+\treturn nil\n+}\n+\n+var cmpOpts = []cmp.Option{\n+\tcmp.Transformer(\"bytes2string\", func(in []byte) (out string) {\n+\t\treturn string(in)\n+\t}),\n+}\n+\n+func diff(c Coder, elem *exec.FullValue, eg yaml.MapItem) bool {\n+\tvar got, want interface{}\n+\tswitch c.Urn {\n+\tcase \"beam:coder:bytes:v1\":\n+\t\tgot = string(elem.Elm.([]byte))\n+\t\tswitch egv := eg.Value.(type) {\n+\t\tcase string:\n+\t\t\twant = egv\n+\t\tcase []byte:\n+\t\t\twant = string(egv)\n+\t\t}\n+\tcase \"beam:coder:varint:v1\":\n+\t\tgot, want = elem.Elm.(int64), int64(eg.Value.(int))\n+\tcase \"beam:coder:double:v1\":\n+\t\tgot = elem.Elm.(float64)\n+\t\tswitch v := eg.Value.(string); v {\n+\t\tcase \"NaN\":\n+\t\t\t// Do the NaN comparison here since NaN by definition != NaN.\n+\t\t\tif math.IsNaN(got.(float64)) {\n+\t\t\t\twant, got = 1, 1\n+\t\t\t} else {\n+\t\t\t\twant = math.NaN()\n+\t\t\t}\n+\t\tcase \"-Infinity\":\n+\t\t\twant = math.Inf(-1)\n+\t\tcase \"Infinity\":\n+\t\t\twant = math.Inf(1)\n+\t\tdefault:\n+\t\t\twant, _ = strconv.ParseFloat(v, 64)\n+\t\t}\n+\n+\tcase \"beam:coder:kv:v1\":\n+\t\tv := eg.Value.(yaml.MapSlice)\n+\t\tpass := true\n+\t\tif !diff(c.Components[0], &exec.FullValue{Elm: elem.Elm}, v[0]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\tif !diff(c.Components[1], &exec.FullValue{Elm: elem.Elm2}, v[1]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\treturn pass\n+\n+\tcase \"beam:coder:iterable:v1\":\n+\t\tpass := true\n+\t\tgotrv := reflect.ValueOf(elem.Elm)\n+\t\twantrv := reflect.ValueOf(eg.Value)\n+\t\tif gotrv.Len() != wantrv.Len() {\n+\t\t\tlog.Printf(\"Lengths don't match. got %v, want %v;  %v, %v\", gotrv.Len(), wantrv.Len(), gotrv, wantrv)\n+\t\t\treturn false\n+\t\t}\n+\t\tfor i := 0; i < wantrv.Len(); i++ {\n+\t\t\tif !diff(c.Components[0],\n+\t\t\t\t&exec.FullValue{Elm: gotrv.Index(i).Interface()},\n+\t\t\t\tyaml.MapItem{Value: wantrv.Index(i).Interface()}) {\n+\t\t\t\tpass = false\n+\t\t\t}\n+\n+\t\t}\n+\t\treturn pass\n+\tcase \"beam:coder:interval_window:v1\":\n+\t\tvar a, b int\n+\t\tval := eg.Value\n+\t\tif is, ok := eg.Value.([]interface{}); ok {\n+\t\t\tval = is[0]\n+\t\t}\n+\t\tv := val.(yaml.MapSlice)\n+\n+\t\ta = v[0].Value.(int)\n+\t\tb = v[1].Value.(int)\n+\t\tend := mtime.FromMilliseconds(int64(a))\n+\t\tstart := end - mtime.Time(int64(b))\n+\t\twant = window.IntervalWindow{Start: start, End: end}\n+\t\t// If this is nested in an iterable, windows won't be populated.\n+\t\tif len(elem.Windows) == 0 {\n+\t\t\tgot = elem.Elm\n+\t\t} else {\n+\t\t\tgot = elem.Windows[0]\n+\t\t}\n+\n+\tcase \"beam:coder:global_window:v1\":\n+\t\twant = window.GlobalWindow{}\n+\t\t// If this is nested in an iterable, windows won't be populated.\n+\t\tif len(elem.Windows) == 0 {\n+\t\t\tgot = window.GlobalWindow(elem.Elm.(struct{}))\n+\t\t} else {\n+\t\t\tgot = elem.Windows[0]\n+\t\t}\n+\tcase \"beam:coder:windowed_value:v1\", \"beam:coder:param_windowed_value:v1\":\n+\t\t// elem contains all the information, but we need to compare the element+timestamp\n+\t\t// separately from the windows, to avoid repeated expected value parsing logic.\n+\t\tpass := true\n+\t\tvs := eg.Value.(yaml.MapSlice)\n+\t\tif !diff(c.Components[0], elem, vs[0]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\tif d := cmp.Diff(\n+\t\t\tmtime.FromMilliseconds(int64(vs[1].Value.(int))),\n+\t\t\telem.Timestamp, cmpOpts...); d != \"\" {\n+\n+\t\t\tpass = false\n+\t\t}\n+\t\tif !diff(c.Components[1], elem, vs[3]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\t// TODO compare pane information.\n+\t\treturn pass\n+\tcase \"beam:coder:row:v1\":\n+\t\tfs := eg.Value.(yaml.MapSlice)\n+\t\tvar rfs []reflect.StructField\n+\t\t// There are only 2 pointer examples, but they reuse field names,\n+\t\t// so we key off the proto hash to know which example we're handling.\n+\t\tptrEg := strings.Contains(c.Payload, \"51ace21c7393\")\n+\t\tfor _, rf := range fs {\n+\t\t\tname := rf.Key.(string)\n+\t\t\tt := nameToType[name]\n+\t\t\tif ptrEg {\n+\t\t\t\tt = reflect.PtrTo(t)\n+\t\t\t}\n+\t\t\trfs = append(rfs, reflect.StructField{\n+\t\t\t\tName: strings.ToUpper(name[:1]) + name[1:],\n+\t\t\t\tType: t,\n+\t\t\t\tTag:  reflect.StructTag(fmt.Sprintf(\"beam:\\\"%v\\\"\", name)),\n+\t\t\t})\n+\t\t}\n+\t\trv := reflect.New(reflect.StructOf(rfs)).Elem()\n+\t\tfor i, rf := range fs {\n+\t\t\tsetField(rv, i, rf.Value)\n+\t\t}\n+\n+\t\tgot, want = elem.Elm, rv.Interface()\n+\tdefault:\n+\t\tgot, want = elem.Elm, eg.Value\n+\t}\n+\tif d := cmp.Diff(want, got, cmpOpts...); d != \"\" {\n+\t\tlog.Printf(\"Decoding error: diff(-want,+got): %v\\n\", d)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+// standard_coders.yaml uses the name for type indication, except for nullability.\n+var nameToType = map[string]reflect.Type{\n+\t\"str\":     reflectx.String,\n+\t\"i32\":     reflectx.Int32,\n+\t\"f64\":     reflectx.Float64,\n+\t\"arr\":     reflect.SliceOf(reflectx.String),\n+\t\"f_bool\":  reflectx.Bool,\n+\t\"f_bytes\": reflect.PtrTo(reflectx.ByteSlice),\n+\t\"f_map\":   reflect.MapOf(reflectx.String, reflect.PtrTo(reflectx.Int64)),\n+}\n+\n+func setField(rv reflect.Value, i int, v interface{}) {\n+\tif v == nil {\n+\t\treturn\n+\t}\n+\trf := rv.Field(i)\n+\tif rf.Kind() == reflect.Ptr {\n+\t\t// Ensure it's initialized.\n+\t\trf.Set(reflect.New(rf.Type().Elem()))\n+\t\trf = rf.Elem()\n+\t}\n+\tswitch rf.Kind() {\n+\tcase reflect.String:\n+\t\trf.SetString(v.(string))\n+\tcase reflect.Int32:\n+\t\trf.SetInt(int64(v.(int)))\n+\tcase reflect.Float64:\n+\t\tc, err := strconv.ParseFloat(v.(string), 64)\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\trf.SetFloat(c)\n+\tcase reflect.Slice:\n+\t\tif rf.Type() == reflectx.ByteSlice {\n+\t\t\trf.Set(reflect.ValueOf([]byte(v.(string))))\n+\t\t\tbreak\n+\t\t}\n+\t\t// Value is a []interface{} with string values.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIyNzc3OQ==", "bodyText": "The yaml file exclusively uses lists of strings, which is why we know what type to interpret them as here.", "url": "https://github.com/apache/beam/pull/12588#discussion_r488227779", "createdAt": "2020-09-14T21:22:37Z", "author": {"login": "lostluck"}, "path": "sdks/go/test/regression/coders/fromyaml/fromyaml.go", "diffHunk": "@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// fromyaml generates a resource file from the standard_coders.yaml\n+// file for use in these coder regression tests.\n+//\n+// It expects to be run in it's test directory, or via it's go test.\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"math\"\n+\t\"reflect\"\n+\t\"runtime/debug\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/mtime\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/window\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"golang.org/x/text/encoding/charmap\"\n+\tyaml \"gopkg.in/yaml.v2\"\n+)\n+\n+var unimplementedCoders = map[string]bool{\n+\t\"beam:coder:param_windowed_value:v1\": true,\n+\t\"beam:coder:timer:v1\":                true,\n+}\n+\n+// Coder is a representation a serialized beam coder.\n+type Coder struct {\n+\tUrn              string  `yaml:\"urn,omitempty\"`\n+\tPayload          string  `yaml:\"payload,omitempty\"`\n+\tComponents       []Coder `yaml:\"components,omitempty\"`\n+\tNonDeterministic bool    `yaml:\"non_deterministic,omitempty\"`\n+}\n+\n+type logger interface {\n+\tErrorf(string, ...interface{})\n+\tLogf(string, ...interface{})\n+}\n+\n+// Spec is a set of conditions that a coder must pass.\n+type Spec struct {\n+\tCoder    Coder         `yaml:\"coder,omitempty\"`\n+\tNested   *bool         `yaml:\"nested,omitempty\"`\n+\tExamples yaml.MapSlice `yaml:\"examples,omitempty\"`\n+\tLog      logger\n+\n+\tid       int // for generating coder ids.\n+\tcoderPBs map[string]*pipepb.Coder\n+}\n+\n+func (s *Spec) nextID() string {\n+\tret := fmt.Sprintf(\"%d\", s.id)\n+\ts.id++\n+\treturn ret\n+}\n+\n+func (s *Spec) testStandardCoder() (err error) {\n+\tif unimplementedCoders[s.Coder.Urn] {\n+\t\tlog.Printf(\"skipping unimplemented coder urn: %v\", s.Coder.Urn)\n+\t\treturn nil\n+\t}\n+\t// Construct the coder proto equivalents.\n+\n+\t// Only nested tests need to be run, since nestedness is a pre-portability\n+\t// concept.\n+\t// For legacy Java reasons, the row coder examples are all marked nested: false\n+\t// so we need to check that before skipping unnested tests.\n+\tif s.Coder.Urn != \"beam:coder:row:v1\" && s.Nested != nil && !*s.Nested {\n+\t\tlog.Printf(\"skipping unnested coder spec: %v\\n\", s.Coder)\n+\t\treturn nil\n+\t}\n+\n+\ts.coderPBs = make(map[string]*pipepb.Coder)\n+\tid := s.parseCoder(s.Coder)\n+\tb := graphx.NewCoderUnmarshaller(s.coderPBs)\n+\tunderTest, err := b.Coder(id)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"unable to create coder: %v\", err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif e := recover(); e != nil {\n+\t\t\terr = fmt.Errorf(\"panicked on coder %v || %v:\\n\\t%v :\\n%s\", underTest, s.Coder, e, debug.Stack())\n+\t\t}\n+\t}()\n+\n+\tvar decFails, encFails int\n+\tfor _, eg := range s.Examples {\n+\n+\t\t// Test Decoding\n+\t\t// Ideally we'd use the beam package coders, but KVs make that complicated.\n+\t\t// This can be cleaned up once a type parametered beam.KV type exists.\n+\t\tdec := exec.MakeElementDecoder(underTest)\n+\t\tencoded := eg.Key.(string)\n+\t\tvar elem exec.FullValue\n+\n+\t\t// What I would have expected.\n+\t\t//\t\tr := charmap.ISO8859_1.NewDecoder().Reader(strings.NewReader(encoded))\n+\t\trecoded, err := charmap.ISO8859_1.NewEncoder().String(encoded)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tr := strings.NewReader(recoded)\n+\t\tif err := dec.DecodeTo(r, &elem); err != nil {\n+\t\t\treturn fmt.Errorf(\"err decoding %q: %v\", encoded, err)\n+\t\t}\n+\t\tif !diff(s.Coder, &elem, eg) {\n+\t\t\tdecFails++\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Test Encoding\n+\t\tif s.Coder.NonDeterministic {\n+\t\t\t// Skip verifying nondeterministic encodings.\n+\t\t\tcontinue\n+\t\t}\n+\t\tenc := exec.MakeElementEncoder(underTest)\n+\t\tvar out bytes.Buffer\n+\t\tif err := enc.Encode(&elem, &out); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif d := cmp.Diff(recoded, string(out.Bytes())); d != \"\" {\n+\t\t\tlog.Printf(\"Encoding error: diff(-want,+got): %v\\n\", d)\n+\t\t}\n+\t}\n+\tif decFails+encFails > 0 {\n+\t\treturn fmt.Errorf(\"failed to decode %v times, and encode %v times\", decFails, encFails)\n+\t}\n+\n+\treturn nil\n+}\n+\n+var cmpOpts = []cmp.Option{\n+\tcmp.Transformer(\"bytes2string\", func(in []byte) (out string) {\n+\t\treturn string(in)\n+\t}),\n+}\n+\n+func diff(c Coder, elem *exec.FullValue, eg yaml.MapItem) bool {\n+\tvar got, want interface{}\n+\tswitch c.Urn {\n+\tcase \"beam:coder:bytes:v1\":\n+\t\tgot = string(elem.Elm.([]byte))\n+\t\tswitch egv := eg.Value.(type) {\n+\t\tcase string:\n+\t\t\twant = egv\n+\t\tcase []byte:\n+\t\t\twant = string(egv)\n+\t\t}\n+\tcase \"beam:coder:varint:v1\":\n+\t\tgot, want = elem.Elm.(int64), int64(eg.Value.(int))\n+\tcase \"beam:coder:double:v1\":\n+\t\tgot = elem.Elm.(float64)\n+\t\tswitch v := eg.Value.(string); v {\n+\t\tcase \"NaN\":\n+\t\t\t// Do the NaN comparison here since NaN by definition != NaN.\n+\t\t\tif math.IsNaN(got.(float64)) {\n+\t\t\t\twant, got = 1, 1\n+\t\t\t} else {\n+\t\t\t\twant = math.NaN()\n+\t\t\t}\n+\t\tcase \"-Infinity\":\n+\t\t\twant = math.Inf(-1)\n+\t\tcase \"Infinity\":\n+\t\t\twant = math.Inf(1)\n+\t\tdefault:\n+\t\t\twant, _ = strconv.ParseFloat(v, 64)\n+\t\t}\n+\n+\tcase \"beam:coder:kv:v1\":\n+\t\tv := eg.Value.(yaml.MapSlice)\n+\t\tpass := true\n+\t\tif !diff(c.Components[0], &exec.FullValue{Elm: elem.Elm}, v[0]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\tif !diff(c.Components[1], &exec.FullValue{Elm: elem.Elm2}, v[1]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\treturn pass\n+\n+\tcase \"beam:coder:iterable:v1\":\n+\t\tpass := true\n+\t\tgotrv := reflect.ValueOf(elem.Elm)\n+\t\twantrv := reflect.ValueOf(eg.Value)\n+\t\tif gotrv.Len() != wantrv.Len() {\n+\t\t\tlog.Printf(\"Lengths don't match. got %v, want %v;  %v, %v\", gotrv.Len(), wantrv.Len(), gotrv, wantrv)\n+\t\t\treturn false\n+\t\t}\n+\t\tfor i := 0; i < wantrv.Len(); i++ {\n+\t\t\tif !diff(c.Components[0],\n+\t\t\t\t&exec.FullValue{Elm: gotrv.Index(i).Interface()},\n+\t\t\t\tyaml.MapItem{Value: wantrv.Index(i).Interface()}) {\n+\t\t\t\tpass = false\n+\t\t\t}\n+\n+\t\t}\n+\t\treturn pass\n+\tcase \"beam:coder:interval_window:v1\":\n+\t\tvar a, b int\n+\t\tval := eg.Value\n+\t\tif is, ok := eg.Value.([]interface{}); ok {\n+\t\t\tval = is[0]\n+\t\t}\n+\t\tv := val.(yaml.MapSlice)\n+\n+\t\ta = v[0].Value.(int)\n+\t\tb = v[1].Value.(int)\n+\t\tend := mtime.FromMilliseconds(int64(a))\n+\t\tstart := end - mtime.Time(int64(b))\n+\t\twant = window.IntervalWindow{Start: start, End: end}\n+\t\t// If this is nested in an iterable, windows won't be populated.\n+\t\tif len(elem.Windows) == 0 {\n+\t\t\tgot = elem.Elm\n+\t\t} else {\n+\t\t\tgot = elem.Windows[0]\n+\t\t}\n+\n+\tcase \"beam:coder:global_window:v1\":\n+\t\twant = window.GlobalWindow{}\n+\t\t// If this is nested in an iterable, windows won't be populated.\n+\t\tif len(elem.Windows) == 0 {\n+\t\t\tgot = window.GlobalWindow(elem.Elm.(struct{}))\n+\t\t} else {\n+\t\t\tgot = elem.Windows[0]\n+\t\t}\n+\tcase \"beam:coder:windowed_value:v1\", \"beam:coder:param_windowed_value:v1\":\n+\t\t// elem contains all the information, but we need to compare the element+timestamp\n+\t\t// separately from the windows, to avoid repeated expected value parsing logic.\n+\t\tpass := true\n+\t\tvs := eg.Value.(yaml.MapSlice)\n+\t\tif !diff(c.Components[0], elem, vs[0]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\tif d := cmp.Diff(\n+\t\t\tmtime.FromMilliseconds(int64(vs[1].Value.(int))),\n+\t\t\telem.Timestamp, cmpOpts...); d != \"\" {\n+\n+\t\t\tpass = false\n+\t\t}\n+\t\tif !diff(c.Components[1], elem, vs[3]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\t// TODO compare pane information.\n+\t\treturn pass\n+\tcase \"beam:coder:row:v1\":\n+\t\tfs := eg.Value.(yaml.MapSlice)\n+\t\tvar rfs []reflect.StructField\n+\t\t// There are only 2 pointer examples, but they reuse field names,\n+\t\t// so we key off the proto hash to know which example we're handling.\n+\t\tptrEg := strings.Contains(c.Payload, \"51ace21c7393\")\n+\t\tfor _, rf := range fs {\n+\t\t\tname := rf.Key.(string)\n+\t\t\tt := nameToType[name]\n+\t\t\tif ptrEg {\n+\t\t\t\tt = reflect.PtrTo(t)\n+\t\t\t}\n+\t\t\trfs = append(rfs, reflect.StructField{\n+\t\t\t\tName: strings.ToUpper(name[:1]) + name[1:],\n+\t\t\t\tType: t,\n+\t\t\t\tTag:  reflect.StructTag(fmt.Sprintf(\"beam:\\\"%v\\\"\", name)),\n+\t\t\t})\n+\t\t}\n+\t\trv := reflect.New(reflect.StructOf(rfs)).Elem()\n+\t\tfor i, rf := range fs {\n+\t\t\tsetField(rv, i, rf.Value)\n+\t\t}\n+\n+\t\tgot, want = elem.Elm, rv.Interface()\n+\tdefault:\n+\t\tgot, want = elem.Elm, eg.Value\n+\t}\n+\tif d := cmp.Diff(want, got, cmpOpts...); d != \"\" {\n+\t\tlog.Printf(\"Decoding error: diff(-want,+got): %v\\n\", d)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+// standard_coders.yaml uses the name for type indication, except for nullability.\n+var nameToType = map[string]reflect.Type{\n+\t\"str\":     reflectx.String,\n+\t\"i32\":     reflectx.Int32,\n+\t\"f64\":     reflectx.Float64,\n+\t\"arr\":     reflect.SliceOf(reflectx.String),\n+\t\"f_bool\":  reflectx.Bool,\n+\t\"f_bytes\": reflect.PtrTo(reflectx.ByteSlice),\n+\t\"f_map\":   reflect.MapOf(reflectx.String, reflect.PtrTo(reflectx.Int64)),\n+}\n+\n+func setField(rv reflect.Value, i int, v interface{}) {\n+\tif v == nil {\n+\t\treturn\n+\t}\n+\trf := rv.Field(i)\n+\tif rf.Kind() == reflect.Ptr {\n+\t\t// Ensure it's initialized.\n+\t\trf.Set(reflect.New(rf.Type().Elem()))\n+\t\trf = rf.Elem()\n+\t}\n+\tswitch rf.Kind() {\n+\tcase reflect.String:\n+\t\trf.SetString(v.(string))\n+\tcase reflect.Int32:\n+\t\trf.SetInt(int64(v.(int)))\n+\tcase reflect.Float64:\n+\t\tc, err := strconv.ParseFloat(v.(string), 64)\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\trf.SetFloat(c)\n+\tcase reflect.Slice:\n+\t\tif rf.Type() == reflectx.ByteSlice {\n+\t\t\trf.Set(reflect.ValueOf([]byte(v.(string))))\n+\t\t\tbreak\n+\t\t}\n+\t\t// Value is a []interface{} with string values.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDg0Mg=="}, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEzOTgxNA==", "bodyText": "Gotcha. It seems a little brittle (if the yaml file ever adds an example with a list of other types then this will break), so a comment mentioning that it's due to the contents of the yaml file would be helpful if that happens.", "url": "https://github.com/apache/beam/pull/12588#discussion_r489139814", "createdAt": "2020-09-16T03:30:10Z", "author": {"login": "youngoli"}, "path": "sdks/go/test/regression/coders/fromyaml/fromyaml.go", "diffHunk": "@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// fromyaml generates a resource file from the standard_coders.yaml\n+// file for use in these coder regression tests.\n+//\n+// It expects to be run in it's test directory, or via it's go test.\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"math\"\n+\t\"reflect\"\n+\t\"runtime/debug\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/mtime\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/window\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"golang.org/x/text/encoding/charmap\"\n+\tyaml \"gopkg.in/yaml.v2\"\n+)\n+\n+var unimplementedCoders = map[string]bool{\n+\t\"beam:coder:param_windowed_value:v1\": true,\n+\t\"beam:coder:timer:v1\":                true,\n+}\n+\n+// Coder is a representation a serialized beam coder.\n+type Coder struct {\n+\tUrn              string  `yaml:\"urn,omitempty\"`\n+\tPayload          string  `yaml:\"payload,omitempty\"`\n+\tComponents       []Coder `yaml:\"components,omitempty\"`\n+\tNonDeterministic bool    `yaml:\"non_deterministic,omitempty\"`\n+}\n+\n+type logger interface {\n+\tErrorf(string, ...interface{})\n+\tLogf(string, ...interface{})\n+}\n+\n+// Spec is a set of conditions that a coder must pass.\n+type Spec struct {\n+\tCoder    Coder         `yaml:\"coder,omitempty\"`\n+\tNested   *bool         `yaml:\"nested,omitempty\"`\n+\tExamples yaml.MapSlice `yaml:\"examples,omitempty\"`\n+\tLog      logger\n+\n+\tid       int // for generating coder ids.\n+\tcoderPBs map[string]*pipepb.Coder\n+}\n+\n+func (s *Spec) nextID() string {\n+\tret := fmt.Sprintf(\"%d\", s.id)\n+\ts.id++\n+\treturn ret\n+}\n+\n+func (s *Spec) testStandardCoder() (err error) {\n+\tif unimplementedCoders[s.Coder.Urn] {\n+\t\tlog.Printf(\"skipping unimplemented coder urn: %v\", s.Coder.Urn)\n+\t\treturn nil\n+\t}\n+\t// Construct the coder proto equivalents.\n+\n+\t// Only nested tests need to be run, since nestedness is a pre-portability\n+\t// concept.\n+\t// For legacy Java reasons, the row coder examples are all marked nested: false\n+\t// so we need to check that before skipping unnested tests.\n+\tif s.Coder.Urn != \"beam:coder:row:v1\" && s.Nested != nil && !*s.Nested {\n+\t\tlog.Printf(\"skipping unnested coder spec: %v\\n\", s.Coder)\n+\t\treturn nil\n+\t}\n+\n+\ts.coderPBs = make(map[string]*pipepb.Coder)\n+\tid := s.parseCoder(s.Coder)\n+\tb := graphx.NewCoderUnmarshaller(s.coderPBs)\n+\tunderTest, err := b.Coder(id)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"unable to create coder: %v\", err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif e := recover(); e != nil {\n+\t\t\terr = fmt.Errorf(\"panicked on coder %v || %v:\\n\\t%v :\\n%s\", underTest, s.Coder, e, debug.Stack())\n+\t\t}\n+\t}()\n+\n+\tvar decFails, encFails int\n+\tfor _, eg := range s.Examples {\n+\n+\t\t// Test Decoding\n+\t\t// Ideally we'd use the beam package coders, but KVs make that complicated.\n+\t\t// This can be cleaned up once a type parametered beam.KV type exists.\n+\t\tdec := exec.MakeElementDecoder(underTest)\n+\t\tencoded := eg.Key.(string)\n+\t\tvar elem exec.FullValue\n+\n+\t\t// What I would have expected.\n+\t\t//\t\tr := charmap.ISO8859_1.NewDecoder().Reader(strings.NewReader(encoded))\n+\t\trecoded, err := charmap.ISO8859_1.NewEncoder().String(encoded)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tr := strings.NewReader(recoded)\n+\t\tif err := dec.DecodeTo(r, &elem); err != nil {\n+\t\t\treturn fmt.Errorf(\"err decoding %q: %v\", encoded, err)\n+\t\t}\n+\t\tif !diff(s.Coder, &elem, eg) {\n+\t\t\tdecFails++\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Test Encoding\n+\t\tif s.Coder.NonDeterministic {\n+\t\t\t// Skip verifying nondeterministic encodings.\n+\t\t\tcontinue\n+\t\t}\n+\t\tenc := exec.MakeElementEncoder(underTest)\n+\t\tvar out bytes.Buffer\n+\t\tif err := enc.Encode(&elem, &out); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif d := cmp.Diff(recoded, string(out.Bytes())); d != \"\" {\n+\t\t\tlog.Printf(\"Encoding error: diff(-want,+got): %v\\n\", d)\n+\t\t}\n+\t}\n+\tif decFails+encFails > 0 {\n+\t\treturn fmt.Errorf(\"failed to decode %v times, and encode %v times\", decFails, encFails)\n+\t}\n+\n+\treturn nil\n+}\n+\n+var cmpOpts = []cmp.Option{\n+\tcmp.Transformer(\"bytes2string\", func(in []byte) (out string) {\n+\t\treturn string(in)\n+\t}),\n+}\n+\n+func diff(c Coder, elem *exec.FullValue, eg yaml.MapItem) bool {\n+\tvar got, want interface{}\n+\tswitch c.Urn {\n+\tcase \"beam:coder:bytes:v1\":\n+\t\tgot = string(elem.Elm.([]byte))\n+\t\tswitch egv := eg.Value.(type) {\n+\t\tcase string:\n+\t\t\twant = egv\n+\t\tcase []byte:\n+\t\t\twant = string(egv)\n+\t\t}\n+\tcase \"beam:coder:varint:v1\":\n+\t\tgot, want = elem.Elm.(int64), int64(eg.Value.(int))\n+\tcase \"beam:coder:double:v1\":\n+\t\tgot = elem.Elm.(float64)\n+\t\tswitch v := eg.Value.(string); v {\n+\t\tcase \"NaN\":\n+\t\t\t// Do the NaN comparison here since NaN by definition != NaN.\n+\t\t\tif math.IsNaN(got.(float64)) {\n+\t\t\t\twant, got = 1, 1\n+\t\t\t} else {\n+\t\t\t\twant = math.NaN()\n+\t\t\t}\n+\t\tcase \"-Infinity\":\n+\t\t\twant = math.Inf(-1)\n+\t\tcase \"Infinity\":\n+\t\t\twant = math.Inf(1)\n+\t\tdefault:\n+\t\t\twant, _ = strconv.ParseFloat(v, 64)\n+\t\t}\n+\n+\tcase \"beam:coder:kv:v1\":\n+\t\tv := eg.Value.(yaml.MapSlice)\n+\t\tpass := true\n+\t\tif !diff(c.Components[0], &exec.FullValue{Elm: elem.Elm}, v[0]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\tif !diff(c.Components[1], &exec.FullValue{Elm: elem.Elm2}, v[1]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\treturn pass\n+\n+\tcase \"beam:coder:iterable:v1\":\n+\t\tpass := true\n+\t\tgotrv := reflect.ValueOf(elem.Elm)\n+\t\twantrv := reflect.ValueOf(eg.Value)\n+\t\tif gotrv.Len() != wantrv.Len() {\n+\t\t\tlog.Printf(\"Lengths don't match. got %v, want %v;  %v, %v\", gotrv.Len(), wantrv.Len(), gotrv, wantrv)\n+\t\t\treturn false\n+\t\t}\n+\t\tfor i := 0; i < wantrv.Len(); i++ {\n+\t\t\tif !diff(c.Components[0],\n+\t\t\t\t&exec.FullValue{Elm: gotrv.Index(i).Interface()},\n+\t\t\t\tyaml.MapItem{Value: wantrv.Index(i).Interface()}) {\n+\t\t\t\tpass = false\n+\t\t\t}\n+\n+\t\t}\n+\t\treturn pass\n+\tcase \"beam:coder:interval_window:v1\":\n+\t\tvar a, b int\n+\t\tval := eg.Value\n+\t\tif is, ok := eg.Value.([]interface{}); ok {\n+\t\t\tval = is[0]\n+\t\t}\n+\t\tv := val.(yaml.MapSlice)\n+\n+\t\ta = v[0].Value.(int)\n+\t\tb = v[1].Value.(int)\n+\t\tend := mtime.FromMilliseconds(int64(a))\n+\t\tstart := end - mtime.Time(int64(b))\n+\t\twant = window.IntervalWindow{Start: start, End: end}\n+\t\t// If this is nested in an iterable, windows won't be populated.\n+\t\tif len(elem.Windows) == 0 {\n+\t\t\tgot = elem.Elm\n+\t\t} else {\n+\t\t\tgot = elem.Windows[0]\n+\t\t}\n+\n+\tcase \"beam:coder:global_window:v1\":\n+\t\twant = window.GlobalWindow{}\n+\t\t// If this is nested in an iterable, windows won't be populated.\n+\t\tif len(elem.Windows) == 0 {\n+\t\t\tgot = window.GlobalWindow(elem.Elm.(struct{}))\n+\t\t} else {\n+\t\t\tgot = elem.Windows[0]\n+\t\t}\n+\tcase \"beam:coder:windowed_value:v1\", \"beam:coder:param_windowed_value:v1\":\n+\t\t// elem contains all the information, but we need to compare the element+timestamp\n+\t\t// separately from the windows, to avoid repeated expected value parsing logic.\n+\t\tpass := true\n+\t\tvs := eg.Value.(yaml.MapSlice)\n+\t\tif !diff(c.Components[0], elem, vs[0]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\tif d := cmp.Diff(\n+\t\t\tmtime.FromMilliseconds(int64(vs[1].Value.(int))),\n+\t\t\telem.Timestamp, cmpOpts...); d != \"\" {\n+\n+\t\t\tpass = false\n+\t\t}\n+\t\tif !diff(c.Components[1], elem, vs[3]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\t// TODO compare pane information.\n+\t\treturn pass\n+\tcase \"beam:coder:row:v1\":\n+\t\tfs := eg.Value.(yaml.MapSlice)\n+\t\tvar rfs []reflect.StructField\n+\t\t// There are only 2 pointer examples, but they reuse field names,\n+\t\t// so we key off the proto hash to know which example we're handling.\n+\t\tptrEg := strings.Contains(c.Payload, \"51ace21c7393\")\n+\t\tfor _, rf := range fs {\n+\t\t\tname := rf.Key.(string)\n+\t\t\tt := nameToType[name]\n+\t\t\tif ptrEg {\n+\t\t\t\tt = reflect.PtrTo(t)\n+\t\t\t}\n+\t\t\trfs = append(rfs, reflect.StructField{\n+\t\t\t\tName: strings.ToUpper(name[:1]) + name[1:],\n+\t\t\t\tType: t,\n+\t\t\t\tTag:  reflect.StructTag(fmt.Sprintf(\"beam:\\\"%v\\\"\", name)),\n+\t\t\t})\n+\t\t}\n+\t\trv := reflect.New(reflect.StructOf(rfs)).Elem()\n+\t\tfor i, rf := range fs {\n+\t\t\tsetField(rv, i, rf.Value)\n+\t\t}\n+\n+\t\tgot, want = elem.Elm, rv.Interface()\n+\tdefault:\n+\t\tgot, want = elem.Elm, eg.Value\n+\t}\n+\tif d := cmp.Diff(want, got, cmpOpts...); d != \"\" {\n+\t\tlog.Printf(\"Decoding error: diff(-want,+got): %v\\n\", d)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+// standard_coders.yaml uses the name for type indication, except for nullability.\n+var nameToType = map[string]reflect.Type{\n+\t\"str\":     reflectx.String,\n+\t\"i32\":     reflectx.Int32,\n+\t\"f64\":     reflectx.Float64,\n+\t\"arr\":     reflect.SliceOf(reflectx.String),\n+\t\"f_bool\":  reflectx.Bool,\n+\t\"f_bytes\": reflect.PtrTo(reflectx.ByteSlice),\n+\t\"f_map\":   reflect.MapOf(reflectx.String, reflect.PtrTo(reflectx.Int64)),\n+}\n+\n+func setField(rv reflect.Value, i int, v interface{}) {\n+\tif v == nil {\n+\t\treturn\n+\t}\n+\trf := rv.Field(i)\n+\tif rf.Kind() == reflect.Ptr {\n+\t\t// Ensure it's initialized.\n+\t\trf.Set(reflect.New(rf.Type().Elem()))\n+\t\trf = rf.Elem()\n+\t}\n+\tswitch rf.Kind() {\n+\tcase reflect.String:\n+\t\trf.SetString(v.(string))\n+\tcase reflect.Int32:\n+\t\trf.SetInt(int64(v.(int)))\n+\tcase reflect.Float64:\n+\t\tc, err := strconv.ParseFloat(v.(string), 64)\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\trf.SetFloat(c)\n+\tcase reflect.Slice:\n+\t\tif rf.Type() == reflectx.ByteSlice {\n+\t\t\trf.Set(reflect.ValueOf([]byte(v.(string))))\n+\t\t\tbreak\n+\t\t}\n+\t\t// Value is a []interface{} with string values.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDg0Mg=="}, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 338}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 705, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}