{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5MDM3NTU2", "number": 10949, "title": "[BEAM-9371] Add SideInputLoadTest to Java SDK", "bodyText": "Thank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-02-24T15:02:17Z", "url": "https://github.com/apache/beam/pull/10949", "merged": true, "mergeCommit": {"oid": "88c7aa25f874f885b5af66c462d2e5fc34519b62"}, "closed": true, "closedAt": "2020-03-26T07:11:55Z", "author": {"login": "mwalenia"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHe3wIAH2gAyMzc5MDM3NTU2OmJlZmJkMjM2MWZiZGYyNmU0OTVlZWI0NDBmOWZmZmRkOTNjYjkyOGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRMRolgFqTM4MTQ1MDAyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "befbd2361fbdf26e495eeb440f9fffdd93cb928c", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/befbd2361fbdf26e495eeb440f9fffdd93cb928c", "committedDate": "2020-02-24T15:01:36Z", "message": "[BEAM-9731] Add SideInputLoadTest implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cec849858f313c81c3332650a810b2e401fbed8", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/6cec849858f313c81c3332650a810b2e401fbed8", "committedDate": "2020-02-24T16:20:47Z", "message": "Fix spotbugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/0cc55d5151584ca6c5aa1e2fb0249eab543657e3", "committedDate": "2020-02-25T07:51:42Z", "message": "Fix code style error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MjUzMTEy", "url": "https://github.com/apache/beam/pull/10949#pullrequestreview-367253112", "createdAt": "2020-03-02T14:46:04Z", "commit": {"oid": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNDo0NjowNFrOFwiF4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNDo0NjowNFrOFwiF4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQzNDUyOA==", "bodyText": "Is there a specific reason we do windowing only for iterable case?", "url": "https://github.com/apache/beam/pull/10949#discussion_r386434528", "createdAt": "2020-03-02T14:46:04Z", "author": {"login": "Ardagan"}, "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjM1OTc5", "url": "https://github.com/apache/beam/pull/10949#pullrequestreview-367635979", "createdAt": "2020-03-03T00:55:01Z", "commit": {"oid": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDo1NTowMVrOFw0xpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMToxMjowNlrOFw1Fjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MDY0NA==", "bodyText": "What are the metrics? Should they be described in the Javadoc? I read the superclass and did not see much explanation there either.\nThe code here makes OK sense but is not enough information to use it. So I am just wondering what the experience is for someone who wants to use the class to build a new load test.", "url": "https://github.com/apache/beam/pull/10949#discussion_r386740644", "createdAt": "2020-03-03T00:55:01Z", "author": {"login": "kennknowles"}, "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzMwMA==", "bodyText": "I just noticed runtimeMonitor is a protected field. It seems there are actually a few, and you have built enough on top that it may be getting hard to change. But even though I am late, I offer a suggestion for refactor: make LoadTest parameterized instead of a base class.\nEach subclass of LoadTest is really just the main loadTest function and really that function is about the same as writing a PTransform. If you eliminate subclassing you can have LoadTest own the pipeline setup with so it will never be possible to forget or mess up readSourceFromOptions and ParDo.of(runtimeMonitor). It will be less repeat boilerplate. Also you won't have to reference variables defined in another file as protected fields.", "url": "https://github.com/apache/beam/pull/10949#discussion_r386743300", "createdAt": "2020-03-03T01:04:08Z", "author": {"login": "kennknowles"}, "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();\n+      sideInput =\n+          input\n+              .apply(Window.into(FixedWindows.of(Duration.millis(windowDurationMilis))))\n+              .apply(View.asIterable());\n+    } else {\n+      sideInput = input.apply(View.asIterable());\n+    }\n+\n+    input\n+        .apply(ParDo.of(new SideInputTestWithIterable(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzY2OQ==", "bodyText": "This tests Map, not HashMap. The runner (or SDK harness in portability) can choose whatever kind of Map it wants.", "url": "https://github.com/apache/beam/pull/10949#discussion_r386743669", "createdAt": "2020-03-03T01:05:31Z", "author": {"login": "kennknowles"}, "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();\n+      sideInput =\n+          input\n+              .apply(Window.into(FixedWindows.of(Duration.millis(windowDurationMilis))))\n+              .apply(View.asIterable());\n+    } else {\n+      sideInput = input.apply(View.asIterable());\n+    }\n+\n+    input\n+        .apply(ParDo.of(new SideInputTestWithIterable(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private static class AddTimestamps extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+    private static Instant timestamp = TIME;\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      timestamp = TIME.plus(1L);\n+      c.outputWithTimestamp(c.element(), timestamp);\n+    }\n+  }\n+\n+  private static class SideInputTestWithList extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<List<KV<byte[], byte[]>>> sideInput;\n+\n+    public SideInputTestWithList(PCollectionView<List<KV<byte[], byte[]>>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      List<KV<byte[], byte[]>> si = c.sideInput(sideInput);\n+\n+      for (KV<byte[], byte[]> sideInputElement : si) {\n+        // for every _input_ element iterate over all _sideInput_ elements\n+        // count consumed bytes, examine memory usage, etc (Metrics API).\n+        byte[] key = sideInputElement.getKey();\n+      }\n+    }\n+  }\n+\n+  private class SideInputTestWithHashMap extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NDg0OA==", "bodyText": "It is worth documenting that the whole point of View.asList is to force it all to be read into memory so it is fast to iterate multiple times or access a given index. You could test these, too. If you don't need either of those, then View.asIterable will access lazily so it will often perform better and scale larger.", "url": "https://github.com/apache/beam/pull/10949#discussion_r386744848", "createdAt": "2020-03-03T01:09:11Z", "author": {"login": "kennknowles"}, "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();\n+      sideInput =\n+          input\n+              .apply(Window.into(FixedWindows.of(Duration.millis(windowDurationMilis))))\n+              .apply(View.asIterable());\n+    } else {\n+      sideInput = input.apply(View.asIterable());\n+    }\n+\n+    input\n+        .apply(ParDo.of(new SideInputTestWithIterable(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private static class AddTimestamps extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+    private static Instant timestamp = TIME;\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      timestamp = TIME.plus(1L);\n+      c.outputWithTimestamp(c.element(), timestamp);\n+    }\n+  }\n+\n+  private static class SideInputTestWithList extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<List<KV<byte[], byte[]>>> sideInput;\n+\n+    public SideInputTestWithList(PCollectionView<List<KV<byte[], byte[]>>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      List<KV<byte[], byte[]>> si = c.sideInput(sideInput);\n+\n+      for (KV<byte[], byte[]> sideInputElement : si) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTI3MA==", "bodyText": "For View.asIterable it makes the most sense to scan a random distance into the iterable. The most important use case is when you cannot read it all into a list, I think. Both cases are interesting: reading the whole iterable and reading just a prefix.", "url": "https://github.com/apache/beam/pull/10949#discussion_r386745270", "createdAt": "2020-03-03T01:10:45Z", "author": {"login": "kennknowles"}, "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();\n+      sideInput =\n+          input\n+              .apply(Window.into(FixedWindows.of(Duration.millis(windowDurationMilis))))\n+              .apply(View.asIterable());\n+    } else {\n+      sideInput = input.apply(View.asIterable());\n+    }\n+\n+    input\n+        .apply(ParDo.of(new SideInputTestWithIterable(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private static class AddTimestamps extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+    private static Instant timestamp = TIME;\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      timestamp = TIME.plus(1L);\n+      c.outputWithTimestamp(c.element(), timestamp);\n+    }\n+  }\n+\n+  private static class SideInputTestWithList extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<List<KV<byte[], byte[]>>> sideInput;\n+\n+    public SideInputTestWithList(PCollectionView<List<KV<byte[], byte[]>>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      List<KV<byte[], byte[]>> si = c.sideInput(sideInput);\n+\n+      for (KV<byte[], byte[]> sideInputElement : si) {\n+        // for every _input_ element iterate over all _sideInput_ elements\n+        // count consumed bytes, examine memory usage, etc (Metrics API).\n+        byte[] key = sideInputElement.getKey();\n+      }\n+    }\n+  }\n+\n+  private class SideInputTestWithHashMap extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<Map<byte[], byte[]>> sideInput;\n+\n+    public SideInputTestWithHashMap(PCollectionView<Map<byte[], byte[]>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      Map<byte[], byte[]> si = c.sideInput(sideInput);\n+      // access Map elements according to options - % of random access\n+      ArrayList<byte[]> keyList = new ArrayList<>(si.keySet());\n+      int size = keyList.size();\n+      int elementCount = size / options.getAccessPercentage() * 100;\n+      Random gen = new Random();\n+      for (int i = 0; i < elementCount; i++) {\n+        byte[] value = si.get(keyList.get(gen.nextInt(elementCount)));\n+      }\n+    }\n+  }\n+\n+  private class SideInputTestWithIterable extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+\n+    public SideInputTestWithIterable(PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      Iterable<KV<byte[], byte[]>> si = c.sideInput(sideInput);\n+      Integer accessPercentage = options.getAccessPercentage();\n+      int elementCount = (int) (sourceOptions.numRecords * accessPercentage / 100);\n+      for (KV<byte[], byte[]> sideInputElement : si) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTc0Mg==", "bodyText": "This part doesn't work well at high scale for some map implementations. An important use case is accessing just some keys and not others. A runner/SDK may have a separate place where they write the keySet so that you can make this call efficiently. But they may not. We don't want to make this test so sensitive to that (you could separate test efficiency of keySet). Can you calculate random keys in advance based on sourceOptions?", "url": "https://github.com/apache/beam/pull/10949#discussion_r386745742", "createdAt": "2020-03-03T01:12:06Z", "author": {"login": "kennknowles"}, "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();\n+      sideInput =\n+          input\n+              .apply(Window.into(FixedWindows.of(Duration.millis(windowDurationMilis))))\n+              .apply(View.asIterable());\n+    } else {\n+      sideInput = input.apply(View.asIterable());\n+    }\n+\n+    input\n+        .apply(ParDo.of(new SideInputTestWithIterable(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private static class AddTimestamps extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+    private static Instant timestamp = TIME;\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      timestamp = TIME.plus(1L);\n+      c.outputWithTimestamp(c.element(), timestamp);\n+    }\n+  }\n+\n+  private static class SideInputTestWithList extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<List<KV<byte[], byte[]>>> sideInput;\n+\n+    public SideInputTestWithList(PCollectionView<List<KV<byte[], byte[]>>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      List<KV<byte[], byte[]>> si = c.sideInput(sideInput);\n+\n+      for (KV<byte[], byte[]> sideInputElement : si) {\n+        // for every _input_ element iterate over all _sideInput_ elements\n+        // count consumed bytes, examine memory usage, etc (Metrics API).\n+        byte[] key = sideInputElement.getKey();\n+      }\n+    }\n+  }\n+\n+  private class SideInputTestWithHashMap extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<Map<byte[], byte[]>> sideInput;\n+\n+    public SideInputTestWithHashMap(PCollectionView<Map<byte[], byte[]>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      Map<byte[], byte[]> si = c.sideInput(sideInput);\n+      // access Map elements according to options - % of random access\n+      ArrayList<byte[]> keyList = new ArrayList<>(si.keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3"}, "originalPosition": 179}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "952392ed25f9e14309b3a49bab9468bb262d69ae", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/952392ed25f9e14309b3a49bab9468bb262d69ae", "committedDate": "2020-03-05T14:12:54Z", "message": "Add windowing to all cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cb172d19c9b76bc83f745bd72680dc4b152bb87", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/1cb172d19c9b76bc83f745bd72680dc4b152bb87", "committedDate": "2020-03-10T08:20:30Z", "message": "Make code spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c8b51195808db5c934d32dd385aa3b61129b08b", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/8c8b51195808db5c934d32dd385aa3b61129b08b", "committedDate": "2020-03-12T15:26:47Z", "message": "Calculate random keys in advance"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eaff6739ad8c717c43422803a32df8be8b83f093", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/eaff6739ad8c717c43422803a32df8be8b83f093", "committedDate": "2020-03-12T15:26:11Z", "message": "Calculate random keys in advance"}, "afterCommit": {"oid": "8c8b51195808db5c934d32dd385aa3b61129b08b", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/8c8b51195808db5c934d32dd385aa3b61129b08b", "committedDate": "2020-03-12T15:26:47Z", "message": "Calculate random keys in advance"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNDUwMDIx", "url": "https://github.com/apache/beam/pull/10949#pullrequestreview-381450021", "createdAt": "2020-03-25T19:00:55Z", "commit": {"oid": "8c8b51195808db5c934d32dd385aa3b61129b08b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2887, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}