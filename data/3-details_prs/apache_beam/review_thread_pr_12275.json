{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5ODY4MzU0", "number": 12275, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzozMToxMlrOEPngIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNjoxNlrOEPoxBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODExMjk5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/iobase.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzozMToxMlrOGzbVHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMToyMzoyMlrOGzhkdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3ODMzNA==", "bodyText": "You may also want to check self._fraction is not None.", "url": "https://github.com/apache/beam/pull/12275#discussion_r456578334", "createdAt": "2020-07-17T17:31:12Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1301,18 +1302,22 @@ def __repr__(self):\n   @property\n   def completed_work(self):\n     # type: () -> float\n-    if self._completed:\n+    if self._completed is not None:\n       return self._completed\n-    elif self._remaining and self._fraction:\n+    elif self._remaining is not None and self._fraction:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "177ad396e9df13906c219b59851c2e77d3c427d9"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4MDU2NA==", "bodyText": "Fixed", "url": "https://github.com/apache/beam/pull/12275#discussion_r456680564", "createdAt": "2020-07-17T21:23:22Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1301,18 +1302,22 @@ def __repr__(self):\n   @property\n   def completed_work(self):\n     # type: () -> float\n-    if self._completed:\n+    if self._completed is not None:\n       return self._completed\n-    elif self._remaining and self._fraction:\n+    elif self._remaining is not None and self._fraction:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3ODMzNA=="}, "originalCommit": {"oid": "177ad396e9df13906c219b59851c2e77d3c427d9"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODE3MDUxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/iobase.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo0ODo1NlrOGzb3ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMToxODo0OFrOGzhecg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4NzE2Ng==", "bodyText": "Same above.", "url": "https://github.com/apache/beam/pull/12275#discussion_r456587166", "createdAt": "2020-07-17T17:48:56Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1301,18 +1302,22 @@ def __repr__(self):\n   @property\n   def completed_work(self):\n     # type: () -> float\n-    if self._completed:\n+    if self._completed is not None:\n       return self._completed\n-    elif self._remaining and self._fraction:\n+    elif self._remaining is not None and self._fraction:\n       return self._remaining * self._fraction / (1 - self._fraction)\n+    else:\n+      return self._fraction\n \n   @property\n   def remaining_work(self):\n     # type: () -> float\n-    if self._remaining:\n+    if self._remaining is not None:\n       return self._remaining\n-    elif self._completed:\n+    elif self._completed is not None and self._fraction:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "177ad396e9df13906c219b59851c2e77d3c427d9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3OTAyNg==", "bodyText": "This one needs to also check whether self._fraction is not 0 otherwise we would divide by zero here.", "url": "https://github.com/apache/beam/pull/12275#discussion_r456679026", "createdAt": "2020-07-17T21:18:48Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1301,18 +1302,22 @@ def __repr__(self):\n   @property\n   def completed_work(self):\n     # type: () -> float\n-    if self._completed:\n+    if self._completed is not None:\n       return self._completed\n-    elif self._remaining and self._fraction:\n+    elif self._remaining is not None and self._fraction:\n       return self._remaining * self._fraction / (1 - self._fraction)\n+    else:\n+      return self._fraction\n \n   @property\n   def remaining_work(self):\n     # type: () -> float\n-    if self._remaining:\n+    if self._remaining is not None:\n       return self._remaining\n-    elif self._completed:\n+    elif self._completed is not None and self._fraction:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4NzE2Ng=="}, "originalCommit": {"oid": "177ad396e9df13906c219b59851c2e77d3c427d9"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODIzNDMxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/common.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODowODowMFrOGzcedg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMToxOToxNFrOGzhe_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5NzExMA==", "bodyText": "len(windowed_value.windows) > 1 ?", "url": "https://github.com/apache/beam/pull/12275#discussion_r456597110", "createdAt": "2020-07-17T18:08:00Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/runners/common.py", "diffHunk": "@@ -685,46 +689,40 @@ def invoke_process(self,\n     # or if the process accesses the window parameter. We can just call it once\n     # otherwise as none of the arguments are changing\n \n+    residuals = []\n     if self.is_splittable:\n-      restriction_tracker = self.invoke_create_tracker(restriction)\n-      watermark_estimator = self.invoke_create_watermark_estimator(\n-          watermark_estimator_state)\n-\n-      if len(windowed_value.windows) > 1 and self.has_windowed_inputs:\n-        # Should never get here due to window explosion in\n-        # the upstream pair-with-restriction.\n-        raise NotImplementedError(\n-            'SDFs in multiply-windowed values with windowed arguments.')\n       with self.splitting_lock:\n-        self.threadsafe_restriction_tracker = ThreadsafeRestrictionTracker(\n-            restriction_tracker)\n         self.current_windowed_value = windowed_value\n-        self.threadsafe_watermark_estimator = (\n-            ThreadsafeWatermarkEstimator(watermark_estimator))\n-\n-      restriction_tracker_param = (\n-          self.signature.process_method.restriction_provider_arg_name)\n-      if not restriction_tracker_param:\n-        raise ValueError(\n-            'DoFn is splittable but DoFn does not have a '\n-            'RestrictionTrackerParam defined')\n-      additional_kwargs[restriction_tracker_param] = (\n-          RestrictionTrackerView(self.threadsafe_restriction_tracker))\n-      watermark_param = (\n-          self.signature.process_method.watermark_estimator_provider_arg_name)\n-      # When the watermark_estimator is a NoOpWatermarkEstimator, the system\n-      # will not add watermark_param into the DoFn param list.\n-      if watermark_param is not None:\n-        additional_kwargs[watermark_param] = self.threadsafe_watermark_estimator\n+        self.restriction = restriction\n+        self.watermark_estimator_state = watermark_estimator_state\n       try:\n-        return self._invoke_process_per_window(\n-            windowed_value, additional_args, additional_kwargs)\n+        if self.has_windowed_inputs and len(windowed_value.windows) != 1:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "177ad396e9df13906c219b59851c2e77d3c427d9"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3OTE2Nw==", "bodyText": "It seems like we shouldn't produce any outputs if we are in 0 windows but your recommendation makes sense.\nFixed.", "url": "https://github.com/apache/beam/pull/12275#discussion_r456679167", "createdAt": "2020-07-17T21:19:14Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/common.py", "diffHunk": "@@ -685,46 +689,40 @@ def invoke_process(self,\n     # or if the process accesses the window parameter. We can just call it once\n     # otherwise as none of the arguments are changing\n \n+    residuals = []\n     if self.is_splittable:\n-      restriction_tracker = self.invoke_create_tracker(restriction)\n-      watermark_estimator = self.invoke_create_watermark_estimator(\n-          watermark_estimator_state)\n-\n-      if len(windowed_value.windows) > 1 and self.has_windowed_inputs:\n-        # Should never get here due to window explosion in\n-        # the upstream pair-with-restriction.\n-        raise NotImplementedError(\n-            'SDFs in multiply-windowed values with windowed arguments.')\n       with self.splitting_lock:\n-        self.threadsafe_restriction_tracker = ThreadsafeRestrictionTracker(\n-            restriction_tracker)\n         self.current_windowed_value = windowed_value\n-        self.threadsafe_watermark_estimator = (\n-            ThreadsafeWatermarkEstimator(watermark_estimator))\n-\n-      restriction_tracker_param = (\n-          self.signature.process_method.restriction_provider_arg_name)\n-      if not restriction_tracker_param:\n-        raise ValueError(\n-            'DoFn is splittable but DoFn does not have a '\n-            'RestrictionTrackerParam defined')\n-      additional_kwargs[restriction_tracker_param] = (\n-          RestrictionTrackerView(self.threadsafe_restriction_tracker))\n-      watermark_param = (\n-          self.signature.process_method.watermark_estimator_provider_arg_name)\n-      # When the watermark_estimator is a NoOpWatermarkEstimator, the system\n-      # will not add watermark_param into the DoFn param list.\n-      if watermark_param is not None:\n-        additional_kwargs[watermark_param] = self.threadsafe_watermark_estimator\n+        self.restriction = restriction\n+        self.watermark_estimator_state = watermark_estimator_state\n       try:\n-        return self._invoke_process_per_window(\n-            windowed_value, additional_args, additional_kwargs)\n+        if self.has_windowed_inputs and len(windowed_value.windows) != 1:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5NzExMA=="}, "originalCommit": {"oid": "177ad396e9df13906c219b59851c2e77d3c427d9"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODI2MjQ3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/common.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODoxNzozNVrOGzcv1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMTozMDozMlrOGzhtFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYwMTU1OA==", "bodyText": "Would it be better to check whether False should be returned first then create restriction_tracker and watermark_estimator?\nAnd the function itself looks kind of ambiguous to me. The function is used no matter whether the window is observed to prepare the params for processing sdf. Is it possible to separate the check and creating params part?", "url": "https://github.com/apache/beam/pull/12275#discussion_r456601558", "createdAt": "2020-07-17T18:17:35Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/runners/common.py", "diffHunk": "@@ -735,7 +733,44 @@ def invoke_process(self,\n     else:\n       self._invoke_process_per_window(\n           windowed_value, additional_args, additional_kwargs)\n-    return None\n+    return residuals\n+\n+  def _should_process_window_for_sdf(\n+      self,\n+      windowed_value, # type: WindowedValue\n+      additional_kwargs,\n+      window_index=None, # type: Optional[int]\n+  ):\n+    restriction_tracker = self.invoke_create_tracker(self.restriction)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "177ad396e9df13906c219b59851c2e77d3c427d9"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4Mjc3Mw==", "bodyText": "I don't want to hold the splitting lock while the user methods are being invoked.", "url": "https://github.com/apache/beam/pull/12275#discussion_r456682773", "createdAt": "2020-07-17T21:30:32Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/common.py", "diffHunk": "@@ -735,7 +733,44 @@ def invoke_process(self,\n     else:\n       self._invoke_process_per_window(\n           windowed_value, additional_args, additional_kwargs)\n-    return None\n+    return residuals\n+\n+  def _should_process_window_for_sdf(\n+      self,\n+      windowed_value, # type: WindowedValue\n+      additional_kwargs,\n+      window_index=None, # type: Optional[int]\n+  ):\n+    restriction_tracker = self.invoke_create_tracker(self.restriction)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYwMTU1OA=="}, "originalCommit": {"oid": "177ad396e9df13906c219b59851c2e77d3c427d9"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODMyMDA0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/common.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNjoxNlrOGzdTFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMToyNDo0NVrOGzhmMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMDU4MQ==", "bodyText": "Can we add a comment here to explain why stop_window should not be None?", "url": "https://github.com/apache/beam/pull/12275#discussion_r456610581", "createdAt": "2020-07-17T18:36:16Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/runners/common.py", "diffHunk": "@@ -845,52 +880,241 @@ def _invoke_process_per_window(self,\n             deferred_timestamp=deferred_timestamp)\n     return None\n \n+  @staticmethod\n+  def _try_split(fraction,\n+      window_index, # type: Optional[int]\n+      stop_window_index, # type: Optional[int]\n+      windowed_value, # type: WindowedValue\n+      restriction,\n+      watermark_estimator_state,\n+      restriction_provider, # type: RestrictionProvider\n+      restriction_tracker, # type: RestrictionTracker\n+      watermark_estimator, # type: WatermarkEstimator\n+                 ):\n+    # type: (...) -> Optional[Tuple[Iterable[SplitResultPrimary], Iterable[SplitResultResidual], Optional[int]]]\n+\n+    \"\"\"Try to split returning a primaries, residuals and a new stop index.\n+\n+    For non-window observing splittable DoFns we split the current restriction\n+    and assign the primary and residual to all the windows.\n+\n+    For window observing splittable DoFns, we:\n+    1) return a split at a window boundary if the fraction lies outside of the\n+       current window.\n+    2) attempt to split the current restriction, if successful then return\n+       the primary and residual for the current window and an additional\n+       primary and residual for any fully processed and fully unprocessed\n+       windows.\n+    3) fall back to returning a split at the window boundary if possible\n+\n+    Args:\n+      window_index: the current index of the window being processed or None\n+                    if the splittable DoFn is not window observing.\n+      stop_window_index: the current index to stop processing at or None\n+                         if the splittable DoFn is not window observing.\n+      windowed_value: the current windowed value\n+      restriction: the initial restriction when processing was started.\n+      watermark_estimator_state: the initial watermark estimator state when\n+                                 processing was started.\n+      restriction_provider: the DoFn's restriction provider\n+      restriction_tracker: the current restriction tracker\n+      watermark_estimator: the current watermark estimator\n+\n+    Returns:\n+      A tuple containing (primaries, residuals, new_stop_index) or None if\n+      splitting was not possible. new_stop_index will only be set if the\n+      splittable DoFn is window observing otherwise it will be None.\n+    \"\"\"\n+    def compute_whole_window_split(to_index, from_index):\n+      restriction_size = restriction_provider.restriction_size(\n+          windowed_value, restriction)\n+      # The primary and residual both share the same value only differing\n+      # by the set of windows they are in.\n+      value = ((windowed_value.value, (restriction, watermark_estimator_state)),\n+               restriction_size)\n+      primary_restriction = SplitResultPrimary(\n+          primary_value=WindowedValue(\n+              value,\n+              windowed_value.timestamp,\n+              windowed_value.windows[:to_index])) if to_index > 0 else None\n+      # Don't report any updated watermarks for the residual since they have\n+      # not processed any part of the restriction.\n+      residual_restriction = SplitResultResidual(\n+          residual_value=WindowedValue(\n+              value,\n+              windowed_value.timestamp,\n+              windowed_value.windows[from_index:stop_window_index]),\n+          current_watermark=None,\n+          deferred_timestamp=None) if from_index < stop_window_index else None\n+      return (primary_restriction, residual_restriction)\n+\n+    primary_restrictions = []\n+    residual_restrictions = []\n+\n+    window_observing = window_index is not None\n+    # If we are processing each window separately and we aren't on the last\n+    # window then compute whether the split lies within the current window\n+    # or a future window.\n+    if window_observing and window_index != stop_window_index - 1:\n+      progress = restriction_tracker.current_progress()\n+      if not progress:\n+        # Assume no work has been completed for the current window if progress\n+        # is unavailable.\n+        from apache_beam.io.iobase import RestrictionProgress\n+        progress = RestrictionProgress(completed=0, remaining=1)\n+\n+      scaled_progress = PerWindowInvoker._scale_progress(\n+          progress, window_index, stop_window_index)\n+      # Compute the fraction of the remainder relative to the scaled progress.\n+      # If the value is greater than or equal to progress.remaining_work then we\n+      # should split at the closest window boundary.\n+      fraction_of_remainder = scaled_progress.remaining_work * fraction\n+      if fraction_of_remainder >= progress.remaining_work:\n+        # The fraction is outside of the current window and hence we will\n+        # split at the closest window boundary. Favor a split and return the\n+        # last window if we would have rounded up to the end of the window\n+        # based upon the fraction.\n+        new_stop_window_index = min(\n+            stop_window_index - 1,\n+            window_index + max(\n+                1,\n+                int(\n+                    round((\n+                        progress.completed_work +\n+                        scaled_progress.remaining_work * fraction) /\n+                          progress.total_work))))\n+        primary, residual = compute_whole_window_split(\n+            new_stop_window_index, new_stop_window_index)\n+        assert primary is not None\n+        assert residual is not None\n+        return ([primary], [residual], new_stop_window_index)\n+      else:\n+        # The fraction is within the current window being processed so compute\n+        # the updated fraction based upon the number of windows being processed.\n+        new_stop_window_index = window_index + 1\n+        fraction = fraction_of_remainder / progress.remaining_work\n+        # Attempt to split below, if we can't then we'll compute a split\n+        # using only window boundaries\n+    else:\n+      # We aren't splitting within multiple windows so we don't change our\n+      # stop index.\n+      new_stop_window_index = stop_window_index\n+\n+    # Temporary workaround for [BEAM-7473]: get current_watermark before\n+    # split, in case watermark gets advanced before getting split results.\n+    # In worst case, current_watermark is always stale, which is ok.\n+    current_watermark = (watermark_estimator.current_watermark())\n+    current_estimator_state = (watermark_estimator.get_estimator_state())\n+    split = restriction_tracker.try_split(fraction)\n+    if split:\n+      primary, residual = split\n+      element = windowed_value.value\n+      primary_size = restriction_provider.restriction_size(\n+          windowed_value.value, primary)\n+      residual_size = restriction_provider.restriction_size(\n+          windowed_value.value, residual)\n+      # We use the watermark estimator state for the original process call\n+      # for the primary and the updated watermark estimator state for the\n+      # residual for the split.\n+      primary_split_value = ((element, (primary, watermark_estimator_state)),\n+                             primary_size)\n+      residual_split_value = ((element, (residual, current_estimator_state)),\n+                              residual_size)\n+      windows = (\n+          windowed_value.windows[window_index],\n+      ) if window_observing else windowed_value.windows\n+      primary_restrictions.append(\n+          SplitResultPrimary(\n+              primary_value=WindowedValue(\n+                  primary_split_value, windowed_value.timestamp, windows)))\n+      residual_restrictions.append(\n+          SplitResultResidual(\n+              residual_value=WindowedValue(\n+                  residual_split_value, windowed_value.timestamp, windows),\n+              current_watermark=current_watermark,\n+              deferred_timestamp=None))\n+\n+      if window_observing:\n+        assert new_stop_window_index == window_index + 1\n+        primary, residual = compute_whole_window_split(\n+            window_index, window_index + 1)\n+        if primary:\n+          primary_restrictions.append(primary)\n+        if residual:\n+          residual_restrictions.append(residual)\n+      return (\n+          primary_restrictions, residual_restrictions, new_stop_window_index)\n+    elif new_stop_window_index and new_stop_window_index != stop_window_index:\n+      # If we failed to split but have a new stop index then return a split\n+      # at the window boundary.\n+      primary, residual = compute_whole_window_split(\n+          new_stop_window_index, new_stop_window_index)\n+      assert primary is not None\n+      assert residual is not None\n+      return ([primary], [residual], new_stop_window_index)\n+    else:\n+      return None\n+\n   def try_split(self, fraction):\n-    # type: (...) -> Optional[Tuple[SplitResultPrimary, SplitResultResidual]]\n+    # type: (...) -> Optional[Tuple[Iterable[SplitResultPrimary], Iterable[SplitResultResidual]]]\n     if not self.is_splittable:\n       return None\n \n     with self.splitting_lock:\n+      if not self.threadsafe_restriction_tracker:\n+        return None\n+\n       # Make a local reference to member variables that change references during\n       # processing under lock before attempting to split so we have a consistent\n       # view of all the references.\n-      current_windowed_value = self.current_windowed_value\n-      threadsafe_restriction_tracker = self.threadsafe_restriction_tracker\n-      threadsafe_watermark_estimator = self.threadsafe_watermark_estimator\n-\n-    if threadsafe_restriction_tracker:\n-      # Temporary workaround for [BEAM-7473]: get current_watermark before\n-      # split, in case watermark gets advanced before getting split results.\n-      # In worst case, current_watermark is always stale, which is ok.\n-      current_watermark = (threadsafe_watermark_estimator.current_watermark())\n-      estimator_state = (threadsafe_watermark_estimator.get_estimator_state())\n-      split = threadsafe_restriction_tracker.try_split(fraction)\n-      if split:\n-        primary, residual = split\n-        element = current_windowed_value.value\n-        restriction_provider = self.signature.get_restriction_provider()\n-        primary_size = restriction_provider.restriction_size(element, primary)\n-        residual_size = restriction_provider.restriction_size(element, residual)\n-        primary_value = ((element, (primary, None)), primary_size)\n-        residual_value = ((element, (residual, estimator_state)), residual_size)\n-        return (\n-            SplitResultPrimary(\n-                primary_value=current_windowed_value.with_value(primary_value)),\n-            SplitResultResidual(\n-                residual_value=current_windowed_value.with_value(\n-                    residual_value),\n-                current_watermark=current_watermark,\n-                deferred_timestamp=None))\n-    return None\n+      result = PerWindowInvoker._try_split(\n+          fraction,\n+          self.current_window_index,\n+          self.stop_window_index,\n+          self.current_windowed_value,\n+          self.restriction,\n+          self.watermark_estimator_state,\n+          self.signature.get_restriction_provider(),\n+          self.threadsafe_restriction_tracker,\n+          self.threadsafe_watermark_estimator)\n+      if not result:\n+        return None\n+\n+      residuals, primaries, self.stop_window_index = result\n+      return (residuals, primaries)\n+\n+  @staticmethod\n+  def _scale_progress(progress, window_index, stop_window_index):\n+    # We scale progress based upon the amount of work we will do for one\n+    # window and have it apply for all windows.\n+    completed = window_index * progress.total_work + progress.completed_work\n+    remaining = (\n+        stop_window_index -\n+        (window_index + 1)) * progress.total_work + progress.remaining_work\n+    from apache_beam.io.iobase import RestrictionProgress\n+    return RestrictionProgress(completed=completed, remaining=remaining)\n \n   def current_element_progress(self):\n     # type: () -> Optional[RestrictionProgress]\n-    restriction_tracker = self.threadsafe_restriction_tracker\n-    if restriction_tracker:\n-      return restriction_tracker.current_progress()\n-    else:\n+    if not self.is_splittable:\n       return None\n \n+    with self.splitting_lock:\n+      current_window_index = self.current_window_index\n+      stop_window_index = self.stop_window_index\n+      threadsafe_restriction_tracker = self.threadsafe_restriction_tracker\n+\n+    if not threadsafe_restriction_tracker:\n+      return None\n+\n+    progress = threadsafe_restriction_tracker.current_progress()\n+    if not current_window_index or not progress:\n+      return progress\n+\n+    assert stop_window_index", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "177ad396e9df13906c219b59851c2e77d3c427d9"}, "originalPosition": 428}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4MTAxMQ==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/12275#discussion_r456681011", "createdAt": "2020-07-17T21:24:45Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/common.py", "diffHunk": "@@ -845,52 +880,241 @@ def _invoke_process_per_window(self,\n             deferred_timestamp=deferred_timestamp)\n     return None\n \n+  @staticmethod\n+  def _try_split(fraction,\n+      window_index, # type: Optional[int]\n+      stop_window_index, # type: Optional[int]\n+      windowed_value, # type: WindowedValue\n+      restriction,\n+      watermark_estimator_state,\n+      restriction_provider, # type: RestrictionProvider\n+      restriction_tracker, # type: RestrictionTracker\n+      watermark_estimator, # type: WatermarkEstimator\n+                 ):\n+    # type: (...) -> Optional[Tuple[Iterable[SplitResultPrimary], Iterable[SplitResultResidual], Optional[int]]]\n+\n+    \"\"\"Try to split returning a primaries, residuals and a new stop index.\n+\n+    For non-window observing splittable DoFns we split the current restriction\n+    and assign the primary and residual to all the windows.\n+\n+    For window observing splittable DoFns, we:\n+    1) return a split at a window boundary if the fraction lies outside of the\n+       current window.\n+    2) attempt to split the current restriction, if successful then return\n+       the primary and residual for the current window and an additional\n+       primary and residual for any fully processed and fully unprocessed\n+       windows.\n+    3) fall back to returning a split at the window boundary if possible\n+\n+    Args:\n+      window_index: the current index of the window being processed or None\n+                    if the splittable DoFn is not window observing.\n+      stop_window_index: the current index to stop processing at or None\n+                         if the splittable DoFn is not window observing.\n+      windowed_value: the current windowed value\n+      restriction: the initial restriction when processing was started.\n+      watermark_estimator_state: the initial watermark estimator state when\n+                                 processing was started.\n+      restriction_provider: the DoFn's restriction provider\n+      restriction_tracker: the current restriction tracker\n+      watermark_estimator: the current watermark estimator\n+\n+    Returns:\n+      A tuple containing (primaries, residuals, new_stop_index) or None if\n+      splitting was not possible. new_stop_index will only be set if the\n+      splittable DoFn is window observing otherwise it will be None.\n+    \"\"\"\n+    def compute_whole_window_split(to_index, from_index):\n+      restriction_size = restriction_provider.restriction_size(\n+          windowed_value, restriction)\n+      # The primary and residual both share the same value only differing\n+      # by the set of windows they are in.\n+      value = ((windowed_value.value, (restriction, watermark_estimator_state)),\n+               restriction_size)\n+      primary_restriction = SplitResultPrimary(\n+          primary_value=WindowedValue(\n+              value,\n+              windowed_value.timestamp,\n+              windowed_value.windows[:to_index])) if to_index > 0 else None\n+      # Don't report any updated watermarks for the residual since they have\n+      # not processed any part of the restriction.\n+      residual_restriction = SplitResultResidual(\n+          residual_value=WindowedValue(\n+              value,\n+              windowed_value.timestamp,\n+              windowed_value.windows[from_index:stop_window_index]),\n+          current_watermark=None,\n+          deferred_timestamp=None) if from_index < stop_window_index else None\n+      return (primary_restriction, residual_restriction)\n+\n+    primary_restrictions = []\n+    residual_restrictions = []\n+\n+    window_observing = window_index is not None\n+    # If we are processing each window separately and we aren't on the last\n+    # window then compute whether the split lies within the current window\n+    # or a future window.\n+    if window_observing and window_index != stop_window_index - 1:\n+      progress = restriction_tracker.current_progress()\n+      if not progress:\n+        # Assume no work has been completed for the current window if progress\n+        # is unavailable.\n+        from apache_beam.io.iobase import RestrictionProgress\n+        progress = RestrictionProgress(completed=0, remaining=1)\n+\n+      scaled_progress = PerWindowInvoker._scale_progress(\n+          progress, window_index, stop_window_index)\n+      # Compute the fraction of the remainder relative to the scaled progress.\n+      # If the value is greater than or equal to progress.remaining_work then we\n+      # should split at the closest window boundary.\n+      fraction_of_remainder = scaled_progress.remaining_work * fraction\n+      if fraction_of_remainder >= progress.remaining_work:\n+        # The fraction is outside of the current window and hence we will\n+        # split at the closest window boundary. Favor a split and return the\n+        # last window if we would have rounded up to the end of the window\n+        # based upon the fraction.\n+        new_stop_window_index = min(\n+            stop_window_index - 1,\n+            window_index + max(\n+                1,\n+                int(\n+                    round((\n+                        progress.completed_work +\n+                        scaled_progress.remaining_work * fraction) /\n+                          progress.total_work))))\n+        primary, residual = compute_whole_window_split(\n+            new_stop_window_index, new_stop_window_index)\n+        assert primary is not None\n+        assert residual is not None\n+        return ([primary], [residual], new_stop_window_index)\n+      else:\n+        # The fraction is within the current window being processed so compute\n+        # the updated fraction based upon the number of windows being processed.\n+        new_stop_window_index = window_index + 1\n+        fraction = fraction_of_remainder / progress.remaining_work\n+        # Attempt to split below, if we can't then we'll compute a split\n+        # using only window boundaries\n+    else:\n+      # We aren't splitting within multiple windows so we don't change our\n+      # stop index.\n+      new_stop_window_index = stop_window_index\n+\n+    # Temporary workaround for [BEAM-7473]: get current_watermark before\n+    # split, in case watermark gets advanced before getting split results.\n+    # In worst case, current_watermark is always stale, which is ok.\n+    current_watermark = (watermark_estimator.current_watermark())\n+    current_estimator_state = (watermark_estimator.get_estimator_state())\n+    split = restriction_tracker.try_split(fraction)\n+    if split:\n+      primary, residual = split\n+      element = windowed_value.value\n+      primary_size = restriction_provider.restriction_size(\n+          windowed_value.value, primary)\n+      residual_size = restriction_provider.restriction_size(\n+          windowed_value.value, residual)\n+      # We use the watermark estimator state for the original process call\n+      # for the primary and the updated watermark estimator state for the\n+      # residual for the split.\n+      primary_split_value = ((element, (primary, watermark_estimator_state)),\n+                             primary_size)\n+      residual_split_value = ((element, (residual, current_estimator_state)),\n+                              residual_size)\n+      windows = (\n+          windowed_value.windows[window_index],\n+      ) if window_observing else windowed_value.windows\n+      primary_restrictions.append(\n+          SplitResultPrimary(\n+              primary_value=WindowedValue(\n+                  primary_split_value, windowed_value.timestamp, windows)))\n+      residual_restrictions.append(\n+          SplitResultResidual(\n+              residual_value=WindowedValue(\n+                  residual_split_value, windowed_value.timestamp, windows),\n+              current_watermark=current_watermark,\n+              deferred_timestamp=None))\n+\n+      if window_observing:\n+        assert new_stop_window_index == window_index + 1\n+        primary, residual = compute_whole_window_split(\n+            window_index, window_index + 1)\n+        if primary:\n+          primary_restrictions.append(primary)\n+        if residual:\n+          residual_restrictions.append(residual)\n+      return (\n+          primary_restrictions, residual_restrictions, new_stop_window_index)\n+    elif new_stop_window_index and new_stop_window_index != stop_window_index:\n+      # If we failed to split but have a new stop index then return a split\n+      # at the window boundary.\n+      primary, residual = compute_whole_window_split(\n+          new_stop_window_index, new_stop_window_index)\n+      assert primary is not None\n+      assert residual is not None\n+      return ([primary], [residual], new_stop_window_index)\n+    else:\n+      return None\n+\n   def try_split(self, fraction):\n-    # type: (...) -> Optional[Tuple[SplitResultPrimary, SplitResultResidual]]\n+    # type: (...) -> Optional[Tuple[Iterable[SplitResultPrimary], Iterable[SplitResultResidual]]]\n     if not self.is_splittable:\n       return None\n \n     with self.splitting_lock:\n+      if not self.threadsafe_restriction_tracker:\n+        return None\n+\n       # Make a local reference to member variables that change references during\n       # processing under lock before attempting to split so we have a consistent\n       # view of all the references.\n-      current_windowed_value = self.current_windowed_value\n-      threadsafe_restriction_tracker = self.threadsafe_restriction_tracker\n-      threadsafe_watermark_estimator = self.threadsafe_watermark_estimator\n-\n-    if threadsafe_restriction_tracker:\n-      # Temporary workaround for [BEAM-7473]: get current_watermark before\n-      # split, in case watermark gets advanced before getting split results.\n-      # In worst case, current_watermark is always stale, which is ok.\n-      current_watermark = (threadsafe_watermark_estimator.current_watermark())\n-      estimator_state = (threadsafe_watermark_estimator.get_estimator_state())\n-      split = threadsafe_restriction_tracker.try_split(fraction)\n-      if split:\n-        primary, residual = split\n-        element = current_windowed_value.value\n-        restriction_provider = self.signature.get_restriction_provider()\n-        primary_size = restriction_provider.restriction_size(element, primary)\n-        residual_size = restriction_provider.restriction_size(element, residual)\n-        primary_value = ((element, (primary, None)), primary_size)\n-        residual_value = ((element, (residual, estimator_state)), residual_size)\n-        return (\n-            SplitResultPrimary(\n-                primary_value=current_windowed_value.with_value(primary_value)),\n-            SplitResultResidual(\n-                residual_value=current_windowed_value.with_value(\n-                    residual_value),\n-                current_watermark=current_watermark,\n-                deferred_timestamp=None))\n-    return None\n+      result = PerWindowInvoker._try_split(\n+          fraction,\n+          self.current_window_index,\n+          self.stop_window_index,\n+          self.current_windowed_value,\n+          self.restriction,\n+          self.watermark_estimator_state,\n+          self.signature.get_restriction_provider(),\n+          self.threadsafe_restriction_tracker,\n+          self.threadsafe_watermark_estimator)\n+      if not result:\n+        return None\n+\n+      residuals, primaries, self.stop_window_index = result\n+      return (residuals, primaries)\n+\n+  @staticmethod\n+  def _scale_progress(progress, window_index, stop_window_index):\n+    # We scale progress based upon the amount of work we will do for one\n+    # window and have it apply for all windows.\n+    completed = window_index * progress.total_work + progress.completed_work\n+    remaining = (\n+        stop_window_index -\n+        (window_index + 1)) * progress.total_work + progress.remaining_work\n+    from apache_beam.io.iobase import RestrictionProgress\n+    return RestrictionProgress(completed=completed, remaining=remaining)\n \n   def current_element_progress(self):\n     # type: () -> Optional[RestrictionProgress]\n-    restriction_tracker = self.threadsafe_restriction_tracker\n-    if restriction_tracker:\n-      return restriction_tracker.current_progress()\n-    else:\n+    if not self.is_splittable:\n       return None\n \n+    with self.splitting_lock:\n+      current_window_index = self.current_window_index\n+      stop_window_index = self.stop_window_index\n+      threadsafe_restriction_tracker = self.threadsafe_restriction_tracker\n+\n+    if not threadsafe_restriction_tracker:\n+      return None\n+\n+    progress = threadsafe_restriction_tracker.current_progress()\n+    if not current_window_index or not progress:\n+      return progress\n+\n+    assert stop_window_index", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMDU4MQ=="}, "originalCommit": {"oid": "177ad396e9df13906c219b59851c2e77d3c427d9"}, "originalPosition": 428}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1068, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}