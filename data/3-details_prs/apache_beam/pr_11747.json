{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NzY2NDMx", "number": 11747, "title": "[BEAM-9951] Using the builder pattern for Go synthetic config frontend", "bodyText": "Instead of just creating SourceConfigs and StepConfigs, have a builder\npattern to allow more user-friendly creation of those configs with\ndefaults.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-05-18T22:08:24Z", "url": "https://github.com/apache/beam/pull/11747", "merged": true, "mergeCommit": {"oid": "2eaea235697a3ca02117cf7d75eda84d10a42c78"}, "closed": true, "closedAt": "2020-05-19T20:14:47Z", "author": {"login": "youngoli"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcioHwfgFqTQxMzk5MTMyMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABci6OY1gBqjMzNTM1Mjc3NDc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzOTkxMzIw", "url": "https://github.com/apache/beam/pull/11747#pullrequestreview-413991320", "createdAt": "2020-05-18T22:56:20Z", "commit": {"oid": "875cc99bb795b761333a8513e8c3884961be054e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjo1NjoyMFrOGXKGXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMzowMzo1N1rOGXKRUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNTkwMw==", "bodyText": "Note: Default encoding with JSON (or even future with beam.Schemas) will not encode unexported fields. You'll need to register a coder with beam.RegisterCoder if you want to ensure these get encoded properly.\nAlternatively, having the fields be exported while still providing and recommending a builder is not unreasonable. Eg. Document on the type  (as you have it) that the builder is recommended etc.", "url": "https://github.com/apache/beam/pull/11747#discussion_r426935903", "createdAt": "2020-05-18T22:56:20Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -135,27 +155,79 @@ func (fn *sourceFn) ProcessElement(rt *offsetrange.Tracker, config SourceConfig,\n \treturn nil\n }\n \n-// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n-// fields. SourceConfigs should be initialized with this method.\n-func DefaultSourceConfig() SourceConfig {\n-\treturn SourceConfig{\n-\t\tNumElements:   1, // Defaults shouldn't drop elements, so at least 1.\n-\t\tInitialSplits: 1, // Defaults to 1, i.e. no initial splitting.\n+// SourceConfigBuilder is used to initialize SourceConfigs. See\n+// SourceConfigBuilder's methods for descriptions of the fields in a\n+// SourceConfig and how they can be set. The intended approach for using this\n+// builder is to begin by calling the DefaultSourceConfig function, followed by\n+// calling setters, followed by calling Build.\n+//\n+// Usage example:\n+//\n+//    cfg := synthetic.DefaultSourceConfig().NumElements(5000).InitialSplits(2).Build()\n+type SourceConfigBuilder struct {\n+\tcfg SourceConfig\n+}\n+\n+// DefaultSourceConfig creates a SourceConfigBuilder set with intended defaults\n+// for the SourceConfig fields. This function is the intended starting point for\n+// initializing a SourceConfig and should always be used to create\n+// SourceConfigBuilders.\n+//\n+// To see descriptions of the various SourceConfig fields and their defaults,\n+// see the methods to SourceConfigBuilder.\n+func DefaultSourceConfig() *SourceConfigBuilder {\n+\treturn &SourceConfigBuilder{\n+\t\tcfg: SourceConfig{\n+\t\t\tnumElements:   1, // 0 is invalid (drops elements).\n+\t\t\tinitialSplits: 1, // 0 is invalid (drops elements).\n+\t\t},\n+\t}\n+}\n+\n+// NumElements is the number of elements for the source to generate and emit.\n+//\n+// Valid values are in the range of [1, ...] and the default value is 1. Values\n+// of 0 (and below) are invalid as they result in sources that emit no elements.\n+func (b *SourceConfigBuilder) NumElements(val int) *SourceConfigBuilder {\n+\tb.cfg.numElements = val\n+\treturn b\n+}\n+\n+// InitialSplits determines the number of initial splits to perform in the\n+// source's SplitRestriction method. Restrictions in synthetic sources represent\n+// the number of elements being emitted, and this split is performed evenly\n+// across that number of elements.\n+//\n+// Each resulting restriction will have at least 1 element in it, and each\n+// element being emitted will be contained in exactly one restriction. That\n+// means that if the desired number of splits is greater than the number of\n+// elements N, then N initial restrictions will be created, each containing 1\n+// element.\n+//\n+// Valid values are in the range of [1, ...] and the default value is 1. Values\n+// of 0 (and below) are invalid as they would result in dropping elements that\n+// are expected to be emitted.\n+func (b *SourceConfigBuilder) InitialSplits(val int) *SourceConfigBuilder {\n+\tb.cfg.initialSplits = val\n+\treturn b\n+}\n+\n+// Build constructs the SourceConfig initialized by this builder. It also\n+// performs error checking on the fields, and panics if any have been set to\n+// invalid values.\n+func (b *SourceConfigBuilder) Build() SourceConfig {\n+\tif b.cfg.initialSplits <= 0 {\n+\t\tpanic(fmt.Sprintf(\"SourceConfig.InitialSplits must be >= 1. Got: %v\", b.cfg.initialSplits))\n+\t}\n+\tif b.cfg.numElements <= 0 {\n+\t\tpanic(fmt.Sprintf(\"SourceConfig.NumElements must be >= 1. Got: %v\", b.cfg.numElements))\n \t}\n+\treturn b.cfg\n }\n \n // SourceConfig is a struct containing all the configuration options for a\n-// synthetic source.\n+// synthetic source. It should be created via a SourceConfigBuilder.\n type SourceConfig struct {\n-\t// NumElements is the number of elements for the source to generate and\n-\t// emit.\n-\tNumElements int\n-\n-\t// InitialSplits determines the number of initial splits to perform in the\n-\t// source's SplitRestriction method. Note that in some edge cases, the\n-\t// number of splits performed might differ from this config value. Each\n-\t// restriction will always have one element in it, and at least one\n-\t// restriction will always be output, so the number of splits will be in\n-\t// the range of [1, N] where N is the size of the original restriction.\n-\tInitialSplits int\n+\tnumElements   int", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "875cc99bb795b761333a8513e8c3884961be054e"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzODcwNA==", "bodyText": "Same comment here WRT the unexported fields being unserializable.", "url": "https://github.com/apache/beam/pull/11747#discussion_r426938704", "createdAt": "2020-05-18T23:03:57Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/step.go", "diffHunk": "@@ -144,49 +143,130 @@ func (fn *sdfStepFn) Setup() {\n // ProcessElement takes an input and either filters it or produces a number of\n // outputs identical to that input based on the restriction size.\n func (fn *sdfStepFn) ProcessElement(rt *offsetrange.Tracker, key, val []byte, emit func([]byte, []byte)) {\n-\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n-\t\treturn\n-\t}\n+\tfiltered := fn.cfg.filterRatio > 0 && fn.rng.Float64() < fn.cfg.filterRatio\n+\n \tfor i := rt.Rest.Start; rt.TryClaim(i) == true; i++ {\n-\t\temit(key, val)\n+\t\tif !filtered {\n+\t\t\temit(key, val)\n+\t\t}\n+\t}\n+}\n+\n+// StepConfigBuilder is used to initialize StepConfigs. See StepConfigBuilder's\n+// methods for descriptions of the fields in a StepConfig and how they can be\n+// set. The intended approach for using this builder is to begin by calling the\n+// DefaultStepConfig function, followed by calling setters, followed by calling\n+// Build.\n+//\n+// Usage example:\n+//\n+//    cfg := synthetic.DefaultStepConfig().OutputPerInput(10).FilterRatio(0.5).Build()\n+type StepConfigBuilder struct {\n+\tcfg StepConfig\n+}\n+\n+// DefaultSourceConfig creates a StepConfig with intended defaults for the\n+// StepConfig fields. This function is the intended starting point for\n+// initializing a StepConfig and should always be used to create\n+// StepConfigBuilders.\n+//\n+// To see descriptions of the various StepConfig fields and their defaults, see\n+// the methods to StepConfigBuilder.\n+func DefaultStepConfig() *StepConfigBuilder {\n+\treturn &StepConfigBuilder{\n+\t\tcfg: StepConfig{\n+\t\t\toutputPerInput: 1,     // Defaults shouldn't drop elements, so at least 1.\n+\t\t\tfilterRatio:    0.0,   // Defaults shouldn't drop elements, so don't filter.\n+\t\t\tsplittable:     false, // Default to non-splittable, SDFs are situational.\n+\t\t\tinitialSplits:  1,     // Defaults to 1, i.e. no initial splitting.\n+\t\t},\n \t}\n }\n \n-// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n-// fields. SourceConfigs should be initialized with this method.\n-func DefaultStepConfig() StepConfig {\n-\treturn StepConfig{\n-\t\tOutputPerInput: 1,     // Defaults shouldn't drop elements, so at least 1.\n-\t\tFilterRatio:    0.0,   // Defaults shouldn't drop elements, so don't filter.\n-\t\tSplittable:     false, // Default to non-splittable, SDFs are situational.\n-\t\tInitialSplits:  1,     // Defaults to 1, i.e. no initial splitting.\n+// OutputPerInput is the number of outputs to emit per input received. Each\n+// output is identical to the original input. A value of 0 drops all inputs and\n+// produces no output.\n+//\n+// Valid values are in the range of [0, ...] and the default value is 1. Values\n+// below 0 are invalid as they have no logical meaning for this field.\n+func (b *StepConfigBuilder) OutputPerInput(val int) *StepConfigBuilder {\n+\tb.cfg.outputPerInput = val\n+\treturn b\n+}\n+\n+// FilterRatio indicates the random chance that an input will be filtered\n+// out, meaning that no outputs will get emitted for it. For example, a\n+// FilterRatio of 0.25 means that 25% of inputs will be filtered out, a\n+// FilterRatio of 0 means no elements are filtered, and a FilterRatio of 1.0\n+// means every element is filtered.\n+//\n+// In a non-splittable step, this is performed on each input element, meaning\n+// all outputs for that element would be filtered. In a splittable step, this is\n+// performed on each input restriction instead of the entire element, meaning\n+// that some outputs for an element may be filtered and others kept.\n+//\n+// Note that even when elements are filtered out, the work associated with\n+// processing those elements is still performed, which differs from setting an\n+// OutputPerInput of 0. Also note that if a\n+//\n+// Valid values are in the range if [0.0, 1.0], and the default value is 0. In\n+// order to avoid precision errors, invalid values do not cause errors. Instead,\n+// values below 0 are functionally equivalent to 0, and values above 1 are\n+// functionally equivalent to 1.\n+func (b *StepConfigBuilder) FilterRatio(val float64) *StepConfigBuilder {\n+\tb.cfg.filterRatio = val\n+\treturn b\n+}\n+\n+// Splittable indicates whether the step should use the splittable DoFn or\n+// non-splittable DoFn implementation.\n+//\n+// Splittable steps will split along restrictions representing the number of\n+// OutputPerInput for each element, so it is most useful for steps with a high\n+// OutputPerInput. Conversely, if OutputPerInput is 1, then there is no way to\n+// split restrictions further, so making the step splittable will do nothing.\n+func (b *StepConfigBuilder) Splittable(val bool) *StepConfigBuilder {\n+\tb.cfg.splittable = val\n+\treturn b\n+}\n+\n+// InitialSplits is only applicable if Splittable is set to true, and determines\n+// the number of initial splits to perform in the step's SplitRestriction\n+// method. Restrictions in synthetic steps represent the number of elements to\n+// emit for each input element, as defined by the OutputPerInput config field,\n+// and this split is performed evenly across that number of elements.\n+//\n+// Each resulting restriction will have at least 1 element in it, and each\n+// element being emitted will be contained in exactly one restriction. That\n+// means that if the desired number of splits is greater than the OutputPerInput\n+// N, then N initial restrictions will be created, each containing 1 element.\n+//\n+// Valid values are in the range of [1, ...] and the default value is 1. Values\n+// of 0 (and below) are invalid as they would result in dropping elements that\n+// are expected to be emitted.\n+func (b *StepConfigBuilder) InitialSplits(val int) *StepConfigBuilder {\n+\tb.cfg.initialSplits = val\n+\treturn b\n+}\n+\n+// Build constructs the StepConfig initialized by this builder. It also performs\n+// error checking on the fields, and panics if any have been set to invalid\n+// values.\n+func (b *StepConfigBuilder) Build() StepConfig {\n+\tif b.cfg.initialSplits <= 0 {\n+\t\tpanic(fmt.Sprintf(\"StepConfig.InitialSplits must be >= 1. Got: %v\", b.cfg.initialSplits))\n+\t}\n+\tif b.cfg.outputPerInput < 0 {\n+\t\tpanic(fmt.Sprintf(\"StepConfig.OutputPerInput cannot be negative. Got: %v\", b.cfg.outputPerInput))\n \t}\n+\treturn b.cfg\n }\n \n // StepConfig is a struct containing all the configuration options for a\n-// synthetic step.\n+// synthetic step. It should be created via a StepConfigBuilder.\n type StepConfig struct {\n-\t// OutputPerInput is the number of outputs to emit per input received. Each\n-\t// output is identical to the original input. A value of 0 drops each input.\n-\tOutputPerInput int\n-\n-\t// FilterRatio indicates the random chance that an input will be filtered\n-\t// out, meaning that no outputs will get emitted for it. For example, a\n-\t// FilterRatio of 0.25 means that 25% of inputs will get filtered out.\n-\tFilterRatio float64\n-\n-\t// Splittable indicates whether the step should use the splittable DoFn or\n-\t// non-splittable DoFn implementation. Splittable steps will split the\n-\t// number of OutputPerInput into restrictions, so it is most useful for\n-\t// steps with a high OutputPerInput.\n-\tSplittable bool\n-\n-\t// InitialSplits is only applicable if Splittable is set to true, and\n-\t// determines the number of initial splits to perform in the step's\n-\t// SplitRestriction method. Note that in some edge cases, the number of\n-\t// splits performed might differ from this config value. Each restriction\n-\t// will always have one element in it, and at least one restriction will\n-\t// always be output, so the number of splits will be in the range of [1, N]\n-\t// where N is the size of the original restriction.\n-\tInitialSplits int\n+\toutputPerInput int", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "875cc99bb795b761333a8513e8c3884961be054e"}, "originalPosition": 236}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NzExNjI0", "url": "https://github.com/apache/beam/pull/11747#pullrequestreview-414711624", "createdAt": "2020-05-19T18:24:01Z", "commit": {"oid": "9db94d905c6d0b3830bfeda3e7ade2fb6947da30"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d032818c55bf1b0ae1d7fa622dd051c77405d383", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/d032818c55bf1b0ae1d7fa622dd051c77405d383", "committedDate": "2020-05-19T20:09:29Z", "message": "[BEAM-9951] Using the builder pattern for Go synthetic config frontend\n\nInstead of just creating SourceConfigs and StepConfigs, have a builder\npattern to allow more user-friendly creation of those configs with\ndefaults."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9db94d905c6d0b3830bfeda3e7ade2fb6947da30", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/9db94d905c6d0b3830bfeda3e7ade2fb6947da30", "committedDate": "2020-05-19T03:08:48Z", "message": "Fixup: Exporting config fields"}, "afterCommit": {"oid": "d032818c55bf1b0ae1d7fa622dd051c77405d383", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/d032818c55bf1b0ae1d7fa622dd051c77405d383", "committedDate": "2020-05-19T20:09:29Z", "message": "[BEAM-9951] Using the builder pattern for Go synthetic config frontend\n\nInstead of just creating SourceConfigs and StepConfigs, have a builder\npattern to allow more user-friendly creation of those configs with\ndefaults."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4668, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}