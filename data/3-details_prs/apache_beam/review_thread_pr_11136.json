{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5MTczODAx", "number": 11136, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODowMjoyNFrODpnoxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoxODo1NlrODpn_Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTY3NjIwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/testing/load_tests/sideinput_test.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODowMjoyNFrOF46UJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODowMjoyNFrOF46UJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMDAwNQ==", "bodyText": "It'd be helpful to list the types here, too.", "url": "https://github.com/apache/beam/pull/11136#discussion_r395220005", "createdAt": "2020-03-19T18:02:24Z", "author": {"login": "ibzib"}, "path": "sdks/python/apache_beam/testing/load_tests/sideinput_test.py", "diffHunk": "@@ -47,65 +49,154 @@\n or:\n \n ./gradlew -PloadTest.args=\"\n-    --publish_to_big_query=true\n-    --project=...\n-    --metrics_dataset=python_load_tests\n-    --metrics_table=side_input\n+    --side_input_type=iter\n     --input_options='{\n-      \\\"num_records\\\": 1,\n-      \\\"key_size\\\": 1,\n-      \\\"value_size\\\": 1}'\n-    --runner=DirectRunner\" \\\n+      \\\"num_records\\\": 300,\n+      \\\"key_size\\\": 5,\n+      \\\"value_size\\\": 15}'\" \\\n -PloadTest.mainClass=apache_beam.testing.load_tests.sideinput_test \\\n -Prunner=DirectRunner :sdks:python:apache_beam:testing:load_tests:run\n \"\"\"\n \n # pytype: skip-file\n \n from __future__ import absolute_import\n+from __future__ import division\n \n import logging\n \n import apache_beam as beam\n-from apache_beam.pvalue import AsIter\n from apache_beam.testing.load_tests.load_test import LoadTest\n from apache_beam.testing.load_tests.load_test_metrics_utils import MeasureTime\n from apache_beam.testing.synthetic_pipeline import SyntheticSource\n \n \n class SideInputTest(LoadTest):\n+  SIDE_INPUT_TYPES = {\n+      'iter': beam.pvalue.AsIter,\n+      'list': beam.pvalue.AsList,\n+      'dict': beam.pvalue.AsDict,\n+  }\n+\n   def __init__(self):\n     super(SideInputTest, self).__init__()\n-    self.iterations = self.get_option_or_default(\n-        'number_of_counter_operations', 1)\n+    self.windows = self.get_option_or_default('window_count', default=0)\n+    self.access_percentage = self.get_option_or_default(\n+        'access_percentage', default=100)\n+    if self.access_percentage < 0 or self.access_percentage > 100:\n+      raise ValueError(\n+          'access_percentage: Invalid value. Should be in range '\n+          'from 0 to 100, got {} instead'.format(self.access_percentage))\n+\n+    self.side_input_size = self.get_option_or_default(\n+        'side_input_size', default=0)\n+    if self.side_input_size == 0:\n+      self.side_input_size = self.input_options.get('num_records')\n+\n+    self.side_input_type = self.pipeline.get_option('side_input_type')\n+    if self.side_input_type is None:\n+      raise ValueError('side_input_type is required')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f19191e09b1ae251e4a4b003a2aa94b80fa4b7c"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTcwOTkxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/testing/load_tests/sideinput_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoxMjoxM1rOF46qJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNDozNjoyNVrOF5WTfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNTYzNg==", "bodyText": "For first_n < len(side_input), wouldn't we access a total of first_n + 1 elements?", "url": "https://github.com/apache/beam/pull/11136#discussion_r395225636", "createdAt": "2020-03-19T18:12:13Z", "author": {"login": "ibzib"}, "path": "sdks/python/apache_beam/testing/load_tests/sideinput_test.py", "diffHunk": "@@ -47,65 +49,154 @@\n or:\n \n ./gradlew -PloadTest.args=\"\n-    --publish_to_big_query=true\n-    --project=...\n-    --metrics_dataset=python_load_tests\n-    --metrics_table=side_input\n+    --side_input_type=iter\n     --input_options='{\n-      \\\"num_records\\\": 1,\n-      \\\"key_size\\\": 1,\n-      \\\"value_size\\\": 1}'\n-    --runner=DirectRunner\" \\\n+      \\\"num_records\\\": 300,\n+      \\\"key_size\\\": 5,\n+      \\\"value_size\\\": 15}'\" \\\n -PloadTest.mainClass=apache_beam.testing.load_tests.sideinput_test \\\n -Prunner=DirectRunner :sdks:python:apache_beam:testing:load_tests:run\n \"\"\"\n \n # pytype: skip-file\n \n from __future__ import absolute_import\n+from __future__ import division\n \n import logging\n \n import apache_beam as beam\n-from apache_beam.pvalue import AsIter\n from apache_beam.testing.load_tests.load_test import LoadTest\n from apache_beam.testing.load_tests.load_test_metrics_utils import MeasureTime\n from apache_beam.testing.synthetic_pipeline import SyntheticSource\n \n \n class SideInputTest(LoadTest):\n+  SIDE_INPUT_TYPES = {\n+      'iter': beam.pvalue.AsIter,\n+      'list': beam.pvalue.AsList,\n+      'dict': beam.pvalue.AsDict,\n+  }\n+\n   def __init__(self):\n     super(SideInputTest, self).__init__()\n-    self.iterations = self.get_option_or_default(\n-        'number_of_counter_operations', 1)\n+    self.windows = self.get_option_or_default('window_count', default=0)\n+    self.access_percentage = self.get_option_or_default(\n+        'access_percentage', default=100)\n+    if self.access_percentage < 0 or self.access_percentage > 100:\n+      raise ValueError(\n+          'access_percentage: Invalid value. Should be in range '\n+          'from 0 to 100, got {} instead'.format(self.access_percentage))\n+\n+    self.side_input_size = self.get_option_or_default(\n+        'side_input_size', default=0)\n+    if self.side_input_size == 0:\n+      self.side_input_size = self.input_options.get('num_records')\n+\n+    self.side_input_type = self.pipeline.get_option('side_input_type')\n+    if self.side_input_type is None:\n+      raise ValueError('side_input_type is required')\n+\n+  def materialize_as(self):\n+    try:\n+      return self.SIDE_INPUT_TYPES[self.side_input_type]\n+    except KeyError:\n+      raise ValueError(\n+          'Unknown side input type. You have to provide one of '\n+          'these: {}'.format(list(self.SIDE_INPUT_TYPES.keys())))\n \n   def test(self):\n-    def join_fn(element, side_input, iterations):\n-      result = []\n-      for i in range(iterations):\n-        for key, value in side_input:\n-          if i == iterations - 1:\n-            result.append({key: element[1] + value})\n-      yield result\n-\n-    main_input = (\n+    class SequenceSideInputTestDoFn(beam.DoFn):\n+      \"\"\"Iterate over first n side_input elements. Iterate over all\n+      elements if `first_n` is :data:`None`.\"\"\"\n+      def __init__(self, first_n=None):\n+        self._first_n = first_n\n+\n+      def process(self, unused_element, side_input):\n+        for i, _ in enumerate(side_input):\n+          if self._first_n and i >= self._first_n:\n+            return\n+          # No-op. We only make sure that the element is accessed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f19191e09b1ae251e4a4b003a2aa94b80fa4b7c"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3ODU5MA==", "bodyText": "Ohh that's right. Thanks.\nI'll use a while loop and iter(), so that we'd be able to treat list and iterable in the same way.", "url": "https://github.com/apache/beam/pull/11136#discussion_r395678590", "createdAt": "2020-03-20T14:36:25Z", "author": {"login": "kamilwu"}, "path": "sdks/python/apache_beam/testing/load_tests/sideinput_test.py", "diffHunk": "@@ -47,65 +49,154 @@\n or:\n \n ./gradlew -PloadTest.args=\"\n-    --publish_to_big_query=true\n-    --project=...\n-    --metrics_dataset=python_load_tests\n-    --metrics_table=side_input\n+    --side_input_type=iter\n     --input_options='{\n-      \\\"num_records\\\": 1,\n-      \\\"key_size\\\": 1,\n-      \\\"value_size\\\": 1}'\n-    --runner=DirectRunner\" \\\n+      \\\"num_records\\\": 300,\n+      \\\"key_size\\\": 5,\n+      \\\"value_size\\\": 15}'\" \\\n -PloadTest.mainClass=apache_beam.testing.load_tests.sideinput_test \\\n -Prunner=DirectRunner :sdks:python:apache_beam:testing:load_tests:run\n \"\"\"\n \n # pytype: skip-file\n \n from __future__ import absolute_import\n+from __future__ import division\n \n import logging\n \n import apache_beam as beam\n-from apache_beam.pvalue import AsIter\n from apache_beam.testing.load_tests.load_test import LoadTest\n from apache_beam.testing.load_tests.load_test_metrics_utils import MeasureTime\n from apache_beam.testing.synthetic_pipeline import SyntheticSource\n \n \n class SideInputTest(LoadTest):\n+  SIDE_INPUT_TYPES = {\n+      'iter': beam.pvalue.AsIter,\n+      'list': beam.pvalue.AsList,\n+      'dict': beam.pvalue.AsDict,\n+  }\n+\n   def __init__(self):\n     super(SideInputTest, self).__init__()\n-    self.iterations = self.get_option_or_default(\n-        'number_of_counter_operations', 1)\n+    self.windows = self.get_option_or_default('window_count', default=0)\n+    self.access_percentage = self.get_option_or_default(\n+        'access_percentage', default=100)\n+    if self.access_percentage < 0 or self.access_percentage > 100:\n+      raise ValueError(\n+          'access_percentage: Invalid value. Should be in range '\n+          'from 0 to 100, got {} instead'.format(self.access_percentage))\n+\n+    self.side_input_size = self.get_option_or_default(\n+        'side_input_size', default=0)\n+    if self.side_input_size == 0:\n+      self.side_input_size = self.input_options.get('num_records')\n+\n+    self.side_input_type = self.pipeline.get_option('side_input_type')\n+    if self.side_input_type is None:\n+      raise ValueError('side_input_type is required')\n+\n+  def materialize_as(self):\n+    try:\n+      return self.SIDE_INPUT_TYPES[self.side_input_type]\n+    except KeyError:\n+      raise ValueError(\n+          'Unknown side input type. You have to provide one of '\n+          'these: {}'.format(list(self.SIDE_INPUT_TYPES.keys())))\n \n   def test(self):\n-    def join_fn(element, side_input, iterations):\n-      result = []\n-      for i in range(iterations):\n-        for key, value in side_input:\n-          if i == iterations - 1:\n-            result.append({key: element[1] + value})\n-      yield result\n-\n-    main_input = (\n+    class SequenceSideInputTestDoFn(beam.DoFn):\n+      \"\"\"Iterate over first n side_input elements. Iterate over all\n+      elements if `first_n` is :data:`None`.\"\"\"\n+      def __init__(self, first_n=None):\n+        self._first_n = first_n\n+\n+      def process(self, unused_element, side_input):\n+        for i, _ in enumerate(side_input):\n+          if self._first_n and i >= self._first_n:\n+            return\n+          # No-op. We only make sure that the element is accessed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNTYzNg=="}, "originalCommit": {"oid": "5f19191e09b1ae251e4a4b003a2aa94b80fa4b7c"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTczMzIzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/testing/load_tests/sideinput_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoxODo1NlrOF465VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjowODo0NlrOF5RLcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyOTUyNQ==", "bodyText": "Is there any particular reason we need to use the real time? If not, it would be easier to read timestamps if we start at 0.", "url": "https://github.com/apache/beam/pull/11136#discussion_r395229525", "createdAt": "2020-03-19T18:18:56Z", "author": {"login": "ibzib"}, "path": "sdks/python/apache_beam/testing/load_tests/sideinput_test.py", "diffHunk": "@@ -47,65 +49,154 @@\n or:\n \n ./gradlew -PloadTest.args=\"\n-    --publish_to_big_query=true\n-    --project=...\n-    --metrics_dataset=python_load_tests\n-    --metrics_table=side_input\n+    --side_input_type=iter\n     --input_options='{\n-      \\\"num_records\\\": 1,\n-      \\\"key_size\\\": 1,\n-      \\\"value_size\\\": 1}'\n-    --runner=DirectRunner\" \\\n+      \\\"num_records\\\": 300,\n+      \\\"key_size\\\": 5,\n+      \\\"value_size\\\": 15}'\" \\\n -PloadTest.mainClass=apache_beam.testing.load_tests.sideinput_test \\\n -Prunner=DirectRunner :sdks:python:apache_beam:testing:load_tests:run\n \"\"\"\n \n # pytype: skip-file\n \n from __future__ import absolute_import\n+from __future__ import division\n \n import logging\n \n import apache_beam as beam\n-from apache_beam.pvalue import AsIter\n from apache_beam.testing.load_tests.load_test import LoadTest\n from apache_beam.testing.load_tests.load_test_metrics_utils import MeasureTime\n from apache_beam.testing.synthetic_pipeline import SyntheticSource\n \n \n class SideInputTest(LoadTest):\n+  SIDE_INPUT_TYPES = {\n+      'iter': beam.pvalue.AsIter,\n+      'list': beam.pvalue.AsList,\n+      'dict': beam.pvalue.AsDict,\n+  }\n+\n   def __init__(self):\n     super(SideInputTest, self).__init__()\n-    self.iterations = self.get_option_or_default(\n-        'number_of_counter_operations', 1)\n+    self.windows = self.get_option_or_default('window_count', default=0)\n+    self.access_percentage = self.get_option_or_default(\n+        'access_percentage', default=100)\n+    if self.access_percentage < 0 or self.access_percentage > 100:\n+      raise ValueError(\n+          'access_percentage: Invalid value. Should be in range '\n+          'from 0 to 100, got {} instead'.format(self.access_percentage))\n+\n+    self.side_input_size = self.get_option_or_default(\n+        'side_input_size', default=0)\n+    if self.side_input_size == 0:\n+      self.side_input_size = self.input_options.get('num_records')\n+\n+    self.side_input_type = self.pipeline.get_option('side_input_type')\n+    if self.side_input_type is None:\n+      raise ValueError('side_input_type is required')\n+\n+  def materialize_as(self):\n+    try:\n+      return self.SIDE_INPUT_TYPES[self.side_input_type]\n+    except KeyError:\n+      raise ValueError(\n+          'Unknown side input type. You have to provide one of '\n+          'these: {}'.format(list(self.SIDE_INPUT_TYPES.keys())))\n \n   def test(self):\n-    def join_fn(element, side_input, iterations):\n-      result = []\n-      for i in range(iterations):\n-        for key, value in side_input:\n-          if i == iterations - 1:\n-            result.append({key: element[1] + value})\n-      yield result\n-\n-    main_input = (\n+    class SequenceSideInputTestDoFn(beam.DoFn):\n+      \"\"\"Iterate over first n side_input elements. Iterate over all\n+      elements if `first_n` is :data:`None`.\"\"\"\n+      def __init__(self, first_n=None):\n+        self._first_n = first_n\n+\n+      def process(self, unused_element, side_input):\n+        for i, _ in enumerate(side_input):\n+          if self._first_n and i >= self._first_n:\n+            return\n+          # No-op. We only make sure that the element is accessed.\n+\n+    class MappingSideInputTestDoFn(beam.DoFn):\n+      \"\"\"Take a sequence of keys as an additional side input and for each\n+      key in the sequence checks the value for key in the dictionary.\"\"\"\n+      def process(self, unused_element, dict_side_input, keys_to_check):\n+        for key in keys_to_check:\n+          # No-op. We only make sure that the element is accessed.\n+          dict_side_input[key]\n+\n+    class GetRandomKeys(beam.DoFn):\n+      def __init__(self, n):\n+        self._n = n\n+\n+      def process(self, unused_element, dict_side_input):\n+        import random\n+        n = min(self._n, len(dict_side_input))\n+        return random.sample(dict_side_input.keys(), n)\n+\n+    class AddEventTimestamps(beam.DoFn):\n+      \"\"\"Assign timestamp to each element of PCollection, starting from the\n+      current Unix seconds-since-epoch timestamp.\"\"\"\n+      def setup(self):\n+        import time\n+        self.current_time = int(time.time())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f19191e09b1ae251e4a4b003a2aa94b80fa4b7c"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NDYwOQ==", "bodyText": "No particular reason. I'll change it to start at 0.", "url": "https://github.com/apache/beam/pull/11136#discussion_r395594609", "createdAt": "2020-03-20T12:08:46Z", "author": {"login": "kamilwu"}, "path": "sdks/python/apache_beam/testing/load_tests/sideinput_test.py", "diffHunk": "@@ -47,65 +49,154 @@\n or:\n \n ./gradlew -PloadTest.args=\"\n-    --publish_to_big_query=true\n-    --project=...\n-    --metrics_dataset=python_load_tests\n-    --metrics_table=side_input\n+    --side_input_type=iter\n     --input_options='{\n-      \\\"num_records\\\": 1,\n-      \\\"key_size\\\": 1,\n-      \\\"value_size\\\": 1}'\n-    --runner=DirectRunner\" \\\n+      \\\"num_records\\\": 300,\n+      \\\"key_size\\\": 5,\n+      \\\"value_size\\\": 15}'\" \\\n -PloadTest.mainClass=apache_beam.testing.load_tests.sideinput_test \\\n -Prunner=DirectRunner :sdks:python:apache_beam:testing:load_tests:run\n \"\"\"\n \n # pytype: skip-file\n \n from __future__ import absolute_import\n+from __future__ import division\n \n import logging\n \n import apache_beam as beam\n-from apache_beam.pvalue import AsIter\n from apache_beam.testing.load_tests.load_test import LoadTest\n from apache_beam.testing.load_tests.load_test_metrics_utils import MeasureTime\n from apache_beam.testing.synthetic_pipeline import SyntheticSource\n \n \n class SideInputTest(LoadTest):\n+  SIDE_INPUT_TYPES = {\n+      'iter': beam.pvalue.AsIter,\n+      'list': beam.pvalue.AsList,\n+      'dict': beam.pvalue.AsDict,\n+  }\n+\n   def __init__(self):\n     super(SideInputTest, self).__init__()\n-    self.iterations = self.get_option_or_default(\n-        'number_of_counter_operations', 1)\n+    self.windows = self.get_option_or_default('window_count', default=0)\n+    self.access_percentage = self.get_option_or_default(\n+        'access_percentage', default=100)\n+    if self.access_percentage < 0 or self.access_percentage > 100:\n+      raise ValueError(\n+          'access_percentage: Invalid value. Should be in range '\n+          'from 0 to 100, got {} instead'.format(self.access_percentage))\n+\n+    self.side_input_size = self.get_option_or_default(\n+        'side_input_size', default=0)\n+    if self.side_input_size == 0:\n+      self.side_input_size = self.input_options.get('num_records')\n+\n+    self.side_input_type = self.pipeline.get_option('side_input_type')\n+    if self.side_input_type is None:\n+      raise ValueError('side_input_type is required')\n+\n+  def materialize_as(self):\n+    try:\n+      return self.SIDE_INPUT_TYPES[self.side_input_type]\n+    except KeyError:\n+      raise ValueError(\n+          'Unknown side input type. You have to provide one of '\n+          'these: {}'.format(list(self.SIDE_INPUT_TYPES.keys())))\n \n   def test(self):\n-    def join_fn(element, side_input, iterations):\n-      result = []\n-      for i in range(iterations):\n-        for key, value in side_input:\n-          if i == iterations - 1:\n-            result.append({key: element[1] + value})\n-      yield result\n-\n-    main_input = (\n+    class SequenceSideInputTestDoFn(beam.DoFn):\n+      \"\"\"Iterate over first n side_input elements. Iterate over all\n+      elements if `first_n` is :data:`None`.\"\"\"\n+      def __init__(self, first_n=None):\n+        self._first_n = first_n\n+\n+      def process(self, unused_element, side_input):\n+        for i, _ in enumerate(side_input):\n+          if self._first_n and i >= self._first_n:\n+            return\n+          # No-op. We only make sure that the element is accessed.\n+\n+    class MappingSideInputTestDoFn(beam.DoFn):\n+      \"\"\"Take a sequence of keys as an additional side input and for each\n+      key in the sequence checks the value for key in the dictionary.\"\"\"\n+      def process(self, unused_element, dict_side_input, keys_to_check):\n+        for key in keys_to_check:\n+          # No-op. We only make sure that the element is accessed.\n+          dict_side_input[key]\n+\n+    class GetRandomKeys(beam.DoFn):\n+      def __init__(self, n):\n+        self._n = n\n+\n+      def process(self, unused_element, dict_side_input):\n+        import random\n+        n = min(self._n, len(dict_side_input))\n+        return random.sample(dict_side_input.keys(), n)\n+\n+    class AddEventTimestamps(beam.DoFn):\n+      \"\"\"Assign timestamp to each element of PCollection, starting from the\n+      current Unix seconds-since-epoch timestamp.\"\"\"\n+      def setup(self):\n+        import time\n+        self.current_time = int(time.time())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyOTUyNQ=="}, "originalCommit": {"oid": "5f19191e09b1ae251e4a4b003a2aa94b80fa4b7c"}, "originalPosition": 163}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1654, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}