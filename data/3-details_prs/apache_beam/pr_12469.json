{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMDcyNTM2", "number": 12469, "title": "[BEAM-9547] Lift associative aggregations.", "bodyText": "Also fix issue with inputs getting used in downstream stages.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-08-05T00:10:43Z", "url": "https://github.com/apache/beam/pull/12469", "merged": true, "mergeCommit": {"oid": "198a583c140a34211fbeb9cb43d8692cf8bf1cd5"}, "closed": true, "closedAt": "2020-08-13T19:16:37Z", "author": {"login": "robertwb"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7vzubgH2gAyNDYzMDcyNTM2OjA4NThmMjlkZjY4MWI2ZTM1MzhiNTc5M2JkMjk3MzllZmZkY2FiZWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-isyqgH2gAyNDYzMDcyNTM2OjIzOGQxZTU1MzQzYjM4NDk3MmU4NTJjMWI1OGMwMDhmZmEzMDc0MGE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0858f29df681b6e3538b5793bd29739effdcabed", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/0858f29df681b6e3538b5793bd29739effdcabed", "committedDate": "2020-08-05T00:09:39Z", "message": "[BEAM-9547] Lift associative aggregations.\n\nAlso fix issue with inputs getting used in downstream stages."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a169fd059670561fe925c79b77d06b4e40c33d5", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/7a169fd059670561fe925c79b77d06b4e40c33d5", "committedDate": "2020-08-05T23:38:23Z", "message": "fix lint, py 3.5 issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d24e048925ae6c787735925b7001ac8e2f204c77", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/d24e048925ae6c787735925b7001ac8e2f204c77", "committedDate": "2020-08-05T23:41:36Z", "message": "Merge branch 'master' into dataframes-agg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6", "committedDate": "2020-08-05T23:43:01Z", "message": "cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzkxODM4", "url": "https://github.com/apache/beam/pull/12469#pullrequestreview-465391838", "createdAt": "2020-08-11T20:10:05Z", "commit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDoxMDowNVrOG_Hdnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNzowNzoxMlrOG_qj8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzNTc0Mw==", "bodyText": "Would it be reasonable to re-order the columns by name when asserting equality?", "url": "https://github.com/apache/beam/pull/12469#discussion_r468835743", "createdAt": "2020-08-11T20:10:05Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames_test.py", "diffHunk": "@@ -80,6 +81,24 @@ def test_loc(self):\n     self._run_test(lambda df: df.loc[df.A > 10], df)\n     self._run_test(lambda df: df.loc[lambda df: df.A > 10], df)\n \n+  def test_series_agg(self):\n+    s = pd.Series(list(range(16)))\n+    self._run_test(lambda s: s.agg('sum'), s)\n+    self._run_test(lambda s: s.agg(['sum']), s)\n+    self._run_test(lambda s: s.agg(['sum', 'mean']), s)\n+    self._run_test(lambda s: s.agg(['mean']), s)\n+    self._run_test(lambda s: s.agg('mean'), s)\n+\n+  @unittest.skipIf(sys.version_info < (3, 6), 'Nondeterministic dict ordering.')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwODI3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for arg in expr.args():\n          \n          \n            \n                    if arg in inputs:\n          \n          \n            \n                      stage.inputs.add(arg)\n          \n          \n            \n                  # Ensure that any inputs for the overall transform are added in downstream stages\n          \n          \n            \n                  for arg in expr.args():\n          \n          \n            \n                    if arg in inputs:\n          \n          \n            \n                      stage.inputs.add(arg)", "url": "https://github.com/apache/beam/pull/12469#discussion_r469408273", "createdAt": "2020-08-12T17:02:48Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -244,6 +261,9 @@ def expr_to_stages(expr):\n             # It also must be declared as an output of the producing stage.\n             expr_to_stage(arg).outputs.add(arg)\n       stage.ops.append(expr)\n+      for arg in expr.args():\n+        if arg in inputs:\n+          stage.inputs.add(arg)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwOTg0MQ==", "bodyText": "Could you add some comments describing the case each if is handling? I had a hard time making sense of them all", "url": "https://github.com/apache/beam/pull/12469#discussion_r469409841", "createdAt": "2020-08-12T17:05:33Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -150,35 +164,79 @@ def at(self, *args, **kwargs):\n   def loc(self):\n     return _DeferredLoc(self)\n \n-  @frame_base.args_to_kwargs(pd.DataFrame)\n-  @frame_base.populate_defaults(pd.DataFrame)\n-  def aggregate(self, axis, **kwargs):\n+  def aggregate(self, func, axis=0, *args, **kwargs):\n     if axis is None:\n-      return self.agg(axis=1, **kwargs).agg(axis=0, **kwargs)\n-    return frame_base.DeferredFrame.wrap(\n+      return self.agg(func, *args, **dict(kwargs, axis=1)).agg(\n+          func, *args, **dict(kwargs, axis=0))\n+    elif axis in (1, 'columns'):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'aggregate',\n+              lambda df: df.agg(func, axis=1, *args, **kwargs),\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing()))\n+    elif len(self._expr.proxy().columns) == 0 or args or kwargs:\n+      return frame_base.DeferredFrame.wrap(\n         expressions.ComputedExpression(\n             'aggregate',\n-            lambda df: df.agg(axis=axis, **kwargs),\n+            lambda df: df.agg(func, *args, **kwargs),\n             [self._expr],\n-            # TODO(robertwb): Sub-aggregate when possible.\n             requires_partition_by=partitionings.Singleton()))\n+    else:\n+      if not isinstance(func, dict):\n+        col_names = list(self._expr.proxy().columns)\n+        func = {col: func for col in col_names}\n+      else:\n+        col_names = list(func.keys())\n+      aggregated_cols = []\n+      for col in col_names:\n+        funcs = func[col]\n+        if not isinstance(funcs, list):\n+          funcs = [funcs]\n+        aggregated_cols.append(self[col].agg(funcs, *args, **kwargs))\n+      if any(isinstance(funcs, list) for funcs in func.values()):\n+        return frame_base.DeferredFrame.wrap(\n+            expressions.ComputedExpression(\n+                'join_aggregate',\n+                lambda *cols: pd.DataFrame(\n+                    {col: value for col, value in zip(col_names, cols)}),\n+                [col._expr for col in aggregated_cols]))\n+      else:\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+                lambda *cols: pd.Series(\n+                    {col: value[0] for col, value in zip(col_names, cols)}),\n+              [col._expr for col in aggregated_cols],\n+              proxy=self._expr.proxy().agg(func, *args, **kwargs)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDEzNA==", "bodyText": "Here as well", "url": "https://github.com/apache/beam/pull/12469#discussion_r469410134", "createdAt": "2020-08-12T17:06:02Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -35,20 +35,34 @@ def __array__(self, dtype=None):\n   transform = frame_base._elementwise_method(\n       'transform', restrictions={'axis': 0})\n \n-  def agg(self, *args, **kwargs):\n-    return frame_base.DeferredFrame.wrap(\n-        expressions.ComputedExpression(\n-            'agg',\n-            lambda df: df.agg(*args, **kwargs), [self._expr],\n-            preserves_partition_by=partitionings.Singleton(),\n-            requires_partition_by=partitionings.Singleton()))\n-\n-  all = frame_base._associative_agg_method('all')\n-  any = frame_base._associative_agg_method('any')\n-  min = frame_base._associative_agg_method('min')\n-  max = frame_base._associative_agg_method('max')\n-  prod = product = frame_base._associative_agg_method('prod')\n-  sum = frame_base._associative_agg_method('sum')\n+  def agg(self, func, axis=0, *args, **kwargs):\n+    if isinstance(func, list) and len(func) > 1:\n+      rows = [self.agg([f], *args, **kwargs) for f in func]\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+              lambda *rows: pd.concat(rows), [row._expr for row in rows]))\n+    else:\n+      base_func = func[0] if isinstance(func, list) else func\n+      if _is_associative(base_func) and not args and not kwargs:\n+        intermediate = expressions.elementwise_expression(\n+            'pre_agg',\n+            lambda s: s.agg([base_func], *args, **kwargs), [self._expr])\n+      else:\n+        intermediate = self._expr\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'agg',\n+              lambda s: s.agg(func, *args, **kwargs), [intermediate],\n+              preserves_partition_by=partitionings.Singleton(),\n+              requires_partition_by=partitionings.Singleton()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDgwMA==", "bodyText": "I think we're missing this alias in Series", "url": "https://github.com/apache/beam/pull/12469#discussion_r469410800", "createdAt": "2020-08-12T17:07:12Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -150,35 +164,79 @@ def at(self, *args, **kwargs):\n   def loc(self):\n     return _DeferredLoc(self)\n \n-  @frame_base.args_to_kwargs(pd.DataFrame)\n-  @frame_base.populate_defaults(pd.DataFrame)\n-  def aggregate(self, axis, **kwargs):\n+  def aggregate(self, func, axis=0, *args, **kwargs):\n     if axis is None:\n-      return self.agg(axis=1, **kwargs).agg(axis=0, **kwargs)\n-    return frame_base.DeferredFrame.wrap(\n+      return self.agg(func, *args, **dict(kwargs, axis=1)).agg(\n+          func, *args, **dict(kwargs, axis=0))\n+    elif axis in (1, 'columns'):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'aggregate',\n+              lambda df: df.agg(func, axis=1, *args, **kwargs),\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing()))\n+    elif len(self._expr.proxy().columns) == 0 or args or kwargs:\n+      return frame_base.DeferredFrame.wrap(\n         expressions.ComputedExpression(\n             'aggregate',\n-            lambda df: df.agg(axis=axis, **kwargs),\n+            lambda df: df.agg(func, *args, **kwargs),\n             [self._expr],\n-            # TODO(robertwb): Sub-aggregate when possible.\n             requires_partition_by=partitionings.Singleton()))\n+    else:\n+      if not isinstance(func, dict):\n+        col_names = list(self._expr.proxy().columns)\n+        func = {col: func for col in col_names}\n+      else:\n+        col_names = list(func.keys())\n+      aggregated_cols = []\n+      for col in col_names:\n+        funcs = func[col]\n+        if not isinstance(funcs, list):\n+          funcs = [funcs]\n+        aggregated_cols.append(self[col].agg(funcs, *args, **kwargs))\n+      if any(isinstance(funcs, list) for funcs in func.values()):\n+        return frame_base.DeferredFrame.wrap(\n+            expressions.ComputedExpression(\n+                'join_aggregate',\n+                lambda *cols: pd.DataFrame(\n+                    {col: value for col, value in zip(col_names, cols)}),\n+                [col._expr for col in aggregated_cols]))\n+      else:\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+                lambda *cols: pd.Series(\n+                    {col: value[0] for col, value in zip(col_names, cols)}),\n+              [col._expr for col in aggregated_cols],\n+              proxy=self._expr.proxy().agg(func, *args, **kwargs)))\n \n   agg = aggregate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afaf3e67be30b0324d40dc85e78cc69b9608365d", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/afaf3e67be30b0324d40dc85e78cc69b9608365d", "committedDate": "2020-08-13T00:17:29Z", "message": "fixup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzU5NTIy", "url": "https://github.com/apache/beam/pull/12469#pullrequestreview-466359522", "createdAt": "2020-08-13T00:14:55Z", "commit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMDoxNDo1NVrOG_3IeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMDoxNzowMFrOG_3K0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNjc2MQ==", "bodyText": "Column ordering seems to be a fairly fundamental property of dataframes that I'd prefer to check in general, and 3.5 won't be supported for long.", "url": "https://github.com/apache/beam/pull/12469#discussion_r469616761", "createdAt": "2020-08-13T00:14:55Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames_test.py", "diffHunk": "@@ -80,6 +81,24 @@ def test_loc(self):\n     self._run_test(lambda df: df.loc[df.A > 10], df)\n     self._run_test(lambda df: df.loc[lambda df: df.A > 10], df)\n \n+  def test_series_agg(self):\n+    s = pd.Series(list(range(16)))\n+    self._run_test(lambda s: s.agg('sum'), s)\n+    self._run_test(lambda s: s.agg(['sum']), s)\n+    self._run_test(lambda s: s.agg(['sum', 'mean']), s)\n+    self._run_test(lambda s: s.agg(['mean']), s)\n+    self._run_test(lambda s: s.agg('mean'), s)\n+\n+  @unittest.skipIf(sys.version_info < (3, 6), 'Nondeterministic dict ordering.')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzNTc0Mw=="}, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzA1OA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617058", "createdAt": "2020-08-13T00:16:07Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -244,6 +261,9 @@ def expr_to_stages(expr):\n             # It also must be declared as an output of the producing stage.\n             expr_to_stage(arg).outputs.add(arg)\n       stage.ops.append(expr)\n+      for arg in expr.args():\n+        if arg in inputs:\n+          stage.inputs.add(arg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwODI3Mw=="}, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzI4Ng==", "bodyText": "Good call. Done.", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617286", "createdAt": "2020-08-13T00:16:52Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -150,35 +164,79 @@ def at(self, *args, **kwargs):\n   def loc(self):\n     return _DeferredLoc(self)\n \n-  @frame_base.args_to_kwargs(pd.DataFrame)\n-  @frame_base.populate_defaults(pd.DataFrame)\n-  def aggregate(self, axis, **kwargs):\n+  def aggregate(self, func, axis=0, *args, **kwargs):\n     if axis is None:\n-      return self.agg(axis=1, **kwargs).agg(axis=0, **kwargs)\n-    return frame_base.DeferredFrame.wrap(\n+      return self.agg(func, *args, **dict(kwargs, axis=1)).agg(\n+          func, *args, **dict(kwargs, axis=0))\n+    elif axis in (1, 'columns'):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'aggregate',\n+              lambda df: df.agg(func, axis=1, *args, **kwargs),\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing()))\n+    elif len(self._expr.proxy().columns) == 0 or args or kwargs:\n+      return frame_base.DeferredFrame.wrap(\n         expressions.ComputedExpression(\n             'aggregate',\n-            lambda df: df.agg(axis=axis, **kwargs),\n+            lambda df: df.agg(func, *args, **kwargs),\n             [self._expr],\n-            # TODO(robertwb): Sub-aggregate when possible.\n             requires_partition_by=partitionings.Singleton()))\n+    else:\n+      if not isinstance(func, dict):\n+        col_names = list(self._expr.proxy().columns)\n+        func = {col: func for col in col_names}\n+      else:\n+        col_names = list(func.keys())\n+      aggregated_cols = []\n+      for col in col_names:\n+        funcs = func[col]\n+        if not isinstance(funcs, list):\n+          funcs = [funcs]\n+        aggregated_cols.append(self[col].agg(funcs, *args, **kwargs))\n+      if any(isinstance(funcs, list) for funcs in func.values()):\n+        return frame_base.DeferredFrame.wrap(\n+            expressions.ComputedExpression(\n+                'join_aggregate',\n+                lambda *cols: pd.DataFrame(\n+                    {col: value for col, value in zip(col_names, cols)}),\n+                [col._expr for col in aggregated_cols]))\n+      else:\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+                lambda *cols: pd.Series(\n+                    {col: value[0] for col, value in zip(col_names, cols)}),\n+              [col._expr for col in aggregated_cols],\n+              proxy=self._expr.proxy().agg(func, *args, **kwargs)))\n \n   agg = aggregate", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDgwMA=="}, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzMyMw==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617323", "createdAt": "2020-08-13T00:16:56Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -150,35 +164,79 @@ def at(self, *args, **kwargs):\n   def loc(self):\n     return _DeferredLoc(self)\n \n-  @frame_base.args_to_kwargs(pd.DataFrame)\n-  @frame_base.populate_defaults(pd.DataFrame)\n-  def aggregate(self, axis, **kwargs):\n+  def aggregate(self, func, axis=0, *args, **kwargs):\n     if axis is None:\n-      return self.agg(axis=1, **kwargs).agg(axis=0, **kwargs)\n-    return frame_base.DeferredFrame.wrap(\n+      return self.agg(func, *args, **dict(kwargs, axis=1)).agg(\n+          func, *args, **dict(kwargs, axis=0))\n+    elif axis in (1, 'columns'):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'aggregate',\n+              lambda df: df.agg(func, axis=1, *args, **kwargs),\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing()))\n+    elif len(self._expr.proxy().columns) == 0 or args or kwargs:\n+      return frame_base.DeferredFrame.wrap(\n         expressions.ComputedExpression(\n             'aggregate',\n-            lambda df: df.agg(axis=axis, **kwargs),\n+            lambda df: df.agg(func, *args, **kwargs),\n             [self._expr],\n-            # TODO(robertwb): Sub-aggregate when possible.\n             requires_partition_by=partitionings.Singleton()))\n+    else:\n+      if not isinstance(func, dict):\n+        col_names = list(self._expr.proxy().columns)\n+        func = {col: func for col in col_names}\n+      else:\n+        col_names = list(func.keys())\n+      aggregated_cols = []\n+      for col in col_names:\n+        funcs = func[col]\n+        if not isinstance(funcs, list):\n+          funcs = [funcs]\n+        aggregated_cols.append(self[col].agg(funcs, *args, **kwargs))\n+      if any(isinstance(funcs, list) for funcs in func.values()):\n+        return frame_base.DeferredFrame.wrap(\n+            expressions.ComputedExpression(\n+                'join_aggregate',\n+                lambda *cols: pd.DataFrame(\n+                    {col: value for col, value in zip(col_names, cols)}),\n+                [col._expr for col in aggregated_cols]))\n+      else:\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+                lambda *cols: pd.Series(\n+                    {col: value[0] for col, value in zip(col_names, cols)}),\n+              [col._expr for col in aggregated_cols],\n+              proxy=self._expr.proxy().agg(func, *args, **kwargs)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwOTg0MQ=="}, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzM2Mg==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617362", "createdAt": "2020-08-13T00:17:00Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -35,20 +35,34 @@ def __array__(self, dtype=None):\n   transform = frame_base._elementwise_method(\n       'transform', restrictions={'axis': 0})\n \n-  def agg(self, *args, **kwargs):\n-    return frame_base.DeferredFrame.wrap(\n-        expressions.ComputedExpression(\n-            'agg',\n-            lambda df: df.agg(*args, **kwargs), [self._expr],\n-            preserves_partition_by=partitionings.Singleton(),\n-            requires_partition_by=partitionings.Singleton()))\n-\n-  all = frame_base._associative_agg_method('all')\n-  any = frame_base._associative_agg_method('any')\n-  min = frame_base._associative_agg_method('min')\n-  max = frame_base._associative_agg_method('max')\n-  prod = product = frame_base._associative_agg_method('prod')\n-  sum = frame_base._associative_agg_method('sum')\n+  def agg(self, func, axis=0, *args, **kwargs):\n+    if isinstance(func, list) and len(func) > 1:\n+      rows = [self.agg([f], *args, **kwargs) for f in func]\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+              lambda *rows: pd.concat(rows), [row._expr for row in rows]))\n+    else:\n+      base_func = func[0] if isinstance(func, list) else func\n+      if _is_associative(base_func) and not args and not kwargs:\n+        intermediate = expressions.elementwise_expression(\n+            'pre_agg',\n+            lambda s: s.agg([base_func], *args, **kwargs), [self._expr])\n+      else:\n+        intermediate = self._expr\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'agg',\n+              lambda s: s.agg(func, *args, **kwargs), [intermediate],\n+              preserves_partition_by=partitionings.Singleton(),\n+              requires_partition_by=partitionings.Singleton()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDEzNA=="}, "originalCommit": {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b101ee22a485405aabc50ded1c6fb8bfd8bd69e9", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/b101ee22a485405aabc50ded1c6fb8bfd8bd69e9", "committedDate": "2020-08-13T16:23:54Z", "message": "Merge branch 'master' into dataframes-agg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "238d1e55343b384972e852c1b58c008ffa30740a", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/238d1e55343b384972e852c1b58c008ffa30740a", "committedDate": "2020-08-13T16:35:05Z", "message": "merge and update wrt non-parallel-operations decorator and check"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3724, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}