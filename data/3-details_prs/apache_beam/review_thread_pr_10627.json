{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MTY4Mzc2", "number": 10627, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDoxODozNVrODbtQdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMjo0Mjo1MlrODdgdiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzc5NjM3OnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDoxODozNVrOFjWQJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNzo1MzoxNlrOFj0Qtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwOTA2MA==", "bodyText": "I'm not sure that we need withOutputTimestampOffset - I think withOutputTimestamp is sufficient.", "url": "https://github.com/apache/beam/pull/10627#discussion_r372609060", "createdAt": "2020-01-29T20:18:35Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1074,6 +1075,12 @@ public Timer withOutputTimestamp(Instant outputTimestamp) {\n       return this;\n     }\n \n+    @Override\n+    public Timer withOutputTimestampOffset(Duration outputTimestampOffset) {\n+      this.outputTimestampOffset = outputTimestampOffset;\n+      return this;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa1a9386b4e9a0c7ce321f732f2c16677a9e773e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEwMDcyNg==", "bodyText": "@reuvenlax  done", "url": "https://github.com/apache/beam/pull/10627#discussion_r373100726", "createdAt": "2020-01-30T17:53:16Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1074,6 +1075,12 @@ public Timer withOutputTimestamp(Instant outputTimestamp) {\n       return this;\n     }\n \n+    @Override\n+    public Timer withOutputTimestampOffset(Duration outputTimestampOffset) {\n+      this.outputTimestampOffset = outputTimestampOffset;\n+      return this;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwOTA2MA=="}, "originalCommit": {"oid": "aa1a9386b4e9a0c7ce321f732f2c16677a9e773e"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzgwNjkzOnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDoyMjoyM1rOFjWWqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxODoxOTo1OFrOFj1CEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYxMDczMQ==", "bodyText": "I think that we should verify that the output timestamp is > the timestamp of the input message (if in processElement) or the output timestamp of the firing timer (if in processTimer). The < check remains correct - even for processing-time timers.", "url": "https://github.com/apache/beam/pull/10627#discussion_r372610731", "createdAt": "2020-01-29T20:22:23Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1092,15 +1099,19 @@ private void verifyAbsoluteTimeDomain() {\n      * </ul>\n      */\n     private void setAndVerifyOutputTimestamp() {\n-      // Output timestamp is currently not supported in processing time timers.\n-      if (outputTimestamp != null && !TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        throw new IllegalStateException(\"Cannot set outputTimestamp in processing time domain.\");\n-      }\n+\n       // Output timestamp is set to the delivery time if not initialized by an user.\n-      if (outputTimestamp == null) {\n+      if (outputTimestamp == null && TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n         outputTimestamp = target;\n       }\n \n+      if (TimeDomain.PROCESSING_TIME.equals(spec.getTimeDomain())) {\n+        outputTimestamp =\n+            outputTimestampOffset.equals(Duration.ZERO)\n+                ? target\n+                : target.minus(offset.minus(outputTimestampOffset));\n+      }\n+\n       if (TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa1a9386b4e9a0c7ce321f732f2c16677a9e773e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEwMDY4MQ==", "bodyText": "@reuvenlax , does that mean we need to compare output timestamp with timerInternal.currentInputWatermarkTime()? I think it will fail our previous test case of output timestamp with event timer as we have set output timestamp as 5 while having a timestamp of input element as 9.", "url": "https://github.com/apache/beam/pull/10627#discussion_r373100681", "createdAt": "2020-01-30T17:53:11Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1092,15 +1099,19 @@ private void verifyAbsoluteTimeDomain() {\n      * </ul>\n      */\n     private void setAndVerifyOutputTimestamp() {\n-      // Output timestamp is currently not supported in processing time timers.\n-      if (outputTimestamp != null && !TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        throw new IllegalStateException(\"Cannot set outputTimestamp in processing time domain.\");\n-      }\n+\n       // Output timestamp is set to the delivery time if not initialized by an user.\n-      if (outputTimestamp == null) {\n+      if (outputTimestamp == null && TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n         outputTimestamp = target;\n       }\n \n+      if (TimeDomain.PROCESSING_TIME.equals(spec.getTimeDomain())) {\n+        outputTimestamp =\n+            outputTimestampOffset.equals(Duration.ZERO)\n+                ? target\n+                : target.minus(offset.minus(outputTimestampOffset));\n+      }\n+\n       if (TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYxMDczMQ=="}, "originalCommit": {"oid": "aa1a9386b4e9a0c7ce321f732f2c16677a9e773e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzExMzM2MQ==", "bodyText": "@reuvenlax  done", "url": "https://github.com/apache/beam/pull/10627#discussion_r373113361", "createdAt": "2020-01-30T18:19:58Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1092,15 +1099,19 @@ private void verifyAbsoluteTimeDomain() {\n      * </ul>\n      */\n     private void setAndVerifyOutputTimestamp() {\n-      // Output timestamp is currently not supported in processing time timers.\n-      if (outputTimestamp != null && !TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        throw new IllegalStateException(\"Cannot set outputTimestamp in processing time domain.\");\n-      }\n+\n       // Output timestamp is set to the delivery time if not initialized by an user.\n-      if (outputTimestamp == null) {\n+      if (outputTimestamp == null && TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n         outputTimestamp = target;\n       }\n \n+      if (TimeDomain.PROCESSING_TIME.equals(spec.getTimeDomain())) {\n+        outputTimestamp =\n+            outputTimestampOffset.equals(Duration.ZERO)\n+                ? target\n+                : target.minus(offset.minus(outputTimestampOffset));\n+      }\n+\n       if (TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYxMDczMQ=="}, "originalCommit": {"oid": "aa1a9386b4e9a0c7ce321f732f2c16677a9e773e"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzgwOTAxOnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDoyMzoxMVrOFjWX8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxODoyMDowN1rOFj1CZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYxMTA1OQ==", "bodyText": "I think that if the timer is processing time, then then default outputTimestamp should be that of the input element (or the output time of the firing timer if in processTimer).", "url": "https://github.com/apache/beam/pull/10627#discussion_r372611059", "createdAt": "2020-01-29T20:23:11Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1092,15 +1099,19 @@ private void verifyAbsoluteTimeDomain() {\n      * </ul>\n      */\n     private void setAndVerifyOutputTimestamp() {\n-      // Output timestamp is currently not supported in processing time timers.\n-      if (outputTimestamp != null && !TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        throw new IllegalStateException(\"Cannot set outputTimestamp in processing time domain.\");\n-      }\n+\n       // Output timestamp is set to the delivery time if not initialized by an user.\n-      if (outputTimestamp == null) {\n+      if (outputTimestamp == null && TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n         outputTimestamp = target;\n       }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa1a9386b4e9a0c7ce321f732f2c16677a9e773e"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzExMzQ0Nw==", "bodyText": "@reuvenlax  done", "url": "https://github.com/apache/beam/pull/10627#discussion_r373113447", "createdAt": "2020-01-30T18:20:07Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1092,15 +1099,19 @@ private void verifyAbsoluteTimeDomain() {\n      * </ul>\n      */\n     private void setAndVerifyOutputTimestamp() {\n-      // Output timestamp is currently not supported in processing time timers.\n-      if (outputTimestamp != null && !TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        throw new IllegalStateException(\"Cannot set outputTimestamp in processing time domain.\");\n-      }\n+\n       // Output timestamp is set to the delivery time if not initialized by an user.\n-      if (outputTimestamp == null) {\n+      if (outputTimestamp == null && TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n         outputTimestamp = target;\n       }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYxMTA1OQ=="}, "originalCommit": {"oid": "aa1a9386b4e9a0c7ce321f732f2c16677a9e773e"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzM1Mjc1OnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDoxMzo0MlrOFj4gCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNjowMDoxNFrOFkP6BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MDE4Nw==", "bodyText": "I think this should be timestamp(), not fireTimestamp().", "url": "https://github.com/apache/beam/pull/10627#discussion_r373170187", "createdAt": "2020-01-30T20:13:42Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -930,7 +935,7 @@ public Timer timer(String timerId) {\n       try {\n         TimerSpec spec = (TimerSpec) signature.timerDeclarations().get(timerId).field().get(fn);\n         return new TimerInternalsTimer(\n-            window, getNamespace(), timerId, spec, stepContext.timerInternals());\n+            window, getNamespace(), timerId, spec, fireTimestamp(), stepContext.timerInternals());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU1MzY2OA==", "bodyText": "@reuvenlax  done", "url": "https://github.com/apache/beam/pull/10627#discussion_r373553668", "createdAt": "2020-01-31T16:00:14Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -930,7 +935,7 @@ public Timer timer(String timerId) {\n       try {\n         TimerSpec spec = (TimerSpec) signature.timerDeclarations().get(timerId).field().get(fn);\n         return new TimerInternalsTimer(\n-            window, getNamespace(), timerId, spec, stepContext.timerInternals());\n+            window, getNamespace(), timerId, spec, fireTimestamp(), stepContext.timerInternals());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MDE4Nw=="}, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzM1MzY2OnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDoxMzo1N1rOFj4gjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNjowMDoyMVrOFkP6QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MDMxNg==", "bodyText": "ditto - this should be timestamp() not fireTimestamp()", "url": "https://github.com/apache/beam/pull/10627#discussion_r373170316", "createdAt": "2020-01-30T20:13:57Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -942,7 +947,12 @@ public TimerMap timerFamily(String timerFamilyId) {\n         TimerSpec spec =\n             (TimerSpec) signature.timerFamilyDeclarations().get(timerFamilyId).field().get(fn);\n         return new TimerInternalsTimerMap(\n-            timerFamilyId, window(), getNamespace(), spec, stepContext.timerInternals());\n+            timerFamilyId,\n+            window(),\n+            getNamespace(),\n+            spec,\n+            fireTimestamp(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU1MzcyOA==", "bodyText": "done", "url": "https://github.com/apache/beam/pull/10627#discussion_r373553728", "createdAt": "2020-01-31T16:00:21Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -942,7 +947,12 @@ public TimerMap timerFamily(String timerFamilyId) {\n         TimerSpec spec =\n             (TimerSpec) signature.timerFamilyDeclarations().get(timerFamilyId).field().get(fn);\n         return new TimerInternalsTimerMap(\n-            timerFamilyId, window(), getNamespace(), spec, stepContext.timerInternals());\n+            timerFamilyId,\n+            window(),\n+            getNamespace(),\n+            spec,\n+            fireTimestamp(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MDMxNg=="}, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzM1ODQ5OnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDoxNTozOVrOFj4jhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNjowMDo1OVrOFkP7ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MTA3Ng==", "bodyText": "check outputTimestamp is in the window for processing-timer as well.", "url": "https://github.com/apache/beam/pull/10627#discussion_r373171076", "createdAt": "2020-01-30T20:15:39Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1092,14 +1107,25 @@ private void verifyAbsoluteTimeDomain() {\n      * </ul>\n      */\n     private void setAndVerifyOutputTimestamp() {\n-      // Output timestamp is currently not supported in processing time timers.\n-      if (outputTimestamp != null && !TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        throw new IllegalStateException(\"Cannot set outputTimestamp in processing time domain.\");\n-      }\n+\n       // Output timestamp is set to the delivery time if not initialized by an user.\n-      if (outputTimestamp == null) {\n+      if (outputTimestamp == null && TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n         outputTimestamp = target;\n       }\n+      // For processing timers\n+      if (outputTimestamp == null) {\n+        // For processing timers output timestamp will be:\n+        // 1) timestamp of input element\n+        // OR\n+        // 2) output timestamp of firing timer.\n+        outputTimestamp = elementInputTimestamp;\n+      }\n+\n+      checkArgument(\n+          !outputTimestamp.isBefore(elementInputTimestamp),\n+          \"output timestamp %s should be after input message timestamp or output timestamp of firing timers %s\",\n+          outputTimestamp,\n+          elementInputTimestamp);\n \n       if (TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU1NDA0Mw==", "bodyText": "@reuvenlax done", "url": "https://github.com/apache/beam/pull/10627#discussion_r373554043", "createdAt": "2020-01-31T16:00:59Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1092,14 +1107,25 @@ private void verifyAbsoluteTimeDomain() {\n      * </ul>\n      */\n     private void setAndVerifyOutputTimestamp() {\n-      // Output timestamp is currently not supported in processing time timers.\n-      if (outputTimestamp != null && !TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        throw new IllegalStateException(\"Cannot set outputTimestamp in processing time domain.\");\n-      }\n+\n       // Output timestamp is set to the delivery time if not initialized by an user.\n-      if (outputTimestamp == null) {\n+      if (outputTimestamp == null && TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n         outputTimestamp = target;\n       }\n+      // For processing timers\n+      if (outputTimestamp == null) {\n+        // For processing timers output timestamp will be:\n+        // 1) timestamp of input element\n+        // OR\n+        // 2) output timestamp of firing timer.\n+        outputTimestamp = elementInputTimestamp;\n+      }\n+\n+      checkArgument(\n+          !outputTimestamp.isBefore(elementInputTimestamp),\n+          \"output timestamp %s should be after input message timestamp or output timestamp of firing timers %s\",\n+          outputTimestamp,\n+          elementInputTimestamp);\n \n       if (TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MTA3Ng=="}, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzM2NDUyOnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDoxNzo0NlrOFj4nIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNjowMjowOFrOFkP9vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MjAwMQ==", "bodyText": "I think you want the second DoFn to set an event-time timer. That way you can test that the watermark hold in the first DoFn prevents firing of the second DoFn's timer, which it will only do if the second DoFn's timer is even time.", "url": "https://github.com/apache/beam/pull/10627#discussion_r373172001", "createdAt": "2020-01-30T20:17:46Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -3806,6 +3807,90 @@ public void onTimer(\n       pipeline.run();\n     }\n \n+    @Test\n+    @Category({\n+      ValidatesRunner.class,\n+      UsesStatefulParDo.class,\n+      UsesTimersInParDo.class,\n+      UsesTestStreamWithProcessingTime.class,\n+      UsesTestStreamWithOutputTimestamp.class\n+    })\n+    public void testOutputTimestampWithProcessingTime() {\n+      final String timerId = \"foo\";\n+      DoFn<KV<String, Integer>, KV<String, Integer>> fn1 =\n+          new DoFn<KV<String, Integer>, KV<String, Integer>>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @Timestamp Instant timestamp,\n+                OutputReceiver<KV<String, Integer>> o) {\n+              timer\n+                  .withOutputTimestamp(timestamp.plus(Duration.standardSeconds(5)))\n+                  .offset(Duration.standardSeconds(10))\n+                  .setRelative();\n+              // Output a message. This will cause the next DoFn to set a timer as well.\n+              o.output(KV.of(\"foo\", 100));\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(OnTimerContext c, BoundedWindow w) {}\n+          };\n+\n+      DoFn<KV<String, Integer>, Integer> fn2 =\n+          new DoFn<KV<String, Integer>, Integer>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU1NDYyMA==", "bodyText": "@reuvenlax  updated", "url": "https://github.com/apache/beam/pull/10627#discussion_r373554620", "createdAt": "2020-01-31T16:02:08Z", "author": {"login": "rehmanmuradali"}, "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -3806,6 +3807,90 @@ public void onTimer(\n       pipeline.run();\n     }\n \n+    @Test\n+    @Category({\n+      ValidatesRunner.class,\n+      UsesStatefulParDo.class,\n+      UsesTimersInParDo.class,\n+      UsesTestStreamWithProcessingTime.class,\n+      UsesTestStreamWithOutputTimestamp.class\n+    })\n+    public void testOutputTimestampWithProcessingTime() {\n+      final String timerId = \"foo\";\n+      DoFn<KV<String, Integer>, KV<String, Integer>> fn1 =\n+          new DoFn<KV<String, Integer>, KV<String, Integer>>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @Timestamp Instant timestamp,\n+                OutputReceiver<KV<String, Integer>> o) {\n+              timer\n+                  .withOutputTimestamp(timestamp.plus(Duration.standardSeconds(5)))\n+                  .offset(Duration.standardSeconds(10))\n+                  .setRelative();\n+              // Output a message. This will cause the next DoFn to set a timer as well.\n+              o.output(KV.of(\"foo\", 100));\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(OnTimerContext c, BoundedWindow w) {}\n+          };\n+\n+      DoFn<KV<String, Integer>, Integer> fn2 =\n+          new DoFn<KV<String, Integer>, Integer>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3MjAwMQ=="}, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzM4MjI3OnYy", "diffSide": "RIGHT", "path": "runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDoyNDoxOFrOFj4yLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNjowMjo0MVrOFkP-xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3NDgyOQ==", "bodyText": "I don't think this is right. We want to fire timers based on firing time, not based on the hold.", "url": "https://github.com/apache/beam/pull/10627#discussion_r373174829", "createdAt": "2020-01-30T20:24:18Z", "author": {"login": "reuvenlax"}, "path": "runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java", "diffHunk": "@@ -676,7 +676,9 @@ private synchronized void updateTimers(TimerUpdate update) {\n       Map<StructuralKey<?>, List<TimerData>> firedTimers;\n       switch (domain) {\n         case PROCESSING_TIME:\n-          firedTimers = extractFiredTimers(firingTime, processingTimers);\n+          firedTimers =\n+              extractFiredTimers(\n+                  INSTANT_ORDERING.min(firingTime, earliestHold.get()), processingTimers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU1NDg4Nw==", "bodyText": "done", "url": "https://github.com/apache/beam/pull/10627#discussion_r373554887", "createdAt": "2020-01-31T16:02:41Z", "author": {"login": "rehmanmuradali"}, "path": "runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java", "diffHunk": "@@ -676,7 +676,9 @@ private synchronized void updateTimers(TimerUpdate update) {\n       Map<StructuralKey<?>, List<TimerData>> firedTimers;\n       switch (domain) {\n         case PROCESSING_TIME:\n-          firedTimers = extractFiredTimers(firingTime, processingTimers);\n+          firedTimers =\n+              extractFiredTimers(\n+                  INSTANT_ORDERING.min(firingTime, earliestHold.get()), processingTimers);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3NDgyOQ=="}, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzM4NDc4OnYy", "diffSide": "LEFT", "path": "runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDoyNToxNFrOFj4zzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNjowMzo0OVrOFkQBHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3NTI0NA==", "bodyText": "I wonder if this is sufficient. The NavigableSet is ordered by timer firing time, not by outputTimestamp. This means that the logic to just look at the first timer (which was correct before we had holds) is probably no longer enough. we probably need to iterate over the set (or we need to have a second data structure to hold the watermark holds and take the minimum of that data structure).", "url": "https://github.com/apache/beam/pull/10627#discussion_r373175244", "createdAt": "2020-01-30T20:25:14Z", "author": {"login": "reuvenlax"}, "path": "runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java", "diffHunk": "@@ -597,16 +597,16 @@ public synchronized Instant getEarliestTimerTimestamp() {\n       Instant earliest = THE_END_OF_TIME.get();\n       for (NavigableSet<TimerData> timers : processingTimers.values()) {\n         if (!timers.isEmpty()) {\n-          earliest = INSTANT_ORDERING.min(timers.first().getTimestamp(), earliest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU1NTQ4Ng==", "bodyText": "@reuvenlax  added a new function to calculate the earliest outputTimestamp from NavigableSet.", "url": "https://github.com/apache/beam/pull/10627#discussion_r373555486", "createdAt": "2020-01-31T16:03:49Z", "author": {"login": "rehmanmuradali"}, "path": "runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java", "diffHunk": "@@ -597,16 +597,16 @@ public synchronized Instant getEarliestTimerTimestamp() {\n       Instant earliest = THE_END_OF_TIME.get();\n       for (NavigableSet<TimerData> timers : processingTimers.values()) {\n         if (!timers.isEmpty()) {\n-          earliest = INSTANT_ORDERING.min(timers.first().getTimestamp(), earliest);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3NTI0NA=="}, "originalCommit": {"oid": "54e897759e7a07a92116a027e38f15db08d5f08d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTUwMTU2OnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwMDozODo0OFrOFkfmTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNzo0Mzo0NVrOFkgiMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgxMDc2NA==", "bodyText": "are we missing an else clause here?", "url": "https://github.com/apache/beam/pull/10627#discussion_r373810764", "createdAt": "2020-02-02T00:38:48Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1092,24 +1107,39 @@ private void verifyAbsoluteTimeDomain() {\n      * </ul>\n      */\n     private void setAndVerifyOutputTimestamp() {\n-      // Output timestamp is currently not supported in processing time timers.\n-      if (outputTimestamp != null && !TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        throw new IllegalStateException(\"Cannot set outputTimestamp in processing time domain.\");\n-      }\n+\n       // Output timestamp is set to the delivery time if not initialized by an user.\n-      if (outputTimestamp == null) {\n+      if (outputTimestamp == null && TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n         outputTimestamp = target;\n       }\n-\n-      if (TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        Instant windowExpiry = window.maxTimestamp().plus(allowedLateness);\n-        checkArgument(\n-            !target.isAfter(windowExpiry),\n-            \"Attempted to set event time timer that outputs for %s but that is\"\n-                + \" after the expiration of window %s\",\n-            target,\n-            windowExpiry);\n+      // For processing timers\n+      if (outputTimestamp == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c6b602e16407bc099673555bc72a45692d2b1ad"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyNjA5OQ==", "bodyText": "@reuvenlax  we only set outputTimestamp here. I think If that is already set before then we don't need anything. I think else clause is not required here.", "url": "https://github.com/apache/beam/pull/10627#discussion_r373826099", "createdAt": "2020-02-02T07:43:45Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1092,24 +1107,39 @@ private void verifyAbsoluteTimeDomain() {\n      * </ul>\n      */\n     private void setAndVerifyOutputTimestamp() {\n-      // Output timestamp is currently not supported in processing time timers.\n-      if (outputTimestamp != null && !TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        throw new IllegalStateException(\"Cannot set outputTimestamp in processing time domain.\");\n-      }\n+\n       // Output timestamp is set to the delivery time if not initialized by an user.\n-      if (outputTimestamp == null) {\n+      if (outputTimestamp == null && TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n         outputTimestamp = target;\n       }\n-\n-      if (TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        Instant windowExpiry = window.maxTimestamp().plus(allowedLateness);\n-        checkArgument(\n-            !target.isAfter(windowExpiry),\n-            \"Attempted to set event time timer that outputs for %s but that is\"\n-                + \" after the expiration of window %s\",\n-            target,\n-            windowExpiry);\n+      // For processing timers\n+      if (outputTimestamp == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgxMDc2NA=="}, "originalCommit": {"oid": "4c6b602e16407bc099673555bc72a45692d2b1ad"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTUxMjgxOnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwMToyMTowMFrOFkfr_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNzo0MToyNFrOFkghrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgxMjIyMA==", "bodyText": "final", "url": "https://github.com/apache/beam/pull/10627#discussion_r373812220", "createdAt": "2020-02-02T01:21:00Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -987,6 +997,7 @@ public void outputWithTimestamp(OutputT output, Instant timestamp) {\n     private final TimerSpec spec;\n     private Instant target;\n     private Instant outputTimestamp;\n+    private Instant elementInputTimestamp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c6b602e16407bc099673555bc72a45692d2b1ad"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyNTk2Nw==", "bodyText": "@reuvenlax  done", "url": "https://github.com/apache/beam/pull/10627#discussion_r373825967", "createdAt": "2020-02-02T07:41:24Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -987,6 +997,7 @@ public void outputWithTimestamp(OutputT output, Instant timestamp) {\n     private final TimerSpec spec;\n     private Instant target;\n     private Instant outputTimestamp;\n+    private Instant elementInputTimestamp;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgxMjIyMA=="}, "originalCommit": {"oid": "4c6b602e16407bc099673555bc72a45692d2b1ad"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTU0NzQ2OnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwMzozMzoyOVrOFkf89g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNzo0MTozNFrOFkghxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgxNjU2Ng==", "bodyText": "check this before setting outputTimestamp above (and only if outputTimestamp != null)", "url": "https://github.com/apache/beam/pull/10627#discussion_r373816566", "createdAt": "2020-02-02T03:33:29Z", "author": {"login": "reuvenlax"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1092,24 +1107,39 @@ private void verifyAbsoluteTimeDomain() {\n      * </ul>\n      */\n     private void setAndVerifyOutputTimestamp() {\n-      // Output timestamp is currently not supported in processing time timers.\n-      if (outputTimestamp != null && !TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        throw new IllegalStateException(\"Cannot set outputTimestamp in processing time domain.\");\n-      }\n+\n       // Output timestamp is set to the delivery time if not initialized by an user.\n-      if (outputTimestamp == null) {\n+      if (outputTimestamp == null && TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n         outputTimestamp = target;\n       }\n-\n-      if (TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        Instant windowExpiry = window.maxTimestamp().plus(allowedLateness);\n-        checkArgument(\n-            !target.isAfter(windowExpiry),\n-            \"Attempted to set event time timer that outputs for %s but that is\"\n-                + \" after the expiration of window %s\",\n-            target,\n-            windowExpiry);\n+      // For processing timers\n+      if (outputTimestamp == null) {\n+        // For processing timers output timestamp will be:\n+        // 1) timestamp of input element\n+        // OR\n+        // 2) output timestamp of firing timer.\n+        outputTimestamp = elementInputTimestamp;\n       }\n+\n+      checkArgument(\n+          !outputTimestamp.isBefore(elementInputTimestamp),\n+          \"output timestamp %s should be after input message timestamp or output timestamp of firing timers %s\",\n+          outputTimestamp,\n+          elementInputTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c6b602e16407bc099673555bc72a45692d2b1ad"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyNTk5MQ==", "bodyText": "@reuvenlax  done", "url": "https://github.com/apache/beam/pull/10627#discussion_r373825991", "createdAt": "2020-02-02T07:41:34Z", "author": {"login": "rehmanmuradali"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/SimpleDoFnRunner.java", "diffHunk": "@@ -1092,24 +1107,39 @@ private void verifyAbsoluteTimeDomain() {\n      * </ul>\n      */\n     private void setAndVerifyOutputTimestamp() {\n-      // Output timestamp is currently not supported in processing time timers.\n-      if (outputTimestamp != null && !TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        throw new IllegalStateException(\"Cannot set outputTimestamp in processing time domain.\");\n-      }\n+\n       // Output timestamp is set to the delivery time if not initialized by an user.\n-      if (outputTimestamp == null) {\n+      if (outputTimestamp == null && TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n         outputTimestamp = target;\n       }\n-\n-      if (TimeDomain.EVENT_TIME.equals(spec.getTimeDomain())) {\n-        Instant windowExpiry = window.maxTimestamp().plus(allowedLateness);\n-        checkArgument(\n-            !target.isAfter(windowExpiry),\n-            \"Attempted to set event time timer that outputs for %s but that is\"\n-                + \" after the expiration of window %s\",\n-            target,\n-            windowExpiry);\n+      // For processing timers\n+      if (outputTimestamp == null) {\n+        // For processing timers output timestamp will be:\n+        // 1) timestamp of input element\n+        // OR\n+        // 2) output timestamp of firing timer.\n+        outputTimestamp = elementInputTimestamp;\n       }\n+\n+      checkArgument(\n+          !outputTimestamp.isBefore(elementInputTimestamp),\n+          \"output timestamp %s should be after input message timestamp or output timestamp of firing timers %s\",\n+          outputTimestamp,\n+          elementInputTimestamp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgxNjU2Ng=="}, "originalCommit": {"oid": "4c6b602e16407bc099673555bc72a45692d2b1ad"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjY0ODc3OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMjozMzo0MFrOFmJgqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMDozNzozN1rOFmpaMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0NjAyNg==", "bodyText": "just use timer.set, not timer.offset", "url": "https://github.com/apache/beam/pull/10627#discussion_r375546026", "createdAt": "2020-02-05T22:33:40Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -3806,6 +3812,90 @@ public void onTimer(\n       pipeline.run();\n     }\n \n+    @Test\n+    @Category({\n+      ValidatesRunner.class,\n+      UsesStatefulParDo.class,\n+      UsesTimersInParDo.class,\n+      UsesTestStreamWithProcessingTime.class,\n+      UsesTestStreamWithOutputTimestamp.class\n+    })\n+    public void testOutputTimestampWithProcessingTime() {\n+      final String timerId = \"foo\";\n+      DoFn<KV<String, Integer>, KV<String, Integer>> fn1 =\n+          new DoFn<KV<String, Integer>, KV<String, Integer>>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @Timestamp Instant timestamp,\n+                OutputReceiver<KV<String, Integer>> o) {\n+              timer\n+                  .withOutputTimestamp(timestamp.plus(Duration.standardSeconds(5)))\n+                  .offset(Duration.standardSeconds(10))\n+                  .setRelative();\n+              // Output a message. This will cause the next DoFn to set a timer as well.\n+              o.output(KV.of(\"foo\", 100));\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(OnTimerContext c, BoundedWindow w) {}\n+          };\n+\n+      DoFn<KV<String, Integer>, Integer> fn2 =\n+          new DoFn<KV<String, Integer>, Integer>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+            @StateId(\"timerFired\")\n+            final StateSpec<ValueState<Boolean>> timerFiredState = StateSpecs.value();\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @StateId(\"timerFired\") ValueState<Boolean> timerFiredState) {\n+              Boolean timerFired = timerFiredState.read();\n+              assertTrue(timerFired == null || !timerFired);\n+              // Set a timer to 8. This is earlier than the previous DoFn's timer, but after the\n+              // previous\n+              // DoFn timer's watermark hold. This timer should not fire until the previous timer\n+              // fires and removes\n+              // the watermark hold.\n+              timer.offset(Duration.standardSeconds(8)).setRelative();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45ecc6a72bc3dd7803e9651b1b8adb097ee29cb"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2ODY1OA==", "bodyText": "@reuvenlax  done", "url": "https://github.com/apache/beam/pull/10627#discussion_r376068658", "createdAt": "2020-02-06T20:37:37Z", "author": {"login": "rehmanmuradali"}, "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -3806,6 +3812,90 @@ public void onTimer(\n       pipeline.run();\n     }\n \n+    @Test\n+    @Category({\n+      ValidatesRunner.class,\n+      UsesStatefulParDo.class,\n+      UsesTimersInParDo.class,\n+      UsesTestStreamWithProcessingTime.class,\n+      UsesTestStreamWithOutputTimestamp.class\n+    })\n+    public void testOutputTimestampWithProcessingTime() {\n+      final String timerId = \"foo\";\n+      DoFn<KV<String, Integer>, KV<String, Integer>> fn1 =\n+          new DoFn<KV<String, Integer>, KV<String, Integer>>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @Timestamp Instant timestamp,\n+                OutputReceiver<KV<String, Integer>> o) {\n+              timer\n+                  .withOutputTimestamp(timestamp.plus(Duration.standardSeconds(5)))\n+                  .offset(Duration.standardSeconds(10))\n+                  .setRelative();\n+              // Output a message. This will cause the next DoFn to set a timer as well.\n+              o.output(KV.of(\"foo\", 100));\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(OnTimerContext c, BoundedWindow w) {}\n+          };\n+\n+      DoFn<KV<String, Integer>, Integer> fn2 =\n+          new DoFn<KV<String, Integer>, Integer>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+            @StateId(\"timerFired\")\n+            final StateSpec<ValueState<Boolean>> timerFiredState = StateSpecs.value();\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @StateId(\"timerFired\") ValueState<Boolean> timerFiredState) {\n+              Boolean timerFired = timerFiredState.read();\n+              assertTrue(timerFired == null || !timerFired);\n+              // Set a timer to 8. This is earlier than the previous DoFn's timer, but after the\n+              // previous\n+              // DoFn timer's watermark hold. This timer should not fire until the previous timer\n+              // fires and removes\n+              // the watermark hold.\n+              timer.offset(Duration.standardSeconds(8)).setRelative();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0NjAyNg=="}, "originalCommit": {"oid": "c45ecc6a72bc3dd7803e9651b1b8adb097ee29cb"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjY2NjQ3OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMjo0MDo0OVrOFmJrng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNjo1Nzo1MVrOFmzzPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0ODgzMA==", "bodyText": "I think you might have to advance processing time to at least 11.\nYou also need to advance the watermark to at least 10 to allow the timer to fire. Right now this isn't testing anything, because the input watermark is preventing the timer from firing.", "url": "https://github.com/apache/beam/pull/10627#discussion_r375548830", "createdAt": "2020-02-05T22:40:49Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -3806,6 +3812,90 @@ public void onTimer(\n       pipeline.run();\n     }\n \n+    @Test\n+    @Category({\n+      ValidatesRunner.class,\n+      UsesStatefulParDo.class,\n+      UsesTimersInParDo.class,\n+      UsesTestStreamWithProcessingTime.class,\n+      UsesTestStreamWithOutputTimestamp.class\n+    })\n+    public void testOutputTimestampWithProcessingTime() {\n+      final String timerId = \"foo\";\n+      DoFn<KV<String, Integer>, KV<String, Integer>> fn1 =\n+          new DoFn<KV<String, Integer>, KV<String, Integer>>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @Timestamp Instant timestamp,\n+                OutputReceiver<KV<String, Integer>> o) {\n+              timer\n+                  .withOutputTimestamp(timestamp.plus(Duration.standardSeconds(5)))\n+                  .offset(Duration.standardSeconds(10))\n+                  .setRelative();\n+              // Output a message. This will cause the next DoFn to set a timer as well.\n+              o.output(KV.of(\"foo\", 100));\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(OnTimerContext c, BoundedWindow w) {}\n+          };\n+\n+      DoFn<KV<String, Integer>, Integer> fn2 =\n+          new DoFn<KV<String, Integer>, Integer>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+            @StateId(\"timerFired\")\n+            final StateSpec<ValueState<Boolean>> timerFiredState = StateSpecs.value();\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @StateId(\"timerFired\") ValueState<Boolean> timerFiredState) {\n+              Boolean timerFired = timerFiredState.read();\n+              assertTrue(timerFired == null || !timerFired);\n+              // Set a timer to 8. This is earlier than the previous DoFn's timer, but after the\n+              // previous\n+              // DoFn timer's watermark hold. This timer should not fire until the previous timer\n+              // fires and removes\n+              // the watermark hold.\n+              timer.offset(Duration.standardSeconds(8)).setRelative();\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(\n+                @StateId(\"timerFired\") ValueState<Boolean> timerFiredState,\n+                OutputReceiver<Integer> o) {\n+              timerFiredState.write(true);\n+              o.output(100);\n+            }\n+          };\n+\n+      TestStream<KV<String, Integer>> stream =\n+          TestStream.create(KvCoder.of(StringUtf8Coder.of(), VarIntCoder.of()))\n+              .advanceProcessingTime(Duration.standardSeconds(1))\n+              // Cause fn2 to set a timer.\n+              .addElements(KV.of(\"key\", 1))\n+              // Normally this would case fn2's timer to expire, but it shouldn't here because of\n+              // the output timestamp.\n+              .advanceProcessingTime(Duration.standardSeconds(9))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45ecc6a72bc3dd7803e9651b1b8adb097ee29cb"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA3MDQzNg==", "bodyText": "@reuvenlax, I think if we advance processing time to 11, it will fire fn1's timer as we have set delivery time offset as 10. If we advance processing time by  9 and watermark by 11 then it will test the functionality?", "url": "https://github.com/apache/beam/pull/10627#discussion_r376070436", "createdAt": "2020-02-06T20:41:32Z", "author": {"login": "rehmanmuradali"}, "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -3806,6 +3812,90 @@ public void onTimer(\n       pipeline.run();\n     }\n \n+    @Test\n+    @Category({\n+      ValidatesRunner.class,\n+      UsesStatefulParDo.class,\n+      UsesTimersInParDo.class,\n+      UsesTestStreamWithProcessingTime.class,\n+      UsesTestStreamWithOutputTimestamp.class\n+    })\n+    public void testOutputTimestampWithProcessingTime() {\n+      final String timerId = \"foo\";\n+      DoFn<KV<String, Integer>, KV<String, Integer>> fn1 =\n+          new DoFn<KV<String, Integer>, KV<String, Integer>>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @Timestamp Instant timestamp,\n+                OutputReceiver<KV<String, Integer>> o) {\n+              timer\n+                  .withOutputTimestamp(timestamp.plus(Duration.standardSeconds(5)))\n+                  .offset(Duration.standardSeconds(10))\n+                  .setRelative();\n+              // Output a message. This will cause the next DoFn to set a timer as well.\n+              o.output(KV.of(\"foo\", 100));\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(OnTimerContext c, BoundedWindow w) {}\n+          };\n+\n+      DoFn<KV<String, Integer>, Integer> fn2 =\n+          new DoFn<KV<String, Integer>, Integer>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+            @StateId(\"timerFired\")\n+            final StateSpec<ValueState<Boolean>> timerFiredState = StateSpecs.value();\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @StateId(\"timerFired\") ValueState<Boolean> timerFiredState) {\n+              Boolean timerFired = timerFiredState.read();\n+              assertTrue(timerFired == null || !timerFired);\n+              // Set a timer to 8. This is earlier than the previous DoFn's timer, but after the\n+              // previous\n+              // DoFn timer's watermark hold. This timer should not fire until the previous timer\n+              // fires and removes\n+              // the watermark hold.\n+              timer.offset(Duration.standardSeconds(8)).setRelative();\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(\n+                @StateId(\"timerFired\") ValueState<Boolean> timerFiredState,\n+                OutputReceiver<Integer> o) {\n+              timerFiredState.write(true);\n+              o.output(100);\n+            }\n+          };\n+\n+      TestStream<KV<String, Integer>> stream =\n+          TestStream.create(KvCoder.of(StringUtf8Coder.of(), VarIntCoder.of()))\n+              .advanceProcessingTime(Duration.standardSeconds(1))\n+              // Cause fn2 to set a timer.\n+              .addElements(KV.of(\"key\", 1))\n+              // Normally this would case fn2's timer to expire, but it shouldn't here because of\n+              // the output timestamp.\n+              .advanceProcessingTime(Duration.standardSeconds(9))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0ODgzMA=="}, "originalCommit": {"oid": "c45ecc6a72bc3dd7803e9651b1b8adb097ee29cb"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MzU5NA==", "bodyText": "yes, but you need to advance the watermark before calling addElements.", "url": "https://github.com/apache/beam/pull/10627#discussion_r376153594", "createdAt": "2020-02-07T00:14:56Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -3806,6 +3812,90 @@ public void onTimer(\n       pipeline.run();\n     }\n \n+    @Test\n+    @Category({\n+      ValidatesRunner.class,\n+      UsesStatefulParDo.class,\n+      UsesTimersInParDo.class,\n+      UsesTestStreamWithProcessingTime.class,\n+      UsesTestStreamWithOutputTimestamp.class\n+    })\n+    public void testOutputTimestampWithProcessingTime() {\n+      final String timerId = \"foo\";\n+      DoFn<KV<String, Integer>, KV<String, Integer>> fn1 =\n+          new DoFn<KV<String, Integer>, KV<String, Integer>>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @Timestamp Instant timestamp,\n+                OutputReceiver<KV<String, Integer>> o) {\n+              timer\n+                  .withOutputTimestamp(timestamp.plus(Duration.standardSeconds(5)))\n+                  .offset(Duration.standardSeconds(10))\n+                  .setRelative();\n+              // Output a message. This will cause the next DoFn to set a timer as well.\n+              o.output(KV.of(\"foo\", 100));\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(OnTimerContext c, BoundedWindow w) {}\n+          };\n+\n+      DoFn<KV<String, Integer>, Integer> fn2 =\n+          new DoFn<KV<String, Integer>, Integer>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+            @StateId(\"timerFired\")\n+            final StateSpec<ValueState<Boolean>> timerFiredState = StateSpecs.value();\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @StateId(\"timerFired\") ValueState<Boolean> timerFiredState) {\n+              Boolean timerFired = timerFiredState.read();\n+              assertTrue(timerFired == null || !timerFired);\n+              // Set a timer to 8. This is earlier than the previous DoFn's timer, but after the\n+              // previous\n+              // DoFn timer's watermark hold. This timer should not fire until the previous timer\n+              // fires and removes\n+              // the watermark hold.\n+              timer.offset(Duration.standardSeconds(8)).setRelative();\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(\n+                @StateId(\"timerFired\") ValueState<Boolean> timerFiredState,\n+                OutputReceiver<Integer> o) {\n+              timerFiredState.write(true);\n+              o.output(100);\n+            }\n+          };\n+\n+      TestStream<KV<String, Integer>> stream =\n+          TestStream.create(KvCoder.of(StringUtf8Coder.of(), VarIntCoder.of()))\n+              .advanceProcessingTime(Duration.standardSeconds(1))\n+              // Cause fn2 to set a timer.\n+              .addElements(KV.of(\"key\", 1))\n+              // Normally this would case fn2's timer to expire, but it shouldn't here because of\n+              // the output timestamp.\n+              .advanceProcessingTime(Duration.standardSeconds(9))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0ODgzMA=="}, "originalCommit": {"oid": "c45ecc6a72bc3dd7803e9651b1b8adb097ee29cb"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIzODkwOQ==", "bodyText": "@reuvenlax done", "url": "https://github.com/apache/beam/pull/10627#discussion_r376238909", "createdAt": "2020-02-07T06:57:51Z", "author": {"login": "rehmanmuradali"}, "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -3806,6 +3812,90 @@ public void onTimer(\n       pipeline.run();\n     }\n \n+    @Test\n+    @Category({\n+      ValidatesRunner.class,\n+      UsesStatefulParDo.class,\n+      UsesTimersInParDo.class,\n+      UsesTestStreamWithProcessingTime.class,\n+      UsesTestStreamWithOutputTimestamp.class\n+    })\n+    public void testOutputTimestampWithProcessingTime() {\n+      final String timerId = \"foo\";\n+      DoFn<KV<String, Integer>, KV<String, Integer>> fn1 =\n+          new DoFn<KV<String, Integer>, KV<String, Integer>>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @Timestamp Instant timestamp,\n+                OutputReceiver<KV<String, Integer>> o) {\n+              timer\n+                  .withOutputTimestamp(timestamp.plus(Duration.standardSeconds(5)))\n+                  .offset(Duration.standardSeconds(10))\n+                  .setRelative();\n+              // Output a message. This will cause the next DoFn to set a timer as well.\n+              o.output(KV.of(\"foo\", 100));\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(OnTimerContext c, BoundedWindow w) {}\n+          };\n+\n+      DoFn<KV<String, Integer>, Integer> fn2 =\n+          new DoFn<KV<String, Integer>, Integer>() {\n+\n+            @TimerId(timerId)\n+            private final TimerSpec timer = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+            @StateId(\"timerFired\")\n+            final StateSpec<ValueState<Boolean>> timerFiredState = StateSpecs.value();\n+\n+            @ProcessElement\n+            public void processElement(\n+                @TimerId(timerId) Timer timer,\n+                @StateId(\"timerFired\") ValueState<Boolean> timerFiredState) {\n+              Boolean timerFired = timerFiredState.read();\n+              assertTrue(timerFired == null || !timerFired);\n+              // Set a timer to 8. This is earlier than the previous DoFn's timer, but after the\n+              // previous\n+              // DoFn timer's watermark hold. This timer should not fire until the previous timer\n+              // fires and removes\n+              // the watermark hold.\n+              timer.offset(Duration.standardSeconds(8)).setRelative();\n+            }\n+\n+            @OnTimer(timerId)\n+            public void onTimer(\n+                @StateId(\"timerFired\") ValueState<Boolean> timerFiredState,\n+                OutputReceiver<Integer> o) {\n+              timerFiredState.write(true);\n+              o.output(100);\n+            }\n+          };\n+\n+      TestStream<KV<String, Integer>> stream =\n+          TestStream.create(KvCoder.of(StringUtf8Coder.of(), VarIntCoder.of()))\n+              .advanceProcessingTime(Duration.standardSeconds(1))\n+              // Cause fn2 to set a timer.\n+              .addElements(KV.of(\"key\", 1))\n+              // Normally this would case fn2's timer to expire, but it shouldn't here because of\n+              // the output timestamp.\n+              .advanceProcessingTime(Duration.standardSeconds(9))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0ODgzMA=="}, "originalCommit": {"oid": "c45ecc6a72bc3dd7803e9651b1b8adb097ee29cb"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjY3MTQ1OnYy", "diffSide": "RIGHT", "path": "runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMjo0Mjo1MlrOFmJuvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMDozNzoxMlrOFmpZVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0OTYzMA==", "bodyText": "What about the other getEarliestTimerTimestamp function? Does that need to be updated?", "url": "https://github.com/apache/beam/pull/10627#discussion_r375549630", "createdAt": "2020-02-05T22:42:52Z", "author": {"login": "reuvenlax"}, "path": "runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java", "diffHunk": "@@ -597,20 +597,29 @@ public synchronized Instant getEarliestTimerTimestamp() {\n       Instant earliest = THE_END_OF_TIME.get();\n       for (NavigableSet<TimerData> timers : processingTimers.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45ecc6a72bc3dd7803e9651b1b8adb097ee29cb"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2ODQzNw==", "bodyText": "@reuvenlax  done", "url": "https://github.com/apache/beam/pull/10627#discussion_r376068437", "createdAt": "2020-02-06T20:37:12Z", "author": {"login": "rehmanmuradali"}, "path": "runners/direct-java/src/main/java/org/apache/beam/runners/direct/WatermarkManager.java", "diffHunk": "@@ -597,20 +597,29 @@ public synchronized Instant getEarliestTimerTimestamp() {\n       Instant earliest = THE_END_OF_TIME.get();\n       for (NavigableSet<TimerData> timers : processingTimers.values()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0OTYzMA=="}, "originalCommit": {"oid": "c45ecc6a72bc3dd7803e9651b1b8adb097ee29cb"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2210, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}