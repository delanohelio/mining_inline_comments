{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MjE1NTg0", "number": 11929, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoxNzo0OVrOEDIMVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyMDoxNlrOED71og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE1NDEzOnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoxNzo0OVrOGgAYGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjozNzo0M1rOGheyJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMzc4Nw==", "bodyText": "you can add the schema for the outputs here, so that users do not need to add them themselves?", "url": "https://github.com/apache/beam/pull/11929#discussion_r436213787", "createdAt": "2020-06-06T00:17:49Z", "author": {"login": "pabloem"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {\n+\n+      return jsonStrings.apply(\n+          ParDo.of(\n+                  new DoFn<String, Row>() {\n+                    @ProcessElement\n+                    public void processElement(ProcessContext context) {\n+                      try {\n+                        context.output(jsonToRow(objectMapper(), context.element()));\n+                      } catch (Exception ex) {\n+                        context.output(\n+                            deadLetter,\n+                            Row.withSchema(ERROR_ROW_SCHEMA)\n+                                .addValue(context.element())\n+                                .addValue(ex.getMessage())\n+                                .build());\n+                      }\n+                    }\n+                  })\n+              .withOutputTags(main, TupleTagList.of(deadLetter)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MDU1MA==", "bodyText": "Fixed.", "url": "https://github.com/apache/beam/pull/11929#discussion_r437760550", "createdAt": "2020-06-09T22:37:43Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {\n+\n+      return jsonStrings.apply(\n+          ParDo.of(\n+                  new DoFn<String, Row>() {\n+                    @ProcessElement\n+                    public void processElement(ProcessContext context) {\n+                      try {\n+                        context.output(jsonToRow(objectMapper(), context.element()));\n+                      } catch (Exception ex) {\n+                        context.output(\n+                            deadLetter,\n+                            Row.withSchema(ERROR_ROW_SCHEMA)\n+                                .addValue(context.element())\n+                                .addValue(ex.getMessage())\n+                                .build());\n+                      }\n+                    }\n+                  })\n+              .withOutputTags(main, TupleTagList.of(deadLetter)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMzc4Nw=="}, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE1NDUwOnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoxODowOVrOGgAYVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzoyMTo0NFrOGhJfPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMzg0Ng==", "bodyText": "Maybe add the schema for the PCollections in expand so that users won't have to add them manually?", "url": "https://github.com/apache/beam/pull/11929#discussion_r436213846", "createdAt": "2020-06-06T00:18:09Z", "author": {"login": "pabloem"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -72,10 +79,44 @@\n @Experimental(Kind.SCHEMAS)\n public class JsonToRow {\n \n+  private static final String LINE_FIELD_NAME = \"line\";\n+  private static final String ERROR_FIELD_NAME = \"err\";\n+\n+  public static final Schema ERROR_ROW_SCHEMA =\n+      Schema.of(\n+          Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+          Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+  public static final TupleTag<Row> MAIN_TUPLE_TAG = new TupleTag<Row>() {};\n+  public static final TupleTag<Row> DEAD_LETTER_TUPLE_TAG = new TupleTag<Row>() {};\n+\n   public static PTransform<PCollection<String>, PCollection<Row>> withSchema(Schema rowSchema) {\n     return JsonToRowFn.forSchema(rowSchema);\n   }\n \n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects of form: {@link JsonToRow#ERROR_ROW_SCHEMA} line : The original json string err :\n+   * The error message from the parsing function.\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>{@link JsonToRow#MAIN_TUPLE_TAG}\n+   *\n+   * <p>{@Code PCollection<Row> personRows =\n+   * results.get(JsonToRow.MAIN_TUPLE_TAG).setRowSchema(personSchema)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDczOQ==", "bodyText": "+1. If you output.a Row, you should be setting the schema in your transform.", "url": "https://github.com/apache/beam/pull/11929#discussion_r436220739", "createdAt": "2020-06-06T00:49:28Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -72,10 +79,44 @@\n @Experimental(Kind.SCHEMAS)\n public class JsonToRow {\n \n+  private static final String LINE_FIELD_NAME = \"line\";\n+  private static final String ERROR_FIELD_NAME = \"err\";\n+\n+  public static final Schema ERROR_ROW_SCHEMA =\n+      Schema.of(\n+          Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+          Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+  public static final TupleTag<Row> MAIN_TUPLE_TAG = new TupleTag<Row>() {};\n+  public static final TupleTag<Row> DEAD_LETTER_TUPLE_TAG = new TupleTag<Row>() {};\n+\n   public static PTransform<PCollection<String>, PCollection<Row>> withSchema(Schema rowSchema) {\n     return JsonToRowFn.forSchema(rowSchema);\n   }\n \n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects of form: {@link JsonToRow#ERROR_ROW_SCHEMA} line : The original json string err :\n+   * The error message from the parsing function.\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>{@link JsonToRow#MAIN_TUPLE_TAG}\n+   *\n+   * <p>{@Code PCollection<Row> personRows =\n+   * results.get(JsonToRow.MAIN_TUPLE_TAG).setRowSchema(personSchema)}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMzg0Ng=="}, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMTY0Ng==", "bodyText": "Fixed.", "url": "https://github.com/apache/beam/pull/11929#discussion_r437411646", "createdAt": "2020-06-09T13:21:44Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -72,10 +79,44 @@\n @Experimental(Kind.SCHEMAS)\n public class JsonToRow {\n \n+  private static final String LINE_FIELD_NAME = \"line\";\n+  private static final String ERROR_FIELD_NAME = \"err\";\n+\n+  public static final Schema ERROR_ROW_SCHEMA =\n+      Schema.of(\n+          Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+          Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+  public static final TupleTag<Row> MAIN_TUPLE_TAG = new TupleTag<Row>() {};\n+  public static final TupleTag<Row> DEAD_LETTER_TUPLE_TAG = new TupleTag<Row>() {};\n+\n   public static PTransform<PCollection<String>, PCollection<Row>> withSchema(Schema rowSchema) {\n     return JsonToRowFn.forSchema(rowSchema);\n   }\n \n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects of form: {@link JsonToRow#ERROR_ROW_SCHEMA} line : The original json string err :\n+   * The error message from the parsing function.\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>{@link JsonToRow#MAIN_TUPLE_TAG}\n+   *\n+   * <p>{@Code PCollection<Row> personRows =\n+   * results.get(JsonToRow.MAIN_TUPLE_TAG).setRowSchema(personSchema)}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMzg0Ng=="}, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE1NjUzOnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoyMDoyNlrOGgAZjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzoyMjo1MFrOGhJiTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDE1Nw==", "bodyText": "I guess this doesn't make sense, but - would it help to include the Row Schema that we tried(and failed) to use for this JSON string? Some users may not needed, and others can add it themselves in the downstream ParDo - but it's possible it may help. Thoughts?", "url": "https://github.com/apache/beam/pull/11929#discussion_r436214157", "createdAt": "2020-06-06T00:20:26Z", "author": {"login": "pabloem"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {\n+\n+      return jsonStrings.apply(\n+          ParDo.of(\n+                  new DoFn<String, Row>() {\n+                    @ProcessElement\n+                    public void processElement(ProcessContext context) {\n+                      try {\n+                        context.output(jsonToRow(objectMapper(), context.element()));\n+                      } catch (Exception ex) {\n+                        context.output(\n+                            deadLetter,\n+                            Row.withSchema(ERROR_ROW_SCHEMA)\n+                                .addValue(context.element())\n+                                .addValue(ex.getMessage())\n+                                .build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTE1NQ==", "bodyText": "(I am mostly leaning towards not doing this, but lmk what you think)", "url": "https://github.com/apache/beam/pull/11929#discussion_r436215155", "createdAt": "2020-06-06T00:27:59Z", "author": {"login": "pabloem"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {\n+\n+      return jsonStrings.apply(\n+          ParDo.of(\n+                  new DoFn<String, Row>() {\n+                    @ProcessElement\n+                    public void processElement(ProcessContext context) {\n+                      try {\n+                        context.output(jsonToRow(objectMapper(), context.element()));\n+                      } catch (Exception ex) {\n+                        context.output(\n+                            deadLetter,\n+                            Row.withSchema(ERROR_ROW_SCHEMA)\n+                                .addValue(context.element())\n+                                .addValue(ex.getMessage())\n+                                .build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDE1Nw=="}, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMjI0OQ==", "bodyText": "I think it would be nice to add it as SideInput, but I think for this first version maybe we stay with basic error message?", "url": "https://github.com/apache/beam/pull/11929#discussion_r437412249", "createdAt": "2020-06-09T13:22:36Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {\n+\n+      return jsonStrings.apply(\n+          ParDo.of(\n+                  new DoFn<String, Row>() {\n+                    @ProcessElement\n+                    public void processElement(ProcessContext context) {\n+                      try {\n+                        context.output(jsonToRow(objectMapper(), context.element()));\n+                      } catch (Exception ex) {\n+                        context.output(\n+                            deadLetter,\n+                            Row.withSchema(ERROR_ROW_SCHEMA)\n+                                .addValue(context.element())\n+                                .addValue(ex.getMessage())\n+                                .build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDE1Nw=="}, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMjQyOA==", "bodyText": "I think it would be nice to add it as SideInput, but I think for this first version maybe we stay with basic error message?", "url": "https://github.com/apache/beam/pull/11929#discussion_r437412428", "createdAt": "2020-06-09T13:22:50Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {\n+\n+      return jsonStrings.apply(\n+          ParDo.of(\n+                  new DoFn<String, Row>() {\n+                    @ProcessElement\n+                    public void processElement(ProcessContext context) {\n+                      try {\n+                        context.output(jsonToRow(objectMapper(), context.element()));\n+                      } catch (Exception ex) {\n+                        context.output(\n+                            deadLetter,\n+                            Row.withSchema(ERROR_ROW_SCHEMA)\n+                                .addValue(context.element())\n+                                .addValue(ex.getMessage())\n+                                .build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDE1Nw=="}, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE2MjY5OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoyNzoxNlrOGgAdGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzoyMzoxMlrOGhJjPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTA2NA==", "bodyText": "PCollectionTuple is not great (though it's what we have after all) - do you think it could make sense to return a custom, more elegant Result type? See this PR, where something like this was added for Map-type ptransforms: https://github.com/apache/beam/pull/7736/files#diff-895d512e486834dfd818eec82c75b2c3R122-R181", "url": "https://github.com/apache/beam/pull/11929#discussion_r436215064", "createdAt": "2020-06-06T00:27:16Z", "author": {"login": "pabloem"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMjY3MQ==", "bodyText": "Created a ParseResult object.", "url": "https://github.com/apache/beam/pull/11929#discussion_r437412671", "createdAt": "2020-06-09T13:23:12Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTA2NA=="}, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE5ODQ0OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDo0ODo0MFrOGgAy9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzoyMzoyMFrOGhJjqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDY2MA==", "bodyText": "would be nicer to make these field names configurable, though with defaults.", "url": "https://github.com/apache/beam/pull/11929#discussion_r436220660", "createdAt": "2020-06-06T00:48:40Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -72,10 +79,44 @@\n @Experimental(Kind.SCHEMAS)\n public class JsonToRow {\n \n+  private static final String LINE_FIELD_NAME = \"line\";\n+  private static final String ERROR_FIELD_NAME = \"err\";\n+\n+  public static final Schema ERROR_ROW_SCHEMA =\n+      Schema.of(\n+          Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+          Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMjc3Nw==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11929#discussion_r437412777", "createdAt": "2020-06-09T13:23:20Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -72,10 +79,44 @@\n @Experimental(Kind.SCHEMAS)\n public class JsonToRow {\n \n+  private static final String LINE_FIELD_NAME = \"line\";\n+  private static final String ERROR_FIELD_NAME = \"err\";\n+\n+  public static final Schema ERROR_ROW_SCHEMA =\n+      Schema.of(\n+          Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+          Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDY2MA=="}, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzE5ODY0OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDo0OTowMlrOGgAzFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDowMToxN1rOGiKJGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDY5NA==", "bodyText": "give these tuple tags real names", "url": "https://github.com/apache/beam/pull/11929#discussion_r436220694", "createdAt": "2020-06-06T00:49:02Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -72,10 +79,44 @@\n @Experimental(Kind.SCHEMAS)\n public class JsonToRow {\n \n+  private static final String LINE_FIELD_NAME = \"line\";\n+  private static final String ERROR_FIELD_NAME = \"err\";\n+\n+  public static final Schema ERROR_ROW_SCHEMA =\n+      Schema.of(\n+          Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+          Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+  public static final TupleTag<Row> MAIN_TUPLE_TAG = new TupleTag<Row>() {};\n+  public static final TupleTag<Row> DEAD_LETTER_TUPLE_TAG = new TupleTag<Row>() {};\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MDkzOQ==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11929#discussion_r438470939", "createdAt": "2020-06-11T00:01:17Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -72,10 +79,44 @@\n @Experimental(Kind.SCHEMAS)\n public class JsonToRow {\n \n+  private static final String LINE_FIELD_NAME = \"line\";\n+  private static final String ERROR_FIELD_NAME = \"err\";\n+\n+  public static final Schema ERROR_ROW_SCHEMA =\n+      Schema.of(\n+          Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+          Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+  public static final TupleTag<Row> MAIN_TUPLE_TAG = new TupleTag<Row>() {};\n+  public static final TupleTag<Row> DEAD_LETTER_TUPLE_TAG = new TupleTag<Row>() {};\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDY5NA=="}, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzIwMDc3OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDo1MToyMFrOGgA0MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzoyMzozN1rOGhJkYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDk3Ng==", "bodyText": "I think it would be cleaner to wrap this in a custom result class and not expose the TupleTags to users. Look org.apache.beam.sdk.io.gcp.bigquery.WriteResult for an example.", "url": "https://github.com/apache/beam/pull/11929#discussion_r436220976", "createdAt": "2020-06-06T00:51:20Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMjk2Mg==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11929#discussion_r437412962", "createdAt": "2020-06-09T13:23:37Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDk3Ng=="}, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzIwMTIwOnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDo1MTo1MFrOGgA0aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDo1MTo1MFrOGgA0aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMTAzMg==", "bodyText": "make final", "url": "https://github.com/apache/beam/pull/11929#discussion_r436221032", "createdAt": "2020-06-06T00:51:50Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzIwMjM5OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDo1MzoxMlrOGgA1Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMToxODoyN1rOGhhnhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMTE4Nw==", "bodyText": "Why not use injected parameters instead of ProcessContext?", "url": "https://github.com/apache/beam/pull/11929#discussion_r436221187", "createdAt": "2020-06-06T00:53:12Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {\n+\n+      return jsonStrings.apply(\n+          ParDo.of(\n+                  new DoFn<String, Row>() {\n+                    @ProcessElement\n+                    public void processElement(ProcessContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwNjk4MQ==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11929#discussion_r437806981", "createdAt": "2020-06-10T01:18:27Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {\n+\n+      return jsonStrings.apply(\n+          ParDo.of(\n+                  new DoFn<String, Row>() {\n+                    @ProcessElement\n+                    public void processElement(ProcessContext context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMTE4Nw=="}, "originalCommit": {"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTQ5NDMyOnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNTowMzozMFrOGhOijA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMToxODo1MFrOGhhnzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ5NDQxMg==", "bodyText": "I think we should name this something different, as not everyone knows the term dead letter.", "url": "https://github.com/apache/beam/pull/11929#discussion_r437494412", "createdAt": "2020-06-09T15:03:30Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwNzA1Mw==", "bodyText": "Changed to withExceptionReporting.", "url": "https://github.com/apache/beam/pull/11929#discussion_r437807053", "createdAt": "2020-06-10T01:18:50Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ5NDQxMg=="}, "originalCommit": {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTU5MzM3OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToxNzo0MlrOGhPfTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMjoyNzo0NlrOGiMZ9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUwOTk2Ng==", "bodyText": "Seems a bit roundabout. I would store these in the ParseResult object itself.", "url": "https://github.com/apache/beam/pull/11929#discussion_r437509966", "createdAt": "2020-06-09T15:17:42Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUwODAyMg==", "bodyText": "Changed to be passed in via resultBuilder.", "url": "https://github.com/apache/beam/pull/11929#discussion_r438508022", "createdAt": "2020-06-11T02:27:46Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUwOTk2Ng=="}, "originalCommit": {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTU5NjcyOnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToxODowN1rOGhPhdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo0ODozMlrOGhfACQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMDUxOQ==", "bodyText": "why volatle?", "url": "https://github.com/apache/beam/pull/11929#discussion_r437510519", "createdAt": "2020-06-09T15:18:07Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());\n+      this.failedParse =\n+          result.get(PARSE_ERROR_LINE).setRowSchema(JsonToRowWithErrFn.ERROR_ROW_SCHEMA);\n+      this.failedParseWithErr =\n+          result\n+              .get(PARSE_ERROR_LINE_WITH_MSG)\n+              .setRowSchema(JsonToRowWithErrFn.ERROR_ROW_WITH_ERR_MSG_SCHEMA);\n+\n+      return ParseResult.result(this);\n+    }\n+\n+    private static class ParseWithError extends DoFn<String, Row> {\n+      private transient volatile @Nullable ObjectMapper objectMapper;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NDEwNQ==", "bodyText": "This was used in the original JsonToRow , but I didnt see any notes as to why. Also this Object Mapper was at the Transform class level before and used in an anon DoFn.\nIn theory this is something that I would instantiate in @setup, but again we might want to make those changes in a separate PR which can also have some larger tests to make sure it works ok with multiple DoFn's are active?", "url": "https://github.com/apache/beam/pull/11929#discussion_r437764105", "createdAt": "2020-06-09T22:48:32Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());\n+      this.failedParse =\n+          result.get(PARSE_ERROR_LINE).setRowSchema(JsonToRowWithErrFn.ERROR_ROW_SCHEMA);\n+      this.failedParseWithErr =\n+          result\n+              .get(PARSE_ERROR_LINE_WITH_MSG)\n+              .setRowSchema(JsonToRowWithErrFn.ERROR_ROW_WITH_ERR_MSG_SCHEMA);\n+\n+      return ParseResult.result(this);\n+    }\n+\n+    private static class ParseWithError extends DoFn<String, Row> {\n+      private transient volatile @Nullable ObjectMapper objectMapper;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMDUxOQ=="}, "originalCommit": {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTYwNjA4OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToxOToxNFrOGhPnRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo0MjoyN1rOGhe4dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMjAwNA==", "bodyText": "Instead of separate output tags why not just add a nullable error-msg field to ERROR_ROW_SCHEMA that is not filled in if not asked for.", "url": "https://github.com/apache/beam/pull/11929#discussion_r437512004", "createdAt": "2020-06-09T15:19:14Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());\n+      this.failedParse =\n+          result.get(PARSE_ERROR_LINE).setRowSchema(JsonToRowWithErrFn.ERROR_ROW_SCHEMA);\n+      this.failedParseWithErr =\n+          result\n+              .get(PARSE_ERROR_LINE_WITH_MSG)\n+              .setRowSchema(JsonToRowWithErrFn.ERROR_ROW_WITH_ERR_MSG_SCHEMA);\n+\n+      return ParseResult.result(this);\n+    }\n+\n+    private static class ParseWithError extends DoFn<String, Row> {\n+      private transient volatile @Nullable ObjectMapper objectMapper;\n+      Schema schema;\n+      Boolean withExtendedErrorInfo;\n+\n+      ParseWithError(Schema schema, Boolean withExtendedErrorInfo) {\n+        this.schema = schema;\n+        this.withExtendedErrorInfo = withExtendedErrorInfo;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        try {\n+\n+          context.output(jsonToRow(objectMapper(), context.element()));\n+\n+        } catch (Exception ex) {\n+\n+          if (withExtendedErrorInfo) {\n+            context.output(\n+                PARSE_ERROR_LINE_WITH_MSG,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MjE2NQ==", "bodyText": "One advantage of being explicit is that the program will fail at pipeline creation time if the option is accidentally forgotten about.  Otherwise they could get a NPE.\nBut not sure if that protection is valuable enough, or if the simplification of the API is better?", "url": "https://github.com/apache/beam/pull/11929#discussion_r437762165", "createdAt": "2020-06-09T22:42:27Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());\n+      this.failedParse =\n+          result.get(PARSE_ERROR_LINE).setRowSchema(JsonToRowWithErrFn.ERROR_ROW_SCHEMA);\n+      this.failedParseWithErr =\n+          result\n+              .get(PARSE_ERROR_LINE_WITH_MSG)\n+              .setRowSchema(JsonToRowWithErrFn.ERROR_ROW_WITH_ERR_MSG_SCHEMA);\n+\n+      return ParseResult.result(this);\n+    }\n+\n+    private static class ParseWithError extends DoFn<String, Row> {\n+      private transient volatile @Nullable ObjectMapper objectMapper;\n+      Schema schema;\n+      Boolean withExtendedErrorInfo;\n+\n+      ParseWithError(Schema schema, Boolean withExtendedErrorInfo) {\n+        this.schema = schema;\n+        this.withExtendedErrorInfo = withExtendedErrorInfo;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        try {\n+\n+          context.output(jsonToRow(objectMapper(), context.element()));\n+\n+        } catch (Exception ex) {\n+\n+          if (withExtendedErrorInfo) {\n+            context.output(\n+                PARSE_ERROR_LINE_WITH_MSG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMjAwNA=="}, "originalCommit": {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTYxMDI3OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToxOTo0M1rOGhPp0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo0NDowNVrOGhe6ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMjY1OA==", "bodyText": "BTW you know that there's a more-readable builder now, right?", "url": "https://github.com/apache/beam/pull/11929#discussion_r437512658", "createdAt": "2020-06-09T15:19:43Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());\n+      this.failedParse =\n+          result.get(PARSE_ERROR_LINE).setRowSchema(JsonToRowWithErrFn.ERROR_ROW_SCHEMA);\n+      this.failedParseWithErr =\n+          result\n+              .get(PARSE_ERROR_LINE_WITH_MSG)\n+              .setRowSchema(JsonToRowWithErrFn.ERROR_ROW_WITH_ERR_MSG_SCHEMA);\n+\n+      return ParseResult.result(this);\n+    }\n+\n+    private static class ParseWithError extends DoFn<String, Row> {\n+      private transient volatile @Nullable ObjectMapper objectMapper;\n+      Schema schema;\n+      Boolean withExtendedErrorInfo;\n+\n+      ParseWithError(Schema schema, Boolean withExtendedErrorInfo) {\n+        this.schema = schema;\n+        this.withExtendedErrorInfo = withExtendedErrorInfo;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        try {\n+\n+          context.output(jsonToRow(objectMapper(), context.element()));\n+\n+        } catch (Exception ex) {\n+\n+          if (withExtendedErrorInfo) {\n+            context.output(\n+                PARSE_ERROR_LINE_WITH_MSG,\n+                Row.withSchema(ERROR_ROW_WITH_ERR_MSG_SCHEMA)\n+                    .addValue(context.element())\n+                    .addValue(ex.getMessage())\n+                    .build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MjY4Mw==", "bodyText": "Not sure, do you mean using withFieldValue?", "url": "https://github.com/apache/beam/pull/11929#discussion_r437762683", "createdAt": "2020-06-09T22:44:05Z", "author": {"login": "rezarokni"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());\n+      this.failedParse =\n+          result.get(PARSE_ERROR_LINE).setRowSchema(JsonToRowWithErrFn.ERROR_ROW_SCHEMA);\n+      this.failedParseWithErr =\n+          result\n+              .get(PARSE_ERROR_LINE_WITH_MSG)\n+              .setRowSchema(JsonToRowWithErrFn.ERROR_ROW_WITH_ERR_MSG_SCHEMA);\n+\n+      return ParseResult.result(this);\n+    }\n+\n+    private static class ParseWithError extends DoFn<String, Row> {\n+      private transient volatile @Nullable ObjectMapper objectMapper;\n+      Schema schema;\n+      Boolean withExtendedErrorInfo;\n+\n+      ParseWithError(Schema schema, Boolean withExtendedErrorInfo) {\n+        this.schema = schema;\n+        this.withExtendedErrorInfo = withExtendedErrorInfo;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        try {\n+\n+          context.output(jsonToRow(objectMapper(), context.element()));\n+\n+        } catch (Exception ex) {\n+\n+          if (withExtendedErrorInfo) {\n+            context.output(\n+                PARSE_ERROR_LINE_WITH_MSG,\n+                Row.withSchema(ERROR_ROW_WITH_ERR_MSG_SCHEMA)\n+                    .addValue(context.element())\n+                    .addValue(ex.getMessage())\n+                    .build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMjY1OA=="}, "originalCommit": {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTYxNTcwOnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyMDoxNlrOGhPs0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyMDoxNlrOGhPs0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMzQyNw==", "bodyText": "see above - I don't think we need both here.", "url": "https://github.com/apache/beam/pull/11929#discussion_r437513427", "createdAt": "2020-06-09T15:20:16Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());\n+      this.failedParse =\n+          result.get(PARSE_ERROR_LINE).setRowSchema(JsonToRowWithErrFn.ERROR_ROW_SCHEMA);\n+      this.failedParseWithErr =\n+          result\n+              .get(PARSE_ERROR_LINE_WITH_MSG)\n+              .setRowSchema(JsonToRowWithErrFn.ERROR_ROW_WITH_ERR_MSG_SCHEMA);\n+\n+      return ParseResult.result(this);\n+    }\n+\n+    private static class ParseWithError extends DoFn<String, Row> {\n+      private transient volatile @Nullable ObjectMapper objectMapper;\n+      Schema schema;\n+      Boolean withExtendedErrorInfo;\n+\n+      ParseWithError(Schema schema, Boolean withExtendedErrorInfo) {\n+        this.schema = schema;\n+        this.withExtendedErrorInfo = withExtendedErrorInfo;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        try {\n+\n+          context.output(jsonToRow(objectMapper(), context.element()));\n+\n+        } catch (Exception ex) {\n+\n+          if (withExtendedErrorInfo) {\n+            context.output(\n+                PARSE_ERROR_LINE_WITH_MSG,\n+                Row.withSchema(ERROR_ROW_WITH_ERR_MSG_SCHEMA)\n+                    .addValue(context.element())\n+                    .addValue(ex.getMessage())\n+                    .build());\n+          } else {\n+            context.output(\n+                PARSE_ERROR_LINE,\n+                Row.withSchema(ERROR_ROW_SCHEMA).addValue(context.element()).build());\n+          }\n+        }\n+      }\n+\n+      private ObjectMapper objectMapper() {\n+        if (this.objectMapper == null) {\n+          synchronized (this) {\n+            if (this.objectMapper == null) {\n+              this.objectMapper = newObjectMapperWith(RowJsonDeserializer.forSchema(schema));\n+            }\n+          }\n+        }\n+\n+        return this.objectMapper;\n+      }\n+    }\n+  }\n+\n+  /** The result of a {@link JsonToRow#withDeadLetter(Schema)} transform. */\n+  public static final class ParseResult implements POutput {\n+    private final JsonToRowWithErrFn jsonToRowWithErrFn;\n+\n+    private ParseResult(JsonToRowWithErrFn jsonToRowWithErrFn) {\n+      this.jsonToRowWithErrFn = jsonToRowWithErrFn;\n+    }\n+\n+    public static ParseResult result(JsonToRowWithErrFn jsonToRowWithErrFn) {\n+      return new ParseResult(jsonToRowWithErrFn);\n+    }\n+\n+    @Override\n+    public Pipeline getPipeline() {\n+      return jsonToRowWithErrFn.pipeline;\n+    }\n+\n+    @Override\n+    public Map<TupleTag<?>, PValue> expand() {\n+      if (jsonToRowWithErrFn.getExtendedErrorInfo()) {\n+        return ImmutableMap.of(\n+            JsonToRowWithErrFn.PARSED_LINE,\n+            jsonToRowWithErrFn.parsedLine,\n+            JsonToRowWithErrFn.PARSE_ERROR_LINE_WITH_MSG,\n+            jsonToRowWithErrFn.failedParseWithErr);\n+      }\n+      return ImmutableMap.of(\n+          JsonToRowWithErrFn.PARSED_LINE,\n+          jsonToRowWithErrFn.parsedLine,\n+          JsonToRowWithErrFn.PARSE_ERROR_LINE,\n+          jsonToRowWithErrFn.failedParse);\n+    }\n+\n+    @Override\n+    public void finishSpecifyingOutput(\n+        String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+    /** Returns a {@link PCollection} containing the {@link Row}s that have been parsed. */\n+    public PCollection<Row> getResults() {\n+      return jsonToRowWithErrFn.parsedLine;\n+    }\n+\n+    /**\n+     * Returns a {@link PCollection} containing the {@link Row}s that didn't parse.\n+     *\n+     * <p>Only use this method if you haven't enabled {@link\n+     * JsonToRowWithErrFn#withExtendedErrorInfo()} . Otherwise use {@link\n+     * ParseResult##getFailedInsertsWithErr()}\n+     */\n+    public PCollection<Row> getFailedToParseLines() {\n+      checkArgument(\n+          !jsonToRowWithErrFn.getExtendedErrorInfo(),\n+          \"Cannot use getFailedToParseLines as this ParseResult uses extended errors\"\n+              + \" information. Use getFailedToParseLinesWithErr instead\");\n+      return jsonToRowWithErrFn.failedParse;\n+    }\n+\n+    /**\n+     * Returns a {@link PCollection} containing the a Row with detailed error information.\n+     *\n+     * <p>Only use this method if you have enabled {@link\n+     * JsonToRowWithErrFn#withExtendedErrorInfo()}. * Otherwise use {@link\n+     * ParseResult#getFailedToParseLines()}\n+     */\n+    public PCollection<Row> getFailedToParseLinesWithErr() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d"}, "originalPosition": 292}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3620, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}