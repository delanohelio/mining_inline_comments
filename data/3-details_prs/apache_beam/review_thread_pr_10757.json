{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNTY4ODk2", "number": 10757, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjozMDo0MlrODigFOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMDozMDowNVrODl7t8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTAzODAzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjozMDo0MlrOFtyQqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNjo1MDowOVrOF2LH4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MzcwNA==", "bodyText": "These lists could be constants like UNLIFTABLE_AGGREGATIONS and LIFTABLE_AGGREGATIONS (similar for series operations above), to make this more self-documenting.", "url": "https://github.com/apache/beam/pull/10757#discussion_r383553704", "createdAt": "2020-02-24T22:30:42Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -0,0 +1,208 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import pandas as pd\n+\n+from apache_beam.dataframe import expressions\n+from apache_beam.dataframe import frame_base\n+\n+\n+@frame_base.DeferredFrame._register_for(pd.Series)\n+class DeferredSeries(frame_base.DeferredFrame):\n+  pass\n+\n+\n+for base in ['add', 'sub', 'mul', 'div', 'truediv', 'floordiv', 'mod', 'pow']:\n+  for p in ['%s', 'r%s', '__%s__', '__r%s__']:\n+    # TODO: non-trivial level?\n+    name = p % base\n+    setattr(\n+        DeferredSeries,\n+        name,\n+        frame_base._elementwise_method(name, restrictions={'level': None}))\n+  setattr(\n+      DeferredSeries,\n+      '__i%s__' % base,\n+      frame_base._elementwise_method('__i%s__' % base, inplace=True))\n+for name in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n+  setattr(DeferredSeries, name, frame_base._elementwise_method(name))\n+for name in ['apply', 'map', 'transform']:\n+  setattr(DeferredSeries, name, frame_base._elementwise_method(name))\n+\n+\n+@frame_base.DeferredFrame._register_for(pd.DataFrame)\n+class DeferredDataFrame(frame_base.DeferredFrame):\n+  def groupby(self, cols):\n+    # TODO: what happens to the existing index?\n+    # We set the columns to index as we have a notion of being partitioned by\n+    # index, but not partitioned by an arbitrary subset of columns.\n+    return DeferredGroupBy(\n+        expressions.ComputedExpression(\n+            'groupbyindex',\n+            lambda df: df.groupby(level=list(range(df.index.nlevels))),\n+            [self.set_index(cols)._expr],\n+            requires_partition_by_index=True,\n+            preserves_partition_by_index=True))\n+\n+  def __getattr__(self, name):\n+    # Column attribute access.\n+    if name in self._expr.proxy().columns:\n+      return self[name]\n+    else:\n+      return super(DeferredDataFrame, self).__getattr__(name)\n+\n+  def __getitem__(self, key):\n+    if key in self._expr.proxy().columns:\n+      return self._elementwise(lambda df: df[key], 'get_column')\n+    else:\n+      raise NotImplementedError(key)\n+\n+  def __setitem__(self, key, value):\n+    if isinstance(key, str):\n+      # yapf: disable\n+      return self._elementwise(\n+          lambda df, key, value: df.__setitem__(key, value),\n+          'set_column',\n+          (key, value),\n+          inplace=True)\n+    else:\n+      raise NotImplementedError(key)\n+\n+  def set_index(self, keys, **kwargs):\n+    if isinstance(keys, str):\n+      keys = [keys]\n+    else:\n+      keys = keys\n+    if not set(keys).issubset(self._expr.proxy().columns):\n+      raise NotImplementedError(keys)\n+    return self._elementwise(\n+        lambda df: df.set_index(keys, **kwargs),\n+        'set_index',\n+        inplace=kwargs.get('inplace', False))\n+\n+  def at(self, *args, **kwargs):\n+    raise NotImplementedError()\n+\n+  @property\n+  def loc(self):\n+    return _DeferredLoc(self)\n+\n+\n+class DeferredGroupBy(frame_base.DeferredFrame):\n+  def agg(self, fn):\n+    if not callable(fn):\n+      raise NotImplementedError(fn)\n+    return DeferredDataFrame(\n+        expressions.ComputedExpression(\n+            'agg',\n+            lambda df: df.agg(fn), [self._expr],\n+            requires_partition_by_index=True,\n+            preserves_partition_by_index=True))\n+\n+\n+def _liftable_agg(meth):\n+  name, func = frame_base.name_and_func(meth)\n+\n+  def wrapper(self, *args, **kargs):\n+    assert isinstance(self, DeferredGroupBy)\n+    ungrouped = self._expr.args()[0]\n+    pre_agg = expressions.ComputedExpression(\n+        'pre_combine_' + name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [ungrouped],\n+        requires_partition_by_index=False,\n+        preserves_partition_by_index=True)\n+    post_agg = expressions.ComputedExpression(\n+        'post_combine_' + name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [pre_agg],\n+        requires_partition_by_index=True,\n+        preserves_partition_by_index=True)\n+    return frame_base.DeferredFrame.wrap(post_agg)\n+\n+  return wrapper\n+\n+\n+def _unliftable_agg(meth):\n+  name, func = frame_base.name_and_func(meth)\n+\n+  def wrapper(self, *args, **kargs):\n+    assert isinstance(self, DeferredGroupBy)\n+    ungrouped = self._expr.args()[0]\n+    post_agg = expressions.ComputedExpression(\n+        name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [ungrouped],\n+        requires_partition_by_index=True,\n+        preserves_partition_by_index=True)\n+    return frame_base.DeferredFrame.wrap(post_agg)\n+\n+  return wrapper\n+\n+\n+for meth in ['all', 'any', 'max', 'min', 'prod', 'size', 'sum']:\n+  setattr(DeferredGroupBy, meth, _liftable_agg(meth))\n+for meth in ['mean', 'median', 'std', 'var']:\n+  setattr(DeferredGroupBy, meth, _unliftable_agg(meth))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0b9c69c5b71417a212c201a01bc7f0bf40ff211"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMjI5Mg==", "bodyText": "Somewhat related: I wonder if there's some way to get a full accounting of pandas operations, so we can create functions that raise NotImplementedError for \"everything else\" and/or generate a to-do list for future work. Would it be reasonable to use dir(pd.core.groupby.generic.DataFrameGroupBy) minus internal functions?", "url": "https://github.com/apache/beam/pull/10757#discussion_r389132292", "createdAt": "2020-03-06T20:38:58Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -0,0 +1,208 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import pandas as pd\n+\n+from apache_beam.dataframe import expressions\n+from apache_beam.dataframe import frame_base\n+\n+\n+@frame_base.DeferredFrame._register_for(pd.Series)\n+class DeferredSeries(frame_base.DeferredFrame):\n+  pass\n+\n+\n+for base in ['add', 'sub', 'mul', 'div', 'truediv', 'floordiv', 'mod', 'pow']:\n+  for p in ['%s', 'r%s', '__%s__', '__r%s__']:\n+    # TODO: non-trivial level?\n+    name = p % base\n+    setattr(\n+        DeferredSeries,\n+        name,\n+        frame_base._elementwise_method(name, restrictions={'level': None}))\n+  setattr(\n+      DeferredSeries,\n+      '__i%s__' % base,\n+      frame_base._elementwise_method('__i%s__' % base, inplace=True))\n+for name in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n+  setattr(DeferredSeries, name, frame_base._elementwise_method(name))\n+for name in ['apply', 'map', 'transform']:\n+  setattr(DeferredSeries, name, frame_base._elementwise_method(name))\n+\n+\n+@frame_base.DeferredFrame._register_for(pd.DataFrame)\n+class DeferredDataFrame(frame_base.DeferredFrame):\n+  def groupby(self, cols):\n+    # TODO: what happens to the existing index?\n+    # We set the columns to index as we have a notion of being partitioned by\n+    # index, but not partitioned by an arbitrary subset of columns.\n+    return DeferredGroupBy(\n+        expressions.ComputedExpression(\n+            'groupbyindex',\n+            lambda df: df.groupby(level=list(range(df.index.nlevels))),\n+            [self.set_index(cols)._expr],\n+            requires_partition_by_index=True,\n+            preserves_partition_by_index=True))\n+\n+  def __getattr__(self, name):\n+    # Column attribute access.\n+    if name in self._expr.proxy().columns:\n+      return self[name]\n+    else:\n+      return super(DeferredDataFrame, self).__getattr__(name)\n+\n+  def __getitem__(self, key):\n+    if key in self._expr.proxy().columns:\n+      return self._elementwise(lambda df: df[key], 'get_column')\n+    else:\n+      raise NotImplementedError(key)\n+\n+  def __setitem__(self, key, value):\n+    if isinstance(key, str):\n+      # yapf: disable\n+      return self._elementwise(\n+          lambda df, key, value: df.__setitem__(key, value),\n+          'set_column',\n+          (key, value),\n+          inplace=True)\n+    else:\n+      raise NotImplementedError(key)\n+\n+  def set_index(self, keys, **kwargs):\n+    if isinstance(keys, str):\n+      keys = [keys]\n+    else:\n+      keys = keys\n+    if not set(keys).issubset(self._expr.proxy().columns):\n+      raise NotImplementedError(keys)\n+    return self._elementwise(\n+        lambda df: df.set_index(keys, **kwargs),\n+        'set_index',\n+        inplace=kwargs.get('inplace', False))\n+\n+  def at(self, *args, **kwargs):\n+    raise NotImplementedError()\n+\n+  @property\n+  def loc(self):\n+    return _DeferredLoc(self)\n+\n+\n+class DeferredGroupBy(frame_base.DeferredFrame):\n+  def agg(self, fn):\n+    if not callable(fn):\n+      raise NotImplementedError(fn)\n+    return DeferredDataFrame(\n+        expressions.ComputedExpression(\n+            'agg',\n+            lambda df: df.agg(fn), [self._expr],\n+            requires_partition_by_index=True,\n+            preserves_partition_by_index=True))\n+\n+\n+def _liftable_agg(meth):\n+  name, func = frame_base.name_and_func(meth)\n+\n+  def wrapper(self, *args, **kargs):\n+    assert isinstance(self, DeferredGroupBy)\n+    ungrouped = self._expr.args()[0]\n+    pre_agg = expressions.ComputedExpression(\n+        'pre_combine_' + name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [ungrouped],\n+        requires_partition_by_index=False,\n+        preserves_partition_by_index=True)\n+    post_agg = expressions.ComputedExpression(\n+        'post_combine_' + name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [pre_agg],\n+        requires_partition_by_index=True,\n+        preserves_partition_by_index=True)\n+    return frame_base.DeferredFrame.wrap(post_agg)\n+\n+  return wrapper\n+\n+\n+def _unliftable_agg(meth):\n+  name, func = frame_base.name_and_func(meth)\n+\n+  def wrapper(self, *args, **kargs):\n+    assert isinstance(self, DeferredGroupBy)\n+    ungrouped = self._expr.args()[0]\n+    post_agg = expressions.ComputedExpression(\n+        name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [ungrouped],\n+        requires_partition_by_index=True,\n+        preserves_partition_by_index=True)\n+    return frame_base.DeferredFrame.wrap(post_agg)\n+\n+  return wrapper\n+\n+\n+for meth in ['all', 'any', 'max', 'min', 'prod', 'size', 'sum']:\n+  setattr(DeferredGroupBy, meth, _liftable_agg(meth))\n+for meth in ['mean', 'median', 'std', 'var']:\n+  setattr(DeferredGroupBy, meth, _unliftable_agg(meth))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MzcwNA=="}, "originalCommit": {"oid": "a0b9c69c5b71417a212c201a01bc7f0bf40ff211"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0OTY2NA==", "bodyText": "Pulled these out into constants.\nYes, I think doing dir(cls) to both fill in NotImplemented methods and track current progress would be good to do (and we already have the correspondence with DeferredFrame._register_for).", "url": "https://github.com/apache/beam/pull/10757#discussion_r392349664", "createdAt": "2020-03-13T16:50:09Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -0,0 +1,208 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import pandas as pd\n+\n+from apache_beam.dataframe import expressions\n+from apache_beam.dataframe import frame_base\n+\n+\n+@frame_base.DeferredFrame._register_for(pd.Series)\n+class DeferredSeries(frame_base.DeferredFrame):\n+  pass\n+\n+\n+for base in ['add', 'sub', 'mul', 'div', 'truediv', 'floordiv', 'mod', 'pow']:\n+  for p in ['%s', 'r%s', '__%s__', '__r%s__']:\n+    # TODO: non-trivial level?\n+    name = p % base\n+    setattr(\n+        DeferredSeries,\n+        name,\n+        frame_base._elementwise_method(name, restrictions={'level': None}))\n+  setattr(\n+      DeferredSeries,\n+      '__i%s__' % base,\n+      frame_base._elementwise_method('__i%s__' % base, inplace=True))\n+for name in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n+  setattr(DeferredSeries, name, frame_base._elementwise_method(name))\n+for name in ['apply', 'map', 'transform']:\n+  setattr(DeferredSeries, name, frame_base._elementwise_method(name))\n+\n+\n+@frame_base.DeferredFrame._register_for(pd.DataFrame)\n+class DeferredDataFrame(frame_base.DeferredFrame):\n+  def groupby(self, cols):\n+    # TODO: what happens to the existing index?\n+    # We set the columns to index as we have a notion of being partitioned by\n+    # index, but not partitioned by an arbitrary subset of columns.\n+    return DeferredGroupBy(\n+        expressions.ComputedExpression(\n+            'groupbyindex',\n+            lambda df: df.groupby(level=list(range(df.index.nlevels))),\n+            [self.set_index(cols)._expr],\n+            requires_partition_by_index=True,\n+            preserves_partition_by_index=True))\n+\n+  def __getattr__(self, name):\n+    # Column attribute access.\n+    if name in self._expr.proxy().columns:\n+      return self[name]\n+    else:\n+      return super(DeferredDataFrame, self).__getattr__(name)\n+\n+  def __getitem__(self, key):\n+    if key in self._expr.proxy().columns:\n+      return self._elementwise(lambda df: df[key], 'get_column')\n+    else:\n+      raise NotImplementedError(key)\n+\n+  def __setitem__(self, key, value):\n+    if isinstance(key, str):\n+      # yapf: disable\n+      return self._elementwise(\n+          lambda df, key, value: df.__setitem__(key, value),\n+          'set_column',\n+          (key, value),\n+          inplace=True)\n+    else:\n+      raise NotImplementedError(key)\n+\n+  def set_index(self, keys, **kwargs):\n+    if isinstance(keys, str):\n+      keys = [keys]\n+    else:\n+      keys = keys\n+    if not set(keys).issubset(self._expr.proxy().columns):\n+      raise NotImplementedError(keys)\n+    return self._elementwise(\n+        lambda df: df.set_index(keys, **kwargs),\n+        'set_index',\n+        inplace=kwargs.get('inplace', False))\n+\n+  def at(self, *args, **kwargs):\n+    raise NotImplementedError()\n+\n+  @property\n+  def loc(self):\n+    return _DeferredLoc(self)\n+\n+\n+class DeferredGroupBy(frame_base.DeferredFrame):\n+  def agg(self, fn):\n+    if not callable(fn):\n+      raise NotImplementedError(fn)\n+    return DeferredDataFrame(\n+        expressions.ComputedExpression(\n+            'agg',\n+            lambda df: df.agg(fn), [self._expr],\n+            requires_partition_by_index=True,\n+            preserves_partition_by_index=True))\n+\n+\n+def _liftable_agg(meth):\n+  name, func = frame_base.name_and_func(meth)\n+\n+  def wrapper(self, *args, **kargs):\n+    assert isinstance(self, DeferredGroupBy)\n+    ungrouped = self._expr.args()[0]\n+    pre_agg = expressions.ComputedExpression(\n+        'pre_combine_' + name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [ungrouped],\n+        requires_partition_by_index=False,\n+        preserves_partition_by_index=True)\n+    post_agg = expressions.ComputedExpression(\n+        'post_combine_' + name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [pre_agg],\n+        requires_partition_by_index=True,\n+        preserves_partition_by_index=True)\n+    return frame_base.DeferredFrame.wrap(post_agg)\n+\n+  return wrapper\n+\n+\n+def _unliftable_agg(meth):\n+  name, func = frame_base.name_and_func(meth)\n+\n+  def wrapper(self, *args, **kargs):\n+    assert isinstance(self, DeferredGroupBy)\n+    ungrouped = self._expr.args()[0]\n+    post_agg = expressions.ComputedExpression(\n+        name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [ungrouped],\n+        requires_partition_by_index=True,\n+        preserves_partition_by_index=True)\n+    return frame_base.DeferredFrame.wrap(post_agg)\n+\n+  return wrapper\n+\n+\n+for meth in ['all', 'any', 'max', 'min', 'prod', 'size', 'sum']:\n+  setattr(DeferredGroupBy, meth, _liftable_agg(meth))\n+for meth in ['mean', 'median', 'std', 'var']:\n+  setattr(DeferredGroupBy, meth, _unliftable_agg(meth))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MzcwNA=="}, "originalCommit": {"oid": "a0b9c69c5b71417a212c201a01bc7f0bf40ff211"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTAyMzIwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMDozMDowNVrOFzGh0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNjo1MTo0MlrOF2LLVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyODY1Ng==", "bodyText": "It doesn't look like this import is actually used in this file. Given how closely related frame and frame_base are, I wonder if they should just be combined?", "url": "https://github.com/apache/beam/pull/10757#discussion_r389128656", "createdAt": "2020-03-06T20:30:05Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames_test.py", "diffHunk": "@@ -0,0 +1,79 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+import numpy as np\n+import pandas as pd\n+\n+from apache_beam.dataframe import expressions\n+from apache_beam.dataframe import frame_base\n+from apache_beam.dataframe import frames", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0b9c69c5b71417a212c201a01bc7f0bf40ff211"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MDU0OA==", "bodyText": "The idea here is that frame_base would contain the infrastructure, and frame would grow to include the concrete implementations of various operations (which would grow over time).", "url": "https://github.com/apache/beam/pull/10757#discussion_r392350548", "createdAt": "2020-03-13T16:51:42Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames_test.py", "diffHunk": "@@ -0,0 +1,79 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+import numpy as np\n+import pandas as pd\n+\n+from apache_beam.dataframe import expressions\n+from apache_beam.dataframe import frame_base\n+from apache_beam.dataframe import frames", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyODY1Ng=="}, "originalCommit": {"oid": "a0b9c69c5b71417a212c201a01bc7f0bf40ff211"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2143, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}