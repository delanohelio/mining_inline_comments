{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MDA4MDgx", "number": 11922, "title": "[BEAM-2939] Fix FnApiDoFnRunner to ensure that we output within the correct window when processing a splittable dofn", "bodyText": "This fixes a bug where we would output within all the windows instead of just the current window.\nThis would not impact any SDF that used only a single window while processing.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-06-04T18:15:14Z", "url": "https://github.com/apache/beam/pull/11922", "merged": true, "mergeCommit": {"oid": "96836a741558ba93ab367b44ad46fbbf28b86449"}, "closed": true, "closedAt": "2020-06-05T21:04:29Z", "author": {"login": "lukecwik"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoCKwsgH2gAyNDI4MDA4MDgxOjBiZWVjNmE5ZjIxYjEzOWQwYTY1ZGZhNjk5Yzk1MDk1MTM0MDQ3MTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcoXrvpgFqTQyNTU2MTc5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0beec6a9f21b139d0a65dfa699c9509513404710", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/0beec6a9f21b139d0a65dfa699c9509513404710", "committedDate": "2020-06-04T18:14:37Z", "message": "[BEAM-2939] Fix FnApiDoFnRunner to ensure that we output within the correct window.\n\nThis fixes a bug where we would output within all the windows instead of just the current window.\nThis would not impact any SDF that used only a single window while processing."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NzkyNjQ3", "url": "https://github.com/apache/beam/pull/11922#pullrequestreview-424792647", "createdAt": "2020-06-04T20:12:08Z", "commit": {"oid": "0beec6a9f21b139d0a65dfa699c9509513404710"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxMjowOFrOGfWIeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxMjowOFrOGfWIeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTY1Nw==", "bodyText": "I'm wondering why the split is on the first window?", "url": "https://github.com/apache/beam/pull/11922#discussion_r435521657", "createdAt": "2020-06-04T20:12:08Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java", "diffHunk": "@@ -1593,6 +1601,391 @@ public void testProcessElementForSizedElementAndRestriction() throws Exception {\n     assertEquals(stateData, fakeClient.getData());\n   }\n \n+  @Test\n+  public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n+    Pipeline p = Pipeline.create();\n+    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+    TestSplittableDoFn doFn = new TestSplittableDoFn(singletonSideInputView);\n+\n+    valuePCollection\n+        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+        .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+    RunnerApi.Pipeline pProto =\n+        ProtoOverrides.updateTransform(\n+            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+            SplittableParDoExpander.createSizedReplacement());\n+    String expandedTransformId =\n+        Iterables.find(\n+                pProto.getComponents().getTransformsMap().entrySet(),\n+                entry ->\n+                    entry\n+                            .getValue()\n+                            .getSpec()\n+                            .getUrn()\n+                            .equals(\n+                                PTransformTranslation\n+                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+            .getKey();\n+    RunnerApi.PTransform pTransform =\n+        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+    String inputPCollectionId =\n+        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+    RunnerApi.PCollection inputPCollection =\n+        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+    RehydratedComponents rehydratedComponents =\n+        RehydratedComponents.forComponents(pProto.getComponents());\n+    Coder<WindowedValue> inputCoder =\n+        WindowedValue.getFullCoder(\n+            CoderTranslation.fromProto(\n+                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                rehydratedComponents,\n+                TranslationContext.DEFAULT),\n+            (Coder)\n+                CoderTranslation.fromProto(\n+                    pProto\n+                        .getComponents()\n+                        .getCodersOrThrow(\n+                            pProto\n+                                .getComponents()\n+                                .getWindowingStrategiesOrThrow(\n+                                    inputPCollection.getWindowingStrategyId())\n+                                .getWindowCoderId()),\n+                    rehydratedComponents,\n+                    TranslationContext.DEFAULT));\n+    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+    ImmutableMap<StateKey, ByteString> stateData =\n+        ImmutableMap.of(\n+            multimapSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+            encode(\"8\"));\n+\n+    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+    PCollectionConsumerRegistry consumers =\n+        new PCollectionConsumerRegistry(\n+            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+    consumers.register(\n+        outputPCollectionId,\n+        TEST_TRANSFORM_ID,\n+        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+    PTransformFunctionRegistry startFunctionRegistry =\n+        new PTransformFunctionRegistry(\n+            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+    PTransformFunctionRegistry finishFunctionRegistry =\n+        new PTransformFunctionRegistry(\n+            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+    new FnApiDoFnRunner.Factory<>()\n+        .createRunnerForPTransform(\n+            PipelineOptionsFactory.create(),\n+            null /* beamFnDataClient */,\n+            fakeClient,\n+            null /* beamFnTimerClient */,\n+            TEST_TRANSFORM_ID,\n+            pTransform,\n+            Suppliers.ofInstance(\"57L\")::get,\n+            pProto.getComponents().getPcollectionsMap(),\n+            pProto.getComponents().getCodersMap(),\n+            pProto.getComponents().getWindowingStrategiesMap(),\n+            consumers,\n+            startFunctionRegistry,\n+            finishFunctionRegistry,\n+            teardownFunctions::add,\n+            progressRequestCallbacks::add,\n+            splitListener,\n+            null /* bundleFinalizer */);\n+\n+    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+    mainOutputValues.clear();\n+\n+    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+    FnDataReceiver<WindowedValue<?>> mainInput =\n+        consumers.getMultiplexingConsumer(inputPCollectionId);\n+    assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+    {\n+      // Check that before processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      // Check that after processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+      // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n+      // watermark.\n+      assertEquals(2, splitListener.getPrimaryRoots().size());\n+      assertEquals(2, splitListener.getResidualRoots().size());\n+      for (int i = 0; i < splitListener.getPrimaryRoots().size(); ++i) {\n+        BundleApplication primaryRoot = splitListener.getPrimaryRoots().get(i);\n+        DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(i);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+      }\n+      assertThat(\n+          Collections2.transform(\n+              splitListener.getPrimaryRoots(), (root) -> decode(inputCoder, root.getElement())),\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane())));\n+      assertThat(\n+          Collections2.transform(\n+              splitListener.getResidualRoots(),\n+              (root) -> decode(inputCoder, root.getApplication().getElement())),\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\n+                          \"5\",\n+                          KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\n+                          \"5\",\n+                          KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane())));\n+      splitListener.clear();\n+\n+      // Check that before processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n+              window1,\n+              window2);\n+      mainInput.accept(secondValue);\n+      // Check that after processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window2, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window2, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window2, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window2, firstValue.getPane())));\n+      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+      assertTrue(splitListener.getResidualRoots().isEmpty());\n+      mainOutputValues.clear();\n+    }\n+\n+    {\n+      // Setup and launch the trySplit thread.\n+      ExecutorService executorService = Executors.newSingleThreadExecutor();\n+      Future<HandlesSplits.SplitResult> trySplitFuture =\n+          executorService.submit(\n+              () -> {\n+                try {\n+                  doFn.waitForSplitElementToBeProcessed();\n+                  // Currently processing \"3\" out of range [0, 5) elements.\n+                  assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                  // Check that during progressing of an element we report progress\n+                  List<MonitoringInfo> mis =\n+                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                  expectedCompleted.putLabels(\n+                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                  expectedCompleted.setPayload(\n+                      ByteString.copyFrom(\n+                          CoderUtils.encodeToByteArray(\n+                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n+                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                  expectedRemaining.putLabels(\n+                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                  expectedRemaining.setPayload(\n+                      ByteString.copyFrom(\n+                          CoderUtils.encodeToByteArray(\n+                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(2.0))));\n+                  assertThat(\n+                      mis,\n+                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                  return ((HandlesSplits) mainInput).trySplit(0);\n+                } finally {\n+                  doFn.releaseWaitingProcessElementThread();\n+                }\n+              });\n+\n+      // Check that before processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      WindowedValue<?> splitValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n+              window1,\n+              window2);\n+      mainInput.accept(splitValue);\n+      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+      // Check that after processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first window.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0beec6a9f21b139d0a65dfa699c9509513404710"}, "originalPosition": 356}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f58af70504e4cfc12212d56c576bec87c2599d38", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/f58af70504e4cfc12212d56c576bec87c2599d38", "committedDate": "2020-06-04T23:17:06Z", "message": "Make sure that splitting/checkpointing is window aware."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTAzMzM5", "url": "https://github.com/apache/beam/pull/11922#pullrequestreview-425503339", "createdAt": "2020-06-05T17:49:45Z", "commit": {"oid": "f58af70504e4cfc12212d56c576bec87c2599d38"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo0OTo0NVrOGf3wZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODozNTowNFrOGf5SBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MjU0OA==", "bodyText": "Duplicated {@link #processElementForSizedElementAndRestriction}?", "url": "https://github.com/apache/beam/pull/11922#discussion_r436072548", "createdAt": "2020-06-05T17:49:45Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -296,6 +299,12 @@ public void accept(WindowedValue input) throws Exception {\n   /** Only valid during {@code processElement...} methods, null otherwise. */\n   private WindowedValue<InputT> currentElement;\n \n+  /**\n+   * Only valid during {@link #processElementForSizedElementAndRestriction} and {@link\n+   * #processElementForSizedElementAndRestriction}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f58af70504e4cfc12212d56c576bec87c2599d38"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4NTIwNA==", "bodyText": "currentWindowIterator .next()?", "url": "https://github.com/apache/beam/pull/11922#discussion_r436085204", "createdAt": "2020-06-05T18:12:09Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -577,26 +586,83 @@ public Instant timestamp(DoFn<InputT, OutputT> doFn) {\n     switch (pTransform.getSpec().getUrn()) {\n       case PTransformTranslation.SPLITTABLE_PROCESS_ELEMENTS_URN:\n         this.convertSplitResultToWindowedSplitResult =\n-            (splitResult, watermarkEstimatorState) ->\n-                WindowedSplitResult.forRoots(\n-                    WindowedValue.of(\n-                        KV.of(\n-                            currentElement.getValue(),\n-                            KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n-                        currentElement.getTimestamp(),\n-                        currentWindow,\n-                        currentElement.getPane()),\n-                    WindowedValue.of(\n-                        KV.of(\n-                            currentElement.getValue(),\n-                            KV.of(splitResult.getResidual(), watermarkEstimatorState)),\n-                        currentElement.getTimestamp(),\n-                        currentWindow,\n-                        currentElement.getPane()));\n+            (splitResult, watermarkEstimatorState) -> {\n+              List<BoundedWindow> primaryFullyProcessedWindows =\n+                  ImmutableList.copyOf(\n+                      Iterables.limit(\n+                          currentElement.getWindows(), currentWindowIterator.previousIndex()));\n+              // Advances the iterator consuming the remaining windows.\n+              List<BoundedWindow> residualUnprocessedWindows =\n+                  ImmutableList.copyOf(currentWindowIterator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f58af70504e4cfc12212d56c576bec87c2599d38"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4NTQ4OA==", "bodyText": "currentWindowIterator.next()?", "url": "https://github.com/apache/beam/pull/11922#discussion_r436085488", "createdAt": "2020-06-05T18:12:33Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -577,26 +586,83 @@ public Instant timestamp(DoFn<InputT, OutputT> doFn) {\n     switch (pTransform.getSpec().getUrn()) {\n       case PTransformTranslation.SPLITTABLE_PROCESS_ELEMENTS_URN:\n         this.convertSplitResultToWindowedSplitResult =\n-            (splitResult, watermarkEstimatorState) ->\n-                WindowedSplitResult.forRoots(\n-                    WindowedValue.of(\n-                        KV.of(\n-                            currentElement.getValue(),\n-                            KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n-                        currentElement.getTimestamp(),\n-                        currentWindow,\n-                        currentElement.getPane()),\n-                    WindowedValue.of(\n-                        KV.of(\n-                            currentElement.getValue(),\n-                            KV.of(splitResult.getResidual(), watermarkEstimatorState)),\n-                        currentElement.getTimestamp(),\n-                        currentWindow,\n-                        currentElement.getPane()));\n+            (splitResult, watermarkEstimatorState) -> {\n+              List<BoundedWindow> primaryFullyProcessedWindows =\n+                  ImmutableList.copyOf(\n+                      Iterables.limit(\n+                          currentElement.getWindows(), currentWindowIterator.previousIndex()));\n+              // Advances the iterator consuming the remaining windows.\n+              List<BoundedWindow> residualUnprocessedWindows =\n+                  ImmutableList.copyOf(currentWindowIterator);\n+              return WindowedSplitResult.forRoots(\n+                  primaryFullyProcessedWindows.isEmpty()\n+                      ? null\n+                      : WindowedValue.of(\n+                          KV.of(\n+                              currentElement.getValue(),\n+                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                          currentElement.getTimestamp(),\n+                          primaryFullyProcessedWindows,\n+                          currentElement.getPane()),\n+                  WindowedValue.of(\n+                      KV.of(\n+                          currentElement.getValue(),\n+                          KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n+                      currentElement.getTimestamp(),\n+                      currentWindow,\n+                      currentElement.getPane()),\n+                  WindowedValue.of(\n+                      KV.of(\n+                          currentElement.getValue(),\n+                          KV.of(splitResult.getResidual(), watermarkEstimatorState)),\n+                      currentElement.getTimestamp(),\n+                      currentWindow,\n+                      currentElement.getPane()),\n+                  residualUnprocessedWindows.isEmpty()\n+                      ? null\n+                      : WindowedValue.of(\n+                          KV.of(\n+                              currentElement.getValue(),\n+                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                          currentElement.getTimestamp(),\n+                          residualUnprocessedWindows,\n+                          currentElement.getPane()));\n+            };\n         break;\n       case PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN:\n         this.convertSplitResultToWindowedSplitResult =\n             (splitResult, watermarkEstimatorState) -> {\n+              List<BoundedWindow> primaryFullyProcessedWindows =\n+                  ImmutableList.copyOf(\n+                      Iterables.limit(\n+                          currentElement.getWindows(), currentWindowIterator.previousIndex()));\n+              // Advances the iterator consuming the remaining windows.\n+              List<BoundedWindow> residualUnprocessedWindows =\n+                  ImmutableList.copyOf(currentWindowIterator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f58af70504e4cfc12212d56c576bec87c2599d38"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5MzA0OA==", "bodyText": "I'm wondering should the size be fullSize * num of windows?", "url": "https://github.com/apache/beam/pull/11922#discussion_r436093048", "createdAt": "2020-06-05T18:26:02Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -632,6 +698,17 @@ public Object restriction() {\n                         }\n                       });\n               return WindowedSplitResult.forRoots(\n+                  primaryFullyProcessedWindows.isEmpty()\n+                      ? null\n+                      : WindowedValue.of(\n+                          KV.of(\n+                              KV.of(\n+                                  currentElement.getValue(),\n+                                  KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                              fullSize),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f58af70504e4cfc12212d56c576bec87c2599d38"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5NzU0Mw==", "bodyText": "This also takes care of self checkpoint, right?", "url": "https://github.com/apache/beam/pull/11922#discussion_r436097543", "createdAt": "2020-06-05T18:35:04Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -941,20 +1047,59 @@ private Progress getProgress() {\n           convertSplitResultToWindowedSplitResult.apply(result, watermarkAndState.getValue());\n     }\n \n+    List<BundleApplication> primaryRoots = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f58af70504e4cfc12212d56c576bec87c2599d38"}, "originalPosition": 253}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16d4619eb8fb312347a3ab73c7efadcee7f75a5d", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/16d4619eb8fb312347a3ab73c7efadcee7f75a5d", "committedDate": "2020-06-05T19:08:13Z", "message": "fixup! Address PR comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTYxNzk0", "url": "https://github.com/apache/beam/pull/11922#pullrequestreview-425561794", "createdAt": "2020-06-05T19:18:39Z", "commit": {"oid": "16d4619eb8fb312347a3ab73c7efadcee7f75a5d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4019, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}