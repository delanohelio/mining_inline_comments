{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0MTM3OTE0", "number": 559, "title": "[OC-1144] Adds parents to entity and forbides cycle in transitive ref\"", "bodyText": "Signed-off-by: LE-GALL Ronan Ext 43667786+rlg-rte@users.noreply.github.com\nFeature:\nOC-1144 adds parent reference declaration to entity+\nA cycle detection is performed when post or patch of Entities", "createdAt": "2020-11-02T15:30:44Z", "url": "https://github.com/opfab/operatorfabric-core/pull/559", "merged": true, "mergeCommit": {"oid": "0b70015972abfa561e426cc1a22b0083719c0add"}, "closed": true, "closedAt": "2020-11-05T12:21:50Z", "author": {"login": "rlg-pro"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdYmRELgH2gAyNTE0MTM3OTE0OjMzYzQ4YzI0ZDVlZDlkYzRlYzZiZDgwMGZjZWZlYzk4YThkNjk1OTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZgUoFAH2gAyNTE0MTM3OTE0OjIzN2FhMGFiNmEwM2NlZDBjNjIwZTlmN2M4MzZjY2FiNzc4ODUyZWM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591", "author": {"user": {"login": "rlg-pro", "name": null}}, "url": "https://github.com/opfab/operatorfabric-core/commit/33c48c24d5ed9dc4ec6bd800fcefec98a8d69591", "committedDate": "2020-11-02T15:26:27Z", "message": "[OC-1144] Adds parents to entity and forbides cycle in transitive ref\"\n\nSigned-off-by: LE-GALL Ronan Ext <43667786+rlg-rte@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMzcxMTAy", "url": "https://github.com/opfab/operatorfabric-core/pull/559#pullrequestreview-522371102", "createdAt": "2020-11-03T10:40:40Z", "commit": {"oid": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMDo0MDo0MFrOHspBOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMzowMTo0N1rOHstv3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU3MTQ1MQ==", "bodyText": "Put it in package org.lfenergy.operatorfabric.users.utils", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516571451", "createdAt": "2020-11-03T10:40:40Z", "author": {"login": "freddidierRTE"}, "path": "services/core/users/src/main/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetector.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package org.lfenergy.operatorfabric.users.controllers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU3OTM3NA==", "bodyText": "You should sychronized this bock of code", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516579374", "createdAt": "2020-11-03T10:54:07Z", "author": {"login": "freddidierRTE"}, "path": "services/core/users/src/main/java/org/lfenergy/operatorfabric/users/controllers/EntitiesController.java", "diffHunk": "@@ -81,9 +82,18 @@ public Entity createEntity(HttpServletRequest request, HttpServletResponse respo\n             response.addHeader(\"Location\", request.getContextPath() + \"/entities/\" + entity.getId());\n             response.setStatus(201);\n         }\n+        // let's do this quite mindlessly\n+        List<EntityData> entities = entityRepository.findAll();\n+        this.checkForCycleInEntityParenthood(entity, entities);\n         return entityRepository.save((EntityData) entity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzMjM4Mw==", "bodyText": "Why not just :\n.filter(entity -> { if (entity == null) return false; return !entity.getId().equals(currentEntity.getId(); }) ...", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516632383", "createdAt": "2020-11-03T12:32:28Z", "author": {"login": "freddidierRTE"}, "path": "services/core/users/src/main/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetector.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package org.lfenergy.operatorfabric.users.controllers;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiError;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiErrorException;\n+import org.lfenergy.operatorfabric.users.model.Entity;\n+import org.springframework.http.HttpStatus;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/*\n+This helper class presumes that stored Entities don't cycle (beware manual database updates)\n+ */\n+@Slf4j\n+public class EntityCycleDetector {\n+    final private List<String> visitedId;\n+    final private Map<String, List<String>> graph;\n+    final private String currentEntityId;\n+\n+    EntityCycleDetector(Entity currentEntity, List<? extends Entity> allEntities) {\n+        this.currentEntityId = currentEntity.getId();\n+        Set<Entity> allEntitiesPlusNewOne = allEntities.stream()\n+                // allow update of an entity by removing its former version from inspected entities\n+                .filter(entity -> {\n+                    if (entity == null) return false;\n+                    boolean idDifference = entity.getId().equals(currentEntity.getId());\n+                    boolean isNewEntity = entity.equals(currentEntity);\n+                    boolean isNotPreviousVersionOfTheUpdateEntity = !idDifference || isNewEntity;\n+                    return isNotPreviousVersionOfTheUpdateEntity;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzMzUyMg==", "bodyText": "genuineAddition shoud always return true as the entity has been removed from the Set ?", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516633522", "createdAt": "2020-11-03T12:34:38Z", "author": {"login": "freddidierRTE"}, "path": "services/core/users/src/main/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetector.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package org.lfenergy.operatorfabric.users.controllers;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiError;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiErrorException;\n+import org.lfenergy.operatorfabric.users.model.Entity;\n+import org.springframework.http.HttpStatus;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/*\n+This helper class presumes that stored Entities don't cycle (beware manual database updates)\n+ */\n+@Slf4j\n+public class EntityCycleDetector {\n+    final private List<String> visitedId;\n+    final private Map<String, List<String>> graph;\n+    final private String currentEntityId;\n+\n+    EntityCycleDetector(Entity currentEntity, List<? extends Entity> allEntities) {\n+        this.currentEntityId = currentEntity.getId();\n+        Set<Entity> allEntitiesPlusNewOne = allEntities.stream()\n+                // allow update of an entity by removing its former version from inspected entities\n+                .filter(entity -> {\n+                    if (entity == null) return false;\n+                    boolean idDifference = entity.getId().equals(currentEntity.getId());\n+                    boolean isNewEntity = entity.equals(currentEntity);\n+                    boolean isNotPreviousVersionOfTheUpdateEntity = !idDifference || isNewEntity;\n+                    return isNotPreviousVersionOfTheUpdateEntity;\n+                })\n+                .collect(Collectors.toSet());\n+        boolean genuineAddition = allEntitiesPlusNewOne.add(currentEntity);\n+        if (genuineAddition) {\n+            this.graph = allEntitiesPlusNewOne.stream()\n+                    .collect(Collectors.toMap(Entity::getId, entity -> entity.getParents()));\n+        } else {\n+            // no detection needed has entity identical to stored one\n+            this.graph = Collections.emptyMap();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzNTUxMw==", "bodyText": "parentEntityId instead of childEntityId", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516635513", "createdAt": "2020-11-03T12:38:21Z", "author": {"login": "freddidierRTE"}, "path": "services/core/users/src/main/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetector.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package org.lfenergy.operatorfabric.users.controllers;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiError;\n+import org.lfenergy.operatorfabric.springtools.error.model.ApiErrorException;\n+import org.lfenergy.operatorfabric.users.model.Entity;\n+import org.springframework.http.HttpStatus;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/*\n+This helper class presumes that stored Entities don't cycle (beware manual database updates)\n+ */\n+@Slf4j\n+public class EntityCycleDetector {\n+    final private List<String> visitedId;\n+    final private Map<String, List<String>> graph;\n+    final private String currentEntityId;\n+\n+    EntityCycleDetector(Entity currentEntity, List<? extends Entity> allEntities) {\n+        this.currentEntityId = currentEntity.getId();\n+        Set<Entity> allEntitiesPlusNewOne = allEntities.stream()\n+                // allow update of an entity by removing its former version from inspected entities\n+                .filter(entity -> {\n+                    if (entity == null) return false;\n+                    boolean idDifference = entity.getId().equals(currentEntity.getId());\n+                    boolean isNewEntity = entity.equals(currentEntity);\n+                    boolean isNotPreviousVersionOfTheUpdateEntity = !idDifference || isNewEntity;\n+                    return isNotPreviousVersionOfTheUpdateEntity;\n+                })\n+                .collect(Collectors.toSet());\n+        boolean genuineAddition = allEntitiesPlusNewOne.add(currentEntity);\n+        if (genuineAddition) {\n+            this.graph = allEntitiesPlusNewOne.stream()\n+                    .collect(Collectors.toMap(Entity::getId, entity -> entity.getParents()));\n+        } else {\n+            // no detection needed has entity identical to stored one\n+            this.graph = Collections.emptyMap();\n+        }\n+        this.visitedId = new ArrayList<>(graph.size());\n+    }\n+\n+    void throwApiExceptionOnCycle() {\n+        if (hasCycle()) {\n+            String cycle = String.join(\"->\", visitedId);\n+            throw new ApiErrorException(\n+                    ApiError.builder()\n+                            .status(HttpStatus.BAD_REQUEST)\n+                            .message(EntitiesController.CYCLE_DETECTION + \": \" + cycle)\n+                            .build());\n+        }\n+    }\n+    // inspects only cycle introduce by new entity and stops on the first one detected\n+    boolean hasCycle() {\n+        if(graph.isEmpty()) return false;// false entity update, i.e. stored and new one are identical\n+        return hasCycle(this.currentEntityId, visitedId);\n+    }\n+\n+    private boolean hasCycle(String entityId, List<String> visited) {\n+        if (visited.contains(entityId)){\n+            visited.add(entityId); // for error message clarity\n+            return true;\n+        }\n+        visited.add(entityId);\n+        if (graph.containsKey(entityId)) {\n+            for (String childEntityId : graph.get(entityId)) {\n+                if (hasCycle(childEntityId, visited)) return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzNzkyMw==", "bodyText": "the collection is not empty in this test", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516637923", "createdAt": "2020-11-03T12:42:37Z", "author": {"login": "freddidierRTE"}, "path": "services/core/users/src/test/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetectorShould.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.lfenergy.operatorfabric.users.controllers;\n+\n+import org.junit.jupiter.api.Test;\n+import org.lfenergy.operatorfabric.users.model.Entity;\n+import org.lfenergy.operatorfabric.users.model.EntityData;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class EntityCycleDetectorShould {\n+\n+    /*\n+    Method naming convention expected to ease comprehension of tests\n+    It's a mix of Serpent and Camel Case.\n+    Double '_' to separate \"Given statements\".\n+\n+    Begins with expected result:\n+    - OK -> no cycle detected (hasCycle() return false);\n+    - CYCLE -> a cycle detected within the entities (hasCycle() return true).\n+\n+    THe 3rd part describes the Added Entity (which is tested) and it's parent content.\n+\n+    The 5th part describes the entity collection itself.\n+\n+    Shorthands used:\n+     - 4 -> for;\n+     - 2 -> to.\n+\n+    All constants and helping methods are declared right after the first method using them and are declared in CamelCase.\n+\n+     */\n+\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParents__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        Entity withoutAnyParent = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"this entity has no parents\")\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent, noEntities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    private final String testedEntity = \"entityFreshlyAdded\";\n+\n+    @Test\n+    void OK__4__AddedEntityWithUnknownParents__In__AnEmptyEntityCollection(){\n+        List<EntityData> noEntities = Collections.emptyList();\n+        Entity withoutAnyParent = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"this entity has unknown parents\")\n+                .parents(UNKNOWNPARENTS)\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent, noEntities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    private final Set<String> UNKNOWNPARENTS = Stream.of(\"unknownParent0\", \"unknownParent1\", \"unknownParent2\").collect(Collectors.toSet());\n+\n+    @Test\n+    void CYCLE__4__AddedEntityReferring2Itself__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        String entityId = testedEntity;\n+        Entity entityWithUnknownParents = EntityData.builder()\n+                .id(entityId)\n+                .description(\"this entity references itself\")\n+                .parents(this.buildSet(entityId))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(entityWithUnknownParents, noEntities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private Set<String> buildSet(String... parents) {\n+        return Arrays.asList(parents).stream().collect(Collectors.toSet());\n+    }\n+\n+    @Test\n+    void CYCLE__4__AddedEntityWithUnknownParentsAndReferring2ItSelf__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        String entityId = testedEntity;\n+\n+        Entity withoutAnyParent_And_RefersItself = EntityData.builder()\n+                .id(entityId)\n+                .description(\"this entity has unknown parents AND references itself\")\n+                .parents(this.mixeParentRef(UNKNOWNPARENTS, entityId))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent_And_RefersItself, noEntities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private Set<String> mixeParentRef(Set<String> idCollections, String ... ids){\n+        Set<String> collect = Arrays.stream(ids).collect(Collectors.toSet());\n+        collect.addAll(UNKNOWNPARENTS);\n+        return collect;\n+    }\n+\n+    private final EntityData entityWithNoParent = EntityData.builder()\n+            .id(\"entityWithNoParent\")\n+            .description(\"first entity\").build();\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParent__In__AnEntityCollectionOfOneWithNoParent() {\n+        List<Entity> entities = Arrays.asList(entityWithNoParent);\n+        EntityData has_no_parents = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"has no parents\")\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(has_no_parents, entities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    @Test\n+    void CYCLE__4__AddedEntityReferencingItSelf__In__AnEntityCollectionOfOneWithNoParent() {\n+        List<Entity> entities = Arrays.asList(entityWithNoParent);\n+        EntityData has_no_parents = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"has no parents\")\n+                .parents(this.buildSet(testedEntity))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(has_no_parents, entities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private final EntityData entityReferencingUnknownParents = EntityData.builder()\n+            .id(\"entityReferencingUnknownParent\")\n+            .description(\"this entity as unknown entity has parents\")\n+            .parents(UNKNOWNPARENTS)\n+            .build();\n+    private final EntityData entityReferencingEntityWithNoParents = EntityData.builder()\n+            .id(\"entityWithEntityWithNoParentAsParent\")\n+            .description(\"This entity has a single parent entity, the one with no Parents\")\n+            .parents(this.buildSet(entityWithNoParent))\n+            .build();\n+\n+    private Set<String> buildSet(Entity ... entities) {\n+        return Arrays.stream(entities).map(Entity::getId).collect(Collectors.toSet());\n+    }\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParent__In__AnEmptyEntityCollection () {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzODIwNA==", "bodyText": "the collection is not empty in this test", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516638204", "createdAt": "2020-11-03T12:43:12Z", "author": {"login": "freddidierRTE"}, "path": "services/core/users/src/test/java/org/lfenergy/operatorfabric/users/controllers/EntityCycleDetectorShould.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.lfenergy.operatorfabric.users.controllers;\n+\n+import org.junit.jupiter.api.Test;\n+import org.lfenergy.operatorfabric.users.model.Entity;\n+import org.lfenergy.operatorfabric.users.model.EntityData;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class EntityCycleDetectorShould {\n+\n+    /*\n+    Method naming convention expected to ease comprehension of tests\n+    It's a mix of Serpent and Camel Case.\n+    Double '_' to separate \"Given statements\".\n+\n+    Begins with expected result:\n+    - OK -> no cycle detected (hasCycle() return false);\n+    - CYCLE -> a cycle detected within the entities (hasCycle() return true).\n+\n+    THe 3rd part describes the Added Entity (which is tested) and it's parent content.\n+\n+    The 5th part describes the entity collection itself.\n+\n+    Shorthands used:\n+     - 4 -> for;\n+     - 2 -> to.\n+\n+    All constants and helping methods are declared right after the first method using them and are declared in CamelCase.\n+\n+     */\n+\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParents__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        Entity withoutAnyParent = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"this entity has no parents\")\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent, noEntities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    private final String testedEntity = \"entityFreshlyAdded\";\n+\n+    @Test\n+    void OK__4__AddedEntityWithUnknownParents__In__AnEmptyEntityCollection(){\n+        List<EntityData> noEntities = Collections.emptyList();\n+        Entity withoutAnyParent = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"this entity has unknown parents\")\n+                .parents(UNKNOWNPARENTS)\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent, noEntities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    private final Set<String> UNKNOWNPARENTS = Stream.of(\"unknownParent0\", \"unknownParent1\", \"unknownParent2\").collect(Collectors.toSet());\n+\n+    @Test\n+    void CYCLE__4__AddedEntityReferring2Itself__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        String entityId = testedEntity;\n+        Entity entityWithUnknownParents = EntityData.builder()\n+                .id(entityId)\n+                .description(\"this entity references itself\")\n+                .parents(this.buildSet(entityId))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(entityWithUnknownParents, noEntities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private Set<String> buildSet(String... parents) {\n+        return Arrays.asList(parents).stream().collect(Collectors.toSet());\n+    }\n+\n+    @Test\n+    void CYCLE__4__AddedEntityWithUnknownParentsAndReferring2ItSelf__In__AnEmptyEntityCollection() {\n+        List<EntityData> noEntities = Collections.emptyList();\n+        String entityId = testedEntity;\n+\n+        Entity withoutAnyParent_And_RefersItself = EntityData.builder()\n+                .id(entityId)\n+                .description(\"this entity has unknown parents AND references itself\")\n+                .parents(this.mixeParentRef(UNKNOWNPARENTS, entityId))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(withoutAnyParent_And_RefersItself, noEntities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private Set<String> mixeParentRef(Set<String> idCollections, String ... ids){\n+        Set<String> collect = Arrays.stream(ids).collect(Collectors.toSet());\n+        collect.addAll(UNKNOWNPARENTS);\n+        return collect;\n+    }\n+\n+    private final EntityData entityWithNoParent = EntityData.builder()\n+            .id(\"entityWithNoParent\")\n+            .description(\"first entity\").build();\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParent__In__AnEntityCollectionOfOneWithNoParent() {\n+        List<Entity> entities = Arrays.asList(entityWithNoParent);\n+        EntityData has_no_parents = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"has no parents\")\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(has_no_parents, entities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    @Test\n+    void CYCLE__4__AddedEntityReferencingItSelf__In__AnEntityCollectionOfOneWithNoParent() {\n+        List<Entity> entities = Arrays.asList(entityWithNoParent);\n+        EntityData has_no_parents = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"has no parents\")\n+                .parents(this.buildSet(testedEntity))\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(has_no_parents, entities);\n+        assertThat(underTest.hasCycle()).isTrue();\n+    }\n+\n+    private final EntityData entityReferencingUnknownParents = EntityData.builder()\n+            .id(\"entityReferencingUnknownParent\")\n+            .description(\"this entity as unknown entity has parents\")\n+            .parents(UNKNOWNPARENTS)\n+            .build();\n+    private final EntityData entityReferencingEntityWithNoParents = EntityData.builder()\n+            .id(\"entityWithEntityWithNoParentAsParent\")\n+            .description(\"This entity has a single parent entity, the one with no Parents\")\n+            .parents(this.buildSet(entityWithNoParent))\n+            .build();\n+\n+    private Set<String> buildSet(Entity ... entities) {\n+        return Arrays.stream(entities).map(Entity::getId).collect(Collectors.toSet());\n+    }\n+\n+    @Test\n+    void OK__4__AddedEntityWithNoParent__In__AnEmptyEntityCollection () {\n+        List<Entity> entities = Arrays.asList(\n+                entityWithNoParent\n+                , entityReferencingUnknownParents\n+                , entityReferencingEntityWithNoParents);\n+        EntityData has_no_parents = EntityData.builder()\n+                .id(testedEntity)\n+                .description(\"has no parents\")\n+                .build();\n+        EntityCycleDetector underTest = new EntityCycleDetector(has_no_parents, entities);\n+        assertThat(underTest.hasCycle()).isFalse();\n+    }\n+\n+    @Test\n+    void OK__4__AddedEntityReferringUnknownParent__In__AnEmptyCollection () {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY0ODkyNQ==", "bodyText": "users/entities/checkEntityGroupManagement.feature", "url": "https://github.com/opfab/operatorfabric-core/pull/559#discussion_r516648925", "createdAt": "2020-11-03T13:01:47Z", "author": {"login": "freddidierRTE"}, "path": "src/test/api/karate/launchAllUsers.sh", "diffHunk": "@@ -53,4 +53,5 @@ java -jar karate.jar                                         \\\n       users/deleteUser.feature                               \\\n       users/entities/deleteEntity.feature                    \\\n       users/groups/deleteGroup.feature                       \\\n-      users/perimeters/deletePerimeter.feature\n\\ No newline at end of file\n+      users/perimeters/deletePerimeter.feature               \\\n+      users/checkEntityGroupManagement.feature", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33c48c24d5ed9dc4ec6bd800fcefec98a8d69591"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdacb04fb8ab81d60840b325c1707f62bda2b396", "author": {"user": {"login": "rlg-pro", "name": null}}, "url": "https://github.com/opfab/operatorfabric-core/commit/fdacb04fb8ab81d60840b325c1707f62bda2b396", "committedDate": "2020-11-04T17:44:53Z", "message": "[OC-1144] applyes suggested modifications\n\nSigned-off-by: LE-GALL Ronan Ext <43667786+rlg-rte@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "237aa0ab6a03ced0c620e9f7c836ccab778852ec", "author": {"user": {"login": "freddidierRTE", "name": null}}, "url": "https://github.com/opfab/operatorfabric-core/commit/237aa0ab6a03ced0c620e9f7c836ccab778852ec", "committedDate": "2020-11-05T11:04:50Z", "message": "[OC-1144] Correct minor sonar warnings\n\nSigned-off-by: freddidierRTE <frederic-f.didier@rte-france.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1216, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}