{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzMzYyNTk2", "number": 908, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTowOTowOFrOFB8GJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDozNDo0MFrOFO6I_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTc3NTExOnYy", "diffSide": "LEFT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/AdamicAdarIndexPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTowOTowOFrOIA2JJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMjozMzozMFrOIT54XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1Nzk4OQ==", "bodyText": "@Nova-2119 can you let me know if you removed the use of Tuple because it was causing memory issues or was it a side effect that you didn't need to use them when you re-factored this?", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537757989", "createdAt": "2020-12-07T19:09:08Z", "author": {"login": "arcturus2"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/AdamicAdarIndexPlugin.java", "diffHunk": "@@ -33,10 +33,7 @@\n import au.gov.asd.tac.constellation.plugins.parameters.types.IntegerParameterType;\n import au.gov.asd.tac.constellation.plugins.parameters.types.IntegerParameterType.IntegerParameterValue;\n import au.gov.asd.tac.constellation.plugins.templates.SimpleEditPlugin;\n-import au.gov.asd.tac.constellation.utilities.datastructure.Tuple;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MjE3Mw==", "bodyText": "Just a side effect", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557742173", "createdAt": "2021-01-14T22:33:30Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/AdamicAdarIndexPlugin.java", "diffHunk": "@@ -33,10 +33,7 @@\n import au.gov.asd.tac.constellation.plugins.parameters.types.IntegerParameterType;\n import au.gov.asd.tac.constellation.plugins.parameters.types.IntegerParameterType.IntegerParameterValue;\n import au.gov.asd.tac.constellation.plugins.templates.SimpleEditPlugin;\n-import au.gov.asd.tac.constellation.utilities.datastructure.Tuple;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1Nzk4OQ=="}, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjY5OTAxOnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMjo1MTowNVrOIA-auw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMjo1MTowNVrOIA-auw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5MzU2Mw==", "bodyText": "should be able to omit the brackets that around the outside of this boolean", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537893563", "createdAt": "2020-12-07T22:51:05Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjcwNzY3OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMjo1Mzo0MlrOIA-f1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMjozNTo1MVrOIT59mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5NDg3MA==", "bodyText": "change this declaration to a plain old Map (the instantiation below is fine)", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537894870", "createdAt": "2020-12-07T22:53:42Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MzUxMg==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557743512", "createdAt": "2021-01-14T22:35:51Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5NDg3MA=="}, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjcxMjM2OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMjo1NTowMFrOIA-ihg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMjo0NToxNFrOIT6M7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5NTU1OA==", "bodyText": "final", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537895558", "createdAt": "2020-12-07T22:55:00Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0NzQzNg==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557747436", "createdAt": "2021-01-14T22:45:14Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5NTU1OA=="}, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njc0Njk4OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzowNToyNVrOIA-11w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDoyNjozNFrOIT8iiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMDUwMw==", "bodyText": "I think getMagnitude() is more complicated then it needs to be. If you set magnitude to calculateMagnitude() at the end of the constructor and then getMagnitude() simply returns magnitude.\nThis will help prevent needing to do a null check everytime", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537900503", "createdAt": "2020-12-07T23:05:25Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {\n+                mag += Math.pow(neighbourWeight, 2);\n+            }\n+            return (float) Math.sqrt(mag);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3NjI5Mw==", "bodyText": "Can you explain this to me further?", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557776293", "createdAt": "2021-01-14T23:58:34Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {\n+                mag += Math.pow(neighbourWeight, 2);\n+            }\n+            return (float) Math.sqrt(mag);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMDUwMw=="}, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NTczOQ==", "bodyText": "@Nova-2119 If I recall, you initially instantiated magnitude to null so as far as I could tell, the null check in getMagnitude() was purely to run calculateMagnitude() the first time and so didn't appear to be needed for subsequent calls. Subsequent calls on getMagnitude() would still do that null check though so my idea was really about moving that `calculateMagnitude()' call out of the function so that a null check wasn't needed.\nObviously you've made changes since so it doesn't really apply now but those were my thoughts at the time", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557785739", "createdAt": "2021-01-15T00:26:34Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {\n+                mag += Math.pow(neighbourWeight, 2);\n+            }\n+            return (float) Math.sqrt(mag);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMDUwMw=="}, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njc1NjQ3OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzowODoxMlrOIA-7MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDowMDoyOVrOIT8AVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMTg3Mw==", "bodyText": "minor but adding spacing between dot, =, and 0 would be good", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537901873", "createdAt": "2020-12-07T23:08:12Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {\n+                mag += Math.pow(neighbourWeight, 2);\n+            }\n+            return (float) Math.sqrt(mag);\n+        }\n+        \n     }\n-\n-    private float magnitude(final int[] vector) {\n-        float magnitude = 0;\n-        for (int index = 0; index < vector.length; index++) {\n-            magnitude += Math.pow(vector[index], 2);\n+    \n+    BitSet getCommonNeighbours(final BitSet leftVertexNeighbours, final BitSet rightVertexNeighbours) {\n+        final BitSet intersection = (BitSet) leftVertexNeighbours.clone();\n+        intersection.and(rightVertexNeighbours);\n+        return intersection;\n+    }\n+    \n+    float getNeighbourDotProduct(final VertexWithNeighbours vertex1, final VertexWithNeighbours vertex2, BitSet intersection) {\n+        float dot=0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3Njk4MA==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557776980", "createdAt": "2021-01-15T00:00:29Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {\n+                mag += Math.pow(neighbourWeight, 2);\n+            }\n+            return (float) Math.sqrt(mag);\n+        }\n+        \n     }\n-\n-    private float magnitude(final int[] vector) {\n-        float magnitude = 0;\n-        for (int index = 0; index < vector.length; index++) {\n-            magnitude += Math.pow(vector[index], 2);\n+    \n+    BitSet getCommonNeighbours(final BitSet leftVertexNeighbours, final BitSet rightVertexNeighbours) {\n+        final BitSet intersection = (BitSet) leftVertexNeighbours.clone();\n+        intersection.and(rightVertexNeighbours);\n+        return intersection;\n+    }\n+    \n+    float getNeighbourDotProduct(final VertexWithNeighbours vertex1, final VertexWithNeighbours vertex2, BitSet intersection) {\n+        float dot=0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMTg3Mw=="}, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njc1NzU5OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzowODozNFrOIA-72g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDowMDoyNVrOIT8AOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMjA0Mg==", "bodyText": "intersection can be final", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537902042", "createdAt": "2020-12-07T23:08:34Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {\n+                mag += Math.pow(neighbourWeight, 2);\n+            }\n+            return (float) Math.sqrt(mag);\n+        }\n+        \n     }\n-\n-    private float magnitude(final int[] vector) {\n-        float magnitude = 0;\n-        for (int index = 0; index < vector.length; index++) {\n-            magnitude += Math.pow(vector[index], 2);\n+    \n+    BitSet getCommonNeighbours(final BitSet leftVertexNeighbours, final BitSet rightVertexNeighbours) {\n+        final BitSet intersection = (BitSet) leftVertexNeighbours.clone();\n+        intersection.and(rightVertexNeighbours);\n+        return intersection;\n+    }\n+    \n+    float getNeighbourDotProduct(final VertexWithNeighbours vertex1, final VertexWithNeighbours vertex2, BitSet intersection) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3Njk1Mg==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557776952", "createdAt": "2021-01-15T00:00:25Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {\n+                mag += Math.pow(neighbourWeight, 2);\n+            }\n+            return (float) Math.sqrt(mag);\n+        }\n+        \n     }\n-\n-    private float magnitude(final int[] vector) {\n-        float magnitude = 0;\n-        for (int index = 0; index < vector.length; index++) {\n-            magnitude += Math.pow(vector[index], 2);\n+    \n+    BitSet getCommonNeighbours(final BitSet leftVertexNeighbours, final BitSet rightVertexNeighbours) {\n+        final BitSet intersection = (BitSet) leftVertexNeighbours.clone();\n+        intersection.and(rightVertexNeighbours);\n+        return intersection;\n+    }\n+    \n+    float getNeighbourDotProduct(final VertexWithNeighbours vertex1, final VertexWithNeighbours vertex2, BitSet intersection) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMjA0Mg=="}, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njc1ODU0OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzowODo1M1rOIA-8aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMzo1OTo0MlrOIT7_LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMjE4NA==", "bodyText": "final", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537902184", "createdAt": "2020-12-07T23:08:53Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3NjY4NQ==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557776685", "createdAt": "2021-01-14T23:59:42Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMjE4NA=="}, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Njg2MjY4OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzozNTo1MlrOIA_2KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMjo1NDo1OVrOIT6dNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNjk2OA==", "bodyText": "for completion, should a recalculation of magnitude be done every time the weights map is updated?", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537916968", "createdAt": "2020-12-07T23:35:52Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc1MTYwNA==", "bodyText": "Hmm I see what you are getting at, but I don't think this is the correct solution, otherwise we will be calculating magnitude a heap of times.\nInstead I think I will make it set an recalculateMagnitude boolean to true and modifiy getMagnitude to recalculate it if the bit is true. That way we can ensure it is up to date when retrieved without calculating it too many times.", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557751604", "createdAt": "2021-01-14T22:54:59Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNjk2OA=="}, "originalCommit": {"oid": "87dc582b478d88fc59610291570e6b06e52337e4"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NDQ3NzE2OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNDozNDo1OVrOIRX6dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQyMjo1NzowM1rOISY0SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4ODUwMg==", "bodyText": "@Nova-2119 @cygnus-x-1 Previously vxId4 was last but now vxId3 is. Does that mean the page rank was wrong before or wrong now?", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r555088502", "createdAt": "2021-01-11T14:34:59Z", "author": {"login": "arcturus2"}, "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "diffHunk": "@@ -102,15 +102,15 @@ public void testNormalisedPagerank() throws Exception {\n         final PluginParameters parameters = instance.createParameters();\n         parameters.setBooleanValue(PagerankCentralityPlugin.TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID, true);\n         parameters.setFloatValue(PagerankCentralityPlugin.DAMPING_FACTOR_PARAMETER_ID, 0.85f);\n-        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 100);\n+        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 2);\n         parameters.setFloatValue(PagerankCentralityPlugin.EPSILON_PARAMETER_ID, 1E-8f);\n         parameters.setBooleanValue(PagerankCentralityPlugin.NORMALISE_AVAILABLE_PARAMETER_ID, true);\n         PluginExecution.withPlugin(instance).withParameters(parameters).executeNow(graph);\n \n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.22181106f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.4309117f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.42492065f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.8254921f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 1f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.18089105f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.39393282f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.5371851f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 1f);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ee29e58d790588b0bdac24d18c4995bec81193c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE1MTg4MQ==", "bodyText": "It was wrong before, all the values were slightly out because when there was a sink it included itself in the count of how many nodes it was distributing its pagerank too when it shouldn't have (it used the total number of nodes rather than number of nodes-1).\nThis has changed all the values a little.", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r556151881", "createdAt": "2021-01-12T22:57:03Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "diffHunk": "@@ -102,15 +102,15 @@ public void testNormalisedPagerank() throws Exception {\n         final PluginParameters parameters = instance.createParameters();\n         parameters.setBooleanValue(PagerankCentralityPlugin.TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID, true);\n         parameters.setFloatValue(PagerankCentralityPlugin.DAMPING_FACTOR_PARAMETER_ID, 0.85f);\n-        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 100);\n+        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 2);\n         parameters.setFloatValue(PagerankCentralityPlugin.EPSILON_PARAMETER_ID, 1E-8f);\n         parameters.setBooleanValue(PagerankCentralityPlugin.NORMALISE_AVAILABLE_PARAMETER_ID, true);\n         PluginExecution.withPlugin(instance).withParameters(parameters).executeNow(graph);\n \n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.22181106f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.4309117f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.42492065f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.8254921f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 1f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.18089105f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.39393282f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.5371851f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 1f);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4ODUwMg=="}, "originalCommit": {"oid": "2ee29e58d790588b0bdac24d18c4995bec81193c"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NDQ4MTIyOnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNDozNTo1MlrOIRX88w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDowMzo1MVrOIT8EOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4OTEzOQ==", "bodyText": "@Nova-2119 @cygnus-x-1 Previously vxId4 was last but now its vxId3. Does that mean the page rank was wrong before or wrong now?", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r555089139", "createdAt": "2021-01-11T14:35:52Z", "author": {"login": "arcturus2"}, "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "diffHunk": "@@ -84,16 +84,16 @@ public void testPagerank() throws Exception {\n         final PluginParameters parameters = instance.createParameters();\n         parameters.setBooleanValue(PagerankCentralityPlugin.TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID, true);\n         parameters.setFloatValue(PagerankCentralityPlugin.DAMPING_FACTOR_PARAMETER_ID, 0.85f);\n-        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 100);\n+        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 2);\n         parameters.setFloatValue(PagerankCentralityPlugin.EPSILON_PARAMETER_ID, 1E-8f);\n         parameters.setBooleanValue(PagerankCentralityPlugin.NORMALISE_AVAILABLE_PARAMETER_ID, false);\n         PluginExecution.withPlugin(instance).withParameters(parameters).executeNow(graph);\n \n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.08510862f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.15745096f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.15202528f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.28124678f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 0.32416838f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.0725f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.134125f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.1755625f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.3094375f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 0.308375f);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ee29e58d790588b0bdac24d18c4995bec81193c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE1MTMxMw==", "bodyText": "It was wrong before, all the values were slightly out because when there was a sink it included itself in the count of how many nodes it was distributing its pagerank too when it shouldn't have (it used the total number of nodes rather than number of nodes-1).\nThis has changed all the values a little.", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r556151313", "createdAt": "2021-01-12T22:56:05Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "diffHunk": "@@ -84,16 +84,16 @@ public void testPagerank() throws Exception {\n         final PluginParameters parameters = instance.createParameters();\n         parameters.setBooleanValue(PagerankCentralityPlugin.TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID, true);\n         parameters.setFloatValue(PagerankCentralityPlugin.DAMPING_FACTOR_PARAMETER_ID, 0.85f);\n-        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 100);\n+        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 2);\n         parameters.setFloatValue(PagerankCentralityPlugin.EPSILON_PARAMETER_ID, 1E-8f);\n         parameters.setBooleanValue(PagerankCentralityPlugin.NORMALISE_AVAILABLE_PARAMETER_ID, false);\n         PluginExecution.withPlugin(instance).withParameters(parameters).executeNow(graph);\n \n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.08510862f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.15745096f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.15202528f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.28124678f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 0.32416838f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.0725f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.134125f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.1755625f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.3094375f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 0.308375f);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4OTEzOQ=="}, "originalCommit": {"oid": "2ee29e58d790588b0bdac24d18c4995bec81193c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3Nzk3Ng==", "bodyText": "ok thank you @Nova-2119", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557777976", "createdAt": "2021-01-15T00:03:51Z", "author": {"login": "arcturus2"}, "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "diffHunk": "@@ -84,16 +84,16 @@ public void testPagerank() throws Exception {\n         final PluginParameters parameters = instance.createParameters();\n         parameters.setBooleanValue(PagerankCentralityPlugin.TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID, true);\n         parameters.setFloatValue(PagerankCentralityPlugin.DAMPING_FACTOR_PARAMETER_ID, 0.85f);\n-        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 100);\n+        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 2);\n         parameters.setFloatValue(PagerankCentralityPlugin.EPSILON_PARAMETER_ID, 1E-8f);\n         parameters.setBooleanValue(PagerankCentralityPlugin.NORMALISE_AVAILABLE_PARAMETER_ID, false);\n         PluginExecution.withPlugin(instance).withParameters(parameters).executeNow(graph);\n \n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.08510862f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.15745096f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.15202528f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.28124678f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 0.32416838f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.0725f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.134125f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.1755625f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.3094375f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 0.308375f);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4OTEzOQ=="}, "originalCommit": {"oid": "2ee29e58d790588b0bdac24d18c4995bec81193c"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc1ODk5OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDoyOTowMlrOIT8odw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMjo0NjoxN1rOIcTIAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NzI1NQ==", "bodyText": "\ud83d\ude04 (EDIT: I'd either rename this, make it final and use it in the subsequent for loop, or remove the variable entirely)", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557787255", "createdAt": "2021-01-15T00:29:02Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +110,132 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            int bleh = graph.getVertexNeighbourCount(vertexId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cf373c1505b3d3fb20c830a983d4fd917af958a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUzODgxMw==", "bodyText": "haha yeah i've gone ahead and deleted it.", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r566538813", "createdAt": "2021-01-29T02:28:08Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +110,132 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            int bleh = graph.getVertexNeighbourCount(vertexId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NzI1NQ=="}, "originalCommit": {"oid": "8cf373c1505b3d3fb20c830a983d4fd917af958a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjU0NDM4NQ==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r566544385", "createdAt": "2021-01-29T02:46:17Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +110,132 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            int bleh = graph.getVertexNeighbourCount(vertexId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NzI1NQ=="}, "originalCommit": {"oid": "8cf373c1505b3d3fb20c830a983d4fd917af958a"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc2NjUxOnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDozMzowMFrOIT8s0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMjo0NjoyM1rOIcTIMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODM3MA==", "bodyText": "can use the primitive type here", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557788370", "createdAt": "2021-01-15T00:33:00Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +110,132 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            int bleh = graph.getVertexNeighbourCount(vertexId);\n+            if (graph.getVertexNeighbourCount(vertexId) >= minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == vertexId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == vertexId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final Map<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+        private Boolean recalculateMagnitude = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cf373c1505b3d3fb20c830a983d4fd917af958a"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjU0NDQzMw==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r566544433", "createdAt": "2021-01-29T02:46:23Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +110,132 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            int bleh = graph.getVertexNeighbourCount(vertexId);\n+            if (graph.getVertexNeighbourCount(vertexId) >= minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == vertexId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == vertexId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final Map<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+        private Boolean recalculateMagnitude = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODM3MA=="}, "originalCommit": {"oid": "8cf373c1505b3d3fb20c830a983d4fd917af958a"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc2OTU3OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDozNDo0MFrOIT8urQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwMjo0NjoyOFrOIcTISg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODg0NQ==", "bodyText": "can omit == true from if condition", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557788845", "createdAt": "2021-01-15T00:34:40Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +110,132 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            int bleh = graph.getVertexNeighbourCount(vertexId);\n+            if (graph.getVertexNeighbourCount(vertexId) >= minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == vertexId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == vertexId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final Map<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+        private Boolean recalculateMagnitude = true;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            final int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+            recalculateMagnitude = true;\n+        }\n+        \n+        private float getMagnitude() {\n+            if (recalculateMagnitude == true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cf373c1505b3d3fb20c830a983d4fd917af958a"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjU0NDQ1OA==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r566544458", "createdAt": "2021-01-29T02:46:28Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +110,132 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            int bleh = graph.getVertexNeighbourCount(vertexId);\n+            if (graph.getVertexNeighbourCount(vertexId) >= minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == vertexId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == vertexId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final Map<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+        private Boolean recalculateMagnitude = true;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            final int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+            recalculateMagnitude = true;\n+        }\n+        \n+        private float getMagnitude() {\n+            if (recalculateMagnitude == true) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODg0NQ=="}, "originalCommit": {"oid": "8cf373c1505b3d3fb20c830a983d4fd917af958a"}, "originalPosition": 177}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2146, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}