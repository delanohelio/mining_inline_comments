{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MzMyMTQ2", "number": 894, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQyMTozNDowMFrOE8BXyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMzoxNjozMVrOFQNyUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMzcyNDkxOnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQyMTozNDowMFrOH37dbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxNToxMlrOH5VcNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwNzkxNw==", "bodyText": "Could this be made private or was the intention that this could be called elsewhere?", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528407917", "createdAt": "2020-11-22T21:34:00Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MjE2Ng==", "bodyText": "Ahh yes it definitely can :)", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529882166", "createdAt": "2020-11-24T21:15:12Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwNzkxNw=="}, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMzcyNTUzOnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQyMTozNDozNlrOH37dtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjowNDo0NFrOH5XlAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwNzk5MA==", "bodyText": "Could this potentially be made public? (should be ok if it sits in a private class)", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528407990", "createdAt": "2020-11-22T21:34:36Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NTY3MQ==", "bodyText": "I can (and will) but what is the advantage over it being package private, given its in a private class? Is it just a legibility thing?", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529885671", "createdAt": "2020-11-24T21:21:33Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwNzk5MA=="}, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkxNzE4NQ==", "bodyText": "I think it's definitely a legibility thing for me. Even though it's perfectly valid, it just looks odd not having a (visible) access modifier. Given it is in a private class, so long as the function isn't private it probably doesn't make much of difference what access modifier you add to it (package private, protected, public) in this instance. Really I'm just suggesting what I've seen elsewhere", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529917185", "createdAt": "2020-11-24T22:04:44Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwNzk5MA=="}, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMzcyNjM3OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQyMTozNTowM1rOH37eEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToyMjoxMlrOH5VrGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODA4Mg==", "bodyText": "vertexPosition can be final", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528408082", "createdAt": "2020-11-22T21:35:03Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NTk3OQ==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529885979", "createdAt": "2020-11-24T21:22:12Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODA4Mg=="}, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMzcyODA3OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQyMTozNjozNVrOH37e4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToyMjo0OFrOH5VsQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODI4OQ==", "bodyText": "make pgVertex final", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528408289", "createdAt": "2020-11-22T21:36:35Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NjI3NQ==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529886275", "createdAt": "2020-11-24T21:22:48Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODI4OQ=="}, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMzcyOTk5OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQyMTozODozOVrOH37fyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToyMzoxN1rOH5VtMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODUyMQ==", "bodyText": "final", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528408521", "createdAt": "2020-11-22T21:38:39Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){\n+            // identify incoming connections and store connected vertices and their outgoing connection count\n+                final int linkCount = graph.getVertexLinkCount(pgVertex.vertexId);\n+                for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n+    //              For each link\n+                    final int linkId = graph.getVertexLink(pgVertex.vertexId, linkPosition);\n+                    final int linkLowId = graph.getLinkLowVertex(linkId);\n+                    final int linkHighId = graph.getLinkHighVertex(linkId);\n+                    if (linkLowId != linkHighId) {\n+                        // If it isnt a link to itself\n+                        final Integer neighbourId = pgVertex.vertexId == linkLowId ? linkHighId : linkLowId;\n+                        final int edgeCount = graph.getLinkEdgeCount(linkId);\n+                        for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n+                            // Then for every edge in the link\n+                            final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n+                            final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                            if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeSourceVertex(edgeId) == pgVertex.vertexId) {\n+                                // If egde is facing outwards, add 1 to outCount.\n+                                pgVertex.outCount +=1;\n+                            } else if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeDestinationVertex(edgeId) == pgVertex.vertexId) {\n+                                // If edge is facing towards vertex add the source as a neighbour.\n+                                pgVertex.neighbours.add(pagerankVertices[graph.getVertexPosition(neighbourId)]);\n+                            }\n                         }\n                     }\n                 }\n+                // If it is a sink (that is it has no outgoing transaction) then treat it as if it connect to every other vertex. Otherwise the total pagerank will gradually reduce from one to zero.\n+                if (pgVertex.outCount == 0) {\n+                    pgVertex.outCount = vertexCount - 1;\n+                    sinks.add(pgVertex);\n+                    pgVertex.isSink = true;\n+                }\n+                pgVertex.updatePagerankContribution();\n             }\n         }\n-\n-        // handle dangling vertices by linking them to all pages\n-        for (final int neighbourId : verticesWithZeroOutLinks) {\n-            final int updatedCount = vertexInLinks.size();\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, updatedCount));\n-            }\n+        \n+        private static void updateSinkPagerankContribution() {\n+            sinkPagerankContribution = sinks.parallelStream().mapToDouble(pgVertex -> pgVertex.pagerankContribution).sum();\n         }\n-\n-        // initialise pagerank values\n-        final double[] tempPageranks = new double[graph.getVertexCapacity()];\n-        final double[] pageranks = new double[graph.getVertexCapacity()];\n-        Arrays.fill(pageranks, (double) 1 / vertexInLinks.size());\n-\n-        // calculate pagerank for each vertex\n-        for (int iteration = 0; iteration < iterations; iteration++) {\n-            Arrays.fill(tempPageranks, 0);\n-\n+        \n+        private void updatePagerankContribution() {\n+            pagerankContribution = pagerank/outCount;\n+        }\n+        \n+        private static void updateAllPageranks() {\n+            delta = 0;\n             double maxPagerank = 0;\n-            double delta = 0;\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                double neighbourContribution = 0.0;\n-                final Set<Tuple<Integer, Integer>> neighbours = vertexInLinks.get(vertexId);\n-                for (final Tuple<Integer, Integer> neighbour : neighbours) {\n-                    final int neighbourId = neighbour.getFirst();\n-                    final int neighbourOutCount = neighbour.getSecond();\n-                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n-                    neighbourContribution += (pageranks[neighbourPosition] / neighbourOutCount);\n+            for( PagerankVertex pgVertex: pagerankVertices) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NjUxMg==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529886512", "createdAt": "2020-11-24T21:23:17Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){\n+            // identify incoming connections and store connected vertices and their outgoing connection count\n+                final int linkCount = graph.getVertexLinkCount(pgVertex.vertexId);\n+                for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n+    //              For each link\n+                    final int linkId = graph.getVertexLink(pgVertex.vertexId, linkPosition);\n+                    final int linkLowId = graph.getLinkLowVertex(linkId);\n+                    final int linkHighId = graph.getLinkHighVertex(linkId);\n+                    if (linkLowId != linkHighId) {\n+                        // If it isnt a link to itself\n+                        final Integer neighbourId = pgVertex.vertexId == linkLowId ? linkHighId : linkLowId;\n+                        final int edgeCount = graph.getLinkEdgeCount(linkId);\n+                        for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n+                            // Then for every edge in the link\n+                            final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n+                            final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                            if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeSourceVertex(edgeId) == pgVertex.vertexId) {\n+                                // If egde is facing outwards, add 1 to outCount.\n+                                pgVertex.outCount +=1;\n+                            } else if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeDestinationVertex(edgeId) == pgVertex.vertexId) {\n+                                // If edge is facing towards vertex add the source as a neighbour.\n+                                pgVertex.neighbours.add(pagerankVertices[graph.getVertexPosition(neighbourId)]);\n+                            }\n                         }\n                     }\n                 }\n+                // If it is a sink (that is it has no outgoing transaction) then treat it as if it connect to every other vertex. Otherwise the total pagerank will gradually reduce from one to zero.\n+                if (pgVertex.outCount == 0) {\n+                    pgVertex.outCount = vertexCount - 1;\n+                    sinks.add(pgVertex);\n+                    pgVertex.isSink = true;\n+                }\n+                pgVertex.updatePagerankContribution();\n             }\n         }\n-\n-        // handle dangling vertices by linking them to all pages\n-        for (final int neighbourId : verticesWithZeroOutLinks) {\n-            final int updatedCount = vertexInLinks.size();\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, updatedCount));\n-            }\n+        \n+        private static void updateSinkPagerankContribution() {\n+            sinkPagerankContribution = sinks.parallelStream().mapToDouble(pgVertex -> pgVertex.pagerankContribution).sum();\n         }\n-\n-        // initialise pagerank values\n-        final double[] tempPageranks = new double[graph.getVertexCapacity()];\n-        final double[] pageranks = new double[graph.getVertexCapacity()];\n-        Arrays.fill(pageranks, (double) 1 / vertexInLinks.size());\n-\n-        // calculate pagerank for each vertex\n-        for (int iteration = 0; iteration < iterations; iteration++) {\n-            Arrays.fill(tempPageranks, 0);\n-\n+        \n+        private void updatePagerankContribution() {\n+            pagerankContribution = pagerank/outCount;\n+        }\n+        \n+        private static void updateAllPageranks() {\n+            delta = 0;\n             double maxPagerank = 0;\n-            double delta = 0;\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                double neighbourContribution = 0.0;\n-                final Set<Tuple<Integer, Integer>> neighbours = vertexInLinks.get(vertexId);\n-                for (final Tuple<Integer, Integer> neighbour : neighbours) {\n-                    final int neighbourId = neighbour.getFirst();\n-                    final int neighbourOutCount = neighbour.getSecond();\n-                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n-                    neighbourContribution += (pageranks[neighbourPosition] / neighbourOutCount);\n+            for( PagerankVertex pgVertex: pagerankVertices) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODUyMQ=="}, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMzczMDIzOnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQyMTozOTowMVrOH37f6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToyMzoyNlrOH5VtYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODU1Mw==", "bodyText": "final", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528408553", "createdAt": "2020-11-22T21:39:01Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){\n+            // identify incoming connections and store connected vertices and their outgoing connection count\n+                final int linkCount = graph.getVertexLinkCount(pgVertex.vertexId);\n+                for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n+    //              For each link\n+                    final int linkId = graph.getVertexLink(pgVertex.vertexId, linkPosition);\n+                    final int linkLowId = graph.getLinkLowVertex(linkId);\n+                    final int linkHighId = graph.getLinkHighVertex(linkId);\n+                    if (linkLowId != linkHighId) {\n+                        // If it isnt a link to itself\n+                        final Integer neighbourId = pgVertex.vertexId == linkLowId ? linkHighId : linkLowId;\n+                        final int edgeCount = graph.getLinkEdgeCount(linkId);\n+                        for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n+                            // Then for every edge in the link\n+                            final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n+                            final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                            if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeSourceVertex(edgeId) == pgVertex.vertexId) {\n+                                // If egde is facing outwards, add 1 to outCount.\n+                                pgVertex.outCount +=1;\n+                            } else if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeDestinationVertex(edgeId) == pgVertex.vertexId) {\n+                                // If edge is facing towards vertex add the source as a neighbour.\n+                                pgVertex.neighbours.add(pagerankVertices[graph.getVertexPosition(neighbourId)]);\n+                            }\n                         }\n                     }\n                 }\n+                // If it is a sink (that is it has no outgoing transaction) then treat it as if it connect to every other vertex. Otherwise the total pagerank will gradually reduce from one to zero.\n+                if (pgVertex.outCount == 0) {\n+                    pgVertex.outCount = vertexCount - 1;\n+                    sinks.add(pgVertex);\n+                    pgVertex.isSink = true;\n+                }\n+                pgVertex.updatePagerankContribution();\n             }\n         }\n-\n-        // handle dangling vertices by linking them to all pages\n-        for (final int neighbourId : verticesWithZeroOutLinks) {\n-            final int updatedCount = vertexInLinks.size();\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, updatedCount));\n-            }\n+        \n+        private static void updateSinkPagerankContribution() {\n+            sinkPagerankContribution = sinks.parallelStream().mapToDouble(pgVertex -> pgVertex.pagerankContribution).sum();\n         }\n-\n-        // initialise pagerank values\n-        final double[] tempPageranks = new double[graph.getVertexCapacity()];\n-        final double[] pageranks = new double[graph.getVertexCapacity()];\n-        Arrays.fill(pageranks, (double) 1 / vertexInLinks.size());\n-\n-        // calculate pagerank for each vertex\n-        for (int iteration = 0; iteration < iterations; iteration++) {\n-            Arrays.fill(tempPageranks, 0);\n-\n+        \n+        private void updatePagerankContribution() {\n+            pagerankContribution = pagerank/outCount;\n+        }\n+        \n+        private static void updateAllPageranks() {\n+            delta = 0;\n             double maxPagerank = 0;\n-            double delta = 0;\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                double neighbourContribution = 0.0;\n-                final Set<Tuple<Integer, Integer>> neighbours = vertexInLinks.get(vertexId);\n-                for (final Tuple<Integer, Integer> neighbour : neighbours) {\n-                    final int neighbourId = neighbour.getFirst();\n-                    final int neighbourOutCount = neighbour.getSecond();\n-                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n-                    neighbourContribution += (pageranks[neighbourPosition] / neighbourOutCount);\n+            for( PagerankVertex pgVertex: pagerankVertices) {\n+                pgVertex.stageNewPagerank();\n+                delta += Math.abs(pgVertex.pagerank - pgVertex.stagedPagerank);\n+                if (pgVertex.stagedPagerank > maxPagerank) {\n+                    maxPagerank = pgVertex.stagedPagerank;\n                 }\n-\n-                final int vertexPosition = graph.getVertexPosition(vertexId);\n-                tempPageranks[vertexPosition] = ((1 - dampingFactor) / vertexInLinks.size()) + (dampingFactor * neighbourContribution);\n-                maxPagerank = Math.max(tempPageranks[vertexPosition], maxPagerank);\n-                delta += Math.abs(pageranks[vertexPosition] - tempPageranks[vertexPosition]);\n             }\n \n-            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+            for (PagerankVertex pgVertex: pagerankVertices) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NjU2Mg==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529886562", "createdAt": "2020-11-24T21:23:26Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){\n+            // identify incoming connections and store connected vertices and their outgoing connection count\n+                final int linkCount = graph.getVertexLinkCount(pgVertex.vertexId);\n+                for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n+    //              For each link\n+                    final int linkId = graph.getVertexLink(pgVertex.vertexId, linkPosition);\n+                    final int linkLowId = graph.getLinkLowVertex(linkId);\n+                    final int linkHighId = graph.getLinkHighVertex(linkId);\n+                    if (linkLowId != linkHighId) {\n+                        // If it isnt a link to itself\n+                        final Integer neighbourId = pgVertex.vertexId == linkLowId ? linkHighId : linkLowId;\n+                        final int edgeCount = graph.getLinkEdgeCount(linkId);\n+                        for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n+                            // Then for every edge in the link\n+                            final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n+                            final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                            if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeSourceVertex(edgeId) == pgVertex.vertexId) {\n+                                // If egde is facing outwards, add 1 to outCount.\n+                                pgVertex.outCount +=1;\n+                            } else if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeDestinationVertex(edgeId) == pgVertex.vertexId) {\n+                                // If edge is facing towards vertex add the source as a neighbour.\n+                                pgVertex.neighbours.add(pagerankVertices[graph.getVertexPosition(neighbourId)]);\n+                            }\n                         }\n                     }\n                 }\n+                // If it is a sink (that is it has no outgoing transaction) then treat it as if it connect to every other vertex. Otherwise the total pagerank will gradually reduce from one to zero.\n+                if (pgVertex.outCount == 0) {\n+                    pgVertex.outCount = vertexCount - 1;\n+                    sinks.add(pgVertex);\n+                    pgVertex.isSink = true;\n+                }\n+                pgVertex.updatePagerankContribution();\n             }\n         }\n-\n-        // handle dangling vertices by linking them to all pages\n-        for (final int neighbourId : verticesWithZeroOutLinks) {\n-            final int updatedCount = vertexInLinks.size();\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, updatedCount));\n-            }\n+        \n+        private static void updateSinkPagerankContribution() {\n+            sinkPagerankContribution = sinks.parallelStream().mapToDouble(pgVertex -> pgVertex.pagerankContribution).sum();\n         }\n-\n-        // initialise pagerank values\n-        final double[] tempPageranks = new double[graph.getVertexCapacity()];\n-        final double[] pageranks = new double[graph.getVertexCapacity()];\n-        Arrays.fill(pageranks, (double) 1 / vertexInLinks.size());\n-\n-        // calculate pagerank for each vertex\n-        for (int iteration = 0; iteration < iterations; iteration++) {\n-            Arrays.fill(tempPageranks, 0);\n-\n+        \n+        private void updatePagerankContribution() {\n+            pagerankContribution = pagerank/outCount;\n+        }\n+        \n+        private static void updateAllPageranks() {\n+            delta = 0;\n             double maxPagerank = 0;\n-            double delta = 0;\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                double neighbourContribution = 0.0;\n-                final Set<Tuple<Integer, Integer>> neighbours = vertexInLinks.get(vertexId);\n-                for (final Tuple<Integer, Integer> neighbour : neighbours) {\n-                    final int neighbourId = neighbour.getFirst();\n-                    final int neighbourOutCount = neighbour.getSecond();\n-                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n-                    neighbourContribution += (pageranks[neighbourPosition] / neighbourOutCount);\n+            for( PagerankVertex pgVertex: pagerankVertices) {\n+                pgVertex.stageNewPagerank();\n+                delta += Math.abs(pgVertex.pagerank - pgVertex.stagedPagerank);\n+                if (pgVertex.stagedPagerank > maxPagerank) {\n+                    maxPagerank = pgVertex.stagedPagerank;\n                 }\n-\n-                final int vertexPosition = graph.getVertexPosition(vertexId);\n-                tempPageranks[vertexPosition] = ((1 - dampingFactor) / vertexInLinks.size()) + (dampingFactor * neighbourContribution);\n-                maxPagerank = Math.max(tempPageranks[vertexPosition], maxPagerank);\n-                delta += Math.abs(pageranks[vertexPosition] - tempPageranks[vertexPosition]);\n             }\n \n-            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+            for (PagerankVertex pgVertex: pagerankVertices) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODU1Mw=="}, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMzczMDcxOnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQyMTozOToxOFrOH37gHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToyMzo0MFrOH5Vt4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODYwNg==", "bodyText": "final", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528408606", "createdAt": "2020-11-22T21:39:18Z", "author": {"login": "antares1470"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){\n+            // identify incoming connections and store connected vertices and their outgoing connection count\n+                final int linkCount = graph.getVertexLinkCount(pgVertex.vertexId);\n+                for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n+    //              For each link\n+                    final int linkId = graph.getVertexLink(pgVertex.vertexId, linkPosition);\n+                    final int linkLowId = graph.getLinkLowVertex(linkId);\n+                    final int linkHighId = graph.getLinkHighVertex(linkId);\n+                    if (linkLowId != linkHighId) {\n+                        // If it isnt a link to itself\n+                        final Integer neighbourId = pgVertex.vertexId == linkLowId ? linkHighId : linkLowId;\n+                        final int edgeCount = graph.getLinkEdgeCount(linkId);\n+                        for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n+                            // Then for every edge in the link\n+                            final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n+                            final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                            if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeSourceVertex(edgeId) == pgVertex.vertexId) {\n+                                // If egde is facing outwards, add 1 to outCount.\n+                                pgVertex.outCount +=1;\n+                            } else if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeDestinationVertex(edgeId) == pgVertex.vertexId) {\n+                                // If edge is facing towards vertex add the source as a neighbour.\n+                                pgVertex.neighbours.add(pagerankVertices[graph.getVertexPosition(neighbourId)]);\n+                            }\n                         }\n                     }\n                 }\n+                // If it is a sink (that is it has no outgoing transaction) then treat it as if it connect to every other vertex. Otherwise the total pagerank will gradually reduce from one to zero.\n+                if (pgVertex.outCount == 0) {\n+                    pgVertex.outCount = vertexCount - 1;\n+                    sinks.add(pgVertex);\n+                    pgVertex.isSink = true;\n+                }\n+                pgVertex.updatePagerankContribution();\n             }\n         }\n-\n-        // handle dangling vertices by linking them to all pages\n-        for (final int neighbourId : verticesWithZeroOutLinks) {\n-            final int updatedCount = vertexInLinks.size();\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, updatedCount));\n-            }\n+        \n+        private static void updateSinkPagerankContribution() {\n+            sinkPagerankContribution = sinks.parallelStream().mapToDouble(pgVertex -> pgVertex.pagerankContribution).sum();\n         }\n-\n-        // initialise pagerank values\n-        final double[] tempPageranks = new double[graph.getVertexCapacity()];\n-        final double[] pageranks = new double[graph.getVertexCapacity()];\n-        Arrays.fill(pageranks, (double) 1 / vertexInLinks.size());\n-\n-        // calculate pagerank for each vertex\n-        for (int iteration = 0; iteration < iterations; iteration++) {\n-            Arrays.fill(tempPageranks, 0);\n-\n+        \n+        private void updatePagerankContribution() {\n+            pagerankContribution = pagerank/outCount;\n+        }\n+        \n+        private static void updateAllPageranks() {\n+            delta = 0;\n             double maxPagerank = 0;\n-            double delta = 0;\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                double neighbourContribution = 0.0;\n-                final Set<Tuple<Integer, Integer>> neighbours = vertexInLinks.get(vertexId);\n-                for (final Tuple<Integer, Integer> neighbour : neighbours) {\n-                    final int neighbourId = neighbour.getFirst();\n-                    final int neighbourOutCount = neighbour.getSecond();\n-                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n-                    neighbourContribution += (pageranks[neighbourPosition] / neighbourOutCount);\n+            for( PagerankVertex pgVertex: pagerankVertices) {\n+                pgVertex.stageNewPagerank();\n+                delta += Math.abs(pgVertex.pagerank - pgVertex.stagedPagerank);\n+                if (pgVertex.stagedPagerank > maxPagerank) {\n+                    maxPagerank = pgVertex.stagedPagerank;\n                 }\n-\n-                final int vertexPosition = graph.getVertexPosition(vertexId);\n-                tempPageranks[vertexPosition] = ((1 - dampingFactor) / vertexInLinks.size()) + (dampingFactor * neighbourContribution);\n-                maxPagerank = Math.max(tempPageranks[vertexPosition], maxPagerank);\n-                delta += Math.abs(pageranks[vertexPosition] - tempPageranks[vertexPosition]);\n             }\n \n-            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+            for (PagerankVertex pgVertex: pagerankVertices) {\n                 if (normaliseByAvailable && maxPagerank > 0) {\n-                    pageranks[vertexPosition] = tempPageranks[vertexPosition] / maxPagerank;\n+                    pgVertex.pagerank = pgVertex.stagedPagerank / maxPagerank;\n                 } else {\n-                    pageranks[vertexPosition] = tempPageranks[vertexPosition];\n+                    pgVertex.pagerank = pgVertex.stagedPagerank;\n                 }\n+                pgVertex.updatePagerankContribution();\n             }\n-\n-            if (delta < epsilon) {\n-                break;\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void commitPageranksToGraph(){\n+            for (PagerankVertex pgVertex : pagerankVertices) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NjY5MQ==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529886691", "createdAt": "2020-11-24T21:23:40Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){\n+            // identify incoming connections and store connected vertices and their outgoing connection count\n+                final int linkCount = graph.getVertexLinkCount(pgVertex.vertexId);\n+                for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n+    //              For each link\n+                    final int linkId = graph.getVertexLink(pgVertex.vertexId, linkPosition);\n+                    final int linkLowId = graph.getLinkLowVertex(linkId);\n+                    final int linkHighId = graph.getLinkHighVertex(linkId);\n+                    if (linkLowId != linkHighId) {\n+                        // If it isnt a link to itself\n+                        final Integer neighbourId = pgVertex.vertexId == linkLowId ? linkHighId : linkLowId;\n+                        final int edgeCount = graph.getLinkEdgeCount(linkId);\n+                        for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n+                            // Then for every edge in the link\n+                            final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n+                            final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                            if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeSourceVertex(edgeId) == pgVertex.vertexId) {\n+                                // If egde is facing outwards, add 1 to outCount.\n+                                pgVertex.outCount +=1;\n+                            } else if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeDestinationVertex(edgeId) == pgVertex.vertexId) {\n+                                // If edge is facing towards vertex add the source as a neighbour.\n+                                pgVertex.neighbours.add(pagerankVertices[graph.getVertexPosition(neighbourId)]);\n+                            }\n                         }\n                     }\n                 }\n+                // If it is a sink (that is it has no outgoing transaction) then treat it as if it connect to every other vertex. Otherwise the total pagerank will gradually reduce from one to zero.\n+                if (pgVertex.outCount == 0) {\n+                    pgVertex.outCount = vertexCount - 1;\n+                    sinks.add(pgVertex);\n+                    pgVertex.isSink = true;\n+                }\n+                pgVertex.updatePagerankContribution();\n             }\n         }\n-\n-        // handle dangling vertices by linking them to all pages\n-        for (final int neighbourId : verticesWithZeroOutLinks) {\n-            final int updatedCount = vertexInLinks.size();\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, updatedCount));\n-            }\n+        \n+        private static void updateSinkPagerankContribution() {\n+            sinkPagerankContribution = sinks.parallelStream().mapToDouble(pgVertex -> pgVertex.pagerankContribution).sum();\n         }\n-\n-        // initialise pagerank values\n-        final double[] tempPageranks = new double[graph.getVertexCapacity()];\n-        final double[] pageranks = new double[graph.getVertexCapacity()];\n-        Arrays.fill(pageranks, (double) 1 / vertexInLinks.size());\n-\n-        // calculate pagerank for each vertex\n-        for (int iteration = 0; iteration < iterations; iteration++) {\n-            Arrays.fill(tempPageranks, 0);\n-\n+        \n+        private void updatePagerankContribution() {\n+            pagerankContribution = pagerank/outCount;\n+        }\n+        \n+        private static void updateAllPageranks() {\n+            delta = 0;\n             double maxPagerank = 0;\n-            double delta = 0;\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                double neighbourContribution = 0.0;\n-                final Set<Tuple<Integer, Integer>> neighbours = vertexInLinks.get(vertexId);\n-                for (final Tuple<Integer, Integer> neighbour : neighbours) {\n-                    final int neighbourId = neighbour.getFirst();\n-                    final int neighbourOutCount = neighbour.getSecond();\n-                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n-                    neighbourContribution += (pageranks[neighbourPosition] / neighbourOutCount);\n+            for( PagerankVertex pgVertex: pagerankVertices) {\n+                pgVertex.stageNewPagerank();\n+                delta += Math.abs(pgVertex.pagerank - pgVertex.stagedPagerank);\n+                if (pgVertex.stagedPagerank > maxPagerank) {\n+                    maxPagerank = pgVertex.stagedPagerank;\n                 }\n-\n-                final int vertexPosition = graph.getVertexPosition(vertexId);\n-                tempPageranks[vertexPosition] = ((1 - dampingFactor) / vertexInLinks.size()) + (dampingFactor * neighbourContribution);\n-                maxPagerank = Math.max(tempPageranks[vertexPosition], maxPagerank);\n-                delta += Math.abs(pageranks[vertexPosition] - tempPageranks[vertexPosition]);\n             }\n \n-            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+            for (PagerankVertex pgVertex: pagerankVertices) {\n                 if (normaliseByAvailable && maxPagerank > 0) {\n-                    pageranks[vertexPosition] = tempPageranks[vertexPosition] / maxPagerank;\n+                    pgVertex.pagerank = pgVertex.stagedPagerank / maxPagerank;\n                 } else {\n-                    pageranks[vertexPosition] = tempPageranks[vertexPosition];\n+                    pgVertex.pagerank = pgVertex.stagedPagerank;\n                 }\n+                pgVertex.updatePagerankContribution();\n             }\n-\n-            if (delta < epsilon) {\n-                break;\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void commitPageranksToGraph(){\n+            for (PagerankVertex pgVertex : pagerankVertices) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODYwNg=="}, "originalCommit": {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NDQ1OTE5OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNDozMTowM1rOIRXvYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDowMjoxOVrOIT8CfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4NTY2Nw==", "bodyText": "@Nova-2119 @cygnus-x-1 so I am OK with updating the unit test but I am worried about this change. Previously vxId4 was last but now vxId3 is last. Does that mean the page rank was wrong before or wrong now?", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r555085667", "createdAt": "2021-01-11T14:31:03Z", "author": {"login": "arcturus2"}, "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "diffHunk": "@@ -102,15 +102,15 @@ public void testNormalisedPagerank() throws Exception {\n         final PluginParameters parameters = instance.createParameters();\n         parameters.setBooleanValue(PagerankCentralityPlugin.TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID, true);\n         parameters.setFloatValue(PagerankCentralityPlugin.DAMPING_FACTOR_PARAMETER_ID, 0.85f);\n-        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 100);\n+        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 2);\n         parameters.setFloatValue(PagerankCentralityPlugin.EPSILON_PARAMETER_ID, 1E-8f);\n         parameters.setBooleanValue(PagerankCentralityPlugin.NORMALISE_AVAILABLE_PARAMETER_ID, true);\n         PluginExecution.withPlugin(instance).withParameters(parameters).executeNow(graph);\n \n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.22181106f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.4309117f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.42492065f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.8254921f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 1f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.18089105f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.39393282f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.5371851f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 1f);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE2MTQ0NQ==", "bodyText": "It was wrong beforehand. When there is a sink its pagerank is distributed to all other nodes equally. However rather than divide by the maount of nodes - 1 it used to divide by the amount of nodes. This meant that some of the pagerank would be lost and the other nodes got less then they should have.", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r556161445", "createdAt": "2021-01-12T23:20:34Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "diffHunk": "@@ -102,15 +102,15 @@ public void testNormalisedPagerank() throws Exception {\n         final PluginParameters parameters = instance.createParameters();\n         parameters.setBooleanValue(PagerankCentralityPlugin.TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID, true);\n         parameters.setFloatValue(PagerankCentralityPlugin.DAMPING_FACTOR_PARAMETER_ID, 0.85f);\n-        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 100);\n+        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 2);\n         parameters.setFloatValue(PagerankCentralityPlugin.EPSILON_PARAMETER_ID, 1E-8f);\n         parameters.setBooleanValue(PagerankCentralityPlugin.NORMALISE_AVAILABLE_PARAMETER_ID, true);\n         PluginExecution.withPlugin(instance).withParameters(parameters).executeNow(graph);\n \n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.22181106f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.4309117f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.42492065f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.8254921f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 1f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.18089105f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.39393282f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.5371851f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 1f);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4NTY2Nw=="}, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3NzUzMw==", "bodyText": "ok thanks @Nova-2119", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r557777533", "createdAt": "2021-01-15T00:02:19Z", "author": {"login": "arcturus2"}, "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "diffHunk": "@@ -102,15 +102,15 @@ public void testNormalisedPagerank() throws Exception {\n         final PluginParameters parameters = instance.createParameters();\n         parameters.setBooleanValue(PagerankCentralityPlugin.TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID, true);\n         parameters.setFloatValue(PagerankCentralityPlugin.DAMPING_FACTOR_PARAMETER_ID, 0.85f);\n-        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 100);\n+        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 2);\n         parameters.setFloatValue(PagerankCentralityPlugin.EPSILON_PARAMETER_ID, 1E-8f);\n         parameters.setBooleanValue(PagerankCentralityPlugin.NORMALISE_AVAILABLE_PARAMETER_ID, true);\n         PluginExecution.withPlugin(instance).withParameters(parameters).executeNow(graph);\n \n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.22181106f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.4309117f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.42492065f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.8254921f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 1f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.18089105f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.39393282f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.5371851f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 1f);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4NTY2Nw=="}, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTQ0ODIzOnYy", "diffSide": "LEFT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMzowMDowMlrOIV8qjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMjoyNzowMVrOIbebHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NDk0Mg==", "bodyText": "You should add an additional author rather than replace the author (although i am happy for all bug reports to go to you :p).", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r559884942", "createdAt": "2021-01-19T03:00:02Z", "author": {"login": "cygnus-x-1"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -44,7 +40,7 @@\n  * Calculates pagerank centrality for each vertex. This centrality measure does\n  * not include loops.\n  *\n- * @author cygnus_x-1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4MDkyNg==", "bodyText": "Oh would you look at that, suddenly you're on the author list again \ud83d\ude04", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r565680926", "createdAt": "2021-01-27T22:27:01Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -44,7 +40,7 @@\n  * Calculates pagerank centrality for each vertex. This centrality measure does\n  * not include loops.\n  *\n- * @author cygnus_x-1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NDk0Mg=="}, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTQ1MDQyOnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMzowMToxOVrOIV8r6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMjozMjoxN1rOIbeloA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NTI4OA==", "bodyText": "This is my favourite line of code, i read it as \"iteration, iteration, iteration, iteration, iteration.... true\".", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r559885288", "createdAt": "2021-01-19T03:01:19Z", "author": {"login": "cygnus-x-1"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4MzYxNg==", "bodyText": "I have named this line:\nThe iteration of the alliteration of iteration\nBut also i've renamed them to maxIterations and currentIteration", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r565683616", "createdAt": "2021-01-27T22:32:17Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NTI4OA=="}, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTQ1MjI5OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMzowMjoyOFrOIV8tAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMjozNjo1NVrOIbeuLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NTU3MQ==", "bodyText": "final PagerankVertex", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r559885571", "createdAt": "2021-01-19T03:02:28Z", "author": {"login": "cygnus-x-1"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    private static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(final int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        public static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4NTgwNA==", "bodyText": "Done", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r565685804", "createdAt": "2021-01-27T22:36:55Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    private static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(final int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        public static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NTU3MQ=="}, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTQ2MjQ0OnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMzowODo0MlrOIV8y_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMjo1Mjo0NFrOIbfMlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NzEwMg==", "bodyText": "Is there a reason for instantiating PagerankVertex with a vertex position over a vertex id? I can't see this causing any issues in this instance, but it's generally not recommended practice due to the volatility of vertex position.", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r559887102", "createdAt": "2021-01-19T03:08:42Z", "author": {"login": "cygnus-x-1"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    private static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(final int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        public static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY5MzU5MQ==", "bodyText": "Hmm, I think the reason is a combination of lines 161 and 192. Im using the position just so that I can add it to the pageRankVerticies array in that position and then refer back to it.\nIf I instead stores them in a Set and used the id as the key then I could change line 192 to retrieve them by ID instead and not use the position at all. Do you think that would be better?", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r565693591", "createdAt": "2021-01-27T22:52:44Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    private static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(final int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        public static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NzEwMg=="}, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTQ3NDExOnYy", "diffSide": "RIGHT", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwMzoxNjozMVrOIV86Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMzoxODowMVrOIbf5Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4ODkxMQ==", "bodyText": "It feels weird to me that this class both represents a Pagerank controller for a graph as well as an individual Pagerank result for a vertex. Maybe you have a good reason for doing this, but it feels like it could use some logical seperation.", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r559888911", "createdAt": "2021-01-19T03:16:31Z", "author": {"login": "cygnus-x-1"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    private static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(final int vertexPosition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwNDk3NA==", "bodyText": "Nope no good reason, just hadn't thought about it.\nI think I agree, i'm going to make this change and see how it feels.", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r565704974", "createdAt": "2021-01-27T23:18:01Z", "author": {"login": "Nova-2119"}, "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    private static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(final int vertexPosition) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4ODkxMQ=="}, "originalCommit": {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2142, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}