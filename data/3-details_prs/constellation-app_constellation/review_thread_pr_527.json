{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5MTMxODgy", "number": 527, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyMzo0MFrOD9NAtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyNjo0M1rOD9NBcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTAyOTAxOnYy", "diffSide": "RIGHT", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyMzo0MFrOGWj_kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyMzo0MFrOGWj_kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTU2OQ==", "bodyText": "Use java.util.logging.Logger instead", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311569", "createdAt": "2020-05-17T22:23:40Z", "author": {"login": "antares1470"}, "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0fa47703950f616526a8835b38724bc3d76edc5"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTAyOTQ0OnYy", "diffSide": "RIGHT", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyNDozNlrOGWj_1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyNDozNlrOGWj_1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTYzNw==", "bodyText": "replace data.size() > 0 with !data.isEmpty()", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311637", "createdAt": "2020-05-17T22:24:36Z", "author": {"login": "antares1470"}, "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;\n+\n+/**\n+ * A text hashmod based on a supplied CSV file. Will modify attributes specified\n+ * in the headers to be values based on the first Key column.\n+ *\n+ * @author CrucisGamma\n+ */\n+public class Hashmod {\n+\n+    public static final String ATTRIBUTE_NAME = \"hashmod\";\n+    private HashmodCSVImportFileParser parser;\n+    private String csvFileStr;\n+    private List<String[]> data;\n+\n+    public Hashmod() {\n+        parser = null;\n+        csvFileStr = \"\";\n+    }\n+\n+    /**\n+     * Create a new Hashmod.\n+     *\n+     * @param csvFile Name of the CSV file the user has chosen\n+     */\n+    public Hashmod(final String csvFileStr) {\n+        if (csvFileStr == null) {\n+            this.csvFileStr = \"\";\n+        } else {\n+            this.csvFileStr = csvFileStr;\n+        }\n+\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public void setCSVFileStr(final String csvFileStr) {\n+        this.csvFileStr = csvFileStr;\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public String[] getCSVFileHeaders() {\n+        if (data != null && data.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0fa47703950f616526a8835b38724bc3d76edc5"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTAzMDY2OnYy", "diffSide": "RIGHT", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyNjowM1rOGWkAbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyNjowM1rOGWkAbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTc5MA==", "bodyText": "replace data.size() > 0 with !data.isEmpty()", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311790", "createdAt": "2020-05-17T22:26:03Z", "author": {"login": "antares1470"}, "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;\n+\n+/**\n+ * A text hashmod based on a supplied CSV file. Will modify attributes specified\n+ * in the headers to be values based on the first Key column.\n+ *\n+ * @author CrucisGamma\n+ */\n+public class Hashmod {\n+\n+    public static final String ATTRIBUTE_NAME = \"hashmod\";\n+    private HashmodCSVImportFileParser parser;\n+    private String csvFileStr;\n+    private List<String[]> data;\n+\n+    public Hashmod() {\n+        parser = null;\n+        csvFileStr = \"\";\n+    }\n+\n+    /**\n+     * Create a new Hashmod.\n+     *\n+     * @param csvFile Name of the CSV file the user has chosen\n+     */\n+    public Hashmod(final String csvFileStr) {\n+        if (csvFileStr == null) {\n+            this.csvFileStr = \"\";\n+        } else {\n+            this.csvFileStr = csvFileStr;\n+        }\n+\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public void setCSVFileStr(final String csvFileStr) {\n+        this.csvFileStr = csvFileStr;\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public String[] getCSVFileHeaders() {\n+        if (data != null && data.size() > 0) {\n+            return data.get(0);\n+        }\n+        return null;\n+    }\n+\n+    public String[] getCSVRow(final int row) {\n+        if (data != null && data.size() > row) {\n+            return data.get(row);\n+        }\n+        return null;\n+    }\n+\n+    public String getCSVKey() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > 0) {\n+            if (headers.length > 0) {\n+                return headers[0];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public HashMap<String, Integer> getCSVKeys() {\n+        final HashMap<String, Integer> keys = new HashMap<>();\n+        if (data != null && data.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0fa47703950f616526a8835b38724bc3d76edc5"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTAzMDc1OnYy", "diffSide": "RIGHT", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyNjoxOVrOGWkAfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyNjoxOVrOGWkAfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTgwNg==", "bodyText": "replace data.size() > 0 with !data.isEmpty()", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311806", "createdAt": "2020-05-17T22:26:19Z", "author": {"login": "antares1470"}, "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;\n+\n+/**\n+ * A text hashmod based on a supplied CSV file. Will modify attributes specified\n+ * in the headers to be values based on the first Key column.\n+ *\n+ * @author CrucisGamma\n+ */\n+public class Hashmod {\n+\n+    public static final String ATTRIBUTE_NAME = \"hashmod\";\n+    private HashmodCSVImportFileParser parser;\n+    private String csvFileStr;\n+    private List<String[]> data;\n+\n+    public Hashmod() {\n+        parser = null;\n+        csvFileStr = \"\";\n+    }\n+\n+    /**\n+     * Create a new Hashmod.\n+     *\n+     * @param csvFile Name of the CSV file the user has chosen\n+     */\n+    public Hashmod(final String csvFileStr) {\n+        if (csvFileStr == null) {\n+            this.csvFileStr = \"\";\n+        } else {\n+            this.csvFileStr = csvFileStr;\n+        }\n+\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public void setCSVFileStr(final String csvFileStr) {\n+        this.csvFileStr = csvFileStr;\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public String[] getCSVFileHeaders() {\n+        if (data != null && data.size() > 0) {\n+            return data.get(0);\n+        }\n+        return null;\n+    }\n+\n+    public String[] getCSVRow(final int row) {\n+        if (data != null && data.size() > row) {\n+            return data.get(row);\n+        }\n+        return null;\n+    }\n+\n+    public String getCSVKey() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > 0) {\n+            if (headers.length > 0) {\n+                return headers[0];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public HashMap<String, Integer> getCSVKeys() {\n+        final HashMap<String, Integer> keys = new HashMap<>();\n+        if (data != null && data.size() > 0) {\n+            for (int i = 1; i < data.size(); i++) {\n+                final String[] row = getCSVRow(i);\n+                if (row[0] != null) {\n+                    keys.put(row[0].toUpperCase(), 0);\n+                }\n+            }\n+        }\n+        return keys;\n+    }\n+\n+    public int getNumberCSVColumns() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null) {\n+            return headers.length;\n+        }\n+        return 0;\n+    }\n+\n+    public String getCSVHeader(final int col) {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > col) {\n+            return headers[col];\n+        }\n+        return null;\n+    }\n+\n+    public List<String[]> getCSVFileData() {\n+        if (data != null && data.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0fa47703950f616526a8835b38724bc3d76edc5"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTAzMDg0OnYy", "diffSide": "RIGHT", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyNjoyOFrOGWkAiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyNjoyOFrOGWkAiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTgxOQ==", "bodyText": "replace data.size() > 0 with !data.isEmpty()", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311819", "createdAt": "2020-05-17T22:26:28Z", "author": {"login": "antares1470"}, "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;\n+\n+/**\n+ * A text hashmod based on a supplied CSV file. Will modify attributes specified\n+ * in the headers to be values based on the first Key column.\n+ *\n+ * @author CrucisGamma\n+ */\n+public class Hashmod {\n+\n+    public static final String ATTRIBUTE_NAME = \"hashmod\";\n+    private HashmodCSVImportFileParser parser;\n+    private String csvFileStr;\n+    private List<String[]> data;\n+\n+    public Hashmod() {\n+        parser = null;\n+        csvFileStr = \"\";\n+    }\n+\n+    /**\n+     * Create a new Hashmod.\n+     *\n+     * @param csvFile Name of the CSV file the user has chosen\n+     */\n+    public Hashmod(final String csvFileStr) {\n+        if (csvFileStr == null) {\n+            this.csvFileStr = \"\";\n+        } else {\n+            this.csvFileStr = csvFileStr;\n+        }\n+\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public void setCSVFileStr(final String csvFileStr) {\n+        this.csvFileStr = csvFileStr;\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public String[] getCSVFileHeaders() {\n+        if (data != null && data.size() > 0) {\n+            return data.get(0);\n+        }\n+        return null;\n+    }\n+\n+    public String[] getCSVRow(final int row) {\n+        if (data != null && data.size() > row) {\n+            return data.get(row);\n+        }\n+        return null;\n+    }\n+\n+    public String getCSVKey() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > 0) {\n+            if (headers.length > 0) {\n+                return headers[0];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public HashMap<String, Integer> getCSVKeys() {\n+        final HashMap<String, Integer> keys = new HashMap<>();\n+        if (data != null && data.size() > 0) {\n+            for (int i = 1; i < data.size(); i++) {\n+                final String[] row = getCSVRow(i);\n+                if (row[0] != null) {\n+                    keys.put(row[0].toUpperCase(), 0);\n+                }\n+            }\n+        }\n+        return keys;\n+    }\n+\n+    public int getNumberCSVColumns() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null) {\n+            return headers.length;\n+        }\n+        return 0;\n+    }\n+\n+    public String getCSVHeader(final int col) {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > col) {\n+            return headers[col];\n+        }\n+        return null;\n+    }\n+\n+    public List<String[]> getCSVFileData() {\n+        if (data != null && data.size() > 0) {\n+            return data;\n+        }\n+        return null;\n+    }\n+\n+    public String getValueFromKey(final String key, final int value) {\n+        if (data != null && data.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0fa47703950f616526a8835b38724bc3d76edc5"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTAzMDg5OnYy", "diffSide": "RIGHT", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyNjo0M1rOGWkAkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjoyNjo0M1rOGWkAkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTgyNg==", "bodyText": "replace data.size() > 0 with !data.isEmpty()", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311826", "createdAt": "2020-05-17T22:26:43Z", "author": {"login": "antares1470"}, "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;\n+\n+/**\n+ * A text hashmod based on a supplied CSV file. Will modify attributes specified\n+ * in the headers to be values based on the first Key column.\n+ *\n+ * @author CrucisGamma\n+ */\n+public class Hashmod {\n+\n+    public static final String ATTRIBUTE_NAME = \"hashmod\";\n+    private HashmodCSVImportFileParser parser;\n+    private String csvFileStr;\n+    private List<String[]> data;\n+\n+    public Hashmod() {\n+        parser = null;\n+        csvFileStr = \"\";\n+    }\n+\n+    /**\n+     * Create a new Hashmod.\n+     *\n+     * @param csvFile Name of the CSV file the user has chosen\n+     */\n+    public Hashmod(final String csvFileStr) {\n+        if (csvFileStr == null) {\n+            this.csvFileStr = \"\";\n+        } else {\n+            this.csvFileStr = csvFileStr;\n+        }\n+\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public void setCSVFileStr(final String csvFileStr) {\n+        this.csvFileStr = csvFileStr;\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public String[] getCSVFileHeaders() {\n+        if (data != null && data.size() > 0) {\n+            return data.get(0);\n+        }\n+        return null;\n+    }\n+\n+    public String[] getCSVRow(final int row) {\n+        if (data != null && data.size() > row) {\n+            return data.get(row);\n+        }\n+        return null;\n+    }\n+\n+    public String getCSVKey() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > 0) {\n+            if (headers.length > 0) {\n+                return headers[0];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public HashMap<String, Integer> getCSVKeys() {\n+        final HashMap<String, Integer> keys = new HashMap<>();\n+        if (data != null && data.size() > 0) {\n+            for (int i = 1; i < data.size(); i++) {\n+                final String[] row = getCSVRow(i);\n+                if (row[0] != null) {\n+                    keys.put(row[0].toUpperCase(), 0);\n+                }\n+            }\n+        }\n+        return keys;\n+    }\n+\n+    public int getNumberCSVColumns() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null) {\n+            return headers.length;\n+        }\n+        return 0;\n+    }\n+\n+    public String getCSVHeader(final int col) {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > col) {\n+            return headers[col];\n+        }\n+        return null;\n+    }\n+\n+    public List<String[]> getCSVFileData() {\n+        if (data != null && data.size() > 0) {\n+            return data;\n+        }\n+        return null;\n+    }\n+\n+    public String getValueFromKey(final String key, final int value) {\n+        if (data != null && data.size() > 0) {\n+            for (int i = 1; i < data.size(); i++) {\n+                final String[] row = getCSVRow(i);\n+                if (row[0].equalsIgnoreCase(key)) {\n+\n+                    if (row.length > value) {\n+                        return row[value];\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public Boolean doesKeyExist(final String key) {\n+        if (key == null) {\n+            return false;\n+        }\n+        if (data != null && data.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0fa47703950f616526a8835b38724bc3d76edc5"}, "originalPosition": 152}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2351, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}