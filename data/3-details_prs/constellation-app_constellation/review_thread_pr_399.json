{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MTEwNzU1", "number": 399, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMzoyNTo1OFrODu7dng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMzo1MDoxNVrODu7muA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNTM1MzI2OnYy", "diffSide": "LEFT", "path": "CoreGraphFramework/src/au/gov/asd/tac/constellation/graph/StoreGraph.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMzoyNTo1OFrOGBETYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwMTowMTowN1rOGBFDjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MjI1OA==", "bodyText": "Don't know where I was going on this section of code. Cheers", "url": "https://github.com/constellation-app/constellation/pull/399#discussion_r403772258", "createdAt": "2020-04-05T23:25:58Z", "author": {"login": "aldebaran30701"}, "path": "CoreGraphFramework/src/au/gov/asd/tac/constellation/graph/StoreGraph.java", "diffHunk": "@@ -2019,79 +2024,79 @@ private int recalculateBitmask(final GraphElementType elementType, final int id)\n     // TODO: Clean up this code and cases\n     /**\n      * Evaluates a string representation of a query in relation to a single\n-     * element on the graph returns true when the node satisfies the condition.\n-     * False otherwise. Query is structured as below:\n+     * element on the graph returns true when the node satisfies the condition,\n+     * false otherwise.\n+     * <p>\n+     * A query should be structured as follows:\n      * vertex_color:<=:0,0,0 vertex_selected:==:true vertex_color:>:255,255,255\n      *\n-     * @param postfixQuery the string query\n-     * @param id the id of the element\n-     * @return a boolean result determining whether the element satisfied the\n+     * @param elementType the type of the element\n+     * @param elementId the id of the element\n+     * @param query the query expression\n+     * @return a boolean determining whether the element satisfied the\n      * constraints.\n      */\n-    private boolean evaluateQuery(final String postfixQuery, final int id, final GraphElementType elementType) {\n-        // Exit condition for show all\n-        if (postfixQuery.equals(\"\")) {\n+    private boolean evaluateLayerQuery(final GraphElementType elementType, final int elementId, final String query) {\n+        // exit condition for show all\n+        if (query.isBlank()) {\n             return true;\n         }\n \n-        Operator currentOperand = Operator.NOTFOUND;\n+        // Split with backtick to reduce chance of char in query.\n+        final String[] rules = query.split(\"`\");\n+//        System.out.println(\"Rules: \" + rules.length);\n \n-        String[] rules = postfixQuery.split(\"`\"); // Split with backtick to reduce chance of char in query.\n-        //System.out.println(\"Rules: \" + rules.length);\n+        // iterate over rules\n         String evaluatedResult = \"\";\n-        boolean finalRes = true;\n-        boolean ignoreRes = false;\n-\n-        for (String rule : rules) {\n-            //System.out.println(\"Rule: \" + rule);\n-            String[] ruleSegments = rule.split(\":\");\n-            int segCount = 0;\n-            AttributeDescription ad = null;\n-            int attrID = 1;\n-            // iterate over each section and grab the values.\n-            for (String segment : ruleSegments) {\n-                //System.out.println(\"Current: \" + segment);\n-                segCount++;\n-                switch (segCount) {\n+        Operator currentOperand = Operator.NOTFOUND;\n+        boolean finalResult = true;\n+        boolean ignoreResult = false;\n+        for (final String rule : rules) {\n+//            System.out.println(\"Rule: \" + rule);\n+            final String[] ruleSegments = rule.split(\":\");\n+\n+            // iterate over each segment and grab the values\n+            AttributeDescription attributeDescription = null;\n+            int attributeId = 1;\n+            int segmentCount = 0;\n+            for (final String ruleSegment : ruleSegments) {\n+//                System.out.println(\"Current: \" + ruleSegment);\n+                segmentCount++;\n+                switch (segmentCount) {\n                     case 1: {\n-                        if (elementType == GraphElementType.VERTEX) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3da4fee9c0952b9c18b624bf2c42f8940be5e33e"}, "originalPosition": 961}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4NDEyNA==", "bodyText": "It looked like you'd separated it out to support debug print statements.", "url": "https://github.com/constellation-app/constellation/pull/399#discussion_r403784124", "createdAt": "2020-04-06T00:57:37Z", "author": {"login": "cygnus-x-1"}, "path": "CoreGraphFramework/src/au/gov/asd/tac/constellation/graph/StoreGraph.java", "diffHunk": "@@ -2019,79 +2024,79 @@ private int recalculateBitmask(final GraphElementType elementType, final int id)\n     // TODO: Clean up this code and cases\n     /**\n      * Evaluates a string representation of a query in relation to a single\n-     * element on the graph returns true when the node satisfies the condition.\n-     * False otherwise. Query is structured as below:\n+     * element on the graph returns true when the node satisfies the condition,\n+     * false otherwise.\n+     * <p>\n+     * A query should be structured as follows:\n      * vertex_color:<=:0,0,0 vertex_selected:==:true vertex_color:>:255,255,255\n      *\n-     * @param postfixQuery the string query\n-     * @param id the id of the element\n-     * @return a boolean result determining whether the element satisfied the\n+     * @param elementType the type of the element\n+     * @param elementId the id of the element\n+     * @param query the query expression\n+     * @return a boolean determining whether the element satisfied the\n      * constraints.\n      */\n-    private boolean evaluateQuery(final String postfixQuery, final int id, final GraphElementType elementType) {\n-        // Exit condition for show all\n-        if (postfixQuery.equals(\"\")) {\n+    private boolean evaluateLayerQuery(final GraphElementType elementType, final int elementId, final String query) {\n+        // exit condition for show all\n+        if (query.isBlank()) {\n             return true;\n         }\n \n-        Operator currentOperand = Operator.NOTFOUND;\n+        // Split with backtick to reduce chance of char in query.\n+        final String[] rules = query.split(\"`\");\n+//        System.out.println(\"Rules: \" + rules.length);\n \n-        String[] rules = postfixQuery.split(\"`\"); // Split with backtick to reduce chance of char in query.\n-        //System.out.println(\"Rules: \" + rules.length);\n+        // iterate over rules\n         String evaluatedResult = \"\";\n-        boolean finalRes = true;\n-        boolean ignoreRes = false;\n-\n-        for (String rule : rules) {\n-            //System.out.println(\"Rule: \" + rule);\n-            String[] ruleSegments = rule.split(\":\");\n-            int segCount = 0;\n-            AttributeDescription ad = null;\n-            int attrID = 1;\n-            // iterate over each section and grab the values.\n-            for (String segment : ruleSegments) {\n-                //System.out.println(\"Current: \" + segment);\n-                segCount++;\n-                switch (segCount) {\n+        Operator currentOperand = Operator.NOTFOUND;\n+        boolean finalResult = true;\n+        boolean ignoreResult = false;\n+        for (final String rule : rules) {\n+//            System.out.println(\"Rule: \" + rule);\n+            final String[] ruleSegments = rule.split(\":\");\n+\n+            // iterate over each segment and grab the values\n+            AttributeDescription attributeDescription = null;\n+            int attributeId = 1;\n+            int segmentCount = 0;\n+            for (final String ruleSegment : ruleSegments) {\n+//                System.out.println(\"Current: \" + ruleSegment);\n+                segmentCount++;\n+                switch (segmentCount) {\n                     case 1: {\n-                        if (elementType == GraphElementType.VERTEX) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MjI1OA=="}, "originalCommit": {"oid": "3da4fee9c0952b9c18b624bf2c42f8940be5e33e"}, "originalPosition": 961}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4NDU5MQ==", "bodyText": "There were a few parts I did do that. But I think this was a case of coding before coffee. \ud83d\ude06", "url": "https://github.com/constellation-app/constellation/pull/399#discussion_r403784591", "createdAt": "2020-04-06T01:01:07Z", "author": {"login": "aldebaran30701"}, "path": "CoreGraphFramework/src/au/gov/asd/tac/constellation/graph/StoreGraph.java", "diffHunk": "@@ -2019,79 +2024,79 @@ private int recalculateBitmask(final GraphElementType elementType, final int id)\n     // TODO: Clean up this code and cases\n     /**\n      * Evaluates a string representation of a query in relation to a single\n-     * element on the graph returns true when the node satisfies the condition.\n-     * False otherwise. Query is structured as below:\n+     * element on the graph returns true when the node satisfies the condition,\n+     * false otherwise.\n+     * <p>\n+     * A query should be structured as follows:\n      * vertex_color:<=:0,0,0 vertex_selected:==:true vertex_color:>:255,255,255\n      *\n-     * @param postfixQuery the string query\n-     * @param id the id of the element\n-     * @return a boolean result determining whether the element satisfied the\n+     * @param elementType the type of the element\n+     * @param elementId the id of the element\n+     * @param query the query expression\n+     * @return a boolean determining whether the element satisfied the\n      * constraints.\n      */\n-    private boolean evaluateQuery(final String postfixQuery, final int id, final GraphElementType elementType) {\n-        // Exit condition for show all\n-        if (postfixQuery.equals(\"\")) {\n+    private boolean evaluateLayerQuery(final GraphElementType elementType, final int elementId, final String query) {\n+        // exit condition for show all\n+        if (query.isBlank()) {\n             return true;\n         }\n \n-        Operator currentOperand = Operator.NOTFOUND;\n+        // Split with backtick to reduce chance of char in query.\n+        final String[] rules = query.split(\"`\");\n+//        System.out.println(\"Rules: \" + rules.length);\n \n-        String[] rules = postfixQuery.split(\"`\"); // Split with backtick to reduce chance of char in query.\n-        //System.out.println(\"Rules: \" + rules.length);\n+        // iterate over rules\n         String evaluatedResult = \"\";\n-        boolean finalRes = true;\n-        boolean ignoreRes = false;\n-\n-        for (String rule : rules) {\n-            //System.out.println(\"Rule: \" + rule);\n-            String[] ruleSegments = rule.split(\":\");\n-            int segCount = 0;\n-            AttributeDescription ad = null;\n-            int attrID = 1;\n-            // iterate over each section and grab the values.\n-            for (String segment : ruleSegments) {\n-                //System.out.println(\"Current: \" + segment);\n-                segCount++;\n-                switch (segCount) {\n+        Operator currentOperand = Operator.NOTFOUND;\n+        boolean finalResult = true;\n+        boolean ignoreResult = false;\n+        for (final String rule : rules) {\n+//            System.out.println(\"Rule: \" + rule);\n+            final String[] ruleSegments = rule.split(\":\");\n+\n+            // iterate over each segment and grab the values\n+            AttributeDescription attributeDescription = null;\n+            int attributeId = 1;\n+            int segmentCount = 0;\n+            for (final String ruleSegment : ruleSegments) {\n+//                System.out.println(\"Current: \" + ruleSegment);\n+                segmentCount++;\n+                switch (segmentCount) {\n                     case 1: {\n-                        if (elementType == GraphElementType.VERTEX) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MjI1OA=="}, "originalCommit": {"oid": "3da4fee9c0952b9c18b624bf2c42f8940be5e33e"}, "originalPosition": 961}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNTM1NDc3OnYy", "diffSide": "LEFT", "path": "CoreGraphFramework/src/au/gov/asd/tac/constellation/graph/StoreGraph.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMzoyNzoyOVrOGBEUGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMzoyNzoyOVrOGBEUGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MjQ0Mg==", "bodyText": "I'll merge in some code that removes this. The functionality of >= can be achieved by checking the query with > || =.", "url": "https://github.com/constellation-app/constellation/pull/399#discussion_r403772442", "createdAt": "2020-04-05T23:27:29Z", "author": {"login": "aldebaran30701"}, "path": "CoreGraphFramework/src/au/gov/asd/tac/constellation/graph/StoreGraph.java", "diffHunk": "@@ -2019,79 +2024,79 @@ private int recalculateBitmask(final GraphElementType elementType, final int id)\n     // TODO: Clean up this code and cases\n     /**\n      * Evaluates a string representation of a query in relation to a single\n-     * element on the graph returns true when the node satisfies the condition.\n-     * False otherwise. Query is structured as below:\n+     * element on the graph returns true when the node satisfies the condition,\n+     * false otherwise.\n+     * <p>\n+     * A query should be structured as follows:\n      * vertex_color:<=:0,0,0 vertex_selected:==:true vertex_color:>:255,255,255\n      *\n-     * @param postfixQuery the string query\n-     * @param id the id of the element\n-     * @return a boolean result determining whether the element satisfied the\n+     * @param elementType the type of the element\n+     * @param elementId the id of the element\n+     * @param query the query expression\n+     * @return a boolean determining whether the element satisfied the\n      * constraints.\n      */\n-    private boolean evaluateQuery(final String postfixQuery, final int id, final GraphElementType elementType) {\n-        // Exit condition for show all\n-        if (postfixQuery.equals(\"\")) {\n+    private boolean evaluateLayerQuery(final GraphElementType elementType, final int elementId, final String query) {\n+        // exit condition for show all\n+        if (query.isBlank()) {\n             return true;\n         }\n \n-        Operator currentOperand = Operator.NOTFOUND;\n+        // Split with backtick to reduce chance of char in query.\n+        final String[] rules = query.split(\"`\");\n+//        System.out.println(\"Rules: \" + rules.length);\n \n-        String[] rules = postfixQuery.split(\"`\"); // Split with backtick to reduce chance of char in query.\n-        //System.out.println(\"Rules: \" + rules.length);\n+        // iterate over rules\n         String evaluatedResult = \"\";\n-        boolean finalRes = true;\n-        boolean ignoreRes = false;\n-\n-        for (String rule : rules) {\n-            //System.out.println(\"Rule: \" + rule);\n-            String[] ruleSegments = rule.split(\":\");\n-            int segCount = 0;\n-            AttributeDescription ad = null;\n-            int attrID = 1;\n-            // iterate over each section and grab the values.\n-            for (String segment : ruleSegments) {\n-                //System.out.println(\"Current: \" + segment);\n-                segCount++;\n-                switch (segCount) {\n+        Operator currentOperand = Operator.NOTFOUND;\n+        boolean finalResult = true;\n+        boolean ignoreResult = false;\n+        for (final String rule : rules) {\n+//            System.out.println(\"Rule: \" + rule);\n+            final String[] ruleSegments = rule.split(\":\");\n+\n+            // iterate over each segment and grab the values\n+            AttributeDescription attributeDescription = null;\n+            int attributeId = 1;\n+            int segmentCount = 0;\n+            for (final String ruleSegment : ruleSegments) {\n+//                System.out.println(\"Current: \" + ruleSegment);\n+                segmentCount++;\n+                switch (segmentCount) {\n                     case 1: {\n-                        if (elementType == GraphElementType.VERTEX) {\n-                            attrID = getAttribute(GraphElementType.VERTEX, segment);\n-                        } else if (elementType == GraphElementType.TRANSACTION) {\n-                            attrID = getAttribute(GraphElementType.TRANSACTION, segment);\n-                        }\n-                        \n-                        if (attrID != Graph.NOT_FOUND) {\n-                            ad = attributeDescriptions[attrID];\n+                        attributeId = getAttribute(elementType, ruleSegment);\n+                        if (attributeId != Graph.NOT_FOUND) {\n+                            attributeDescription = attributeDescriptions[attributeId];\n                         }\n                         break;\n                     }\n                     case 2: {\n-                        switch (segment) {\n-                            case \"=\": {// equality\n+                        switch (ruleSegment) {\n+                            case \"=\": { // equality\n                                 currentOperand = Operator.EQUALS;\n                                 break;\n                             }\n-                            case \"!=\": {// not equality\n+                            case \"!=\": { // non-equality\n                                 currentOperand = Operator.NOTEQUALS;\n                                 break;\n                             }\n-                            case \">\": {// greater than - how to handle things which can't be compared GT or LT?\n+                            case \">\": { // greater than\n                                 currentOperand = Operator.GREATERTHAN;\n                                 break;\n                             }\n-                            case \"<\": {// Less than\n+                            case \"<\": { // less than\n                                 currentOperand = Operator.LESSTHAN;\n                                 break;\n                             }\n-                            case \">=\": {// greater than or EQ to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3da4fee9c0952b9c18b624bf2c42f8940be5e33e"}, "originalPosition": 998}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNTM2NTczOnYy", "diffSide": "RIGHT", "path": "CoreGraphFramework/src/au/gov/asd/tac/constellation/graph/StoreGraph.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMzozODo1MlrOGBEZjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMzozODo1MlrOGBEZjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MzgzOA==", "bodyText": "The only reason it is checked here is so that when the element bitmask is changed, it doesn't re-update the bitmask and get called numerous times.", "url": "https://github.com/constellation-app/constellation/pull/399#discussion_r403773838", "createdAt": "2020-04-05T23:38:52Z", "author": {"login": "aldebaran30701"}, "path": "CoreGraphFramework/src/au/gov/asd/tac/constellation/graph/StoreGraph.java", "diffHunk": "@@ -2381,13 +2376,15 @@ public void setIntValue(final int attribute, final int id, final int value) {\n             }\n         }\n \n-        // If the selected layers to display value has changed then recalculate visibility of all objects, otherwise,\n-        // check if the change impacts an objects visibility\n-        if (selectedFilterBitmaskAttrId >= 0 && selectedFilterBitmaskAttrId == attribute) {\n+        // if selected visible layers has changed then recalculate visibility of all objects, \n+        // otherwise check if the change impacts an objects visibility\n+        if (attribute == layerMaskSelectedAttributeId && layerMaskSelectedAttributeId >= 0) {\n             // one node changes, pass to change list then only iterate that?\n-            updateAllBitmasks(); // hits here when changing layers only. not on update of elements to layers\n-        } else if (!avoidUpdate) {\n-            updateBitmask(attribute, id);\n+            // hits here when changing layers only. not on update of elements to layers\n+            updateAllLayerMasks();\n+        } else if (!avoidLayerUpdate) {\n+            // TODO: why is avoidLayerUpdate only checked here?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3da4fee9c0952b9c18b624bf2c42f8940be5e33e"}, "originalPosition": 1323}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNTM3NjU2OnYy", "diffSide": "RIGHT", "path": "CoreLayersView/src/au/gov/asd/tac/constellation/views/layers/LayersViewPane.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMzo1MDoxNVrOGBEfLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMzo1MDoxNVrOGBEfLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3NTI3Ng==", "bodyText": "Perfect.", "url": "https://github.com/constellation-app/constellation/pull/399#discussion_r403775276", "createdAt": "2020-04-05T23:50:15Z", "author": {"login": "aldebaran30701"}, "path": "CoreLayersView/src/au/gov/asd/tac/constellation/views/layers/LayersViewPane.java", "diffHunk": "@@ -96,13 +96,19 @@ public LayersViewPane(final LayersViewController controller) {\n         // create options\n         this.options = new HBox();\n         options.setAlignment(Pos.TOP_LEFT);\n-        options.setBackground(new Background(new BackgroundFill(Color.GREEN, CornerRadii.EMPTY, Insets.EMPTY)));\n+//        options.setBackground(new Background(new BackgroundFill(Color.GREEN, CornerRadii.EMPTY, Insets.EMPTY)));\n         \n         // create add button\n         final Button addButton = new Button(\"Add New Layer\");\n         addButton.setAlignment(Pos.CENTER_RIGHT);\n         addButton.setOnAction(event -> {\n-            createLayer(false);\n+            if (layers.getChildren().size() <= 32) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3da4fee9c0952b9c18b624bf2c42f8940be5e33e"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2466, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}