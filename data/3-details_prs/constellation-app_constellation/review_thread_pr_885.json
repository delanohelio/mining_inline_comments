{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzNzQ3OTUz", "number": 885, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1MjoxMlrOE0N1Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1NTo0NlrOE0N3PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg4MDU4OnYy", "diffSide": "RIGHT", "path": "CoreTableView/src/au/gov/asd/tac/constellation/views/tableview2/TableViewPane.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1MjoxMlrOHr03PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzo0NDoyOVrOHr1dnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjkyNQ==", "bodyText": "A real minor one but how about calling it updateSelectionFromFxThread?", "url": "https://github.com/constellation-app/constellation/pull/885#discussion_r515716925", "createdAt": "2020-11-02T02:52:12Z", "author": {"login": "arcturus2"}, "path": "CoreTableView/src/au/gov/asd/tac/constellation/views/tableview2/TableViewPane.java", "diffHunk": "@@ -1239,44 +1234,99 @@ public void updateSelection(final Graph graph, final TableViewState state) {\n                 if (!state.isSelectedOnly()) {\n                     final List<Integer> selectedIds = new ArrayList<>();\n                     final ReadableGraph readableGraph = graph.getReadableGraph();\n-                    try {\n-                        final boolean isVertex = state.getElementType() == GraphElementType.VERTEX;\n-                        final int selectedAttributeId = isVertex\n-                                ? VisualConcept.VertexAttribute.SELECTED.get(readableGraph)\n-                                : VisualConcept.TransactionAttribute.SELECTED.get(readableGraph);\n-                        final int elementCount = isVertex\n-                                ? readableGraph.getVertexCount()\n-                                : readableGraph.getTransactionCount();\n-                        for (int elementPosition = 0; elementPosition < elementCount; elementPosition++) {\n-                            final int elementId = isVertex\n-                                    ? readableGraph.getVertex(elementPosition)\n-                                    : readableGraph.getTransaction(elementPosition);\n-                            boolean isSelected = false;\n-                            if (selectedAttributeId != Graph.NOT_FOUND) {\n-                                isSelected = readableGraph.getBooleanValue(selectedAttributeId, elementId);\n-                            }\n-                            if (isSelected) {\n-                                selectedIds.add(elementId);\n-                            }\n-                        }\n-                    } finally {\n-                        readableGraph.release();\n-                    }\n+                    addToSelectedIds(selectedIds, readableGraph, state);\n \n                     // update table selection\n                     final int[] selectedIndices = selectedIds.stream().map(id -> elementIdToRowIndex.get(id))\n                             .map(row -> table.getItems().indexOf(row)).mapToInt(i -> i).toArray();\n-\n-                    Platform.runLater(() -> {\n+                    \n+                    Platform.runLater(() -> {                        \n                         selectedProperty.removeListener(tableSelectionListener);\n                         table.getSelectionModel().clearSelection();\n                         if (!selectedIds.isEmpty()) {\n                             table.getSelectionModel().selectIndices(selectedIndices[0], selectedIndices);\n                         }\n-                        selectedProperty.addListener(tableSelectionListener);\n+                        selectedProperty.addListener(tableSelectionListener);                            \n                     });\n                 }\n             }\n         }\n     }\n+       \n+    /**\n+     * A version of the updateSelection(Graph, TableViewState) function which is\n+     * to be run on the JavaFX Application Thread\n+     * \n+     * @param graph the graph to read selection from.\n+     * @param state the current table view state.\n+     */\n+    private void updateSelectionFromJAT(final Graph graph, final TableViewState state) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee8630b73bbddbc60cfd949ac15f4c16faea4c3f"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyNjc0OQ==", "bodyText": "done", "url": "https://github.com/constellation-app/constellation/pull/885#discussion_r515726749", "createdAt": "2020-11-02T03:44:29Z", "author": {"login": "antares1470"}, "path": "CoreTableView/src/au/gov/asd/tac/constellation/views/tableview2/TableViewPane.java", "diffHunk": "@@ -1239,44 +1234,99 @@ public void updateSelection(final Graph graph, final TableViewState state) {\n                 if (!state.isSelectedOnly()) {\n                     final List<Integer> selectedIds = new ArrayList<>();\n                     final ReadableGraph readableGraph = graph.getReadableGraph();\n-                    try {\n-                        final boolean isVertex = state.getElementType() == GraphElementType.VERTEX;\n-                        final int selectedAttributeId = isVertex\n-                                ? VisualConcept.VertexAttribute.SELECTED.get(readableGraph)\n-                                : VisualConcept.TransactionAttribute.SELECTED.get(readableGraph);\n-                        final int elementCount = isVertex\n-                                ? readableGraph.getVertexCount()\n-                                : readableGraph.getTransactionCount();\n-                        for (int elementPosition = 0; elementPosition < elementCount; elementPosition++) {\n-                            final int elementId = isVertex\n-                                    ? readableGraph.getVertex(elementPosition)\n-                                    : readableGraph.getTransaction(elementPosition);\n-                            boolean isSelected = false;\n-                            if (selectedAttributeId != Graph.NOT_FOUND) {\n-                                isSelected = readableGraph.getBooleanValue(selectedAttributeId, elementId);\n-                            }\n-                            if (isSelected) {\n-                                selectedIds.add(elementId);\n-                            }\n-                        }\n-                    } finally {\n-                        readableGraph.release();\n-                    }\n+                    addToSelectedIds(selectedIds, readableGraph, state);\n \n                     // update table selection\n                     final int[] selectedIndices = selectedIds.stream().map(id -> elementIdToRowIndex.get(id))\n                             .map(row -> table.getItems().indexOf(row)).mapToInt(i -> i).toArray();\n-\n-                    Platform.runLater(() -> {\n+                    \n+                    Platform.runLater(() -> {                        \n                         selectedProperty.removeListener(tableSelectionListener);\n                         table.getSelectionModel().clearSelection();\n                         if (!selectedIds.isEmpty()) {\n                             table.getSelectionModel().selectIndices(selectedIndices[0], selectedIndices);\n                         }\n-                        selectedProperty.addListener(tableSelectionListener);\n+                        selectedProperty.addListener(tableSelectionListener);                            \n                     });\n                 }\n             }\n         }\n     }\n+       \n+    /**\n+     * A version of the updateSelection(Graph, TableViewState) function which is\n+     * to be run on the JavaFX Application Thread\n+     * \n+     * @param graph the graph to read selection from.\n+     * @param state the current table view state.\n+     */\n+    private void updateSelectionFromJAT(final Graph graph, final TableViewState state) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjkyNQ=="}, "originalCommit": {"oid": "ee8630b73bbddbc60cfd949ac15f4c16faea4c3f"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg4NTQxOnYy", "diffSide": "RIGHT", "path": "CoreTableView/src/au/gov/asd/tac/constellation/views/tableview2/TableViewPane.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo1NTo0NlrOHr06CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDo1MToxNlrOHr2NpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNzY0MQ==", "bodyText": "So if it is meant to be run on the FX thread, how is this bit passing?", "url": "https://github.com/constellation-app/constellation/pull/885#discussion_r515717641", "createdAt": "2020-11-02T02:55:46Z", "author": {"login": "arcturus2"}, "path": "CoreTableView/src/au/gov/asd/tac/constellation/views/tableview2/TableViewPane.java", "diffHunk": "@@ -1239,44 +1234,99 @@ public void updateSelection(final Graph graph, final TableViewState state) {\n                 if (!state.isSelectedOnly()) {\n                     final List<Integer> selectedIds = new ArrayList<>();\n                     final ReadableGraph readableGraph = graph.getReadableGraph();\n-                    try {\n-                        final boolean isVertex = state.getElementType() == GraphElementType.VERTEX;\n-                        final int selectedAttributeId = isVertex\n-                                ? VisualConcept.VertexAttribute.SELECTED.get(readableGraph)\n-                                : VisualConcept.TransactionAttribute.SELECTED.get(readableGraph);\n-                        final int elementCount = isVertex\n-                                ? readableGraph.getVertexCount()\n-                                : readableGraph.getTransactionCount();\n-                        for (int elementPosition = 0; elementPosition < elementCount; elementPosition++) {\n-                            final int elementId = isVertex\n-                                    ? readableGraph.getVertex(elementPosition)\n-                                    : readableGraph.getTransaction(elementPosition);\n-                            boolean isSelected = false;\n-                            if (selectedAttributeId != Graph.NOT_FOUND) {\n-                                isSelected = readableGraph.getBooleanValue(selectedAttributeId, elementId);\n-                            }\n-                            if (isSelected) {\n-                                selectedIds.add(elementId);\n-                            }\n-                        }\n-                    } finally {\n-                        readableGraph.release();\n-                    }\n+                    addToSelectedIds(selectedIds, readableGraph, state);\n \n                     // update table selection\n                     final int[] selectedIndices = selectedIds.stream().map(id -> elementIdToRowIndex.get(id))\n                             .map(row -> table.getItems().indexOf(row)).mapToInt(i -> i).toArray();\n-\n-                    Platform.runLater(() -> {\n+                    \n+                    Platform.runLater(() -> {                        \n                         selectedProperty.removeListener(tableSelectionListener);\n                         table.getSelectionModel().clearSelection();\n                         if (!selectedIds.isEmpty()) {\n                             table.getSelectionModel().selectIndices(selectedIndices[0], selectedIndices);\n                         }\n-                        selectedProperty.addListener(tableSelectionListener);\n+                        selectedProperty.addListener(tableSelectionListener);                            \n                     });\n                 }\n             }\n         }\n     }\n+       \n+    /**\n+     * A version of the updateSelection(Graph, TableViewState) function which is\n+     * to be run on the JavaFX Application Thread\n+     * \n+     * @param graph the graph to read selection from.\n+     * @param state the current table view state.\n+     */\n+    private void updateSelectionFromJAT(final Graph graph, final TableViewState state) {\n+        synchronized (LOCK) {\n+            if (graph != null && state != null) {\n+\n+                if (!Platform.isFxApplicationThread()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee8630b73bbddbc60cfd949ac15f4c16faea4c3f"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyNjU1Nw==", "bodyText": "Platform.isFxApplicationThread() is a boolean function that returns true if we are running in the fx application thread. So the condition here returns true if we are NOT running on the fx application thread", "url": "https://github.com/constellation-app/constellation/pull/885#discussion_r515726557", "createdAt": "2020-11-02T03:43:40Z", "author": {"login": "antares1470"}, "path": "CoreTableView/src/au/gov/asd/tac/constellation/views/tableview2/TableViewPane.java", "diffHunk": "@@ -1239,44 +1234,99 @@ public void updateSelection(final Graph graph, final TableViewState state) {\n                 if (!state.isSelectedOnly()) {\n                     final List<Integer> selectedIds = new ArrayList<>();\n                     final ReadableGraph readableGraph = graph.getReadableGraph();\n-                    try {\n-                        final boolean isVertex = state.getElementType() == GraphElementType.VERTEX;\n-                        final int selectedAttributeId = isVertex\n-                                ? VisualConcept.VertexAttribute.SELECTED.get(readableGraph)\n-                                : VisualConcept.TransactionAttribute.SELECTED.get(readableGraph);\n-                        final int elementCount = isVertex\n-                                ? readableGraph.getVertexCount()\n-                                : readableGraph.getTransactionCount();\n-                        for (int elementPosition = 0; elementPosition < elementCount; elementPosition++) {\n-                            final int elementId = isVertex\n-                                    ? readableGraph.getVertex(elementPosition)\n-                                    : readableGraph.getTransaction(elementPosition);\n-                            boolean isSelected = false;\n-                            if (selectedAttributeId != Graph.NOT_FOUND) {\n-                                isSelected = readableGraph.getBooleanValue(selectedAttributeId, elementId);\n-                            }\n-                            if (isSelected) {\n-                                selectedIds.add(elementId);\n-                            }\n-                        }\n-                    } finally {\n-                        readableGraph.release();\n-                    }\n+                    addToSelectedIds(selectedIds, readableGraph, state);\n \n                     // update table selection\n                     final int[] selectedIndices = selectedIds.stream().map(id -> elementIdToRowIndex.get(id))\n                             .map(row -> table.getItems().indexOf(row)).mapToInt(i -> i).toArray();\n-\n-                    Platform.runLater(() -> {\n+                    \n+                    Platform.runLater(() -> {                        \n                         selectedProperty.removeListener(tableSelectionListener);\n                         table.getSelectionModel().clearSelection();\n                         if (!selectedIds.isEmpty()) {\n                             table.getSelectionModel().selectIndices(selectedIndices[0], selectedIndices);\n                         }\n-                        selectedProperty.addListener(tableSelectionListener);\n+                        selectedProperty.addListener(tableSelectionListener);                            \n                     });\n                 }\n             }\n         }\n     }\n+       \n+    /**\n+     * A version of the updateSelection(Graph, TableViewState) function which is\n+     * to be run on the JavaFX Application Thread\n+     * \n+     * @param graph the graph to read selection from.\n+     * @param state the current table view state.\n+     */\n+    private void updateSelectionFromJAT(final Graph graph, final TableViewState state) {\n+        synchronized (LOCK) {\n+            if (graph != null && state != null) {\n+\n+                if (!Platform.isFxApplicationThread()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNzY0MQ=="}, "originalCommit": {"oid": "ee8630b73bbddbc60cfd949ac15f4c16faea4c3f"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczOTA0NA==", "bodyText": "Doh! Thanks, I totally misread it.", "url": "https://github.com/constellation-app/constellation/pull/885#discussion_r515739044", "createdAt": "2020-11-02T04:51:16Z", "author": {"login": "arcturus2"}, "path": "CoreTableView/src/au/gov/asd/tac/constellation/views/tableview2/TableViewPane.java", "diffHunk": "@@ -1239,44 +1234,99 @@ public void updateSelection(final Graph graph, final TableViewState state) {\n                 if (!state.isSelectedOnly()) {\n                     final List<Integer> selectedIds = new ArrayList<>();\n                     final ReadableGraph readableGraph = graph.getReadableGraph();\n-                    try {\n-                        final boolean isVertex = state.getElementType() == GraphElementType.VERTEX;\n-                        final int selectedAttributeId = isVertex\n-                                ? VisualConcept.VertexAttribute.SELECTED.get(readableGraph)\n-                                : VisualConcept.TransactionAttribute.SELECTED.get(readableGraph);\n-                        final int elementCount = isVertex\n-                                ? readableGraph.getVertexCount()\n-                                : readableGraph.getTransactionCount();\n-                        for (int elementPosition = 0; elementPosition < elementCount; elementPosition++) {\n-                            final int elementId = isVertex\n-                                    ? readableGraph.getVertex(elementPosition)\n-                                    : readableGraph.getTransaction(elementPosition);\n-                            boolean isSelected = false;\n-                            if (selectedAttributeId != Graph.NOT_FOUND) {\n-                                isSelected = readableGraph.getBooleanValue(selectedAttributeId, elementId);\n-                            }\n-                            if (isSelected) {\n-                                selectedIds.add(elementId);\n-                            }\n-                        }\n-                    } finally {\n-                        readableGraph.release();\n-                    }\n+                    addToSelectedIds(selectedIds, readableGraph, state);\n \n                     // update table selection\n                     final int[] selectedIndices = selectedIds.stream().map(id -> elementIdToRowIndex.get(id))\n                             .map(row -> table.getItems().indexOf(row)).mapToInt(i -> i).toArray();\n-\n-                    Platform.runLater(() -> {\n+                    \n+                    Platform.runLater(() -> {                        \n                         selectedProperty.removeListener(tableSelectionListener);\n                         table.getSelectionModel().clearSelection();\n                         if (!selectedIds.isEmpty()) {\n                             table.getSelectionModel().selectIndices(selectedIndices[0], selectedIndices);\n                         }\n-                        selectedProperty.addListener(tableSelectionListener);\n+                        selectedProperty.addListener(tableSelectionListener);                            \n                     });\n                 }\n             }\n         }\n     }\n+       \n+    /**\n+     * A version of the updateSelection(Graph, TableViewState) function which is\n+     * to be run on the JavaFX Application Thread\n+     * \n+     * @param graph the graph to read selection from.\n+     * @param state the current table view state.\n+     */\n+    private void updateSelectionFromJAT(final Graph graph, final TableViewState state) {\n+        synchronized (LOCK) {\n+            if (graph != null && state != null) {\n+\n+                if (!Platform.isFxApplicationThread()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNzY0MQ=="}, "originalCommit": {"oid": "ee8630b73bbddbc60cfd949ac15f4c16faea4c3f"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2133, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}