{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1OTIwNjk1", "number": 773, "title": "Split nodes plugin enhancement - Split nodes into same level", "bodyText": "Description of the Change\nA new option Split Nodes into same level is added in to the Split nodes plugin, enabling which will split nodes such that the new nodes are hanging off from the same parent node rather than from one of the new nodes.\n\nAlternate Designs\nN/A\n\nWhy Should This Be In Core?\nBetter UX\n\nBenefits\nBetter UX\n\nPossible Drawbacks\nN/A\n\nVerification Process\n\nOpen a graph and open Attribute Editor\nRenamed some nodes to a delimited string  such as 'abc;def;ghi'\nOpen up Data Access View and go to Split Nodes plugin\nSet the split character as ';' and select the  Split Nodes into same level option\nEnsure the renamed node/s is/are selected and run the plugin\nEnsure all the new nodes have the same nodes connected via similar transactions as the selected node\n\n\nApplicable Issues\n#743", "createdAt": "2020-08-11T07:24:59Z", "url": "https://github.com/constellation-app/constellation/pull/773", "merged": true, "mergeCommit": {"oid": "2aa76d9cfc21c01930a31622665b8fbb75df6d33"}, "closed": true, "closedAt": "2020-08-31T22:18:01Z", "author": {"login": "Auriga2"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc9w7ACgH2gAyNDY1OTIwNjk1OmVmYTAwNjM4YzdlZDdlNDUxMGZkNmQ1OGY1YjYzYTY0MWY5OTc0OWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdEaY81gFqTQ3ODk5NzcyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "efa00638c7ed7e4510fd6d58f5b63a641f99749d", "author": {"user": {"login": "Auriga2", "name": null}}, "url": "https://github.com/constellation-app/constellation/commit/efa00638c7ed7e4510fd6d58f5b63a641f99749d", "committedDate": "2020-08-11T06:35:21Z", "message": "Split node plugin split into same level\n\n(cherry picked from commit a5143e217e2be06300506f4a33b2d40add021c3b)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "author": {"user": {"login": "Auriga2", "name": null}}, "url": "https://github.com/constellation-app/constellation/commit/5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "committedDate": "2020-08-11T07:56:15Z", "message": "Fix code smells"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTk1Njgz", "url": "https://github.com/constellation-app/constellation/pull/773#pullrequestreview-467195683", "createdAt": "2020-08-13T23:29:39Z", "commit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMzoyOTozOVrOHAhBLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMzoyOTozOVrOHAhBLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwMzAyMw==", "bodyText": "A minor spelling typo, should be \"Copying\"", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470303023", "createdAt": "2020-08-13T23:29:39Z", "author": {"login": "arcturus2"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MjkzMDY0", "url": "https://github.com/constellation-app/constellation/pull/773#pullrequestreview-467293064", "createdAt": "2020-08-14T04:02:12Z", "commit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNDowMjoxMlrOHAmyfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNDoxNDoyNlrOHAm90Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NzU2Ng==", "bodyText": "I'm wondering if there is a better name and description for this? I'm not sure whether this makes sense to a user without already knowing what it does. I can't think of anything off the top of my head though", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470397566", "createdAt": "2020-08-14T04:02:12Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -94,6 +95,12 @@ public PluginParameters createParameters() {\n         split.setStringValue(null);\n         params.addParameter(split);\n \n+        final PluginParameter<BooleanParameterValue> splitIntoSameLevelParameter = BooleanParameterType.build(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID);\n+        splitIntoSameLevelParameter.setName(\"Split Nodes into same level\");\n+        splitIntoSameLevelParameter.setDescription(\"Choose to split Nodes hanging off from the same parent node rather than from one of the new nodes\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5ODEyOA==", "bodyText": "these 3 can be made final", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470398128", "createdAt": "2020-08-14T04:04:37Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5ODI4Mw==", "bodyText": "final", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470398283", "createdAt": "2020-08-14T04:05:16Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5ODYzMg==", "bodyText": "these 2 can be final", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470398632", "createdAt": "2020-08-14T04:06:40Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTE3OQ==", "bodyText": "if directed can't ever be true, it's probably better to remove this variable and just simply add false into the relevant function calls. That's just my personal opinion though", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399179", "createdAt": "2020-08-14T04:08:54Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTMyMg==", "bodyText": "final", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399322", "createdAt": "2020-08-14T04:09:29Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTQ0Nw==", "bodyText": "these 3 can be final", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399447", "createdAt": "2020-08-14T04:10:03Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTU4NQ==", "bodyText": "final", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399585", "createdAt": "2020-08-14T04:10:36Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTYyNw==", "bodyText": "these 2 can be final", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399627", "createdAt": "2020-08-14T04:10:48Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTY3Mw==", "bodyText": "final", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399673", "createdAt": "2020-08-14T04:10:59Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTc4NA==", "bodyText": "these 3 can be final", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399784", "createdAt": "2020-08-14T04:11:38Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);\n+            graph.setStringValue(transactionTypeAttributeId, newTransactionId, linkType);\n         }\n-        result.set(GraphRecordStoreUtilities.TRANSACTION + AnalyticConcept.TransactionAttribute.TYPE, linkType);\n+        return newVertexId;\n     }\n \n     @Override\n-    protected RecordStore query(final RecordStore query, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final RecordStore result = new GraphRecordStore();\n-\n+    public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n         final Map<String, PluginParameter<?>> splitParameters = parameters.getParameters();\n         final String character = splitParameters.get(SPLIT_PARAMETER_ID) != null && splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() != null ? splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() : \"\";\n         final ParameterValue transactionTypeChoice = splitParameters.get(TRANSACTION_TYPE_PARAMETER_ID).getSingleChoice();\n         final String linkType = transactionTypeChoice != null ? transactionTypeChoice.toString() : AnalyticConcept.TransactionType.CORRELATION.getName();\n         final boolean allOccurrences = splitParameters.get(ALL_OCCURRENCES_PARAMETER_ID).getBooleanValue();\n+        final boolean splitIntoSameLevel = splitParameters.get(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID).getBooleanValue();\n+\n+        int vertexSelectedAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.SELECTED.getName());\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        List<Integer> newVertices = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTkwMQ==", "bodyText": "final", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399901", "createdAt": "2020-08-14T04:12:05Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);\n+            graph.setStringValue(transactionTypeAttributeId, newTransactionId, linkType);\n         }\n-        result.set(GraphRecordStoreUtilities.TRANSACTION + AnalyticConcept.TransactionAttribute.TYPE, linkType);\n+        return newVertexId;\n     }\n \n     @Override\n-    protected RecordStore query(final RecordStore query, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final RecordStore result = new GraphRecordStore();\n-\n+    public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n         final Map<String, PluginParameter<?>> splitParameters = parameters.getParameters();\n         final String character = splitParameters.get(SPLIT_PARAMETER_ID) != null && splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() != null ? splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() : \"\";\n         final ParameterValue transactionTypeChoice = splitParameters.get(TRANSACTION_TYPE_PARAMETER_ID).getSingleChoice();\n         final String linkType = transactionTypeChoice != null ? transactionTypeChoice.toString() : AnalyticConcept.TransactionType.CORRELATION.getName();\n         final boolean allOccurrences = splitParameters.get(ALL_OCCURRENCES_PARAMETER_ID).getBooleanValue();\n+        final boolean splitIntoSameLevel = splitParameters.get(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID).getBooleanValue();\n+\n+        int vertexSelectedAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.SELECTED.getName());\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        List<Integer> newVertices = new ArrayList<>();\n+\n+        final int graphVertexCount = graph.getVertexCount();\n+        for (int position = 0; position < graphVertexCount; position++) {\n+            int currentVertexId = graph.getVertex(position);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwMDQ2NQ==", "bodyText": "given the use of substrings, I would probably just leave it as an array rather than converting it to a list", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470400465", "createdAt": "2020-08-14T04:14:26Z", "author": {"login": "antares1470"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);\n+            graph.setStringValue(transactionTypeAttributeId, newTransactionId, linkType);\n         }\n-        result.set(GraphRecordStoreUtilities.TRANSACTION + AnalyticConcept.TransactionAttribute.TYPE, linkType);\n+        return newVertexId;\n     }\n \n     @Override\n-    protected RecordStore query(final RecordStore query, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final RecordStore result = new GraphRecordStore();\n-\n+    public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n         final Map<String, PluginParameter<?>> splitParameters = parameters.getParameters();\n         final String character = splitParameters.get(SPLIT_PARAMETER_ID) != null && splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() != null ? splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() : \"\";\n         final ParameterValue transactionTypeChoice = splitParameters.get(TRANSACTION_TYPE_PARAMETER_ID).getSingleChoice();\n         final String linkType = transactionTypeChoice != null ? transactionTypeChoice.toString() : AnalyticConcept.TransactionType.CORRELATION.getName();\n         final boolean allOccurrences = splitParameters.get(ALL_OCCURRENCES_PARAMETER_ID).getBooleanValue();\n+        final boolean splitIntoSameLevel = splitParameters.get(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID).getBooleanValue();\n+\n+        int vertexSelectedAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.SELECTED.getName());\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        List<Integer> newVertices = new ArrayList<>();\n+\n+        final int graphVertexCount = graph.getVertexCount();\n+        for (int position = 0; position < graphVertexCount; position++) {\n+            int currentVertexId = graph.getVertex(position);\n+\n+            if (graph.getBooleanValue(vertexSelectedAttributeId, currentVertexId)) {\n+                final String identifier = graph.getStringValue(vertexIdentifierAttributeId, currentVertexId);\n+\n+                if (identifier != null && identifier.contains(character) && identifier.indexOf(character) < identifier.length() - character.length()) {\n+                    String leftNodeIdentifier = \"\";\n+                    if (allOccurrences) {\n+                        final List<String> substrings = new ArrayList<>(Arrays.asList(identifier.split(character)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 223}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTM1NTgz", "url": "https://github.com/constellation-app/constellation/pull/773#pullrequestreview-468935583", "createdAt": "2020-08-18T01:40:54Z", "commit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMTo0MDo1NFrOHCAWfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMjowOTozOFrOHCAzCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2NDk1OQ==", "bodyText": "This should probably be a SimpleEditPlugin as it's not performing a query.", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r471864959", "createdAt": "2020-08-18T01:40:54Z", "author": {"login": "cygnus-x-1"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -60,12 +63,10 @@\n     @ServiceProvider(service = DataAccessPlugin.class),\n     @ServiceProvider(service = Plugin.class)})\n @NbBundle.Messages(\"SplitNodesPlugin=Split Nodes Based on Identifier\")\n-public class SplitNodesPlugin extends RecordStoreQueryPlugin implements DataAccessPlugin {\n-\n-    private static final String SOURCE_ID = GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID;\n-    private static final String SOURCE_IDENTIFIER = GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER;\n+public class SplitNodesPlugin extends SimpleQueryPlugin implements DataAccessPlugin {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2Nzk2MA==", "bodyText": "RecordStoreQueryPlugin has this as an in-built feature - perhaps that could be moved down the stack to SimpleEditPlugin (the first plugin type which can edit a graph) so that it doesn't need to be implemented per plugin?", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r471867960", "createdAt": "2020-08-18T01:52:44Z", "author": {"login": "cygnus-x-1"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);\n+            graph.setStringValue(transactionTypeAttributeId, newTransactionId, linkType);\n         }\n-        result.set(GraphRecordStoreUtilities.TRANSACTION + AnalyticConcept.TransactionAttribute.TYPE, linkType);\n+        return newVertexId;\n     }\n \n     @Override\n-    protected RecordStore query(final RecordStore query, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final RecordStore result = new GraphRecordStore();\n-\n+    public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n         final Map<String, PluginParameter<?>> splitParameters = parameters.getParameters();\n         final String character = splitParameters.get(SPLIT_PARAMETER_ID) != null && splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() != null ? splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() : \"\";\n         final ParameterValue transactionTypeChoice = splitParameters.get(TRANSACTION_TYPE_PARAMETER_ID).getSingleChoice();\n         final String linkType = transactionTypeChoice != null ? transactionTypeChoice.toString() : AnalyticConcept.TransactionType.CORRELATION.getName();\n         final boolean allOccurrences = splitParameters.get(ALL_OCCURRENCES_PARAMETER_ID).getBooleanValue();\n+        final boolean splitIntoSameLevel = splitParameters.get(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID).getBooleanValue();\n+\n+        int vertexSelectedAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.SELECTED.getName());\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        List<Integer> newVertices = new ArrayList<>();\n+\n+        final int graphVertexCount = graph.getVertexCount();\n+        for (int position = 0; position < graphVertexCount; position++) {\n+            int currentVertexId = graph.getVertex(position);\n+\n+            if (graph.getBooleanValue(vertexSelectedAttributeId, currentVertexId)) {\n+                final String identifier = graph.getStringValue(vertexIdentifierAttributeId, currentVertexId);\n+\n+                if (identifier != null && identifier.contains(character) && identifier.indexOf(character) < identifier.length() - character.length()) {\n+                    String leftNodeIdentifier = \"\";\n+                    if (allOccurrences) {\n+                        final List<String> substrings = new ArrayList<>(Arrays.asList(identifier.split(character)));\n+                        leftNodeIdentifier = substrings.get(0);\n+                        for (int i = 1; i < substrings.size(); i++) {\n+                            newVertices.add(createNewNode(graph, position, substrings.get(i), linkType, splitIntoSameLevel));\n+                        }\n \n-        query.reset();\n-        while (query.next()) {\n-            final String identifier = query.get(SOURCE_IDENTIFIER);\n-            if (identifier != null && identifier.contains(character) && identifier.indexOf(character) < identifier.length() - character.length()) {\n-                if (allOccurrences) {\n-                    final List<String> substrings = new ArrayList<>(Arrays.asList(identifier.split(character)));\n-                    final String left = substrings.get(0);\n-                    for (int i = 1; i < substrings.size(); i++) {\n-                        final String right = substrings.get(i);\n-                        editResultStore(result, left, right, query, linkType);\n+                    } else {\n+                        final int i = identifier.indexOf(character);\n+                        leftNodeIdentifier = identifier.substring(0, i);\n+                        newVertices.add(createNewNode(graph, position, identifier.substring(i + 1), linkType, splitIntoSameLevel));\n                     }\n-                } else {\n-                    final int i = identifier.indexOf(character);\n-                    final String left = identifier.substring(0, i);\n-                    final String right = identifier.substring(i + 1);\n-                    editResultStore(result, left, right, query, linkType);\n+                    // Rename the selected node\n+                    graph.setStringValue(vertexIdentifierAttributeId, currentVertexId, leftNodeIdentifier);\n                 }\n             }\n         }\n+        if (!newVertices.isEmpty()) {\n+            // Reset the view\n+            graph.validateKey(GraphElementType.VERTEX, true);\n+            graph.validateKey(GraphElementType.TRANSACTION, true);\n \n-        return result;\n+            final PluginExecutor arrangement = completionArrangement();\n+            if (arrangement != null) {\n+                // run the arrangement\n+                final VertexListInclusionGraph vlGraph = new VertexListInclusionGraph(graph, AbstractInclusionGraph.Connections.NONE, newVertices);\n+                arrangement.executeNow(vlGraph.getInclusionGraph());\n+                vlGraph.retrieveCoords();\n+            }\n+\n+            PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n+            PluginExecutor.startWith(InteractiveGraphPluginRegistry.RESET_VIEW).executeNow(graph);\n+        }\n     }\n+\n+    public PluginExecutor completionArrangement() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2OTQ5Mw==", "bodyText": "This happens automatically on commit - so unless you're trying to catch it early for custom exception handling, this seems unnecessary.", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r471869493", "createdAt": "2020-08-18T01:58:51Z", "author": {"login": "cygnus-x-1"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);\n+            graph.setStringValue(transactionTypeAttributeId, newTransactionId, linkType);\n         }\n-        result.set(GraphRecordStoreUtilities.TRANSACTION + AnalyticConcept.TransactionAttribute.TYPE, linkType);\n+        return newVertexId;\n     }\n \n     @Override\n-    protected RecordStore query(final RecordStore query, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final RecordStore result = new GraphRecordStore();\n-\n+    public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n         final Map<String, PluginParameter<?>> splitParameters = parameters.getParameters();\n         final String character = splitParameters.get(SPLIT_PARAMETER_ID) != null && splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() != null ? splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() : \"\";\n         final ParameterValue transactionTypeChoice = splitParameters.get(TRANSACTION_TYPE_PARAMETER_ID).getSingleChoice();\n         final String linkType = transactionTypeChoice != null ? transactionTypeChoice.toString() : AnalyticConcept.TransactionType.CORRELATION.getName();\n         final boolean allOccurrences = splitParameters.get(ALL_OCCURRENCES_PARAMETER_ID).getBooleanValue();\n+        final boolean splitIntoSameLevel = splitParameters.get(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID).getBooleanValue();\n+\n+        int vertexSelectedAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.SELECTED.getName());\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        List<Integer> newVertices = new ArrayList<>();\n+\n+        final int graphVertexCount = graph.getVertexCount();\n+        for (int position = 0; position < graphVertexCount; position++) {\n+            int currentVertexId = graph.getVertex(position);\n+\n+            if (graph.getBooleanValue(vertexSelectedAttributeId, currentVertexId)) {\n+                final String identifier = graph.getStringValue(vertexIdentifierAttributeId, currentVertexId);\n+\n+                if (identifier != null && identifier.contains(character) && identifier.indexOf(character) < identifier.length() - character.length()) {\n+                    String leftNodeIdentifier = \"\";\n+                    if (allOccurrences) {\n+                        final List<String> substrings = new ArrayList<>(Arrays.asList(identifier.split(character)));\n+                        leftNodeIdentifier = substrings.get(0);\n+                        for (int i = 1; i < substrings.size(); i++) {\n+                            newVertices.add(createNewNode(graph, position, substrings.get(i), linkType, splitIntoSameLevel));\n+                        }\n \n-        query.reset();\n-        while (query.next()) {\n-            final String identifier = query.get(SOURCE_IDENTIFIER);\n-            if (identifier != null && identifier.contains(character) && identifier.indexOf(character) < identifier.length() - character.length()) {\n-                if (allOccurrences) {\n-                    final List<String> substrings = new ArrayList<>(Arrays.asList(identifier.split(character)));\n-                    final String left = substrings.get(0);\n-                    for (int i = 1; i < substrings.size(); i++) {\n-                        final String right = substrings.get(i);\n-                        editResultStore(result, left, right, query, linkType);\n+                    } else {\n+                        final int i = identifier.indexOf(character);\n+                        leftNodeIdentifier = identifier.substring(0, i);\n+                        newVertices.add(createNewNode(graph, position, identifier.substring(i + 1), linkType, splitIntoSameLevel));\n                     }\n-                } else {\n-                    final int i = identifier.indexOf(character);\n-                    final String left = identifier.substring(0, i);\n-                    final String right = identifier.substring(i + 1);\n-                    editResultStore(result, left, right, query, linkType);\n+                    // Rename the selected node\n+                    graph.setStringValue(vertexIdentifierAttributeId, currentVertexId, leftNodeIdentifier);\n                 }\n             }\n         }\n+        if (!newVertices.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg3MjI2NQ==", "bodyText": "I've looked over the code and still can't understand what this is supposed to be doing - could you explain it?", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r471872265", "createdAt": "2020-08-18T02:09:38Z", "author": {"login": "cygnus-x-1"}, "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -94,6 +95,12 @@ public PluginParameters createParameters() {\n         split.setStringValue(null);\n         params.addParameter(split);\n \n+        final PluginParameter<BooleanParameterValue> splitIntoSameLevelParameter = BooleanParameterType.build(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID);\n+        splitIntoSameLevelParameter.setName(\"Split Nodes into same level\");\n+        splitIntoSameLevelParameter.setDescription(\"Choose to split Nodes hanging off from the same parent node rather than from one of the new nodes\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NzU2Ng=="}, "originalCommit": {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8ff89050f896cbeee40b6e484a2be144294ef64", "author": {"user": {"login": "Auriga2", "name": null}}, "url": "https://github.com/constellation-app/constellation/commit/d8ff89050f896cbeee40b6e484a2be144294ef64", "committedDate": "2020-08-25T05:47:08Z", "message": "Improvements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTc0Njg5", "url": "https://github.com/constellation-app/constellation/pull/773#pullrequestreview-477174689", "createdAt": "2020-08-28T00:55:38Z", "commit": {"oid": "d8ff89050f896cbeee40b6e484a2be144294ef64"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc1df858d86f6a22cdb1f15cfd639d14c4ca33de", "author": {"user": {"login": "Auriga2", "name": null}}, "url": "https://github.com/constellation-app/constellation/commit/bc1df858d86f6a22cdb1f15cfd639d14c4ca33de", "committedDate": "2020-08-28T06:47:06Z", "message": "More improvements."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MjQ0Mzg3", "url": "https://github.com/constellation-app/constellation/pull/773#pullrequestreview-478244387", "createdAt": "2020-08-30T23:28:36Z", "commit": {"oid": "bc1df858d86f6a22cdb1f15cfd639d14c4ca33de"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQyMzoyODozNlrOHJmd3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQyMzoyODozNlrOHJmd3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgyOTQ2OQ==", "bodyText": "The first interpretation that came to mind when reading this was that it splits nodes that have duplicate transactions rather than duplicating the transactions of the split node for all the newly created nodes. Might be worth slightly altering the entry just to make the latter (correct) interpretation of the functionality clearer.", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r479829469", "createdAt": "2020-08-30T23:28:36Z", "author": {"login": "antares1470"}, "path": "CoreFunctionality/src/au/gov/asd/tac/constellation/functionality/whatsnew/whatsnew.txt", "diffHunk": "@@ -1,6 +1,9 @@\n == 3030-12-31 Getting Started\n <p>If you're new to CONSTELLATION, read the <a href=\"\" helpId=\"au.gov.asd.tac.constellation.functionality.introduction\">introduction</a>.</p>\n \n+== 2020-08-28 Split Nodes Plugin\n+<p>A new option is added to split nodes with duplicate transactions.</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc1df858d86f6a22cdb1f15cfd639d14c4ca33de"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21546c7c4eadfb41a465180df48c302ac89dd02e", "author": {"user": {"login": "Auriga2", "name": null}}, "url": "https://github.com/constellation-app/constellation/commit/21546c7c4eadfb41a465180df48c302ac89dd02e", "committedDate": "2020-08-31T03:59:34Z", "message": "Merge branch 'master' into feature/Split-Nodes-Plugin-Enhancement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fd8bf196ab6dc2a2edcf4d79c81e4580f3385f8", "author": {"user": {"login": "Auriga2", "name": null}}, "url": "https://github.com/constellation-app/constellation/commit/6fd8bf196ab6dc2a2edcf4d79c81e4580f3385f8", "committedDate": "2020-08-31T04:54:15Z", "message": "Improve what's new text"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MzEwMjQ5", "url": "https://github.com/constellation-app/constellation/pull/773#pullrequestreview-478310249", "createdAt": "2020-08-31T05:11:54Z", "commit": {"oid": "6fd8bf196ab6dc2a2edcf4d79c81e4580f3385f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4OTk3NzI3", "url": "https://github.com/constellation-app/constellation/pull/773#pullrequestreview-478997727", "createdAt": "2020-08-31T22:17:43Z", "commit": {"oid": "6fd8bf196ab6dc2a2edcf4d79c81e4580f3385f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3642, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}