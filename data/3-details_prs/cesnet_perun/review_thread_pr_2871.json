{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczODA1OTA5", "number": 2871, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMDo1MTo0MlrOEeQY0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwODoxOTozNlrOEfVlew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMTYxMjMyOnYy", "diffSide": "RIGHT", "path": "perun-rpc/src/main/java/cz/metacentrum/perun/rpc/methods/ServicesManagerMethod.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMDo1MTo0MlrOHJzxeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzozNTo1MFrOHK2lLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA0NzQ4MA==", "bodyText": "Not service but facility.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480047480", "createdAt": "2020-08-31T10:51:42Z", "author": {"login": "balcirakpeter"}, "path": "perun-rpc/src/main/java/cz/metacentrum/perun/rpc/methods/ServicesManagerMethod.java", "diffHunk": "@@ -525,6 +529,82 @@ public ServiceAttributes call(ApiCaller ac, Deserializer parms) throws PerunExce\n \t\t}\n \t},\n \n+\t/*#\n+\t * Generates hashed hierarchical data structure for given service and resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE0MjA2MA==", "bodyText": "Fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481142060", "createdAt": "2020-09-01T13:35:50Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-rpc/src/main/java/cz/metacentrum/perun/rpc/methods/ServicesManagerMethod.java", "diffHunk": "@@ -525,6 +529,82 @@ public ServiceAttributes call(ApiCaller ac, Deserializer parms) throws PerunExce\n \t\t}\n \t},\n \n+\t/*#\n+\t * Generates hashed hierarchical data structure for given service and resource.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA0NzQ4MA=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMTYxNDExOnYy", "diffSide": "RIGHT", "path": "perun-rpc/src/main/java/cz/metacentrum/perun/rpc/methods/ServicesManagerMethod.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMDo1MjoyMlrOHJzyeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzozNTo1NlrOHK2lXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA0NzczNg==", "bodyText": "Same as previous", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480047736", "createdAt": "2020-08-31T10:52:22Z", "author": {"login": "balcirakpeter"}, "path": "perun-rpc/src/main/java/cz/metacentrum/perun/rpc/methods/ServicesManagerMethod.java", "diffHunk": "@@ -525,6 +529,82 @@ public ServiceAttributes call(ApiCaller ac, Deserializer parms) throws PerunExce\n \t\t}\n \t},\n \n+\t/*#\n+\t * Generates hashed hierarchical data structure for given service and resource.\n+\t *\n+\t * @param service service\n+\t * @param facility facility\n+\t * @param filterExpiredMembers if the generator should filter expired members\n+\t * @return generated hashed data structure\n+\t * @throw FacilityNotExistsException if there is no such facility\n+\t * @throw ServiceNotExistsException if there is no such service\n+\t * @throw PrivilegeException insufficient permissions\n+\t */\n+\t/*#\n+\t * Generates hashed hierarchical data structure for given service and resource.\n+\t *\n+\t * @param service service\n+\t * @param facility facility\n+\t * @return generated hashed data structure\n+\t * @throw FacilityNotExistsException if there is no such facility\n+\t * @throw ServiceNotExistsException if there is no such service\n+\t * @throw PrivilegeException insufficient permissions\n+\t */\n+\tgetHashedHierarchicalData {\n+\t\t@Override\n+\t\tpublic HashedGenData call(ApiCaller ac, Deserializer parms) throws PerunException {\n+\t\t\tif (parms.contains(\"filterExpiredMembers\")) {\n+\t\t\t\treturn ac.getServicesManager().getHashedHierarchicalData(ac.getSession(),\n+\t\t\t\t\t\tac.getServiceById(parms.readInt(\"service\")),\n+\t\t\t\t\t\tac.getFacilityById(parms.readInt(\"facility\")),\n+\t\t\t\t\t\tparms.readBoolean(\"filterExpiredMembers\"));\n+\t\t\t} else {\n+\t\t\t\treturn ac.getServicesManager().getHashedHierarchicalData(ac.getSession(),\n+\t\t\t\t\t\tac.getServiceById(parms.readInt(\"service\")),\n+\t\t\t\t\t\tac.getFacilityById(parms.readInt(\"facility\")),\n+\t\t\t\t\t\tfalse);\n+\t\t\t}\n+\t\t}\n+\t},\n+\n+\t/*#\n+\t * Generates hashed data with group structure for given service and resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE0MjEwOQ==", "bodyText": "Fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481142109", "createdAt": "2020-09-01T13:35:56Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-rpc/src/main/java/cz/metacentrum/perun/rpc/methods/ServicesManagerMethod.java", "diffHunk": "@@ -525,6 +529,82 @@ public ServiceAttributes call(ApiCaller ac, Deserializer parms) throws PerunExce\n \t\t}\n \t},\n \n+\t/*#\n+\t * Generates hashed hierarchical data structure for given service and resource.\n+\t *\n+\t * @param service service\n+\t * @param facility facility\n+\t * @param filterExpiredMembers if the generator should filter expired members\n+\t * @return generated hashed data structure\n+\t * @throw FacilityNotExistsException if there is no such facility\n+\t * @throw ServiceNotExistsException if there is no such service\n+\t * @throw PrivilegeException insufficient permissions\n+\t */\n+\t/*#\n+\t * Generates hashed hierarchical data structure for given service and resource.\n+\t *\n+\t * @param service service\n+\t * @param facility facility\n+\t * @return generated hashed data structure\n+\t * @throw FacilityNotExistsException if there is no such facility\n+\t * @throw ServiceNotExistsException if there is no such service\n+\t * @throw PrivilegeException insufficient permissions\n+\t */\n+\tgetHashedHierarchicalData {\n+\t\t@Override\n+\t\tpublic HashedGenData call(ApiCaller ac, Deserializer parms) throws PerunException {\n+\t\t\tif (parms.contains(\"filterExpiredMembers\")) {\n+\t\t\t\treturn ac.getServicesManager().getHashedHierarchicalData(ac.getSession(),\n+\t\t\t\t\t\tac.getServiceById(parms.readInt(\"service\")),\n+\t\t\t\t\t\tac.getFacilityById(parms.readInt(\"facility\")),\n+\t\t\t\t\t\tparms.readBoolean(\"filterExpiredMembers\"));\n+\t\t\t} else {\n+\t\t\t\treturn ac.getServicesManager().getHashedHierarchicalData(ac.getSession(),\n+\t\t\t\t\t\tac.getServiceById(parms.readInt(\"service\")),\n+\t\t\t\t\t\tac.getFacilityById(parms.readInt(\"facility\")),\n+\t\t\t\t\t\tfalse);\n+\t\t\t}\n+\t\t}\n+\t},\n+\n+\t/*#\n+\t * Generates hashed data with group structure for given service and resource.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA0NzczNg=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMTczMDAxOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/bl/ServicesManagerBl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMToyMTo1OVrOHJ05Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzozNjowMVrOHK2low==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA2NTc5OA==", "bodyText": "service and facility", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480065798", "createdAt": "2020-08-31T11:21:59Z", "author": {"login": "balcirakpeter"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/bl/ServicesManagerBl.java", "diffHunk": "@@ -333,6 +334,28 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE0MjE3OQ==", "bodyText": "Fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481142179", "createdAt": "2020-09-01T13:36:01Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/bl/ServicesManagerBl.java", "diffHunk": "@@ -333,6 +334,28 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA2NTc5OA=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMTczMDY5OnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/bl/ServicesManagerBl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMToyMjoxMVrOHJ05YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzozNjowNlrOHK2l2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA2NTg4OQ==", "bodyText": "same as above", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480065889", "createdAt": "2020-08-31T11:22:11Z", "author": {"login": "balcirakpeter"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/bl/ServicesManagerBl.java", "diffHunk": "@@ -333,6 +334,28 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.\n+\t *\n+\t * @param perunSession perun session\n+\t * @param service service\n+\t * @param facility facility\n+\t * @param filterExpiredMembers if the generator should filter expired members\n+\t * @return generated hashed data structure\n+\t */\n+\tHashedGenData getHashedHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);\n+\n+\t/**\n+\t * Generates hashed data with group structure for given service and resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE0MjIzMw==", "bodyText": "Fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481142233", "createdAt": "2020-09-01T13:36:06Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/bl/ServicesManagerBl.java", "diffHunk": "@@ -333,6 +334,28 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.\n+\t *\n+\t * @param perunSession perun session\n+\t * @param service service\n+\t * @param facility facility\n+\t * @param filterExpiredMembers if the generator should filter expired members\n+\t * @return generated hashed data structure\n+\t */\n+\tHashedGenData getHashedHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);\n+\n+\t/**\n+\t * Generates hashed data with group structure for given service and resource.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA2NTg4OQ=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMTczNDk0OnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/api/ServicesManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMToyMzozNlrOHJ072Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzozNjoxMFrOHK2mAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA2NjUyMQ==", "bodyText": "service and facility", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480066521", "createdAt": "2020-08-31T11:23:36Z", "author": {"login": "balcirakpeter"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/api/ServicesManager.java", "diffHunk": "@@ -375,6 +375,34 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers) throws FacilityNotExistsException, ServiceNotExistsException, PrivilegeException;\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE0MjI3NA==", "bodyText": "Fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481142274", "createdAt": "2020-09-01T13:36:10Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/api/ServicesManager.java", "diffHunk": "@@ -375,6 +375,34 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers) throws FacilityNotExistsException, ServiceNotExistsException, PrivilegeException;\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA2NjUyMQ=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMTczNTQzOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/api/ServicesManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMToyMzo0NlrOHJ08Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzozNjoxNlrOHK2mUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA2NjU5MQ==", "bodyText": "same as above", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480066591", "createdAt": "2020-08-31T11:23:46Z", "author": {"login": "balcirakpeter"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/api/ServicesManager.java", "diffHunk": "@@ -375,6 +375,34 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers) throws FacilityNotExistsException, ServiceNotExistsException, PrivilegeException;\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.\n+\t *\n+\t * @param perunSession perun session\n+\t * @param service service\n+\t * @param facility facility\n+\t * @param filterExpiredMembers if the generator should filter expired members\n+\t * @return generated hashed data structure\n+\t * @throws FacilityNotExistsException if there is no such facility\n+\t * @throws ServiceNotExistsException if there is no such service\n+\t * @throws PrivilegeException insufficient permissions\n+\t */\n+\tHashedGenData getHashedHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers) throws FacilityNotExistsException, ServiceNotExistsException, PrivilegeException;\n+\n+\t/**\n+\t * Generates hashed data with group structure for given service and resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE0MjM1Mw==", "bodyText": "Fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481142353", "createdAt": "2020-09-01T13:36:16Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/api/ServicesManager.java", "diffHunk": "@@ -375,6 +375,34 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers) throws FacilityNotExistsException, ServiceNotExistsException, PrivilegeException;\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.\n+\t *\n+\t * @param perunSession perun session\n+\t * @param service service\n+\t * @param facility facility\n+\t * @param filterExpiredMembers if the generator should filter expired members\n+\t * @return generated hashed data structure\n+\t * @throws FacilityNotExistsException if there is no such facility\n+\t * @throws ServiceNotExistsException if there is no such service\n+\t * @throws PrivilegeException insufficient permissions\n+\t */\n+\tHashedGenData getHashedHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers) throws FacilityNotExistsException, ServiceNotExistsException, PrivilegeException;\n+\n+\t/**\n+\t * Generates hashed data with group structure for given service and resource.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA2NjU5MQ=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjAwNzM2OnYy", "diffSide": "RIGHT", "path": "perun-base/src/main/java/cz/metacentrum/perun/core/api/GenDataNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMjo1MDoyN1rOHJ3dbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNToyOVrOHLr9RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEwNzg4Nw==", "bodyText": "Is there any reason to use just 1 letter from the whole name?\nH - Hashes\nC - Children\nM - Members", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480107887", "createdAt": "2020-08-31T12:50:27Z", "author": {"login": "stavamichal"}, "path": "perun-base/src/main/java/cz/metacentrum/perun/core/api/GenDataNode.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package cz.metacentrum.perun.core.api;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataNode {\n+\n+\tprivate final List<String> hashes;\n+\tprivate final List<GenDataNode> children;\n+\tprivate final List<GenMemberDataNode> members;\n+\n+\tprivate GenDataNode(List<String> hashes, List<GenDataNode> children, List<GenMemberDataNode> members) {\n+\t\tthis.hashes = hashes;\n+\t\tthis.children = children;\n+\t\tthis.members = members;\n+\t}\n+\n+\tpublic List<String> getH() {\n+\t\treturn Collections.unmodifiableList(hashes);\n+\t}\n+\n+\tpublic List<GenDataNode> getC() {\n+\t\treturn Collections.unmodifiableList(children);\n+\t}\n+\n+\tpublic List<GenMemberDataNode> getM() {\n+\t\treturn Collections.unmodifiableList(members);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNjU4MA==", "bodyText": "This was done so the generated JSON file is as smallest as possible. But it's true that the getter doesn't need to be named like it. I have replaced the names in the getters with their full names and added annotations to make sure the generated file contains only the one letter keys.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482016580", "createdAt": "2020-09-02T12:05:29Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-base/src/main/java/cz/metacentrum/perun/core/api/GenDataNode.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package cz.metacentrum.perun.core.api;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataNode {\n+\n+\tprivate final List<String> hashes;\n+\tprivate final List<GenDataNode> children;\n+\tprivate final List<GenMemberDataNode> members;\n+\n+\tprivate GenDataNode(List<String> hashes, List<GenDataNode> children, List<GenMemberDataNode> members) {\n+\t\tthis.hashes = hashes;\n+\t\tthis.children = children;\n+\t\tthis.members = members;\n+\t}\n+\n+\tpublic List<String> getH() {\n+\t\treturn Collections.unmodifiableList(hashes);\n+\t}\n+\n+\tpublic List<GenDataNode> getC() {\n+\t\treturn Collections.unmodifiableList(children);\n+\t}\n+\n+\tpublic List<GenMemberDataNode> getM() {\n+\t\treturn Collections.unmodifiableList(members);\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEwNzg4Nw=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjAxNTMwOnYy", "diffSide": "RIGHT", "path": "perun-base/src/main/java/cz/metacentrum/perun/core/api/GenDataNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMjo1MjozOVrOHJ3iAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNTozN1rOHLr9qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEwOTA1OQ==", "bodyText": "For all new classes, you should add some Javadoc about usage.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480109059", "createdAt": "2020-08-31T12:52:39Z", "author": {"login": "stavamichal"}, "path": "perun-base/src/main/java/cz/metacentrum/perun/core/api/GenDataNode.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package cz.metacentrum.perun.core.api;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNjY4Mg==", "bodyText": "Added.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482016682", "createdAt": "2020-09-02T12:05:37Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-base/src/main/java/cz/metacentrum/perun/core/api/GenDataNode.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package cz.metacentrum.perun.core.api;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEwOTA1OQ=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjA0MjE1OnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/api/ServicesManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMjo1OTo1NVrOHJ3x2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNjozMlrOHLr_vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDExMzExMg==", "bodyText": "Because the structure of every \"getData\" method is different, you need to define it more specifically. For example, you have different objects on different levels in the hierarchy, somewhere you are using groups, somewhere not. We need to know this information without reading the code itself. I would add this information for both methods to the entry layer, RPC, and open API.\nFor the business layer, you can use a link to the entry layer.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480113112", "createdAt": "2020-08-31T12:59:55Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/api/ServicesManager.java", "diffHunk": "@@ -375,6 +375,34 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers) throws FacilityNotExistsException, ServiceNotExistsException, PrivilegeException;\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzIxMw==", "bodyText": "I have added the javadoc to all places, except OpenAPI. I don't think it is necessary right now.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017213", "createdAt": "2020-09-02T12:06:32Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/api/ServicesManager.java", "diffHunk": "@@ -375,6 +375,34 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers) throws FacilityNotExistsException, ServiceNotExistsException, PrivilegeException;\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDExMzExMg=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjA5NTQzOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/blImpl/AttributesManagerBlImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzoxNDozOFrOHJ4R8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNjo0MFrOHLsAAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMTMzMA==", "bodyText": "Please add tests for both these methods.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480121330", "createdAt": "2020-08-31T13:14:38Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/blImpl/AttributesManagerBlImpl.java", "diffHunk": "@@ -3115,6 +3126,11 @@ public void deleteAttribute(PerunSession sess, AttributeDefinition attributeDefi\n \t\treturn getAttributesManagerImpl().getRequiredAttributes(sess, service, group);\n \t}\n \n+\t@Override\n+\tpublic Map<Group, List<Attribute>> getRequiredAttributesForGroups(PerunSession sess, Service service, List<Group> groups) {\n+\t\treturn getAttributesManagerImpl().getRequiredAttributesForGroups(sess, service, groups);\n+\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzI4MA==", "bodyText": "Tests created.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017280", "createdAt": "2020-09-02T12:06:40Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/blImpl/AttributesManagerBlImpl.java", "diffHunk": "@@ -3115,6 +3126,11 @@ public void deleteAttribute(PerunSession sess, AttributeDefinition attributeDefi\n \t\treturn getAttributesManagerImpl().getRequiredAttributes(sess, service, group);\n \t}\n \n+\t@Override\n+\tpublic Map<Group, List<Attribute>> getRequiredAttributesForGroups(PerunSession sess, Service service, List<Group> groups) {\n+\t\treturn getAttributesManagerImpl().getRequiredAttributesForGroups(sess, service, groups);\n+\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMTMzMA=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjA5ODg2OnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/bl/ServicesManagerBl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzoxNTozMlrOHJ4T9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNjo1MFrOHLsAag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMTg0NA==", "bodyText": "Should you also add tests for both these methods? To at least test expected attributes are there and expected objects are in the structure?", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480121844", "createdAt": "2020-08-31T13:15:32Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/bl/ServicesManagerBl.java", "diffHunk": "@@ -333,6 +334,28 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.\n+\t *\n+\t * @param perunSession perun session\n+\t * @param service service\n+\t * @param facility facility\n+\t * @param filterExpiredMembers if the generator should filter expired members\n+\t * @return generated hashed data structure\n+\t */\n+\tHashedGenData getHashedHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);\n+\n+\t/**\n+\t * Generates hashed data with group structure for given service and resource.\n+\t *\n+\t * @param perunSession perun session\n+\t * @param service service\n+\t * @param facility facility\n+\t * @param filterExpiredMembers if the generator should filter expired members\n+\t * @return generated hashed data structure\n+\t */\n+\tHashedGenData getHashedDataWithGroups(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzM4Ng==", "bodyText": "Tests created.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017386", "createdAt": "2020-09-02T12:06:50Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/bl/ServicesManagerBl.java", "diffHunk": "@@ -333,6 +334,28 @@\n \t */\n \tServiceAttributes getHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);\n \n+\t/**\n+\t * Generates hashed hierarchical data structure for given service and resource.\n+\t *\n+\t * @param perunSession perun session\n+\t * @param service service\n+\t * @param facility facility\n+\t * @param filterExpiredMembers if the generator should filter expired members\n+\t * @return generated hashed data structure\n+\t */\n+\tHashedGenData getHashedHierarchicalData(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);\n+\n+\t/**\n+\t * Generates hashed data with group structure for given service and resource.\n+\t *\n+\t * @param perunSession perun session\n+\t * @param service service\n+\t * @param facility facility\n+\t * @param filterExpiredMembers if the generator should filter expired members\n+\t * @return generated hashed data structure\n+\t */\n+\tHashedGenData getHashedDataWithGroups(PerunSession perunSession, Service service, Facility facility, boolean filterExpiredMembers);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMTg0NA=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjEwNTAwOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/impl/AttributesManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzoxNjozNFrOHJ4XnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzozNjoyN1rOHK2myg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMjc4MQ==", "bodyText": "This looks weird", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480122781", "createdAt": "2020-08-31T13:16:34Z", "author": {"login": "balcirakpeter"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/impl/AttributesManagerImpl.java", "diffHunk": "@@ -2775,6 +2901,31 @@ public void deleteAllAttributeAuthz(PerunSession sess, AttributeDefinition attri\n \t\treturn getRequiredAttributes(sess, Collections.singletonList(service), group);\n \t}\n \n+\t@Override\n+\tpublic Map<Group, List<Attribute>> getRequiredAttributesForGroups(PerunSession sess, Service service, List<Group> groups) {\n+\t\ttry {\n+\t\t\treturn jdbc.execute(\"SELECT \" + getAttributeMappingSelectQuery(\"grp\") + \", groups.id FROM attr_names \" +\n+\t\t\t\t\t\"JOIN service_required_attrs ON attr_names.id=service_required_attrs.attr_id AND service_required_attrs.service_id=? \" +\n+\t\t\t\t\t\"JOIN groups ON groups.id \" + Compatibility.getStructureForInClause() +\n+\t\t\t\t\t\"LEFT JOIN group_attr_values grp ON attr_names.id=grp.attr_id \" +\n+\t\t\t\t\t\"AND grp.group_id=groups.id WHERE namespace IN (?,?,?,?)\",\n+\t\t\t\t\t(PreparedStatementCallback<HashMap<Group, List<Attribute>>>) preparedStatement -> {\n+\t\t\t\tArray sqlArray = DatabaseManagerBl.prepareSQLArrayOfNumbers(groups, preparedStatement);\n+\t\t\t\tpreparedStatement.setInt(1, service.getId());\n+\t\t\t\tpreparedStatement.setArray(2, sqlArray);\n+\t\t\t\tpreparedStatement.setString(3, AttributesManager.NS_GROUP_ATTR_CORE);\n+\t\t\t\tpreparedStatement.setString(4, AttributesManager.NS_GROUP_ATTR_DEF);\n+\t\t\t\tpreparedStatement.setString(5, AttributesManager.NS_GROUP_ATTR_OPT);\n+\t\t\t\tpreparedStatement.setString(6, AttributesManager.NS_GROUP_ATTR_VIRT);\n+\t\t\t\tGroupAttributeExtractor groupAttributeExtractor = new GroupAttributeExtractor(sess, this, groups);\n+\t\t\t\treturn groupAttributeExtractor.extractData(preparedStatement.executeQuery());\n+\t\t\t});\n+\t\t} catch (InternalErrorException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE0MjQ3NA==", "bodyText": "Removed the try block completely.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481142474", "createdAt": "2020-09-01T13:36:27Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/impl/AttributesManagerImpl.java", "diffHunk": "@@ -2775,6 +2901,31 @@ public void deleteAllAttributeAuthz(PerunSession sess, AttributeDefinition attri\n \t\treturn getRequiredAttributes(sess, Collections.singletonList(service), group);\n \t}\n \n+\t@Override\n+\tpublic Map<Group, List<Attribute>> getRequiredAttributesForGroups(PerunSession sess, Service service, List<Group> groups) {\n+\t\ttry {\n+\t\t\treturn jdbc.execute(\"SELECT \" + getAttributeMappingSelectQuery(\"grp\") + \", groups.id FROM attr_names \" +\n+\t\t\t\t\t\"JOIN service_required_attrs ON attr_names.id=service_required_attrs.attr_id AND service_required_attrs.service_id=? \" +\n+\t\t\t\t\t\"JOIN groups ON groups.id \" + Compatibility.getStructureForInClause() +\n+\t\t\t\t\t\"LEFT JOIN group_attr_values grp ON attr_names.id=grp.attr_id \" +\n+\t\t\t\t\t\"AND grp.group_id=groups.id WHERE namespace IN (?,?,?,?)\",\n+\t\t\t\t\t(PreparedStatementCallback<HashMap<Group, List<Attribute>>>) preparedStatement -> {\n+\t\t\t\tArray sqlArray = DatabaseManagerBl.prepareSQLArrayOfNumbers(groups, preparedStatement);\n+\t\t\t\tpreparedStatement.setInt(1, service.getId());\n+\t\t\t\tpreparedStatement.setArray(2, sqlArray);\n+\t\t\t\tpreparedStatement.setString(3, AttributesManager.NS_GROUP_ATTR_CORE);\n+\t\t\t\tpreparedStatement.setString(4, AttributesManager.NS_GROUP_ATTR_DEF);\n+\t\t\t\tpreparedStatement.setString(5, AttributesManager.NS_GROUP_ATTR_OPT);\n+\t\t\t\tpreparedStatement.setString(6, AttributesManager.NS_GROUP_ATTR_VIRT);\n+\t\t\t\tGroupAttributeExtractor groupAttributeExtractor = new GroupAttributeExtractor(sess, this, groups);\n+\t\t\t\treturn groupAttributeExtractor.extractData(preparedStatement.executeQuery());\n+\t\t\t});\n+\t\t} catch (InternalErrorException ex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMjc4MQ=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjE2MTIwOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/impl/AttributesManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzoyOTozNlrOHJ45pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNjo1NlrOHLsAlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzMTQ5NA==", "bodyText": "We don't need to throw InternalErrorException any more. You can skip this part.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480131494", "createdAt": "2020-08-31T13:29:36Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/impl/AttributesManagerImpl.java", "diffHunk": "@@ -2440,6 +2441,30 @@ public void deleteAllAttributeAuthz(PerunSession sess, AttributeDefinition attri\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic Map<Member, List<Attribute>> getRequiredAttributes(PerunSession sess, Service service, List<Member> members, Group group) {\n+\t\ttry {\n+\t\t\treturn jdbc.execute(\"SELECT \" + getAttributeMappingSelectQuery(\"mem_gr\") + \", members.id FROM attr_names \" +\n+\t\t\t\t\t\"JOIN service_required_attrs ON attr_names.id=service_required_attrs.attr_id AND service_required_attrs.service_id=? \" +\n+\t\t\t\t\t\"JOIN members ON members.id \" + Compatibility.getStructureForInClause() +\n+\t\t\t\t\t\"LEFT JOIN member_group_attr_values mem_gr ON attr_names.id=mem_gr.attr_id AND group_id=? AND member_id=members.id \" +\n+\t\t\t\t\t\"WHERE namespace IN (?,?,?)\", (PreparedStatementCallback<HashMap<Member, List<Attribute>>>) preparedStatement -> {\n+\t\t\t\tArray sqlArray = DatabaseManagerBl.prepareSQLArrayOfNumbers(members, preparedStatement);\n+\t\t\t\tpreparedStatement.setInt(1, service.getId());\n+\t\t\t\tpreparedStatement.setArray(2, sqlArray);\n+\t\t\t\tpreparedStatement.setInt(3, group.getId());\n+\t\t\t\tpreparedStatement.setString(4, AttributesManager.NS_MEMBER_GROUP_ATTR_DEF);\n+\t\t\t\tpreparedStatement.setString(5, AttributesManager.NS_MEMBER_GROUP_ATTR_OPT);\n+\t\t\t\tpreparedStatement.setString(6, AttributesManager.NS_MEMBER_GROUP_ATTR_VIRT);\n+\t\t\t\tMemberGroupAttributeExtractor memberAttributeExtractor = new MemberGroupAttributeExtractor(sess, this, members, group);\n+\t\t\t\treturn memberAttributeExtractor.extractData(preparedStatement.executeQuery());\n+\t\t\t});\n+\t\t} catch (InternalErrorException ex) {\n+\t\t\t//Finding or invoking oracle array method was unsuccessful\n+\t\t\tthrow new InternalErrorException(ex);\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzQyOQ==", "bodyText": "Removed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017429", "createdAt": "2020-09-02T12:06:56Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/impl/AttributesManagerImpl.java", "diffHunk": "@@ -2440,6 +2441,30 @@ public void deleteAllAttributeAuthz(PerunSession sess, AttributeDefinition attri\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic Map<Member, List<Attribute>> getRequiredAttributes(PerunSession sess, Service service, List<Member> members, Group group) {\n+\t\ttry {\n+\t\t\treturn jdbc.execute(\"SELECT \" + getAttributeMappingSelectQuery(\"mem_gr\") + \", members.id FROM attr_names \" +\n+\t\t\t\t\t\"JOIN service_required_attrs ON attr_names.id=service_required_attrs.attr_id AND service_required_attrs.service_id=? \" +\n+\t\t\t\t\t\"JOIN members ON members.id \" + Compatibility.getStructureForInClause() +\n+\t\t\t\t\t\"LEFT JOIN member_group_attr_values mem_gr ON attr_names.id=mem_gr.attr_id AND group_id=? AND member_id=members.id \" +\n+\t\t\t\t\t\"WHERE namespace IN (?,?,?)\", (PreparedStatementCallback<HashMap<Member, List<Attribute>>>) preparedStatement -> {\n+\t\t\t\tArray sqlArray = DatabaseManagerBl.prepareSQLArrayOfNumbers(members, preparedStatement);\n+\t\t\t\tpreparedStatement.setInt(1, service.getId());\n+\t\t\t\tpreparedStatement.setArray(2, sqlArray);\n+\t\t\t\tpreparedStatement.setInt(3, group.getId());\n+\t\t\t\tpreparedStatement.setString(4, AttributesManager.NS_MEMBER_GROUP_ATTR_DEF);\n+\t\t\t\tpreparedStatement.setString(5, AttributesManager.NS_MEMBER_GROUP_ATTR_OPT);\n+\t\t\t\tpreparedStatement.setString(6, AttributesManager.NS_MEMBER_GROUP_ATTR_VIRT);\n+\t\t\t\tMemberGroupAttributeExtractor memberAttributeExtractor = new MemberGroupAttributeExtractor(sess, this, members, group);\n+\t\t\t\treturn memberAttributeExtractor.extractData(preparedStatement.executeQuery());\n+\t\t\t});\n+\t\t} catch (InternalErrorException ex) {\n+\t\t\t//Finding or invoking oracle array method was unsuccessful\n+\t\t\tthrow new InternalErrorException(ex);\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzMTQ5NA=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjE2MTgwOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/impl/AttributesManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzoyOTo0NFrOHJ459w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNzowMVrOHLsAsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzMTU3NQ==", "bodyText": "We don't need to throw InternalErrorException any more. You can skip this part.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480131575", "createdAt": "2020-08-31T13:29:44Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/impl/AttributesManagerImpl.java", "diffHunk": "@@ -2775,6 +2901,31 @@ public void deleteAllAttributeAuthz(PerunSession sess, AttributeDefinition attri\n \t\treturn getRequiredAttributes(sess, Collections.singletonList(service), group);\n \t}\n \n+\t@Override\n+\tpublic Map<Group, List<Attribute>> getRequiredAttributesForGroups(PerunSession sess, Service service, List<Group> groups) {\n+\t\ttry {\n+\t\t\treturn jdbc.execute(\"SELECT \" + getAttributeMappingSelectQuery(\"grp\") + \", groups.id FROM attr_names \" +\n+\t\t\t\t\t\"JOIN service_required_attrs ON attr_names.id=service_required_attrs.attr_id AND service_required_attrs.service_id=? \" +\n+\t\t\t\t\t\"JOIN groups ON groups.id \" + Compatibility.getStructureForInClause() +\n+\t\t\t\t\t\"LEFT JOIN group_attr_values grp ON attr_names.id=grp.attr_id \" +\n+\t\t\t\t\t\"AND grp.group_id=groups.id WHERE namespace IN (?,?,?,?)\",\n+\t\t\t\t\t(PreparedStatementCallback<HashMap<Group, List<Attribute>>>) preparedStatement -> {\n+\t\t\t\tArray sqlArray = DatabaseManagerBl.prepareSQLArrayOfNumbers(groups, preparedStatement);\n+\t\t\t\tpreparedStatement.setInt(1, service.getId());\n+\t\t\t\tpreparedStatement.setArray(2, sqlArray);\n+\t\t\t\tpreparedStatement.setString(3, AttributesManager.NS_GROUP_ATTR_CORE);\n+\t\t\t\tpreparedStatement.setString(4, AttributesManager.NS_GROUP_ATTR_DEF);\n+\t\t\t\tpreparedStatement.setString(5, AttributesManager.NS_GROUP_ATTR_OPT);\n+\t\t\t\tpreparedStatement.setString(6, AttributesManager.NS_GROUP_ATTR_VIRT);\n+\t\t\t\tGroupAttributeExtractor groupAttributeExtractor = new GroupAttributeExtractor(sess, this, groups);\n+\t\t\t\treturn groupAttributeExtractor.extractData(preparedStatement.executeQuery());\n+\t\t\t});\n+\t\t} catch (InternalErrorException ex) {\n+\t\t\t//Finding or invoking oracle array method was unsuccessful\n+\t\t\tthrow new InternalErrorException(ex);\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzQ1OQ==", "bodyText": "Removed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017459", "createdAt": "2020-09-02T12:07:01Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/impl/AttributesManagerImpl.java", "diffHunk": "@@ -2775,6 +2901,31 @@ public void deleteAllAttributeAuthz(PerunSession sess, AttributeDefinition attri\n \t\treturn getRequiredAttributes(sess, Collections.singletonList(service), group);\n \t}\n \n+\t@Override\n+\tpublic Map<Group, List<Attribute>> getRequiredAttributesForGroups(PerunSession sess, Service service, List<Group> groups) {\n+\t\ttry {\n+\t\t\treturn jdbc.execute(\"SELECT \" + getAttributeMappingSelectQuery(\"grp\") + \", groups.id FROM attr_names \" +\n+\t\t\t\t\t\"JOIN service_required_attrs ON attr_names.id=service_required_attrs.attr_id AND service_required_attrs.service_id=? \" +\n+\t\t\t\t\t\"JOIN groups ON groups.id \" + Compatibility.getStructureForInClause() +\n+\t\t\t\t\t\"LEFT JOIN group_attr_values grp ON attr_names.id=grp.attr_id \" +\n+\t\t\t\t\t\"AND grp.group_id=groups.id WHERE namespace IN (?,?,?,?)\",\n+\t\t\t\t\t(PreparedStatementCallback<HashMap<Group, List<Attribute>>>) preparedStatement -> {\n+\t\t\t\tArray sqlArray = DatabaseManagerBl.prepareSQLArrayOfNumbers(groups, preparedStatement);\n+\t\t\t\tpreparedStatement.setInt(1, service.getId());\n+\t\t\t\tpreparedStatement.setArray(2, sqlArray);\n+\t\t\t\tpreparedStatement.setString(3, AttributesManager.NS_GROUP_ATTR_CORE);\n+\t\t\t\tpreparedStatement.setString(4, AttributesManager.NS_GROUP_ATTR_DEF);\n+\t\t\t\tpreparedStatement.setString(5, AttributesManager.NS_GROUP_ATTR_OPT);\n+\t\t\t\tpreparedStatement.setString(6, AttributesManager.NS_GROUP_ATTR_VIRT);\n+\t\t\t\tGroupAttributeExtractor groupAttributeExtractor = new GroupAttributeExtractor(sess, this, groups);\n+\t\t\t\treturn groupAttributeExtractor.extractData(preparedStatement.executeQuery());\n+\t\t\t});\n+\t\t} catch (InternalErrorException ex) {\n+\t\t\t//Finding or invoking oracle array method was unsuccessful\n+\t\t\tthrow new InternalErrorException(ex);\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzMTU3NQ=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjE4MjA1OnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/implApi/AttributesManagerImplApi.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzozNDo0OVrOHJ5F_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNzowOFrOHLsA6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzNDY1Mg==", "bodyText": "For the given members and the given group.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r480134652", "createdAt": "2020-08-31T13:34:49Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/implApi/AttributesManagerImplApi.java", "diffHunk": "@@ -1312,6 +1312,19 @@\n \t */\n \tList<Attribute> getRequiredAttributes(PerunSession sess, Service service, Member member, Group group);\n \n+\t/**\n+\t * Get member-group attributes which are required by the service, for given members.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzUxMw==", "bodyText": "Fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017513", "createdAt": "2020-09-02T12:07:08Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/implApi/AttributesManagerImplApi.java", "diffHunk": "@@ -1312,6 +1312,19 @@\n \t */\n \tList<Attribute> getRequiredAttributes(PerunSession sess, Service service, Member member, Group group);\n \n+\t/**\n+\t * Get member-group attributes which are required by the service, for given members.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzNDY1Mg=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODMwNzgxOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzowNTo0NVrOHK1XOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNzoxNlrOHLsBJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyMjEwNg==", "bodyText": "I don't think there is a good reason to separate this line.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481122106", "createdAt": "2020-09-01T13:05:45Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzU3NA==", "bodyText": "Fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017574", "createdAt": "2020-09-02T12:07:16Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyMjEwNg=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODMzMzcwOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMzoxMjoyNFrOHK1nmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNzoyNlrOHLsBcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyNjI5Ng==", "bodyText": "You would probably want to use list of notYetProcessedGroups here instead of list of groups.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481126296", "createdAt": "2020-09-01T13:12:24Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzY0OQ==", "bodyText": "Yes, fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017649", "createdAt": "2020-09-02T12:07:26Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyNjI5Ng=="}, "originalCommit": {"oid": "60b1d983a5622bc75fd5839f6e4ef4dbb2dd04c5"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjU5OTAxOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzoxMTo0MFrOHLfv9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNzozNFrOHLsBtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgxNjU2Nw==", "bodyText": "There is probably missing assigning of actual processed resource object to variable lastLoadedResource.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481816567", "createdAt": "2020-09-02T07:11:40Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzcxOA==", "bodyText": "Yes, fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017718", "createdAt": "2020-09-02T12:07:34Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgxNjU2Nw=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjY0NzI3OnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzoyMDo1OVrOHLgOGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNzo0NlrOHLsCCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyNDI4Mw==", "bodyText": "This is misleading. This VO is not really a fake. In my opinion, fake means that such an ID does not exist at all. This is just uncomplete VO object with only the ID set.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481824283", "createdAt": "2020-09-02T07:20:59Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzgwMA==", "bodyText": "Comment changed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017800", "createdAt": "2020-09-02T12:07:46Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyNDI4Mw=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjY1MjE0OnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzoyMTo1OVrOHLgRcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNzo1NFrOHLsCSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyNTEzNw==", "bodyText": "You can create the VO object only inside this if clause.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481825137", "createdAt": "2020-09-02T07:21:59Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzg2Ng==", "bodyText": "Moved.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017866", "createdAt": "2020-09-02T12:07:54Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyNTEzNw=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjY2MzMxOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzoyNDoyM1rOHLgZBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowODowMlrOHLsCow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyNzA3Ng==", "bodyText": "I know it would be double-check, but you should check if resource=lastLoadedResource here too.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481827076", "createdAt": "2020-09-02T07:24:23Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));\n+\t\t}\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\tUser user = loadedUsersById.get(member.getUserId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzk1NQ==", "bodyText": "Check added.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482017955", "createdAt": "2020-09-02T12:08:02Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));\n+\t\t}\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\tUser user = loadedUsersById.get(member.getUserId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyNzA3Ng=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjY2NDczOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzoyNDo0MVrOHLgaBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowODowOVrOHLsC3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyNzMzNA==", "bodyText": "I know it would be double-check, but you should check if group=lastLoadedGroup here too.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481827334", "createdAt": "2020-09-02T07:24:41Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));\n+\t\t}\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\tUser user = loadedUsersById.get(member.getUserId());\n+\n+\t\thashes.addAll(getMemberAttributesHashes(member));\n+\t\thashes.addAll(getUserAttributesHashes(user));\n+\t\thashes.addAll(getUserFacilityAttributesHashes(user, facility));\n+\t\thashes.addAll(getMemberResourceAttributesHashes(member, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member, Group group) {\n+\t\tList<String> hashes = getMemberAttributesHashes(resource, member);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxODAxNA==", "bodyText": "Check added.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482018014", "createdAt": "2020-09-02T12:08:09Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));\n+\t\t}\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\tUser user = loadedUsersById.get(member.getUserId());\n+\n+\t\thashes.addAll(getMemberAttributesHashes(member));\n+\t\thashes.addAll(getUserAttributesHashes(user));\n+\t\thashes.addAll(getUserFacilityAttributesHashes(user, facility));\n+\t\thashes.addAll(getMemberResourceAttributesHashes(member, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member, Group group) {\n+\t\tList<String> hashes = getMemberAttributesHashes(resource, member);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyNzMzNA=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjY2NjU3OnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzoyNDo1OVrOHLgbOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzoyODozOFrOHLvHoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyNzY0MQ==", "bodyText": "I know it would be double-check, but you should check if resource=lastLoadedResource and group=lastLoadedGroup here too.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481827641", "createdAt": "2020-09-02T07:24:59Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));\n+\t\t}\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\tUser user = loadedUsersById.get(member.getUserId());\n+\n+\t\thashes.addAll(getMemberAttributesHashes(member));\n+\t\thashes.addAll(getUserAttributesHashes(user));\n+\t\thashes.addAll(getUserFacilityAttributesHashes(user, facility));\n+\t\thashes.addAll(getMemberResourceAttributesHashes(member, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member, Group group) {\n+\t\tList<String> hashes = getMemberAttributesHashes(resource, member);\n+\n+\t\thashes.addAll(getMemberGroupAttributesHashes(member, group));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getGroupAttributesHashes(Resource resource, Group group) {\n+\t\tList<String> hashes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxMTQ1MA==", "bodyText": "The group=lastLoadedGroup check shouldn't be here. The lastLoadedGroup is set when loading attributes for one group and multiple members. In this case, you are getting attributes that were loaded for one resource and multiple groups. The fact that the last loaded resource is the given one should prevent most of the errors (it is still possible that the load method wasn't called with this exactly given group, but this is more complex and it should be solved in the future refactorization.)\nI will add at least a comment that this should be fixed during the refactorization.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482011450", "createdAt": "2020-09-02T11:55:23Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));\n+\t\t}\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\tUser user = loadedUsersById.get(member.getUserId());\n+\n+\t\thashes.addAll(getMemberAttributesHashes(member));\n+\t\thashes.addAll(getUserAttributesHashes(user));\n+\t\thashes.addAll(getUserFacilityAttributesHashes(user, facility));\n+\t\thashes.addAll(getMemberResourceAttributesHashes(member, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member, Group group) {\n+\t\tList<String> hashes = getMemberAttributesHashes(resource, member);\n+\n+\t\thashes.addAll(getMemberGroupAttributesHashes(member, group));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getGroupAttributesHashes(Resource resource, Group group) {\n+\t\tList<String> hashes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyNzY0MQ=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA2ODM4NA==", "bodyText": "Ok.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482068384", "createdAt": "2020-09-02T13:28:38Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));\n+\t\t}\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\tUser user = loadedUsersById.get(member.getUserId());\n+\n+\t\thashes.addAll(getMemberAttributesHashes(member));\n+\t\thashes.addAll(getUserAttributesHashes(user));\n+\t\thashes.addAll(getUserFacilityAttributesHashes(user, facility));\n+\t\thashes.addAll(getMemberResourceAttributesHashes(member, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member, Group group) {\n+\t\tList<String> hashes = getMemberAttributesHashes(resource, member);\n+\n+\t\thashes.addAll(getMemberGroupAttributesHashes(member, group));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getGroupAttributesHashes(Resource resource, Group group) {\n+\t\tList<String> hashes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyNzY0MQ=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjg1NjYxOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwODowMTo0NFrOHLiWpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowODoxOVrOHLsDSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg1OTIzNg==", "bodyText": "Same as the misleading info about the fake above.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481859236", "createdAt": "2020-09-02T08:01:44Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));\n+\t\t}\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\tUser user = loadedUsersById.get(member.getUserId());\n+\n+\t\thashes.addAll(getMemberAttributesHashes(member));\n+\t\thashes.addAll(getUserAttributesHashes(user));\n+\t\thashes.addAll(getUserFacilityAttributesHashes(user, facility));\n+\t\thashes.addAll(getMemberResourceAttributesHashes(member, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member, Group group) {\n+\t\tList<String> hashes = getMemberAttributesHashes(resource, member);\n+\n+\t\thashes.addAll(getMemberGroupAttributesHashes(member, group));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getGroupAttributesHashes(Resource resource, Group group) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\thashes.addAll(getGroupAttributesHashes(group));\n+\t\thashes.addAll(getGroupResourceAttributesHashes(group, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, List<Attribute>> getAllFetchedAttributes() {\n+\t\treturn attributesByHash.entrySet().stream()\n+\t\t\t\t.filter(entry -> !entry.getValue().isEmpty())\n+\t\t\t\t.collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\t}\n+\n+\tprivate List<String> getVoAttributesHashes(Vo vo) {\n+\t\tString hash = hasher.hashVo(vo);\n+\n+\t\treturn getAndStoreHash(hash, vo, voAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberGroupAttributesHashes(Member member, Group group) {\n+\t\tif (!group.equals(lastLoadedGroup)) {\n+\t\t\tthrow new IllegalStateException(\"Cannot load member-group attributes for group \" + group + \", because last\" +\n+\t\t\t\t\t\"loaded group is: \" + lastLoadedGroup);\n+\t\t}\n+\t\tString hash = hasher.hashMemberGroup(member, group);\n+\n+\t\treturn getAndStoreHash(hash, member, memberGroupAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberResourceAttributesHashes(Member member, Resource resource) {\n+\t\tif (!resource.equals(lastLoadedResource)) {\n+\t\t\tthrow new IllegalStateException(\"The last loaded resource is different than the required one. Required: \" +\n+\t\t\t\t\tresource + \", Last loaded: \" + lastLoadedResource);\n+\t\t}\n+\t\tString hash = hasher.hashMemberResource(member, resource);\n+\n+\t\treturn getAndStoreHash(hash, member, memberResourceAttrs);\n+\t}\n+\n+\tprivate List<String> getResourceAttributesHashes(Resource resource) {\n+\t\tString hash = hasher.hashResource(resource);\n+\n+\t\treturn getAndStoreHash(hash, resource, resourceAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberAttributesHashes(Member member) {\n+\t\tString hash = hasher.hashMember(member);\n+\n+\t\treturn getAndStoreHash(hash, member, memberAttrs);\n+\t}\n+\n+\n+\tprivate List<String> getGroupAttributesHashes(Group group) {\n+\t\tString hash = hasher.hashGroup(group);\n+\n+\t\treturn getAndStoreHash(hash, group, groupAttrs);\n+\t}\n+\n+\tprivate List<String> getGroupResourceAttributesHashes(Group group, Resource resource) {\n+\t\tif (!resource.equals(lastLoadedResource)) {\n+\t\t\tthrow new IllegalStateException(\"The last loaded resource is different than the required one. Required: \" +\n+\t\t\t\t\tresource + \", Last loaded: \" + lastLoadedResource);\n+\t\t}\n+\n+\t\tString hash = hasher.hashGroupResource(group, resource);\n+\n+\t\treturn getAndStoreHash(hash, group, groupResourceAttrs);\n+\t}\n+\n+\tprivate List<String> getUserAttributesHashes(User user) {\n+\t\tString hash = hasher.hashUser(user);\n+\n+\t\treturn getAndStoreHash(hash, user, userAttrs);\n+\t}\n+\n+\tprivate List<String> getUserFacilityAttributesHashes(User user, Facility facility) {\n+\t\tString hash = hasher.hashUserFacility(user, facility);\n+\n+\t\treturn getAndStoreHash(hash, user, userFacilityAttrs);\n+\t}\n+\n+\t/**\n+\t * Get a list of attributes for given hash, and loads appropriate entity attributes from given map\n+\t * into the map of all processed attributes.\n+\t *\n+\t * If the map doesn't contain attributes for the given entity, or the list is empty,\n+\t * this method returns an empty list. Otherwise, it returns a List with the given hash.\n+\t *\n+\t * @param hash entity hash\n+\t * @param entity the entity which the hash belongs\n+\t * @param map map of attributes for the entity\n+\t * @param <T> the type of the entity User, Member, ...\n+\t * @return List with the hash or empty list if the map doesn't contain any attributes for the given entity\n+\t */\n+\tprivate <T> List<String> getAndStoreHash(String hash, T entity, Map<T, List<Attribute>> map) {\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (!map.containsKey(entity)) {\n+\t\t\t\treturn emptyList();\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, map.get(entity));\n+\t\t}\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\tprivate void loadMemberSpecificAttributes(List<Member> members) {\n+\t\tmemberAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, null, service, members)\n+\t\t);\n+\n+\t\tList<Integer> userIds = members.stream()\n+\t\t\t\t.map(Member::getUserId)\n+\t\t\t\t.collect(toList());\n+\n+\t\tList<User> users = sess.getPerunBl().getUsersManagerBl().getUsersByIds(sess, userIds);\n+\n+\t\tMap<Integer, User> usersById = users.stream()\n+\t\t\t\t.collect(toMap(User::getId, Function.identity()));\n+\t\tloadedUsersById.putAll(usersById);\n+\n+\t\tloadUserSpecificAttributes(users);\n+\t}\n+\n+\tprivate void loadUserSpecificAttributes(List<User> users) {\n+\t\tuserAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, users)\n+\t\t);\n+\n+\t\tuserFacilityAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility, users)\n+\t\t);\n+\t}\n+\n+\tprivate void loadVoSpecificAttributes(Resource resource) {\n+\t\t// create fake vo for map, because of optimization", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxODEyMg==", "bodyText": "Fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482018122", "createdAt": "2020-09-02T12:08:19Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));\n+\t\t}\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\tUser user = loadedUsersById.get(member.getUserId());\n+\n+\t\thashes.addAll(getMemberAttributesHashes(member));\n+\t\thashes.addAll(getUserAttributesHashes(user));\n+\t\thashes.addAll(getUserFacilityAttributesHashes(user, facility));\n+\t\thashes.addAll(getMemberResourceAttributesHashes(member, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member, Group group) {\n+\t\tList<String> hashes = getMemberAttributesHashes(resource, member);\n+\n+\t\thashes.addAll(getMemberGroupAttributesHashes(member, group));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getGroupAttributesHashes(Resource resource, Group group) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\thashes.addAll(getGroupAttributesHashes(group));\n+\t\thashes.addAll(getGroupResourceAttributesHashes(group, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, List<Attribute>> getAllFetchedAttributes() {\n+\t\treturn attributesByHash.entrySet().stream()\n+\t\t\t\t.filter(entry -> !entry.getValue().isEmpty())\n+\t\t\t\t.collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\t}\n+\n+\tprivate List<String> getVoAttributesHashes(Vo vo) {\n+\t\tString hash = hasher.hashVo(vo);\n+\n+\t\treturn getAndStoreHash(hash, vo, voAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberGroupAttributesHashes(Member member, Group group) {\n+\t\tif (!group.equals(lastLoadedGroup)) {\n+\t\t\tthrow new IllegalStateException(\"Cannot load member-group attributes for group \" + group + \", because last\" +\n+\t\t\t\t\t\"loaded group is: \" + lastLoadedGroup);\n+\t\t}\n+\t\tString hash = hasher.hashMemberGroup(member, group);\n+\n+\t\treturn getAndStoreHash(hash, member, memberGroupAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberResourceAttributesHashes(Member member, Resource resource) {\n+\t\tif (!resource.equals(lastLoadedResource)) {\n+\t\t\tthrow new IllegalStateException(\"The last loaded resource is different than the required one. Required: \" +\n+\t\t\t\t\tresource + \", Last loaded: \" + lastLoadedResource);\n+\t\t}\n+\t\tString hash = hasher.hashMemberResource(member, resource);\n+\n+\t\treturn getAndStoreHash(hash, member, memberResourceAttrs);\n+\t}\n+\n+\tprivate List<String> getResourceAttributesHashes(Resource resource) {\n+\t\tString hash = hasher.hashResource(resource);\n+\n+\t\treturn getAndStoreHash(hash, resource, resourceAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberAttributesHashes(Member member) {\n+\t\tString hash = hasher.hashMember(member);\n+\n+\t\treturn getAndStoreHash(hash, member, memberAttrs);\n+\t}\n+\n+\n+\tprivate List<String> getGroupAttributesHashes(Group group) {\n+\t\tString hash = hasher.hashGroup(group);\n+\n+\t\treturn getAndStoreHash(hash, group, groupAttrs);\n+\t}\n+\n+\tprivate List<String> getGroupResourceAttributesHashes(Group group, Resource resource) {\n+\t\tif (!resource.equals(lastLoadedResource)) {\n+\t\t\tthrow new IllegalStateException(\"The last loaded resource is different than the required one. Required: \" +\n+\t\t\t\t\tresource + \", Last loaded: \" + lastLoadedResource);\n+\t\t}\n+\n+\t\tString hash = hasher.hashGroupResource(group, resource);\n+\n+\t\treturn getAndStoreHash(hash, group, groupResourceAttrs);\n+\t}\n+\n+\tprivate List<String> getUserAttributesHashes(User user) {\n+\t\tString hash = hasher.hashUser(user);\n+\n+\t\treturn getAndStoreHash(hash, user, userAttrs);\n+\t}\n+\n+\tprivate List<String> getUserFacilityAttributesHashes(User user, Facility facility) {\n+\t\tString hash = hasher.hashUserFacility(user, facility);\n+\n+\t\treturn getAndStoreHash(hash, user, userFacilityAttrs);\n+\t}\n+\n+\t/**\n+\t * Get a list of attributes for given hash, and loads appropriate entity attributes from given map\n+\t * into the map of all processed attributes.\n+\t *\n+\t * If the map doesn't contain attributes for the given entity, or the list is empty,\n+\t * this method returns an empty list. Otherwise, it returns a List with the given hash.\n+\t *\n+\t * @param hash entity hash\n+\t * @param entity the entity which the hash belongs\n+\t * @param map map of attributes for the entity\n+\t * @param <T> the type of the entity User, Member, ...\n+\t * @return List with the hash or empty list if the map doesn't contain any attributes for the given entity\n+\t */\n+\tprivate <T> List<String> getAndStoreHash(String hash, T entity, Map<T, List<Attribute>> map) {\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (!map.containsKey(entity)) {\n+\t\t\t\treturn emptyList();\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, map.get(entity));\n+\t\t}\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\tprivate void loadMemberSpecificAttributes(List<Member> members) {\n+\t\tmemberAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, null, service, members)\n+\t\t);\n+\n+\t\tList<Integer> userIds = members.stream()\n+\t\t\t\t.map(Member::getUserId)\n+\t\t\t\t.collect(toList());\n+\n+\t\tList<User> users = sess.getPerunBl().getUsersManagerBl().getUsersByIds(sess, userIds);\n+\n+\t\tMap<Integer, User> usersById = users.stream()\n+\t\t\t\t.collect(toMap(User::getId, Function.identity()));\n+\t\tloadedUsersById.putAll(usersById);\n+\n+\t\tloadUserSpecificAttributes(users);\n+\t}\n+\n+\tprivate void loadUserSpecificAttributes(List<User> users) {\n+\t\tuserAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, users)\n+\t\t);\n+\n+\t\tuserFacilityAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility, users)\n+\t\t);\n+\t}\n+\n+\tprivate void loadVoSpecificAttributes(Resource resource) {\n+\t\t// create fake vo for map, because of optimization", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg1OTIzNg=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjg2NTU3OnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwODowMzozMFrOHLichg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMTo1OToxNVrOHLrxLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg2MDc0Mg==", "bodyText": "There is probably missing assigning of actual processed resource object to variable lastLoadedResource.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481860742", "createdAt": "2020-09-02T08:03:30Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));\n+\t\t}\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\tUser user = loadedUsersById.get(member.getUserId());\n+\n+\t\thashes.addAll(getMemberAttributesHashes(member));\n+\t\thashes.addAll(getUserAttributesHashes(user));\n+\t\thashes.addAll(getUserFacilityAttributesHashes(user, facility));\n+\t\thashes.addAll(getMemberResourceAttributesHashes(member, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member, Group group) {\n+\t\tList<String> hashes = getMemberAttributesHashes(resource, member);\n+\n+\t\thashes.addAll(getMemberGroupAttributesHashes(member, group));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getGroupAttributesHashes(Resource resource, Group group) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\thashes.addAll(getGroupAttributesHashes(group));\n+\t\thashes.addAll(getGroupResourceAttributesHashes(group, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, List<Attribute>> getAllFetchedAttributes() {\n+\t\treturn attributesByHash.entrySet().stream()\n+\t\t\t\t.filter(entry -> !entry.getValue().isEmpty())\n+\t\t\t\t.collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\t}\n+\n+\tprivate List<String> getVoAttributesHashes(Vo vo) {\n+\t\tString hash = hasher.hashVo(vo);\n+\n+\t\treturn getAndStoreHash(hash, vo, voAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberGroupAttributesHashes(Member member, Group group) {\n+\t\tif (!group.equals(lastLoadedGroup)) {\n+\t\t\tthrow new IllegalStateException(\"Cannot load member-group attributes for group \" + group + \", because last\" +\n+\t\t\t\t\t\"loaded group is: \" + lastLoadedGroup);\n+\t\t}\n+\t\tString hash = hasher.hashMemberGroup(member, group);\n+\n+\t\treturn getAndStoreHash(hash, member, memberGroupAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberResourceAttributesHashes(Member member, Resource resource) {\n+\t\tif (!resource.equals(lastLoadedResource)) {\n+\t\t\tthrow new IllegalStateException(\"The last loaded resource is different than the required one. Required: \" +\n+\t\t\t\t\tresource + \", Last loaded: \" + lastLoadedResource);\n+\t\t}\n+\t\tString hash = hasher.hashMemberResource(member, resource);\n+\n+\t\treturn getAndStoreHash(hash, member, memberResourceAttrs);\n+\t}\n+\n+\tprivate List<String> getResourceAttributesHashes(Resource resource) {\n+\t\tString hash = hasher.hashResource(resource);\n+\n+\t\treturn getAndStoreHash(hash, resource, resourceAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberAttributesHashes(Member member) {\n+\t\tString hash = hasher.hashMember(member);\n+\n+\t\treturn getAndStoreHash(hash, member, memberAttrs);\n+\t}\n+\n+\n+\tprivate List<String> getGroupAttributesHashes(Group group) {\n+\t\tString hash = hasher.hashGroup(group);\n+\n+\t\treturn getAndStoreHash(hash, group, groupAttrs);\n+\t}\n+\n+\tprivate List<String> getGroupResourceAttributesHashes(Group group, Resource resource) {\n+\t\tif (!resource.equals(lastLoadedResource)) {\n+\t\t\tthrow new IllegalStateException(\"The last loaded resource is different than the required one. Required: \" +\n+\t\t\t\t\tresource + \", Last loaded: \" + lastLoadedResource);\n+\t\t}\n+\n+\t\tString hash = hasher.hashGroupResource(group, resource);\n+\n+\t\treturn getAndStoreHash(hash, group, groupResourceAttrs);\n+\t}\n+\n+\tprivate List<String> getUserAttributesHashes(User user) {\n+\t\tString hash = hasher.hashUser(user);\n+\n+\t\treturn getAndStoreHash(hash, user, userAttrs);\n+\t}\n+\n+\tprivate List<String> getUserFacilityAttributesHashes(User user, Facility facility) {\n+\t\tString hash = hasher.hashUserFacility(user, facility);\n+\n+\t\treturn getAndStoreHash(hash, user, userFacilityAttrs);\n+\t}\n+\n+\t/**\n+\t * Get a list of attributes for given hash, and loads appropriate entity attributes from given map\n+\t * into the map of all processed attributes.\n+\t *\n+\t * If the map doesn't contain attributes for the given entity, or the list is empty,\n+\t * this method returns an empty list. Otherwise, it returns a List with the given hash.\n+\t *\n+\t * @param hash entity hash\n+\t * @param entity the entity which the hash belongs\n+\t * @param map map of attributes for the entity\n+\t * @param <T> the type of the entity User, Member, ...\n+\t * @return List with the hash or empty list if the map doesn't contain any attributes for the given entity\n+\t */\n+\tprivate <T> List<String> getAndStoreHash(String hash, T entity, Map<T, List<Attribute>> map) {\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (!map.containsKey(entity)) {\n+\t\t\t\treturn emptyList();\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, map.get(entity));\n+\t\t}\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\tprivate void loadMemberSpecificAttributes(List<Member> members) {\n+\t\tmemberAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, null, service, members)\n+\t\t);\n+\n+\t\tList<Integer> userIds = members.stream()\n+\t\t\t\t.map(Member::getUserId)\n+\t\t\t\t.collect(toList());\n+\n+\t\tList<User> users = sess.getPerunBl().getUsersManagerBl().getUsersByIds(sess, userIds);\n+\n+\t\tMap<Integer, User> usersById = users.stream()\n+\t\t\t\t.collect(toMap(User::getId, Function.identity()));\n+\t\tloadedUsersById.putAll(usersById);\n+\n+\t\tloadUserSpecificAttributes(users);\n+\t}\n+\n+\tprivate void loadUserSpecificAttributes(List<User> users) {\n+\t\tuserAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, users)\n+\t\t);\n+\n+\t\tuserFacilityAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility, users)\n+\t\t);\n+\t}\n+\n+\tprivate void loadVoSpecificAttributes(Resource resource) {\n+\t\t// create fake vo for map, because of optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\t\tif (!voAttrs.containsKey(vo)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxMzQ4NQ==", "bodyText": "I was missing because this was a private method and at the place where it was used, the last loaded resource was set. But I have added it here as well just to make sure.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482013485", "createdAt": "2020-09-02T11:59:15Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GenDataProviderImpl.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+import cz.metacentrum.perun.core.api.exceptions.GroupResourceMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+import cz.metacentrum.perun.core.api.exceptions.MemberGroupMismatchException;\n+import cz.metacentrum.perun.core.api.exceptions.VoNotExistsException;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GenDataProviderImpl implements GenDataProvider {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\n+\tprivate final Map<String, List<Attribute>> attributesByHash = new HashMap<>();\n+\n+\tprivate List<Attribute> facilityAttrs;\n+\n+\t/**\n+\t * Map of Member-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Group-Resource attributes. This map is overwritten when data for new resource are loaded!!!\n+\t */\n+\tprivate Map<Group, List<Attribute>> groupResourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Map of Member-Group attributes. This map is overwritten when data for new group are loaded!!!\n+\t */\n+\tprivate Map<Member, List<Attribute>> memberGroupAttrs = new HashMap<>();\n+\n+\t/**\n+\t * These maps are not overwritten, because they do not depend on currently loaded entities.\n+\t */\n+\tprivate final Map<Member, List<Attribute>> memberAttrs = new HashMap<>();\n+\tprivate final Map<Group, List<Attribute>> groupAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userAttrs = new HashMap<>();\n+\tprivate final Map<User, List<Attribute>> userFacilityAttrs = new HashMap<>();\n+\tprivate final Map<Resource, List<Attribute>> resourceAttrs = new HashMap<>();\n+\n+\t/**\n+\t * Vos has to contain only ids, or only vos loaded from DB. Because of the equals and hashCode\n+\t * implementations. If they were mixed, it would cause data duplicity.\n+\t */\n+\tprivate final Map<Vo, List<Attribute>> voAttrs = new HashMap<>();\n+\n+\tprivate Group lastLoadedGroup;\n+\tprivate Resource lastLoadedResource;\n+\n+\tprivate final Map<Integer, User> loadedUsersById = new HashMap<>();\n+\tprivate final Set<Member> processedMembers = new HashSet<>();\n+\tprivate final Set<Group> processedGroups = new HashSet<>();\n+\n+\tprivate final Hasher hasher = new IdHasher();\n+\n+\tpublic GenDataProviderImpl(PerunSessionImpl sess, Service service, Facility facility) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t}\n+\n+\t@Override\n+\tpublic void loadFacilityAttributes() {\n+\t\tfacilityAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic void loadGroupsAttributes(Resource resource, List<Group> groups) {\n+\t\tgroupResourceAttrs = new HashMap<>();\n+\n+\t\tfor (Group group: groups) {\n+\t\t\ttry {\n+\t\t\t\t// FIXME - attributes could be loaded at once to get a better performance\n+\t\t\t\tgroupResourceAttrs.put(group,\n+\t\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, group));\n+\t\t\t} catch (GroupResourceMismatchException e) {\n+\t\t\t\tthrow new InternalErrorException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<Group> notYetProcessedGroups = new ArrayList<>(groups);\n+\t\tnotYetProcessedGroups.removeAll(processedGroups);\n+\t\tprocessedGroups.addAll(notYetProcessedGroups);\n+\n+\t\tgroupAttrs.putAll(\n+\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributesForGroups(sess, service, groups)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void loadMemberGroupAttributes(Group group, List<Member> members) {\n+\t\tlastLoadedGroup = group;\n+\t\tmemberGroupAttrs = new HashMap<>();\n+\t\ttry {\n+\t\t\tmemberGroupAttrs.putAll(\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, members, group)\n+\t\t\t);\n+\t\t} catch (MemberGroupMismatchException e) {\n+\t\t\tthrow new InternalErrorException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void loadResourceAttributes(Resource resource, List<Member> members, boolean loadVoAttributes) {\n+\t\tlastLoadedResource = resource;\n+\n+\t\tif (!resourceAttrs.containsKey(resource)) {\n+\t\t\tresourceAttrs.put(resource,\n+\t\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource));\n+\t\t}\n+\n+\t\tif (loadVoAttributes) {\n+\t\t\tloadVoSpecificAttributes(resource);\n+\t\t}\n+\n+\t\tmemberResourceAttrs =\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, resource, members);\n+\n+\t\t// we don't need to load again attributes for the already processed members\n+\t\tList<Member> notYetProcessedMembers = new ArrayList<>(members);\n+\t\tnotYetProcessedMembers.removeAll(processedMembers);\n+\t\tprocessedMembers.addAll(notYetProcessedMembers);\n+\n+\t\tloadMemberSpecificAttributes(notYetProcessedMembers);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getFacilityAttributesHashes() {\n+\t\tString hash = hasher.hashFacility(facility);\n+\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (facilityAttrs == null) {\n+\t\t\t\tthrow new IllegalStateException(\"Facility attributes need to be loaded first.\");\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, facilityAttrs);\n+\t\t}\n+\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getResourceAttributesHashes(Resource resource, boolean addVoAttributes) {\n+\t\tList<String> hashes = getResourceAttributesHashes(resource);\n+\n+\t\t// create fake vo for optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\n+\t\tif (addVoAttributes) {\n+\t\t\thashes.addAll(getVoAttributesHashes(vo));\n+\t\t}\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\tUser user = loadedUsersById.get(member.getUserId());\n+\n+\t\thashes.addAll(getMemberAttributesHashes(member));\n+\t\thashes.addAll(getUserAttributesHashes(user));\n+\t\thashes.addAll(getUserFacilityAttributesHashes(user, facility));\n+\t\thashes.addAll(getMemberResourceAttributesHashes(member, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getMemberAttributesHashes(Resource resource, Member member, Group group) {\n+\t\tList<String> hashes = getMemberAttributesHashes(resource, member);\n+\n+\t\thashes.addAll(getMemberGroupAttributesHashes(member, group));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> getGroupAttributesHashes(Resource resource, Group group) {\n+\t\tList<String> hashes = new ArrayList<>();\n+\n+\t\thashes.addAll(getGroupAttributesHashes(group));\n+\t\thashes.addAll(getGroupResourceAttributesHashes(group, resource));\n+\n+\t\treturn hashes;\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, List<Attribute>> getAllFetchedAttributes() {\n+\t\treturn attributesByHash.entrySet().stream()\n+\t\t\t\t.filter(entry -> !entry.getValue().isEmpty())\n+\t\t\t\t.collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\t}\n+\n+\tprivate List<String> getVoAttributesHashes(Vo vo) {\n+\t\tString hash = hasher.hashVo(vo);\n+\n+\t\treturn getAndStoreHash(hash, vo, voAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberGroupAttributesHashes(Member member, Group group) {\n+\t\tif (!group.equals(lastLoadedGroup)) {\n+\t\t\tthrow new IllegalStateException(\"Cannot load member-group attributes for group \" + group + \", because last\" +\n+\t\t\t\t\t\"loaded group is: \" + lastLoadedGroup);\n+\t\t}\n+\t\tString hash = hasher.hashMemberGroup(member, group);\n+\n+\t\treturn getAndStoreHash(hash, member, memberGroupAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberResourceAttributesHashes(Member member, Resource resource) {\n+\t\tif (!resource.equals(lastLoadedResource)) {\n+\t\t\tthrow new IllegalStateException(\"The last loaded resource is different than the required one. Required: \" +\n+\t\t\t\t\tresource + \", Last loaded: \" + lastLoadedResource);\n+\t\t}\n+\t\tString hash = hasher.hashMemberResource(member, resource);\n+\n+\t\treturn getAndStoreHash(hash, member, memberResourceAttrs);\n+\t}\n+\n+\tprivate List<String> getResourceAttributesHashes(Resource resource) {\n+\t\tString hash = hasher.hashResource(resource);\n+\n+\t\treturn getAndStoreHash(hash, resource, resourceAttrs);\n+\t}\n+\n+\tprivate List<String> getMemberAttributesHashes(Member member) {\n+\t\tString hash = hasher.hashMember(member);\n+\n+\t\treturn getAndStoreHash(hash, member, memberAttrs);\n+\t}\n+\n+\n+\tprivate List<String> getGroupAttributesHashes(Group group) {\n+\t\tString hash = hasher.hashGroup(group);\n+\n+\t\treturn getAndStoreHash(hash, group, groupAttrs);\n+\t}\n+\n+\tprivate List<String> getGroupResourceAttributesHashes(Group group, Resource resource) {\n+\t\tif (!resource.equals(lastLoadedResource)) {\n+\t\t\tthrow new IllegalStateException(\"The last loaded resource is different than the required one. Required: \" +\n+\t\t\t\t\tresource + \", Last loaded: \" + lastLoadedResource);\n+\t\t}\n+\n+\t\tString hash = hasher.hashGroupResource(group, resource);\n+\n+\t\treturn getAndStoreHash(hash, group, groupResourceAttrs);\n+\t}\n+\n+\tprivate List<String> getUserAttributesHashes(User user) {\n+\t\tString hash = hasher.hashUser(user);\n+\n+\t\treturn getAndStoreHash(hash, user, userAttrs);\n+\t}\n+\n+\tprivate List<String> getUserFacilityAttributesHashes(User user, Facility facility) {\n+\t\tString hash = hasher.hashUserFacility(user, facility);\n+\n+\t\treturn getAndStoreHash(hash, user, userFacilityAttrs);\n+\t}\n+\n+\t/**\n+\t * Get a list of attributes for given hash, and loads appropriate entity attributes from given map\n+\t * into the map of all processed attributes.\n+\t *\n+\t * If the map doesn't contain attributes for the given entity, or the list is empty,\n+\t * this method returns an empty list. Otherwise, it returns a List with the given hash.\n+\t *\n+\t * @param hash entity hash\n+\t * @param entity the entity which the hash belongs\n+\t * @param map map of attributes for the entity\n+\t * @param <T> the type of the entity User, Member, ...\n+\t * @return List with the hash or empty list if the map doesn't contain any attributes for the given entity\n+\t */\n+\tprivate <T> List<String> getAndStoreHash(String hash, T entity, Map<T, List<Attribute>> map) {\n+\t\tif (!attributesByHash.containsKey(hash)) {\n+\t\t\tif (!map.containsKey(entity)) {\n+\t\t\t\treturn emptyList();\n+\t\t\t}\n+\t\t\tattributesByHash.put(hash, map.get(entity));\n+\t\t}\n+\t\treturn attributesByHash.get(hash).isEmpty() ? emptyList() : singletonList(hash);\n+\t}\n+\n+\tprivate void loadMemberSpecificAttributes(List<Member> members) {\n+\t\tmemberAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, null, service, members)\n+\t\t);\n+\n+\t\tList<Integer> userIds = members.stream()\n+\t\t\t\t.map(Member::getUserId)\n+\t\t\t\t.collect(toList());\n+\n+\t\tList<User> users = sess.getPerunBl().getUsersManagerBl().getUsersByIds(sess, userIds);\n+\n+\t\tMap<Integer, User> usersById = users.stream()\n+\t\t\t\t.collect(toMap(User::getId, Function.identity()));\n+\t\tloadedUsersById.putAll(usersById);\n+\n+\t\tloadUserSpecificAttributes(users);\n+\t}\n+\n+\tprivate void loadUserSpecificAttributes(List<User> users) {\n+\t\tuserAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, users)\n+\t\t);\n+\n+\t\tuserFacilityAttrs.putAll(\n+\t\t\t\tsess.getPerunBl().getAttributesManagerBl().getRequiredAttributes(sess, service, facility, users)\n+\t\t);\n+\t}\n+\n+\tprivate void loadVoSpecificAttributes(Resource resource) {\n+\t\t// create fake vo for map, because of optimization\n+\t\tVo vo = new Vo();\n+\t\tvo.setId(resource.getVoId());\n+\t\tif (!voAttrs.containsKey(vo)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg2MDc0Mg=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 346}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjg3OTMwOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/IdHasher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwODowNjoxNVrOHLilsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMTo1OTo1MlrOHLrydA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg2MzA5MQ==", "bodyText": "Please add at least a simple Javadoc about this class.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481863091", "createdAt": "2020-09-02T08:06:15Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/IdHasher.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class IdHasher implements Hasher {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxMzgxMg==", "bodyText": "Done.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482013812", "createdAt": "2020-09-02T11:59:52Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/IdHasher.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.User;\n+import cz.metacentrum.perun.core.api.Vo;\n+\n+/**\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class IdHasher implements Hasher {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg2MzA5MQ=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjk0ODM4OnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/HierarchicalHashedDataGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwODoxOToyMlrOHLjS_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowOToxNFrOHLsFJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg3NDY4Ng==", "bodyText": "You can use FacilitiesManager.getAssignedResources(sess, facility, specificVo, specificService) instead and call it as:\nList<Resource> resources = sess.getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility, null, service);", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481874686", "createdAt": "2020-09-02T08:19:22Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/HierarchicalHashedDataGenerator.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.GenDataNode;\n+import cz.metacentrum.perun.core.api.GenMemberDataNode;\n+import cz.metacentrum.perun.core.api.HashedGenData;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Generates data in format:\n+ *\n+ * attributes: {...hashes...}\n+ * hierarchy: {\n+ *    ** facility **\n+ *    hashes: [...hashes...]\n+ *    members: []\n+ *    children: [\n+ *      {\n+ *        ** resource1 **\n+ *        hashes: [...hashes...]\n+ *        children: []\n+ *        members: [\n+ *          {\n+ *            ** member 1 **\n+ *            hashes: [...hashes...]\n+ *          },\n+ *          {\n+ *            ** member 2 **\n+ *            ...\n+ *          }\n+ *        ]\n+ *      },\n+ *      {\n+ *        ** resource2 **\n+ *        ...\n+ *      }\n+ *    ]\n+ * }\n+ *\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class HierarchicalHashedDataGenerator implements HashedDataGenerator {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\tprivate final GenDataProvider dataProvider;\n+\tprivate final boolean filterExpiredMembers;\n+\n+\tprivate HierarchicalHashedDataGenerator(PerunSessionImpl sess, Service service, Facility facility,\n+\t                                        boolean filterExpiredMembers) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t\tthis.filterExpiredMembers = filterExpiredMembers;\n+\t\tdataProvider = new GenDataProviderImpl(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic HashedGenData generateData() {\n+\t\tdataProvider.loadFacilityAttributes();\n+\n+\t\tList<Resource> resources = sess.getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n+\t\tresources.retainAll(sess.getPerunBl().getServicesManagerBl().getAssignedResources(sess, service));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxODU5Nw==", "bodyText": "replaced", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482018597", "createdAt": "2020-09-02T12:09:14Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/HierarchicalHashedDataGenerator.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.GenDataNode;\n+import cz.metacentrum.perun.core.api.GenMemberDataNode;\n+import cz.metacentrum.perun.core.api.HashedGenData;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Generates data in format:\n+ *\n+ * attributes: {...hashes...}\n+ * hierarchy: {\n+ *    ** facility **\n+ *    hashes: [...hashes...]\n+ *    members: []\n+ *    children: [\n+ *      {\n+ *        ** resource1 **\n+ *        hashes: [...hashes...]\n+ *        children: []\n+ *        members: [\n+ *          {\n+ *            ** member 1 **\n+ *            hashes: [...hashes...]\n+ *          },\n+ *          {\n+ *            ** member 2 **\n+ *            ...\n+ *          }\n+ *        ]\n+ *      },\n+ *      {\n+ *        ** resource2 **\n+ *        ...\n+ *      }\n+ *    ]\n+ * }\n+ *\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class HierarchicalHashedDataGenerator implements HashedDataGenerator {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\tprivate final GenDataProvider dataProvider;\n+\tprivate final boolean filterExpiredMembers;\n+\n+\tprivate HierarchicalHashedDataGenerator(PerunSessionImpl sess, Service service, Facility facility,\n+\t                                        boolean filterExpiredMembers) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t\tthis.filterExpiredMembers = filterExpiredMembers;\n+\t\tdataProvider = new GenDataProviderImpl(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic HashedGenData generateData() {\n+\t\tdataProvider.loadFacilityAttributes();\n+\n+\t\tList<Resource> resources = sess.getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n+\t\tresources.retainAll(sess.getPerunBl().getServicesManagerBl().getAssignedResources(sess, service));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg3NDY4Ng=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjk0OTcxOnYy", "diffSide": "RIGHT", "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GroupsHashedDataGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwODoxOTozNlrOHLjT4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowOTozNlrOHLsF0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg3NDkxMw==", "bodyText": "You can use FacilitiesManager.getAssignedResources(sess, facility, specificVo, specificService) instead and call it as:\nList<Resource> resources = sess.getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility, null, service);", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r481874913", "createdAt": "2020-09-02T08:19:36Z", "author": {"login": "stavamichal"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GroupsHashedDataGenerator.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.GenDataNode;\n+import cz.metacentrum.perun.core.api.GenMemberDataNode;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.HashedGenData;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.VosManager;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Generates data in format:\n+ *\n+ * attributes: {...hashes...}\n+ * hierarchy: {\n+ *    ** facility **\n+ *    hashes: [...hashes...]\n+ *    members: []\n+ *    children: [\n+ *      {\n+ *        ** resource1 **\n+ *        hashes: [...hashes...]\n+ *        children: [\n+ *          {\n+ *            ** group A **\n+ *            hashes: [...hashes...]\n+ *            members: [...group members...]\n+ *            children: [...sub groups...]\n+ *          },\n+ *          {\n+ *            ** group B **\n+ *            ...\n+ *          }\n+ *        ]\n+ *        members: [\n+ *          {\n+ *            ** member 1 **\n+ *            hashes: [...hashes...]\n+ *          },\n+ *          {\n+ *            ** member 2 **\n+ *            ...\n+ *          }\n+ *        ]\n+ *      },\n+ *      {\n+ *        ** resource2 **\n+ *        ...\n+ *      }\n+ *    ]\n+ * }\n+ *\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GroupsHashedDataGenerator implements HashedDataGenerator {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\tprivate final GenDataProvider dataProvider;\n+\tprivate final boolean filterExpiredMembers;\n+\n+\tprivate GroupsHashedDataGenerator(PerunSessionImpl sess, Service service, Facility facility,\n+\t                                 boolean filterExpiredMembers) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t\tthis.filterExpiredMembers = filterExpiredMembers;\n+\t\tdataProvider = new GenDataProviderImpl(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic HashedGenData generateData() {\n+\t\tdataProvider.loadFacilityAttributes();\n+\n+\t\tList<Resource> resources = sess.getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n+\t\tresources.retainAll(sess.getPerunBl().getServicesManagerBl().getAssignedResources(sess, service));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxODc3MA==", "bodyText": "Fixed.", "url": "https://github.com/CESNET/perun/pull/2871#discussion_r482018770", "createdAt": "2020-09-02T12:09:36Z", "author": {"login": "Vojtech-Sassmann"}, "path": "perun-core/src/main/java/cz/metacentrum/perun/core/provisioning/GroupsHashedDataGenerator.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package cz.metacentrum.perun.core.provisioning;\n+\n+import cz.metacentrum.perun.core.api.Attribute;\n+import cz.metacentrum.perun.core.api.Facility;\n+import cz.metacentrum.perun.core.api.GenDataNode;\n+import cz.metacentrum.perun.core.api.GenMemberDataNode;\n+import cz.metacentrum.perun.core.api.Group;\n+import cz.metacentrum.perun.core.api.HashedGenData;\n+import cz.metacentrum.perun.core.api.Member;\n+import cz.metacentrum.perun.core.api.Resource;\n+import cz.metacentrum.perun.core.api.Service;\n+import cz.metacentrum.perun.core.api.VosManager;\n+import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Generates data in format:\n+ *\n+ * attributes: {...hashes...}\n+ * hierarchy: {\n+ *    ** facility **\n+ *    hashes: [...hashes...]\n+ *    members: []\n+ *    children: [\n+ *      {\n+ *        ** resource1 **\n+ *        hashes: [...hashes...]\n+ *        children: [\n+ *          {\n+ *            ** group A **\n+ *            hashes: [...hashes...]\n+ *            members: [...group members...]\n+ *            children: [...sub groups...]\n+ *          },\n+ *          {\n+ *            ** group B **\n+ *            ...\n+ *          }\n+ *        ]\n+ *        members: [\n+ *          {\n+ *            ** member 1 **\n+ *            hashes: [...hashes...]\n+ *          },\n+ *          {\n+ *            ** member 2 **\n+ *            ...\n+ *          }\n+ *        ]\n+ *      },\n+ *      {\n+ *        ** resource2 **\n+ *        ...\n+ *      }\n+ *    ]\n+ * }\n+ *\n+ * @author Vojtech Sassmann <vojtech.sassmann@gmail.com>\n+ */\n+public class GroupsHashedDataGenerator implements HashedDataGenerator {\n+\n+\tprivate final PerunSessionImpl sess;\n+\tprivate final Service service;\n+\tprivate final Facility facility;\n+\tprivate final GenDataProvider dataProvider;\n+\tprivate final boolean filterExpiredMembers;\n+\n+\tprivate GroupsHashedDataGenerator(PerunSessionImpl sess, Service service, Facility facility,\n+\t                                 boolean filterExpiredMembers) {\n+\t\tthis.sess = sess;\n+\t\tthis.service = service;\n+\t\tthis.facility = facility;\n+\t\tthis.filterExpiredMembers = filterExpiredMembers;\n+\t\tdataProvider = new GenDataProviderImpl(sess, service, facility);\n+\t}\n+\n+\t@Override\n+\tpublic HashedGenData generateData() {\n+\t\tdataProvider.loadFacilityAttributes();\n+\n+\t\tList<Resource> resources = sess.getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n+\t\tresources.retainAll(sess.getPerunBl().getServicesManagerBl().getAssignedResources(sess, service));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg3NDkxMw=="}, "originalCommit": {"oid": "c2360fc907b21688fc99c389718c4561a6c5d1aa"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2247, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}