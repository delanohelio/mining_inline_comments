{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzNDk4NzI4", "number": 4518, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjowOTo0NFrOFCSsUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo1ODo0OVrOFC6UpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTQ3NzMwOnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/introspection/StreamIntrospectionComputation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjowOTo0NFrOIBW8UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDowMToyM1rOICWE0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI5NTM3Nw==", "bodyText": "Could we have a simple pojo to represent this model and read/write it with Jackson?", "url": "https://github.com/nuxeo/nuxeo/pull/4518#discussion_r538295377", "createdAt": "2020-12-08T12:09:44Z", "author": {"login": "kevinleturc"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/introspection/StreamIntrospectionComputation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.ecm.core.bulk.introspection;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.lib.stream.computation.AbstractComputation;\n+import org.nuxeo.lib.stream.computation.ComputationContext;\n+import org.nuxeo.lib.stream.computation.Record;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+/**\n+ * A computation that reads processor and metrics streams to build a representation of stream activities in the cluster.\n+ * The representation is pushed to the KV Store.\n+ *\n+ * @since 11.5\n+ */\n+public class StreamIntrospectionComputation extends AbstractComputation {\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(\n+            StreamIntrospectionComputation.class);\n+\n+    public static final String NAME = \"stream/introspection\";\n+\n+    public static final String INTROSPECTION_KV_STORE = \"introspection\";\n+\n+    public static final String INTROSPECTION_KEY = \"streamIntrospection\";\n+\n+    protected static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    protected final Map<String, JsonNode> streams = new HashMap<>();\n+\n+    protected final Map<String, JsonNode> processors = new HashMap<>();\n+\n+    protected final Map<String, JsonNode> metrics = new HashMap<>();\n+\n+    protected static final long TTL_SECONDS = 300;\n+\n+    protected String model;\n+\n+    public StreamIntrospectionComputation() {\n+        super(NAME, 2, 0);\n+    }\n+\n+    @Override\n+    public void init(ComputationContext context) {\n+        if (context.isSpareComputation()) {\n+            log.info(\"Spare instance nothing to report\");\n+        } else {\n+            log.warn(\"Instance elected to introspect Nuxeo Stream activity\");\n+        }\n+        loadModel(getKvStore().getString(INTROSPECTION_KEY));\n+    }\n+\n+    protected void loadModel(String modelJson) {\n+        streams.clear();\n+        processors.clear();\n+        metrics.clear();\n+        if (modelJson == null || modelJson.isBlank()) {\n+            model = null;\n+            return;\n+        }\n+        try {\n+            JsonNode modelNode = OBJECT_MAPPER.readTree(modelJson);\n+            JsonNode node = modelNode.get(\"streams\");\n+            if (node.isArray()) {\n+                for (JsonNode item : node) {\n+                    streams.put(item.get(\"name\").asText(), item);\n+                }\n+            }\n+            node = modelNode.get(\"processors\");\n+            if (node.isArray()) {\n+                for (JsonNode item : node) {\n+                    processors.put(getProcessorKey(item), item);\n+                }\n+            }\n+            node = modelNode.get(\"metrics\");\n+            if (node.isArray()) {\n+                for (JsonNode item : node) {\n+                    metrics.put(item.get(\"ip\").asText(), item);\n+                }\n+            }\n+            model = modelJson;\n+        } catch (JsonProcessingException e) {\n+            log.error(\"Unable to parse KV model as JSON {}\", modelJson, e);\n+            model = null;\n+        }\n+    }\n+\n+    @Override\n+    public void processRecord(ComputationContext context, String inputStreamName, Record record) {\n+        JsonNode json = getJson(record);\n+        if (json != null) {\n+            if (INPUT_1.equals(inputStreamName)) {\n+                updateStreamsAndProcessors(json);\n+            } else if (INPUT_2.equals(inputStreamName)) {\n+                if (json.has(\"ip\")) {\n+                    metrics.put(json.get(\"ip\").asText(), json);\n+                }\n+            }\n+        }\n+        removeOldNodes();\n+        buildModel();\n+        updateModel();\n+        context.askForCheckpoint();\n+    }\n+\n+    protected void updateStreamsAndProcessors(JsonNode node) {\n+        JsonNode streamsNode = node.get(\"streams\");\n+        if (streamsNode == null) {\n+            log.warn(\"Invalid metric without streams field: {}\", node);\n+            return;\n+        }\n+        if (streamsNode.isArray()) {\n+            for (JsonNode item : streamsNode) {\n+                streams.put(item.get(\"name\").asText(), item);\n+            }\n+        }\n+        ((ObjectNode) node).remove(\"streams\");\n+        processors.put(getProcessorKey(node), node);\n+    }\n+\n+    protected String getProcessorKey(JsonNode json) {\n+        return json.at(\"/metadata/ip\").asText() + \":\" + json.at(\"/metadata/processorName\").asText();\n+    }\n+\n+    protected void updateModel() {\n+        KeyValueStore kv = getKvStore();\n+        kv.put(INTROSPECTION_KEY, model);\n+    }\n+\n+    protected KeyValueStore getKvStore() {\n+        return Framework.getService(KeyValueService.class).getKeyValueStore(INTROSPECTION_KV_STORE);\n+    }\n+\n+    protected void buildModel() {\n+        ObjectNode node = OBJECT_MAPPER.createObjectNode();\n+        ArrayNode streamsNode = OBJECT_MAPPER.createArrayNode();\n+        streamsNode.addAll(streams.values());\n+        node.set(\"streams\", streamsNode);\n+        ArrayNode processorsNode = OBJECT_MAPPER.createArrayNode();\n+        processorsNode.addAll(processors.values());\n+        node.set(\"processors\", processorsNode);\n+        ArrayNode metricsNode = OBJECT_MAPPER.createArrayNode();\n+        metricsNode.addAll(metrics.values());\n+        node.set(\"metrics\", metricsNode);\n+        try {\n+            model = OBJECT_MAPPER.writer().writeValueAsString(node);\n+        } catch (JsonProcessingException e) {\n+            log.error(\"Cannot build JSON model\", e);\n+            model = \"{}\";\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afd670931d0dc0a6d6208c40a0dce86f35bcfcb7"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMyOTc0NQ==", "bodyText": "yes probably but this is only the early stage of the representation that can be refactored depending on how we want to exploit it, the important thing is to start publishing the information (metrics and processor producer code)", "url": "https://github.com/nuxeo/nuxeo/pull/4518#discussion_r539329745", "createdAt": "2020-12-09T14:01:23Z", "author": {"login": "bdelbosc"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/introspection/StreamIntrospectionComputation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.ecm.core.bulk.introspection;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.lib.stream.computation.AbstractComputation;\n+import org.nuxeo.lib.stream.computation.ComputationContext;\n+import org.nuxeo.lib.stream.computation.Record;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+/**\n+ * A computation that reads processor and metrics streams to build a representation of stream activities in the cluster.\n+ * The representation is pushed to the KV Store.\n+ *\n+ * @since 11.5\n+ */\n+public class StreamIntrospectionComputation extends AbstractComputation {\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(\n+            StreamIntrospectionComputation.class);\n+\n+    public static final String NAME = \"stream/introspection\";\n+\n+    public static final String INTROSPECTION_KV_STORE = \"introspection\";\n+\n+    public static final String INTROSPECTION_KEY = \"streamIntrospection\";\n+\n+    protected static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    protected final Map<String, JsonNode> streams = new HashMap<>();\n+\n+    protected final Map<String, JsonNode> processors = new HashMap<>();\n+\n+    protected final Map<String, JsonNode> metrics = new HashMap<>();\n+\n+    protected static final long TTL_SECONDS = 300;\n+\n+    protected String model;\n+\n+    public StreamIntrospectionComputation() {\n+        super(NAME, 2, 0);\n+    }\n+\n+    @Override\n+    public void init(ComputationContext context) {\n+        if (context.isSpareComputation()) {\n+            log.info(\"Spare instance nothing to report\");\n+        } else {\n+            log.warn(\"Instance elected to introspect Nuxeo Stream activity\");\n+        }\n+        loadModel(getKvStore().getString(INTROSPECTION_KEY));\n+    }\n+\n+    protected void loadModel(String modelJson) {\n+        streams.clear();\n+        processors.clear();\n+        metrics.clear();\n+        if (modelJson == null || modelJson.isBlank()) {\n+            model = null;\n+            return;\n+        }\n+        try {\n+            JsonNode modelNode = OBJECT_MAPPER.readTree(modelJson);\n+            JsonNode node = modelNode.get(\"streams\");\n+            if (node.isArray()) {\n+                for (JsonNode item : node) {\n+                    streams.put(item.get(\"name\").asText(), item);\n+                }\n+            }\n+            node = modelNode.get(\"processors\");\n+            if (node.isArray()) {\n+                for (JsonNode item : node) {\n+                    processors.put(getProcessorKey(item), item);\n+                }\n+            }\n+            node = modelNode.get(\"metrics\");\n+            if (node.isArray()) {\n+                for (JsonNode item : node) {\n+                    metrics.put(item.get(\"ip\").asText(), item);\n+                }\n+            }\n+            model = modelJson;\n+        } catch (JsonProcessingException e) {\n+            log.error(\"Unable to parse KV model as JSON {}\", modelJson, e);\n+            model = null;\n+        }\n+    }\n+\n+    @Override\n+    public void processRecord(ComputationContext context, String inputStreamName, Record record) {\n+        JsonNode json = getJson(record);\n+        if (json != null) {\n+            if (INPUT_1.equals(inputStreamName)) {\n+                updateStreamsAndProcessors(json);\n+            } else if (INPUT_2.equals(inputStreamName)) {\n+                if (json.has(\"ip\")) {\n+                    metrics.put(json.get(\"ip\").asText(), json);\n+                }\n+            }\n+        }\n+        removeOldNodes();\n+        buildModel();\n+        updateModel();\n+        context.askForCheckpoint();\n+    }\n+\n+    protected void updateStreamsAndProcessors(JsonNode node) {\n+        JsonNode streamsNode = node.get(\"streams\");\n+        if (streamsNode == null) {\n+            log.warn(\"Invalid metric without streams field: {}\", node);\n+            return;\n+        }\n+        if (streamsNode.isArray()) {\n+            for (JsonNode item : streamsNode) {\n+                streams.put(item.get(\"name\").asText(), item);\n+            }\n+        }\n+        ((ObjectNode) node).remove(\"streams\");\n+        processors.put(getProcessorKey(node), node);\n+    }\n+\n+    protected String getProcessorKey(JsonNode json) {\n+        return json.at(\"/metadata/ip\").asText() + \":\" + json.at(\"/metadata/processorName\").asText();\n+    }\n+\n+    protected void updateModel() {\n+        KeyValueStore kv = getKvStore();\n+        kv.put(INTROSPECTION_KEY, model);\n+    }\n+\n+    protected KeyValueStore getKvStore() {\n+        return Framework.getService(KeyValueService.class).getKeyValueStore(INTROSPECTION_KV_STORE);\n+    }\n+\n+    protected void buildModel() {\n+        ObjectNode node = OBJECT_MAPPER.createObjectNode();\n+        ArrayNode streamsNode = OBJECT_MAPPER.createArrayNode();\n+        streamsNode.addAll(streams.values());\n+        node.set(\"streams\", streamsNode);\n+        ArrayNode processorsNode = OBJECT_MAPPER.createArrayNode();\n+        processorsNode.addAll(processors.values());\n+        node.set(\"processors\", processorsNode);\n+        ArrayNode metricsNode = OBJECT_MAPPER.createArrayNode();\n+        metricsNode.addAll(metrics.values());\n+        node.set(\"metrics\", metricsNode);\n+        try {\n+            model = OBJECT_MAPPER.writer().writeValueAsString(node);\n+        } catch (JsonProcessingException e) {\n+            log.error(\"Cannot build JSON model\", e);\n+            model = \"{}\";\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI5NTM3Nw=="}, "originalCommit": {"oid": "afd670931d0dc0a6d6208c40a0dce86f35bcfcb7"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDg2ODExOnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-runtime-stream/src/main/java/org/nuxeo/runtime/stream/StreamMetricsNuxeoReporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo1NDowNVrOICJShA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo0NTo1N1rOICS2TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEyMDI2MA==", "bodyText": "We could use MetricFilter#startsWith.", "url": "https://github.com/nuxeo/nuxeo/pull/4518#discussion_r539120260", "createdAt": "2020-12-09T08:54:05Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-runtime-stream/src/main/java/org/nuxeo/runtime/stream/StreamMetricsNuxeoReporter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.runtime.stream;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.lib.stream.computation.log.LogStreamManager;\n+import org.nuxeo.runtime.metrics.AbstractMetricsReporter;\n+\n+import io.dropwizard.metrics5.MetricAttribute;\n+import io.dropwizard.metrics5.MetricFilter;\n+import io.dropwizard.metrics5.MetricRegistry;\n+import io.dropwizard.metrics5.ScheduledReporter;\n+\n+/**\n+ * A Specialized Nuxeo Metrics Reporter that sends only Nuxeo Stream metrics into a Stream.\n+ *\n+ * @since 11.5\n+ */\n+public class StreamMetricsNuxeoReporter extends AbstractMetricsReporter {\n+\n+    private static final Logger log = LogManager.getLogger(StreamMetricsNuxeoReporter.class);\n+\n+    protected ScheduledReporter reporter;\n+\n+    protected static final MetricFilter STREAM_METRICS_FILTER = (name, metric) -> {\n+        String metricName = name.getKey();\n+        if (metricName.startsWith(\"nuxeo.streams\")) {\n+            return true;\n+        }\n+        return false;\n+    };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afd670931d0dc0a6d6208c40a0dce86f35bcfcb7"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3Njg3Ng==", "bodyText": "+1", "url": "https://github.com/nuxeo/nuxeo/pull/4518#discussion_r539276876", "createdAt": "2020-12-09T12:45:57Z", "author": {"login": "efge"}, "path": "modules/runtime/nuxeo-runtime-stream/src/main/java/org/nuxeo/runtime/stream/StreamMetricsNuxeoReporter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.runtime.stream;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.lib.stream.computation.log.LogStreamManager;\n+import org.nuxeo.runtime.metrics.AbstractMetricsReporter;\n+\n+import io.dropwizard.metrics5.MetricAttribute;\n+import io.dropwizard.metrics5.MetricFilter;\n+import io.dropwizard.metrics5.MetricRegistry;\n+import io.dropwizard.metrics5.ScheduledReporter;\n+\n+/**\n+ * A Specialized Nuxeo Metrics Reporter that sends only Nuxeo Stream metrics into a Stream.\n+ *\n+ * @since 11.5\n+ */\n+public class StreamMetricsNuxeoReporter extends AbstractMetricsReporter {\n+\n+    private static final Logger log = LogManager.getLogger(StreamMetricsNuxeoReporter.class);\n+\n+    protected ScheduledReporter reporter;\n+\n+    protected static final MetricFilter STREAM_METRICS_FILTER = (name, metric) -> {\n+        String metricName = name.getKey();\n+        if (metricName.startsWith(\"nuxeo.streams\")) {\n+            return true;\n+        }\n+        return false;\n+    };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEyMDI2MA=="}, "originalCommit": {"oid": "afd670931d0dc0a6d6208c40a0dce86f35bcfcb7"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTU0ODE3OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-runtime-stream/src/main/java/org/nuxeo/runtime/stream/StreamMetricsReporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMToyMDoxOVrOICPjEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMToyMDoxOVrOICPjEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMjgwMg==", "bodyText": "Is the comment still relevant?", "url": "https://github.com/nuxeo/nuxeo/pull/4518#discussion_r539222802", "createdAt": "2020-12-09T11:20:19Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-runtime-stream/src/main/java/org/nuxeo/runtime/stream/StreamMetricsReporter.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.runtime.stream;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.nuxeo.lib.stream.computation.log.LogStreamManager.METRICS_STREAM;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.nuxeo.lib.stream.StreamRuntimeException;\n+import org.nuxeo.lib.stream.computation.Record;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.cluster.ClusterService;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+import io.dropwizard.metrics5.Counter;\n+import io.dropwizard.metrics5.Gauge;\n+import io.dropwizard.metrics5.Histogram;\n+import io.dropwizard.metrics5.Meter;\n+import io.dropwizard.metrics5.MetricFilter;\n+import io.dropwizard.metrics5.MetricName;\n+import io.dropwizard.metrics5.MetricRegistry;\n+import io.dropwizard.metrics5.ScheduledReporter;\n+import io.dropwizard.metrics5.Snapshot;\n+import io.dropwizard.metrics5.Timer;\n+\n+/**\n+ * A Dropwizard Metrics Reporter that sends metrics into a Nuxeo Stream.\n+ *\n+ * @since 11.5\n+ */\n+public class StreamMetricsReporter extends ScheduledReporter {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    protected String hostIp;\n+\n+    protected String hostname;\n+\n+    protected String nodeId;\n+\n+    public StreamMetricsReporter(MetricRegistry registry, MetricFilter filter) {\n+        super(registry, \"stream-reporter\", filter, TimeUnit.SECONDS, TimeUnit.SECONDS);\n+        try {\n+            InetAddress host = InetAddress.getLocalHost();\n+            hostIp = host.getHostAddress();\n+            hostname = host.getHostName();\n+        } catch (UnknownHostException e) {\n+            hostIp = \"unknown\";\n+            hostname = \"unknown\";\n+        }\n+    }\n+\n+    protected String getNodeId() {\n+        if (nodeId == null) {\n+            ClusterService clusterService = Framework.getService(ClusterService.class);\n+            if (clusterService.isEnabled()) {\n+                // register cache invalidator\n+                nodeId = clusterService.getNodeId();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afd670931d0dc0a6d6208c40a0dce86f35bcfcb7"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTg5MTkzOnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-stream/src/main/java/org/nuxeo/lib/stream/computation/log/LogStreamManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo0MToxNFrOICSqHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo0MToxNFrOICSqHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3Mzc1Ng==", "bodyText": "You're caching a value (map) that will be used used in createStreamProcessor potentially by several concurrent threads, so you must be more careful about thread safety. Either don't cache at all, which I would recommend because creation of this map is cheap and createStreamProcessor is not called that much, or use an explicit lock or a double-check locking idiom with a volatile variable and assignment as the last step of the internal if.", "url": "https://github.com/nuxeo/nuxeo/pull/4518#discussion_r539273756", "createdAt": "2020-12-09T12:41:14Z", "author": {"login": "efge"}, "path": "modules/runtime/nuxeo-stream/src/main/java/org/nuxeo/lib/stream/computation/log/LogStreamManager.java", "diffHunk": "@@ -90,9 +112,30 @@ public StreamProcessor createStreamProcessor(String processorName) {\n         }\n         LogStreamProcessor processor = new LogStreamProcessor(this);\n         processor.init(topologies.get(processorName), settings.get(processorName));\n+        Map<String, String> meta = new HashMap<>();\n+        meta.put(\"processorName\",  processorName);\n+        meta.putAll(getSystemMetadata());\n+        append(PROCESSORS_STREAM, Record.of(meta.get(\"ip\"), processor.toJson(meta).getBytes(UTF_8)));\n         return processor;\n     }\n \n+    protected Map<String, String> getSystemMetadata() {\n+        if (systemMetadata == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21bc72aac4aa422b6356e14feab9bedb04ba54c0"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTkxNDk3OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-runtime-stream/src/main/java/org/nuxeo/runtime/stream/StreamMetricsNuxeoReporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo0NjozMFrOICS3ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo0NjozMFrOICS3ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3NzE3OQ==", "bodyText": "Override does nothing, you can remove the method", "url": "https://github.com/nuxeo/nuxeo/pull/4518#discussion_r539277179", "createdAt": "2020-12-09T12:46:30Z", "author": {"login": "efge"}, "path": "modules/runtime/nuxeo-runtime-stream/src/main/java/org/nuxeo/runtime/stream/StreamMetricsNuxeoReporter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.runtime.stream;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.lib.stream.computation.log.LogStreamManager;\n+import org.nuxeo.runtime.metrics.AbstractMetricsReporter;\n+\n+import io.dropwizard.metrics5.MetricAttribute;\n+import io.dropwizard.metrics5.MetricFilter;\n+import io.dropwizard.metrics5.MetricRegistry;\n+import io.dropwizard.metrics5.ScheduledReporter;\n+\n+/**\n+ * A Specialized Nuxeo Metrics Reporter that sends only Nuxeo Stream metrics into a Stream.\n+ *\n+ * @since 11.5\n+ */\n+public class StreamMetricsNuxeoReporter extends AbstractMetricsReporter {\n+\n+    private static final Logger log = LogManager.getLogger(StreamMetricsNuxeoReporter.class);\n+\n+    protected ScheduledReporter reporter;\n+\n+    protected static final MetricFilter STREAM_METRICS_FILTER = (name, metric) -> {\n+        String metricName = name.getKey();\n+        if (metricName.startsWith(\"nuxeo.streams\")) {\n+            return true;\n+        }\n+        return false;\n+    };\n+\n+    @Override\n+    public void init(long pollInterval, Map<String, String> options) {\n+        super.init(pollInterval, options);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c46bdc525b9e84407978958b929c26a5469483ec"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTkyODU1OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-runtime-stream/src/main/java/org/nuxeo/runtime/stream/StreamMetricsReporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo0OTozNFrOICS_bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo0OTozNFrOICS_bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3OTIxNQ==", "bodyText": "Could you add a comment explaining why we don't keep the full milliseconds granularity? (also no need for final; and this could be moved below the service check)", "url": "https://github.com/nuxeo/nuxeo/pull/4518#discussion_r539279215", "createdAt": "2020-12-09T12:49:34Z", "author": {"login": "efge"}, "path": "modules/runtime/nuxeo-runtime-stream/src/main/java/org/nuxeo/runtime/stream/StreamMetricsReporter.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.runtime.stream;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.nuxeo.lib.stream.computation.log.LogStreamManager.METRICS_STREAM;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.nuxeo.lib.stream.StreamRuntimeException;\n+import org.nuxeo.lib.stream.computation.Record;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.cluster.ClusterService;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+import io.dropwizard.metrics5.Counter;\n+import io.dropwizard.metrics5.Gauge;\n+import io.dropwizard.metrics5.Histogram;\n+import io.dropwizard.metrics5.Meter;\n+import io.dropwizard.metrics5.MetricFilter;\n+import io.dropwizard.metrics5.MetricName;\n+import io.dropwizard.metrics5.MetricRegistry;\n+import io.dropwizard.metrics5.ScheduledReporter;\n+import io.dropwizard.metrics5.Snapshot;\n+import io.dropwizard.metrics5.Timer;\n+\n+/**\n+ * A Dropwizard Metrics Reporter that sends metrics into a Nuxeo Stream.\n+ *\n+ * @since 11.5\n+ */\n+public class StreamMetricsReporter extends ScheduledReporter {\n+\n+    protected static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    protected String hostIp;\n+\n+    protected String hostname;\n+\n+    protected String nodeId;\n+\n+    public StreamMetricsReporter(MetricRegistry registry, MetricFilter filter) {\n+        super(registry, \"stream-reporter\", filter, TimeUnit.SECONDS, TimeUnit.SECONDS);\n+        try {\n+            InetAddress host = InetAddress.getLocalHost();\n+            hostIp = host.getHostAddress();\n+            hostname = host.getHostName();\n+        } catch (UnknownHostException e) {\n+            hostIp = \"unknown\";\n+            hostname = \"unknown\";\n+        }\n+    }\n+\n+    protected String getNodeId() {\n+        if (nodeId == null) {\n+            ClusterService clusterService = Framework.getService(ClusterService.class);\n+            if (clusterService.isEnabled()) {\n+                // register cache invalidator\n+                nodeId = clusterService.getNodeId();\n+            }\n+        }\n+        return nodeId;\n+    }\n+\n+    @Override\n+    public void report(SortedMap<MetricName, Gauge> gauges, SortedMap<MetricName, Counter> counters,\n+            SortedMap<MetricName, Histogram> histograms, SortedMap<MetricName, Meter> meters,\n+            SortedMap<MetricName, Timer> timers) {\n+        final long timestamp = System.currentTimeMillis() / 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c46bdc525b9e84407978958b929c26a5469483ec"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTk0NTc2OnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/introspection/StreamIntrospectionComputation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo1MzozMVrOICTJRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo1MzozMVrOICTJRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI4MTczMw==", "bodyText": "StringUtils.isBlank", "url": "https://github.com/nuxeo/nuxeo/pull/4518#discussion_r539281733", "createdAt": "2020-12-09T12:53:31Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/introspection/StreamIntrospectionComputation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.ecm.core.bulk.introspection;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.lib.stream.computation.AbstractComputation;\n+import org.nuxeo.lib.stream.computation.ComputationContext;\n+import org.nuxeo.lib.stream.computation.Record;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.kv.KeyValueService;\n+import org.nuxeo.runtime.kv.KeyValueStore;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+/**\n+ * A computation that reads processor and metrics streams to build a representation of stream activities in the cluster.\n+ * The representation is pushed to the KV Store.\n+ *\n+ * @since 11.5\n+ */\n+public class StreamIntrospectionComputation extends AbstractComputation {\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(\n+            StreamIntrospectionComputation.class);\n+\n+    public static final String NAME = \"stream/introspection\";\n+\n+    public static final String INTROSPECTION_KV_STORE = \"introspection\";\n+\n+    public static final String INTROSPECTION_KEY = \"streamIntrospection\";\n+\n+    protected static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    protected final Map<String, JsonNode> streams = new HashMap<>();\n+\n+    protected final Map<String, JsonNode> processors = new HashMap<>();\n+\n+    protected final Map<String, JsonNode> metrics = new HashMap<>();\n+\n+    protected static final long TTL_SECONDS = 300;\n+\n+    protected String model;\n+\n+    public StreamIntrospectionComputation() {\n+        super(NAME, 2, 0);\n+    }\n+\n+    @Override\n+    public void init(ComputationContext context) {\n+        if (context.isSpareComputation()) {\n+            log.info(\"Spare instance nothing to report\");\n+        } else {\n+            log.warn(\"Instance elected to introspect Nuxeo Stream activity\");\n+        }\n+        loadModel(getKvStore().getString(INTROSPECTION_KEY));\n+    }\n+\n+    protected void loadModel(String modelJson) {\n+        streams.clear();\n+        processors.clear();\n+        metrics.clear();\n+        if (modelJson == null || modelJson.isBlank()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfab3e32c99965f5f2adcd41c13a6c48e8284cbc"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTk3MDI5OnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/introspection/StreamIntrospectionConverter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo1ODo0OVrOICTXWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjo1ODo0OVrOICTXWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI4NTMzNw==", "bodyText": "Why not 0 too?", "url": "https://github.com/nuxeo/nuxeo/pull/4518#discussion_r539285337", "createdAt": "2020-12-09T12:58:49Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/introspection/StreamIntrospectionConverter.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.ecm.core.bulk.introspection;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.nuxeo.lib.stream.log.Name;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * @since 11.5\n+ */\n+public class StreamIntrospectionConverter {\n+    protected static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    protected final String json;\n+\n+    protected final JsonNode root;\n+\n+    public StreamIntrospectionConverter(String json) {\n+        this.json = json;\n+        try {\n+            this.root = OBJECT_MAPPER.readTree(json);\n+        } catch (JsonProcessingException e) {\n+            throw new IllegalArgumentException(\"Invalid JSON: \" + json, e);\n+        }\n+    }\n+\n+    public String getPuml() {\n+        StringBuilder ret = new StringBuilder();\n+        ret.append(\"@startuml\\n\");\n+        Map<String, String> streamMetrics = parseMetrics();\n+        ret.append(getPumlHeader(\"Stream Introspection at \" + streamMetrics.get(\"date\")));\n+        JsonNode node = root.get(\"streams\");\n+        if (node.isArray()) {\n+            for (JsonNode item : node) {\n+                dumpStream(ret, item, streamMetrics);\n+            }\n+        }\n+\n+        node = root.get(\"processors\");\n+        if (node.isArray()) {\n+            for (JsonNode item : node) {\n+                String host = item.at(\"/metadata/ip\").asText();\n+                // ret.append(\"rectangle node.\" + host + \" {\\n\");\n+                JsonNode computations = item.get(\"computations\");\n+                if (computations.isArray()) {\n+                    for (JsonNode computation : computations) {\n+                        dumpComputation(host, ret, computation, streamMetrics);\n+                    }\n+                }\n+                // ret.append(\"}\\n\");\n+                JsonNode topologies = item.get(\"topology\");\n+                if (topologies.isArray()) {\n+                    for (JsonNode topo : topologies) {\n+                        String comment = \"\";\n+                        String source = topo.get(0).asText();\n+                        String target = topo.get(1).asText();\n+                        if (target.startsWith(\"computation:\")) {\n+                            String stream = source.replace(\"stream:\", \"\");\n+                            String computation = target.replace(\"computation:\", \"\");\n+                            String lag = streamMetrics.get(stream + \":\" + computation + \":lag\");\n+                            String latency = streamMetrics.get(stream + \":\" + computation + \":latency\");\n+                            String pos = streamMetrics.get(stream + \":\" + computation + \":pos\");\n+                            String end = getStreamEnd(streamMetrics, stream);\n+                            // provide info only when there is a lag\n+                            if (lag != null && \"0\".equals(lag)) {\n+                                comment = String.format(\": %s/%s lag: %s, latency: %ss\", pos, end, lag, latency);\n+                            }\n+                        }\n+                        ret.append(String.format(\"%s==>%s%s%n\", getPumlIdentifierForHost(host, source),\n+                                getPumlIdentifierForHost(host, target), comment));\n+                    }\n+                }\n+\n+            }\n+        }\n+\n+        ret.append(\"@enduml\\n\");\n+        return ret.toString();\n+    }\n+\n+    protected Map<String, String> parseMetrics() {\n+        Map<String, String> streamMetrics = new HashMap<>();\n+        JsonNode node = root.get(\"metrics\");\n+        long timestamp = 0;\n+        if (node.isArray()) {\n+            for (JsonNode host : node) {\n+                String hostIp = host.get(\"ip\").asText();\n+                long metricTimestamp = host.get(\"timestamp\").asLong();\n+                if (metricTimestamp > timestamp) {\n+                    timestamp = metricTimestamp;\n+                }\n+                JsonNode hostMetrics = host.get(\"metrics\");\n+                if (hostMetrics.isArray()) {\n+                    for (JsonNode metric : hostMetrics) {\n+\n+                        if (metric.has(\"stream\")) {\n+                            String key = metric.get(\"k\").asText();\n+                            String streamName = Name.urnOfId(metric.get(\"stream\").asText());\n+                            String computationName = Name.urnOfId(metric.get(\"group\").asText());\n+                            if (\"nuxeo.streams.global.stream.group.end\".equals(key)) {\n+                                streamMetrics.put(streamName + \":end\", metric.get(\"v\").asText());\n+                            } else if (\"nuxeo.streams.global.stream.group.lag\".equals(key)) {\n+                                streamMetrics.put(streamName + \":\" + computationName + \":lag\",\n+                                        metric.get(\"v\").asText());\n+                            } else if (\"nuxeo.streams.global.stream.group.latency\".equals(key)) {\n+                                streamMetrics.put(streamName + \":\" + computationName + \":latency\",\n+                                        metric.get(\"v\").asText());\n+                            } else if (\"nuxeo.streams.global.stream.group.pos\".equals(key)) {\n+                                streamMetrics.put(streamName + \":\" + computationName + \":pos\",\n+                                        metric.get(\"v\").asText());\n+                            }\n+                        } else if (metric.get(\"k\").asText().endsWith(\"processRecord\")) {\n+                            int count = metric.get(\"count\").asInt();\n+                            if (count == 0) {\n+                                continue;\n+                            }\n+                            String computationName = Name.urnOfId(metric.get(\"computation\").asText());\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":count\", metric.get(\"count\").asText());\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":sum\",\n+                                    getNiceDouble3(metric.get(\"sum\").asDouble() / 1000000000));\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":p50\",\n+                                    getNiceDouble3(metric.get(\"p50\").asDouble()));\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":mean\",\n+                                    getNiceDouble3(metric.get(\"mean\").asDouble()));\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":p99\",\n+                                    getNiceDouble3(metric.get(\"p99\").asDouble()));\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":rate1m\",\n+                                    getNiceDouble(metric.get(\"rate1m\").asDouble()));\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":rate5m\",\n+                                    getNiceDouble(metric.get(\"rate5m\").asDouble()));\n+                        } else if (metric.get(\"k\").asText().endsWith(\"processTimer\")) {\n+                            int count = metric.get(\"count\").asInt();\n+                            if (count == 0) {\n+                                continue;\n+                            }\n+                            String computationName = Name.urnOfId(metric.get(\"computation\").asText());\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":timer:count\",\n+                                    metric.get(\"count\").asText());\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":timer:sum\",\n+                                    getNiceDouble3(metric.get(\"sum\").asDouble() / 1000000000));\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":timer:p50\",\n+                                    getNiceDouble3(metric.get(\"p50\").asDouble()));\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":timer:mean\",\n+                                    getNiceDouble3(metric.get(\"mean\").asDouble()));\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":timer:p99\",\n+                                    getNiceDouble3(metric.get(\"p99\").asDouble()));\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":timer:rate1m\",\n+                                    getNiceDouble(metric.get(\"rate1m\").asDouble()));\n+                            streamMetrics.put(computationName + \":\" + hostIp + \":timer:rate5m\",\n+                                    getNiceDouble(metric.get(\"rate5m\").asDouble()));\n+                        } else if (metric.get(\"k\").asText().endsWith(\"computation.failure\")) {\n+                            int failure = metric.get(\"v\").asInt();\n+                            if (failure > 0) {\n+                                String computationName = Name.urnOfId(metric.get(\"computation\").asText()) + \":\"\n+                                        + hostIp;\n+                                streamMetrics.put(computationName + \":failure\", metric.get(\"v\").asText());\n+                            }\n+                        } else if (metric.get(\"k\").asText().endsWith(\"stream.failure\")) {\n+                            int value = metric.get(\"v\").asInt();\n+                            if (value > 0) {\n+                                streamMetrics.put(hostIp + \":failure\", metric.get(\"v\").asText());\n+                            }\n+                        } else if (metric.get(\"k\").asText().endsWith(\"computation.skippedRecord\")) {\n+                            int value = metric.get(\"v\").asInt();\n+                            if (value > 0) {\n+                                String computationName = Name.urnOfId(metric.get(\"computation\").asText()) + \":\"\n+                                        + hostIp;\n+                                streamMetrics.put(computationName + \":skipped\", metric.get(\"v\").asText());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        streamMetrics.put(\"timestamp\", String.valueOf(timestamp));\n+        streamMetrics.put(\"date\", Instant.ofEpochSecond(timestamp).toString());\n+        return streamMetrics;\n+    }\n+\n+    protected String getNiceDouble(Double number) {\n+        return String.format(\"%.2f\", number);\n+    }\n+\n+    protected String getNiceDouble3(Double number) {\n+        return String.format(\"%.3f\", number);\n+    }\n+\n+    protected String getPumlHeader(String title) {\n+        return \"title \" + title + \"\\n\\n\" //\n+                + \"skinparam defaultFontName Courier\\n\" + \"skinparam handwritten false\\n\" //\n+                + \"skinparam queueBackgroundColor LightYellow\\n\" //\n+                + \"skinparam nodeBackgroundColor Azure\\n\" //\n+                + \"skinparam componentBackgroundColor Azure\\n\" //\n+                + \"skinparam nodebackgroundColor<<failure>> Yellow\\n\" //\n+                + \"skinparam componentbackgroundColor<<failure>> Yellow\\n\" //\n+                + \"skinparam component {\\n\"\n+                + \"  BorderColor black\\n\" + \"  ArrowColor #CC6655\\n\" + \"}\\n\";\n+    }\n+\n+    protected String getPumlIdentifierForHost(String host, String id) {\n+        if (id.startsWith(\"computation:\")) {\n+            return getPumlIdentifier(id + \":\" + host);\n+        }\n+        return getPumlIdentifier(id);\n+    }\n+\n+    protected void dumpStream(StringBuilder ret, JsonNode item, Map<String, String> metrics) {\n+        String name = item.get(\"name\").asText();\n+        String partitions = item.get(\"partitions\").asText();\n+        String codec = item.get(\"codec\").asText();\n+        ret.append(String.format(\"queue %s [%s%n----%npartitions: %s%ncodec: %s%n-----%nrecords: %s]%n\",\n+                getPumlIdentifier(\"stream:\" + name), name, partitions, codec, getStreamEnd(metrics, name)));\n+    }\n+\n+    protected String getStreamEnd(Map<String, String> metrics, String name) {\n+        String ret = metrics.get(name + \":end\");\n+        return ret == null ? \"0\" : ret;\n+    }\n+\n+    protected void dumpComputation(String host, StringBuilder ret, JsonNode item, Map<String, String> metrics) {\n+        String name = item.get(\"name\").asText();\n+        String threads = item.get(\"threads\").asText();\n+        String continueOnFailure = item.get(\"continueOnFailure\").asText();\n+        String failure = \"\";\n+        if (metrics.containsKey(name + \":\" + host + \":failure\")) {\n+            failure = \" <<failure>>\";\n+        }\n+        ret.append(String.format(\"component %s %s[%s%n----%nthreads: %s%ncontinue on failure: %s%n%s%s]%n\",\n+                getPumlIdentifier(\"computation:\" + name + \":\" + host), failure, name + \" on \" + host, threads, continueOnFailure,\n+                getBatchInfo(item), getComputationMetrics(host, name, item, metrics)));\n+    }\n+\n+    protected String getComputationMetrics(String host, String name, JsonNode item, Map<String, String> metrics) {\n+        String ret = \"\";\n+        String baseKey = name + \":\" + host;\n+        if (!metrics.containsKey(baseKey + \":count\")) {\n+            return ret;\n+        }\n+        ret += \"\\n----\\n\";\n+        if (metrics.containsKey(baseKey + \":failure\")) {\n+            ret += \"FAILURE: \" + metrics.get(baseKey + \":failure\") + \"\\n\";\n+        }\n+        ret += \"record count: \" + metrics.get(baseKey + \":count\") + \", total: \" + metrics.get(baseKey + \":sum\") + \"s\\n\";\n+        if (metrics.containsKey(baseKey + \":skipped\")) {\n+            ret += \"record skipped: \" + metrics.get(baseKey + \":skipped\") + \"\\n\";\n+        }\n+        ret += \"mean: \" + metrics.get(baseKey + \":mean\") + \"s, p50: \" + metrics.get(baseKey + \":p50\") + \"s, p99: \"\n+                + metrics.get(baseKey + \":p99\") + \"s\\n\";\n+        ret += \"rate 1min: \" + metrics.get(baseKey + \":rate1m\") + \"op/s, 5min: \" + metrics.get(baseKey + \":rate5m\")\n+                + \"op/s\";\n+        if (!metrics.containsKey(baseKey + \":timer:count\")) {\n+            return ret;\n+        }\n+        ret += \"\\n----\\n\";\n+        baseKey = baseKey + \":timer\";\n+        ret += \"timer count: \" + metrics.get(baseKey + \":count\") + \", total: \" + metrics.get(baseKey + \":sum\") + \"s\\n\";\n+        ret += \"mean: \" + metrics.get(baseKey + \":mean\") + \"s, p50: \" + metrics.get(baseKey + \":p50\") + \"s, p99: \"\n+                + metrics.get(baseKey + \":p99\") + \"s\\n\";\n+        ret += \"rate 5min: \" + metrics.get(baseKey + \":rate5m\") + \"op/s\";\n+        return ret;\n+    }\n+\n+    protected String getBatchInfo(JsonNode item) {\n+        String ret = \"\";\n+        int batchCapacity = item.get(\"batchCapacity\").asInt();\n+        if (batchCapacity > 1) {\n+            int batchThresholdMs = item.get(\"batchCapacity\").asInt();\n+            ret += \"batch \" + item.get(\"batchCapacity\").asText() + \" \" + batchThresholdMs + \"ms\\n\";\n+        } else {\n+            ret += \"no batch\\n\";\n+        }\n+        int retry = item.get(\"maxRetries\").asInt();\n+        if (retry > 1) {\n+            ret += \"max retry: \" + item.get(\"maxRetries\").asText() + \", delay: \" + item.get(\"retryDelayMs\").asText()\n+                    + \"ms\";\n+        } else {\n+            ret += \"no retry\";\n+        }\n+        return ret;\n+    }\n+\n+    protected String getPumlIdentifier(String name) {\n+        return name.replaceAll(\"[^a-zA-Z1-9]\", \".\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afd670931d0dc0a6d6208c40a0dce86f35bcfcb7"}, "originalPosition": 306}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4274, "cost": 1, "resetAt": "2021-11-03T18:41:40Z"}}}