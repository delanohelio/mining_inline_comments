{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5NjIzMzI2", "number": 3981, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwOTo0MDoxNlrOD8Zs8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDoyMjoyN1rOD-Plaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjYyMjU4OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-runtime-jtajca/src/main/java/org/nuxeo/runtime/transaction/TransactionHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwOTo0MDoxNlrOGVURkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToxMDo0N1rOGVXZGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNTQ1OQ==", "bodyText": "is the method idempotent?", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r425005459", "createdAt": "2020-05-14T09:40:16Z", "author": {"login": "bdelbosc"}, "path": "modules/runtime/nuxeo-runtime-jtajca/src/main/java/org/nuxeo/runtime/transaction/TransactionHelper.java", "diffHunk": "@@ -533,6 +534,23 @@ public static void registerSynchronization(Synchronization handler) {\n         }\n     }\n \n+    /**\n+     * Enlists a XA resource in the current transaction.\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd86c005bccbce4675b037428f2a66fb53787227"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA1NjUzOQ==", "bodyText": "No it's a direct link to the TransactionManager's identical method. In a previous version of the code it was used in many more places but now only one test (in WorkManagerTXTest) uses it... I think I'll keep it though as it doesn't do harm.", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r425056539", "createdAt": "2020-05-14T11:10:47Z", "author": {"login": "efge"}, "path": "modules/runtime/nuxeo-runtime-jtajca/src/main/java/org/nuxeo/runtime/transaction/TransactionHelper.java", "diffHunk": "@@ -533,6 +534,23 @@ public static void registerSynchronization(Synchronization handler) {\n         }\n     }\n \n+    /**\n+     * Enlists a XA resource in the current transaction.\n+     *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNTQ1OQ=="}, "originalCommit": {"oid": "cd86c005bccbce4675b037428f2a66fb53787227"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjYzNDUyOnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql/src/main/java/org/nuxeo/ecm/core/storage/sql/jdbc/SQLInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwOTo0MzoxM1rOGVUZKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTowODozN1rOGVXVSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNzQwMw==", "bodyText": "is this required for test purpose?", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r425007403", "createdAt": "2020-05-14T09:43:13Z", "author": {"login": "bdelbosc"}, "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql/src/main/java/org/nuxeo/ecm/core/storage/sql/jdbc/SQLInfo.java", "diffHunk": "@@ -114,7 +114,7 @@\n \n     private final Map<String, Column> copyIdColumnMap;\n \n-    protected final Map<String, SQLInfoSelect> selectFragmentById;\n+    public final Map<String, SQLInfoSelect> selectFragmentById;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9840a6aea9bc3efb9fd5bca4f9faa96c554a0b01"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA1NTU2MA==", "bodyText": "No it's for VCSLockManager which is in a different package.", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r425055560", "createdAt": "2020-05-14T11:08:37Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql/src/main/java/org/nuxeo/ecm/core/storage/sql/jdbc/SQLInfo.java", "diffHunk": "@@ -114,7 +114,7 @@\n \n     private final Map<String, Column> copyIdColumnMap;\n \n-    protected final Map<String, SQLInfoSelect> selectFragmentById;\n+    public final Map<String, SQLInfoSelect> selectFragmentById;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNzQwMw=="}, "originalCommit": {"oid": "9840a6aea9bc3efb9fd5bca4f9faa96c554a0b01"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjcxNDY3OnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-management-jtajca/src/test/resources/ds-contrib-with-fatal.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMDowNDo0MlrOGVVNJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTowNzoyNVrOGVXSmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAyMDcxMA==", "bodyText": "Why changing names? maxPoolSize sounds better than maxTotal.", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r425020710", "createdAt": "2020-05-14T10:04:42Z", "author": {"login": "bdelbosc"}, "path": "modules/core/nuxeo-core-management-jtajca/src/test/resources/ds-contrib-with-fatal.xml", "diffHunk": "@@ -2,11 +2,10 @@\n <component name=\"org.nuxeo.runtime.jtajca.management.test.ds\">\n   <extension target=\"org.nuxeo.runtime.datasource\" point=\"datasources\">\n     <datasource name=\"jdbc/canrollback\" driverClassName=\"${nuxeo.test.vcs.driver}\"\n-      maxPoolSize=\"20\" minPoolSize=\"5\">\n+      maxTotal=\"20\" minTotal=\"5\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12aeac8365d3d928409611a0434ec32968a10ff2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA1NDg3NQ==", "bodyText": "I'm re-aligning with the official standard names of Apache DBCP (and therefore also Tomcat). The old names are still kept for compat though (see PooledDataSourceRegistry.createPooledDataSource)", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r425054875", "createdAt": "2020-05-14T11:07:25Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-management-jtajca/src/test/resources/ds-contrib-with-fatal.xml", "diffHunk": "@@ -2,11 +2,10 @@\n <component name=\"org.nuxeo.runtime.jtajca.management.test.ds\">\n   <extension target=\"org.nuxeo.runtime.datasource\" point=\"datasources\">\n     <datasource name=\"jdbc/canrollback\" driverClassName=\"${nuxeo.test.vcs.driver}\"\n-      maxPoolSize=\"20\" minPoolSize=\"5\">\n+      maxTotal=\"20\" minTotal=\"5\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAyMDcxMA=="}, "originalCommit": {"oid": "12aeac8365d3d928409611a0434ec32968a10ff2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDY0NDkzOnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-api/src/main/java/org/nuxeo/ecm/core/api/repository/PoolConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwODo0MjozMlrOGV74BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNjoxMDowMVrOGWbKhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY1NDI3Ng==", "bodyText": "Wrong log message stating about geronimo which is removed in this PR.", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r425654276", "createdAt": "2020-05-15T08:42:32Z", "author": {"login": "kevinleturc"}, "path": "modules/core/nuxeo-core-api/src/main/java/org/nuxeo/ecm/core/api/repository/PoolConfiguration.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * (C) Copyright 2006-2012 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ *     Julien Carsique\n+ */\n+package org.nuxeo.ecm.core.api.repository;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.common.xmap.annotation.XNode;\n+import org.nuxeo.common.xmap.annotation.XObject;\n+\n+/**\n+ * Descriptor of the pool of low-level Nuxeo Sessions.\n+ *\n+ * @since 5.6\n+ */\n+@XObject(\"pool\")\n+public class PoolConfiguration {\n+\n+    private static final Logger log = LogManager.getLogger(PoolConfiguration.class);\n+\n+    public static final int DEFAULT_MAX_POOL_SIZE = 20;\n+\n+    public static final int DEFAULT_MIN_POOL_SIZE = 0;\n+\n+    public static final int DEFAULT_BLOCKING_TIMEOUT_MILLIS = 100;\n+\n+    @XNode(\"@maxPoolSize\")\n+    private Integer maxPoolSize;\n+\n+    @XNode(\"@minPoolSize\")\n+    private Integer minPoolSize;\n+\n+    @XNode(\"@blockingTimeoutMillis\")\n+    private Integer blockingTimeoutMillis;\n+\n+    public PoolConfiguration() {\n+    }\n+\n+    /** Copy constructor. */\n+    public PoolConfiguration(PoolConfiguration other) {\n+        maxPoolSize = other.maxPoolSize;\n+        minPoolSize = other.minPoolSize;\n+        blockingTimeoutMillis = other.blockingTimeoutMillis;\n+    }\n+\n+    public void merge(PoolConfiguration other) {\n+        if (other.maxPoolSize != null) {\n+            maxPoolSize = other.maxPoolSize;\n+        }\n+        if (other.minPoolSize != null) {\n+            minPoolSize = other.minPoolSize;\n+        }\n+        if (other.blockingTimeoutMillis != null) {\n+            blockingTimeoutMillis = other.blockingTimeoutMillis;\n+        }\n+    }\n+\n+    private static int defaultInt(Integer value, int def) {\n+        return value == null ? def : value.intValue();\n+    }\n+\n+    public int getMaxPoolSize() {\n+        return defaultInt(maxPoolSize, DEFAULT_MAX_POOL_SIZE);\n+    }\n+\n+    public int getMinPoolSize() {\n+        return defaultInt(minPoolSize, DEFAULT_MIN_POOL_SIZE);\n+    }\n+\n+    public int getBlockingTimeoutMillis() {\n+        return defaultInt(blockingTimeoutMillis, DEFAULT_BLOCKING_TIMEOUT_MILLIS);\n+    }\n+\n+    public void setMaxPoolSize(int maxPoolSize) {\n+        this.maxPoolSize = Integer.valueOf(maxPoolSize);\n+    }\n+\n+    public void setMinPoolSize(int minPoolSize) {\n+        this.minPoolSize = Integer.valueOf(minPoolSize);\n+    }\n+\n+    public void setBlockingTimeoutMillis(int blockingTimeoutMillis) {\n+        this.blockingTimeoutMillis = Integer.valueOf(blockingTimeoutMillis);\n+    }\n+\n+    @XNode(\"@maxActive\")\n+    public void setMaxActive(int num) {\n+        maxPoolSize = num;\n+        log.warn(\n+                \"maxActive deprecated dbcp pool attribute usage, should use maxPoolSize geronimo pool attribute instead\");\n+    }\n+\n+    @XNode(\"@maxIdle\")\n+    public void setMaxIdle(int num) {\n+        minPoolSize = num;\n+        log.warn(\n+                \"maxIdle deprecated dbcp pool attribute usage, should use minPoolSize geronimo pool attribute instead\");\n+    }\n+\n+    @XNode(\"@maxWait\")\n+    public void setMaxWait(int num) {\n+        blockingTimeoutMillis = num;\n+        log.warn(\n+                \"maxWait deprecated dbcp pool attribute usage, should use blockingTimeoutMillis geronimo pool attribute instead\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d7adf76e8337076b0ff2c661508da5604e53fe7"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2NjkxOQ==", "bodyText": "I'm removing the warn completely, as we have no intention of removing the old name", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r426166919", "createdAt": "2020-05-16T16:10:01Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-api/src/main/java/org/nuxeo/ecm/core/api/repository/PoolConfiguration.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * (C) Copyright 2006-2012 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ *     Julien Carsique\n+ */\n+package org.nuxeo.ecm.core.api.repository;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.common.xmap.annotation.XNode;\n+import org.nuxeo.common.xmap.annotation.XObject;\n+\n+/**\n+ * Descriptor of the pool of low-level Nuxeo Sessions.\n+ *\n+ * @since 5.6\n+ */\n+@XObject(\"pool\")\n+public class PoolConfiguration {\n+\n+    private static final Logger log = LogManager.getLogger(PoolConfiguration.class);\n+\n+    public static final int DEFAULT_MAX_POOL_SIZE = 20;\n+\n+    public static final int DEFAULT_MIN_POOL_SIZE = 0;\n+\n+    public static final int DEFAULT_BLOCKING_TIMEOUT_MILLIS = 100;\n+\n+    @XNode(\"@maxPoolSize\")\n+    private Integer maxPoolSize;\n+\n+    @XNode(\"@minPoolSize\")\n+    private Integer minPoolSize;\n+\n+    @XNode(\"@blockingTimeoutMillis\")\n+    private Integer blockingTimeoutMillis;\n+\n+    public PoolConfiguration() {\n+    }\n+\n+    /** Copy constructor. */\n+    public PoolConfiguration(PoolConfiguration other) {\n+        maxPoolSize = other.maxPoolSize;\n+        minPoolSize = other.minPoolSize;\n+        blockingTimeoutMillis = other.blockingTimeoutMillis;\n+    }\n+\n+    public void merge(PoolConfiguration other) {\n+        if (other.maxPoolSize != null) {\n+            maxPoolSize = other.maxPoolSize;\n+        }\n+        if (other.minPoolSize != null) {\n+            minPoolSize = other.minPoolSize;\n+        }\n+        if (other.blockingTimeoutMillis != null) {\n+            blockingTimeoutMillis = other.blockingTimeoutMillis;\n+        }\n+    }\n+\n+    private static int defaultInt(Integer value, int def) {\n+        return value == null ? def : value.intValue();\n+    }\n+\n+    public int getMaxPoolSize() {\n+        return defaultInt(maxPoolSize, DEFAULT_MAX_POOL_SIZE);\n+    }\n+\n+    public int getMinPoolSize() {\n+        return defaultInt(minPoolSize, DEFAULT_MIN_POOL_SIZE);\n+    }\n+\n+    public int getBlockingTimeoutMillis() {\n+        return defaultInt(blockingTimeoutMillis, DEFAULT_BLOCKING_TIMEOUT_MILLIS);\n+    }\n+\n+    public void setMaxPoolSize(int maxPoolSize) {\n+        this.maxPoolSize = Integer.valueOf(maxPoolSize);\n+    }\n+\n+    public void setMinPoolSize(int minPoolSize) {\n+        this.minPoolSize = Integer.valueOf(minPoolSize);\n+    }\n+\n+    public void setBlockingTimeoutMillis(int blockingTimeoutMillis) {\n+        this.blockingTimeoutMillis = Integer.valueOf(blockingTimeoutMillis);\n+    }\n+\n+    @XNode(\"@maxActive\")\n+    public void setMaxActive(int num) {\n+        maxPoolSize = num;\n+        log.warn(\n+                \"maxActive deprecated dbcp pool attribute usage, should use maxPoolSize geronimo pool attribute instead\");\n+    }\n+\n+    @XNode(\"@maxIdle\")\n+    public void setMaxIdle(int num) {\n+        minPoolSize = num;\n+        log.warn(\n+                \"maxIdle deprecated dbcp pool attribute usage, should use minPoolSize geronimo pool attribute instead\");\n+    }\n+\n+    @XNode(\"@maxWait\")\n+    public void setMaxWait(int num) {\n+        blockingTimeoutMillis = num;\n+        log.warn(\n+                \"maxWait deprecated dbcp pool attribute usage, should use blockingTimeoutMillis geronimo pool attribute instead\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY1NDI3Ng=="}, "originalCommit": {"oid": "8d7adf76e8337076b0ff2c661508da5604e53fe7"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDgzODg4OnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestSQLRepositoryAPI.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTozOTozMVrOGV9zxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNjoxMToyN1rOGWbK_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4NTk1OQ==", "bodyText": "The ignore now applies to testOptimisticLockingWithExplicitChangeToken which wasn't the case before, is it wanted?", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r425685959", "createdAt": "2020-05-15T09:39:31Z", "author": {"login": "kevinleturc"}, "path": "modules/core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestSQLRepositoryAPI.java", "diffHunk": "@@ -5101,109 +5053,6 @@ public void testChangeTokenForProxy() {\n     }\n \n     @ConditionalIgnoreRule.Ignore(condition = IgnorePostgreSQL.class, cause = \"NXP-29039\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d7adf76e8337076b0ff2c661508da5604e53fe7"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2NzAzOA==", "bodyText": "Thanks, well spotted.", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r426167038", "createdAt": "2020-05-16T16:11:27Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestSQLRepositoryAPI.java", "diffHunk": "@@ -5101,109 +5053,6 @@ public void testChangeTokenForProxy() {\n     }\n \n     @ConditionalIgnoreRule.Ignore(condition = IgnorePostgreSQL.class, cause = \"NXP-29039\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4NTk1OQ=="}, "originalCommit": {"oid": "8d7adf76e8337076b0ff2c661508da5604e53fe7"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDg3NDUwOnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/repository/RepositoryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTo1MDoxOFrOGV-J9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNjoxNjozOFrOGWbMmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MTYzNg==", "bodyText": "Are such overrides needed?", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r425691636", "createdAt": "2020-05-15T09:50:18Z", "author": {"login": "kevinleturc"}, "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/repository/RepositoryService.java", "diffHunk": "@@ -196,7 +261,155 @@ protected RepositoryFactory getFactory(String repositoryName) {\n     }\n \n     public int getActiveSessionsCount() {\n-        return repositories.values().stream().mapToInt(Repository::getActiveSessionsCount).sum();\n+        return pool.getNumActive();\n+    }\n+\n+    public int getActiveSessionsCount(String repositoryName) {\n+        return pool.getNumActive(repositoryName);\n+    }\n+\n+    /**\n+     * Thread-local sessions allocated, per repository.\n+     */\n+    protected static final Map<String, ThreadLocal<Session>> SESSIONS = new ConcurrentHashMap<>(1);\n+\n+    /**\n+     * Gets a session.\n+     * <p>\n+     * The session is first looked up in the current transaction, otherwise fetched from a pool.\n+     *\n+     * @param repositoryName the repository name\n+     * @return the session\n+     * @since 11.1\n+     */\n+    public Session getSession(String repositoryName) {\n+        if (!TransactionHelper.isTransactionActiveOrMarkedRollback()) {\n+            throw new NuxeoException(\"Cannot use a session outside a transaction\");\n+        }\n+        TransactionHelper.checkTransactionTimeout();\n+        ThreadLocal<Session> threadSessions = SESSIONS.computeIfAbsent(repositoryName, r -> new ThreadLocal<>());\n+        Session session = threadSessions.get();\n+        if (session == null) {\n+            if (!TransactionHelper.isTransactionActive()) {\n+                throw new NuxeoException(\"Cannot use a session when transaction is marked rollback-only\");\n+            }\n+            session = getSessionFromPool(repositoryName, threadSessions::remove);\n+            threadSessions.set(session);\n+        }\n+        return session;\n+    }\n+\n+    protected Session getSessionFromPool(String repositoryName, Runnable cleanup) {\n+        Session session;\n+        try {\n+            session = pool.borrowObject(repositoryName);\n+        } catch (NoSuchElementException e) {\n+            String err = String.format(\n+                    \"Connection pool is fully used,\"\n+                            + \" consider increasing nuxeo.vcs.blocking-timeout-millis (currently %s)\"\n+                            + \" or nuxeo.vcs.max-pool-size (currently %s)\",\n+                    poolConfig.getBlockingTimeoutMillis(), poolConfig.getMaxPoolSize());\n+            throw new NuxeoException(err, e);\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            if (e instanceof InterruptedException) { // NOSONAR\n+                Thread.currentThread().interrupt();\n+            }\n+            throw new NuxeoException(e);\n+        }\n+        // register synchronization for transaction commit/rollback\n+        // and to return to pool and remove from thread-local at end of transaction\n+        TransactionHelper.registerSynchronization(new SessionSynchronization(session, cleanup));\n+        session.start();\n+        return session;\n+    }\n+\n+    /** @since 11.1 */\n+    protected class SessionSynchronization implements Synchronization {\n+\n+        protected final Session session;\n+\n+        protected final Runnable cleanup;\n+\n+        protected SessionSynchronization(Session session, Runnable cleanup) {\n+            this.session = session;\n+            this.cleanup = cleanup;\n+        }\n+\n+        @Override\n+        public void beforeCompletion() {\n+            session.end();\n+        }\n+\n+        @Override\n+        public void afterCompletion(int status) {\n+            boolean completedAbruptly = true;\n+            try {\n+                if (status == STATUS_COMMITTED) {\n+                    session.commit();\n+                } else if (status == STATUS_ROLLEDBACK) {\n+                    session.rollback();\n+                } else {\n+                    log.error(\"Unexpected afterCompletion status: \" + status);\n+                }\n+                completedAbruptly = false;\n+            } finally {\n+                try {\n+                    String repositoryName = session.getRepositoryName();\n+                    if (status == STATUS_COMMITTED && !completedAbruptly) {\n+                        pool.returnObject(repositoryName, session);\n+                    } else {\n+                        pool.invalidateObject(repositoryName, session);\n+                    }\n+                } catch (Exception e) {\n+                    if (e instanceof InterruptedException) { // NOSONAR\n+                        Thread.currentThread().interrupt();\n+                    }\n+                    log.error(e, e);\n+                } finally {\n+                    cleanup.run();\n+                }\n+            }\n+        }\n+    }\n+\n+    /** @since 11.1 */\n+    protected class SessionFactory extends BaseKeyedPooledObjectFactory<String, Session> {\n+\n+        @Override\n+        public Session create(String repositoryName) throws Exception {\n+            Repository repository = getRepository(repositoryName);\n+            if (repository == null) {\n+                throw new DocumentNotFoundException(\"No such repository: \" + repositoryName);\n+            }\n+            return repository.getSession();\n+        }\n+\n+        @Override\n+        public PooledObject<Session> wrap(Session session) {\n+            return new DefaultPooledObject<>(session);\n+        }\n+\n+        @Override\n+        public void activateObject(String repositoryName, PooledObject<Session> p) throws Exception {\n+            super.activateObject(repositoryName, p);\n+        }\n+\n+        @Override\n+        public boolean validateObject(String repositoryName, PooledObject<Session> p) {\n+            return super.validateObject(repositoryName, p);\n+        }\n+\n+        @Override\n+        public void passivateObject(String repositoryName, PooledObject<Session> p) throws Exception {\n+            super.passivateObject(repositoryName, p);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d7adf76e8337076b0ff2c661508da5604e53fe7"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2NzQ0OA==", "bodyText": "No, I'll remove them.", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r426167448", "createdAt": "2020-05-16T16:16:38Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/repository/RepositoryService.java", "diffHunk": "@@ -196,7 +261,155 @@ protected RepositoryFactory getFactory(String repositoryName) {\n     }\n \n     public int getActiveSessionsCount() {\n-        return repositories.values().stream().mapToInt(Repository::getActiveSessionsCount).sum();\n+        return pool.getNumActive();\n+    }\n+\n+    public int getActiveSessionsCount(String repositoryName) {\n+        return pool.getNumActive(repositoryName);\n+    }\n+\n+    /**\n+     * Thread-local sessions allocated, per repository.\n+     */\n+    protected static final Map<String, ThreadLocal<Session>> SESSIONS = new ConcurrentHashMap<>(1);\n+\n+    /**\n+     * Gets a session.\n+     * <p>\n+     * The session is first looked up in the current transaction, otherwise fetched from a pool.\n+     *\n+     * @param repositoryName the repository name\n+     * @return the session\n+     * @since 11.1\n+     */\n+    public Session getSession(String repositoryName) {\n+        if (!TransactionHelper.isTransactionActiveOrMarkedRollback()) {\n+            throw new NuxeoException(\"Cannot use a session outside a transaction\");\n+        }\n+        TransactionHelper.checkTransactionTimeout();\n+        ThreadLocal<Session> threadSessions = SESSIONS.computeIfAbsent(repositoryName, r -> new ThreadLocal<>());\n+        Session session = threadSessions.get();\n+        if (session == null) {\n+            if (!TransactionHelper.isTransactionActive()) {\n+                throw new NuxeoException(\"Cannot use a session when transaction is marked rollback-only\");\n+            }\n+            session = getSessionFromPool(repositoryName, threadSessions::remove);\n+            threadSessions.set(session);\n+        }\n+        return session;\n+    }\n+\n+    protected Session getSessionFromPool(String repositoryName, Runnable cleanup) {\n+        Session session;\n+        try {\n+            session = pool.borrowObject(repositoryName);\n+        } catch (NoSuchElementException e) {\n+            String err = String.format(\n+                    \"Connection pool is fully used,\"\n+                            + \" consider increasing nuxeo.vcs.blocking-timeout-millis (currently %s)\"\n+                            + \" or nuxeo.vcs.max-pool-size (currently %s)\",\n+                    poolConfig.getBlockingTimeoutMillis(), poolConfig.getMaxPoolSize());\n+            throw new NuxeoException(err, e);\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            if (e instanceof InterruptedException) { // NOSONAR\n+                Thread.currentThread().interrupt();\n+            }\n+            throw new NuxeoException(e);\n+        }\n+        // register synchronization for transaction commit/rollback\n+        // and to return to pool and remove from thread-local at end of transaction\n+        TransactionHelper.registerSynchronization(new SessionSynchronization(session, cleanup));\n+        session.start();\n+        return session;\n+    }\n+\n+    /** @since 11.1 */\n+    protected class SessionSynchronization implements Synchronization {\n+\n+        protected final Session session;\n+\n+        protected final Runnable cleanup;\n+\n+        protected SessionSynchronization(Session session, Runnable cleanup) {\n+            this.session = session;\n+            this.cleanup = cleanup;\n+        }\n+\n+        @Override\n+        public void beforeCompletion() {\n+            session.end();\n+        }\n+\n+        @Override\n+        public void afterCompletion(int status) {\n+            boolean completedAbruptly = true;\n+            try {\n+                if (status == STATUS_COMMITTED) {\n+                    session.commit();\n+                } else if (status == STATUS_ROLLEDBACK) {\n+                    session.rollback();\n+                } else {\n+                    log.error(\"Unexpected afterCompletion status: \" + status);\n+                }\n+                completedAbruptly = false;\n+            } finally {\n+                try {\n+                    String repositoryName = session.getRepositoryName();\n+                    if (status == STATUS_COMMITTED && !completedAbruptly) {\n+                        pool.returnObject(repositoryName, session);\n+                    } else {\n+                        pool.invalidateObject(repositoryName, session);\n+                    }\n+                } catch (Exception e) {\n+                    if (e instanceof InterruptedException) { // NOSONAR\n+                        Thread.currentThread().interrupt();\n+                    }\n+                    log.error(e, e);\n+                } finally {\n+                    cleanup.run();\n+                }\n+            }\n+        }\n+    }\n+\n+    /** @since 11.1 */\n+    protected class SessionFactory extends BaseKeyedPooledObjectFactory<String, Session> {\n+\n+        @Override\n+        public Session create(String repositoryName) throws Exception {\n+            Repository repository = getRepository(repositoryName);\n+            if (repository == null) {\n+                throw new DocumentNotFoundException(\"No such repository: \" + repositoryName);\n+            }\n+            return repository.getSession();\n+        }\n+\n+        @Override\n+        public PooledObject<Session> wrap(Session session) {\n+            return new DefaultPooledObject<>(session);\n+        }\n+\n+        @Override\n+        public void activateObject(String repositoryName, PooledObject<Session> p) throws Exception {\n+            super.activateObject(repositoryName, p);\n+        }\n+\n+        @Override\n+        public boolean validateObject(String repositoryName, PooledObject<Session> p) {\n+            return super.validateObject(repositoryName, p);\n+        }\n+\n+        @Override\n+        public void passivateObject(String repositoryName, PooledObject<Session> p) throws Exception {\n+            super.passivateObject(repositoryName, p);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MTYzNg=="}, "originalCommit": {"oid": "8d7adf76e8337076b0ff2c661508da5604e53fe7"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDg5MzI1OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-runtime-datasource/src/main/java/org/nuxeo/runtime/datasource/PooledDataSourceRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTo1NjoxMVrOGV-V7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTo1NjoxMVrOGV-V7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5NDcwMA==", "bodyText": "Extra line.", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r425694700", "createdAt": "2020-05-15T09:56:11Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-runtime-datasource/src/main/java/org/nuxeo/runtime/datasource/PooledDataSourceRegistry.java", "diffHunk": "@@ -13,74 +13,223 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  *\n+ * Contributors:\n+ *     Florent Guillaume\n  */\n package org.nuxeo.runtime.datasource;\n \n-import java.sql.Connection;\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+import java.lang.reflect.InvocationTargetException;\n import java.sql.SQLException;\n-import java.util.HashMap;\n-import java.util.Hashtable;\n import java.util.Map;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n \n-import javax.naming.Context;\n-import javax.naming.Name;\n-import javax.naming.Reference;\n+import javax.naming.NamingException;\n import javax.sql.DataSource;\n+import javax.sql.XADataSource;\n+import javax.transaction.Status;\n+import javax.transaction.Transaction;\n+import javax.transaction.TransactionManager;\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import org.apache.commons.beanutils.BeanUtils;\n+import org.apache.commons.dbcp2.ConnectionFactory;\n+import org.apache.commons.dbcp2.managed.BasicManagedDataSource;\n+import org.apache.commons.dbcp2.managed.TransactionRegistry;\n+import org.apache.commons.lang3.reflect.FieldUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.RuntimeServiceException;\n+import org.nuxeo.runtime.transaction.TransactionHelper;\n \n-public class PooledDataSourceRegistry extends ReentrantReadWriteLock {\n+public class PooledDataSourceRegistry {\n \n-    private static final long serialVersionUID = 1L;\n+    protected final Map<String, DataSource> dataSources = new ConcurrentHashMap<>();\n \n-    public interface PooledDataSource extends DataSource {\n-        void dispose();\n+    protected final Map<String, DataSource> dataSourcesNoSharing = new ConcurrentHashMap<>();\n \n-        Connection getConnection(boolean noSharing) throws SQLException;\n+    public <T> T getDataSource(String name, Class<T> type, boolean noSharing) {\n+        Map<String, DataSource> map = noSharing ? dataSourcesNoSharing : dataSources;\n+        return type.cast(map.get(name));\n     }\n \n-    protected final Map<String, PooledDataSource> pools = new HashMap<>();\n+    public void registerPooledDataSource(String name, Map<String, String> properties) {\n+        dataSources.computeIfAbsent(name, k -> createPooledDataSource(properties, false));\n+        dataSourcesNoSharing.computeIfAbsent(name, k -> createPooledDataSource(properties, true));\n+    }\n \n-    protected final PooledDataSourceFactory poolFactory = new org.nuxeo.runtime.datasource.PooledDataSourceFactory();\n+    /**\n+     * A {@link BasicManagedDataSource} that can configure its internal {@link XADataSource}.\n+     *\n+     * @since 11.1\n+     */\n+    public static class ConfigurableManagedDataSource extends BasicManagedDataSource {\n \n-    public <T> T getPool(String name, Class<T> type) {\n-        return type.cast(pools.get(name));\n-    }\n+        private static final Logger log = LogManager.getLogger(ConfigurableManagedDataSource.class);\n+\n+        protected final Map<String, String> properties;\n+\n+        public ConfigurableManagedDataSource(Map<String, String> properties) {\n+            this.properties = properties;\n+        }\n+        @Override\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d7adf76e8337076b0ff2c661508da5604e53fe7"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTc4MzQ3OnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-management-jtajca/src/main/java/org/nuxeo/ecm/core/management/jtajca/ConnectionPoolMonitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMzo1MzoxM1rOGYM2gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwOTo1NjozNlrOGaXIeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAyOTU2OA==", "bodyText": "Since 11.1?", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r428029568", "createdAt": "2020-05-20T13:53:13Z", "author": {"login": "troger"}, "path": "modules/core/nuxeo-core-management-jtajca/src/main/java/org/nuxeo/ecm/core/management/jtajca/ConnectionPoolMonitor.java", "diffHunk": "@@ -37,6 +35,14 @@\n      */\n     String getName();\n \n+    int getConnectionCount();\n+\n+    int getIdleConnectionCount();\n+\n+    int getBlockingTimeoutMilliseconds();\n+\n+    int getIdleTimeoutMinutes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e86c8bb234d8e8d337edeae1b0ba2bba11ad79"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI5NTE2MQ==", "bodyText": "They were already in the PoolingAttributes class which we used to extend.", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r430295161", "createdAt": "2020-05-26T09:56:36Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-management-jtajca/src/main/java/org/nuxeo/ecm/core/management/jtajca/ConnectionPoolMonitor.java", "diffHunk": "@@ -37,6 +35,14 @@\n      */\n     String getName();\n \n+    int getConnectionCount();\n+\n+    int getIdleConnectionCount();\n+\n+    int getBlockingTimeoutMilliseconds();\n+\n+    int getIdleTimeoutMinutes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAyOTU2OA=="}, "originalCommit": {"oid": "c3e86c8bb234d8e8d337edeae1b0ba2bba11ad79"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTkzNjQzOnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql/src/main/java/org/nuxeo/ecm/core/storage/sql/VCSRepositoryFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDoyMjoyN1rOGYOUTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDoyMjoyN1rOGYOUTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1MzU4MA==", "bodyText": "Since 11.1?", "url": "https://github.com/nuxeo/nuxeo/pull/3981#discussion_r428053580", "createdAt": "2020-05-20T14:22:27Z", "author": {"login": "troger"}, "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql/src/main/java/org/nuxeo/ecm/core/storage/sql/VCSRepositoryFactory.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * (C) Copyright 2006-2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ */\n+package org.nuxeo.ecm.core.storage.sql;\n+\n+import org.nuxeo.ecm.core.repository.RepositoryFactory;\n+import org.nuxeo.ecm.core.storage.sql.coremodel.SQLRepositoryService;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Repository factory for VCS, the repository implements internal pooling of sessions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e86c8bb234d8e8d337edeae1b0ba2bba11ad79"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4196, "cost": 1, "resetAt": "2021-11-03T18:41:40Z"}}}