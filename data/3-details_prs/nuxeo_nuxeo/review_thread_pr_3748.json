{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1NDY4ODE0", "number": 3748, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzowMDozN1rODf9NyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxODowNDoyNFrODf-Qmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODM1NDAwOnYy", "diffSide": "RIGHT", "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/main/java/org/nuxeo/runtime/cluster/ClusterServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzowMDozN1rOFp9ZeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzowMDozN1rOFp9ZeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0MTg4MA==", "bodyText": "can be replaced by:  log.debug(\"Sleeping on busy lock '{}' for {}ms\", () -> key, pollDelay::toMillis);", "url": "https://github.com/nuxeo/nuxeo/pull/3748#discussion_r379541880", "createdAt": "2020-02-14T17:00:37Z", "author": {"login": "RSalem07"}, "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/main/java/org/nuxeo/runtime/cluster/ClusterServiceImpl.java", "diffHunk": "@@ -117,4 +123,148 @@ public void setNodeId(String nodeId) {\n         this.nodeId = nodeId;\n     }\n \n+    @Override\n+    public void runAtomically(String key, Duration duration, Duration pollDelay, Runnable runnable) {\n+        if (!isEnabled()) {\n+            runnable.run();\n+            return;\n+        }\n+        new ClusterLockHelper(getNodeId(), duration, pollDelay).runAtomically(key, runnable);\n+    }\n+\n+    public static class ClusterLockHelper {\n+\n+        private static final Logger log = LogManager.getLogger(ClusterLockHelper.class);\n+\n+        public static final String KV_STORE_NAME = \"cluster\";\n+\n+        // TTL set on the lock, to make it expire if the process crashes or gets stuck\n+        // this is a multiplier of the duration during which we attempt to acquire the lock\n+        private static final int TTL_MULTIPLIER = 10;\n+\n+        protected final String nodeId;\n+\n+        protected final Duration duration;\n+\n+        protected final Duration pollDelay;\n+\n+        protected final KeyValueStore kvStore;\n+\n+        public ClusterLockHelper(String nodeId, Duration duration, Duration pollDelay) {\n+            this.nodeId = nodeId;\n+            this.duration = duration;\n+            this.pollDelay = pollDelay;\n+            kvStore = Framework.getService(KeyValueService.class).getKeyValueStore(KV_STORE_NAME);\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically in a cluster-wide critical section, outside a transaction.\n+         */\n+        public void runAtomically(String key, Runnable runnable) {\n+            runInSeparateTransaction(() -> runAtomicallyInternal(key, runnable));\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} outside the current transaction (committing and finally restarting it if needed).\n+         *\n+         * @implSpec this is different from {@link TransactionHelper#runWithoutTransaction(Runnable)} because that one,\n+         *           in some implementations, may keep the current transaction and start the runnable in a new thread.\n+         *           Here we don't want a new thread or a risk of deadlock, so we just commit the original transaction.\n+         */\n+        protected void runInSeparateTransaction(Runnable runnable) {\n+            // check if there is a current transaction, before committing it\n+            boolean transaction = TransactionHelper.isTransactionActiveOrMarkedRollback();\n+            if (transaction) {\n+                TransactionHelper.commitOrRollbackTransaction();\n+            }\n+            boolean completedAbruptly = true;\n+            try {\n+                if (transaction) {\n+                    TransactionHelper.runInTransaction(runnable);\n+                } else {\n+                    runnable.run();\n+                }\n+                completedAbruptly = false;\n+            } finally {\n+                if (transaction) {\n+                    // restart a transaction if there was one originally\n+                    try {\n+                        TransactionHelper.startTransaction();\n+                    } finally {\n+                        if (completedAbruptly) {\n+                            // mark rollback-only if there was an exception\n+                            TransactionHelper.setTransactionRollbackOnly();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically, in a cluster-wide critical section.\n+         */\n+        protected void runAtomicallyInternal(String key, Runnable runnable) {\n+            String lockInfo = tryLock(key);\n+            if (lockInfo != null) {\n+                try {\n+                    runnable.run();\n+                } finally {\n+                    unLock(key, lockInfo);\n+                }\n+            } else {\n+                throw new RuntimeServiceException(\"Failed to acquire lock '\" + key + \"' after \" + duration.toSeconds()\n+                        + \"s, owner: \" + getLock(key));\n+            }\n+        }\n+\n+        // try to acquire the lock and fail if it takes too long\n+        protected String tryLock(String key) {\n+            log.debug(\"Trying to lock '{}'\", key);\n+            long deadline = System.nanoTime() + duration.toNanos();\n+            long ttl = duration.multipliedBy(TTL_MULTIPLIER).toSeconds();\n+            do {\n+                // try to acquire the lock\n+                String lockInfo = \"node=\" + nodeId + \" time=\" + Instant.now();\n+                if (kvStore.compareAndSet(key, null, lockInfo, ttl)) {\n+                    // lock acquired\n+                    log.debug(\"Lock '{}' acquired after {}ms\", () -> key,\n+                            () -> (System.nanoTime() - (deadline - duration.toNanos())) / 1_000_000);\n+                    return lockInfo;\n+                }\n+                // wait a bit before retrying\n+                log.debug(\"  Sleeping on busy lock '{}' for {}ms\", () -> key, () -> pollDelay.toMillis());\n+                try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8219aa9e7c91cf650cb75ac4ae26a9ea1907ae4a"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODM2MDM3OnYy", "diffSide": "RIGHT", "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/main/java/org/nuxeo/runtime/cluster/ClusterServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzowMjo1NlrOFp9dvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzowMjo1NlrOFp9dvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0Mjk3Mg==", "bodyText": "can be replaced by:\nlog.debug(\"Failed to acquire lock '{}' after {}s\", () -> key,  tryDuration::toSeconds);", "url": "https://github.com/nuxeo/nuxeo/pull/3748#discussion_r379542972", "createdAt": "2020-02-14T17:02:56Z", "author": {"login": "RSalem07"}, "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/main/java/org/nuxeo/runtime/cluster/ClusterServiceImpl.java", "diffHunk": "@@ -117,4 +123,148 @@ public void setNodeId(String nodeId) {\n         this.nodeId = nodeId;\n     }\n \n+    @Override\n+    public void runAtomically(String key, Duration duration, Duration pollDelay, Runnable runnable) {\n+        if (!isEnabled()) {\n+            runnable.run();\n+            return;\n+        }\n+        new ClusterLockHelper(getNodeId(), duration, pollDelay).runAtomically(key, runnable);\n+    }\n+\n+    public static class ClusterLockHelper {\n+\n+        private static final Logger log = LogManager.getLogger(ClusterLockHelper.class);\n+\n+        public static final String KV_STORE_NAME = \"cluster\";\n+\n+        // TTL set on the lock, to make it expire if the process crashes or gets stuck\n+        // this is a multiplier of the duration during which we attempt to acquire the lock\n+        private static final int TTL_MULTIPLIER = 10;\n+\n+        protected final String nodeId;\n+\n+        protected final Duration duration;\n+\n+        protected final Duration pollDelay;\n+\n+        protected final KeyValueStore kvStore;\n+\n+        public ClusterLockHelper(String nodeId, Duration duration, Duration pollDelay) {\n+            this.nodeId = nodeId;\n+            this.duration = duration;\n+            this.pollDelay = pollDelay;\n+            kvStore = Framework.getService(KeyValueService.class).getKeyValueStore(KV_STORE_NAME);\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically in a cluster-wide critical section, outside a transaction.\n+         */\n+        public void runAtomically(String key, Runnable runnable) {\n+            runInSeparateTransaction(() -> runAtomicallyInternal(key, runnable));\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} outside the current transaction (committing and finally restarting it if needed).\n+         *\n+         * @implSpec this is different from {@link TransactionHelper#runWithoutTransaction(Runnable)} because that one,\n+         *           in some implementations, may keep the current transaction and start the runnable in a new thread.\n+         *           Here we don't want a new thread or a risk of deadlock, so we just commit the original transaction.\n+         */\n+        protected void runInSeparateTransaction(Runnable runnable) {\n+            // check if there is a current transaction, before committing it\n+            boolean transaction = TransactionHelper.isTransactionActiveOrMarkedRollback();\n+            if (transaction) {\n+                TransactionHelper.commitOrRollbackTransaction();\n+            }\n+            boolean completedAbruptly = true;\n+            try {\n+                if (transaction) {\n+                    TransactionHelper.runInTransaction(runnable);\n+                } else {\n+                    runnable.run();\n+                }\n+                completedAbruptly = false;\n+            } finally {\n+                if (transaction) {\n+                    // restart a transaction if there was one originally\n+                    try {\n+                        TransactionHelper.startTransaction();\n+                    } finally {\n+                        if (completedAbruptly) {\n+                            // mark rollback-only if there was an exception\n+                            TransactionHelper.setTransactionRollbackOnly();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically, in a cluster-wide critical section.\n+         */\n+        protected void runAtomicallyInternal(String key, Runnable runnable) {\n+            String lockInfo = tryLock(key);\n+            if (lockInfo != null) {\n+                try {\n+                    runnable.run();\n+                } finally {\n+                    unLock(key, lockInfo);\n+                }\n+            } else {\n+                throw new RuntimeServiceException(\"Failed to acquire lock '\" + key + \"' after \" + duration.toSeconds()\n+                        + \"s, owner: \" + getLock(key));\n+            }\n+        }\n+\n+        // try to acquire the lock and fail if it takes too long\n+        protected String tryLock(String key) {\n+            log.debug(\"Trying to lock '{}'\", key);\n+            long deadline = System.nanoTime() + duration.toNanos();\n+            long ttl = duration.multipliedBy(TTL_MULTIPLIER).toSeconds();\n+            do {\n+                // try to acquire the lock\n+                String lockInfo = \"node=\" + nodeId + \" time=\" + Instant.now();\n+                if (kvStore.compareAndSet(key, null, lockInfo, ttl)) {\n+                    // lock acquired\n+                    log.debug(\"Lock '{}' acquired after {}ms\", () -> key,\n+                            () -> (System.nanoTime() - (deadline - duration.toNanos())) / 1_000_000);\n+                    return lockInfo;\n+                }\n+                // wait a bit before retrying\n+                log.debug(\"  Sleeping on busy lock '{}' for {}ms\", () -> key, () -> pollDelay.toMillis());\n+                try {\n+                    Thread.sleep(pollDelay.toMillis());\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    throw new RuntimeServiceException(e);\n+                }\n+            } while (System.nanoTime() < deadline);\n+            log.debug(\"Failed to acquire lock '{}' after {}s\", () -> key, () -> duration.toSeconds());\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8219aa9e7c91cf650cb75ac4ae26a9ea1907ae4a"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODM2NjY1OnYy", "diffSide": "RIGHT", "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/main/java/org/nuxeo/runtime/cluster/ClusterServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzowNToyMVrOFp9hzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzo0MTo0MlrOFp-e2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NDAxNA==", "bodyText": "Unlocking '{}' but the lock had already expired;  -> Unlocking '{}' but the lock had already expired,  a , instead of ;", "url": "https://github.com/nuxeo/nuxeo/pull/3748#discussion_r379544014", "createdAt": "2020-02-14T17:05:21Z", "author": {"login": "RSalem07"}, "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/main/java/org/nuxeo/runtime/cluster/ClusterServiceImpl.java", "diffHunk": "@@ -117,4 +123,148 @@ public void setNodeId(String nodeId) {\n         this.nodeId = nodeId;\n     }\n \n+    @Override\n+    public void runAtomically(String key, Duration duration, Duration pollDelay, Runnable runnable) {\n+        if (!isEnabled()) {\n+            runnable.run();\n+            return;\n+        }\n+        new ClusterLockHelper(getNodeId(), duration, pollDelay).runAtomically(key, runnable);\n+    }\n+\n+    public static class ClusterLockHelper {\n+\n+        private static final Logger log = LogManager.getLogger(ClusterLockHelper.class);\n+\n+        public static final String KV_STORE_NAME = \"cluster\";\n+\n+        // TTL set on the lock, to make it expire if the process crashes or gets stuck\n+        // this is a multiplier of the duration during which we attempt to acquire the lock\n+        private static final int TTL_MULTIPLIER = 10;\n+\n+        protected final String nodeId;\n+\n+        protected final Duration duration;\n+\n+        protected final Duration pollDelay;\n+\n+        protected final KeyValueStore kvStore;\n+\n+        public ClusterLockHelper(String nodeId, Duration duration, Duration pollDelay) {\n+            this.nodeId = nodeId;\n+            this.duration = duration;\n+            this.pollDelay = pollDelay;\n+            kvStore = Framework.getService(KeyValueService.class).getKeyValueStore(KV_STORE_NAME);\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically in a cluster-wide critical section, outside a transaction.\n+         */\n+        public void runAtomically(String key, Runnable runnable) {\n+            runInSeparateTransaction(() -> runAtomicallyInternal(key, runnable));\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} outside the current transaction (committing and finally restarting it if needed).\n+         *\n+         * @implSpec this is different from {@link TransactionHelper#runWithoutTransaction(Runnable)} because that one,\n+         *           in some implementations, may keep the current transaction and start the runnable in a new thread.\n+         *           Here we don't want a new thread or a risk of deadlock, so we just commit the original transaction.\n+         */\n+        protected void runInSeparateTransaction(Runnable runnable) {\n+            // check if there is a current transaction, before committing it\n+            boolean transaction = TransactionHelper.isTransactionActiveOrMarkedRollback();\n+            if (transaction) {\n+                TransactionHelper.commitOrRollbackTransaction();\n+            }\n+            boolean completedAbruptly = true;\n+            try {\n+                if (transaction) {\n+                    TransactionHelper.runInTransaction(runnable);\n+                } else {\n+                    runnable.run();\n+                }\n+                completedAbruptly = false;\n+            } finally {\n+                if (transaction) {\n+                    // restart a transaction if there was one originally\n+                    try {\n+                        TransactionHelper.startTransaction();\n+                    } finally {\n+                        if (completedAbruptly) {\n+                            // mark rollback-only if there was an exception\n+                            TransactionHelper.setTransactionRollbackOnly();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically, in a cluster-wide critical section.\n+         */\n+        protected void runAtomicallyInternal(String key, Runnable runnable) {\n+            String lockInfo = tryLock(key);\n+            if (lockInfo != null) {\n+                try {\n+                    runnable.run();\n+                } finally {\n+                    unLock(key, lockInfo);\n+                }\n+            } else {\n+                throw new RuntimeServiceException(\"Failed to acquire lock '\" + key + \"' after \" + duration.toSeconds()\n+                        + \"s, owner: \" + getLock(key));\n+            }\n+        }\n+\n+        // try to acquire the lock and fail if it takes too long\n+        protected String tryLock(String key) {\n+            log.debug(\"Trying to lock '{}'\", key);\n+            long deadline = System.nanoTime() + duration.toNanos();\n+            long ttl = duration.multipliedBy(TTL_MULTIPLIER).toSeconds();\n+            do {\n+                // try to acquire the lock\n+                String lockInfo = \"node=\" + nodeId + \" time=\" + Instant.now();\n+                if (kvStore.compareAndSet(key, null, lockInfo, ttl)) {\n+                    // lock acquired\n+                    log.debug(\"Lock '{}' acquired after {}ms\", () -> key,\n+                            () -> (System.nanoTime() - (deadline - duration.toNanos())) / 1_000_000);\n+                    return lockInfo;\n+                }\n+                // wait a bit before retrying\n+                log.debug(\"  Sleeping on busy lock '{}' for {}ms\", () -> key, () -> pollDelay.toMillis());\n+                try {\n+                    Thread.sleep(pollDelay.toMillis());\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    throw new RuntimeServiceException(e);\n+                }\n+            } while (System.nanoTime() < deadline);\n+            log.debug(\"Failed to acquire lock '{}' after {}s\", () -> key, () -> duration.toSeconds());\n+            return null;\n+        }\n+\n+        protected void unLock(String key, String lockInfo) {\n+            log.debug(\"Unlocking '{}'\", key);\n+            if (kvStore.compareAndSet(key, lockInfo, null)) {\n+                return;\n+            }\n+            // couldn't remove the lock, it expired an may have been reacquired\n+            String current = kvStore.getString(key);\n+            if (current == null) {\n+                // lock expired but was not reacquired\n+                log.warn(\"Unlocking '{}' but the lock had already expired; \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8219aa9e7c91cf650cb75ac4ae26a9ea1907ae4a"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU1OTY0MQ==", "bodyText": "The ; is on purpose for better grammar.", "url": "https://github.com/nuxeo/nuxeo/pull/3748#discussion_r379559641", "createdAt": "2020-02-14T17:41:42Z", "author": {"login": "efge"}, "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/main/java/org/nuxeo/runtime/cluster/ClusterServiceImpl.java", "diffHunk": "@@ -117,4 +123,148 @@ public void setNodeId(String nodeId) {\n         this.nodeId = nodeId;\n     }\n \n+    @Override\n+    public void runAtomically(String key, Duration duration, Duration pollDelay, Runnable runnable) {\n+        if (!isEnabled()) {\n+            runnable.run();\n+            return;\n+        }\n+        new ClusterLockHelper(getNodeId(), duration, pollDelay).runAtomically(key, runnable);\n+    }\n+\n+    public static class ClusterLockHelper {\n+\n+        private static final Logger log = LogManager.getLogger(ClusterLockHelper.class);\n+\n+        public static final String KV_STORE_NAME = \"cluster\";\n+\n+        // TTL set on the lock, to make it expire if the process crashes or gets stuck\n+        // this is a multiplier of the duration during which we attempt to acquire the lock\n+        private static final int TTL_MULTIPLIER = 10;\n+\n+        protected final String nodeId;\n+\n+        protected final Duration duration;\n+\n+        protected final Duration pollDelay;\n+\n+        protected final KeyValueStore kvStore;\n+\n+        public ClusterLockHelper(String nodeId, Duration duration, Duration pollDelay) {\n+            this.nodeId = nodeId;\n+            this.duration = duration;\n+            this.pollDelay = pollDelay;\n+            kvStore = Framework.getService(KeyValueService.class).getKeyValueStore(KV_STORE_NAME);\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically in a cluster-wide critical section, outside a transaction.\n+         */\n+        public void runAtomically(String key, Runnable runnable) {\n+            runInSeparateTransaction(() -> runAtomicallyInternal(key, runnable));\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} outside the current transaction (committing and finally restarting it if needed).\n+         *\n+         * @implSpec this is different from {@link TransactionHelper#runWithoutTransaction(Runnable)} because that one,\n+         *           in some implementations, may keep the current transaction and start the runnable in a new thread.\n+         *           Here we don't want a new thread or a risk of deadlock, so we just commit the original transaction.\n+         */\n+        protected void runInSeparateTransaction(Runnable runnable) {\n+            // check if there is a current transaction, before committing it\n+            boolean transaction = TransactionHelper.isTransactionActiveOrMarkedRollback();\n+            if (transaction) {\n+                TransactionHelper.commitOrRollbackTransaction();\n+            }\n+            boolean completedAbruptly = true;\n+            try {\n+                if (transaction) {\n+                    TransactionHelper.runInTransaction(runnable);\n+                } else {\n+                    runnable.run();\n+                }\n+                completedAbruptly = false;\n+            } finally {\n+                if (transaction) {\n+                    // restart a transaction if there was one originally\n+                    try {\n+                        TransactionHelper.startTransaction();\n+                    } finally {\n+                        if (completedAbruptly) {\n+                            // mark rollback-only if there was an exception\n+                            TransactionHelper.setTransactionRollbackOnly();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Runs a {@link Runnable} atomically, in a cluster-wide critical section.\n+         */\n+        protected void runAtomicallyInternal(String key, Runnable runnable) {\n+            String lockInfo = tryLock(key);\n+            if (lockInfo != null) {\n+                try {\n+                    runnable.run();\n+                } finally {\n+                    unLock(key, lockInfo);\n+                }\n+            } else {\n+                throw new RuntimeServiceException(\"Failed to acquire lock '\" + key + \"' after \" + duration.toSeconds()\n+                        + \"s, owner: \" + getLock(key));\n+            }\n+        }\n+\n+        // try to acquire the lock and fail if it takes too long\n+        protected String tryLock(String key) {\n+            log.debug(\"Trying to lock '{}'\", key);\n+            long deadline = System.nanoTime() + duration.toNanos();\n+            long ttl = duration.multipliedBy(TTL_MULTIPLIER).toSeconds();\n+            do {\n+                // try to acquire the lock\n+                String lockInfo = \"node=\" + nodeId + \" time=\" + Instant.now();\n+                if (kvStore.compareAndSet(key, null, lockInfo, ttl)) {\n+                    // lock acquired\n+                    log.debug(\"Lock '{}' acquired after {}ms\", () -> key,\n+                            () -> (System.nanoTime() - (deadline - duration.toNanos())) / 1_000_000);\n+                    return lockInfo;\n+                }\n+                // wait a bit before retrying\n+                log.debug(\"  Sleeping on busy lock '{}' for {}ms\", () -> key, () -> pollDelay.toMillis());\n+                try {\n+                    Thread.sleep(pollDelay.toMillis());\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    throw new RuntimeServiceException(e);\n+                }\n+            } while (System.nanoTime() < deadline);\n+            log.debug(\"Failed to acquire lock '{}' after {}s\", () -> key, () -> duration.toSeconds());\n+            return null;\n+        }\n+\n+        protected void unLock(String key, String lockInfo) {\n+            log.debug(\"Unlocking '{}'\", key);\n+            if (kvStore.compareAndSet(key, lockInfo, null)) {\n+                return;\n+            }\n+            // couldn't remove the lock, it expired an may have been reacquired\n+            String current = kvStore.getString(key);\n+            if (current == null) {\n+                // lock expired but was not reacquired\n+                log.warn(\"Unlocking '{}' but the lock had already expired; \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NDAxNA=="}, "originalCommit": {"oid": "8219aa9e7c91cf650cb75ac4ae26a9ea1907ae4a"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODUyNTA3OnYy", "diffSide": "RIGHT", "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/test/java/org/nuxeo/runtime/cluster/ClusterFeature.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxODowNDoyNFrOFp_Fxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxODowNDoyNFrOFp_Fxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2OTYwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Feature to test the {@link CacheService}.\n          \n          \n            \n             * Feature to test the {@link ClusterService}.\n          \n      \n    \n    \n  \n\n?", "url": "https://github.com/nuxeo/nuxeo/pull/3748#discussion_r379569607", "createdAt": "2020-02-14T18:04:24Z", "author": {"login": "troger"}, "path": "nuxeo-runtime/nuxeo-runtime-cluster/src/test/java/org/nuxeo/runtime/cluster/ClusterFeature.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ */\n+package org.nuxeo.runtime.cluster;\n+\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.RunnerFeature;\n+import org.nuxeo.runtime.test.runner.RuntimeFeature;\n+\n+/**\n+ * Feature to test the {@link CacheService}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6474647ed805eb557b4a1dcda33bab2813ec6bbc"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4258, "cost": 1, "resetAt": "2021-11-03T18:41:40Z"}}}