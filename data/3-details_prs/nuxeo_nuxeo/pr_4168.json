{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2OTc3OTk5", "number": 4168, "title": "Feature nxp 29220 explorer xml secure content", "bodyText": "Draft PR on branch feature-NXP-29050-explorer-hide-current-distrib, waiting for #4133 to be merged", "createdAt": "2020-06-19T08:58:48Z", "url": "https://github.com/nuxeo/nuxeo/pull/4168", "merged": true, "mergeCommit": {"oid": "183f2d2be06cf1c4e6935fa26c91ccadf2b04d92"}, "closed": true, "closedAt": "2020-06-24T07:45:06Z", "author": {"login": "atchertchian"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcswIF_AFqTQzMzk1NDczOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuVDbcgFqTQzNjM5NzIwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTU0NzM5", "url": "https://github.com/nuxeo/nuxeo/pull/4168#pullrequestreview-433954739", "createdAt": "2020-06-19T10:03:01Z", "commit": {"oid": "b66213f1d1b0d82b3517f3b02da82aa4acb6b435"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMDowMzowMVrOGmPT7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMDowMzowMVrOGmPT7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0OTkzNA==", "bodyText": "I would have done the rewriting using StAX instead of ad hoc regexps...", "url": "https://github.com/nuxeo/nuxeo/pull/4168#discussion_r442749934", "createdAt": "2020-06-19T10:03:01Z", "author": {"login": "efge"}, "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/documentation/DocumentationHelper.java", "diffHunk": "@@ -134,15 +148,54 @@ public static String getHtml(String doc) {\n      * Makes sure no passwords are embedded in the XML.\n      */\n     public static String secureXML(String xml) {\n-        if (xml == null || !xml.contains(\"assword\")) {\n+        if (StringUtils.isBlank(xml)) {\n             return xml;\n         }\n-        xml = xml.replaceAll(\"<([a-zA-Z]*[pP])assword>[^<]*</([a-zA-Z]*)assword>\", \"<$1assword>********</$2assword>\");\n-        // attributes: nuxeo-core-auth\n-        xml = xml.replaceAll(\"([a-zA-Z]*[pP])assword=\\\"[^\\\"]*\\\"\", \"$1assword=\\\"********\\\"\");\n-        // property: default-repository-config\n-        xml = xml.replaceAll(\"([a-zA-Z]*[pP])assword\\\">[^<]*<\", \"$1assword\\\">********<\");\n-        return xml;\n+        String res = xml;\n+        List<String> keywords = getKeywordList(SECURE_KEYWORDS_PROPERTY, DEFAULT_SECURE_KEYWORDS);\n+        List<String> whitelist = getKeywordList(WHITELISTED_KEYWORDS_PROPERTY, DEFAULT_WHITELISTED_KEYWORDS);\n+        for (String kw : keywords) {\n+            if (res.contains(kw)) {\n+                for (String pattern : List.of(\n+                        // node startswith\n+                        String.format(\"(?<start><(?<key>\\\\w*%s)\\\\s*>)[^<]*(?<end></\\\\w*%s>)\", kw, kw),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b66213f1d1b0d82b3517f3b02da82aa4acb6b435"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MDI4Mjgy", "url": "https://github.com/nuxeo/nuxeo/pull/4168#pullrequestreview-434028282", "createdAt": "2020-06-19T12:13:30Z", "commit": {"oid": "b66213f1d1b0d82b3517f3b02da82aa4acb6b435"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMjoxMzozMVrOGmSppA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMjoxMzozMVrOGmSppA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwNDY0NA==", "bodyText": "Something like below should be used as the ConfigurationService APIs with default value are not designed to pass null.\nreturn cs.getString(property).map(v -> v.split(\"\\\\s*,[,\\\\s]*\")).map(List::of).orElse(defaultValue);", "url": "https://github.com/nuxeo/nuxeo/pull/4168#discussion_r442804644", "createdAt": "2020-06-19T12:13:31Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/documentation/DocumentationHelper.java", "diffHunk": "@@ -134,15 +148,54 @@ public static String getHtml(String doc) {\n      * Makes sure no passwords are embedded in the XML.\n      */\n     public static String secureXML(String xml) {\n-        if (xml == null || !xml.contains(\"assword\")) {\n+        if (StringUtils.isBlank(xml)) {\n             return xml;\n         }\n-        xml = xml.replaceAll(\"<([a-zA-Z]*[pP])assword>[^<]*</([a-zA-Z]*)assword>\", \"<$1assword>********</$2assword>\");\n-        // attributes: nuxeo-core-auth\n-        xml = xml.replaceAll(\"([a-zA-Z]*[pP])assword=\\\"[^\\\"]*\\\"\", \"$1assword=\\\"********\\\"\");\n-        // property: default-repository-config\n-        xml = xml.replaceAll(\"([a-zA-Z]*[pP])assword\\\">[^<]*<\", \"$1assword\\\">********<\");\n-        return xml;\n+        String res = xml;\n+        List<String> keywords = getKeywordList(SECURE_KEYWORDS_PROPERTY, DEFAULT_SECURE_KEYWORDS);\n+        List<String> whitelist = getKeywordList(WHITELISTED_KEYWORDS_PROPERTY, DEFAULT_WHITELISTED_KEYWORDS);\n+        for (String kw : keywords) {\n+            if (res.contains(kw)) {\n+                for (String pattern : List.of(\n+                        // node startswith\n+                        String.format(\"(?<start><(?<key>\\\\w*%s)\\\\s*>)[^<]*(?<end></\\\\w*%s>)\", kw, kw),\n+                        // node endswith\n+                        String.format(\"(?<start><(?<key>%s\\\\w*)\\\\s*>)[^<]*(?<end></%s\\\\w*>)\", kw, kw),\n+                        // attributes startswith\n+                        String.format(\"(?<start>(?<key>\\\\w*%s)=\\\")[^\\\"]*(?<end>\\\")\", kw),\n+                        String.format(\"(?<start>(?<key>\\\\w*%s)\\\"\\\\s*>)[^<]*(?<end><)\", kw),\n+                        // attributes endswith\n+                        String.format(\"(?<start>(?<key>%s\\\\w*)=\\\")[^\\\"]*(?<end>\\\")\", kw),\n+                        String.format(\"(?<start>(?<key>%s\\\\w*)\\\"\\\\s*>)[^<]*(?<end><)\", kw))) {\n+                    res = secureXML(res, pattern, whitelist);\n+                }\n+            }\n+        }\n+        return res;\n+    }\n+\n+    protected static String secureXML(String xml, String pattern, List<String> whitelist) {\n+        StringBuffer result = new StringBuffer();\n+        Matcher m = Pattern.compile(pattern).matcher(xml);\n+        while (m.find()) {\n+            String replacement;\n+            if (whitelist.contains(m.group(\"key\"))) {\n+                replacement = m.group();\n+            } else {\n+                replacement = m.group(\"start\") + SECRET_VALUE + m.group(\"end\");\n+            }\n+            m.appendReplacement(result, replacement);\n+        }\n+        return m.appendTail(result).toString();\n+    }\n+\n+    protected static List<String> getKeywordList(String property, List<String> defaultValue) {\n+        ConfigurationService cs = Framework.getService(ConfigurationService.class);\n+        String value = cs.getString(property, null);\n+        if (value == null) {\n+            return defaultValue;\n+        }\n+        return List.of(value.split(\"\\\\s*,[,\\\\s]*\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b66213f1d1b0d82b3517f3b02da82aa4acb6b435"}, "originalPosition": 90}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b66213f1d1b0d82b3517f3b02da82aa4acb6b435", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/b66213f1d1b0d82b3517f3b02da82aa4acb6b435", "committedDate": "2020-06-19T08:47:21Z", "message": "NXP-29220: make explorer secure keywords configurable"}, "afterCommit": {"oid": "8e3bd9be6a1d01ece6be88f85fc11348ee7f6832", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/8e3bd9be6a1d01ece6be88f85fc11348ee7f6832", "committedDate": "2020-06-22T08:23:11Z", "message": "NXP-29220: use StAX parser for explorer XML secure content"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NzQxMTI4", "url": "https://github.com/nuxeo/nuxeo/pull/4168#pullrequestreview-434741128", "createdAt": "2020-06-22T09:11:28Z", "commit": {"oid": "8e3bd9be6a1d01ece6be88f85fc11348ee7f6832"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToxMToyOFrOGm4TEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOToxMjo0NlrOGm4V1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQyMTQ1OA==", "bodyText": "Wanted?", "url": "https://github.com/nuxeo/nuxeo/pull/4168#discussion_r443421458", "createdAt": "2020-06-22T09:11:28Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/documentation/SecureXMLHelper.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.apidoc.documentation;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.stream.XMLEventFactory;\n+import javax.xml.stream.XMLEventReader;\n+import javax.xml.stream.XMLEventWriter;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.events.Attribute;\n+import javax.xml.stream.events.StartDocument;\n+import javax.xml.stream.events.StartElement;\n+import javax.xml.stream.events.XMLEvent;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Helper for XML secure content management.\n+ *\n+ * @since 11.2\n+ */\n+public class SecureXMLHelper {\n+\n+    private static final Logger log = LogManager.getLogger(SecureXMLHelper.class);\n+\n+    protected static final String KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords\";\n+\n+    public static final List<String> DEFAULT_KEYWORDS = List.of(\"password\", \"Password\", \"secret\", \"apiKey\");\n+\n+    protected static final String WHITELISTED_KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords.whitelisted\";\n+\n+    public static final List<String> DEFAULT_WHITELISTED_KEYWORDS = List.of(\"passwordField\", \"passwordHashAlgorithm\");\n+\n+    protected static final String SECRET_VALUE = \"********\";\n+\n+    protected static final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n+\n+    protected static final XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\n+\n+    protected static final XMLEventFactory eventFactory = XMLEventFactory.newInstance();\n+\n+    /**\n+     * Makes sure no passwords and similar sensitive data are embedded in the XML.\n+     */\n+    public static String secure(String xml) {\n+        if (StringUtils.isBlank(xml)) {\n+            return xml;\n+        }\n+        List<String> keywords = getKeywords();\n+        List<String> whitelist = getWhitelistedKeywords();\n+        try {\n+            return secureStAX(xml, keywords, whitelist);\n+        } catch (XMLStreamException e) {\n+            log.error(e, e);\n+            return secureRegexp(xml, keywords, whitelist);\n+        }\n+    }\n+\n+    public static List<String> getKeywords() {\n+        return getKeywordList(KEYWORDS_PROPERTY, DEFAULT_KEYWORDS);\n+    }\n+\n+    public static List<String> getWhitelistedKeywords() {\n+        return getKeywordList(WHITELISTED_KEYWORDS_PROPERTY, DEFAULT_WHITELISTED_KEYWORDS);\n+    }\n+\n+    protected static List<String> getKeywordList(String property, List<String> defaultValue) {\n+        return Framework.getService(ConfigurationService.class)\n+                        .getString(property)\n+                        .map(v -> v.split(\"\\\\s*,[,\\\\s]*\"))\n+                        .map(List::of)\n+                        .orElse(defaultValue);\n+    }\n+\n+    public static String secureStAX(String xml, List<String> keywords, List<String> whitelist)\n+            throws XMLStreamException {\n+        // System.out.println(\"xml = \" + xml);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e3bd9be6a1d01ece6be88f85fc11348ee7f6832"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQyMjE2Nw==", "bodyText": "The stream InputStream doesn't seem to be closed, could we use try-with-resources to do that?", "url": "https://github.com/nuxeo/nuxeo/pull/4168#discussion_r443422167", "createdAt": "2020-06-22T09:12:46Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/documentation/SecureXMLHelper.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.apidoc.documentation;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.stream.XMLEventFactory;\n+import javax.xml.stream.XMLEventReader;\n+import javax.xml.stream.XMLEventWriter;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.events.Attribute;\n+import javax.xml.stream.events.StartDocument;\n+import javax.xml.stream.events.StartElement;\n+import javax.xml.stream.events.XMLEvent;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Helper for XML secure content management.\n+ *\n+ * @since 11.2\n+ */\n+public class SecureXMLHelper {\n+\n+    private static final Logger log = LogManager.getLogger(SecureXMLHelper.class);\n+\n+    protected static final String KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords\";\n+\n+    public static final List<String> DEFAULT_KEYWORDS = List.of(\"password\", \"Password\", \"secret\", \"apiKey\");\n+\n+    protected static final String WHITELISTED_KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords.whitelisted\";\n+\n+    public static final List<String> DEFAULT_WHITELISTED_KEYWORDS = List.of(\"passwordField\", \"passwordHashAlgorithm\");\n+\n+    protected static final String SECRET_VALUE = \"********\";\n+\n+    protected static final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n+\n+    protected static final XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\n+\n+    protected static final XMLEventFactory eventFactory = XMLEventFactory.newInstance();\n+\n+    /**\n+     * Makes sure no passwords and similar sensitive data are embedded in the XML.\n+     */\n+    public static String secure(String xml) {\n+        if (StringUtils.isBlank(xml)) {\n+            return xml;\n+        }\n+        List<String> keywords = getKeywords();\n+        List<String> whitelist = getWhitelistedKeywords();\n+        try {\n+            return secureStAX(xml, keywords, whitelist);\n+        } catch (XMLStreamException e) {\n+            log.error(e, e);\n+            return secureRegexp(xml, keywords, whitelist);\n+        }\n+    }\n+\n+    public static List<String> getKeywords() {\n+        return getKeywordList(KEYWORDS_PROPERTY, DEFAULT_KEYWORDS);\n+    }\n+\n+    public static List<String> getWhitelistedKeywords() {\n+        return getKeywordList(WHITELISTED_KEYWORDS_PROPERTY, DEFAULT_WHITELISTED_KEYWORDS);\n+    }\n+\n+    protected static List<String> getKeywordList(String property, List<String> defaultValue) {\n+        return Framework.getService(ConfigurationService.class)\n+                        .getString(property)\n+                        .map(v -> v.split(\"\\\\s*,[,\\\\s]*\"))\n+                        .map(List::of)\n+                        .orElse(defaultValue);\n+    }\n+\n+    public static String secureStAX(String xml, List<String> keywords, List<String> whitelist)\n+            throws XMLStreamException {\n+        // System.out.println(\"xml = \" + xml);\n+\n+        InputStream stream = new ByteArrayInputStream(xml.getBytes());\n+        XMLEventReader reader = inputFactory.createXMLEventReader(stream);\n+        OutputStream output = new ByteArrayOutputStream();\n+        XMLEventWriter writer = outputFactory.createXMLEventWriter(output);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e3bd9be6a1d01ece6be88f85fc11348ee7f6832"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cea10091ef49275b036851fb9e218f13236bba5e", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/cea10091ef49275b036851fb9e218f13236bba5e", "committedDate": "2020-06-22T17:41:55Z", "message": "NXP-29220: improve Explorer secure XML logics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf83db9dcb1ce0efe92406536a489adb99ee53d6", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/cf83db9dcb1ce0efe92406536a489adb99ee53d6", "committedDate": "2020-06-22T17:41:55Z", "message": "NXP-29220: make explorer secure keywords configurable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68e6cf1fb7dcb5382601dc5b7bdd53578d300efd", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/68e6cf1fb7dcb5382601dc5b7bdd53578d300efd", "committedDate": "2020-06-22T17:52:00Z", "message": "NXP-29220: add pristine explorer component to show diff after XML processing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9fa993b7cc77385c41e6e857d78a93c070ba5673", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/9fa993b7cc77385c41e6e857d78a93c070ba5673", "committedDate": "2020-06-22T09:19:33Z", "message": "NXP-29220: use StAX parser for explorer XML secure content"}, "afterCommit": {"oid": "b1e184234f58579419df8587fd64f73a0b31e8b8", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/b1e184234f58579419df8587fd64f73a0b31e8b8", "committedDate": "2020-06-22T17:53:18Z", "message": "NXP-29220: use StAX parser for explorer XML secure content"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MjUzNDM3", "url": "https://github.com/nuxeo/nuxeo/pull/4168#pullrequestreview-435253437", "createdAt": "2020-06-22T20:34:34Z", "commit": {"oid": "b1e184234f58579419df8587fd64f73a0b31e8b8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDozNDozNFrOGnQBuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDo0MjozNFrOGnQSFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxMDIzNQ==", "bodyText": "getBytes(UTF_8)", "url": "https://github.com/nuxeo/nuxeo/pull/4168#discussion_r443810235", "createdAt": "2020-06-22T20:34:34Z", "author": {"login": "efge"}, "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/documentation/SecureXMLHelper.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.apidoc.documentation;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.stream.XMLEventFactory;\n+import javax.xml.stream.XMLEventReader;\n+import javax.xml.stream.XMLEventWriter;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.events.Attribute;\n+import javax.xml.stream.events.StartDocument;\n+import javax.xml.stream.events.StartElement;\n+import javax.xml.stream.events.XMLEvent;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Helper for XML secure content management.\n+ *\n+ * @since 11.2\n+ */\n+public class SecureXMLHelper {\n+\n+    protected static final String KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords\";\n+\n+    public static final List<String> DEFAULT_KEYWORDS = List.of(\"password\", \"Password\", \"secret\", \"apiKey\");\n+\n+    protected static final String WHITELISTED_KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords.whitelisted\";\n+\n+    public static final List<String> DEFAULT_WHITELISTED_KEYWORDS = List.of(\"passwordField\", \"passwordHashAlgorithm\");\n+\n+    protected static final String SECRET_VALUE = \"********\";\n+\n+    protected static final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n+\n+    protected static final XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\n+\n+    protected static final XMLEventFactory eventFactory = XMLEventFactory.newInstance();\n+\n+    /**\n+     * Makes sure no passwords and similar sensitive data are embedded in the XML.\n+     */\n+    public static String secure(String xml) {\n+        List<String> keywords = getKeywords();\n+        if (!isChangeNeeded(xml, keywords)) {\n+            return xml;\n+        }\n+        List<String> whitelist = getWhitelistedKeywords();\n+        try {\n+            return secureStAX(xml, keywords, whitelist);\n+        } catch (XMLStreamException e) {\n+            return secureRegexp(xml, keywords, whitelist);\n+        }\n+    }\n+\n+    protected static boolean isChangeNeeded(String xml, List<String> keywords) {\n+        if (StringUtils.isBlank(xml) || keywords.stream().noneMatch(xml::contains)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public static List<String> getKeywords() {\n+        return getKeywordList(KEYWORDS_PROPERTY, DEFAULT_KEYWORDS);\n+    }\n+\n+    public static List<String> getWhitelistedKeywords() {\n+        return getKeywordList(WHITELISTED_KEYWORDS_PROPERTY, DEFAULT_WHITELISTED_KEYWORDS);\n+    }\n+\n+    protected static List<String> getKeywordList(String property, List<String> defaultValue) {\n+        return Framework.getService(ConfigurationService.class)\n+                        .getString(property)\n+                        .map(v -> v.split(\"\\\\s*,[,\\\\s]*\"))\n+                        .map(List::of)\n+                        .orElse(defaultValue);\n+    }\n+\n+    public static String secureStAX(String xml, List<String> keywords, List<String> whitelist)\n+            throws XMLStreamException {\n+        if (!isChangeNeeded(xml, keywords)) {\n+            return xml;\n+        }\n+        try (InputStream stream = new ByteArrayInputStream(xml.getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e184234f58579419df8587fd64f73a0b31e8b8"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxMTMxMg==", "bodyText": "constants -> all caps", "url": "https://github.com/nuxeo/nuxeo/pull/4168#discussion_r443811312", "createdAt": "2020-06-22T20:36:35Z", "author": {"login": "efge"}, "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/documentation/SecureXMLHelper.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.apidoc.documentation;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.stream.XMLEventFactory;\n+import javax.xml.stream.XMLEventReader;\n+import javax.xml.stream.XMLEventWriter;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.events.Attribute;\n+import javax.xml.stream.events.StartDocument;\n+import javax.xml.stream.events.StartElement;\n+import javax.xml.stream.events.XMLEvent;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Helper for XML secure content management.\n+ *\n+ * @since 11.2\n+ */\n+public class SecureXMLHelper {\n+\n+    protected static final String KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords\";\n+\n+    public static final List<String> DEFAULT_KEYWORDS = List.of(\"password\", \"Password\", \"secret\", \"apiKey\");\n+\n+    protected static final String WHITELISTED_KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords.whitelisted\";\n+\n+    public static final List<String> DEFAULT_WHITELISTED_KEYWORDS = List.of(\"passwordField\", \"passwordHashAlgorithm\");\n+\n+    protected static final String SECRET_VALUE = \"********\";\n+\n+    protected static final XMLInputFactory inputFactory = XMLInputFactory.newInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e184234f58579419df8587fd64f73a0b31e8b8"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxMzIzMA==", "bodyText": "Could be just one line", "url": "https://github.com/nuxeo/nuxeo/pull/4168#discussion_r443813230", "createdAt": "2020-06-22T20:40:17Z", "author": {"login": "efge"}, "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/documentation/SecureXMLHelper.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.apidoc.documentation;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.stream.XMLEventFactory;\n+import javax.xml.stream.XMLEventReader;\n+import javax.xml.stream.XMLEventWriter;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.events.Attribute;\n+import javax.xml.stream.events.StartDocument;\n+import javax.xml.stream.events.StartElement;\n+import javax.xml.stream.events.XMLEvent;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Helper for XML secure content management.\n+ *\n+ * @since 11.2\n+ */\n+public class SecureXMLHelper {\n+\n+    protected static final String KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords\";\n+\n+    public static final List<String> DEFAULT_KEYWORDS = List.of(\"password\", \"Password\", \"secret\", \"apiKey\");\n+\n+    protected static final String WHITELISTED_KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords.whitelisted\";\n+\n+    public static final List<String> DEFAULT_WHITELISTED_KEYWORDS = List.of(\"passwordField\", \"passwordHashAlgorithm\");\n+\n+    protected static final String SECRET_VALUE = \"********\";\n+\n+    protected static final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n+\n+    protected static final XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\n+\n+    protected static final XMLEventFactory eventFactory = XMLEventFactory.newInstance();\n+\n+    /**\n+     * Makes sure no passwords and similar sensitive data are embedded in the XML.\n+     */\n+    public static String secure(String xml) {\n+        List<String> keywords = getKeywords();\n+        if (!isChangeNeeded(xml, keywords)) {\n+            return xml;\n+        }\n+        List<String> whitelist = getWhitelistedKeywords();\n+        try {\n+            return secureStAX(xml, keywords, whitelist);\n+        } catch (XMLStreamException e) {\n+            return secureRegexp(xml, keywords, whitelist);\n+        }\n+    }\n+\n+    protected static boolean isChangeNeeded(String xml, List<String> keywords) {\n+        if (StringUtils.isBlank(xml) || keywords.stream().noneMatch(xml::contains)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public static List<String> getKeywords() {\n+        return getKeywordList(KEYWORDS_PROPERTY, DEFAULT_KEYWORDS);\n+    }\n+\n+    public static List<String> getWhitelistedKeywords() {\n+        return getKeywordList(WHITELISTED_KEYWORDS_PROPERTY, DEFAULT_WHITELISTED_KEYWORDS);\n+    }\n+\n+    protected static List<String> getKeywordList(String property, List<String> defaultValue) {\n+        return Framework.getService(ConfigurationService.class)\n+                        .getString(property)\n+                        .map(v -> v.split(\"\\\\s*,[,\\\\s]*\"))\n+                        .map(List::of)\n+                        .orElse(defaultValue);\n+    }\n+\n+    public static String secureStAX(String xml, List<String> keywords, List<String> whitelist)\n+            throws XMLStreamException {\n+        if (!isChangeNeeded(xml, keywords)) {\n+            return xml;\n+        }\n+        try (InputStream stream = new ByteArrayInputStream(xml.getBytes());\n+                OutputStream output = new ByteArrayOutputStream()) {\n+\n+            XMLEventReader reader = inputFactory.createXMLEventReader(stream);\n+            XMLEventWriter writer = outputFactory.createXMLEventWriter(output);\n+\n+            boolean skipContent = false;\n+            while (reader.hasNext()) {\n+                XMLEvent event = reader.nextEvent();\n+                if (skipContent && event.isCharacters()) {\n+                    writer.add(eventFactory.createCharacters(SECRET_VALUE));\n+                    skipContent = false;\n+                    continue;\n+                }\n+                if (event.isStartElement()) {\n+                    StartElement el = event.asStartElement();\n+                    String name = el.getName().getLocalPart();\n+                    if (matches(name, keywords, whitelist)) {\n+                        skipContent = true;\n+                    }\n+                    writer.add(eventFactory.createStartElement(el.getName(), null, null));\n+                    Iterator<Attribute> attrIt = el.getAttributes();\n+                    while (attrIt.hasNext()) {\n+                        Attribute attr = attrIt.next();\n+                        String attrName = attr.getName().getLocalPart();\n+                        String value = attr.getValue();\n+                        if (matches(attrName, keywords, whitelist)) {\n+                            // replace attribute value\n+                            writer.add(eventFactory.createAttribute(attrName, SECRET_VALUE));\n+                        } else {\n+                            writer.add(eventFactory.createAttribute(attrName, value));\n+                            if (matches(value, keywords, whitelist)) {\n+                                // replace node content\n+                                skipContent = true;\n+                            }\n+                        }\n+                    }\n+                } else if (event.isStartDocument()) {\n+                    if (((StartDocument) event).getVersion() == null) {\n+                        // skip it, it's been added by the reader processing\n+                        continue;\n+                    } else {\n+                        writer.add(event);\n+                        writer.add(eventFactory.createCharacters(\"\\n\"));\n+                    }\n+                } else {\n+                    writer.add(event);\n+                }\n+\n+                if (event.isEndElement()) {\n+                    skipContent = false;\n+                }\n+            }\n+            writer.flush();\n+            writer.close();\n+\n+            String all = output.toString();\n+            return all;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e184234f58579419df8587fd64f73a0b31e8b8"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxMzY0NA==", "bodyText": "Define ByteArrayOutputStream output above, and use output.toString(UTF_8) to convert to string. Charset is important.", "url": "https://github.com/nuxeo/nuxeo/pull/4168#discussion_r443813644", "createdAt": "2020-06-22T20:41:03Z", "author": {"login": "efge"}, "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/documentation/SecureXMLHelper.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.apidoc.documentation;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.stream.XMLEventFactory;\n+import javax.xml.stream.XMLEventReader;\n+import javax.xml.stream.XMLEventWriter;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.events.Attribute;\n+import javax.xml.stream.events.StartDocument;\n+import javax.xml.stream.events.StartElement;\n+import javax.xml.stream.events.XMLEvent;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Helper for XML secure content management.\n+ *\n+ * @since 11.2\n+ */\n+public class SecureXMLHelper {\n+\n+    protected static final String KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords\";\n+\n+    public static final List<String> DEFAULT_KEYWORDS = List.of(\"password\", \"Password\", \"secret\", \"apiKey\");\n+\n+    protected static final String WHITELISTED_KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords.whitelisted\";\n+\n+    public static final List<String> DEFAULT_WHITELISTED_KEYWORDS = List.of(\"passwordField\", \"passwordHashAlgorithm\");\n+\n+    protected static final String SECRET_VALUE = \"********\";\n+\n+    protected static final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n+\n+    protected static final XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\n+\n+    protected static final XMLEventFactory eventFactory = XMLEventFactory.newInstance();\n+\n+    /**\n+     * Makes sure no passwords and similar sensitive data are embedded in the XML.\n+     */\n+    public static String secure(String xml) {\n+        List<String> keywords = getKeywords();\n+        if (!isChangeNeeded(xml, keywords)) {\n+            return xml;\n+        }\n+        List<String> whitelist = getWhitelistedKeywords();\n+        try {\n+            return secureStAX(xml, keywords, whitelist);\n+        } catch (XMLStreamException e) {\n+            return secureRegexp(xml, keywords, whitelist);\n+        }\n+    }\n+\n+    protected static boolean isChangeNeeded(String xml, List<String> keywords) {\n+        if (StringUtils.isBlank(xml) || keywords.stream().noneMatch(xml::contains)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public static List<String> getKeywords() {\n+        return getKeywordList(KEYWORDS_PROPERTY, DEFAULT_KEYWORDS);\n+    }\n+\n+    public static List<String> getWhitelistedKeywords() {\n+        return getKeywordList(WHITELISTED_KEYWORDS_PROPERTY, DEFAULT_WHITELISTED_KEYWORDS);\n+    }\n+\n+    protected static List<String> getKeywordList(String property, List<String> defaultValue) {\n+        return Framework.getService(ConfigurationService.class)\n+                        .getString(property)\n+                        .map(v -> v.split(\"\\\\s*,[,\\\\s]*\"))\n+                        .map(List::of)\n+                        .orElse(defaultValue);\n+    }\n+\n+    public static String secureStAX(String xml, List<String> keywords, List<String> whitelist)\n+            throws XMLStreamException {\n+        if (!isChangeNeeded(xml, keywords)) {\n+            return xml;\n+        }\n+        try (InputStream stream = new ByteArrayInputStream(xml.getBytes());\n+                OutputStream output = new ByteArrayOutputStream()) {\n+\n+            XMLEventReader reader = inputFactory.createXMLEventReader(stream);\n+            XMLEventWriter writer = outputFactory.createXMLEventWriter(output);\n+\n+            boolean skipContent = false;\n+            while (reader.hasNext()) {\n+                XMLEvent event = reader.nextEvent();\n+                if (skipContent && event.isCharacters()) {\n+                    writer.add(eventFactory.createCharacters(SECRET_VALUE));\n+                    skipContent = false;\n+                    continue;\n+                }\n+                if (event.isStartElement()) {\n+                    StartElement el = event.asStartElement();\n+                    String name = el.getName().getLocalPart();\n+                    if (matches(name, keywords, whitelist)) {\n+                        skipContent = true;\n+                    }\n+                    writer.add(eventFactory.createStartElement(el.getName(), null, null));\n+                    Iterator<Attribute> attrIt = el.getAttributes();\n+                    while (attrIt.hasNext()) {\n+                        Attribute attr = attrIt.next();\n+                        String attrName = attr.getName().getLocalPart();\n+                        String value = attr.getValue();\n+                        if (matches(attrName, keywords, whitelist)) {\n+                            // replace attribute value\n+                            writer.add(eventFactory.createAttribute(attrName, SECRET_VALUE));\n+                        } else {\n+                            writer.add(eventFactory.createAttribute(attrName, value));\n+                            if (matches(value, keywords, whitelist)) {\n+                                // replace node content\n+                                skipContent = true;\n+                            }\n+                        }\n+                    }\n+                } else if (event.isStartDocument()) {\n+                    if (((StartDocument) event).getVersion() == null) {\n+                        // skip it, it's been added by the reader processing\n+                        continue;\n+                    } else {\n+                        writer.add(event);\n+                        writer.add(eventFactory.createCharacters(\"\\n\"));\n+                    }\n+                } else {\n+                    writer.add(event);\n+                }\n+\n+                if (event.isEndElement()) {\n+                    skipContent = false;\n+                }\n+            }\n+            writer.flush();\n+            writer.close();\n+\n+            String all = output.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e184234f58579419df8587fd64f73a0b31e8b8"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxNDQyMg==", "bodyText": "Could you also add the variants with a ' to delimit attribute values?", "url": "https://github.com/nuxeo/nuxeo/pull/4168#discussion_r443814422", "createdAt": "2020-06-22T20:42:34Z", "author": {"login": "efge"}, "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/documentation/SecureXMLHelper.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.apidoc.documentation;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.stream.XMLEventFactory;\n+import javax.xml.stream.XMLEventReader;\n+import javax.xml.stream.XMLEventWriter;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.events.Attribute;\n+import javax.xml.stream.events.StartDocument;\n+import javax.xml.stream.events.StartElement;\n+import javax.xml.stream.events.XMLEvent;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Helper for XML secure content management.\n+ *\n+ * @since 11.2\n+ */\n+public class SecureXMLHelper {\n+\n+    protected static final String KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords\";\n+\n+    public static final List<String> DEFAULT_KEYWORDS = List.of(\"password\", \"Password\", \"secret\", \"apiKey\");\n+\n+    protected static final String WHITELISTED_KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords.whitelisted\";\n+\n+    public static final List<String> DEFAULT_WHITELISTED_KEYWORDS = List.of(\"passwordField\", \"passwordHashAlgorithm\");\n+\n+    protected static final String SECRET_VALUE = \"********\";\n+\n+    protected static final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n+\n+    protected static final XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\n+\n+    protected static final XMLEventFactory eventFactory = XMLEventFactory.newInstance();\n+\n+    /**\n+     * Makes sure no passwords and similar sensitive data are embedded in the XML.\n+     */\n+    public static String secure(String xml) {\n+        List<String> keywords = getKeywords();\n+        if (!isChangeNeeded(xml, keywords)) {\n+            return xml;\n+        }\n+        List<String> whitelist = getWhitelistedKeywords();\n+        try {\n+            return secureStAX(xml, keywords, whitelist);\n+        } catch (XMLStreamException e) {\n+            return secureRegexp(xml, keywords, whitelist);\n+        }\n+    }\n+\n+    protected static boolean isChangeNeeded(String xml, List<String> keywords) {\n+        if (StringUtils.isBlank(xml) || keywords.stream().noneMatch(xml::contains)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public static List<String> getKeywords() {\n+        return getKeywordList(KEYWORDS_PROPERTY, DEFAULT_KEYWORDS);\n+    }\n+\n+    public static List<String> getWhitelistedKeywords() {\n+        return getKeywordList(WHITELISTED_KEYWORDS_PROPERTY, DEFAULT_WHITELISTED_KEYWORDS);\n+    }\n+\n+    protected static List<String> getKeywordList(String property, List<String> defaultValue) {\n+        return Framework.getService(ConfigurationService.class)\n+                        .getString(property)\n+                        .map(v -> v.split(\"\\\\s*,[,\\\\s]*\"))\n+                        .map(List::of)\n+                        .orElse(defaultValue);\n+    }\n+\n+    public static String secureStAX(String xml, List<String> keywords, List<String> whitelist)\n+            throws XMLStreamException {\n+        if (!isChangeNeeded(xml, keywords)) {\n+            return xml;\n+        }\n+        try (InputStream stream = new ByteArrayInputStream(xml.getBytes());\n+                OutputStream output = new ByteArrayOutputStream()) {\n+\n+            XMLEventReader reader = inputFactory.createXMLEventReader(stream);\n+            XMLEventWriter writer = outputFactory.createXMLEventWriter(output);\n+\n+            boolean skipContent = false;\n+            while (reader.hasNext()) {\n+                XMLEvent event = reader.nextEvent();\n+                if (skipContent && event.isCharacters()) {\n+                    writer.add(eventFactory.createCharacters(SECRET_VALUE));\n+                    skipContent = false;\n+                    continue;\n+                }\n+                if (event.isStartElement()) {\n+                    StartElement el = event.asStartElement();\n+                    String name = el.getName().getLocalPart();\n+                    if (matches(name, keywords, whitelist)) {\n+                        skipContent = true;\n+                    }\n+                    writer.add(eventFactory.createStartElement(el.getName(), null, null));\n+                    Iterator<Attribute> attrIt = el.getAttributes();\n+                    while (attrIt.hasNext()) {\n+                        Attribute attr = attrIt.next();\n+                        String attrName = attr.getName().getLocalPart();\n+                        String value = attr.getValue();\n+                        if (matches(attrName, keywords, whitelist)) {\n+                            // replace attribute value\n+                            writer.add(eventFactory.createAttribute(attrName, SECRET_VALUE));\n+                        } else {\n+                            writer.add(eventFactory.createAttribute(attrName, value));\n+                            if (matches(value, keywords, whitelist)) {\n+                                // replace node content\n+                                skipContent = true;\n+                            }\n+                        }\n+                    }\n+                } else if (event.isStartDocument()) {\n+                    if (((StartDocument) event).getVersion() == null) {\n+                        // skip it, it's been added by the reader processing\n+                        continue;\n+                    } else {\n+                        writer.add(event);\n+                        writer.add(eventFactory.createCharacters(\"\\n\"));\n+                    }\n+                } else {\n+                    writer.add(event);\n+                }\n+\n+                if (event.isEndElement()) {\n+                    skipContent = false;\n+                }\n+            }\n+            writer.flush();\n+            writer.close();\n+\n+            String all = output.toString();\n+            return all;\n+        } catch (IOException e) {\n+            throw new XMLStreamException(e);\n+        }\n+    }\n+\n+    protected static boolean matches(String name, List<String> keywords, List<String> whitelist) {\n+        if (!whitelist.contains(name) && (keywords.stream().anyMatch(kw -> name.startsWith(kw))\n+                || keywords.stream().anyMatch(kw -> name.endsWith(kw)))) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public static String secureRegexp(String xml, List<String> keywords, List<String> whitelist) {\n+        if (!isChangeNeeded(xml, keywords)) {\n+            return xml;\n+        }\n+        String res = xml;\n+        for (String kw : keywords) {\n+            if (res.contains(kw)) {\n+                for (String pattern : List.of(\n+                        // node startswith\n+                        String.format(\"(?<start><(?<key>\\\\w*%s)\\\\s*>)[^<]*(?<end></\\\\w*%s>)\", kw, kw),\n+                        // node endswith\n+                        String.format(\"(?<start><(?<key>%s\\\\w*)\\\\s*>)[^<]*(?<end></%s\\\\w*>)\", kw, kw),\n+                        // attributes startswith\n+                        String.format(\"(?<start>(?<key>\\\\w*%s)=\\\")[^\\\"]*(?<end>\\\")\", kw),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e184234f58579419df8587fd64f73a0b31e8b8"}, "originalPosition": 197}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b1e184234f58579419df8587fd64f73a0b31e8b8", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/b1e184234f58579419df8587fd64f73a0b31e8b8", "committedDate": "2020-06-22T17:53:18Z", "message": "NXP-29220: use StAX parser for explorer XML secure content"}, "afterCommit": {"oid": "6791a746660019749245b6c7362fecd8a48a8373", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/6791a746660019749245b6c7362fecd8a48a8373", "committedDate": "2020-06-23T09:36:52Z", "message": "NXP-29220: use StAX parser for explorer XML secure content"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6791a746660019749245b6c7362fecd8a48a8373", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/6791a746660019749245b6c7362fecd8a48a8373", "committedDate": "2020-06-23T09:36:52Z", "message": "NXP-29220: use StAX parser for explorer XML secure content"}, "afterCommit": {"oid": "ee3f00ccd1519b8dc0041c65f9fe91fabd322a17", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/ee3f00ccd1519b8dc0041c65f9fe91fabd322a17", "committedDate": "2020-06-23T09:39:18Z", "message": "NXP-29220: use StAX parser for explorer XML secure content"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NjQ0NzE2", "url": "https://github.com/nuxeo/nuxeo/pull/4168#pullrequestreview-435644716", "createdAt": "2020-06-23T10:20:55Z", "commit": {"oid": "cea10091ef49275b036851fb9e218f13236bba5e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMDoyMDo1NVrOGni5pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMDoyMDo1NVrOGni5pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDExOTQ2Mg==", "bodyText": "It seems to me there is a case that is not tested ?\n<password></password>\nshould also be replaced with\n<password>********</password>as you do have [^<]* in your regex.\nAn empty password wouldn't be hard to find anyway", "url": "https://github.com/nuxeo/nuxeo/pull/4168#discussion_r444119462", "createdAt": "2020-06-23T10:20:55Z", "author": {"login": "NourNuxeo"}, "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-repo/src/test/java/org/nuxeo/apidoc/test/TestSecureXML.java", "diffHunk": "@@ -15,32 +15,174 @@\n  *\n  * Contributors:\n  *     Florent Guillaume\n+ *     Anahide Tchertchian\n  */\n package org.nuxeo.apidoc.test;\n \n import static org.junit.Assert.assertEquals;\n \n import org.junit.Test;\n-import org.nuxeo.apidoc.documentation.DocumentationHelper;\n+import org.nuxeo.apidoc.documentation.SecureXMLHelper;\n \n public class TestSecureXML {\n \n+    @Test\n+    public void testSecureXMLNode() throws Exception {\n+        assertEquals(\"<password>********</password>\", SecureXMLHelper.secure(\"<password>p1</password>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLNodeSpace() throws Exception {\n+        assertEquals(\"<password >********</password>\", SecureXMLHelper.secure(\"<password >p1</password>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLStartNode() throws Exception {\n+        assertEquals(\"<passwordExample>********</passwordExample>\",\n+                SecureXMLHelper.secure(\"<passwordExample>password</passwordExample>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLEndNode() throws Exception {\n+        assertEquals(\"<examplePassword>********</examplePassword>\",\n+                SecureXMLHelper.secure(\"<examplePassword>password</examplePassword>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLWhitelistedNode() throws Exception {\n+        assertEquals(\"<passwordField>password</passwordField>\",\n+                SecureXMLHelper.secure(\"<passwordField>password</passwordField>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLAttribute() throws Exception {\n+        assertEquals(\"<prop name=\\\"password\\\">********</prop>\",\n+                SecureXMLHelper.secure(\"<prop name=\\\"password\\\">password</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLAttributSpace() throws Exception {\n+        assertEquals(\"<prop name=\\\"password\\\" >********</prop>\",\n+                SecureXMLHelper.secure(\"<prop name=\\\"password\\\" >password</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLAttribute2() throws Exception {\n+        assertEquals(\"<prop password=\\\"********\\\">foo</prop>\",\n+                SecureXMLHelper.secure(\"<prop password=\\\"password\\\">foo</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLAttribute3() throws Exception {\n+        assertEquals(\"<prop password=\\\"********\\\" foo=\\\"bar\\\" />\",\n+                SecureXMLHelper.secure(\"<prop password=\\\"password\\\" foo=\\\"bar\\\" />\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLStartAttribute() throws Exception {\n+        assertEquals(\"<prop name=\\\"passwordExample\\\">********</prop>\",\n+                SecureXMLHelper.secure(\"<prop name=\\\"passwordExample\\\">password</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLStartAttributeSpace() throws Exception {\n+        assertEquals(\"<prop name=\\\"passwordExample\\\" >********</prop>\",\n+                SecureXMLHelper.secure(\"<prop name=\\\"passwordExample\\\" >password</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLStartAttribute2() throws Exception {\n+        assertEquals(\"<prop passwordExample=\\\"********\\\">********</prop>\",\n+                SecureXMLHelper.secure(\"<prop passwordExample=\\\"password\\\">foo</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLStartAttribute3() throws Exception {\n+        assertEquals(\"<prop passwordExample=\\\"********\\\" foo=\\\"bar\\\">baz</prop>\",\n+                SecureXMLHelper.secure(\"<prop passwordExample=\\\"password\\\" foo=\\\"bar\\\">baz</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLEndAttribute() throws Exception {\n+        assertEquals(\"<prop name=\\\"passwordExample\\\">********</prop>\",\n+                SecureXMLHelper.secure(\"<prop name=\\\"passwordExample\\\">password</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLEndAttributeSpace() throws Exception {\n+        assertEquals(\"<prop name=\\\"passwordExample\\\" >********</prop>\",\n+                SecureXMLHelper.secure(\"<prop name=\\\"passwordExample\\\" >password</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLEndAttribute2() throws Exception {\n+        assertEquals(\"<prop passwordExample=\\\"********\\\">********</prop>\",\n+                SecureXMLHelper.secure(\"<prop passwordExample=\\\"password\\\">foo</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLEndAttribute3() throws Exception {\n+        assertEquals(\"<prop passwordExample=\\\"********\\\" foo=\\\"bar\\\" />\",\n+                SecureXMLHelper.secure(\"<prop passwordExample=\\\"password\\\" foo=\\\"bar\\\" />\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLWhitelistedAttribute() throws Exception {\n+        assertEquals(\"<prop name=\\\"passwordField\\\">password</prop>\",\n+                SecureXMLHelper.secure(\"<prop name=\\\"passwordField\\\">password</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLWhitelistedAttributeSpace() throws Exception {\n+        assertEquals(\"<prop name=\\\"passwordField\\\" >password</prop>\",\n+                SecureXMLHelper.secure(\"<prop name=\\\"passwordField\\\" >password</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLWhitelistedAttribute2() throws Exception {\n+        assertEquals(\"<prop passwordField=\\\"password\\\">********</prop>\",\n+                SecureXMLHelper.secure(\"<prop passwordField=\\\"password\\\">foo</prop>\"));\n+    }\n+\n+    @Test\n+    public void testSecureXMLWhitelistedAttribute3() throws Exception {\n+        assertEquals(\"<prop passwordField=\\\"password\\\" foo=\\\"bar\\\"/>\",\n+                SecureXMLHelper.secure(\"<prop passwordField=\\\"password\\\" foo=\\\"bar\\\"/>\"));\n+    }\n+\n     @Test\n     public void testSecureXML() throws Exception {\n-        String xml = \"foo <password>p1</password> \" //\n-                + \" <myPassword>p2</myPassword>\" //\n-                + \" <yo password=\\\"p3\\\" name=\\\"bla\\\">\" //\n-                + \" <yo otherPassword=\\\"p4\\\" name=\\\"bla\\\">\" //\n-                + \" <prop name=\\\"password\\\">p5</prop>\" //\n-                + \" <prop name=\\\"realPassword\\\">p6</prop>\";\n-        String expected = \"foo <password>********</password> \" //\n-                + \" <myPassword>********</myPassword>\" //\n-                + \" <yo password=\\\"********\\\" name=\\\"bla\\\">\" //\n-                + \" <yo otherPassword=\\\"********\\\" name=\\\"bla\\\">\" //\n-                + \" <prop name=\\\"password\\\">********</prop>\" //\n-                + \" <prop name=\\\"realPassword\\\">********</prop>\";\n-        String res = DocumentationHelper.secureXML(xml);\n-        assertEquals(expected, res);\n+        String xml = \"foo <password>p1</password>\\n\" //\n+                + \" <myPassword>p2</myPassword>\\n\" //\n+                + \" <myPassword >p2</myPassword>\\n\" //\n+                + \" <yo password=\\\"p3\\\" other=\\\"bla\\\">\\n\" //\n+                + \" <yo otherPassword=\\\"p4\\\" other=\\\"bla\\\">\\n\" //\n+                + \" <prop name=\\\"password\\\">p5</prop>\\n\" //\n+                + \" <prop name=\\\"realPassword\\\">p6</prop>\\n\" //\n+                + \" <prop name=\\\"realPassword\\\" >p6</prop>\\n\" //\n+                + \" <prop name=\\\"passwordNotWhitelisted\\\">p7</prop>\\n\" //\n+                + \" <prop name=\\\"passwordField\\\">ok</prop>\\n\" //\n+                + \" <secret>${nuxeo.jwt.secret}</secret>\\n\" //\n+                + \" <secretKey>${nuxeo.aws.secretKey}</secretKey>\\n\" //\n+                + \" <option name=\\\"apiKey\\\">${metrics.datadog.apiKey}</option>\\n\" //\n+                + \" <passwordField>password</passwordField>\\n\" //\n+                + \" <passwordHashAlgorithm>SSHA</passwordHashAlgorithm>\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cea10091ef49275b036851fb9e218f13236bba5e"}, "originalPosition": 177}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NzM5Mjk1", "url": "https://github.com/nuxeo/nuxeo/pull/4168#pullrequestreview-435739295", "createdAt": "2020-06-23T12:40:23Z", "commit": {"oid": "843b5e72eff398534727d24141b24960ac89bd2a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMjo0MDoyM1rOGnnRqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMjo0MDoyM1rOGnnRqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE5MTE0Nw==", "bodyText": "Weird indent here", "url": "https://github.com/nuxeo/nuxeo/pull/4168#discussion_r444191147", "createdAt": "2020-06-23T12:40:23Z", "author": {"login": "efge"}, "path": "modules/platform/nuxeo-apidoc-server/nuxeo-apidoc-core/src/main/java/org/nuxeo/apidoc/documentation/SecureXMLHelper.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.apidoc.documentation;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.stream.XMLEventFactory;\n+import javax.xml.stream.XMLEventReader;\n+import javax.xml.stream.XMLEventWriter;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.events.Attribute;\n+import javax.xml.stream.events.StartDocument;\n+import javax.xml.stream.events.StartElement;\n+import javax.xml.stream.events.XMLEvent;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Helper for XML secure content management.\n+ *\n+ * @since 11.2\n+ */\n+public class SecureXMLHelper {\n+\n+    protected static final String KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords\";\n+\n+    public static final List<String> DEFAULT_KEYWORDS = List.of(\"password\", \"Password\", \"secret\", \"apiKey\");\n+\n+    protected static final String WHITELISTED_KEYWORDS_PROPERTY = \"org.nuxeo.apidoc.secure.xml.keywords.whitelisted\";\n+\n+    public static final List<String> DEFAULT_WHITELISTED_KEYWORDS = List.of(\"passwordField\", \"passwordHashAlgorithm\");\n+\n+    protected static final String SECRET_VALUE = \"********\";\n+\n+    protected static final XMLInputFactory INPUT_FACTORY = XMLInputFactory.newInstance();\n+\n+    protected static final XMLOutputFactory OUTPUT_FACTORY = XMLOutputFactory.newInstance();\n+\n+    protected static final XMLEventFactory EVENT_FACTORY = XMLEventFactory.newInstance();\n+\n+    /**\n+     * Makes sure no passwords and similar sensitive data are embedded in the XML.\n+     */\n+    public static String secure(String xml) {\n+        List<String> keywords = getKeywords();\n+        if (!isChangeNeeded(xml, keywords)) {\n+            return xml;\n+        }\n+        List<String> whitelist = getWhitelistedKeywords();\n+        try {\n+            return secureStAX(xml, keywords, whitelist);\n+        } catch (XMLStreamException e) {\n+            return secureRegexp(xml, keywords, whitelist);\n+        }\n+    }\n+\n+    protected static boolean isChangeNeeded(String xml, List<String> keywords) {\n+        if (StringUtils.isBlank(xml) || keywords.stream().noneMatch(xml::contains)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public static List<String> getKeywords() {\n+        return getKeywordList(KEYWORDS_PROPERTY, DEFAULT_KEYWORDS);\n+    }\n+\n+    public static List<String> getWhitelistedKeywords() {\n+        return getKeywordList(WHITELISTED_KEYWORDS_PROPERTY, DEFAULT_WHITELISTED_KEYWORDS);\n+    }\n+\n+    protected static List<String> getKeywordList(String property, List<String> defaultValue) {\n+        return Framework.getService(ConfigurationService.class)\n+                        .getString(property)\n+                        .map(v -> v.split(\"\\\\s*,[,\\\\s]*\"))\n+                        .map(List::of)\n+                        .orElse(defaultValue);\n+    }\n+\n+    public static String secureStAX(String xml, List<String> keywords, List<String> whitelist)\n+            throws XMLStreamException {\n+        if (!isChangeNeeded(xml, keywords)) {\n+            return xml;\n+        }\n+        try (InputStream stream = new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8));\n+                ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n+\n+            XMLEventReader reader = INPUT_FACTORY.createXMLEventReader(stream);\n+            XMLEventWriter writer = OUTPUT_FACTORY.createXMLEventWriter(output);\n+\n+            boolean skipContent = false;\n+            while (reader.hasNext()) {\n+                XMLEvent event = reader.nextEvent();\n+                if (event.isEndElement() && skipContent) {\n+                    skipContent = false;\n+                    continue;\n+                }\n+                if (skipContent) {\n+                    continue;\n+                }\n+                if (event.isStartElement()) {\n+                    StartElement el = event.asStartElement();\n+                    String name = el.getName().getLocalPart();\n+                    if (matches(name, keywords, whitelist)) {\n+                        // skip attributes\n+                        writer.add(EVENT_FACTORY.createStartElement(el.getName(), null, null));\n+                        // replace content if any\n+                        replaceTagContent(reader, writer);\n+                        writer.add(EVENT_FACTORY.createEndElement(el.getName(), null));\n+                        skipContent = true;\n+                        continue;\n+                    }\n+                    // first pass on attributes to assess content\n+                    List<String> attrNameMatches = new ArrayList<>();\n+                    List<String> attrValueMatches = new ArrayList<>();\n+                    Iterator<Attribute> attrIt = el.getAttributes();\n+                    while (attrIt.hasNext()) {\n+                        Attribute attr = attrIt.next();\n+                        String attrName = attr.getName().getLocalPart();\n+                        String value = attr.getValue();\n+                        if (matches(attrName, keywords, whitelist)) {\n+                            attrNameMatches.add(attrName);\n+                        } else if (matches(value, keywords, whitelist)) {\n+                            attrValueMatches.add(attrName);\n+                        }\n+                    }\n+                    if (attrNameMatches.isEmpty() && attrValueMatches.isEmpty()) {\n+                        writer.add(event);\n+                        continue;\n+                    }\n+                    // second pass to replace content\n+                    writer.add(EVENT_FACTORY.createStartElement(el.getName(), null, null));\n+                    attrIt = el.getAttributes();\n+                    while (attrIt.hasNext()) {\n+                        Attribute attr = attrIt.next();\n+                        String attrName = attr.getName().getLocalPart();\n+                        String value = attr.getValue();\n+                        if (!attrValueMatches.isEmpty()) {\n+                            // replace all attributes value except the one matching\n+                            if (attrValueMatches.contains(attrName)) {\n+                                writer.add(EVENT_FACTORY.createAttribute(attrName, value));\n+                            } else {\n+                                writer.add(EVENT_FACTORY.createAttribute(attrName, SECRET_VALUE));\n+                            }\n+                        } else if (attrNameMatches.contains(attrName)) {\n+                            writer.add(EVENT_FACTORY.createAttribute(attrName, SECRET_VALUE));\n+                        } else {\n+                            writer.add(EVENT_FACTORY.createAttribute(attrName, value));\n+                        }\n+                    }\n+                    // replace content if any\n+                    replaceTagContent(reader, writer);\n+                    writer.add(EVENT_FACTORY.createEndElement(el.getName(), null));\n+                    skipContent = true;\n+                } else if (event.isStartDocument()) {\n+                    if (((StartDocument) event).getVersion() == null) {\n+                        // skip it, it's been added by the reader processing\n+                        continue;\n+                    } else {\n+                        writer.add(event);\n+                        writer.add(EVENT_FACTORY.createCharacters(\"\\n\"));\n+                    }\n+                } else {\n+                    writer.add(event);\n+                }\n+            }\n+            writer.flush();\n+            writer.close();\n+\n+            return output.toString(StandardCharsets.UTF_8);\n+        } catch (\n+\n+        IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5e72eff398534727d24141b24960ac89bd2a"}, "originalPosition": 202}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NzM5NzI1", "url": "https://github.com/nuxeo/nuxeo/pull/4168#pullrequestreview-435739725", "createdAt": "2020-06-23T12:40:58Z", "commit": {"oid": "843b5e72eff398534727d24141b24960ac89bd2a"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f15fab3a00c669e1ad5129fccd6d820dc316793f", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/f15fab3a00c669e1ad5129fccd6d820dc316793f", "committedDate": "2020-06-23T12:41:44Z", "message": "NXP-29220: use StAX parser for explorer XML secure content"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7543642282072c62ffcccaaff865e06155cfb80f", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/7543642282072c62ffcccaaff865e06155cfb80f", "committedDate": "2020-06-23T12:41:44Z", "message": "NXP-29220: also replace empty secure keywords"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "843b5e72eff398534727d24141b24960ac89bd2a", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/843b5e72eff398534727d24141b24960ac89bd2a", "committedDate": "2020-06-23T10:59:45Z", "message": "NXP-29220: also replace empty secure keywords"}, "afterCommit": {"oid": "7543642282072c62ffcccaaff865e06155cfb80f", "author": {"user": {"login": "atchertchian", "name": "Anahide Tchertchian"}}, "url": "https://github.com/nuxeo/nuxeo/commit/7543642282072c62ffcccaaff865e06155cfb80f", "committedDate": "2020-06-23T12:41:44Z", "message": "NXP-29220: also replace empty secure keywords"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NzQyOTMw", "url": "https://github.com/nuxeo/nuxeo/pull/4168#pullrequestreview-435742930", "createdAt": "2020-06-23T12:44:57Z", "commit": {"oid": "7543642282072c62ffcccaaff865e06155cfb80f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2Mzk3MjA5", "url": "https://github.com/nuxeo/nuxeo/pull/4168#pullrequestreview-436397209", "createdAt": "2020-06-24T07:38:21Z", "commit": {"oid": "7543642282072c62ffcccaaff865e06155cfb80f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4714, "cost": 1, "resetAt": "2021-11-03T18:41:40Z"}}}