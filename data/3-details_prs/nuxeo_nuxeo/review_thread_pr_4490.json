{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1NjMzMjQ1", "number": 4490, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo0MTowNlrOFDBeOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNzowNjoxMVrOFDCSPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzE0MTcwOnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/AbstractRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo0MTowNlrOICeV7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo0MTowNlrOICeV7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2NTE5OQ==", "bodyText": "Shouldn't be protected?", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539465199", "createdAt": "2020-12-09T16:41:06Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/AbstractRegistry.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.common.xmap.registry;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.nuxeo.common.xmap.Context;\n+import org.nuxeo.common.xmap.XAnnotatedObject;\n+import org.w3c.dom.Element;\n+\n+/**\n+ * @since TODO\n+ */\n+public abstract class AbstractRegistry implements Registry {\n+\n+    protected boolean initialized = false;\n+\n+    protected Set<String> flags = new HashSet<>();\n+\n+    protected List<RegistryContribution> registrations = new ArrayList<>();\n+\n+    public AbstractRegistry() {\n+    }\n+\n+    @Override\n+    public boolean isNull() {\n+        return false;\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzE1MTI2OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/MapRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo0Mjo0NFrOICebqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo0Mjo0NFrOICebqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2NjY2NA==", "bodyText": "contributionClass not needed, same for other methods.", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539466664", "createdAt": "2020-12-09T16:42:44Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/MapRegistry.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.common.xmap.registry;\n+\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.nuxeo.common.xmap.Context;\n+import org.nuxeo.common.xmap.XAnnotatedMember;\n+import org.nuxeo.common.xmap.XAnnotatedObject;\n+import org.w3c.dom.Element;\n+\n+/**\n+ * @since TODO\n+ */\n+public class MapRegistry extends AbstractRegistry implements Registry {\n+\n+    protected Map<String, Object> contributions = new LinkedHashMap<>();\n+\n+    protected Set<String> disabled = new HashSet<>();\n+\n+    public MapRegistry() {\n+        super();\n+    }\n+\n+    @Override\n+    protected void initialize() {\n+        contributions.clear();\n+        disabled.clear();\n+        super.initialize();\n+    }\n+\n+    public Map<String, Object> getContributions() {\n+        checkInitialized();\n+        return contributions.entrySet()\n+                            .stream()\n+                            .filter(x -> !disabled.contains(x.getKey()))\n+                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e2,\n+                                    LinkedHashMap::new));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Map<String, T> getContributions(Class<T> contributionClass) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzE2ODU4OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/AbstractRegistry.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo0NTo1MFrOICelzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjo1MDowNFrOIDTIXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2OTI2MA==", "bodyText": "Why not calling directly the other register method?", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539469260", "createdAt": "2020-12-09T16:45:50Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/AbstractRegistry.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.common.xmap.registry;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.nuxeo.common.xmap.Context;\n+import org.nuxeo.common.xmap.XAnnotatedObject;\n+import org.w3c.dom.Element;\n+\n+/**\n+ * @since TODO\n+ */\n+public abstract class AbstractRegistry implements Registry {\n+\n+    protected boolean initialized = false;\n+\n+    protected Set<String> flags = new HashSet<>();\n+\n+    protected List<RegistryContribution> registrations = new ArrayList<>();\n+\n+    public AbstractRegistry() {\n+    }\n+\n+    @Override\n+    public boolean isNull() {\n+        return false;\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    protected void checkInitialized() {\n+        if (isInitialized()) {\n+            return;\n+        }\n+        initialize();\n+    }\n+\n+    protected void initialize() {\n+        registrations.forEach(rc -> register(rc.getContext(), rc.getObject(), rc.getElement()));\n+        setInitialized(true);\n+    }\n+\n+    @Override\n+    public void flag(String id) {\n+        flags.add(id);\n+    }\n+\n+    @Override\n+    public boolean isFlagged(String id) {\n+        return flags.contains(id);\n+    }\n+\n+    @Override\n+    public void register(Context ctx, XAnnotatedObject xObject, Element element, String flag) {\n+        flags.add(flag);\n+        registrations.add(new RegistryContribution(ctx, xObject, element, flag));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwMTUxMw==", "bodyText": "The idea here is to call the other register method (that will process DOM and apply merge logics and such) only when the registry getters are called (at initialization).\nIt should not hurt to process these right away because they should be retrieved at some point anyway, but in practice it is useful for hot reload logics (so that computations are not done on the fly, some of them being potentially not needed depending on the deploy/undeploy subsequent calls)", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539501513", "createdAt": "2020-12-09T17:27:22Z", "author": {"login": "atchertchian"}, "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/AbstractRegistry.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.common.xmap.registry;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.nuxeo.common.xmap.Context;\n+import org.nuxeo.common.xmap.XAnnotatedObject;\n+import org.w3c.dom.Element;\n+\n+/**\n+ * @since TODO\n+ */\n+public abstract class AbstractRegistry implements Registry {\n+\n+    protected boolean initialized = false;\n+\n+    protected Set<String> flags = new HashSet<>();\n+\n+    protected List<RegistryContribution> registrations = new ArrayList<>();\n+\n+    public AbstractRegistry() {\n+    }\n+\n+    @Override\n+    public boolean isNull() {\n+        return false;\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    protected void checkInitialized() {\n+        if (isInitialized()) {\n+            return;\n+        }\n+        initialize();\n+    }\n+\n+    protected void initialize() {\n+        registrations.forEach(rc -> register(rc.getContext(), rc.getObject(), rc.getElement()));\n+        setInitialized(true);\n+    }\n+\n+    @Override\n+    public void flag(String id) {\n+        flags.add(id);\n+    }\n+\n+    @Override\n+    public boolean isFlagged(String id) {\n+        return flags.contains(id);\n+    }\n+\n+    @Override\n+    public void register(Context ctx, XAnnotatedObject xObject, Element element, String flag) {\n+        flags.add(flag);\n+        registrations.add(new RegistryContribution(ctx, xObject, element, flag));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2OTI2MA=="}, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzMDA3Nw==", "bodyText": "I kept the logic as is in #4537, please tell if you still think there should be changes in this case", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r540330077", "createdAt": "2020-12-10T16:50:04Z", "author": {"login": "atchertchian"}, "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/AbstractRegistry.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.common.xmap.registry;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.nuxeo.common.xmap.Context;\n+import org.nuxeo.common.xmap.XAnnotatedObject;\n+import org.w3c.dom.Element;\n+\n+/**\n+ * @since TODO\n+ */\n+public abstract class AbstractRegistry implements Registry {\n+\n+    protected boolean initialized = false;\n+\n+    protected Set<String> flags = new HashSet<>();\n+\n+    protected List<RegistryContribution> registrations = new ArrayList<>();\n+\n+    public AbstractRegistry() {\n+    }\n+\n+    @Override\n+    public boolean isNull() {\n+        return false;\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    protected void checkInitialized() {\n+        if (isInitialized()) {\n+            return;\n+        }\n+        initialize();\n+    }\n+\n+    protected void initialize() {\n+        registrations.forEach(rc -> register(rc.getContext(), rc.getObject(), rc.getElement()));\n+        setInitialized(true);\n+    }\n+\n+    @Override\n+    public void flag(String id) {\n+        flags.add(id);\n+    }\n+\n+    @Override\n+    public boolean isFlagged(String id) {\n+        return flags.contains(id);\n+    }\n+\n+    @Override\n+    public void register(Context ctx, XAnnotatedObject xObject, Element element, String flag) {\n+        flags.add(flag);\n+        registrations.add(new RegistryContribution(ctx, xObject, element, flag));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2OTI2MA=="}, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzE3ODU4OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/MapRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo0NzozOFrOICeryg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo0NzozOFrOICeryg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ3MDc5NA==", "bodyText": "new ArrayList could be used instead of streams.", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539470794", "createdAt": "2020-12-09T16:47:38Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/MapRegistry.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.common.xmap.registry;\n+\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.nuxeo.common.xmap.Context;\n+import org.nuxeo.common.xmap.XAnnotatedMember;\n+import org.nuxeo.common.xmap.XAnnotatedObject;\n+import org.w3c.dom.Element;\n+\n+/**\n+ * @since TODO\n+ */\n+public class MapRegistry extends AbstractRegistry implements Registry {\n+\n+    protected Map<String, Object> contributions = new LinkedHashMap<>();\n+\n+    protected Set<String> disabled = new HashSet<>();\n+\n+    public MapRegistry() {\n+        super();\n+    }\n+\n+    @Override\n+    protected void initialize() {\n+        contributions.clear();\n+        disabled.clear();\n+        super.initialize();\n+    }\n+\n+    public Map<String, Object> getContributions() {\n+        checkInitialized();\n+        return contributions.entrySet()\n+                            .stream()\n+                            .filter(x -> !disabled.contains(x.getKey()))\n+                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e2,\n+                                    LinkedHashMap::new));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Map<String, T> getContributions(Class<T> contributionClass) {\n+        return (Map<String, T>) getContributions();\n+    }\n+\n+    public List<Object> getContributionValues() {\n+        return getContributions().values().stream().collect(Collectors.toList());\n+    }\n+\n+    public <T> List<T> getContributionValues(Class<T> contributionClass) {\n+        return getContributions(contributionClass).values().stream().collect(Collectors.toList());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzE4MTg0OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/MapRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo0ODoyN1rOICet6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo0ODoyN1rOICet6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ3MTMzOQ==", "bodyText": "This method could return an Optional.", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539471339", "createdAt": "2020-12-09T16:48:27Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/xmap/registry/MapRegistry.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Anahide Tchertchian\n+ */\n+package org.nuxeo.common.xmap.registry;\n+\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.nuxeo.common.xmap.Context;\n+import org.nuxeo.common.xmap.XAnnotatedMember;\n+import org.nuxeo.common.xmap.XAnnotatedObject;\n+import org.w3c.dom.Element;\n+\n+/**\n+ * @since TODO\n+ */\n+public class MapRegistry extends AbstractRegistry implements Registry {\n+\n+    protected Map<String, Object> contributions = new LinkedHashMap<>();\n+\n+    protected Set<String> disabled = new HashSet<>();\n+\n+    public MapRegistry() {\n+        super();\n+    }\n+\n+    @Override\n+    protected void initialize() {\n+        contributions.clear();\n+        disabled.clear();\n+        super.initialize();\n+    }\n+\n+    public Map<String, Object> getContributions() {\n+        checkInitialized();\n+        return contributions.entrySet()\n+                            .stream()\n+                            .filter(x -> !disabled.contains(x.getKey()))\n+                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e2,\n+                                    LinkedHashMap::new));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Map<String, T> getContributions(Class<T> contributionClass) {\n+        return (Map<String, T>) getContributions();\n+    }\n+\n+    public List<Object> getContributionValues() {\n+        return getContributions().values().stream().collect(Collectors.toList());\n+    }\n+\n+    public <T> List<T> getContributionValues(Class<T> contributionClass) {\n+        return getContributions(contributionClass).values().stream().collect(Collectors.toList());\n+    }\n+\n+    public Object getContribution(String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzIxMjk5OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/DefaultComponent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo1NDoyOVrOICfAuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo1NDoyOVrOICfAuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ3NjE1Mw==", "bodyText": "They could return an Optional, also no need for contributionClass.", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539476153", "createdAt": "2020-12-09T16:54:29Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/DefaultComponent.java", "diffHunk": "@@ -149,37 +155,88 @@ public void setLastModified(Long lastModified) {\n \n     /**\n      * @since 10.3\n+     * @deprecated since TODO: use {@link Registry} associated annotations instead.\n+     * @see #getRegistry(String, Class)\n      */\n+    @Deprecated\n     protected DescriptorRegistry getRegistry() {\n         return registry;\n     }\n \n     /**\n      * @since 10.3\n+     * @deprecated since TODO: use {@link Registry} associated annotations instead.\n      */\n+    @Deprecated\n     protected boolean register(String xp, Descriptor descriptor) {\n         return getRegistry().register(name, xp, descriptor);\n     }\n \n     /**\n      * @since 10.3\n+     * @deprecated since TODO: use {@link Registry} associated annotations instead.\n      */\n+    @Deprecated\n     protected boolean unregister(String xp, Descriptor descriptor) {\n         return getRegistry().unregister(name, xp, descriptor);\n     }\n \n     /**\n      * @since 10.3\n+     * @deprecated since TODO: use {@link Registry} associated annotations instead.\n+     * @see #getContribution(String, String, Class)\n      */\n+    @Deprecated\n     protected <T extends Descriptor> T getDescriptor(String xp, String id) {\n         return getRegistry().getDescriptor(name, xp, id);\n     }\n \n     /**\n      * @since 10.3\n+     * @deprecated since TODO: use {@link Registry} associated annotations instead.\n+     * @see #getContributions(String, Class)\n      */\n+    @Deprecated\n     protected <T extends Descriptor> List<T> getDescriptors(String xp) {\n         return getRegistry().getDescriptors(name, xp);\n     }\n \n+    /**\n+     * @since TODO\n+     */\n+    protected <T> T getSingleContribution(String point, Class<T> contributionClass) {\n+        return getRegistry(point, SingleRegistry.class).getContribution(contributionClass);\n+    }\n+\n+    /**\n+     * @since TODO\n+     */\n+    protected <T> T getContribution(String point, String id, Class<T> contributionClass) {\n+        return getRegistry(point, MapRegistry.class).getContribution(id, contributionClass);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzIyMDA5OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/DefaultComponent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo1NTo0OFrOICfE6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo1NTo0OFrOICfE6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ3NzIyNQ==", "bodyText": "What do you think to throw an IllegalStateException instead of returning null which will causes NPE later?", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539477225", "createdAt": "2020-12-09T16:55:48Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/DefaultComponent.java", "diffHunk": "@@ -149,37 +155,88 @@ public void setLastModified(Long lastModified) {\n \n     /**\n      * @since 10.3\n+     * @deprecated since TODO: use {@link Registry} associated annotations instead.\n+     * @see #getRegistry(String, Class)\n      */\n+    @Deprecated\n     protected DescriptorRegistry getRegistry() {\n         return registry;\n     }\n \n     /**\n      * @since 10.3\n+     * @deprecated since TODO: use {@link Registry} associated annotations instead.\n      */\n+    @Deprecated\n     protected boolean register(String xp, Descriptor descriptor) {\n         return getRegistry().register(name, xp, descriptor);\n     }\n \n     /**\n      * @since 10.3\n+     * @deprecated since TODO: use {@link Registry} associated annotations instead.\n      */\n+    @Deprecated\n     protected boolean unregister(String xp, Descriptor descriptor) {\n         return getRegistry().unregister(name, xp, descriptor);\n     }\n \n     /**\n      * @since 10.3\n+     * @deprecated since TODO: use {@link Registry} associated annotations instead.\n+     * @see #getContribution(String, String, Class)\n      */\n+    @Deprecated\n     protected <T extends Descriptor> T getDescriptor(String xp, String id) {\n         return getRegistry().getDescriptor(name, xp, id);\n     }\n \n     /**\n      * @since 10.3\n+     * @deprecated since TODO: use {@link Registry} associated annotations instead.\n+     * @see #getContributions(String, Class)\n      */\n+    @Deprecated\n     protected <T extends Descriptor> List<T> getDescriptors(String xp) {\n         return getRegistry().getDescriptors(name, xp);\n     }\n \n+    /**\n+     * @since TODO\n+     */\n+    protected <T> T getSingleContribution(String point, Class<T> contributionClass) {\n+        return getRegistry(point, SingleRegistry.class).getContribution(contributionClass);\n+    }\n+\n+    /**\n+     * @since TODO\n+     */\n+    protected <T> T getContribution(String point, String id, Class<T> contributionClass) {\n+        return getRegistry(point, MapRegistry.class).getContribution(id, contributionClass);\n+    }\n+\n+    /**\n+     * @since TODO\n+     */\n+    protected <T> List<T> getContributions(String point, Class<T> contributionClass) {\n+        return getRegistry(point, MapRegistry.class).getContributionValues(contributionClass);\n+    }\n+\n+    /**\n+     * @since TODO\n+     */\n+    protected <T> T getRegistry(String point, Class<T> registryClass) {\n+        return getExtensionPoint(point).map(ExtensionPoint::getRegistry).map(registryClass::cast).orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzI1NTIwOnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/impl/ExtensionPointImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNzowMjowN1rOICfZzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjo0ODozNlrOIDTEHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MjU3Mw==", "bodyText": "Could we have it outside of this class, like in ComponentManager? The reason is that this object should be a POJO imho.", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539482573", "createdAt": "2020-12-09T17:02:07Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/impl/ExtensionPointImpl.java", "diffHunk": "@@ -56,6 +66,15 @@\n     @XParent\n     public RegistrationInfo ri;\n \n+    // potential registry class declaration\n+    @XNode(value = \"registry@class\")\n+    protected String registryKlass;\n+\n+    // final operating registry class\n+    protected Registry registry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwNDE2Nw==", "bodyText": "Ok i'll try to move it when reviewing all commits", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539504167", "createdAt": "2020-12-09T17:31:00Z", "author": {"login": "atchertchian"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/impl/ExtensionPointImpl.java", "diffHunk": "@@ -56,6 +66,15 @@\n     @XParent\n     public RegistrationInfo ri;\n \n+    // potential registry class declaration\n+    @XNode(value = \"registry@class\")\n+    protected String registryKlass;\n+\n+    // final operating registry class\n+    protected Registry registry;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MjU3Mw=="}, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxMDczMQ==", "bodyText": "Note that this means moving the registration logics out of this class (and similarly, the registry retrieval will trigger a lookup to the component manager).\nNote that for compat logics, i also think i should stop loading contribution objects on the Extension objects (that should be a POJO too if we're consistent) when a registry is defined: nobody should expect the extension to hold contributions anymore when using registries, and this will spare unneeded xmap load of these objects, wdyt?", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539510731", "createdAt": "2020-12-09T17:37:59Z", "author": {"login": "atchertchian"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/impl/ExtensionPointImpl.java", "diffHunk": "@@ -56,6 +66,15 @@\n     @XParent\n     public RegistrationInfo ri;\n \n+    // potential registry class declaration\n+    @XNode(value = \"registry@class\")\n+    protected String registryKlass;\n+\n+    // final operating registry class\n+    protected Registry registry;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MjU3Mw=="}, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMyODk5MA==", "bodyText": "done with #4537", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r540328990", "createdAt": "2020-12-10T16:48:36Z", "author": {"login": "atchertchian"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/impl/ExtensionPointImpl.java", "diffHunk": "@@ -56,6 +66,15 @@\n     @XParent\n     public RegistrationInfo ri;\n \n+    // potential registry class declaration\n+    @XNode(value = \"registry@class\")\n+    protected String registryKlass;\n+\n+    // final operating registry class\n+    protected Registry registry;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MjU3Mw=="}, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzI2MjM2OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/impl/ExtensionPointImpl.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNzowMzozNlrOICfePw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjo0ODoyMFrOIDTDVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MzcxMQ==", "bodyText": "Why returning null instead of the NULL_REGISTRY?", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539483711", "createdAt": "2020-12-09T17:03:36Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/impl/ExtensionPointImpl.java", "diffHunk": "@@ -76,39 +95,114 @@ public String getSuperComponent() {\n         return superComponent;\n     }\n \n-    public Extension createExtension(Element element) {\n-        return null;\n+    protected XMap getXmap() {\n+        if (xmap == null) {\n+            xmap = new XMap();\n+            for (int i = 0; i < contributions.length; i++) {\n+                Class<?> contrib = contributions[i];\n+                if (contrib != null) {\n+                    xmap.register(contrib);\n+                } else {\n+                    throw new RuntimeException(\n+                            \"Unknown implementation class when contributing to \" + ri.getComponent().getName());\n+                }\n+            }\n+        }\n+        return xmap;\n     }\n \n-    public Object[] loadContributions(RegistrationInfo owner, Extension extension) {\n-        Object[] contribs = extension.getContributions();\n-        if (contribs != null) {\n-            // contributions already computed - this should e an overloaded (extended) extension point\n-            return contribs;\n-        }\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    public void register(Extension extension) {\n         // should compute now the contributions\n         if (contributions != null) {\n-            if (xmap == null) {\n-                xmap = new XMap();\n-                for (Class<?> contrib : contributions) {\n-                    if (contrib != null) {\n-                        xmap.register(contrib);\n-                    } else {\n-                        throw new RuntimeException(\"Unknown implementation class when contributing to \"\n-                                + owner.getComponent().getName());\n-                    }\n-                }\n-            }\n             try {\n-                contribs = xmap.loadAll(new XMapContext(extension.getContext()), extension.getElement());\n+                Context xctx = new XMapContext(extension.getContext());\n+                // backward compatibility\n+                if (extension.getContributions() == null) {\n+                    // overload use case: loaded contributions should use the old descriptor so should not be\n+                    // recomputed\n+                    extension.setContributions(getXmap().loadAll(xctx, extension.getElement()));\n+                }\n+                // fill up registry\n+                Registry registry = getRegistry();\n+                String flag = extension.getId();\n+                if (registry != null && !registry.isFlagged(flag)) {\n+                    registry.flag(flag);\n+                    getXmap().register(registry, xctx, extension.getElement(), flag);\n+                }\n             } catch (XMapException e) {\n                 throw new RuntimeException(\n                         e.getMessage() + \" while processing component: \" + extension.getComponent().getName().getName(),\n                         e);\n             }\n-            extension.setContributions(contribs);\n+        } else {\n+            throw new RuntimeException(String.format(\n+                    \"Cannot contribute contributions from component '%s': extension point '%s:%s' is missing contribution classes\",\n+                    extension.getComponent().getName(), superComponent, name));\n+        }\n+    }\n+\n+    @Override\n+    public void unregister(Extension extension) {\n+        try {\n+            getXmap().unregister(getRegistry(), extension.getId());\n+        } catch (XMapException e) {\n+            log.error(e.getMessage() + \" while unprocessing component: \" + extension.getComponent().getName().getName(),\n+                    e);\n         }\n-        return contribs;\n+    }\n+\n+    @Override\n+    public Registry getRegistry() {\n+        if (registry == null) {\n+            registry = computeFinalRegistry();\n+            if (registry == null) {\n+                registry = NULL_REGISTRY;\n+            }\n+        }\n+        if (registry.isNull()) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4OTM1MQ==", "bodyText": "NULL_REGISTRY is only used for internal caching logics (to avoid detecting over and over that there is no registry defined), i can expose it and return it if better but i'm not convinced it's clearer (?)", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539489351", "createdAt": "2020-12-09T17:11:06Z", "author": {"login": "atchertchian"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/impl/ExtensionPointImpl.java", "diffHunk": "@@ -76,39 +95,114 @@ public String getSuperComponent() {\n         return superComponent;\n     }\n \n-    public Extension createExtension(Element element) {\n-        return null;\n+    protected XMap getXmap() {\n+        if (xmap == null) {\n+            xmap = new XMap();\n+            for (int i = 0; i < contributions.length; i++) {\n+                Class<?> contrib = contributions[i];\n+                if (contrib != null) {\n+                    xmap.register(contrib);\n+                } else {\n+                    throw new RuntimeException(\n+                            \"Unknown implementation class when contributing to \" + ri.getComponent().getName());\n+                }\n+            }\n+        }\n+        return xmap;\n     }\n \n-    public Object[] loadContributions(RegistrationInfo owner, Extension extension) {\n-        Object[] contribs = extension.getContributions();\n-        if (contribs != null) {\n-            // contributions already computed - this should e an overloaded (extended) extension point\n-            return contribs;\n-        }\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    public void register(Extension extension) {\n         // should compute now the contributions\n         if (contributions != null) {\n-            if (xmap == null) {\n-                xmap = new XMap();\n-                for (Class<?> contrib : contributions) {\n-                    if (contrib != null) {\n-                        xmap.register(contrib);\n-                    } else {\n-                        throw new RuntimeException(\"Unknown implementation class when contributing to \"\n-                                + owner.getComponent().getName());\n-                    }\n-                }\n-            }\n             try {\n-                contribs = xmap.loadAll(new XMapContext(extension.getContext()), extension.getElement());\n+                Context xctx = new XMapContext(extension.getContext());\n+                // backward compatibility\n+                if (extension.getContributions() == null) {\n+                    // overload use case: loaded contributions should use the old descriptor so should not be\n+                    // recomputed\n+                    extension.setContributions(getXmap().loadAll(xctx, extension.getElement()));\n+                }\n+                // fill up registry\n+                Registry registry = getRegistry();\n+                String flag = extension.getId();\n+                if (registry != null && !registry.isFlagged(flag)) {\n+                    registry.flag(flag);\n+                    getXmap().register(registry, xctx, extension.getElement(), flag);\n+                }\n             } catch (XMapException e) {\n                 throw new RuntimeException(\n                         e.getMessage() + \" while processing component: \" + extension.getComponent().getName().getName(),\n                         e);\n             }\n-            extension.setContributions(contribs);\n+        } else {\n+            throw new RuntimeException(String.format(\n+                    \"Cannot contribute contributions from component '%s': extension point '%s:%s' is missing contribution classes\",\n+                    extension.getComponent().getName(), superComponent, name));\n+        }\n+    }\n+\n+    @Override\n+    public void unregister(Extension extension) {\n+        try {\n+            getXmap().unregister(getRegistry(), extension.getId());\n+        } catch (XMapException e) {\n+            log.error(e.getMessage() + \" while unprocessing component: \" + extension.getComponent().getName().getName(),\n+                    e);\n         }\n-        return contribs;\n+    }\n+\n+    @Override\n+    public Registry getRegistry() {\n+        if (registry == null) {\n+            registry = computeFinalRegistry();\n+            if (registry == null) {\n+                registry = NULL_REGISTRY;\n+            }\n+        }\n+        if (registry.isNull()) {\n+            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MzcxMQ=="}, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MDI4OQ==", "bodyText": "I think it is, the other side is getting NPE in border cases, it might help no?", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539490289", "createdAt": "2020-12-09T17:12:16Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/impl/ExtensionPointImpl.java", "diffHunk": "@@ -76,39 +95,114 @@ public String getSuperComponent() {\n         return superComponent;\n     }\n \n-    public Extension createExtension(Element element) {\n-        return null;\n+    protected XMap getXmap() {\n+        if (xmap == null) {\n+            xmap = new XMap();\n+            for (int i = 0; i < contributions.length; i++) {\n+                Class<?> contrib = contributions[i];\n+                if (contrib != null) {\n+                    xmap.register(contrib);\n+                } else {\n+                    throw new RuntimeException(\n+                            \"Unknown implementation class when contributing to \" + ri.getComponent().getName());\n+                }\n+            }\n+        }\n+        return xmap;\n     }\n \n-    public Object[] loadContributions(RegistrationInfo owner, Extension extension) {\n-        Object[] contribs = extension.getContributions();\n-        if (contribs != null) {\n-            // contributions already computed - this should e an overloaded (extended) extension point\n-            return contribs;\n-        }\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    public void register(Extension extension) {\n         // should compute now the contributions\n         if (contributions != null) {\n-            if (xmap == null) {\n-                xmap = new XMap();\n-                for (Class<?> contrib : contributions) {\n-                    if (contrib != null) {\n-                        xmap.register(contrib);\n-                    } else {\n-                        throw new RuntimeException(\"Unknown implementation class when contributing to \"\n-                                + owner.getComponent().getName());\n-                    }\n-                }\n-            }\n             try {\n-                contribs = xmap.loadAll(new XMapContext(extension.getContext()), extension.getElement());\n+                Context xctx = new XMapContext(extension.getContext());\n+                // backward compatibility\n+                if (extension.getContributions() == null) {\n+                    // overload use case: loaded contributions should use the old descriptor so should not be\n+                    // recomputed\n+                    extension.setContributions(getXmap().loadAll(xctx, extension.getElement()));\n+                }\n+                // fill up registry\n+                Registry registry = getRegistry();\n+                String flag = extension.getId();\n+                if (registry != null && !registry.isFlagged(flag)) {\n+                    registry.flag(flag);\n+                    getXmap().register(registry, xctx, extension.getElement(), flag);\n+                }\n             } catch (XMapException e) {\n                 throw new RuntimeException(\n                         e.getMessage() + \" while processing component: \" + extension.getComponent().getName().getName(),\n                         e);\n             }\n-            extension.setContributions(contribs);\n+        } else {\n+            throw new RuntimeException(String.format(\n+                    \"Cannot contribute contributions from component '%s': extension point '%s:%s' is missing contribution classes\",\n+                    extension.getComponent().getName(), superComponent, name));\n+        }\n+    }\n+\n+    @Override\n+    public void unregister(Extension extension) {\n+        try {\n+            getXmap().unregister(getRegistry(), extension.getId());\n+        } catch (XMapException e) {\n+            log.error(e.getMessage() + \" while unprocessing component: \" + extension.getComponent().getName().getName(),\n+                    e);\n         }\n-        return contribs;\n+    }\n+\n+    @Override\n+    public Registry getRegistry() {\n+        if (registry == null) {\n+            registry = computeFinalRegistry();\n+            if (registry == null) {\n+                registry = NULL_REGISTRY;\n+            }\n+        }\n+        if (registry.isNull()) {\n+            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MzcxMQ=="}, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxMTExNg==", "bodyText": "Let's see when moving this API to the ComponentManager then", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539511116", "createdAt": "2020-12-09T17:38:34Z", "author": {"login": "atchertchian"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/impl/ExtensionPointImpl.java", "diffHunk": "@@ -76,39 +95,114 @@ public String getSuperComponent() {\n         return superComponent;\n     }\n \n-    public Extension createExtension(Element element) {\n-        return null;\n+    protected XMap getXmap() {\n+        if (xmap == null) {\n+            xmap = new XMap();\n+            for (int i = 0; i < contributions.length; i++) {\n+                Class<?> contrib = contributions[i];\n+                if (contrib != null) {\n+                    xmap.register(contrib);\n+                } else {\n+                    throw new RuntimeException(\n+                            \"Unknown implementation class when contributing to \" + ri.getComponent().getName());\n+                }\n+            }\n+        }\n+        return xmap;\n     }\n \n-    public Object[] loadContributions(RegistrationInfo owner, Extension extension) {\n-        Object[] contribs = extension.getContributions();\n-        if (contribs != null) {\n-            // contributions already computed - this should e an overloaded (extended) extension point\n-            return contribs;\n-        }\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    public void register(Extension extension) {\n         // should compute now the contributions\n         if (contributions != null) {\n-            if (xmap == null) {\n-                xmap = new XMap();\n-                for (Class<?> contrib : contributions) {\n-                    if (contrib != null) {\n-                        xmap.register(contrib);\n-                    } else {\n-                        throw new RuntimeException(\"Unknown implementation class when contributing to \"\n-                                + owner.getComponent().getName());\n-                    }\n-                }\n-            }\n             try {\n-                contribs = xmap.loadAll(new XMapContext(extension.getContext()), extension.getElement());\n+                Context xctx = new XMapContext(extension.getContext());\n+                // backward compatibility\n+                if (extension.getContributions() == null) {\n+                    // overload use case: loaded contributions should use the old descriptor so should not be\n+                    // recomputed\n+                    extension.setContributions(getXmap().loadAll(xctx, extension.getElement()));\n+                }\n+                // fill up registry\n+                Registry registry = getRegistry();\n+                String flag = extension.getId();\n+                if (registry != null && !registry.isFlagged(flag)) {\n+                    registry.flag(flag);\n+                    getXmap().register(registry, xctx, extension.getElement(), flag);\n+                }\n             } catch (XMapException e) {\n                 throw new RuntimeException(\n                         e.getMessage() + \" while processing component: \" + extension.getComponent().getName().getName(),\n                         e);\n             }\n-            extension.setContributions(contribs);\n+        } else {\n+            throw new RuntimeException(String.format(\n+                    \"Cannot contribute contributions from component '%s': extension point '%s:%s' is missing contribution classes\",\n+                    extension.getComponent().getName(), superComponent, name));\n+        }\n+    }\n+\n+    @Override\n+    public void unregister(Extension extension) {\n+        try {\n+            getXmap().unregister(getRegistry(), extension.getId());\n+        } catch (XMapException e) {\n+            log.error(e.getMessage() + \" while unprocessing component: \" + extension.getComponent().getName().getName(),\n+                    e);\n         }\n-        return contribs;\n+    }\n+\n+    @Override\n+    public Registry getRegistry() {\n+        if (registry == null) {\n+            registry = computeFinalRegistry();\n+            if (registry == null) {\n+                registry = NULL_REGISTRY;\n+            }\n+        }\n+        if (registry.isNull()) {\n+            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MzcxMQ=="}, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMyODc5MA==", "bodyText": "I re-arranged the logics while moving to ComponentManager, see #4537", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r540328790", "createdAt": "2020-12-10T16:48:20Z", "author": {"login": "atchertchian"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/model/impl/ExtensionPointImpl.java", "diffHunk": "@@ -76,39 +95,114 @@ public String getSuperComponent() {\n         return superComponent;\n     }\n \n-    public Extension createExtension(Element element) {\n-        return null;\n+    protected XMap getXmap() {\n+        if (xmap == null) {\n+            xmap = new XMap();\n+            for (int i = 0; i < contributions.length; i++) {\n+                Class<?> contrib = contributions[i];\n+                if (contrib != null) {\n+                    xmap.register(contrib);\n+                } else {\n+                    throw new RuntimeException(\n+                            \"Unknown implementation class when contributing to \" + ri.getComponent().getName());\n+                }\n+            }\n+        }\n+        return xmap;\n     }\n \n-    public Object[] loadContributions(RegistrationInfo owner, Extension extension) {\n-        Object[] contribs = extension.getContributions();\n-        if (contribs != null) {\n-            // contributions already computed - this should e an overloaded (extended) extension point\n-            return contribs;\n-        }\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    public void register(Extension extension) {\n         // should compute now the contributions\n         if (contributions != null) {\n-            if (xmap == null) {\n-                xmap = new XMap();\n-                for (Class<?> contrib : contributions) {\n-                    if (contrib != null) {\n-                        xmap.register(contrib);\n-                    } else {\n-                        throw new RuntimeException(\"Unknown implementation class when contributing to \"\n-                                + owner.getComponent().getName());\n-                    }\n-                }\n-            }\n             try {\n-                contribs = xmap.loadAll(new XMapContext(extension.getContext()), extension.getElement());\n+                Context xctx = new XMapContext(extension.getContext());\n+                // backward compatibility\n+                if (extension.getContributions() == null) {\n+                    // overload use case: loaded contributions should use the old descriptor so should not be\n+                    // recomputed\n+                    extension.setContributions(getXmap().loadAll(xctx, extension.getElement()));\n+                }\n+                // fill up registry\n+                Registry registry = getRegistry();\n+                String flag = extension.getId();\n+                if (registry != null && !registry.isFlagged(flag)) {\n+                    registry.flag(flag);\n+                    getXmap().register(registry, xctx, extension.getElement(), flag);\n+                }\n             } catch (XMapException e) {\n                 throw new RuntimeException(\n                         e.getMessage() + \" while processing component: \" + extension.getComponent().getName().getName(),\n                         e);\n             }\n-            extension.setContributions(contribs);\n+        } else {\n+            throw new RuntimeException(String.format(\n+                    \"Cannot contribute contributions from component '%s': extension point '%s:%s' is missing contribution classes\",\n+                    extension.getComponent().getName(), superComponent, name));\n+        }\n+    }\n+\n+    @Override\n+    public void unregister(Extension extension) {\n+        try {\n+            getXmap().unregister(getRegistry(), extension.getId());\n+        } catch (XMapException e) {\n+            log.error(e.getMessage() + \" while unprocessing component: \" + extension.getComponent().getName().getName(),\n+                    e);\n         }\n-        return contribs;\n+    }\n+\n+    @Override\n+    public Registry getRegistry() {\n+        if (registry == null) {\n+            registry = computeFinalRegistry();\n+            if (registry == null) {\n+                registry = NULL_REGISTRY;\n+            }\n+        }\n+        if (registry.isNull()) {\n+            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MzcxMQ=="}, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzI3NDg3OnYy", "diffSide": "RIGHT", "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/services/config/ConfigurationServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNzowNjoxMVrOICfl2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjo0OToxOFrOIDTGNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4NTY1Nw==", "bodyText": "I think we should have the same method on MapRegistry and SingleRegistry, depending on the implementation an exception may be thrown. Then this is the service's responsibility to know which methods it has to call, and this will avoid such methods.", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539485657", "createdAt": "2020-12-09T17:06:11Z", "author": {"login": "kevinleturc"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/services/config/ConfigurationServiceImpl.java", "diffHunk": "@@ -59,32 +59,8 @@\n \n     protected static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n \n-    /**\n-     * XXX remove once we are able to get such a cached map from DefaultComponent\n-     *\n-     * @since 10.3\n-     */\n-    protected volatile Map<String, ConfigurationPropertyDescriptor> descriptors;\n-\n-    /**\n-     * XXX remove once we are able to get such a cached map from DefaultComponent.\n-     * <p>\n-     * We'd ideally need a <T extends Descriptor> Map<String, T> getDescriptors(String xp) with cache method.\n-     *\n-     * @since 10.3\n-     */\n-    protected Map<String, ConfigurationPropertyDescriptor> getDescriptors() {\n-        Map<String, ConfigurationPropertyDescriptor> d = descriptors;\n-        if (d == null) {\n-            synchronized (this) {\n-                d = descriptors;\n-                if (d == null) {\n-                    List<ConfigurationPropertyDescriptor> descs = getDescriptors(CONFIGURATION_EP);\n-                    descriptors = d = descs.stream().collect(Collectors.toMap(desc -> desc.getId(), desc -> desc));\n-                }\n-            }\n-        }\n-        return d;\n+    protected MapRegistry getMapRegistry() {\n+        return getRegistry(CONFIGURATION_EP, MapRegistry.class);\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxMjYwNw==", "bodyText": "I started by putting both Map and Single API on the interface indeed, but i'm not sure it's clearer, and since people can define their own registry class, maybe it's better to keep this out of the interface (?). We can rediscuss this in all cases, i'll try to re-arrange the code with other feedback first.", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r539512607", "createdAt": "2020-12-09T17:40:39Z", "author": {"login": "atchertchian"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/services/config/ConfigurationServiceImpl.java", "diffHunk": "@@ -59,32 +59,8 @@\n \n     protected static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n \n-    /**\n-     * XXX remove once we are able to get such a cached map from DefaultComponent\n-     *\n-     * @since 10.3\n-     */\n-    protected volatile Map<String, ConfigurationPropertyDescriptor> descriptors;\n-\n-    /**\n-     * XXX remove once we are able to get such a cached map from DefaultComponent.\n-     * <p>\n-     * We'd ideally need a <T extends Descriptor> Map<String, T> getDescriptors(String xp) with cache method.\n-     *\n-     * @since 10.3\n-     */\n-    protected Map<String, ConfigurationPropertyDescriptor> getDescriptors() {\n-        Map<String, ConfigurationPropertyDescriptor> d = descriptors;\n-        if (d == null) {\n-            synchronized (this) {\n-                d = descriptors;\n-                if (d == null) {\n-                    List<ConfigurationPropertyDescriptor> descs = getDescriptors(CONFIGURATION_EP);\n-                    descriptors = d = descs.stream().collect(Collectors.toMap(desc -> desc.getId(), desc -> desc));\n-                }\n-            }\n-        }\n-        return d;\n+    protected MapRegistry getMapRegistry() {\n+        return getRegistry(CONFIGURATION_EP, MapRegistry.class);\n     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4NTY1Nw=="}, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMyOTUyNg==", "bodyText": "I think API should be simpler now, but we can discuss this again in the upcoming migration PR (will reference it here when done)", "url": "https://github.com/nuxeo/nuxeo/pull/4490#discussion_r540329526", "createdAt": "2020-12-10T16:49:18Z", "author": {"login": "atchertchian"}, "path": "modules/runtime/nuxeo-runtime/src/main/java/org/nuxeo/runtime/services/config/ConfigurationServiceImpl.java", "diffHunk": "@@ -59,32 +59,8 @@\n \n     protected static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n \n-    /**\n-     * XXX remove once we are able to get such a cached map from DefaultComponent\n-     *\n-     * @since 10.3\n-     */\n-    protected volatile Map<String, ConfigurationPropertyDescriptor> descriptors;\n-\n-    /**\n-     * XXX remove once we are able to get such a cached map from DefaultComponent.\n-     * <p>\n-     * We'd ideally need a <T extends Descriptor> Map<String, T> getDescriptors(String xp) with cache method.\n-     *\n-     * @since 10.3\n-     */\n-    protected Map<String, ConfigurationPropertyDescriptor> getDescriptors() {\n-        Map<String, ConfigurationPropertyDescriptor> d = descriptors;\n-        if (d == null) {\n-            synchronized (this) {\n-                d = descriptors;\n-                if (d == null) {\n-                    List<ConfigurationPropertyDescriptor> descs = getDescriptors(CONFIGURATION_EP);\n-                    descriptors = d = descs.stream().collect(Collectors.toMap(desc -> desc.getId(), desc -> desc));\n-                }\n-            }\n-        }\n-        return d;\n+    protected MapRegistry getMapRegistry() {\n+        return getRegistry(CONFIGURATION_EP, MapRegistry.class);\n     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4NTY1Nw=="}, "originalCommit": {"oid": "c54a3203f9a5a483ad9f7b126a8d895a9304ecb3"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4248, "cost": 1, "resetAt": "2021-11-03T18:41:40Z"}}}