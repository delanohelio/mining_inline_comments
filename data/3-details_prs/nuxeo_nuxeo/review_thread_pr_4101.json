{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NDYxNjE5", "number": 4101, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjo1NTo1MFrOEEq1QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwODowNjo1OVrOEf383g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzMxNTIxOnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/model/BaseSession.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjo1NTo1MFrOGib05g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjo1NTo1MFrOGib05g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MDY3OA==", "bodyText": "missing new line", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r438760678", "createdAt": "2020-06-11T12:55:50Z", "author": {"login": "NourNuxeo"}, "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/model/BaseSession.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ */\n+package org.nuxeo.ecm.core.model;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.Access;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.ecm.core.blob.DocumentBlobManager;\n+import org.nuxeo.ecm.core.query.QueryFilter;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Common code for VCS and DBS {@link Session} implementations.\n+ *\n+ * @since 11.1\n+ */\n+public abstract class BaseSession implements Session<QueryFilter> {\n+\n+    protected final Repository repository;\n+\n+    protected BaseSession(Repository repository) {\n+        this.repository = repository;\n+    }\n+\n+    protected DocumentBlobManager getDocumentBlobManager() {\n+        return Framework.getService(DocumentBlobManager.class);\n+    }\n+\n+    protected void notifyAfterCopy(Document doc) {\n+        getDocumentBlobManager().notifyAfterCopy(doc);\n+    }\n+\n+    /*\n+     * ----- Common ACP code -----\n+     */\n+\n+    protected void checkNegativeAcl(ACP acp) {\n+        if (acp == null || isNegativeAclAllowed()) {\n+            return;\n+        }\n+        for (ACL acl : acp.getACLs()) {\n+            if (acl.getName().equals(ACL.INHERITED_ACL)) {\n+                continue;\n+            }\n+            for (ACE ace : acl.getACEs()) {\n+                if (ace.isGranted()) {\n+                    continue;\n+                }\n+                String permission = ace.getPermission();\n+                if (permission.equals(SecurityConstants.EVERYTHING)\n+                        && ace.getUsername().equals(SecurityConstants.EVERYONE)) {\n+                    continue;\n+                }\n+                // allow Write, as we're sure it doesn't include Read/Browse\n+                if (permission.equals(SecurityConstants.WRITE)) {\n+                    continue;\n+                }\n+                throw new IllegalArgumentException(\"Negative ACL not allowed: \" + ace);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the ACP for the document (without any inheritance).\n+     *\n+     * @param doc the document\n+     * @return the ACP\n+     */\n+    public abstract ACP getACP(Document doc);\n+\n+    @Override\n+    public ACP getMergedACP(Document doc) {\n+        Document base = doc.isVersion() ? doc.getSourceDocument() : doc;\n+        if (base == null) {\n+            return null;\n+        }\n+        ACP acp = getACP(base);\n+        if (doc.getParent() == null) {\n+            return acp;\n+        }\n+        // get inherited ACLs only if no blocking inheritance ACE exists in the top level ACP\n+        ACL acl = null;\n+        if (acp == null || acp.getAccess(SecurityConstants.EVERYONE, SecurityConstants.EVERYTHING) != Access.DENY) {\n+            acl = getInheritedACLs(doc);\n+        }\n+        if (acp == null) {\n+            if (acl == null) {\n+                return null;\n+            }\n+            acp = new ACPImpl();\n+        }\n+        if (acl != null) {\n+            acp.addACL(acl);\n+        }\n+        return acp;\n+    }\n+\n+    protected ACL getInheritedACLs(Document doc) {\n+        doc = doc.getParent();\n+        ACL merged = null;\n+        while (doc != null) {\n+            ACP acp = getACP(doc);\n+            if (acp != null) {\n+                ACL acl = acp.getMergedACLs(ACL.INHERITED_ACL);\n+                if (merged == null) {\n+                    merged = acl;\n+                } else {\n+                    merged.addAll(acl);\n+                }\n+                if (acp.getAccess(SecurityConstants.EVERYONE, SecurityConstants.EVERYTHING) == Access.DENY) {\n+                    break;\n+                }\n+            }\n+            doc = doc.getParent();\n+        }\n+        return merged;\n+    }\n+\n+    /**\n+     * Returns the merge of two ACPs.\n+     */\n+    protected ACP updateACP(ACP curAcp, ACP addAcp) {\n+        if (curAcp == null) {\n+            return addAcp;\n+        }\n+        ACP newAcp = curAcp.clone(); // clone as we may modify ACLs and ACPs\n+        Map<String, ACL> acls = new HashMap<>();\n+        for (ACL acl : newAcp.getACLs()) {\n+            String name = acl.getName();\n+            if (ACL.INHERITED_ACL.equals(name)) {\n+                throw new IllegalStateException(curAcp.toString());\n+            }\n+            acls.put(name, acl);\n+        }\n+        for (ACL acl : addAcp.getACLs()) {\n+            String name = acl.getName();\n+            if (ACL.INHERITED_ACL.equals(name)) {\n+                continue;\n+            }\n+            ACL curAcl = acls.get(name);\n+            if (curAcl != null) {\n+                // TODO avoid duplicates\n+                curAcl.addAll(acl);\n+            } else {\n+                newAcp.addACL(acl);\n+            }\n+        }\n+        return newAcp;\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31a3986c22f18d45305312f14be68217611beef9"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzg2NjUyOnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/EmbeddedFunctions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNTowMDowNFrOGihUhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzo1MzowMVrOGjEyUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1MDY5NQ==", "bodyText": "maybe make the members final as they are meant to be set once per instantiation ?", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r438850695", "createdAt": "2020-06-11T15:00:04Z", "author": {"login": "NourNuxeo"}, "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/EmbeddedFunctions.java", "diffHunk": "@@ -132,82 +143,93 @@ public static boolean isAccessAllowed(Serializable id, Set<String> principals, S\n      * @param id the id of the document\n      * @param principals the allowed identities\n      * @param permissions the allowed permissions\n+     * @param disableVersionACL whether ACLs on a version are disabled\n+     * @since 11.1\n      */\n     public static boolean isAccessAllowed(Connection conn, Serializable id, Set<String> principals,\n-            Set<String> permissions) throws SQLException {\n-        if (isLogEnabled()) {\n-            logDebug(\"isAccessAllowed \" + id + \" \" + principals + \" \" + permissions);\n-        }\n-        try (PreparedStatement ps1 = conn.prepareStatement(\n+            Set<String> permissions, boolean disableVersionACL) throws SQLException {\n+        try (PreparedStatement psAcl = conn.prepareStatement(\n                 \"SELECT \\\"GRANT\\\", \\\"PERMISSION\\\", \\\"USER\\\" FROM \\\"ACLS\\\" WHERE ID = ? AND (STATUS IS NULL OR STATUS = 1) ORDER BY POS\");\n-                PreparedStatement ps2 = conn.prepareStatement(\"SELECT PARENTID FROM HIERARCHY WHERE ID = ?\")) {\n-            boolean first = true;\n-            do {\n-                /*\n-                 * Check permissions at this level.\n-                 */\n-                ps1.setObject(1, id);\n-                try (ResultSet rs = ps1.executeQuery()) {\n-                    while (rs.next()) {\n-                        boolean grant = rs.getShort(1) != 0;\n-                        String permission = rs.getString(2);\n-                        String user = rs.getString(3);\n-                        if (isLogEnabled()) {\n-                            logDebug(\" -> \" + user + \" \" + permission + \" \" + grant);\n-                        }\n-                        if (principals.contains(user) && permissions.contains(permission)) {\n-                            if (isLogEnabled()) {\n-                                logDebug(\" => \" + grant);\n-                            }\n-                            return grant;\n-                        }\n+                PreparedStatement psHier = conn.prepareStatement(\n+                        \"SELECT PARENTID, ISVERSION FROM HIERARCHY WHERE ID = ?\");\n+                PreparedStatement psVer = conn.prepareStatement(\"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n+            RowInfo rowInfo = null; // info about the row for the current id\n+            if (disableVersionACL) {\n+                // if it's a version, ignore its ACL and find the live doc\n+                rowInfo = getRowInfo(psHier, psVer, id);\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                    if (id == null) {\n+                        return false;\n                     }\n+                    rowInfo = null;\n                 }\n-                /*\n-                 * Nothing conclusive found, repeat on the parent.\n-                 */\n-                ps2.setObject(1, id);\n-                Serializable newId;\n-                try (ResultSet rs = ps2.executeQuery()) {\n-                    if (rs.next()) {\n-                        newId = (Serializable) rs.getObject(1);\n-                        if (rs.wasNull()) {\n-                            newId = null;\n-                        }\n-                    } else {\n-                        // no such id\n-                        newId = null;\n-                    }\n+            }\n+            do {\n+                // check permissions at this level\n+                Boolean access = getAccess(psAcl, id, principals, permissions);\n+                if (access != null) {\n+                    return access;\n+                }\n+                // nothing conclusive found, repeat on the parent\n+                if (rowInfo == null) {\n+                    rowInfo = getRowInfo(psHier, psVer, id);\n+                }\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                } else {\n+                    id = rowInfo.parentId;\n                 }\n-                if (first && newId == null) {\n-                    // there is no parent for the first level\n-                    // we may have a version on our hands, find the live doc\n-                    try (PreparedStatement ps3 = conn.prepareStatement(\n-                            \"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n-                        ps3.setObject(1, id);\n-                        try (ResultSet rs = ps3.executeQuery()) {\n-                            if (rs.next()) {\n-                                newId = (Serializable) rs.getObject(1);\n-                                if (rs.wasNull()) {\n-                                    newId = null;\n-                                }\n-                            } else {\n-                                // no such id\n-                                newId = null;\n-                            }\n+                rowInfo = null;\n+            } while (id != null);\n+            // we've reached the root or a placeless document, deny access\n+            return false;\n+        }\n+    }\n+\n+    protected static class RowInfo {\n+\n+        public Serializable parentId;\n+\n+        public boolean isVersion;\n+\n+        public Serializable versionableId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82f3d3a11bd4aeab9c37a639ff53aa78b75d968a"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQzMTc2Mw==", "bodyText": "That would mean writing a constructor, and not being able to update the fields independently which is how this is used today. So no, that would be much more verbosity.", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r439431763", "createdAt": "2020-06-12T13:53:01Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/EmbeddedFunctions.java", "diffHunk": "@@ -132,82 +143,93 @@ public static boolean isAccessAllowed(Serializable id, Set<String> principals, S\n      * @param id the id of the document\n      * @param principals the allowed identities\n      * @param permissions the allowed permissions\n+     * @param disableVersionACL whether ACLs on a version are disabled\n+     * @since 11.1\n      */\n     public static boolean isAccessAllowed(Connection conn, Serializable id, Set<String> principals,\n-            Set<String> permissions) throws SQLException {\n-        if (isLogEnabled()) {\n-            logDebug(\"isAccessAllowed \" + id + \" \" + principals + \" \" + permissions);\n-        }\n-        try (PreparedStatement ps1 = conn.prepareStatement(\n+            Set<String> permissions, boolean disableVersionACL) throws SQLException {\n+        try (PreparedStatement psAcl = conn.prepareStatement(\n                 \"SELECT \\\"GRANT\\\", \\\"PERMISSION\\\", \\\"USER\\\" FROM \\\"ACLS\\\" WHERE ID = ? AND (STATUS IS NULL OR STATUS = 1) ORDER BY POS\");\n-                PreparedStatement ps2 = conn.prepareStatement(\"SELECT PARENTID FROM HIERARCHY WHERE ID = ?\")) {\n-            boolean first = true;\n-            do {\n-                /*\n-                 * Check permissions at this level.\n-                 */\n-                ps1.setObject(1, id);\n-                try (ResultSet rs = ps1.executeQuery()) {\n-                    while (rs.next()) {\n-                        boolean grant = rs.getShort(1) != 0;\n-                        String permission = rs.getString(2);\n-                        String user = rs.getString(3);\n-                        if (isLogEnabled()) {\n-                            logDebug(\" -> \" + user + \" \" + permission + \" \" + grant);\n-                        }\n-                        if (principals.contains(user) && permissions.contains(permission)) {\n-                            if (isLogEnabled()) {\n-                                logDebug(\" => \" + grant);\n-                            }\n-                            return grant;\n-                        }\n+                PreparedStatement psHier = conn.prepareStatement(\n+                        \"SELECT PARENTID, ISVERSION FROM HIERARCHY WHERE ID = ?\");\n+                PreparedStatement psVer = conn.prepareStatement(\"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n+            RowInfo rowInfo = null; // info about the row for the current id\n+            if (disableVersionACL) {\n+                // if it's a version, ignore its ACL and find the live doc\n+                rowInfo = getRowInfo(psHier, psVer, id);\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                    if (id == null) {\n+                        return false;\n                     }\n+                    rowInfo = null;\n                 }\n-                /*\n-                 * Nothing conclusive found, repeat on the parent.\n-                 */\n-                ps2.setObject(1, id);\n-                Serializable newId;\n-                try (ResultSet rs = ps2.executeQuery()) {\n-                    if (rs.next()) {\n-                        newId = (Serializable) rs.getObject(1);\n-                        if (rs.wasNull()) {\n-                            newId = null;\n-                        }\n-                    } else {\n-                        // no such id\n-                        newId = null;\n-                    }\n+            }\n+            do {\n+                // check permissions at this level\n+                Boolean access = getAccess(psAcl, id, principals, permissions);\n+                if (access != null) {\n+                    return access;\n+                }\n+                // nothing conclusive found, repeat on the parent\n+                if (rowInfo == null) {\n+                    rowInfo = getRowInfo(psHier, psVer, id);\n+                }\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                } else {\n+                    id = rowInfo.parentId;\n                 }\n-                if (first && newId == null) {\n-                    // there is no parent for the first level\n-                    // we may have a version on our hands, find the live doc\n-                    try (PreparedStatement ps3 = conn.prepareStatement(\n-                            \"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n-                        ps3.setObject(1, id);\n-                        try (ResultSet rs = ps3.executeQuery()) {\n-                            if (rs.next()) {\n-                                newId = (Serializable) rs.getObject(1);\n-                                if (rs.wasNull()) {\n-                                    newId = null;\n-                                }\n-                            } else {\n-                                // no such id\n-                                newId = null;\n-                            }\n+                rowInfo = null;\n+            } while (id != null);\n+            // we've reached the root or a placeless document, deny access\n+            return false;\n+        }\n+    }\n+\n+    protected static class RowInfo {\n+\n+        public Serializable parentId;\n+\n+        public boolean isVersion;\n+\n+        public Serializable versionableId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1MDY5NQ=="}, "originalCommit": {"oid": "82f3d3a11bd4aeab9c37a639ff53aa78b75d968a"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzg5ODA1OnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/EmbeddedFunctions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNTowNzo0NVrOGihpFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzo1NToyNFrOGjE3uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NTk1Nw==", "bodyText": "Less clarity but maybe this would avoid getting a boolean before knowing if it's aimed at the user regarding the permission ?\nI tried adding a comment not to lose too much readability:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            boolean grant = rs.getShort(1) != 0;\n          \n          \n            \n                            String permission = rs.getString(2);\n          \n          \n            \n                            String user = rs.getString(3);\n          \n          \n            \n                            if (principals.contains(user) && permissions.contains(permission)) {\n          \n          \n            \n                                return grant;\n          \n          \n            \n                            }\n          \n          \n            \n                            String permission = rs.getString(2);\n          \n          \n            \n                            String user = rs.getString(3);\n          \n          \n            \n                            if (principals.contains(user) && permissions.contains(permission)) {\n          \n          \n            \n                                return rs.getShort(1) != 0; // the access grant boolean value\n          \n          \n            \n                            }", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r438855957", "createdAt": "2020-06-11T15:07:45Z", "author": {"login": "NourNuxeo"}, "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/EmbeddedFunctions.java", "diffHunk": "@@ -132,82 +143,93 @@ public static boolean isAccessAllowed(Serializable id, Set<String> principals, S\n      * @param id the id of the document\n      * @param principals the allowed identities\n      * @param permissions the allowed permissions\n+     * @param disableVersionACL whether ACLs on a version are disabled\n+     * @since 11.1\n      */\n     public static boolean isAccessAllowed(Connection conn, Serializable id, Set<String> principals,\n-            Set<String> permissions) throws SQLException {\n-        if (isLogEnabled()) {\n-            logDebug(\"isAccessAllowed \" + id + \" \" + principals + \" \" + permissions);\n-        }\n-        try (PreparedStatement ps1 = conn.prepareStatement(\n+            Set<String> permissions, boolean disableVersionACL) throws SQLException {\n+        try (PreparedStatement psAcl = conn.prepareStatement(\n                 \"SELECT \\\"GRANT\\\", \\\"PERMISSION\\\", \\\"USER\\\" FROM \\\"ACLS\\\" WHERE ID = ? AND (STATUS IS NULL OR STATUS = 1) ORDER BY POS\");\n-                PreparedStatement ps2 = conn.prepareStatement(\"SELECT PARENTID FROM HIERARCHY WHERE ID = ?\")) {\n-            boolean first = true;\n-            do {\n-                /*\n-                 * Check permissions at this level.\n-                 */\n-                ps1.setObject(1, id);\n-                try (ResultSet rs = ps1.executeQuery()) {\n-                    while (rs.next()) {\n-                        boolean grant = rs.getShort(1) != 0;\n-                        String permission = rs.getString(2);\n-                        String user = rs.getString(3);\n-                        if (isLogEnabled()) {\n-                            logDebug(\" -> \" + user + \" \" + permission + \" \" + grant);\n-                        }\n-                        if (principals.contains(user) && permissions.contains(permission)) {\n-                            if (isLogEnabled()) {\n-                                logDebug(\" => \" + grant);\n-                            }\n-                            return grant;\n-                        }\n+                PreparedStatement psHier = conn.prepareStatement(\n+                        \"SELECT PARENTID, ISVERSION FROM HIERARCHY WHERE ID = ?\");\n+                PreparedStatement psVer = conn.prepareStatement(\"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n+            RowInfo rowInfo = null; // info about the row for the current id\n+            if (disableVersionACL) {\n+                // if it's a version, ignore its ACL and find the live doc\n+                rowInfo = getRowInfo(psHier, psVer, id);\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                    if (id == null) {\n+                        return false;\n                     }\n+                    rowInfo = null;\n                 }\n-                /*\n-                 * Nothing conclusive found, repeat on the parent.\n-                 */\n-                ps2.setObject(1, id);\n-                Serializable newId;\n-                try (ResultSet rs = ps2.executeQuery()) {\n-                    if (rs.next()) {\n-                        newId = (Serializable) rs.getObject(1);\n-                        if (rs.wasNull()) {\n-                            newId = null;\n-                        }\n-                    } else {\n-                        // no such id\n-                        newId = null;\n-                    }\n+            }\n+            do {\n+                // check permissions at this level\n+                Boolean access = getAccess(psAcl, id, principals, permissions);\n+                if (access != null) {\n+                    return access;\n+                }\n+                // nothing conclusive found, repeat on the parent\n+                if (rowInfo == null) {\n+                    rowInfo = getRowInfo(psHier, psVer, id);\n+                }\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                } else {\n+                    id = rowInfo.parentId;\n                 }\n-                if (first && newId == null) {\n-                    // there is no parent for the first level\n-                    // we may have a version on our hands, find the live doc\n-                    try (PreparedStatement ps3 = conn.prepareStatement(\n-                            \"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n-                        ps3.setObject(1, id);\n-                        try (ResultSet rs = ps3.executeQuery()) {\n-                            if (rs.next()) {\n-                                newId = (Serializable) rs.getObject(1);\n-                                if (rs.wasNull()) {\n-                                    newId = null;\n-                                }\n-                            } else {\n-                                // no such id\n-                                newId = null;\n-                            }\n+                rowInfo = null;\n+            } while (id != null);\n+            // we've reached the root or a placeless document, deny access\n+            return false;\n+        }\n+    }\n+\n+    protected static class RowInfo {\n+\n+        public Serializable parentId;\n+\n+        public boolean isVersion;\n+\n+        public Serializable versionableId;\n+    }\n+\n+    protected static RowInfo getRowInfo(PreparedStatement psHier, PreparedStatement psVer, Serializable id)\n+            throws SQLException {\n+        psHier.setObject(1, id);\n+        try (ResultSet rs = psHier.executeQuery()) {\n+            RowInfo rowInfo = new RowInfo();\n+            if (rs.next()) {\n+                rowInfo.parentId = (Serializable) rs.getObject(1);\n+                rowInfo.isVersion = rs.getBoolean(2);\n+                if (rowInfo.isVersion) {\n+                    psVer.setObject(1, id);\n+                    try (ResultSet rs2 = psVer.executeQuery()) {\n+                        if (rs2.next()) {\n+                            rowInfo.versionableId = (Serializable) rs2.getObject(1);\n                         }\n                     }\n                 }\n-                first = false;\n-                id = newId;\n-            } while (id != null);\n-            /*\n-             * We reached the root, deny access.\n-             */\n-            if (isLogEnabled()) {\n-                logDebug(\" => false (root)\");\n             }\n-            return false;\n+            return rowInfo;\n+        }\n+    }\n+\n+    protected static Boolean getAccess(PreparedStatement psAcl, Serializable id, Set<String> principals,\n+            Set<String> permissions) throws SQLException {\n+        psAcl.setObject(1, id);\n+        try (ResultSet rs = psAcl.executeQuery()) {\n+            while (rs.next()) {\n+                boolean grant = rs.getShort(1) != 0;\n+                String permission = rs.getString(2);\n+                String user = rs.getString(3);\n+                if (principals.contains(user) && permissions.contains(permission)) {\n+                    return grant;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82f3d3a11bd4aeab9c37a639ff53aa78b75d968a"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQzMzE0NA==", "bodyText": "I prefer the clarity of getting all the values first, then acting on them. Also, this is just code that was moved.", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r439433144", "createdAt": "2020-06-12T13:55:24Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/EmbeddedFunctions.java", "diffHunk": "@@ -132,82 +143,93 @@ public static boolean isAccessAllowed(Serializable id, Set<String> principals, S\n      * @param id the id of the document\n      * @param principals the allowed identities\n      * @param permissions the allowed permissions\n+     * @param disableVersionACL whether ACLs on a version are disabled\n+     * @since 11.1\n      */\n     public static boolean isAccessAllowed(Connection conn, Serializable id, Set<String> principals,\n-            Set<String> permissions) throws SQLException {\n-        if (isLogEnabled()) {\n-            logDebug(\"isAccessAllowed \" + id + \" \" + principals + \" \" + permissions);\n-        }\n-        try (PreparedStatement ps1 = conn.prepareStatement(\n+            Set<String> permissions, boolean disableVersionACL) throws SQLException {\n+        try (PreparedStatement psAcl = conn.prepareStatement(\n                 \"SELECT \\\"GRANT\\\", \\\"PERMISSION\\\", \\\"USER\\\" FROM \\\"ACLS\\\" WHERE ID = ? AND (STATUS IS NULL OR STATUS = 1) ORDER BY POS\");\n-                PreparedStatement ps2 = conn.prepareStatement(\"SELECT PARENTID FROM HIERARCHY WHERE ID = ?\")) {\n-            boolean first = true;\n-            do {\n-                /*\n-                 * Check permissions at this level.\n-                 */\n-                ps1.setObject(1, id);\n-                try (ResultSet rs = ps1.executeQuery()) {\n-                    while (rs.next()) {\n-                        boolean grant = rs.getShort(1) != 0;\n-                        String permission = rs.getString(2);\n-                        String user = rs.getString(3);\n-                        if (isLogEnabled()) {\n-                            logDebug(\" -> \" + user + \" \" + permission + \" \" + grant);\n-                        }\n-                        if (principals.contains(user) && permissions.contains(permission)) {\n-                            if (isLogEnabled()) {\n-                                logDebug(\" => \" + grant);\n-                            }\n-                            return grant;\n-                        }\n+                PreparedStatement psHier = conn.prepareStatement(\n+                        \"SELECT PARENTID, ISVERSION FROM HIERARCHY WHERE ID = ?\");\n+                PreparedStatement psVer = conn.prepareStatement(\"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n+            RowInfo rowInfo = null; // info about the row for the current id\n+            if (disableVersionACL) {\n+                // if it's a version, ignore its ACL and find the live doc\n+                rowInfo = getRowInfo(psHier, psVer, id);\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                    if (id == null) {\n+                        return false;\n                     }\n+                    rowInfo = null;\n                 }\n-                /*\n-                 * Nothing conclusive found, repeat on the parent.\n-                 */\n-                ps2.setObject(1, id);\n-                Serializable newId;\n-                try (ResultSet rs = ps2.executeQuery()) {\n-                    if (rs.next()) {\n-                        newId = (Serializable) rs.getObject(1);\n-                        if (rs.wasNull()) {\n-                            newId = null;\n-                        }\n-                    } else {\n-                        // no such id\n-                        newId = null;\n-                    }\n+            }\n+            do {\n+                // check permissions at this level\n+                Boolean access = getAccess(psAcl, id, principals, permissions);\n+                if (access != null) {\n+                    return access;\n+                }\n+                // nothing conclusive found, repeat on the parent\n+                if (rowInfo == null) {\n+                    rowInfo = getRowInfo(psHier, psVer, id);\n+                }\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                } else {\n+                    id = rowInfo.parentId;\n                 }\n-                if (first && newId == null) {\n-                    // there is no parent for the first level\n-                    // we may have a version on our hands, find the live doc\n-                    try (PreparedStatement ps3 = conn.prepareStatement(\n-                            \"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n-                        ps3.setObject(1, id);\n-                        try (ResultSet rs = ps3.executeQuery()) {\n-                            if (rs.next()) {\n-                                newId = (Serializable) rs.getObject(1);\n-                                if (rs.wasNull()) {\n-                                    newId = null;\n-                                }\n-                            } else {\n-                                // no such id\n-                                newId = null;\n-                            }\n+                rowInfo = null;\n+            } while (id != null);\n+            // we've reached the root or a placeless document, deny access\n+            return false;\n+        }\n+    }\n+\n+    protected static class RowInfo {\n+\n+        public Serializable parentId;\n+\n+        public boolean isVersion;\n+\n+        public Serializable versionableId;\n+    }\n+\n+    protected static RowInfo getRowInfo(PreparedStatement psHier, PreparedStatement psVer, Serializable id)\n+            throws SQLException {\n+        psHier.setObject(1, id);\n+        try (ResultSet rs = psHier.executeQuery()) {\n+            RowInfo rowInfo = new RowInfo();\n+            if (rs.next()) {\n+                rowInfo.parentId = (Serializable) rs.getObject(1);\n+                rowInfo.isVersion = rs.getBoolean(2);\n+                if (rowInfo.isVersion) {\n+                    psVer.setObject(1, id);\n+                    try (ResultSet rs2 = psVer.executeQuery()) {\n+                        if (rs2.next()) {\n+                            rowInfo.versionableId = (Serializable) rs2.getObject(1);\n                         }\n                     }\n                 }\n-                first = false;\n-                id = newId;\n-            } while (id != null);\n-            /*\n-             * We reached the root, deny access.\n-             */\n-            if (isLogEnabled()) {\n-                logDebug(\" => false (root)\");\n             }\n-            return false;\n+            return rowInfo;\n+        }\n+    }\n+\n+    protected static Boolean getAccess(PreparedStatement psAcl, Serializable id, Set<String> principals,\n+            Set<String> permissions) throws SQLException {\n+        psAcl.setObject(1, id);\n+        try (ResultSet rs = psAcl.executeQuery()) {\n+            while (rs.next()) {\n+                boolean grant = rs.getShort(1) != 0;\n+                String permission = rs.getString(2);\n+                String user = rs.getString(3);\n+                if (principals.contains(user) && permissions.contains(permission)) {\n+                    return grant;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NTk1Nw=="}, "originalCommit": {"oid": "82f3d3a11bd4aeab9c37a639ff53aa78b75d968a"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzk3NTM2OnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/H2Functions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToyNjowOVrOGiia6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzo1NzoxOFrOGjE8bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2ODcxNQ==", "bodyText": "Since the signature is not the same maybe it could get rid off the 2 suffix ?\nif the args are not splittable and end in single object collections the name would still be relevant.\nOr is it because of the alias creation you need a distinct name ?\nit seems you can define the arguments types as in java.lang.Integer.parseInt(java.lang.String, int): https://www.h2database.com/html/commands.html#create_alias\nNot sure the result would be pretty with a Connection, 3 String and 1 boolean though...", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r438868715", "createdAt": "2020-06-11T15:26:09Z", "author": {"login": "NourNuxeo"}, "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/H2Functions.java", "diffHunk": "@@ -55,15 +55,34 @@ public static boolean isInTreeString(Connection conn, String id, String baseId)\n         return isInTree(conn, id, baseId);\n     }\n \n+    /**\n+     * @deprecated since 11.1, unused\n+     */\n+    @Deprecated\n     public static boolean isInTreeLong(Connection conn, Long id, Long baseId) throws SQLException {\n         return isInTree(conn, id, baseId);\n     }\n \n+    /**\n+     * Compatibility signature without {@code disableVersionACL} parameter\n+     */\n     public static boolean isAccessAllowedString(Connection conn, String id, String principals, String permissions)\n             throws SQLException {\n         return isAccessAllowed(conn, id, split(principals), split(permissions));\n     }\n \n+    /**\n+     * @since 11.1\n+     */\n+    public static boolean isAccessAllowed2(Connection conn, String id, String principals, String permissions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82f3d3a11bd4aeab9c37a639ff53aa78b75d968a"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQzNDM1MQ==", "bodyText": "Given that this is purely internal I prefer having a short and obviously unambiguous alias definition, so I won't change it.", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r439434351", "createdAt": "2020-06-12T13:57:18Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/H2Functions.java", "diffHunk": "@@ -55,15 +55,34 @@ public static boolean isInTreeString(Connection conn, String id, String baseId)\n         return isInTree(conn, id, baseId);\n     }\n \n+    /**\n+     * @deprecated since 11.1, unused\n+     */\n+    @Deprecated\n     public static boolean isInTreeLong(Connection conn, Long id, Long baseId) throws SQLException {\n         return isInTree(conn, id, baseId);\n     }\n \n+    /**\n+     * Compatibility signature without {@code disableVersionACL} parameter\n+     */\n     public static boolean isAccessAllowedString(Connection conn, String id, String principals, String permissions)\n             throws SQLException {\n         return isAccessAllowed(conn, id, split(principals), split(permissions));\n     }\n \n+    /**\n+     * @since 11.1\n+     */\n+    public static boolean isAccessAllowed2(Connection conn, String id, String principals, String permissions,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2ODcxNQ=="}, "originalCommit": {"oid": "82f3d3a11bd4aeab9c37a639ff53aa78b75d968a"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODU0MDIwOnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestVersionACLAbstract.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzo1NzowNFrOHMarNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo0NToxNFrOHMk30w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4MjAwNA==", "bodyText": "Shouldn't have the same expected for the two checks on user3?", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r482782004", "createdAt": "2020-09-03T07:57:04Z", "author": {"login": "kevinleturc"}, "path": "modules/core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestVersionACLAbstract.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ */\n+package org.nuxeo.ecm.core;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.nuxeo.ecm.core.api.security.SecurityConstants.BROWSE;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.CoreInstance;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.VersioningOption;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.Access;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.ecm.core.model.BaseSession.VersionAclMode;\n+import org.nuxeo.ecm.core.security.SecurityService;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@RepositoryConfig(cleanup = Granularity.METHOD)\n+public abstract class TestVersionACLAbstract {\n+\n+    @Inject\n+    protected CoreFeature coreFeature;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected SecurityService securityService;\n+\n+    protected abstract VersionAclMode getVersionAclMode();\n+\n+    protected abstract boolean isReadVersionPermissionEnabled();\n+\n+    @Test\n+    public void testVersionACL() {\n+        VersionAclMode mode = getVersionAclMode();\n+        DocumentModel folder = session.createDocumentModel(\"/\", \"folder\", \"Folder\");\n+        folder = session.createDocument(folder);\n+        ACP acp = new ACPImpl();\n+        acp.addACE(\"acl1\", ACE.BLOCK);\n+        acp.addACE(\"acl1\", new ACE(\"user1\", \"Read\"));\n+        session.setACP(folder.getRef(), acp, true);\n+\n+        DocumentModel file = session.createDocumentModel(\"/folder\", \"file\", \"File\");\n+        file = session.createDocument(file);\n+        acp = new ACPImpl();\n+        acp.addACE(\"acl2\", new ACE(\"user2\", \"Read\"));\n+        session.setACP(file.getRef(), acp, true);\n+\n+        // create a version\n+        DocumentRef verRef = session.checkIn(file.getRef(), VersioningOption.MINOR, null);\n+        String verId = session.getDocument(verRef).getId();\n+        // add ACL on version itself\n+        acp = new ACPImpl();\n+        acp.addACE(\"acl3\", new ACE(\"user3\", \"Read\"));\n+        session.setACP(verRef, acp, true);\n+\n+        // create a proxy pointing to the version\n+        session.createProxy(verRef, folder.getRef());\n+        session.save();\n+        coreFeature.waitForAsyncCompletion(); // DBS read ACL computation is async\n+\n+        // check ACLs on the version\n+        acp = session.getACP(verRef);\n+        List<ACE> aces = acpToAces(acp);\n+        assertEquals(mode == VersionAclMode.ENABLED ? 4 : 3, aces.size());\n+        Iterator<ACE> aceit = aces.iterator();\n+        if (mode == VersionAclMode.ENABLED) {\n+            assertEquals(\"user3\", aceit.next().getUsername());\n+        }\n+        assertEquals(\"user2\", aceit.next().getUsername());\n+        assertEquals(\"user1\", aceit.next().getUsername());\n+        assertEquals(ACE.BLOCK, aceit.next());\n+\n+        // check Browse permission on the ACL\n+        assertCanBrowse(false, acp, \"nosuchuser\");\n+        assertCanBrowse(true, acp, \"user1\");\n+        assertCanBrowse(true, acp, \"user2\");\n+        assertCanBrowse(mode == VersionAclMode.ENABLED, acp, \"user3\");\n+\n+        // check Browse permission using CoreSession document API\n+        assertCanBrowse(false, verRef, \"nosuchuser\");\n+        assertCanBrowse(true, verRef, \"user1\");\n+        assertCanBrowse(true, verRef, \"user2\");\n+        assertCanBrowse(mode == VersionAclMode.ENABLED, verRef, \"user3\");\n+\n+        // check Browse permission using CoreSession query API\n+        assertCanQuery(false, verId, \"nosuchuser\");\n+        assertCanQuery(true, verId, \"user1\");\n+        assertCanQuery(true, verId, \"user2\");\n+        assertCanQuery(mode != VersionAclMode.DISABLED, verId, \"user3\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbb694af7b66deed6184bfce0c2c52a35458099"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0OTA3NQ==", "bodyText": "Good question. No, the reason is that there's historically a difference in behavior here, which is captured by the VersionAclMode.LEGACY mode:\n/** Version ACL disabled for direct access but enabled for queries. */\nLEGACY", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r482949075", "createdAt": "2020-09-03T12:45:14Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestVersionACLAbstract.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ */\n+package org.nuxeo.ecm.core;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.nuxeo.ecm.core.api.security.SecurityConstants.BROWSE;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.CoreInstance;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.VersioningOption;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.Access;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.ecm.core.model.BaseSession.VersionAclMode;\n+import org.nuxeo.ecm.core.security.SecurityService;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@RepositoryConfig(cleanup = Granularity.METHOD)\n+public abstract class TestVersionACLAbstract {\n+\n+    @Inject\n+    protected CoreFeature coreFeature;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected SecurityService securityService;\n+\n+    protected abstract VersionAclMode getVersionAclMode();\n+\n+    protected abstract boolean isReadVersionPermissionEnabled();\n+\n+    @Test\n+    public void testVersionACL() {\n+        VersionAclMode mode = getVersionAclMode();\n+        DocumentModel folder = session.createDocumentModel(\"/\", \"folder\", \"Folder\");\n+        folder = session.createDocument(folder);\n+        ACP acp = new ACPImpl();\n+        acp.addACE(\"acl1\", ACE.BLOCK);\n+        acp.addACE(\"acl1\", new ACE(\"user1\", \"Read\"));\n+        session.setACP(folder.getRef(), acp, true);\n+\n+        DocumentModel file = session.createDocumentModel(\"/folder\", \"file\", \"File\");\n+        file = session.createDocument(file);\n+        acp = new ACPImpl();\n+        acp.addACE(\"acl2\", new ACE(\"user2\", \"Read\"));\n+        session.setACP(file.getRef(), acp, true);\n+\n+        // create a version\n+        DocumentRef verRef = session.checkIn(file.getRef(), VersioningOption.MINOR, null);\n+        String verId = session.getDocument(verRef).getId();\n+        // add ACL on version itself\n+        acp = new ACPImpl();\n+        acp.addACE(\"acl3\", new ACE(\"user3\", \"Read\"));\n+        session.setACP(verRef, acp, true);\n+\n+        // create a proxy pointing to the version\n+        session.createProxy(verRef, folder.getRef());\n+        session.save();\n+        coreFeature.waitForAsyncCompletion(); // DBS read ACL computation is async\n+\n+        // check ACLs on the version\n+        acp = session.getACP(verRef);\n+        List<ACE> aces = acpToAces(acp);\n+        assertEquals(mode == VersionAclMode.ENABLED ? 4 : 3, aces.size());\n+        Iterator<ACE> aceit = aces.iterator();\n+        if (mode == VersionAclMode.ENABLED) {\n+            assertEquals(\"user3\", aceit.next().getUsername());\n+        }\n+        assertEquals(\"user2\", aceit.next().getUsername());\n+        assertEquals(\"user1\", aceit.next().getUsername());\n+        assertEquals(ACE.BLOCK, aceit.next());\n+\n+        // check Browse permission on the ACL\n+        assertCanBrowse(false, acp, \"nosuchuser\");\n+        assertCanBrowse(true, acp, \"user1\");\n+        assertCanBrowse(true, acp, \"user2\");\n+        assertCanBrowse(mode == VersionAclMode.ENABLED, acp, \"user3\");\n+\n+        // check Browse permission using CoreSession document API\n+        assertCanBrowse(false, verRef, \"nosuchuser\");\n+        assertCanBrowse(true, verRef, \"user1\");\n+        assertCanBrowse(true, verRef, \"user2\");\n+        assertCanBrowse(mode == VersionAclMode.ENABLED, verRef, \"user3\");\n+\n+        // check Browse permission using CoreSession query API\n+        assertCanQuery(false, verId, \"nosuchuser\");\n+        assertCanQuery(true, verId, \"user1\");\n+        assertCanQuery(true, verId, \"user2\");\n+        assertCanQuery(mode != VersionAclMode.DISABLED, verId, \"user3\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4MjAwNA=="}, "originalCommit": {"oid": "ddbb694af7b66deed6184bfce0c2c52a35458099"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODU4MDE0OnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/model/BaseSession.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwODowNjo1OVrOHMbDhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowNjoyOVrOHMlr6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4ODIzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Optional<String> val = configurationService.getString(VERSION_ACL_DISABLED_PROP);\n          \n          \n            \n                        if (!val.isPresent()) {\n          \n          \n            \n                            return ENABLED;\n          \n          \n            \n                        }\n          \n          \n            \n                        String val = configurationService.getString(VERSION_ACL_DISABLED_PROP).orElse(\"false\");\n          \n      \n    \n    \n  \n\n?", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r482788230", "createdAt": "2020-09-03T08:06:59Z", "author": {"login": "kevinleturc"}, "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/model/BaseSession.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ */\n+package org.nuxeo.ecm.core.model;\n+\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.Access;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.api.security.impl.ACLImpl;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.ecm.core.blob.DocumentBlobManager;\n+import org.nuxeo.ecm.core.query.QueryFilter;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Common code for VCS and DBS {@link Session} implementations.\n+ *\n+ * @since 11.3\n+ */\n+public abstract class BaseSession implements Session<QueryFilter> {\n+\n+    private static final Logger log = LogManager.getLogger(BaseSession.class);\n+\n+    /**\n+     * Configuration property controlling whether ACLs on versions are disabled.\n+     *\n+     * @since 11.3\n+     */\n+    public static final String VERSION_ACL_DISABLED_PROP = \"org.nuxeo.version.acl.disabled\";\n+\n+    /**\n+     * Configuration property controlling whether ReadVersion permission is disabled.\n+     *\n+     * @since 11.3\n+     */\n+    public static final String READ_VERSION_PERM_DISABLED_PROP = \"org.nuxeo.version.readversion.disabled\";\n+\n+    /** INTERNAL. How we deal with ACLs on versions. */\n+    public enum VersionAclMode {\n+        /** Version ACL enabled. */\n+        ENABLED,\n+        /** Version ACL disabled. */\n+        DISABLED,\n+        /** Version ACL disabled for direct access but enabled for queries. */\n+        LEGACY;\n+\n+        public static VersionAclMode getConfiguration() {\n+            if (!Framework.isInitialized()) {\n+                // unit tests\n+                return ENABLED;\n+            }\n+            ConfigurationService configurationService = Framework.getService(ConfigurationService.class);\n+            Optional<String> val = configurationService.getString(VERSION_ACL_DISABLED_PROP);\n+            if (!val.isPresent()) {\n+                return ENABLED;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbb694af7b66deed6184bfce0c2c52a35458099"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MjQwOA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r482962408", "createdAt": "2020-09-03T13:06:29Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/model/BaseSession.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ */\n+package org.nuxeo.ecm.core.model;\n+\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.Access;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.api.security.impl.ACLImpl;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.ecm.core.blob.DocumentBlobManager;\n+import org.nuxeo.ecm.core.query.QueryFilter;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Common code for VCS and DBS {@link Session} implementations.\n+ *\n+ * @since 11.3\n+ */\n+public abstract class BaseSession implements Session<QueryFilter> {\n+\n+    private static final Logger log = LogManager.getLogger(BaseSession.class);\n+\n+    /**\n+     * Configuration property controlling whether ACLs on versions are disabled.\n+     *\n+     * @since 11.3\n+     */\n+    public static final String VERSION_ACL_DISABLED_PROP = \"org.nuxeo.version.acl.disabled\";\n+\n+    /**\n+     * Configuration property controlling whether ReadVersion permission is disabled.\n+     *\n+     * @since 11.3\n+     */\n+    public static final String READ_VERSION_PERM_DISABLED_PROP = \"org.nuxeo.version.readversion.disabled\";\n+\n+    /** INTERNAL. How we deal with ACLs on versions. */\n+    public enum VersionAclMode {\n+        /** Version ACL enabled. */\n+        ENABLED,\n+        /** Version ACL disabled. */\n+        DISABLED,\n+        /** Version ACL disabled for direct access but enabled for queries. */\n+        LEGACY;\n+\n+        public static VersionAclMode getConfiguration() {\n+            if (!Framework.isInitialized()) {\n+                // unit tests\n+                return ENABLED;\n+            }\n+            ConfigurationService configurationService = Framework.getService(ConfigurationService.class);\n+            Optional<String> val = configurationService.getString(VERSION_ACL_DISABLED_PROP);\n+            if (!val.isPresent()) {\n+                return ENABLED;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4ODIzMA=="}, "originalCommit": {"oid": "ddbb694af7b66deed6184bfce0c2c52a35458099"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4137, "cost": 1, "resetAt": "2021-11-03T18:41:40Z"}}}