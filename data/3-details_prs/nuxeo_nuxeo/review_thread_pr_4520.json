{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NDYyODM3", "number": 4520, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMDo0MDo1M1rOFVnPaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxNjoyNlrOFVoIWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjA3MzM2OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMDo0MDo1M1rOIeKafg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOToxOTo1M1rOIe4WGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQ5ODgxNA==", "bodyText": "Could you revert this change?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568498814", "createdAt": "2021-02-02T10:40:53Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -5,7 +5,7 @@\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n+ *         http://www.apache.org/licenses/LICENSE-2.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI1MTM1NQ==", "bodyText": "OK, done on the code", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569251355", "createdAt": "2021-02-03T09:19:53Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -5,7 +5,7 @@\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n+ *         http://www.apache.org/licenses/LICENSE-2.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQ5ODgxNA=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjA3MzgyOnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMDo0MDo1N1rOIeKavg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOToyMDowN1rOIe4Wuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQ5ODg3OA==", "bodyText": "Could you revert this change?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568498878", "createdAt": "2021-02-02T10:40:57Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -14,23 +14,28 @@\n  * limitations under the License.\n  *\n  * Contributors:\n- *     Michal Obrebski - Nuxeo\n+ *         Michal Obrebski - Nuxeo", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI1MTUxNQ==", "bodyText": "OK, done on the code", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569251515", "createdAt": "2021-02-03T09:20:07Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -14,23 +14,28 @@\n  * limitations under the License.\n  *\n  * Contributors:\n- *     Michal Obrebski - Nuxeo\n+ *         Michal Obrebski - Nuxeo", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQ5ODg3OA=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjA3NDM4OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMDo0MTowNVrOIeKbEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOTo0MDoxOVrOIe5OgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQ5ODk2Mw==", "bodyText": "Could you revert this change?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568498963", "createdAt": "2021-02-02T10:41:05Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -63,19 +68,21 @@\n public class EasyShare extends ModuleRoot {\n \n     private static final String DEFAULT_PAGE_INDEX = \"0\";\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2NTc5Mg==", "bodyText": "done", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569265792", "createdAt": "2021-02-03T09:40:19Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -63,19 +68,21 @@\n public class EasyShare extends ModuleRoot {\n \n     private static final String DEFAULT_PAGE_INDEX = \"0\";\n-\n+    ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQ5ODk2Mw=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjA3NDcxOnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMDo0MToxMFrOIeKbQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMDo0MToxMFrOIeKbQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQ5OTAxMA==", "bodyText": "Could you revert this change?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568499010", "createdAt": "2021-02-02T10:41:10Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -63,19 +68,21 @@\n public class EasyShare extends ModuleRoot {\n \n     private static final String DEFAULT_PAGE_INDEX = \"0\";\n-\n+    \n     private static final Long PAGE_SIZE = 20L;\n \n     private static final String SHARE_DOC_TYPE = \"EasyShareFolder\";\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjA5MTU1OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMDo0NToxMVrOIeKlWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOToyOTo1MVrOIe4xYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUwMTU5Mg==", "bodyText": "It doesn't follow our code formatting (see https://github.com/nuxeo/nuxeo/blob/master/tools/nuxeo_formatter.xml).\nAt the same time, would you mind removing the final keyword in front of parameters, they are not needed.", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568501592", "createdAt": "2021-02-02T10:45:11Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -63,19 +68,21 @@\n public class EasyShare extends ModuleRoot {\n \n     private static final String DEFAULT_PAGE_INDEX = \"0\";\n-\n+    \n     private static final Long PAGE_SIZE = 20L;\n \n     private static final String SHARE_DOC_TYPE = \"EasyShareFolder\";\n-\n+    \n     protected final Log log = LogFactory.getLog(EasyShare.class);\n \n     @GET\n     public Object doGet() {\n         return getView(\"index\");\n     }\n \n-    public EasyShareUnrestrictedRunner buildUnrestrictedRunner(final String docId, final Long pageIndex) {\n+    public EasyShareUnrestrictedRunner buildUnrestrictedRunner(final String jSessionId,\n+            final String accessCode,\n+            final String docId, final Long pageIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUwODU3Nw==", "bodyText": "It seems the whole class is not formatted, could you perform it?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568508577", "createdAt": "2021-02-02T10:55:56Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -63,19 +68,21 @@\n public class EasyShare extends ModuleRoot {\n \n     private static final String DEFAULT_PAGE_INDEX = \"0\";\n-\n+    \n     private static final Long PAGE_SIZE = 20L;\n \n     private static final String SHARE_DOC_TYPE = \"EasyShareFolder\";\n-\n+    \n     protected final Log log = LogFactory.getLog(EasyShare.class);\n \n     @GET\n     public Object doGet() {\n         return getView(\"index\");\n     }\n \n-    public EasyShareUnrestrictedRunner buildUnrestrictedRunner(final String docId, final Long pageIndex) {\n+    public EasyShareUnrestrictedRunner buildUnrestrictedRunner(final String jSessionId,\n+            final String accessCode,\n+            final String docId, final Long pageIndex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUwMTU5Mg=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI1ODMzOA==", "bodyText": "I just worked on features as the previous code was formatted as it in 10.10. I reapply the settings for this project and format classes.", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569258338", "createdAt": "2021-02-03T09:29:51Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -63,19 +68,21 @@\n public class EasyShare extends ModuleRoot {\n \n     private static final String DEFAULT_PAGE_INDEX = \"0\";\n-\n+    \n     private static final Long PAGE_SIZE = 20L;\n \n     private static final String SHARE_DOC_TYPE = \"EasyShareFolder\";\n-\n+    \n     protected final Log log = LogFactory.getLog(EasyShare.class);\n \n     @GET\n     public Object doGet() {\n         return getView(\"index\");\n     }\n \n-    public EasyShareUnrestrictedRunner buildUnrestrictedRunner(final String docId, final Long pageIndex) {\n+    public EasyShareUnrestrictedRunner buildUnrestrictedRunner(final String jSessionId,\n+            final String accessCode,\n+            final String docId, final Long pageIndex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUwMTU5Mg=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjExMzI1OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMDo1MDowN1rOIeKyKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOTozMTo0OFrOIe42yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUwNDg3NA==", "bodyText": "Could you change these checks by an early return way? Like this, we don't have too many nested conditions and the code is clearer.\nSomething such as:\nif (!session.exists(new IdRef(docId))) {\n    return getView(\"notfound\");\n}\n\nDocumentModel document = session.getDocument(new IdRef(docId));\n...", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568504874", "createdAt": "2021-02-02T10:50:07Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -91,59 +98,159 @@ public Object run(CoreSession session, IdRef docRef) throws NuxeoException {\n                         return getView(\"expired\").arg(\"docShare\", docShare);\n                     }\n \n-                    DocumentModel document = session.getDocument(new IdRef(docId));\n+                    // Check if ref exists preventing user as document not found\n+                    // instead of denied\n+                    if (session.exists(new IdRef(docId))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI1OTcyMw==", "bodyText": "You're right, done", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569259723", "createdAt": "2021-02-03T09:31:48Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -91,59 +98,159 @@ public Object run(CoreSession session, IdRef docRef) throws NuxeoException {\n                         return getView(\"expired\").arg(\"docShare\", docShare);\n                     }\n \n-                    DocumentModel document = session.getDocument(new IdRef(docId));\n+                    // Check if ref exists preventing user as document not found\n+                    // instead of denied\n+                    if (session.exists(new IdRef(docId))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUwNDg3NA=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE2NDY0OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowMjo0OFrOIeLRrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMzo0MTo0MFrOIfCsgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxMjk0Mg==", "bodyText": "Doesn't it a backward compatibility change? What happens if the query parameter for jSessionId is not present?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568512942", "createdAt": "2021-02-02T11:02:48Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -91,59 +98,159 @@ public Object run(CoreSession session, IdRef docRef) throws NuxeoException {\n                         return getView(\"expired\").arg(\"docShare\", docShare);\n                     }\n \n-                    DocumentModel document = session.getDocument(new IdRef(docId));\n+                    // Check if ref exists preventing user as document not found\n+                    // instead of denied\n+                    if (session.exists(new IdRef(docId))) {\n+                        DocumentModel document = session.getDocument(new IdRef(docId));\n \n-                    String query = buildQuery(document);\n+                        // Check validity of accesscode (password)\n+                        if (!checkIfAccessCodeIsValid(docShare,accessCode)) {\n+                            return getView(\"access\").arg(\"docShare\", docShare).arg(\"doc\", document).arg(\n+                                           \"wrongAccessCode\", StringUtils.isNotEmpty(accessCode));\n+                        }\n+\n+                        // Check validity of \"authenticated client\" comparing current JSESSIONID \n+                        // with JSESSIONID captured when password was specified by user.\n+                        // Goal is to avoid sending a link to another person without \n+                        // entering the accessCode (password)\n+                        if (StringUtils.isNotBlank(jSessionId) &&\n+                                StringUtils.isNotBlank(getRequestJSESSIONID()) &&\n+                                !jSessionId.equals(getRequestJSESSIONID())) {\n+                             return getView(\"denied\");\n+                        }\n+                        \n+                        String query = buildQuery(document);\n \n-                    if (query == null) {\n-                        return getView(\"denied\");\n+                        if (query == null) {\n+                            return getView(\"notfound\");\n+                        }\n+\n+                        try (OperationContext opCtx = new OperationContext(session)) {\n+                            OperationChain chain = new OperationChain(\"getEasyShareContent\");\n+                            chain.add(\"Document.Query\")\n+                                    .set(\"query\", query)\n+                                    .set(\"currentPageIndex\", pageIndex)\n+                                    .set(\"pageSize\", PAGE_SIZE);\n+\n+                            AutomationService automationService = Framework.getService(AutomationService.class);\n+                            PaginableDocumentModelListImpl paginable = (PaginableDocumentModelListImpl) automationService.run(\n+                                    opCtx, chain);\n+\n+                            try (OperationContext ctx = new OperationContext(session)) {\n+                                    ctx.setInput(docShare);\n+\n+                                // Audit Log\n+                                Map<String, Object> params = new HashMap<>();\n+                                params.put(\"event\", \"Access\");\n+                                params.put(\"category\", \"Document\");\n+                                params.put(\"comment\", \"IP: \" + getIpAddr());\n+                                automationService.run(ctx, \"Audit.Log\", params);\n+                            }\n+\n+                            // Retrieve SALT for encrypted password\n+                            String encryptedSalt = EasyShareEncryptionUtil.encodeWithSaltString(\n+                                                       EasyShareEncryptionUtil.getNextSaltAsString(),\n+                                                       EasyShareEncryptionUtil.getDefaultSaltAsString());\n+\n+                            // Retrieve encrypted password with SALT\n+                            String encryptedAccessCode = EasyShareEncryptionUtil.encodeWithSaltString(accessCode,\n+                                                             EasyShareEncryptionUtil.decodeWithSaltString(encryptedSalt, \n+                                                             EasyShareEncryptionUtil.getDefaultSaltAsString()));\n+\n+                            // Retrieve encrypted jsessionId\n+                            String encryptedJSessionId = EasyShareEncryptionUtil.encodeWithSaltString(getRequestJSESSIONID(),\n+                                                             EasyShareEncryptionUtil\n+                                                             .decodeWithSaltString(encryptedSalt,\n+                                                             EasyShareEncryptionUtil.getDefaultSaltAsString()));\n+\n+                            return getView(\"folderList\")\n+                                    .arg(\"isFolder\",\n+                                            document.isFolder()\n+                                                    && !SHARE_DOC_TYPE.equals(document.getType())) // Backward\n+                                                                                                   // compatibility\n+                                                                                                   // to\n+                                                                                                   // non-collection\n+                                    .arg(\"currentPageIndex\", paginable.getCurrentPageIndex())\n+                                    .arg(\"numberOfPages\", paginable.getNumberOfPages())\n+                                    .arg(\"docShare\", docShare)\n+                                    .arg(\"docList\", paginable)\n+                                    .arg(\"previousPageAvailable\", paginable.isPreviousPageAvailable())\n+                                    .arg(\"nextPageAvailable\", paginable.isNextPageAvailable())\n+                                    .arg(\"currentPageStatus\",\n+                                            paginable.getProvider().getCurrentPageStatus())\n+                                    .arg(\"accessSecured\", StringUtils.isNotEmpty(accessCode))\n+                                    .arg(\"encryptedAccessCode\", encryptedAccessCode)\n+                                    .arg(\"encryptedSalt\", encryptedSalt)\n+                                    .arg(\"encryptedJSessionId\",encryptedJSessionId);\n+\n+                        } catch (Exception ex) {\n+                            log.error(ex.getMessage());\n+                            return getView(\"denied\");\n+                        }\n+                    } else {\n+                            return getView(\"notfound\");\n                     }\n+                } else {\n+                    return getView(\"notfound\");\n+                }\n+            }\n+        };\n+    }\n+\n+    public EasyShareUnrestrictedRunner buildUnrestrictedRunnerStream(final String jSessionId, final String accessCode, final String docId) {\n+\n+        return new EasyShareUnrestrictedRunner() {\n+            @Override\n+            public Object run(CoreSession session, IdRef docRef) throws NuxeoException {\n+                if (session.exists(docRef)) {\n+                    DocumentModel doc = session.getDocument(docRef);\n+                    try (OperationContext ctx = new OperationContext(session)) {\n+                        DocumentModel docShare = session.getDocument(new IdRef(docId));\n+\n+                        if (!checkIfShareIsValid(docShare)) {\n+                            return Response.serverError().status(Response.Status.NOT_FOUND).build();\n+                        }\n+\n+                        if (!checkIfAccessCodeIsValid(docShare,accessCode)) {\n+                            return Response.serverError().status(Response.Status.FORBIDDEN).build();\n+                        }\n+                        \n+                        if (StringUtils.isBlank(jSessionId) || !jSessionId.equals(getRequestJSESSIONID())) {\n+                            return Response.serverError().status(Response.Status.FORBIDDEN).build();\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyMDkyOQ==", "bodyText": "No backward. the case is :\n\nRetrieve the JSESSIONID when a client \"log in\" providing the right accessCode and put it as a URL parameter (j), this information will be propagated for all generated links (browse in folders or download content)\nWhen connected, the user will click on a link to fetch folder content or download a document (the link is dynamically generated on each refresh)\nOn click, retrieve the URL parameter j (previously encoded with the original JSESSIONID) and compare it with the current JSESSIONID\nIf encoded URL JSESSIONID and current JSESSIONID do not match, we can consider the client (browser) is not the same (maybe the URL has been copied and transferred to another desktop, ...) and so refused the access", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569420929", "createdAt": "2021-02-03T13:41:40Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -91,59 +98,159 @@ public Object run(CoreSession session, IdRef docRef) throws NuxeoException {\n                         return getView(\"expired\").arg(\"docShare\", docShare);\n                     }\n \n-                    DocumentModel document = session.getDocument(new IdRef(docId));\n+                    // Check if ref exists preventing user as document not found\n+                    // instead of denied\n+                    if (session.exists(new IdRef(docId))) {\n+                        DocumentModel document = session.getDocument(new IdRef(docId));\n \n-                    String query = buildQuery(document);\n+                        // Check validity of accesscode (password)\n+                        if (!checkIfAccessCodeIsValid(docShare,accessCode)) {\n+                            return getView(\"access\").arg(\"docShare\", docShare).arg(\"doc\", document).arg(\n+                                           \"wrongAccessCode\", StringUtils.isNotEmpty(accessCode));\n+                        }\n+\n+                        // Check validity of \"authenticated client\" comparing current JSESSIONID \n+                        // with JSESSIONID captured when password was specified by user.\n+                        // Goal is to avoid sending a link to another person without \n+                        // entering the accessCode (password)\n+                        if (StringUtils.isNotBlank(jSessionId) &&\n+                                StringUtils.isNotBlank(getRequestJSESSIONID()) &&\n+                                !jSessionId.equals(getRequestJSESSIONID())) {\n+                             return getView(\"denied\");\n+                        }\n+                        \n+                        String query = buildQuery(document);\n \n-                    if (query == null) {\n-                        return getView(\"denied\");\n+                        if (query == null) {\n+                            return getView(\"notfound\");\n+                        }\n+\n+                        try (OperationContext opCtx = new OperationContext(session)) {\n+                            OperationChain chain = new OperationChain(\"getEasyShareContent\");\n+                            chain.add(\"Document.Query\")\n+                                    .set(\"query\", query)\n+                                    .set(\"currentPageIndex\", pageIndex)\n+                                    .set(\"pageSize\", PAGE_SIZE);\n+\n+                            AutomationService automationService = Framework.getService(AutomationService.class);\n+                            PaginableDocumentModelListImpl paginable = (PaginableDocumentModelListImpl) automationService.run(\n+                                    opCtx, chain);\n+\n+                            try (OperationContext ctx = new OperationContext(session)) {\n+                                    ctx.setInput(docShare);\n+\n+                                // Audit Log\n+                                Map<String, Object> params = new HashMap<>();\n+                                params.put(\"event\", \"Access\");\n+                                params.put(\"category\", \"Document\");\n+                                params.put(\"comment\", \"IP: \" + getIpAddr());\n+                                automationService.run(ctx, \"Audit.Log\", params);\n+                            }\n+\n+                            // Retrieve SALT for encrypted password\n+                            String encryptedSalt = EasyShareEncryptionUtil.encodeWithSaltString(\n+                                                       EasyShareEncryptionUtil.getNextSaltAsString(),\n+                                                       EasyShareEncryptionUtil.getDefaultSaltAsString());\n+\n+                            // Retrieve encrypted password with SALT\n+                            String encryptedAccessCode = EasyShareEncryptionUtil.encodeWithSaltString(accessCode,\n+                                                             EasyShareEncryptionUtil.decodeWithSaltString(encryptedSalt, \n+                                                             EasyShareEncryptionUtil.getDefaultSaltAsString()));\n+\n+                            // Retrieve encrypted jsessionId\n+                            String encryptedJSessionId = EasyShareEncryptionUtil.encodeWithSaltString(getRequestJSESSIONID(),\n+                                                             EasyShareEncryptionUtil\n+                                                             .decodeWithSaltString(encryptedSalt,\n+                                                             EasyShareEncryptionUtil.getDefaultSaltAsString()));\n+\n+                            return getView(\"folderList\")\n+                                    .arg(\"isFolder\",\n+                                            document.isFolder()\n+                                                    && !SHARE_DOC_TYPE.equals(document.getType())) // Backward\n+                                                                                                   // compatibility\n+                                                                                                   // to\n+                                                                                                   // non-collection\n+                                    .arg(\"currentPageIndex\", paginable.getCurrentPageIndex())\n+                                    .arg(\"numberOfPages\", paginable.getNumberOfPages())\n+                                    .arg(\"docShare\", docShare)\n+                                    .arg(\"docList\", paginable)\n+                                    .arg(\"previousPageAvailable\", paginable.isPreviousPageAvailable())\n+                                    .arg(\"nextPageAvailable\", paginable.isNextPageAvailable())\n+                                    .arg(\"currentPageStatus\",\n+                                            paginable.getProvider().getCurrentPageStatus())\n+                                    .arg(\"accessSecured\", StringUtils.isNotEmpty(accessCode))\n+                                    .arg(\"encryptedAccessCode\", encryptedAccessCode)\n+                                    .arg(\"encryptedSalt\", encryptedSalt)\n+                                    .arg(\"encryptedJSessionId\",encryptedJSessionId);\n+\n+                        } catch (Exception ex) {\n+                            log.error(ex.getMessage());\n+                            return getView(\"denied\");\n+                        }\n+                    } else {\n+                            return getView(\"notfound\");\n                     }\n+                } else {\n+                    return getView(\"notfound\");\n+                }\n+            }\n+        };\n+    }\n+\n+    public EasyShareUnrestrictedRunner buildUnrestrictedRunnerStream(final String jSessionId, final String accessCode, final String docId) {\n+\n+        return new EasyShareUnrestrictedRunner() {\n+            @Override\n+            public Object run(CoreSession session, IdRef docRef) throws NuxeoException {\n+                if (session.exists(docRef)) {\n+                    DocumentModel doc = session.getDocument(docRef);\n+                    try (OperationContext ctx = new OperationContext(session)) {\n+                        DocumentModel docShare = session.getDocument(new IdRef(docId));\n+\n+                        if (!checkIfShareIsValid(docShare)) {\n+                            return Response.serverError().status(Response.Status.NOT_FOUND).build();\n+                        }\n+\n+                        if (!checkIfAccessCodeIsValid(docShare,accessCode)) {\n+                            return Response.serverError().status(Response.Status.FORBIDDEN).build();\n+                        }\n+                        \n+                        if (StringUtils.isBlank(jSessionId) || !jSessionId.equals(getRequestJSESSIONID())) {\n+                            return Response.serverError().status(Response.Status.FORBIDDEN).build();\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxMjk0Mg=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE3MzY5OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowNToxMFrOIeLXKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMzo0ODo1NFrOIfDAew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNDM0Nw==", "bodyText": "Why not getting the JSessionId from the parameters like it is done on the GET endpoint?\nOr, why getting the JSessionId from the parameters in the GET endpoint and not from the cookie?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568514347", "createdAt": "2021-02-02T11:05:10Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -185,18 +292,118 @@ private boolean checkIfShareIsValid(DocumentModel docShare) {\n         return true;\n     }\n \n+    \n+    private boolean checkIfAccessCodeIsValid(DocumentModel docShare, String accessCode) {\n+        // Retrieve metadata of current easyshare folder\n+        Boolean docAccessCodeRequired = docShare.getProperty(\"eshare:accessCodeRequired\").getValue(Boolean.class);\n+        String docAccessCode = docShare.getProperty(\"eshare:accessCode\").getValue(String.class);\n+\n+        // Consider a default authorization if no password is not required in easyshare folder metadata (default easyshare feature) \n+        if (BooleanUtils.isNotTrue(docAccessCodeRequired)){\n+            // AccessCode not required\n+            return true;\n+        } else if (StringUtils.isNotBlank(accessCode) && accessCode.equals(docAccessCode)) {\n+            // AccessCode provided and mathing the accessCode defined in Easyshare folder\n+            return true;\n+        } else {\n+            log.error(\"accessCode is empty or does not match for share: \" + docShare.getTitle() + \" (\" + docShare.getId() + \")\");\n+            // Email notification\n+            Map<String, Object> mail = new HashMap<>();\n+            sendNotification(\"easyShareWrongAccessCode\", docShare, mail);\n+            return false;\n+        }\n+    }\n+\n     @Path(\"{shareId}/{folderId}\")\n     @GET\n-    public Object getFolderListing(@PathParam(\"shareId\") String shareId, @PathParam(\"folderId\") final String folderId,\n-            @DefaultValue(DEFAULT_PAGE_INDEX) @QueryParam(\"p\") final Long pageIndex) {\n-        return buildUnrestrictedRunner(folderId, pageIndex).runUnrestricted(shareId);\n+    public Object getFolderListing(@PathParam(\"shareId\") String shareId,\n+            @PathParam(\"folderId\") final String folderId,\n+            @DefaultValue(DEFAULT_PAGE_INDEX) @QueryParam(\"p\") final Long pageIndex, \n+            @QueryParam(\"a\") final String encryptedAccessCode,\n+            @QueryParam(\"s\") final String encryptedSalt,\n+            @QueryParam(\"j\") final String encryptedJSessionId) {\n+\n+    \tString decryptedAccessCode = null;\n+        String decryptedJSessionId = null;\n+        \n+        if (StringUtils.isNotBlank(encryptedAccessCode) && StringUtils.isNotBlank(encryptedSalt)) {\n+            String decryptedSalt = EasyShareEncryptionUtil.decodeWithSaltString(encryptedSalt,\n+                                                         EasyShareEncryptionUtil.getDefaultSaltAsString());\n+            decryptedAccessCode = EasyShareEncryptionUtil\n+                                                        .decodeWithSaltString(encryptedAccessCode, decryptedSalt);\n+            decryptedJSessionId = EasyShareEncryptionUtil\n+                            .decodeWithSaltString(encryptedJSessionId, decryptedSalt);\n+        }\n+        return buildUnrestrictedRunner(decryptedJSessionId, decryptedAccessCode, folderId, pageIndex).runUnrestricted(shareId);\n+    }\n+\n+    @Path(\"{shareId}/{folderId}\")\n+    @POST\n+    public Object postFolderListing(@PathParam(\"shareId\") String shareId,\n+            @PathParam(\"folderId\") final String folderId,\n+            @DefaultValue(DEFAULT_PAGE_INDEX) @FormParam(\"p\") Long pageIndex,\n+            @FormParam(\"accessCode\") final String accessCode) {\n+        return buildUnrestrictedRunner(getRequestJSESSIONID(), accessCode, folderId, pageIndex).runUnrestricted(shareId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNTE5Nw==", "bodyText": "In fact, I don't understand why we're having POST endpoint for get folder listing, get blob stream, etc...", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568515197", "createdAt": "2021-02-02T11:06:30Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -185,18 +292,118 @@ private boolean checkIfShareIsValid(DocumentModel docShare) {\n         return true;\n     }\n \n+    \n+    private boolean checkIfAccessCodeIsValid(DocumentModel docShare, String accessCode) {\n+        // Retrieve metadata of current easyshare folder\n+        Boolean docAccessCodeRequired = docShare.getProperty(\"eshare:accessCodeRequired\").getValue(Boolean.class);\n+        String docAccessCode = docShare.getProperty(\"eshare:accessCode\").getValue(String.class);\n+\n+        // Consider a default authorization if no password is not required in easyshare folder metadata (default easyshare feature) \n+        if (BooleanUtils.isNotTrue(docAccessCodeRequired)){\n+            // AccessCode not required\n+            return true;\n+        } else if (StringUtils.isNotBlank(accessCode) && accessCode.equals(docAccessCode)) {\n+            // AccessCode provided and mathing the accessCode defined in Easyshare folder\n+            return true;\n+        } else {\n+            log.error(\"accessCode is empty or does not match for share: \" + docShare.getTitle() + \" (\" + docShare.getId() + \")\");\n+            // Email notification\n+            Map<String, Object> mail = new HashMap<>();\n+            sendNotification(\"easyShareWrongAccessCode\", docShare, mail);\n+            return false;\n+        }\n+    }\n+\n     @Path(\"{shareId}/{folderId}\")\n     @GET\n-    public Object getFolderListing(@PathParam(\"shareId\") String shareId, @PathParam(\"folderId\") final String folderId,\n-            @DefaultValue(DEFAULT_PAGE_INDEX) @QueryParam(\"p\") final Long pageIndex) {\n-        return buildUnrestrictedRunner(folderId, pageIndex).runUnrestricted(shareId);\n+    public Object getFolderListing(@PathParam(\"shareId\") String shareId,\n+            @PathParam(\"folderId\") final String folderId,\n+            @DefaultValue(DEFAULT_PAGE_INDEX) @QueryParam(\"p\") final Long pageIndex, \n+            @QueryParam(\"a\") final String encryptedAccessCode,\n+            @QueryParam(\"s\") final String encryptedSalt,\n+            @QueryParam(\"j\") final String encryptedJSessionId) {\n+\n+    \tString decryptedAccessCode = null;\n+        String decryptedJSessionId = null;\n+        \n+        if (StringUtils.isNotBlank(encryptedAccessCode) && StringUtils.isNotBlank(encryptedSalt)) {\n+            String decryptedSalt = EasyShareEncryptionUtil.decodeWithSaltString(encryptedSalt,\n+                                                         EasyShareEncryptionUtil.getDefaultSaltAsString());\n+            decryptedAccessCode = EasyShareEncryptionUtil\n+                                                        .decodeWithSaltString(encryptedAccessCode, decryptedSalt);\n+            decryptedJSessionId = EasyShareEncryptionUtil\n+                            .decodeWithSaltString(encryptedJSessionId, decryptedSalt);\n+        }\n+        return buildUnrestrictedRunner(decryptedJSessionId, decryptedAccessCode, folderId, pageIndex).runUnrestricted(shareId);\n+    }\n+\n+    @Path(\"{shareId}/{folderId}\")\n+    @POST\n+    public Object postFolderListing(@PathParam(\"shareId\") String shareId,\n+            @PathParam(\"folderId\") final String folderId,\n+            @DefaultValue(DEFAULT_PAGE_INDEX) @FormParam(\"p\") Long pageIndex,\n+            @FormParam(\"accessCode\") final String accessCode) {\n+        return buildUnrestrictedRunner(getRequestJSESSIONID(), accessCode, folderId, pageIndex).runUnrestricted(shareId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNDM0Nw=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyNjA0Mw==", "bodyText": "Can check my answer here", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569426043", "createdAt": "2021-02-03T13:48:54Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -185,18 +292,118 @@ private boolean checkIfShareIsValid(DocumentModel docShare) {\n         return true;\n     }\n \n+    \n+    private boolean checkIfAccessCodeIsValid(DocumentModel docShare, String accessCode) {\n+        // Retrieve metadata of current easyshare folder\n+        Boolean docAccessCodeRequired = docShare.getProperty(\"eshare:accessCodeRequired\").getValue(Boolean.class);\n+        String docAccessCode = docShare.getProperty(\"eshare:accessCode\").getValue(String.class);\n+\n+        // Consider a default authorization if no password is not required in easyshare folder metadata (default easyshare feature) \n+        if (BooleanUtils.isNotTrue(docAccessCodeRequired)){\n+            // AccessCode not required\n+            return true;\n+        } else if (StringUtils.isNotBlank(accessCode) && accessCode.equals(docAccessCode)) {\n+            // AccessCode provided and mathing the accessCode defined in Easyshare folder\n+            return true;\n+        } else {\n+            log.error(\"accessCode is empty or does not match for share: \" + docShare.getTitle() + \" (\" + docShare.getId() + \")\");\n+            // Email notification\n+            Map<String, Object> mail = new HashMap<>();\n+            sendNotification(\"easyShareWrongAccessCode\", docShare, mail);\n+            return false;\n+        }\n+    }\n+\n     @Path(\"{shareId}/{folderId}\")\n     @GET\n-    public Object getFolderListing(@PathParam(\"shareId\") String shareId, @PathParam(\"folderId\") final String folderId,\n-            @DefaultValue(DEFAULT_PAGE_INDEX) @QueryParam(\"p\") final Long pageIndex) {\n-        return buildUnrestrictedRunner(folderId, pageIndex).runUnrestricted(shareId);\n+    public Object getFolderListing(@PathParam(\"shareId\") String shareId,\n+            @PathParam(\"folderId\") final String folderId,\n+            @DefaultValue(DEFAULT_PAGE_INDEX) @QueryParam(\"p\") final Long pageIndex, \n+            @QueryParam(\"a\") final String encryptedAccessCode,\n+            @QueryParam(\"s\") final String encryptedSalt,\n+            @QueryParam(\"j\") final String encryptedJSessionId) {\n+\n+    \tString decryptedAccessCode = null;\n+        String decryptedJSessionId = null;\n+        \n+        if (StringUtils.isNotBlank(encryptedAccessCode) && StringUtils.isNotBlank(encryptedSalt)) {\n+            String decryptedSalt = EasyShareEncryptionUtil.decodeWithSaltString(encryptedSalt,\n+                                                         EasyShareEncryptionUtil.getDefaultSaltAsString());\n+            decryptedAccessCode = EasyShareEncryptionUtil\n+                                                        .decodeWithSaltString(encryptedAccessCode, decryptedSalt);\n+            decryptedJSessionId = EasyShareEncryptionUtil\n+                            .decodeWithSaltString(encryptedJSessionId, decryptedSalt);\n+        }\n+        return buildUnrestrictedRunner(decryptedJSessionId, decryptedAccessCode, folderId, pageIndex).runUnrestricted(shareId);\n+    }\n+\n+    @Path(\"{shareId}/{folderId}\")\n+    @POST\n+    public Object postFolderListing(@PathParam(\"shareId\") String shareId,\n+            @PathParam(\"folderId\") final String folderId,\n+            @DefaultValue(DEFAULT_PAGE_INDEX) @FormParam(\"p\") Long pageIndex,\n+            @FormParam(\"accessCode\") final String accessCode) {\n+        return buildUnrestrictedRunner(getRequestJSESSIONID(), accessCode, folderId, pageIndex).runUnrestricted(shareId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNDM0Nw=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE4MDU2OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowNjo0NlrOIeLbNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowNjo0NlrOIeLbNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNTM4MA==", "bodyText": "Could you revert this change?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568515380", "createdAt": "2021-02-02T11:06:46Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShare.java", "diffHunk": "@@ -321,4 +487,4 @@ protected String getIpAddr() {\n         }\n         return ip;\n     }\n-}\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 483}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE4MTQxOnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowNjo1NlrOIeLbqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOTo0NDo0OVrOIe5a6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNTQ5Nw==", "bodyText": "Missing Copyright header.", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568515497", "createdAt": "2021-02-02T11:06:56Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2ODk2OA==", "bodyText": "OK, done", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569268968", "createdAt": "2021-02-03T09:44:49Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNTQ5Nw=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE4Mzg3OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowNzoyOFrOIeLdCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOTo0NzowM1rOIe5hbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNTg0OQ==", "bodyText": "Could you add:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class EasyShareEncryptionUtil {\n          \n          \n            \n            /**\n          \n          \n            \n             * @since 11.5\n          \n          \n            \n             */\n          \n          \n            \n            public class EasyShareEncryptionUtil {", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568515849", "createdAt": "2021-02-02T11:07:28Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxODA5Ng==", "bodyText": "It seems that the whole file contains tabs, could you replace them by spaces?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568518096", "createdAt": "2021-02-02T11:11:01Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNTg0OQ=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI3MDYzOA==", "bodyText": "Done for \"since 11.5\" and re-format using nuxeo formater", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569270638", "createdAt": "2021-02-03T09:47:03Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNTg0OQ=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE4Nzc4OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowODoyMlrOIeLfYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowODoyMlrOIeLfYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNjQ0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic static String getDefaultSaltAsString() {\n          \n          \n            \n            \tpublic static String getDefaultSalt() {", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568516448", "createdAt": "2021-02-02T11:08:22Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE4ODM0OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowODozMlrOIeLfwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowODozMlrOIeLfwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNjU0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic static String getNextSaltAsString() {\n          \n          \n            \n            \tpublic static String getNextSalt() {", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568516546", "createdAt": "2021-02-02T11:08:32Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE4OTYyOnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowODo0N1rOIeLgdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowODo0N1rOIeLgdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNjcyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic static String encodeWithSaltString(String input, String salt) {\n          \n          \n            \n            \tpublic static String encode(String input, String salt) {", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568516724", "createdAt": "2021-02-02T11:08:47Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE5MjE0OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowOTozMVrOIeLiFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOTo1MDozN1rOIe5rxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNzE0MA==", "bodyText": "Could you apply our formatter?\nOur lines are 120 characters long and there's no carriage return for the javadoc parameters.", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568517140", "createdAt": "2021-02-02T11:09:31Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI3MzI4Nw==", "bodyText": "Done", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569273287", "createdAt": "2021-02-03T09:50:37Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNzE0MA=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE5Mjg4OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowOTo0NFrOIeLiig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMTowOTo0NFrOIeLiig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNzI1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic static String decodeWithSaltString(String token, String salt) {\n          \n          \n            \n            \tpublic static String decode(String token, String salt) {", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568517258", "createdAt": "2021-02-02T11:09:44Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE5NTM5OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxMDoxN1rOIeLkFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMzoyNzozNlrOIfCGZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNzY1NQ==", "bodyText": "When does it happen? Shouldn't we re-throw a NuxeoException with a Not found/Denied code?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568517655", "createdAt": "2021-02-02T11:10:17Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxMTE3Mg==", "bodyText": "Changed it to remove the try/catch (managed in decodeWithSaltByte throwing NuxeoException. In that case, we're receiving a http 500 error like :\n{\n\"entity-type\": \"exception\",\n\"status\": 500,\n\"message\": \"javax.ws.rs.WebApplicationException: com.sun.jersey.api.MessageException: A message body writer for Java class org.nuxeo.ecm.core.api.NuxeoException, and Java type class org.nuxeo.ecm.core.api.NuxeoException, and MIME media type text/html; charset=UTF-8 was not found.\\n\"\n}\n\nIf I want to manage this part, I should catch the NuxeoException in EasyShare class in all GET/POST method in order to show a \"denied/notfound\" page to end-user ? Like :\n\t\ttry {\n\t\t\t...\n\t\t\t\tdecryptedJSessionId = EasyShareEncryptionUtil.decode(encryptedJSessionId, decryptedSalt);\n\t\t\t...\n\t\t\t}\n\t\t\treturn (Response) buildUnrestrictedRunnerStream(decryptedJSessionId, decryptedAccessCode, shareId)\n\t\t\t\t\t.runUnrestricted(fileId);\n\t\t} catch (NuxeoException e) {\n\t\t\treturn Response.serverError().status(Response.Status.FORBIDDEN).build();\n\t\t}", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569411172", "createdAt": "2021-02-03T13:27:36Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNzY1NQ=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjE5NjQ5OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxMDozN1rOIeLkyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxMDozN1rOIeLkyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxNzgzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate static String encodeWithSaltByte(String input, byte[] salt) {\n          \n          \n            \n            \tprivate static String encode(String input, byte[] salt) {", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568517832", "createdAt": "2021-02-02T11:10:37Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a random salt\n+\t * \n+\t * @return random generated salt over 8 bytes\n+\t */\n+\tprivate static byte[] getNextSaltAsByte() {\n+\t\tbyte[] salt = new byte[8];\n+\t\tnew SecureRandom().nextBytes(salt);\n+\t\treturn salt;\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt byte[]\u00a0(default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tprivate static String encodeWithSaltByte(String input, byte[] salt) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjIwMTQ5OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxMTo1NFrOIeLn1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMTowNDozNlrOIe8w6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxODYxNQ==", "bodyText": "Can't we use URLEncoder or something from a library? Apache libs we depend on may have such things.", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568518615", "createdAt": "2021-02-02T11:11:54Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a random salt\n+\t * \n+\t * @return random generated salt over 8 bytes\n+\t */\n+\tprivate static byte[] getNextSaltAsByte() {\n+\t\tbyte[] salt = new byte[8];\n+\t\tnew SecureRandom().nextBytes(salt);\n+\t\treturn salt;\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt byte[]\u00a0(default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tprivate static String encodeWithSaltByte(String input, byte[] salt) {\n+\t\tif (input == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\ttry {\n+\n+\t\t\tbyte[] randomSalt = salt != null ? salt : SALT;\n+\n+\t\t\tKeySpec keySpec = new PBEKeySpec(null, randomSalt, ITERATION_COUNT);\n+\t\t\tAlgorithmParameterSpec paramSpec = new PBEParameterSpec(randomSalt, ITERATION_COUNT);\n+\t\t\tSecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\n+\n+\t\t\tCipher ecipher = Cipher.getInstance(key.getAlgorithm());\n+\t\t\tecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n+\n+\t\t\tbyte[] enc = ecipher.doFinal(input.getBytes());\n+\n+\t\t\tString res = new String(Base64.encodeBase64(enc));\n+\t\t\t// escapes for url\n+\t\t\tres = res.replace('+', '-').replace('/', '_').replace(\"%\", \"%25\").replace(\"\\n\", \"%0A\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTMyMzc1Mg==", "bodyText": "In fact, using URLEncoder/URLDecoder is not working as expected. For some entries, the passed values are escaped (should not) so the comparision is not working. Following code makes sense for you ?\n    try {\n\n        ...\n        // escapes for url\n        res = res.replace('+', '-').replace('/', '_').replace(\"%\", \"%25\").replace(\"\\n\", \"%0A\");\n\n        return res;\n\n    } catch (GeneralSecurityException e) {\n        // Error on security part, send 403\n        throw new NuxeoException(\"Error encoding/crypting input data\", e, SC_FORBIDDEN);\n    }", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569323752", "createdAt": "2021-02-03T11:04:36Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a random salt\n+\t * \n+\t * @return random generated salt over 8 bytes\n+\t */\n+\tprivate static byte[] getNextSaltAsByte() {\n+\t\tbyte[] salt = new byte[8];\n+\t\tnew SecureRandom().nextBytes(salt);\n+\t\treturn salt;\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt byte[]\u00a0(default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tprivate static String encodeWithSaltByte(String input, byte[] salt) {\n+\t\tif (input == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\ttry {\n+\n+\t\t\tbyte[] randomSalt = salt != null ? salt : SALT;\n+\n+\t\t\tKeySpec keySpec = new PBEKeySpec(null, randomSalt, ITERATION_COUNT);\n+\t\t\tAlgorithmParameterSpec paramSpec = new PBEParameterSpec(randomSalt, ITERATION_COUNT);\n+\t\t\tSecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\n+\n+\t\t\tCipher ecipher = Cipher.getInstance(key.getAlgorithm());\n+\t\t\tecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n+\n+\t\t\tbyte[] enc = ecipher.doFinal(input.getBytes());\n+\n+\t\t\tString res = new String(Base64.encodeBase64(enc));\n+\t\t\t// escapes for url\n+\t\t\tres = res.replace('+', '-').replace('/', '_').replace(\"%\", \"%25\").replace(\"\\n\", \"%0A\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxODYxNQ=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjIwNjUyOnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxMzowNFrOIeLq0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMTowNTo1OVrOIe80hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxOTM3Nw==", "bodyText": "All these exceptions extends GeneralSecurityException, could you catch it instead?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t} catch (InvalidKeySpecException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException\n          \n          \n            \n            \t\t\t\t| InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {\n          \n          \n            \n            \t\t} catch (GeneralSecurityException e) {", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568519377", "createdAt": "2021-02-02T11:13:04Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a random salt\n+\t * \n+\t * @return random generated salt over 8 bytes\n+\t */\n+\tprivate static byte[] getNextSaltAsByte() {\n+\t\tbyte[] salt = new byte[8];\n+\t\tnew SecureRandom().nextBytes(salt);\n+\t\treturn salt;\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt byte[]\u00a0(default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tprivate static String encodeWithSaltByte(String input, byte[] salt) {\n+\t\tif (input == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\ttry {\n+\n+\t\t\tbyte[] randomSalt = salt != null ? salt : SALT;\n+\n+\t\t\tKeySpec keySpec = new PBEKeySpec(null, randomSalt, ITERATION_COUNT);\n+\t\t\tAlgorithmParameterSpec paramSpec = new PBEParameterSpec(randomSalt, ITERATION_COUNT);\n+\t\t\tSecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\n+\n+\t\t\tCipher ecipher = Cipher.getInstance(key.getAlgorithm());\n+\t\t\tecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n+\n+\t\t\tbyte[] enc = ecipher.doFinal(input.getBytes());\n+\n+\t\t\tString res = new String(Base64.encodeBase64(enc));\n+\t\t\t// escapes for url\n+\t\t\tres = res.replace('+', '-').replace('/', '_').replace(\"%\", \"%25\").replace(\"\\n\", \"%0A\");\n+\n+\t\t\treturn res;\n+\n+\t\t} catch (InvalidKeySpecException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException\n+\t\t\t\t| InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTMyNDY3OA==", "bodyText": "Done", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569324678", "createdAt": "2021-02-03T11:05:59Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a random salt\n+\t * \n+\t * @return random generated salt over 8 bytes\n+\t */\n+\tprivate static byte[] getNextSaltAsByte() {\n+\t\tbyte[] salt = new byte[8];\n+\t\tnew SecureRandom().nextBytes(salt);\n+\t\treturn salt;\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt byte[]\u00a0(default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tprivate static String encodeWithSaltByte(String input, byte[] salt) {\n+\t\tif (input == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\ttry {\n+\n+\t\t\tbyte[] randomSalt = salt != null ? salt : SALT;\n+\n+\t\t\tKeySpec keySpec = new PBEKeySpec(null, randomSalt, ITERATION_COUNT);\n+\t\t\tAlgorithmParameterSpec paramSpec = new PBEParameterSpec(randomSalt, ITERATION_COUNT);\n+\t\t\tSecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\n+\n+\t\t\tCipher ecipher = Cipher.getInstance(key.getAlgorithm());\n+\t\t\tecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n+\n+\t\t\tbyte[] enc = ecipher.doFinal(input.getBytes());\n+\n+\t\t\tString res = new String(Base64.encodeBase64(enc));\n+\t\t\t// escapes for url\n+\t\t\tres = res.replace('+', '-').replace('/', '_').replace(\"%\", \"%25\").replace(\"\\n\", \"%0A\");\n+\n+\t\t\treturn res;\n+\n+\t\t} catch (InvalidKeySpecException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException\n+\t\t\t\t| InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxOTM3Nw=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjIwNzc1OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxMzoyMFrOIeLrjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMToyMTo1NVrOIe9Z_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxOTU2NQ==", "bodyText": "Same thing for re-throwing a NuxeoException with the right error code.", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568519565", "createdAt": "2021-02-02T11:13:20Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a random salt\n+\t * \n+\t * @return random generated salt over 8 bytes\n+\t */\n+\tprivate static byte[] getNextSaltAsByte() {\n+\t\tbyte[] salt = new byte[8];\n+\t\tnew SecureRandom().nextBytes(salt);\n+\t\treturn salt;\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt byte[]\u00a0(default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tprivate static String encodeWithSaltByte(String input, byte[] salt) {\n+\t\tif (input == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\ttry {\n+\n+\t\t\tbyte[] randomSalt = salt != null ? salt : SALT;\n+\n+\t\t\tKeySpec keySpec = new PBEKeySpec(null, randomSalt, ITERATION_COUNT);\n+\t\t\tAlgorithmParameterSpec paramSpec = new PBEParameterSpec(randomSalt, ITERATION_COUNT);\n+\t\t\tSecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\n+\n+\t\t\tCipher ecipher = Cipher.getInstance(key.getAlgorithm());\n+\t\t\tecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n+\n+\t\t\tbyte[] enc = ecipher.doFinal(input.getBytes());\n+\n+\t\t\tString res = new String(Base64.encodeBase64(enc));\n+\t\t\t// escapes for url\n+\t\t\tres = res.replace('+', '-').replace('/', '_').replace(\"%\", \"%25\").replace(\"\\n\", \"%0A\");\n+\n+\t\t\treturn res;\n+\n+\t\t} catch (InvalidKeySpecException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException\n+\t\t\t\t| InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {\n+\t\t\treturn null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTMzNDI2OQ==", "bodyText": "In fact, using URLEncoder/URLDecoder is not working as expected. For some entries, the passed values are escaped (should not) so the comparision is not working. Following code makes sense for you ?\n        try {\n\n            ...\n            // escapes for url\n            res = res.replace('+', '-').replace('/', '_').replace(\"%\", \"%25\").replace(\"\\n\", \"%0A\");\n\n            return res;\n\n        } catch (GeneralSecurityException e) {\n            // Error on security part, send 403\n            throw new NuxeoException(\"Error encoding/crypting input data\", e, SC_FORBIDDEN);\n        }", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569334269", "createdAt": "2021-02-03T11:21:55Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a random salt\n+\t * \n+\t * @return random generated salt over 8 bytes\n+\t */\n+\tprivate static byte[] getNextSaltAsByte() {\n+\t\tbyte[] salt = new byte[8];\n+\t\tnew SecureRandom().nextBytes(salt);\n+\t\treturn salt;\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt byte[]\u00a0(default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tprivate static String encodeWithSaltByte(String input, byte[] salt) {\n+\t\tif (input == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\ttry {\n+\n+\t\t\tbyte[] randomSalt = salt != null ? salt : SALT;\n+\n+\t\t\tKeySpec keySpec = new PBEKeySpec(null, randomSalt, ITERATION_COUNT);\n+\t\t\tAlgorithmParameterSpec paramSpec = new PBEParameterSpec(randomSalt, ITERATION_COUNT);\n+\t\t\tSecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\n+\n+\t\t\tCipher ecipher = Cipher.getInstance(key.getAlgorithm());\n+\t\t\tecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n+\n+\t\t\tbyte[] enc = ecipher.doFinal(input.getBytes());\n+\n+\t\t\tString res = new String(Base64.encodeBase64(enc));\n+\t\t\t// escapes for url\n+\t\t\tres = res.replace('+', '-').replace('/', '_').replace(\"%\", \"%25\").replace(\"\\n\", \"%0A\");\n+\n+\t\t\treturn res;\n+\n+\t\t} catch (InvalidKeySpecException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException\n+\t\t\t\t| InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {\n+\t\t\treturn null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxOTU2NQ=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjIwODM2OnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxMzozMVrOIeLr9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMToyMjoxNFrOIe9aug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxOTY3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate static String decodeWithSaltByte(String token, byte[] salt) {\n          \n          \n            \n            \tprivate static String decode(String token, byte[] salt) {", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568519670", "createdAt": "2021-02-02T11:13:31Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a random salt\n+\t * \n+\t * @return random generated salt over 8 bytes\n+\t */\n+\tprivate static byte[] getNextSaltAsByte() {\n+\t\tbyte[] salt = new byte[8];\n+\t\tnew SecureRandom().nextBytes(salt);\n+\t\treturn salt;\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt byte[]\u00a0(default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tprivate static String encodeWithSaltByte(String input, byte[] salt) {\n+\t\tif (input == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\ttry {\n+\n+\t\t\tbyte[] randomSalt = salt != null ? salt : SALT;\n+\n+\t\t\tKeySpec keySpec = new PBEKeySpec(null, randomSalt, ITERATION_COUNT);\n+\t\t\tAlgorithmParameterSpec paramSpec = new PBEParameterSpec(randomSalt, ITERATION_COUNT);\n+\t\t\tSecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\n+\n+\t\t\tCipher ecipher = Cipher.getInstance(key.getAlgorithm());\n+\t\t\tecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n+\n+\t\t\tbyte[] enc = ecipher.doFinal(input.getBytes());\n+\n+\t\t\tString res = new String(Base64.encodeBase64(enc));\n+\t\t\t// escapes for url\n+\t\t\tres = res.replace('+', '-').replace('/', '_').replace(\"%\", \"%25\").replace(\"\\n\", \"%0A\");\n+\n+\t\t\treturn res;\n+\n+\t\t} catch (InvalidKeySpecException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException\n+\t\t\t\t| InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt byte[] (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tprivate static String decodeWithSaltByte(String token, byte[] salt) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTMzNDQ1OA==", "bodyText": "Done", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569334458", "createdAt": "2021-02-03T11:22:14Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a random salt\n+\t * \n+\t * @return random generated salt over 8 bytes\n+\t */\n+\tprivate static byte[] getNextSaltAsByte() {\n+\t\tbyte[] salt = new byte[8];\n+\t\tnew SecureRandom().nextBytes(salt);\n+\t\treturn salt;\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt byte[]\u00a0(default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tprivate static String encodeWithSaltByte(String input, byte[] salt) {\n+\t\tif (input == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\ttry {\n+\n+\t\t\tbyte[] randomSalt = salt != null ? salt : SALT;\n+\n+\t\t\tKeySpec keySpec = new PBEKeySpec(null, randomSalt, ITERATION_COUNT);\n+\t\t\tAlgorithmParameterSpec paramSpec = new PBEParameterSpec(randomSalt, ITERATION_COUNT);\n+\t\t\tSecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\n+\n+\t\t\tCipher ecipher = Cipher.getInstance(key.getAlgorithm());\n+\t\t\tecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n+\n+\t\t\tbyte[] enc = ecipher.doFinal(input.getBytes());\n+\n+\t\t\tString res = new String(Base64.encodeBase64(enc));\n+\t\t\t// escapes for url\n+\t\t\tres = res.replace('+', '-').replace('/', '_').replace(\"%\", \"%25\").replace(\"\\n\", \"%0A\");\n+\n+\t\t\treturn res;\n+\n+\t\t} catch (InvalidKeySpecException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException\n+\t\t\t\t| InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt byte[] (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tprivate static String decodeWithSaltByte(String token, byte[] salt) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxOTY3MA=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjIwOTMzOnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxMzo0N1rOIeLsjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxMzo0N1rOIeLsjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUxOTgyMg==", "bodyText": "Could you a new line at the end of the file?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568519822", "createdAt": "2021-02-02T11:13:47Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/java/org/nuxeo/easyshare/EasyShareEncryptionUtil.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.nuxeo.easyshare;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+public class EasyShareEncryptionUtil {\n+\n+\t// some random salt\n+\tprivate static final byte[] SALT = { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F,\n+\t\t\t(byte) 0x5A, (byte) 0x75 };\n+\n+\tprivate final static int ITERATION_COUNT = 31;\n+\n+\tprivate EasyShareEncryptionUtil() {\n+\t}\n+\n+\t/**\n+\t * Return a predefined SALT\n+\t * \n+\t * @return Predefined SAL (@see SALT)\n+\t */\n+\tpublic static String getDefaultSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(SALT);\n+\t}\n+\n+\t/**\n+\t * Generate a custom salt as base64 encoded string\n+\t * \n+\t * @return random base64 string\n+\t */\n+\tpublic static String getNextSaltAsString() {\n+\n+\t\treturn Base64.encodeBase64String(getNextSaltAsByte());\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt string (default value will be\n+\t * used for salt if param is empty/null) (wrapper for byte[]\u00a0salt)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tpublic static String encodeWithSaltString(String input, String salt) {\n+\t\ttry {\n+\t\t\treturn encodeWithSaltByte(input, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt string (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tpublic static String decodeWithSaltString(String token, String salt) {\n+\t\ttry {\n+\t\t\treturn decodeWithSaltByte(token, Base64.decodeBase64(salt));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a random salt\n+\t * \n+\t * @return random generated salt over 8 bytes\n+\t */\n+\tprivate static byte[] getNextSaltAsByte() {\n+\t\tbyte[] salt = new byte[8];\n+\t\tnew SecureRandom().nextBytes(salt);\n+\t\treturn salt;\n+\t}\n+\n+\t/**\n+\t * Encode an input string with passed salt byte[]\u00a0(default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param input\n+\t *            String to encode\n+\t * @param salt\n+\t *            SALT to use\n+\t * @return An encoded string\n+\t */\n+\tprivate static String encodeWithSaltByte(String input, byte[] salt) {\n+\t\tif (input == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\ttry {\n+\n+\t\t\tbyte[] randomSalt = salt != null ? salt : SALT;\n+\n+\t\t\tKeySpec keySpec = new PBEKeySpec(null, randomSalt, ITERATION_COUNT);\n+\t\t\tAlgorithmParameterSpec paramSpec = new PBEParameterSpec(randomSalt, ITERATION_COUNT);\n+\t\t\tSecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\n+\n+\t\t\tCipher ecipher = Cipher.getInstance(key.getAlgorithm());\n+\t\t\tecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n+\n+\t\t\tbyte[] enc = ecipher.doFinal(input.getBytes());\n+\n+\t\t\tString res = new String(Base64.encodeBase64(enc));\n+\t\t\t// escapes for url\n+\t\t\tres = res.replace('+', '-').replace('/', '_').replace(\"%\", \"%25\").replace(\"\\n\", \"%0A\");\n+\n+\t\t\treturn res;\n+\n+\t\t} catch (InvalidKeySpecException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException\n+\t\t\t\t| InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Decode an encoded token with passed salt byte[] (default value will be\n+\t * used for salt if param is empty/null)\n+\t * \n+\t * @param token\n+\t *            Encoded String to decode using passed salt\n+\t * @param salt\n+\t *            SALT to use when decoding\n+\t * @return Decoded string from token\n+\t */\n+\tprivate static String decodeWithSaltByte(String token, byte[] salt) {\n+\t\tif (token == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\ttry {\n+\n+\t\t\tbyte[] randomSalt = salt != null ? salt : SALT;\n+\n+\t\t\tString input = token.replace(\"%0A\", \"\\n\").replace(\"%25\", \"%\").replace('_', '/').replace('-', '+');\n+\n+\t\t\tbyte[] dec = Base64.decodeBase64(input.getBytes());\n+\n+\t\t\tKeySpec keySpec = new PBEKeySpec(null, randomSalt, ITERATION_COUNT);\n+\t\t\tAlgorithmParameterSpec paramSpec = new PBEParameterSpec(randomSalt, ITERATION_COUNT);\n+\n+\t\t\tSecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\n+\n+\t\t\tCipher dcipher = Cipher.getInstance(key.getAlgorithm());\n+\t\t\tdcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\n+\n+\t\t\tbyte[] decoded = dcipher.doFinal(dec);\n+\n+\t\t\tString result = new String(decoded);\n+\t\t\treturn result;\n+\n+\t\t} catch (InvalidKeySpecException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException\n+\t\t\t\t| InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {\n+\t\t\t// use logger in production code\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjIxMjYzOnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/resources/data/schemas/easysharefolder.xsd", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxNDo0NVrOIeLuog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxNDo0NVrOIeLuog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUyMDM1NA==", "bodyText": "Could you add a new line at the end of the file?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568520354", "createdAt": "2021-02-02T11:14:45Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/resources/data/schemas/easysharefolder.xsd", "diffHunk": "@@ -5,4 +5,6 @@\n   <xs:element name=\"contactEmail\" type=\"xs:string\" />\n   <xs:element name=\"shareComment\" type=\"xs:string\" />\n   <xs:element name=\"hasNotification\" type=\"xs:boolean\" default=\"true\" />\n-</xs:schema>\n+  <xs:element name=\"accessCodeRequired\" type=\"xs:boolean\" default=\"false\"/>\n+  <xs:element name=\"accessCode\" type=\"xs:string\" />\n+</xs:schema>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MjIxOTEzOnYy", "diffSide": "RIGHT", "path": "modules/platform/nuxeo-easyshare-core/src/main/resources/i18n/messages.properties", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMToxNjoyNlrOIeLyhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxMToyNTo0OVrOIe9iqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUyMTM1MQ==", "bodyText": "I think we want to keep the denied error as the folder doesn't exist, otherwise, it gives extra information to the user making the request (ie: the document with this id/path exists).", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r568521351", "createdAt": "2021-02-02T11:16:26Z", "author": {"login": "kevinleturc"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/resources/i18n/messages.properties", "diffHunk": "@@ -1,10 +1,18 @@\n easyshare.label.title=Nuxeo - Easyshare\n easyshare.label.description=Nuxeo Easyshare Folder\n-easyshare.label.denied=Oh no! This folder doesn't exist.\n-easyshare.label.expired=Oh no! This Easy Share folder has expired.\n+easyshare.label.denied=Oh no! This access is secured.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTMzNjQ5MA==", "bodyText": "OK, I can keep the logic in the code but just change the label ? Could you validate this part internally as the message asking for a password will not be \"Oh no! This access is secured\" but \"Oh no! This folder doesn't exist.\" with a password field input ?", "url": "https://github.com/nuxeo/nuxeo/pull/4520#discussion_r569336490", "createdAt": "2021-02-03T11:25:49Z", "author": {"login": "s-guillaume"}, "path": "modules/platform/nuxeo-easyshare-core/src/main/resources/i18n/messages.properties", "diffHunk": "@@ -1,10 +1,18 @@\n easyshare.label.title=Nuxeo - Easyshare\n easyshare.label.description=Nuxeo Easyshare Folder\n-easyshare.label.denied=Oh no! This folder doesn't exist.\n-easyshare.label.expired=Oh no! This Easy Share folder has expired.\n+easyshare.label.denied=Oh no! This access is secured.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODUyMTM1MQ=="}, "originalCommit": {"oid": "2ea026536ad9107be2a1513cf3ad6806ea5bad3c"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4277, "cost": 1, "resetAt": "2021-11-03T18:41:40Z"}}}