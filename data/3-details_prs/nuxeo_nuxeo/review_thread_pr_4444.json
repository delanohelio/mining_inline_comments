{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2ODU5MjY5", "number": 4444, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMDoxNDowN1rOE2sYfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoxNTowNFrOE21xGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1Nzg1NzI3OnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/BulkAdminServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMDoxNDowN1rOHvnmUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNTo0NzozMFrOHv1ATg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY5MzkwNg==", "bodyText": "This constant isn't used...", "url": "https://github.com/nuxeo/nuxeo/pull/4444#discussion_r519693906", "createdAt": "2020-11-09T10:14:07Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/BulkAdminServiceImpl.java", "diffHunk": "@@ -47,6 +47,13 @@\n \n     public static final String BULK_SCROLL_PRODUCE_IMMEDIATE_PROPERTY = \"nuxeo.core.bulk.scroller.produceImmediate\";\n \n+    // @since 11.4\n+    public static final String BULK_SCROLL_PRODUCE_IMMEDIATE_THRESHOLD_PROPERTY = \"nuxeo.core.bulk.scroller.produceImmediateThreshold\";\n+\n+    // by default switch to produce immediate when there are more than 1m ids\n+    // @since 11.4\n+    public static final int DEFAULT_PRODUCE_IMMEDIATE_THRESHOLD_PROPERTY = 1_000_000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdf3174a2286d338edaad5025e80e2f7b4bfe4b2"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkxMzU1MA==", "bodyText": "yes thanks, the pr has been reworked a bit to fix this and to flush accumulated records downstream when reaching the threshold avoiding a reordering of ids.", "url": "https://github.com/nuxeo/nuxeo/pull/4444#discussion_r519913550", "createdAt": "2020-11-09T15:47:30Z", "author": {"login": "bdelbosc"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/BulkAdminServiceImpl.java", "diffHunk": "@@ -47,6 +47,13 @@\n \n     public static final String BULK_SCROLL_PRODUCE_IMMEDIATE_PROPERTY = \"nuxeo.core.bulk.scroller.produceImmediate\";\n \n+    // @since 11.4\n+    public static final String BULK_SCROLL_PRODUCE_IMMEDIATE_THRESHOLD_PROPERTY = \"nuxeo.core.bulk.scroller.produceImmediateThreshold\";\n+\n+    // by default switch to produce immediate when there are more than 1m ids\n+    // @since 11.4\n+    public static final int DEFAULT_PRODUCE_IMMEDIATE_THRESHOLD_PROPERTY = 1_000_000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY5MzkwNg=="}, "originalCommit": {"oid": "cdf3174a2286d338edaad5025e80e2f7b4bfe4b2"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTM3NzU2OnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/computation/BulkScrollerComputation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoxMToxN1rOHv2HHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjozNDoxN1rOHv3IZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMTY3OA==", "bodyText": "Isn't it worth considering a builder pattern, given the number of parameters that we now pass at construction?", "url": "https://github.com/nuxeo/nuxeo/pull/4444#discussion_r519931678", "createdAt": "2020-11-09T16:11:17Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/computation/BulkScrollerComputation.java", "diffHunk": "@@ -111,10 +114,18 @@ public BulkScrollerComputation(String name, int nbOutputStreams, int scrollBatch\n     // @since 11.2\n     public BulkScrollerComputation(String name, int nbOutputStreams, int scrollBatchSize, int scrollKeepAliveSeconds,\n             Duration transactionTimeout, boolean produceImmediate) {\n+        this(name, nbOutputStreams, scrollBatchSize, scrollKeepAliveSeconds, DEFAULT_SCROLL_TRANSACTION_TIMEOUT,\n+                produceImmediate, 0);\n+    }\n+\n+    // @since 11.4\n+    public BulkScrollerComputation(String name, int nbOutputStreams, int scrollBatchSize, int scrollKeepAliveSeconds,\n+            Duration transactionTimeout, boolean produceImmediate, int produceImmediateThreshold) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d169e86307fe2d141b0846460a3ed05ee5d9f7"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0ODM5MQ==", "bodyText": "maybe, but this constructor is only used in one place and is not intended to be used elsewhere", "url": "https://github.com/nuxeo/nuxeo/pull/4444#discussion_r519948391", "createdAt": "2020-11-09T16:34:17Z", "author": {"login": "bdelbosc"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/computation/BulkScrollerComputation.java", "diffHunk": "@@ -111,10 +114,18 @@ public BulkScrollerComputation(String name, int nbOutputStreams, int scrollBatch\n     // @since 11.2\n     public BulkScrollerComputation(String name, int nbOutputStreams, int scrollBatchSize, int scrollKeepAliveSeconds,\n             Duration transactionTimeout, boolean produceImmediate) {\n+        this(name, nbOutputStreams, scrollBatchSize, scrollKeepAliveSeconds, DEFAULT_SCROLL_TRANSACTION_TIMEOUT,\n+                produceImmediate, 0);\n+    }\n+\n+    // @since 11.4\n+    public BulkScrollerComputation(String name, int nbOutputStreams, int scrollBatchSize, int scrollKeepAliveSeconds,\n+            Duration transactionTimeout, boolean produceImmediate, int produceImmediateThreshold) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMTY3OA=="}, "originalCommit": {"oid": "35d169e86307fe2d141b0846460a3ed05ee5d9f7"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTM5NDgwOnYy", "diffSide": "RIGHT", "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/computation/BulkScrollerComputation.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoxNTowNFrOHv2Ryw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMToxMToxNFrOHwBwAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzNDQxMQ==", "bodyText": "Can we put contextImpl.getRecords(actionStream) in a local variable or is the semantic wrong for that?", "url": "https://github.com/nuxeo/nuxeo/pull/4444#discussion_r519934411", "createdAt": "2020-11-09T16:15:04Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/computation/BulkScrollerComputation.java", "diffHunk": "@@ -272,17 +283,30 @@ protected void updateStatusAfterScroll(ComputationContext context, String comman\n     /**\n      * Produces a bucket as a record to appropriate bulk action stream.\n      */\n-    protected void produceBucket(ComputationContext context, String commandId, int bucketSize, long bucketNumber) {\n+    protected void produceBucket(ComputationContext context, String commandId, int bucketSize, long bucketNumber,\n+            long documentCount) {\n         List<String> ids = documentIds.subList(0, min(bucketSize, documentIds.size()));\n         BulkBucket bucket = new BulkBucket(commandId, ids);\n         String key = commandId + \":\" + Long.toString(bucketNumber);\n         Record record = Record.of(key, BulkCodecs.getBucketCodec().encode(bucket));\n-        if (produceImmediate) {\n-            ((ComputationContextImpl) context).produceRecordImmediate(actionStream, record);\n+        if (produceImmediate || (produceImmediateThreshold > 0 && documentCount > produceImmediateThreshold)) {\n+            ComputationContextImpl contextImpl = (ComputationContextImpl) context;\n+            if (!contextImpl.getRecords(actionStream).isEmpty()) {\n+                flushRecords(contextImpl, commandId);\n+            }\n+            contextImpl.produceRecordImmediate(actionStream, record);\n         } else {\n             context.produceRecord(actionStream, record);\n         }\n         ids.clear(); // this clear the documentIds part that has been sent\n     }\n \n+    protected void flushRecords(ComputationContextImpl contextImpl, String commandId) {\n+        log.warn(\"Scroller records threshold reached ({}) for action: {} on command: {}, flushing records downstream\",\n+                produceImmediateThreshold, actionStream, commandId);\n+        contextImpl.getRecords(actionStream)\n+                   .forEach(record -> contextImpl.produceRecordImmediate(actionStream, record));\n+        contextImpl.getRecords(actionStream).clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d169e86307fe2d141b0846460a3ed05ee5d9f7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk1MzAyNg==", "bodyText": "we could will it be more readable not sure", "url": "https://github.com/nuxeo/nuxeo/pull/4444#discussion_r519953026", "createdAt": "2020-11-09T16:40:54Z", "author": {"login": "bdelbosc"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/computation/BulkScrollerComputation.java", "diffHunk": "@@ -272,17 +283,30 @@ protected void updateStatusAfterScroll(ComputationContext context, String comman\n     /**\n      * Produces a bucket as a record to appropriate bulk action stream.\n      */\n-    protected void produceBucket(ComputationContext context, String commandId, int bucketSize, long bucketNumber) {\n+    protected void produceBucket(ComputationContext context, String commandId, int bucketSize, long bucketNumber,\n+            long documentCount) {\n         List<String> ids = documentIds.subList(0, min(bucketSize, documentIds.size()));\n         BulkBucket bucket = new BulkBucket(commandId, ids);\n         String key = commandId + \":\" + Long.toString(bucketNumber);\n         Record record = Record.of(key, BulkCodecs.getBucketCodec().encode(bucket));\n-        if (produceImmediate) {\n-            ((ComputationContextImpl) context).produceRecordImmediate(actionStream, record);\n+        if (produceImmediate || (produceImmediateThreshold > 0 && documentCount > produceImmediateThreshold)) {\n+            ComputationContextImpl contextImpl = (ComputationContextImpl) context;\n+            if (!contextImpl.getRecords(actionStream).isEmpty()) {\n+                flushRecords(contextImpl, commandId);\n+            }\n+            contextImpl.produceRecordImmediate(actionStream, record);\n         } else {\n             context.produceRecord(actionStream, record);\n         }\n         ids.clear(); // this clear the documentIds part that has been sent\n     }\n \n+    protected void flushRecords(ComputationContextImpl contextImpl, String commandId) {\n+        log.warn(\"Scroller records threshold reached ({}) for action: {} on command: {}, flushing records downstream\",\n+                produceImmediateThreshold, actionStream, commandId);\n+        contextImpl.getRecords(actionStream)\n+                   .forEach(record -> contextImpl.produceRecordImmediate(actionStream, record));\n+        contextImpl.getRecords(actionStream).clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzNDQxMQ=="}, "originalCommit": {"oid": "35d169e86307fe2d141b0846460a3ed05ee5d9f7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2NTk1NQ==", "bodyText": "It is more readable, you're just not used to it \ud83d\ude00 With a local variable it's immediately clear that we're acting twice on the same object instead of re-doing a call to getRecords that may return different things... Which was a question I asked myself when I read this!", "url": "https://github.com/nuxeo/nuxeo/pull/4444#discussion_r519965955", "createdAt": "2020-11-09T16:53:53Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/computation/BulkScrollerComputation.java", "diffHunk": "@@ -272,17 +283,30 @@ protected void updateStatusAfterScroll(ComputationContext context, String comman\n     /**\n      * Produces a bucket as a record to appropriate bulk action stream.\n      */\n-    protected void produceBucket(ComputationContext context, String commandId, int bucketSize, long bucketNumber) {\n+    protected void produceBucket(ComputationContext context, String commandId, int bucketSize, long bucketNumber,\n+            long documentCount) {\n         List<String> ids = documentIds.subList(0, min(bucketSize, documentIds.size()));\n         BulkBucket bucket = new BulkBucket(commandId, ids);\n         String key = commandId + \":\" + Long.toString(bucketNumber);\n         Record record = Record.of(key, BulkCodecs.getBucketCodec().encode(bucket));\n-        if (produceImmediate) {\n-            ((ComputationContextImpl) context).produceRecordImmediate(actionStream, record);\n+        if (produceImmediate || (produceImmediateThreshold > 0 && documentCount > produceImmediateThreshold)) {\n+            ComputationContextImpl contextImpl = (ComputationContextImpl) context;\n+            if (!contextImpl.getRecords(actionStream).isEmpty()) {\n+                flushRecords(contextImpl, commandId);\n+            }\n+            contextImpl.produceRecordImmediate(actionStream, record);\n         } else {\n             context.produceRecord(actionStream, record);\n         }\n         ids.clear(); // this clear the documentIds part that has been sent\n     }\n \n+    protected void flushRecords(ComputationContextImpl contextImpl, String commandId) {\n+        log.warn(\"Scroller records threshold reached ({}) for action: {} on command: {}, flushing records downstream\",\n+                produceImmediateThreshold, actionStream, commandId);\n+        contextImpl.getRecords(actionStream)\n+                   .forEach(record -> contextImpl.produceRecordImmediate(actionStream, record));\n+        contextImpl.getRecords(actionStream).clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzNDQxMQ=="}, "originalCommit": {"oid": "35d169e86307fe2d141b0846460a3ed05ee5d9f7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEyMjM2OA==", "bodyText": "Here, for the reasons I mentioned, the code would have been better with a local variable. Please don't ignore reviewer's comments and requests for changes.", "url": "https://github.com/nuxeo/nuxeo/pull/4444#discussion_r520122368", "createdAt": "2020-11-09T21:11:14Z", "author": {"login": "efge"}, "path": "modules/core/nuxeo-core-bulk/src/main/java/org/nuxeo/ecm/core/bulk/computation/BulkScrollerComputation.java", "diffHunk": "@@ -272,17 +283,30 @@ protected void updateStatusAfterScroll(ComputationContext context, String comman\n     /**\n      * Produces a bucket as a record to appropriate bulk action stream.\n      */\n-    protected void produceBucket(ComputationContext context, String commandId, int bucketSize, long bucketNumber) {\n+    protected void produceBucket(ComputationContext context, String commandId, int bucketSize, long bucketNumber,\n+            long documentCount) {\n         List<String> ids = documentIds.subList(0, min(bucketSize, documentIds.size()));\n         BulkBucket bucket = new BulkBucket(commandId, ids);\n         String key = commandId + \":\" + Long.toString(bucketNumber);\n         Record record = Record.of(key, BulkCodecs.getBucketCodec().encode(bucket));\n-        if (produceImmediate) {\n-            ((ComputationContextImpl) context).produceRecordImmediate(actionStream, record);\n+        if (produceImmediate || (produceImmediateThreshold > 0 && documentCount > produceImmediateThreshold)) {\n+            ComputationContextImpl contextImpl = (ComputationContextImpl) context;\n+            if (!contextImpl.getRecords(actionStream).isEmpty()) {\n+                flushRecords(contextImpl, commandId);\n+            }\n+            contextImpl.produceRecordImmediate(actionStream, record);\n         } else {\n             context.produceRecord(actionStream, record);\n         }\n         ids.clear(); // this clear the documentIds part that has been sent\n     }\n \n+    protected void flushRecords(ComputationContextImpl contextImpl, String commandId) {\n+        log.warn(\"Scroller records threshold reached ({}) for action: {} on command: {}, flushing records downstream\",\n+                produceImmediateThreshold, actionStream, commandId);\n+        contextImpl.getRecords(actionStream)\n+                   .forEach(record -> contextImpl.produceRecordImmediate(actionStream, record));\n+        contextImpl.getRecords(actionStream).clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzNDQxMQ=="}, "originalCommit": {"oid": "35d169e86307fe2d141b0846460a3ed05ee5d9f7"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4329, "cost": 1, "resetAt": "2021-11-03T18:41:40Z"}}}