{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MDE0MDcy", "number": 4175, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0Mjo0MFrOEp4RwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODozMzo0OVrOEqCM0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzQ5MTIwOnYy", "diffSide": "LEFT", "path": "facades/PC/build.gradle.kts", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0Mjo0MFrOHb0afg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0Mjo0MFrOHb0afg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMjM1MA==", "bodyText": "This isn't strictly line-for-line compatible because I only kept some of these as gradle \"extra\" properties. Most of them I left as local variables.\nI don't believe it's a problem for the normal build environment, since there's nothing else in the build that interacts with them, but maybe it could be a concern if something like Jenkins has an alternate configuration that sets or uses them differently?", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r498932350", "createdAt": "2020-10-02T16:42:40Z", "author": {"login": "keturn"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd4e5ec7d8d4f171dd6fc51ca75134e2e6253234"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTEwMTkwOnYy", "diffSide": "RIGHT", "path": "facades/PC/build.gradle.kts", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODowOTozNlrOHcC4Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxOTo0NDowNFrOHcDTsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTM3NA==", "bodyText": "On a side note: https://github.com/ronmamo/reflections is available in 0.9.12 now.", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499169374", "createdAt": "2020-10-03T18:09:36Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NjM3MA==", "bodyText": "It has been for a while, but there are some widely reported issues with 0.9.12 (and some for 0.9.11) so I've been afraid to mess with it.", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499176370", "createdAt": "2020-10-03T19:44:04Z", "author": {"login": "keturn"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTM3NA=="}, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTEwMjUxOnYy", "diffSide": "RIGHT", "path": "facades/PC/build.gradle.kts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODoxMDozM1rOHcC4pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODoxMDozM1rOHcC4pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTQ0Nw==", "bodyText": "\ud83d\udc4d I like how this can be inlined now \ud83d\ude03", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499169447", "createdAt": "2020-10-03T18:10:33Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTEwNDE5OnYy", "diffSide": "RIGHT", "path": "facades/PC/build.gradle.kts", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODoxMjo1N1rOHcC5cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QyMTowODoxMVrOHcDpxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTY1MA==", "bodyText": "Hm, so everything else seems to become more (type-)safe, while you reference the dependency via a plain string there? Is there another way to do this in the Kotlin DSL?", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499169650", "createdAt": "2020-10-03T18:12:57Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")\n+        attributes[\"Implementation-Title\"] = \"Terasology-\" + project.name\n+        attributes[\"Implementation-Version\"] = \"\"\"${env[\"BUILD_NUMBER\"]}, ${env[\"GIT_BRANCH\"]}, ${env[\"BUILD_ID\"]}\"\"\"\n     }\n }\n \n configurations {\n-    // for fetching modules for running a server\n-    modules {\n-        transitive = false\n+    register(\"modules\") {\n+        description = \"for fetching modules for running a server\"\n+        isTransitive = false\n     }\n }\n \n-run {\n+tasks.named<JavaExec>(\"run\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n-    args \"-homedir\", \"-noCrashReport\"\n-    jvmArgs \"-Xmx1536m\"\n-    workingDir rootDir\n+    args = listOf(\"-homedir\", \"-noCrashReport\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n+    workingDir = rootDir\n \n-    dependsOn rootProject.moduleClasses\n+    dependsOn(\":moduleClasses\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4MTQ2Nw==", "bodyText": "There's some tension going on in gradle-config-land. In one direction, you have Kotlin making things more type-safe. In the other direction, Gradle has this configuration-avoidance initiative to do lazy evaluation for certain types of things so it doesn't have to figure out the entire multi-project configuration tree before it's able to run a single task. That's discouraged direct links between sub-projects in many ways.\non second thought, I'm not sure how much the configuration-avoidance API has to do with this specific example.\nfrom Kotlin's perspective, these are instances of Project. Project, as a Class, doesn't have a property named moduleClasses. build.gradle.kts files configure projects but they do not define new classes for each of them. Things like rootProject.moduleClasses only work with dynamic run-time attribute-lookup trickery.\nWe certainly could say something along the lines of rootProject.tasks.get(\"moduleClasses\") but that's not any different than what we have here in terms of providing assurance that \"moduleClasses\" is a safe reference.\n...and also the Gradle API is really big and provides a bunch of ways to get references to things and I certainly haven't learned everything about what's supposed to be the current best practice.", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499181467", "createdAt": "2020-10-03T20:58:52Z", "author": {"login": "keturn"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")\n+        attributes[\"Implementation-Title\"] = \"Terasology-\" + project.name\n+        attributes[\"Implementation-Version\"] = \"\"\"${env[\"BUILD_NUMBER\"]}, ${env[\"GIT_BRANCH\"]}, ${env[\"BUILD_ID\"]}\"\"\"\n     }\n }\n \n configurations {\n-    // for fetching modules for running a server\n-    modules {\n-        transitive = false\n+    register(\"modules\") {\n+        description = \"for fetching modules for running a server\"\n+        isTransitive = false\n     }\n }\n \n-run {\n+tasks.named<JavaExec>(\"run\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n-    args \"-homedir\", \"-noCrashReport\"\n-    jvmArgs \"-Xmx1536m\"\n-    workingDir rootDir\n+    args = listOf(\"-homedir\", \"-noCrashReport\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n+    workingDir = rootDir\n \n-    dependsOn rootProject.moduleClasses\n+    dependsOn(\":moduleClasses\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTY1MA=="}, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4MjAyMg==", "bodyText": "Long-term, the \u201csafe\u201d way involves not knowing about the tasks of other projects at all. You declare a dependency like \"I depend on things from \"org.terasology.engine:engine\" and need assets of type <Jar> that conform to bytecode_level=JAVA_1_8\" or something like that, the dependency-resolver does its thing and checks to see if that project exports anything that matches those criteria.", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499182022", "createdAt": "2020-10-03T21:08:11Z", "author": {"login": "keturn"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")\n+        attributes[\"Implementation-Title\"] = \"Terasology-\" + project.name\n+        attributes[\"Implementation-Version\"] = \"\"\"${env[\"BUILD_NUMBER\"]}, ${env[\"GIT_BRANCH\"]}, ${env[\"BUILD_ID\"]}\"\"\"\n     }\n }\n \n configurations {\n-    // for fetching modules for running a server\n-    modules {\n-        transitive = false\n+    register(\"modules\") {\n+        description = \"for fetching modules for running a server\"\n+        isTransitive = false\n     }\n }\n \n-run {\n+tasks.named<JavaExec>(\"run\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n-    args \"-homedir\", \"-noCrashReport\"\n-    jvmArgs \"-Xmx1536m\"\n-    workingDir rootDir\n+    args = listOf(\"-homedir\", \"-noCrashReport\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n+    workingDir = rootDir\n \n-    dependsOn rootProject.moduleClasses\n+    dependsOn(\":moduleClasses\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTY1MA=="}, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTExMDEyOnYy", "diffSide": "RIGHT", "path": "facades/PC/build.gradle.kts", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODoyMzozN1rOHcC8Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODoyMzozN1rOHcC8Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MDM5MA==", "bodyText": "Would be nice to make this adjustable in the future via some kind of command line argument...", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499170390", "createdAt": "2020-10-03T18:23:37Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")\n+        attributes[\"Implementation-Title\"] = \"Terasology-\" + project.name\n+        attributes[\"Implementation-Version\"] = \"\"\"${env[\"BUILD_NUMBER\"]}, ${env[\"GIT_BRANCH\"]}, ${env[\"BUILD_ID\"]}\"\"\"\n     }\n }\n \n configurations {\n-    // for fetching modules for running a server\n-    modules {\n-        transitive = false\n+    register(\"modules\") {\n+        description = \"for fetching modules for running a server\"\n+        isTransitive = false\n     }\n }\n \n-run {\n+tasks.named<JavaExec>(\"run\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n-    args \"-homedir\", \"-noCrashReport\"\n-    jvmArgs \"-Xmx1536m\"\n-    workingDir rootDir\n+    args = listOf(\"-homedir\", \"-noCrashReport\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n+    workingDir = rootDir\n \n-    dependsOn rootProject.moduleClasses\n+    dependsOn(\":moduleClasses\")\n }\n \n-task game(type:JavaExec) {\n+tasks.register<JavaExec>(\"game\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n     // If there are no actual source modules let the user know, just in case ..\n-    if (project(':modules').subprojects.size() == 0) {\n-        def out = services.get(StyledTextOutputFactory).create(\"an-ouput\")\n-        out.withStyle(StyledTextOutput.Style.FailureHeader).println(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n+    if (project(\":modules\").subprojects.isEmpty()) {\n+        logger.warn(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n     }\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTExNDI0OnYy", "diffSide": "RIGHT", "path": "facades/PC/build.gradle.kts", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODoyOTo1MVrOHcC-Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNzowMzozMVrOHlIQdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MDkxNA==", "bodyText": "Do we still need this with the new idea setup introduced recently?", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499170914", "createdAt": "2020-10-03T18:29:51Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")\n+        attributes[\"Implementation-Title\"] = \"Terasology-\" + project.name\n+        attributes[\"Implementation-Version\"] = \"\"\"${env[\"BUILD_NUMBER\"]}, ${env[\"GIT_BRANCH\"]}, ${env[\"BUILD_ID\"]}\"\"\"\n     }\n }\n \n configurations {\n-    // for fetching modules for running a server\n-    modules {\n-        transitive = false\n+    register(\"modules\") {\n+        description = \"for fetching modules for running a server\"\n+        isTransitive = false\n     }\n }\n \n-run {\n+tasks.named<JavaExec>(\"run\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n-    args \"-homedir\", \"-noCrashReport\"\n-    jvmArgs \"-Xmx1536m\"\n-    workingDir rootDir\n+    args = listOf(\"-homedir\", \"-noCrashReport\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n+    workingDir = rootDir\n \n-    dependsOn rootProject.moduleClasses\n+    dependsOn(\":moduleClasses\")\n }\n \n-task game(type:JavaExec) {\n+tasks.register<JavaExec>(\"game\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n     // If there are no actual source modules let the user know, just in case ..\n-    if (project(':modules').subprojects.size() == 0) {\n-        def out = services.get(StyledTextOutputFactory).create(\"an-ouput\")\n-        out.withStyle(StyledTextOutput.Style.FailureHeader).println(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n+    if (project(\":modules\").subprojects.isEmpty()) {\n+        logger.warn(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n     }\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task profile(type:JavaExec) {\n+tasks.register<JavaExec>(\"profile\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application (with Java FlightRecorder profiling)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n-    jvmArgs = [\"-Xms256m\", \"-Xmx1536m\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=filename=terasology.jfr,dumponexit=true\"]\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-homedir\"]\n-    args runArgs\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xms256m\", \"-Xmx1536m\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=filename=terasology.jfr,dumponexit=true\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task debug(type:JavaExec) {\n+tasks.register<JavaExec>(\"debug\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application (in debug mode)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n-    jvmArgs = [\"-Xmx1536m\", \"-Xdebug\", \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\"]\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-homedir\"]\n-    args runArgs\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\", \"-Xdebug\", \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task permissiveNatives(type:JavaExec) {\n+tasks.register<JavaExec>(\"permissiveNatives\") {\n     description = \"Run 'Terasology' with security set to permissive and natives loading a second way (for KComputers)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\", \"-permissiveSecurity\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\", \"-permissiveSecurity\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n \n     systemProperty(\"java.library.path\", rootProject.file(dirNatives + \"/\" + nativeSubdirectoryName()))\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-// By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it\n-// TODO: This is not the Gradle Way. Needs more declared output-fu to determine up-to-date instead of the if\n-task setupServerConfig {\n-    description \"Parses parameters passed via Gradle and writes them to the local run-from-source server dir's config.cfg\"\n-\n-    def json = new JsonBuilder()\n-\n-    def serverRoot = rootProject.file(localServerDataPath);\n-    def config = new File(serverRoot, 'config.cfg')\n-\n-    if (!config.exists()) {\n-\n-        serverRoot.mkdir()\n-        logger.lifecycle(\"Creating config file $config\")\n-\n-        json {\n-            worldGeneration {\n-                if (project.hasProperty('seed')) {\n-                    logger.lifecycle(\"  Seed value: $seed\");\n-                    defaultSeed seed\n-                }\n-                if (project.hasProperty('worldGen')) {\n-                    logger.lifecycle(\"  World Generator: $worldGen\");\n-                    defaultGenerator worldGen\n-                }\n-            }\n-            defaultModSelection {\n-                if (project.hasProperty('extraModules')) {\n-                    logger.lifecycle(\"  Enabling modules: $extraModules\");\n-                    modules extraModules.tokenize(\" ,\")\n-                }\n-            }\n-        }\n-        config.text = json.toPrettyString()\n-    }\n-}\n+apply(from=\"server.build.gradle\")\n \n // TODO: Seems to always be up to date so no modules get copied\n-task setupServerModules(type: Sync) {\n-    description 'Parses \"extraModules\" - a comma-separated list of modules and puts them into ' + localServerDataPath\n+tasks.register<Sync>(\"setupServerModules\") {\n+    description =\n+        \"\"\"Parses \"extraModules\" - a comma-separated list of modules and puts them into $localServerDataPath\"\"\"\n \n-    if (project.hasProperty('extraModules')) {\n+    val extraModules: String? by project;\n+    extraModules?.let {\n         // Grab modules from Artifactory - cheats by declaring them as dependencies\n-        extraModules.tokenize(' ,').each { String module ->\n-            println \"Extra module: \" + module\n+        it.splitToSequence(\",\").forEach {\n+            logger.info(\"Extra module: {}\", it)\n             dependencies {\n-                modules group: 'org.terasology.modules', name: module, version: '+', changing: 'true'\n+                \"modules\"(group = \"org.terasology.modules\", name = it, version = \"+\")\n             }\n         }\n     }\n \n-    from(configurations.modules)\n-    into(new File(rootProject.file(localServerDataPath), \"modules\"))\n+    from(configurations.named(\"modules\"))\n+    into(File(rootProject.file(localServerDataPath), \"modules\"))\n }\n \n // TODO: Make a task to reset server / game data\n-task server(type:JavaExec) {\n-    description \"Starts a headless multiplayer server with data stored in [project-root]/$localServerDataPath\"\n+tasks.register<JavaExec>(\"server\") {\n+    description = \"Starts a headless multiplayer server with data stored in [project-root]/$localServerDataPath\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n-    dependsOn setupServerConfig\n-    dependsOn setupServerModules\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n+    dependsOn(\"setupServerConfig\")\n+    dependsOn(\"setupServerModules\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-headless\", \"-homedir=$localServerDataPath\"]\n-    args runArgs\n-    jvmArgs [\"-Xmx1536\"]\n+    args = listOf(\"-headless\", \"-homedir=$localServerDataPath\")\n+    jvmArgs = listOf(\"-Xmx1536\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n // Preps a version file to bundle with PC dists. This eventually goes into the root of a zip file\n-task createVersionFile(type: Copy) {\n-    inputs.property('dateTime', startDateTimeString)\n-    onlyIf { env.BUILD_URL != null }\n-    from templatesDir\n-    into \"$buildDir\"\n-    include versionFileName\n-    expand(buildNumber: env.BUILD_NUMBER, buildUrl: env.BUILD_URL, gitBranch: env.GIT_BRANCH, dateTime: startDateTimeString, displayVersion: displayVersion)\n-    filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+tasks.register<Copy>(\"createVersionFile\") {\n+    inputs.property(\"dateTime\", startDateTimeString)\n+    onlyIf { env[\"BUILD_URL\"] != null }\n+    from(templatesDir)\n+    into(\"$buildDir\")\n+    include(versionFileName)\n+    expand(mapOf(\n+        \"buildNumber\" to env[\"BUILD_NUMBER\"],\n+        \"buildUrl\" to env[\"BUILD_URL\"],\n+        \"gitBranch\" to env[\"GIT_BRANCH\"],\n+        \"dateTime\" to startDateTimeString,\n+        \"displayVersion\" to displayVersion\n+    ))\n+    filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n }\n \n // TODO: This could probably be done more Gradley (engine project resource dir instead of direct path?) and with some variables\n-task copyCreditsFile(type: Copy) {\n-    description \"Copies the credits file into the engine's resource dir where it'll be read at runtime\"\n-    from \"$rootDir/docs\"\n-    into \"$rootDir/engine/src/main/resources\"\n-    include \"Credits.md\"\n+tasks.register<Copy>(\"copyCreditsFile\") {\n+    description = \"Copies the credits file into the engine's resource dir where it'll be read at runtime\"\n+    from(\"$rootDir/docs\")\n+    into(\"$rootDir/engine/src/main/resources\")\n+    include(\"Credits.md\")\n }\n \n // Main application dist target. Does NOT include any modules.\n-task distApp (type: Sync) {\n+tasks.register<Sync>(\"distApp\") {\n     description = \"Creates an application package for distribution\"\n     group = \"terasology dist\"\n \n-    dependsOn createVersionFile\n-    dependsOn copyCreditsFile\n-    dependsOn rootProject.extractNatives\n-    dependsOn jar\n+    dependsOn(\"createVersionFile\")\n+    dependsOn(\"copyCreditsFile\")\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\"jar\")\n \n-    into (\"${distsDirectory.get().asFile}/app\")\n+    into(\"${distsDirectory.get().asFile}/app\")\n     from (\"$rootDir/README.markdown\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n-        rename('README.markdown', 'README')\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        rename(\"README.markdown\", \"README\")\n     }\n     from (\"$rootDir/LICENSE\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n     }\n     from (\"$rootDir/NOTICE\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n     }\n-    from('launchScripts') {\n-        exclude('TeraEd.exe')\n+    from(\"launchScripts\") {\n+        exclude(\"TeraEd.exe\")\n     }\n \n     from(\"$buildDir/$versionFileName\") {}\n \n     into(subDirLibs) {\n-        from configurations.runtimeClasspath\n-        from project(':engine').jar\n-        from (\"$buildDir/libs\") {\n-            include \"*.jar\"\n+        from(configurations.runtimeClasspath)\n+        from(tasks.getByPath(\":engine:jar\"))\n+        from(\"$buildDir/libs\") {\n+            include(\"*.jar\")\n             rename {\n-                'Terasology.jar'\n+                \"Terasology.jar\"\n             }\n         }\n     }\n     into(dirNatives) {\n-        from \"$rootDir/$dirNatives\"\n+        from(\"$rootDir/$dirNatives\")\n     }\n }\n \n // Distribute modules - only grabs Core in Jenkins but locally will grab any present. \"Distros\" now handle Jenkins packs\n-task distModules (type: Sync) {\n+tasks.register<Sync>(\"distModules\") {\n     description = \"Prepares local modules for distribution\"\n-    dependsOn distApp\n-    dependsOn rootProject.moduleJars\n+    dependsOn(\"distApp\")\n+    dependsOn(\":moduleJars\")\n \n     // So this is probably a hack, but it works ;-) It does not work if it is in distApp, default \"into\" quirk ?\n     into(\"${distsDirectory.get().asFile}/app/modules\")\n-    rootProject.terasologyModules().each {\n-        from \"$rootDir/modules/${it.name}/build/libs\"\n-        include \"*.jar\"\n+    // FIXME: duplicating code from /build.gradle:terasologyModules\n+    val terasologyModules = rootProject.subprojects.filter { it.parent?.name == \"modules\" }\n+    terasologyModules.forEach {\n+        from(\"$rootDir/modules/${it.name}/build/libs\")\n+        include(\"*.jar\")\n     }\n }\n \n-task distPCZip (type: Zip) {\n+tasks.register<Zip>(\"distPCZip\") {\n     group = \"terasology dist\"\n-    dependsOn distApp\n-    dependsOn distModules\n-    from \"${distsDirectory.get().asFile}/app\"\n-    archiveFileName = \"Terasology.zip\"\n+    dependsOn(\"distApp\")\n+    dependsOn(\"distModules\")\n+    from(\"${distsDirectory.get().asFile}/app\")\n+    archiveFileName.set(\"Terasology.zip\")\n }\n \n-task distForLauncher (type: Sync) {\n+tasks.register<Sync>(\"distForLauncher\") {\n     group = \"terasology dist\"\n \n-    into rootDirDist\n-    from distPCZip\n+    into(rootDirDist)\n+    from(tasks.getByName(\"distPCZip\"))\n \n-    into (\"../resources/main/org/terasology/version\") {\n-        from (\"$rootDir/engine/build/classes/org/terasology/version\") {\n-            include ('versionInfo.properties')\n+    into(\"../resources/main/org/terasology/version\") {\n+        from(\"$rootDir/engine/build/classes/org/terasology/version\") {\n+            include(\"versionInfo.properties\")\n         }\n     }\n }\n \n // Prep an IntelliJ module for the facade\n-idea {\n+configure<IdeaModel> {\n     module {\n         // Change around the output a bit\n         inheritOutputDirs = false\n-        outputDir = file('build/classes')\n-        testOutputDir = file('build/testClasses')\n+        outputDir = file(\"build/classes\")\n+        testOutputDir = file(\"build/testClasses\")\n     }\n }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 593}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4MjExMA==", "bodyText": "no but no matter how many times people have asked me that none of them have ever removed it \ud83d\ude09", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499182110", "createdAt": "2020-10-03T21:09:35Z", "author": {"login": "keturn"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")\n+        attributes[\"Implementation-Title\"] = \"Terasology-\" + project.name\n+        attributes[\"Implementation-Version\"] = \"\"\"${env[\"BUILD_NUMBER\"]}, ${env[\"GIT_BRANCH\"]}, ${env[\"BUILD_ID\"]}\"\"\"\n     }\n }\n \n configurations {\n-    // for fetching modules for running a server\n-    modules {\n-        transitive = false\n+    register(\"modules\") {\n+        description = \"for fetching modules for running a server\"\n+        isTransitive = false\n     }\n }\n \n-run {\n+tasks.named<JavaExec>(\"run\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n-    args \"-homedir\", \"-noCrashReport\"\n-    jvmArgs \"-Xmx1536m\"\n-    workingDir rootDir\n+    args = listOf(\"-homedir\", \"-noCrashReport\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n+    workingDir = rootDir\n \n-    dependsOn rootProject.moduleClasses\n+    dependsOn(\":moduleClasses\")\n }\n \n-task game(type:JavaExec) {\n+tasks.register<JavaExec>(\"game\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n     // If there are no actual source modules let the user know, just in case ..\n-    if (project(':modules').subprojects.size() == 0) {\n-        def out = services.get(StyledTextOutputFactory).create(\"an-ouput\")\n-        out.withStyle(StyledTextOutput.Style.FailureHeader).println(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n+    if (project(\":modules\").subprojects.isEmpty()) {\n+        logger.warn(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n     }\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task profile(type:JavaExec) {\n+tasks.register<JavaExec>(\"profile\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application (with Java FlightRecorder profiling)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n-    jvmArgs = [\"-Xms256m\", \"-Xmx1536m\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=filename=terasology.jfr,dumponexit=true\"]\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-homedir\"]\n-    args runArgs\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xms256m\", \"-Xmx1536m\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=filename=terasology.jfr,dumponexit=true\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task debug(type:JavaExec) {\n+tasks.register<JavaExec>(\"debug\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application (in debug mode)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n-    jvmArgs = [\"-Xmx1536m\", \"-Xdebug\", \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\"]\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-homedir\"]\n-    args runArgs\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\", \"-Xdebug\", \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task permissiveNatives(type:JavaExec) {\n+tasks.register<JavaExec>(\"permissiveNatives\") {\n     description = \"Run 'Terasology' with security set to permissive and natives loading a second way (for KComputers)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\", \"-permissiveSecurity\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\", \"-permissiveSecurity\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n \n     systemProperty(\"java.library.path\", rootProject.file(dirNatives + \"/\" + nativeSubdirectoryName()))\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-// By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it\n-// TODO: This is not the Gradle Way. Needs more declared output-fu to determine up-to-date instead of the if\n-task setupServerConfig {\n-    description \"Parses parameters passed via Gradle and writes them to the local run-from-source server dir's config.cfg\"\n-\n-    def json = new JsonBuilder()\n-\n-    def serverRoot = rootProject.file(localServerDataPath);\n-    def config = new File(serverRoot, 'config.cfg')\n-\n-    if (!config.exists()) {\n-\n-        serverRoot.mkdir()\n-        logger.lifecycle(\"Creating config file $config\")\n-\n-        json {\n-            worldGeneration {\n-                if (project.hasProperty('seed')) {\n-                    logger.lifecycle(\"  Seed value: $seed\");\n-                    defaultSeed seed\n-                }\n-                if (project.hasProperty('worldGen')) {\n-                    logger.lifecycle(\"  World Generator: $worldGen\");\n-                    defaultGenerator worldGen\n-                }\n-            }\n-            defaultModSelection {\n-                if (project.hasProperty('extraModules')) {\n-                    logger.lifecycle(\"  Enabling modules: $extraModules\");\n-                    modules extraModules.tokenize(\" ,\")\n-                }\n-            }\n-        }\n-        config.text = json.toPrettyString()\n-    }\n-}\n+apply(from=\"server.build.gradle\")\n \n // TODO: Seems to always be up to date so no modules get copied\n-task setupServerModules(type: Sync) {\n-    description 'Parses \"extraModules\" - a comma-separated list of modules and puts them into ' + localServerDataPath\n+tasks.register<Sync>(\"setupServerModules\") {\n+    description =\n+        \"\"\"Parses \"extraModules\" - a comma-separated list of modules and puts them into $localServerDataPath\"\"\"\n \n-    if (project.hasProperty('extraModules')) {\n+    val extraModules: String? by project;\n+    extraModules?.let {\n         // Grab modules from Artifactory - cheats by declaring them as dependencies\n-        extraModules.tokenize(' ,').each { String module ->\n-            println \"Extra module: \" + module\n+        it.splitToSequence(\",\").forEach {\n+            logger.info(\"Extra module: {}\", it)\n             dependencies {\n-                modules group: 'org.terasology.modules', name: module, version: '+', changing: 'true'\n+                \"modules\"(group = \"org.terasology.modules\", name = it, version = \"+\")\n             }\n         }\n     }\n \n-    from(configurations.modules)\n-    into(new File(rootProject.file(localServerDataPath), \"modules\"))\n+    from(configurations.named(\"modules\"))\n+    into(File(rootProject.file(localServerDataPath), \"modules\"))\n }\n \n // TODO: Make a task to reset server / game data\n-task server(type:JavaExec) {\n-    description \"Starts a headless multiplayer server with data stored in [project-root]/$localServerDataPath\"\n+tasks.register<JavaExec>(\"server\") {\n+    description = \"Starts a headless multiplayer server with data stored in [project-root]/$localServerDataPath\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n-    dependsOn setupServerConfig\n-    dependsOn setupServerModules\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n+    dependsOn(\"setupServerConfig\")\n+    dependsOn(\"setupServerModules\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-headless\", \"-homedir=$localServerDataPath\"]\n-    args runArgs\n-    jvmArgs [\"-Xmx1536\"]\n+    args = listOf(\"-headless\", \"-homedir=$localServerDataPath\")\n+    jvmArgs = listOf(\"-Xmx1536\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n // Preps a version file to bundle with PC dists. This eventually goes into the root of a zip file\n-task createVersionFile(type: Copy) {\n-    inputs.property('dateTime', startDateTimeString)\n-    onlyIf { env.BUILD_URL != null }\n-    from templatesDir\n-    into \"$buildDir\"\n-    include versionFileName\n-    expand(buildNumber: env.BUILD_NUMBER, buildUrl: env.BUILD_URL, gitBranch: env.GIT_BRANCH, dateTime: startDateTimeString, displayVersion: displayVersion)\n-    filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+tasks.register<Copy>(\"createVersionFile\") {\n+    inputs.property(\"dateTime\", startDateTimeString)\n+    onlyIf { env[\"BUILD_URL\"] != null }\n+    from(templatesDir)\n+    into(\"$buildDir\")\n+    include(versionFileName)\n+    expand(mapOf(\n+        \"buildNumber\" to env[\"BUILD_NUMBER\"],\n+        \"buildUrl\" to env[\"BUILD_URL\"],\n+        \"gitBranch\" to env[\"GIT_BRANCH\"],\n+        \"dateTime\" to startDateTimeString,\n+        \"displayVersion\" to displayVersion\n+    ))\n+    filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n }\n \n // TODO: This could probably be done more Gradley (engine project resource dir instead of direct path?) and with some variables\n-task copyCreditsFile(type: Copy) {\n-    description \"Copies the credits file into the engine's resource dir where it'll be read at runtime\"\n-    from \"$rootDir/docs\"\n-    into \"$rootDir/engine/src/main/resources\"\n-    include \"Credits.md\"\n+tasks.register<Copy>(\"copyCreditsFile\") {\n+    description = \"Copies the credits file into the engine's resource dir where it'll be read at runtime\"\n+    from(\"$rootDir/docs\")\n+    into(\"$rootDir/engine/src/main/resources\")\n+    include(\"Credits.md\")\n }\n \n // Main application dist target. Does NOT include any modules.\n-task distApp (type: Sync) {\n+tasks.register<Sync>(\"distApp\") {\n     description = \"Creates an application package for distribution\"\n     group = \"terasology dist\"\n \n-    dependsOn createVersionFile\n-    dependsOn copyCreditsFile\n-    dependsOn rootProject.extractNatives\n-    dependsOn jar\n+    dependsOn(\"createVersionFile\")\n+    dependsOn(\"copyCreditsFile\")\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\"jar\")\n \n-    into (\"${distsDirectory.get().asFile}/app\")\n+    into(\"${distsDirectory.get().asFile}/app\")\n     from (\"$rootDir/README.markdown\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n-        rename('README.markdown', 'README')\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        rename(\"README.markdown\", \"README\")\n     }\n     from (\"$rootDir/LICENSE\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n     }\n     from (\"$rootDir/NOTICE\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n     }\n-    from('launchScripts') {\n-        exclude('TeraEd.exe')\n+    from(\"launchScripts\") {\n+        exclude(\"TeraEd.exe\")\n     }\n \n     from(\"$buildDir/$versionFileName\") {}\n \n     into(subDirLibs) {\n-        from configurations.runtimeClasspath\n-        from project(':engine').jar\n-        from (\"$buildDir/libs\") {\n-            include \"*.jar\"\n+        from(configurations.runtimeClasspath)\n+        from(tasks.getByPath(\":engine:jar\"))\n+        from(\"$buildDir/libs\") {\n+            include(\"*.jar\")\n             rename {\n-                'Terasology.jar'\n+                \"Terasology.jar\"\n             }\n         }\n     }\n     into(dirNatives) {\n-        from \"$rootDir/$dirNatives\"\n+        from(\"$rootDir/$dirNatives\")\n     }\n }\n \n // Distribute modules - only grabs Core in Jenkins but locally will grab any present. \"Distros\" now handle Jenkins packs\n-task distModules (type: Sync) {\n+tasks.register<Sync>(\"distModules\") {\n     description = \"Prepares local modules for distribution\"\n-    dependsOn distApp\n-    dependsOn rootProject.moduleJars\n+    dependsOn(\"distApp\")\n+    dependsOn(\":moduleJars\")\n \n     // So this is probably a hack, but it works ;-) It does not work if it is in distApp, default \"into\" quirk ?\n     into(\"${distsDirectory.get().asFile}/app/modules\")\n-    rootProject.terasologyModules().each {\n-        from \"$rootDir/modules/${it.name}/build/libs\"\n-        include \"*.jar\"\n+    // FIXME: duplicating code from /build.gradle:terasologyModules\n+    val terasologyModules = rootProject.subprojects.filter { it.parent?.name == \"modules\" }\n+    terasologyModules.forEach {\n+        from(\"$rootDir/modules/${it.name}/build/libs\")\n+        include(\"*.jar\")\n     }\n }\n \n-task distPCZip (type: Zip) {\n+tasks.register<Zip>(\"distPCZip\") {\n     group = \"terasology dist\"\n-    dependsOn distApp\n-    dependsOn distModules\n-    from \"${distsDirectory.get().asFile}/app\"\n-    archiveFileName = \"Terasology.zip\"\n+    dependsOn(\"distApp\")\n+    dependsOn(\"distModules\")\n+    from(\"${distsDirectory.get().asFile}/app\")\n+    archiveFileName.set(\"Terasology.zip\")\n }\n \n-task distForLauncher (type: Sync) {\n+tasks.register<Sync>(\"distForLauncher\") {\n     group = \"terasology dist\"\n \n-    into rootDirDist\n-    from distPCZip\n+    into(rootDirDist)\n+    from(tasks.getByName(\"distPCZip\"))\n \n-    into (\"../resources/main/org/terasology/version\") {\n-        from (\"$rootDir/engine/build/classes/org/terasology/version\") {\n-            include ('versionInfo.properties')\n+    into(\"../resources/main/org/terasology/version\") {\n+        from(\"$rootDir/engine/build/classes/org/terasology/version\") {\n+            include(\"versionInfo.properties\")\n         }\n     }\n }\n \n // Prep an IntelliJ module for the facade\n-idea {\n+configure<IdeaModel> {\n     module {\n         // Change around the output a bit\n         inheritOutputDirs = false\n-        outputDir = file('build/classes')\n-        testOutputDir = file('build/testClasses')\n+        outputDir = file(\"build/classes\")\n+        testOutputDir = file(\"build/testClasses\")\n     }\n }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MDkxNA=="}, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 593}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3NzM4Mg==", "bodyText": "It can affect gestalt source module loading when you compile and run it via idea.\n(And it compability with gradle build, it use same output dir, instead standart build//classes)", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r508677382", "createdAt": "2020-10-20T16:36:52Z", "author": {"login": "DarkWeird"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")\n+        attributes[\"Implementation-Title\"] = \"Terasology-\" + project.name\n+        attributes[\"Implementation-Version\"] = \"\"\"${env[\"BUILD_NUMBER\"]}, ${env[\"GIT_BRANCH\"]}, ${env[\"BUILD_ID\"]}\"\"\"\n     }\n }\n \n configurations {\n-    // for fetching modules for running a server\n-    modules {\n-        transitive = false\n+    register(\"modules\") {\n+        description = \"for fetching modules for running a server\"\n+        isTransitive = false\n     }\n }\n \n-run {\n+tasks.named<JavaExec>(\"run\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n-    args \"-homedir\", \"-noCrashReport\"\n-    jvmArgs \"-Xmx1536m\"\n-    workingDir rootDir\n+    args = listOf(\"-homedir\", \"-noCrashReport\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n+    workingDir = rootDir\n \n-    dependsOn rootProject.moduleClasses\n+    dependsOn(\":moduleClasses\")\n }\n \n-task game(type:JavaExec) {\n+tasks.register<JavaExec>(\"game\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n     // If there are no actual source modules let the user know, just in case ..\n-    if (project(':modules').subprojects.size() == 0) {\n-        def out = services.get(StyledTextOutputFactory).create(\"an-ouput\")\n-        out.withStyle(StyledTextOutput.Style.FailureHeader).println(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n+    if (project(\":modules\").subprojects.isEmpty()) {\n+        logger.warn(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n     }\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task profile(type:JavaExec) {\n+tasks.register<JavaExec>(\"profile\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application (with Java FlightRecorder profiling)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n-    jvmArgs = [\"-Xms256m\", \"-Xmx1536m\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=filename=terasology.jfr,dumponexit=true\"]\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-homedir\"]\n-    args runArgs\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xms256m\", \"-Xmx1536m\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=filename=terasology.jfr,dumponexit=true\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task debug(type:JavaExec) {\n+tasks.register<JavaExec>(\"debug\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application (in debug mode)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n-    jvmArgs = [\"-Xmx1536m\", \"-Xdebug\", \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\"]\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-homedir\"]\n-    args runArgs\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\", \"-Xdebug\", \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task permissiveNatives(type:JavaExec) {\n+tasks.register<JavaExec>(\"permissiveNatives\") {\n     description = \"Run 'Terasology' with security set to permissive and natives loading a second way (for KComputers)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\", \"-permissiveSecurity\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\", \"-permissiveSecurity\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n \n     systemProperty(\"java.library.path\", rootProject.file(dirNatives + \"/\" + nativeSubdirectoryName()))\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-// By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it\n-// TODO: This is not the Gradle Way. Needs more declared output-fu to determine up-to-date instead of the if\n-task setupServerConfig {\n-    description \"Parses parameters passed via Gradle and writes them to the local run-from-source server dir's config.cfg\"\n-\n-    def json = new JsonBuilder()\n-\n-    def serverRoot = rootProject.file(localServerDataPath);\n-    def config = new File(serverRoot, 'config.cfg')\n-\n-    if (!config.exists()) {\n-\n-        serverRoot.mkdir()\n-        logger.lifecycle(\"Creating config file $config\")\n-\n-        json {\n-            worldGeneration {\n-                if (project.hasProperty('seed')) {\n-                    logger.lifecycle(\"  Seed value: $seed\");\n-                    defaultSeed seed\n-                }\n-                if (project.hasProperty('worldGen')) {\n-                    logger.lifecycle(\"  World Generator: $worldGen\");\n-                    defaultGenerator worldGen\n-                }\n-            }\n-            defaultModSelection {\n-                if (project.hasProperty('extraModules')) {\n-                    logger.lifecycle(\"  Enabling modules: $extraModules\");\n-                    modules extraModules.tokenize(\" ,\")\n-                }\n-            }\n-        }\n-        config.text = json.toPrettyString()\n-    }\n-}\n+apply(from=\"server.build.gradle\")\n \n // TODO: Seems to always be up to date so no modules get copied\n-task setupServerModules(type: Sync) {\n-    description 'Parses \"extraModules\" - a comma-separated list of modules and puts them into ' + localServerDataPath\n+tasks.register<Sync>(\"setupServerModules\") {\n+    description =\n+        \"\"\"Parses \"extraModules\" - a comma-separated list of modules and puts them into $localServerDataPath\"\"\"\n \n-    if (project.hasProperty('extraModules')) {\n+    val extraModules: String? by project;\n+    extraModules?.let {\n         // Grab modules from Artifactory - cheats by declaring them as dependencies\n-        extraModules.tokenize(' ,').each { String module ->\n-            println \"Extra module: \" + module\n+        it.splitToSequence(\",\").forEach {\n+            logger.info(\"Extra module: {}\", it)\n             dependencies {\n-                modules group: 'org.terasology.modules', name: module, version: '+', changing: 'true'\n+                \"modules\"(group = \"org.terasology.modules\", name = it, version = \"+\")\n             }\n         }\n     }\n \n-    from(configurations.modules)\n-    into(new File(rootProject.file(localServerDataPath), \"modules\"))\n+    from(configurations.named(\"modules\"))\n+    into(File(rootProject.file(localServerDataPath), \"modules\"))\n }\n \n // TODO: Make a task to reset server / game data\n-task server(type:JavaExec) {\n-    description \"Starts a headless multiplayer server with data stored in [project-root]/$localServerDataPath\"\n+tasks.register<JavaExec>(\"server\") {\n+    description = \"Starts a headless multiplayer server with data stored in [project-root]/$localServerDataPath\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n-    dependsOn setupServerConfig\n-    dependsOn setupServerModules\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n+    dependsOn(\"setupServerConfig\")\n+    dependsOn(\"setupServerModules\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-headless\", \"-homedir=$localServerDataPath\"]\n-    args runArgs\n-    jvmArgs [\"-Xmx1536\"]\n+    args = listOf(\"-headless\", \"-homedir=$localServerDataPath\")\n+    jvmArgs = listOf(\"-Xmx1536\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n // Preps a version file to bundle with PC dists. This eventually goes into the root of a zip file\n-task createVersionFile(type: Copy) {\n-    inputs.property('dateTime', startDateTimeString)\n-    onlyIf { env.BUILD_URL != null }\n-    from templatesDir\n-    into \"$buildDir\"\n-    include versionFileName\n-    expand(buildNumber: env.BUILD_NUMBER, buildUrl: env.BUILD_URL, gitBranch: env.GIT_BRANCH, dateTime: startDateTimeString, displayVersion: displayVersion)\n-    filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+tasks.register<Copy>(\"createVersionFile\") {\n+    inputs.property(\"dateTime\", startDateTimeString)\n+    onlyIf { env[\"BUILD_URL\"] != null }\n+    from(templatesDir)\n+    into(\"$buildDir\")\n+    include(versionFileName)\n+    expand(mapOf(\n+        \"buildNumber\" to env[\"BUILD_NUMBER\"],\n+        \"buildUrl\" to env[\"BUILD_URL\"],\n+        \"gitBranch\" to env[\"GIT_BRANCH\"],\n+        \"dateTime\" to startDateTimeString,\n+        \"displayVersion\" to displayVersion\n+    ))\n+    filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n }\n \n // TODO: This could probably be done more Gradley (engine project resource dir instead of direct path?) and with some variables\n-task copyCreditsFile(type: Copy) {\n-    description \"Copies the credits file into the engine's resource dir where it'll be read at runtime\"\n-    from \"$rootDir/docs\"\n-    into \"$rootDir/engine/src/main/resources\"\n-    include \"Credits.md\"\n+tasks.register<Copy>(\"copyCreditsFile\") {\n+    description = \"Copies the credits file into the engine's resource dir where it'll be read at runtime\"\n+    from(\"$rootDir/docs\")\n+    into(\"$rootDir/engine/src/main/resources\")\n+    include(\"Credits.md\")\n }\n \n // Main application dist target. Does NOT include any modules.\n-task distApp (type: Sync) {\n+tasks.register<Sync>(\"distApp\") {\n     description = \"Creates an application package for distribution\"\n     group = \"terasology dist\"\n \n-    dependsOn createVersionFile\n-    dependsOn copyCreditsFile\n-    dependsOn rootProject.extractNatives\n-    dependsOn jar\n+    dependsOn(\"createVersionFile\")\n+    dependsOn(\"copyCreditsFile\")\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\"jar\")\n \n-    into (\"${distsDirectory.get().asFile}/app\")\n+    into(\"${distsDirectory.get().asFile}/app\")\n     from (\"$rootDir/README.markdown\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n-        rename('README.markdown', 'README')\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        rename(\"README.markdown\", \"README\")\n     }\n     from (\"$rootDir/LICENSE\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n     }\n     from (\"$rootDir/NOTICE\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n     }\n-    from('launchScripts') {\n-        exclude('TeraEd.exe')\n+    from(\"launchScripts\") {\n+        exclude(\"TeraEd.exe\")\n     }\n \n     from(\"$buildDir/$versionFileName\") {}\n \n     into(subDirLibs) {\n-        from configurations.runtimeClasspath\n-        from project(':engine').jar\n-        from (\"$buildDir/libs\") {\n-            include \"*.jar\"\n+        from(configurations.runtimeClasspath)\n+        from(tasks.getByPath(\":engine:jar\"))\n+        from(\"$buildDir/libs\") {\n+            include(\"*.jar\")\n             rename {\n-                'Terasology.jar'\n+                \"Terasology.jar\"\n             }\n         }\n     }\n     into(dirNatives) {\n-        from \"$rootDir/$dirNatives\"\n+        from(\"$rootDir/$dirNatives\")\n     }\n }\n \n // Distribute modules - only grabs Core in Jenkins but locally will grab any present. \"Distros\" now handle Jenkins packs\n-task distModules (type: Sync) {\n+tasks.register<Sync>(\"distModules\") {\n     description = \"Prepares local modules for distribution\"\n-    dependsOn distApp\n-    dependsOn rootProject.moduleJars\n+    dependsOn(\"distApp\")\n+    dependsOn(\":moduleJars\")\n \n     // So this is probably a hack, but it works ;-) It does not work if it is in distApp, default \"into\" quirk ?\n     into(\"${distsDirectory.get().asFile}/app/modules\")\n-    rootProject.terasologyModules().each {\n-        from \"$rootDir/modules/${it.name}/build/libs\"\n-        include \"*.jar\"\n+    // FIXME: duplicating code from /build.gradle:terasologyModules\n+    val terasologyModules = rootProject.subprojects.filter { it.parent?.name == \"modules\" }\n+    terasologyModules.forEach {\n+        from(\"$rootDir/modules/${it.name}/build/libs\")\n+        include(\"*.jar\")\n     }\n }\n \n-task distPCZip (type: Zip) {\n+tasks.register<Zip>(\"distPCZip\") {\n     group = \"terasology dist\"\n-    dependsOn distApp\n-    dependsOn distModules\n-    from \"${distsDirectory.get().asFile}/app\"\n-    archiveFileName = \"Terasology.zip\"\n+    dependsOn(\"distApp\")\n+    dependsOn(\"distModules\")\n+    from(\"${distsDirectory.get().asFile}/app\")\n+    archiveFileName.set(\"Terasology.zip\")\n }\n \n-task distForLauncher (type: Sync) {\n+tasks.register<Sync>(\"distForLauncher\") {\n     group = \"terasology dist\"\n \n-    into rootDirDist\n-    from distPCZip\n+    into(rootDirDist)\n+    from(tasks.getByName(\"distPCZip\"))\n \n-    into (\"../resources/main/org/terasology/version\") {\n-        from (\"$rootDir/engine/build/classes/org/terasology/version\") {\n-            include ('versionInfo.properties')\n+    into(\"../resources/main/org/terasology/version\") {\n+        from(\"$rootDir/engine/build/classes/org/terasology/version\") {\n+            include(\"versionInfo.properties\")\n         }\n     }\n }\n \n // Prep an IntelliJ module for the facade\n-idea {\n+configure<IdeaModel> {\n     module {\n         // Change around the output a bit\n         inheritOutputDirs = false\n-        outputDir = file('build/classes')\n-        testOutputDir = file('build/testClasses')\n+        outputDir = file(\"build/classes\")\n+        testOutputDir = file(\"build/testClasses\")\n     }\n }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MDkxNA=="}, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 593}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5NDY0Nw==", "bodyText": "facades/PC/ doesn't have modules in it, so for the stuff that applies only to this sub-project we don't have to worry about the gestalt loader.", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r508694647", "createdAt": "2020-10-20T17:03:31Z", "author": {"login": "keturn"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")\n+        attributes[\"Implementation-Title\"] = \"Terasology-\" + project.name\n+        attributes[\"Implementation-Version\"] = \"\"\"${env[\"BUILD_NUMBER\"]}, ${env[\"GIT_BRANCH\"]}, ${env[\"BUILD_ID\"]}\"\"\"\n     }\n }\n \n configurations {\n-    // for fetching modules for running a server\n-    modules {\n-        transitive = false\n+    register(\"modules\") {\n+        description = \"for fetching modules for running a server\"\n+        isTransitive = false\n     }\n }\n \n-run {\n+tasks.named<JavaExec>(\"run\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n-    args \"-homedir\", \"-noCrashReport\"\n-    jvmArgs \"-Xmx1536m\"\n-    workingDir rootDir\n+    args = listOf(\"-homedir\", \"-noCrashReport\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n+    workingDir = rootDir\n \n-    dependsOn rootProject.moduleClasses\n+    dependsOn(\":moduleClasses\")\n }\n \n-task game(type:JavaExec) {\n+tasks.register<JavaExec>(\"game\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n     // If there are no actual source modules let the user know, just in case ..\n-    if (project(':modules').subprojects.size() == 0) {\n-        def out = services.get(StyledTextOutputFactory).create(\"an-ouput\")\n-        out.withStyle(StyledTextOutput.Style.FailureHeader).println(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n+    if (project(\":modules\").subprojects.isEmpty()) {\n+        logger.warn(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n     }\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task profile(type:JavaExec) {\n+tasks.register<JavaExec>(\"profile\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application (with Java FlightRecorder profiling)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n-    jvmArgs = [\"-Xms256m\", \"-Xmx1536m\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=filename=terasology.jfr,dumponexit=true\"]\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-homedir\"]\n-    args runArgs\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xms256m\", \"-Xmx1536m\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=filename=terasology.jfr,dumponexit=true\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task debug(type:JavaExec) {\n+tasks.register<JavaExec>(\"debug\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application (in debug mode)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n-    jvmArgs = [\"-Xmx1536m\", \"-Xdebug\", \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\"]\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-homedir\"]\n-    args runArgs\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\", \"-Xdebug\", \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task permissiveNatives(type:JavaExec) {\n+tasks.register<JavaExec>(\"permissiveNatives\") {\n     description = \"Run 'Terasology' with security set to permissive and natives loading a second way (for KComputers)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\", \"-permissiveSecurity\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\", \"-permissiveSecurity\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n \n     systemProperty(\"java.library.path\", rootProject.file(dirNatives + \"/\" + nativeSubdirectoryName()))\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-// By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it\n-// TODO: This is not the Gradle Way. Needs more declared output-fu to determine up-to-date instead of the if\n-task setupServerConfig {\n-    description \"Parses parameters passed via Gradle and writes them to the local run-from-source server dir's config.cfg\"\n-\n-    def json = new JsonBuilder()\n-\n-    def serverRoot = rootProject.file(localServerDataPath);\n-    def config = new File(serverRoot, 'config.cfg')\n-\n-    if (!config.exists()) {\n-\n-        serverRoot.mkdir()\n-        logger.lifecycle(\"Creating config file $config\")\n-\n-        json {\n-            worldGeneration {\n-                if (project.hasProperty('seed')) {\n-                    logger.lifecycle(\"  Seed value: $seed\");\n-                    defaultSeed seed\n-                }\n-                if (project.hasProperty('worldGen')) {\n-                    logger.lifecycle(\"  World Generator: $worldGen\");\n-                    defaultGenerator worldGen\n-                }\n-            }\n-            defaultModSelection {\n-                if (project.hasProperty('extraModules')) {\n-                    logger.lifecycle(\"  Enabling modules: $extraModules\");\n-                    modules extraModules.tokenize(\" ,\")\n-                }\n-            }\n-        }\n-        config.text = json.toPrettyString()\n-    }\n-}\n+apply(from=\"server.build.gradle\")\n \n // TODO: Seems to always be up to date so no modules get copied\n-task setupServerModules(type: Sync) {\n-    description 'Parses \"extraModules\" - a comma-separated list of modules and puts them into ' + localServerDataPath\n+tasks.register<Sync>(\"setupServerModules\") {\n+    description =\n+        \"\"\"Parses \"extraModules\" - a comma-separated list of modules and puts them into $localServerDataPath\"\"\"\n \n-    if (project.hasProperty('extraModules')) {\n+    val extraModules: String? by project;\n+    extraModules?.let {\n         // Grab modules from Artifactory - cheats by declaring them as dependencies\n-        extraModules.tokenize(' ,').each { String module ->\n-            println \"Extra module: \" + module\n+        it.splitToSequence(\",\").forEach {\n+            logger.info(\"Extra module: {}\", it)\n             dependencies {\n-                modules group: 'org.terasology.modules', name: module, version: '+', changing: 'true'\n+                \"modules\"(group = \"org.terasology.modules\", name = it, version = \"+\")\n             }\n         }\n     }\n \n-    from(configurations.modules)\n-    into(new File(rootProject.file(localServerDataPath), \"modules\"))\n+    from(configurations.named(\"modules\"))\n+    into(File(rootProject.file(localServerDataPath), \"modules\"))\n }\n \n // TODO: Make a task to reset server / game data\n-task server(type:JavaExec) {\n-    description \"Starts a headless multiplayer server with data stored in [project-root]/$localServerDataPath\"\n+tasks.register<JavaExec>(\"server\") {\n+    description = \"Starts a headless multiplayer server with data stored in [project-root]/$localServerDataPath\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n-    dependsOn setupServerConfig\n-    dependsOn setupServerModules\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n+    dependsOn(\"setupServerConfig\")\n+    dependsOn(\"setupServerModules\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-headless\", \"-homedir=$localServerDataPath\"]\n-    args runArgs\n-    jvmArgs [\"-Xmx1536\"]\n+    args = listOf(\"-headless\", \"-homedir=$localServerDataPath\")\n+    jvmArgs = listOf(\"-Xmx1536\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n // Preps a version file to bundle with PC dists. This eventually goes into the root of a zip file\n-task createVersionFile(type: Copy) {\n-    inputs.property('dateTime', startDateTimeString)\n-    onlyIf { env.BUILD_URL != null }\n-    from templatesDir\n-    into \"$buildDir\"\n-    include versionFileName\n-    expand(buildNumber: env.BUILD_NUMBER, buildUrl: env.BUILD_URL, gitBranch: env.GIT_BRANCH, dateTime: startDateTimeString, displayVersion: displayVersion)\n-    filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+tasks.register<Copy>(\"createVersionFile\") {\n+    inputs.property(\"dateTime\", startDateTimeString)\n+    onlyIf { env[\"BUILD_URL\"] != null }\n+    from(templatesDir)\n+    into(\"$buildDir\")\n+    include(versionFileName)\n+    expand(mapOf(\n+        \"buildNumber\" to env[\"BUILD_NUMBER\"],\n+        \"buildUrl\" to env[\"BUILD_URL\"],\n+        \"gitBranch\" to env[\"GIT_BRANCH\"],\n+        \"dateTime\" to startDateTimeString,\n+        \"displayVersion\" to displayVersion\n+    ))\n+    filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n }\n \n // TODO: This could probably be done more Gradley (engine project resource dir instead of direct path?) and with some variables\n-task copyCreditsFile(type: Copy) {\n-    description \"Copies the credits file into the engine's resource dir where it'll be read at runtime\"\n-    from \"$rootDir/docs\"\n-    into \"$rootDir/engine/src/main/resources\"\n-    include \"Credits.md\"\n+tasks.register<Copy>(\"copyCreditsFile\") {\n+    description = \"Copies the credits file into the engine's resource dir where it'll be read at runtime\"\n+    from(\"$rootDir/docs\")\n+    into(\"$rootDir/engine/src/main/resources\")\n+    include(\"Credits.md\")\n }\n \n // Main application dist target. Does NOT include any modules.\n-task distApp (type: Sync) {\n+tasks.register<Sync>(\"distApp\") {\n     description = \"Creates an application package for distribution\"\n     group = \"terasology dist\"\n \n-    dependsOn createVersionFile\n-    dependsOn copyCreditsFile\n-    dependsOn rootProject.extractNatives\n-    dependsOn jar\n+    dependsOn(\"createVersionFile\")\n+    dependsOn(\"copyCreditsFile\")\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\"jar\")\n \n-    into (\"${distsDirectory.get().asFile}/app\")\n+    into(\"${distsDirectory.get().asFile}/app\")\n     from (\"$rootDir/README.markdown\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n-        rename('README.markdown', 'README')\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        rename(\"README.markdown\", \"README\")\n     }\n     from (\"$rootDir/LICENSE\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n     }\n     from (\"$rootDir/NOTICE\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n     }\n-    from('launchScripts') {\n-        exclude('TeraEd.exe')\n+    from(\"launchScripts\") {\n+        exclude(\"TeraEd.exe\")\n     }\n \n     from(\"$buildDir/$versionFileName\") {}\n \n     into(subDirLibs) {\n-        from configurations.runtimeClasspath\n-        from project(':engine').jar\n-        from (\"$buildDir/libs\") {\n-            include \"*.jar\"\n+        from(configurations.runtimeClasspath)\n+        from(tasks.getByPath(\":engine:jar\"))\n+        from(\"$buildDir/libs\") {\n+            include(\"*.jar\")\n             rename {\n-                'Terasology.jar'\n+                \"Terasology.jar\"\n             }\n         }\n     }\n     into(dirNatives) {\n-        from \"$rootDir/$dirNatives\"\n+        from(\"$rootDir/$dirNatives\")\n     }\n }\n \n // Distribute modules - only grabs Core in Jenkins but locally will grab any present. \"Distros\" now handle Jenkins packs\n-task distModules (type: Sync) {\n+tasks.register<Sync>(\"distModules\") {\n     description = \"Prepares local modules for distribution\"\n-    dependsOn distApp\n-    dependsOn rootProject.moduleJars\n+    dependsOn(\"distApp\")\n+    dependsOn(\":moduleJars\")\n \n     // So this is probably a hack, but it works ;-) It does not work if it is in distApp, default \"into\" quirk ?\n     into(\"${distsDirectory.get().asFile}/app/modules\")\n-    rootProject.terasologyModules().each {\n-        from \"$rootDir/modules/${it.name}/build/libs\"\n-        include \"*.jar\"\n+    // FIXME: duplicating code from /build.gradle:terasologyModules\n+    val terasologyModules = rootProject.subprojects.filter { it.parent?.name == \"modules\" }\n+    terasologyModules.forEach {\n+        from(\"$rootDir/modules/${it.name}/build/libs\")\n+        include(\"*.jar\")\n     }\n }\n \n-task distPCZip (type: Zip) {\n+tasks.register<Zip>(\"distPCZip\") {\n     group = \"terasology dist\"\n-    dependsOn distApp\n-    dependsOn distModules\n-    from \"${distsDirectory.get().asFile}/app\"\n-    archiveFileName = \"Terasology.zip\"\n+    dependsOn(\"distApp\")\n+    dependsOn(\"distModules\")\n+    from(\"${distsDirectory.get().asFile}/app\")\n+    archiveFileName.set(\"Terasology.zip\")\n }\n \n-task distForLauncher (type: Sync) {\n+tasks.register<Sync>(\"distForLauncher\") {\n     group = \"terasology dist\"\n \n-    into rootDirDist\n-    from distPCZip\n+    into(rootDirDist)\n+    from(tasks.getByName(\"distPCZip\"))\n \n-    into (\"../resources/main/org/terasology/version\") {\n-        from (\"$rootDir/engine/build/classes/org/terasology/version\") {\n-            include ('versionInfo.properties')\n+    into(\"../resources/main/org/terasology/version\") {\n+        from(\"$rootDir/engine/build/classes/org/terasology/version\") {\n+            include(\"versionInfo.properties\")\n         }\n     }\n }\n \n // Prep an IntelliJ module for the facade\n-idea {\n+configure<IdeaModel> {\n     module {\n         // Change around the output a bit\n         inheritOutputDirs = false\n-        outputDir = file('build/classes')\n-        testOutputDir = file('build/testClasses')\n+        outputDir = file(\"build/classes\")\n+        testOutputDir = file(\"build/testClasses\")\n     }\n }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MDkxNA=="}, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 593}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTExNjk5OnYy", "diffSide": "RIGHT", "path": "facades/PC/server.build.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODozMzo0OVrOHcC_wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODozMzoxN1rOHlLpzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MTI2NQ==", "bodyText": "Is this comment still up to date for the code? There is no notion of << or doLast in the code (neither before nor after the refactoring)...", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499171265", "createdAt": "2020-10-03T18:33:49Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/server.build.gradle", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+// This is still in Groovy because the embedded Groovy has a JsonBuilder.\n+import groovy.json.JsonBuilder\n+\n+\n+// By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4MjIxOQ==", "bodyText": "I agree with your reading here.\nI don't know whether that means it's just an obsolete comment that should be removed, or if there was a regression and the code lost some desired functionality.", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499182219", "createdAt": "2020-10-03T21:11:25Z", "author": {"login": "keturn"}, "path": "facades/PC/server.build.gradle", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+// This is still in Groovy because the embedded Groovy has a JsonBuilder.\n+import groovy.json.JsonBuilder\n+\n+\n+// By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MTI2NQ=="}, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDI4NA==", "bodyText": "At this point we don't know (anymore), so let's remove this.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r508750284", "createdAt": "2020-10-20T18:33:17Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/server.build.gradle", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+// This is still in Groovy because the embedded Groovy has a JsonBuilder.\n+import groovy.json.JsonBuilder\n+\n+\n+// By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MTI2NQ=="}, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 381, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}