{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzMjIyODc4", "number": 4255, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMToyNzowNVrOE7gJlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMjowNDowOVrOE7g4qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI4MTgwOnYy", "diffSide": "RIGHT", "path": "engine/build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMToyNzowNVrOH3L6Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMzoxNDowNVrOH3PKEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYyODg1MQ==", "bodyText": "Why do we need to doFirst here?", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527628851", "createdAt": "2020-11-20T11:27:05Z", "author": {"login": "skaldarnar"}, "path": "engine/build.gradle", "diffHunk": "@@ -179,11 +181,13 @@ jar {\n \n     from(tasks.getByName(\"cacheReflections\").outputs)\n \n-    manifest {\n-        def manifestClasspath = \"$subDirLibs/\" + configurations.\"${sourceSets.main.runtimeClasspathConfigurationName}\".collect {\n-            it.getName()\n-        }.join(\" $subDirLibs/\")\n-        attributes(\"Class-Path\": manifestClasspath, \"Implementation-Title\": \"Terasology-\" + project.name, \"Implementation-Version\": env.BUILD_NUMBER + \", \" + convertGitBranch(env.GIT_BRANCH) + \", \" + env.BUILD_ID + \", \" + displayVersion)\n+    doFirst {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MjA2Ng==", "bodyText": "trying to collect RuntimeClasspath at setup gradle script is bad practics ( it happens every time when you press gradle's refresh button)\nAlso i catched race condition over gradle's cache  when extracted TypeHandlerLibrary.\nThen I did use doFirst for avoid race condition and made collecting RuntimeClasspath task-related.\ndoFirst, not doLast - because manifest required at task's running.\n{@see https://docs.gradle.org/current/userguide/tutorial_using_tasks.html}", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527682066", "createdAt": "2020-11-20T13:14:05Z", "author": {"login": "DarkWeird"}, "path": "engine/build.gradle", "diffHunk": "@@ -179,11 +181,13 @@ jar {\n \n     from(tasks.getByName(\"cacheReflections\").outputs)\n \n-    manifest {\n-        def manifestClasspath = \"$subDirLibs/\" + configurations.\"${sourceSets.main.runtimeClasspathConfigurationName}\".collect {\n-            it.getName()\n-        }.join(\" $subDirLibs/\")\n-        attributes(\"Class-Path\": manifestClasspath, \"Implementation-Title\": \"Terasology-\" + project.name, \"Implementation-Version\": env.BUILD_NUMBER + \", \" + convertGitBranch(env.GIT_BRANCH) + \", \" + env.BUILD_ID + \", \" + displayVersion)\n+    doFirst {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYyODg1MQ=="}, "originalCommit": {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI4ODA5OnYy", "diffSide": "RIGHT", "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/package-info.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMToyOToxM1rOH3L-Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMToyOToxM1rOH3L-Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYyOTg1OA==", "bodyText": "\ud83d\udc4d \ud83e\udd17", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527629858", "createdAt": "2020-11-20T11:29:13Z", "author": {"login": "skaldarnar"}, "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/package-info.java", "diffHunk": "@@ -0,0 +1,11 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+/**\n+ * This package contains the interfaces and abstract classes for use when defining type handlers.\n+ * Type handlers provide the algorithms for serializing and deserializing types - this uses an implementation agnostic set of interfaces\n+ * so TypeHandlers can be used for different serialization techniques (Json, Protobuf, etc).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODMyNDU3OnYy", "diffSide": "RIGHT", "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTo0MDozNlrOH3MUBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTo0MDozNlrOH3MUBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYzNTQ2MQ==", "bodyText": "I think it is \"built-in handlers\", thus suggestion to rename this slightly:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static void populateBuildinHandlers(TypeHandlerLibrary typeHandlerLibrary) {\n          \n          \n            \n                static void populateBuiltInHandlers(TypeHandlerLibrary typeHandlerLibrary) {", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527635461", "createdAt": "2020-11-20T11:40:36Z", "author": {"login": "skaldarnar"}, "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling;\n+\n+import org.terasology.persistence.typeHandling.coreTypes.BooleanTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.ByteArrayTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.ByteTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.CharacterTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.DoubleTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.FloatTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.IntTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.LongTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.NumberTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.StringTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.ArrayTypeHandlerFactory;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.EnumTypeHandlerFactory;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.StringMapTypeHandlerFactory;\n+import org.terasology.reflection.TypeInfo;\n+import org.terasology.reflection.metadata.ClassMetadata;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+/**\n+ * A library of type handlers. This is used for the construction of class metadata.\n+ * This library should be initialised by adding a number of base type handlers, describing how to serialize each supported type.\n+ * It will then produce serializers for classes (through their ClassMetadata) on request.\n+ */\n+public interface TypeHandlerLibrary {\n+    static void populateBuildinHandlers(TypeHandlerLibrary typeHandlerLibrary) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODMzNjQ0OnYy", "diffSide": "RIGHT", "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTo0NDoyNlrOH3MbZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTo0NDoyNlrOH3MbZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYzNzM0OQ==", "bodyText": "Maybe we can add some Javadoc here? I guess this returns the Serializer for the given type, or null if no serializer for that type was registered?", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527637349", "createdAt": "2020-11-20T11:44:26Z", "author": {"login": "skaldarnar"}, "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibrary.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling;\n+\n+import org.terasology.persistence.typeHandling.coreTypes.BooleanTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.ByteArrayTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.ByteTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.CharacterTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.DoubleTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.FloatTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.IntTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.LongTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.NumberTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.StringTypeHandler;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.ArrayTypeHandlerFactory;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.EnumTypeHandlerFactory;\n+import org.terasology.persistence.typeHandling.coreTypes.factories.StringMapTypeHandlerFactory;\n+import org.terasology.reflection.TypeInfo;\n+import org.terasology.reflection.metadata.ClassMetadata;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+/**\n+ * A library of type handlers. This is used for the construction of class metadata.\n+ * This library should be initialised by adding a number of base type handlers, describing how to serialize each supported type.\n+ * It will then produce serializers for classes (through their ClassMetadata) on request.\n+ */\n+public interface TypeHandlerLibrary {\n+    static void populateBuildinHandlers(TypeHandlerLibrary typeHandlerLibrary) {\n+        typeHandlerLibrary.addTypeHandler(Boolean.class, new BooleanTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Boolean.TYPE, new BooleanTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Byte.class, new ByteTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Byte.TYPE, new ByteTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Character.class, new CharacterTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Character.TYPE, new CharacterTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Double.class, new DoubleTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Double.TYPE, new DoubleTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Float.class, new FloatTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Float.TYPE, new FloatTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Integer.class, new IntTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Integer.TYPE, new IntTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Long.class, new LongTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Long.TYPE, new LongTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(String.class, new StringTypeHandler());\n+        typeHandlerLibrary.addTypeHandler(Number.class, new NumberTypeHandler());\n+\n+        typeHandlerLibrary.addTypeHandlerFactory(new ArrayTypeHandlerFactory());\n+        typeHandlerLibrary.addTypeHandler(byte[].class, new ByteArrayTypeHandler());\n+\n+        typeHandlerLibrary.addTypeHandlerFactory(new EnumTypeHandlerFactory());\n+        typeHandlerLibrary.addTypeHandlerFactory(new StringMapTypeHandlerFactory());\n+    }\n+\n+    /**\n+     * Creates a copy of an this serialization library. This copy is initialised with all type handlers that were added to the original, but does not retain any\n+     * serializers or type handlers that were generated. This can be used to override specific types handlers from another type serializer.\n+     */\n+    TypeHandlerLibrary copy();\n+\n+    Serializer getSerializerFor(ClassMetadata<?, ?> type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODM0NTA4OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibraryImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTo0Njo1OVrOH3MgXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTo0Njo1OVrOH3MgXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYzODYyMQ==", "bodyText": "Is this change intentional? Is it important that the factory is added to this implementation or would the interface be better in the docstring here?\nI'm actually not sure what the best practice here is ... \ud83e\udd14", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527638621", "createdAt": "2020-11-20T11:46:59Z", "author": {"login": "skaldarnar"}, "path": "engine/src/main/java/org/terasology/persistence/typeHandling/TypeHandlerLibraryImpl.java", "diffHunk": "@@ -283,15 +246,16 @@ public Serializer getSerializerFor(ClassMetadata<?, ?> type) {\n     }\n \n     /**\n-     * Adds a new {@link TypeHandlerFactory} to the {@link TypeHandlerLibrary}. Factories\n+     * Adds a new {@link TypeHandlerFactory} to the {@link TypeHandlerLibraryImpl}. Factories", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODM3ODI5OnYy", "diffSide": "RIGHT", "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/inMemory/arrays/PersistedDoubleArray.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTo1NzoyM1rOH3M0WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMzowNTo1MVrOH3O6RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0MzczNw==", "bodyText": "Does it make sense to support this without a rounding mode? when would that be of use?", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527643737", "createdAt": "2020-11-20T11:57:23Z", "author": {"login": "skaldarnar"}, "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/inMemory/arrays/PersistedDoubleArray.java", "diffHunk": "@@ -0,0 +1,63 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling.inMemory.arrays;\n+\n+import gnu.trove.list.TDoubleList;\n+import gnu.trove.list.TFloatList;\n+import gnu.trove.list.TIntList;\n+import gnu.trove.list.TLongList;\n+import org.terasology.persistence.typeHandling.PersistedData;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedDouble;\n+\n+import java.util.Iterator;\n+\n+public class PersistedDoubleArray extends PersistedNumberArray {\n+\n+    private final TDoubleList data;\n+\n+    public PersistedDoubleArray(TDoubleList data) {\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return data.size();\n+    }\n+\n+    @Override\n+    public TDoubleList getAsDoubleArray() {\n+        return data;\n+    }\n+\n+    @Override\n+    public TFloatList getAsFloatArray() {\n+        return TroveUtils.doubleToFloat(data);\n+    }\n+\n+    @Override\n+    public TIntList getAsIntegerArray() {\n+        return TroveUtils.doubleToInt(data);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3ODAyMA==", "bodyText": "just copied behavior from protobuf and/or gson PersistentData impls.\nReally idkm why?", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527678020", "createdAt": "2020-11-20T13:05:51Z", "author": {"login": "DarkWeird"}, "path": "subsystems/TypeHandlerLibrary/src/main/java/org/terasology/persistence/typeHandling/inMemory/arrays/PersistedDoubleArray.java", "diffHunk": "@@ -0,0 +1,63 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling.inMemory.arrays;\n+\n+import gnu.trove.list.TDoubleList;\n+import gnu.trove.list.TFloatList;\n+import gnu.trove.list.TIntList;\n+import gnu.trove.list.TLongList;\n+import org.terasology.persistence.typeHandling.PersistedData;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedDouble;\n+\n+import java.util.Iterator;\n+\n+public class PersistedDoubleArray extends PersistedNumberArray {\n+\n+    private final TDoubleList data;\n+\n+    public PersistedDoubleArray(TDoubleList data) {\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return data.size();\n+    }\n+\n+    @Override\n+    public TDoubleList getAsDoubleArray() {\n+        return data;\n+    }\n+\n+    @Override\n+    public TFloatList getAsFloatArray() {\n+        return TroveUtils.doubleToFloat(data);\n+    }\n+\n+    @Override\n+    public TIntList getAsIntegerArray() {\n+        return TroveUtils.doubleToInt(data);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0MzczNw=="}, "originalCommit": {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODM5OTUxOnYy", "diffSide": "RIGHT", "path": "subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMjowMzowOFrOH3NBIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMjowMzowOFrOH3NBIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0NzAwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @DisplayName(\"Chech simple core types serialization\")\n          \n          \n            \n                @DisplayName(\"Check simple core types serialization\")", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527647008", "createdAt": "2020-11-20T12:03:08Z", "author": {"login": "skaldarnar"}, "path": "subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling.coreTypes;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.terasology.persistence.typeHandling.PersistedData;\n+import org.terasology.persistence.typeHandling.TypeHandler;\n+import org.terasology.persistence.typeHandling.inMemory.InMemoryPersistedDataSerializer;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedBoolean;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedDouble;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedFloat;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedInteger;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedLong;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedString;\n+\n+import java.lang.reflect.Field;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+class SimpleCoreHandlerTest {\n+\n+    private static Stream<Arguments> primitives() {\n+        return Stream.of(\n+                Arguments.of(true, new BooleanTypeHandler(), new PersistedBoolean(true)),\n+\n+                Arguments.of(1.0, new NumberTypeHandler(), new PersistedDouble(1)),\n+                Arguments.of(1, new IntTypeHandler(), new PersistedInteger(1)),\n+                Arguments.of(1L, new LongTypeHandler(), new PersistedLong(1)),\n+                Arguments.of(1.0F, new FloatTypeHandler(), new PersistedFloat(1)),\n+                Arguments.of(1.0, new DoubleTypeHandler(), new PersistedDouble(1)),\n+\n+                Arguments.of(\"foo\", new StringTypeHandler(), new PersistedString(\"foo\")),\n+                Arguments.of('f', new CharacterTypeHandler(), new PersistedString(\"f\")));\n+    }\n+\n+    @ParameterizedTest(name = \"{1}\")\n+    @DisplayName(\"Chech simple core types serialization\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODQwMjMyOnYy", "diffSide": "RIGHT", "path": "subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMjowNDowOVrOH3NC3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowNTo1N1rOH3Q-yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0NzQ1NA==", "bodyText": "Testing some edge cases would be nice, but the setup is quite nice and we can easily add them later.", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527647454", "createdAt": "2020-11-20T12:04:09Z", "author": {"login": "skaldarnar"}, "path": "subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling.coreTypes;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.terasology.persistence.typeHandling.PersistedData;\n+import org.terasology.persistence.typeHandling.TypeHandler;\n+import org.terasology.persistence.typeHandling.inMemory.InMemoryPersistedDataSerializer;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedBoolean;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedDouble;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedFloat;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedInteger;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedLong;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedString;\n+\n+import java.lang.reflect.Field;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+class SimpleCoreHandlerTest {\n+\n+    private static Stream<Arguments> primitives() {\n+        return Stream.of(\n+                Arguments.of(true, new BooleanTypeHandler(), new PersistedBoolean(true)),\n+\n+                Arguments.of(1.0, new NumberTypeHandler(), new PersistedDouble(1)),\n+                Arguments.of(1, new IntTypeHandler(), new PersistedInteger(1)),\n+                Arguments.of(1L, new LongTypeHandler(), new PersistedLong(1)),\n+                Arguments.of(1.0F, new FloatTypeHandler(), new PersistedFloat(1)),\n+                Arguments.of(1.0, new DoubleTypeHandler(), new PersistedDouble(1)),\n+\n+                Arguments.of(\"foo\", new StringTypeHandler(), new PersistedString(\"foo\")),\n+                Arguments.of('f', new CharacterTypeHandler(), new PersistedString(\"f\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcxMTk0Nw==", "bodyText": "this typehandlers almost haven't edge cases. (related to java's data types)\nyeah, I known one case :D sends emoji character to CharacterTypeHandler.. and deserialize it back.", "url": "https://github.com/MovingBlocks/Terasology/pull/4255#discussion_r527711947", "createdAt": "2020-11-20T14:05:57Z", "author": {"login": "DarkWeird"}, "path": "subsystems/TypeHandlerLibrary/src/test/java/org/terasology/persistence/typeHandling/coreTypes/SimpleCoreHandlerTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.persistence.typeHandling.coreTypes;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.terasology.persistence.typeHandling.PersistedData;\n+import org.terasology.persistence.typeHandling.TypeHandler;\n+import org.terasology.persistence.typeHandling.inMemory.InMemoryPersistedDataSerializer;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedBoolean;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedDouble;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedFloat;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedInteger;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedLong;\n+import org.terasology.persistence.typeHandling.inMemory.PersistedString;\n+\n+import java.lang.reflect.Field;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+class SimpleCoreHandlerTest {\n+\n+    private static Stream<Arguments> primitives() {\n+        return Stream.of(\n+                Arguments.of(true, new BooleanTypeHandler(), new PersistedBoolean(true)),\n+\n+                Arguments.of(1.0, new NumberTypeHandler(), new PersistedDouble(1)),\n+                Arguments.of(1, new IntTypeHandler(), new PersistedInteger(1)),\n+                Arguments.of(1L, new LongTypeHandler(), new PersistedLong(1)),\n+                Arguments.of(1.0F, new FloatTypeHandler(), new PersistedFloat(1)),\n+                Arguments.of(1.0, new DoubleTypeHandler(), new PersistedDouble(1)),\n+\n+                Arguments.of(\"foo\", new StringTypeHandler(), new PersistedString(\"foo\")),\n+                Arguments.of('f', new CharacterTypeHandler(), new PersistedString(\"f\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0NzQ1NA=="}, "originalCommit": {"oid": "5b8657b94b9e44aa8cfb87371a312415ecf0d92f"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 270, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}