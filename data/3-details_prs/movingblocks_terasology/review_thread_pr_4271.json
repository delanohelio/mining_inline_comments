{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2NDk1Njkx", "number": 4271, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo0NzoxNVrOE_RMzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMFQxODozMToyM1rOFM9VGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Nzc3NTUwOnYy", "diffSide": "RIGHT", "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzo0NzoxNVrOH84pNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzo0ODoxM1rOIC7rfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYwNDY2MA==", "bodyText": "Maybe better to use java.util.Timer?\nIt can run task every fixed rate (i saw Thread.sleep(5000) in code below)", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r533604660", "createdAt": "2020-12-01T17:47:15Z", "author": {"login": "DarkWeird"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;\n+    private static final String DISCORD_APP_DEFAULT_IMAGE = \"ss_6\";\n+    private static final int MAX_RECONNECT_TRIES = 5;\n+\n+    private final Thread thread;\n+    private final IPCClient ipcClient;\n+    private final DiscordRPCBuffer buffer;\n+    private RichPresence lastRichPresence;\n+\n+    private int tries;\n+\n+    private boolean enabled;\n+    private boolean waiting;\n+    private boolean connectedBefore;\n+    private boolean connected;\n+    private boolean autoReconnect;\n+\n+    public DiscordRPCThread() {\n+        thread = new Thread(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47bae742f7fdb5466bd0bfc66ee01d7275efa3d6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NTg1Mw==", "bodyText": "I thought of using the java.util.Timer. But, that would make handling connection to Discord client harder to do.\nBecause there are special cases like:\n\nIf the player doesn't have the Discord client we need to try to reconnect then gave up on trying.\nIf the player has the Discord client then we connect to it and keep the connection alive. Even if the player disabled the RPC option in the player settings.\nWhen the player toggles the RPC option in the player settings we just have to send null to the Discord client. Instead of closing the connection. And re-connecting again when enabled.", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r539945853", "createdAt": "2020-12-10T07:48:13Z", "author": {"login": "iHDeveloper"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,250 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;\n+    private static final String DISCORD_APP_DEFAULT_IMAGE = \"ss_6\";\n+    private static final int MAX_RECONNECT_TRIES = 5;\n+\n+    private final Thread thread;\n+    private final IPCClient ipcClient;\n+    private final DiscordRPCBuffer buffer;\n+    private RichPresence lastRichPresence;\n+\n+    private int tries;\n+\n+    private boolean enabled;\n+    private boolean waiting;\n+    private boolean connectedBefore;\n+    private boolean connected;\n+    private boolean autoReconnect;\n+\n+    public DiscordRPCThread() {\n+        thread = new Thread(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYwNDY2MA=="}, "originalCommit": {"oid": "47bae742f7fdb5466bd0bfc66ee01d7275efa3d6"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5MTMxMzY0OnYy", "diffSide": "RIGHT", "path": ".idea/checkstyle-idea.xml", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMFQxODoyNDoxNFrOIQ6XSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDoyNTo1NVrOIbaHMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNDM2Mw==", "bodyText": "What kind of scans does this include?\n@keturn to the rescue? \ud83d\ude43", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r554604363", "createdAt": "2021-01-10T18:24:14Z", "author": {"login": "skaldarnar"}, "path": ".idea/checkstyle-idea.xml", "diffHunk": "@@ -10,7 +10,7 @@\n         <entry key=\"location-1\" value=\"BUNDLED:(bundled):Google Checks\" />\n         <entry key=\"location-2\" value=\"PROJECT_RELATIVE:$PROJECT_DIR$/config/metrics/checkstyle/checkstyle.xml:Terasology\" />\n         <entry key=\"property-2.samedir\" value=\"config/metrics/checkstyle\" />\n-        <entry key=\"scan-before-checkin\" value=\"false\" />\n+        <entry key=\"scan-before-checkin\" value=\"true\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA3ODIyMw==", "bodyText": "Honestly, I didn't notice this file is added into the commit stage. \ud83d\ude05\nBut, I can assume it happened because I enabled the Checkstyle scan before VCS check-in (aka before commit).\nEdit: Should I disable it?", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r559078223", "createdAt": "2021-01-17T04:54:23Z", "author": {"login": "iHDeveloper"}, "path": ".idea/checkstyle-idea.xml", "diffHunk": "@@ -10,7 +10,7 @@\n         <entry key=\"location-1\" value=\"BUNDLED:(bundled):Google Checks\" />\n         <entry key=\"location-2\" value=\"PROJECT_RELATIVE:$PROJECT_DIR$/config/metrics/checkstyle/checkstyle.xml:Terasology\" />\n         <entry key=\"property-2.samedir\" value=\"config/metrics/checkstyle\" />\n-        <entry key=\"scan-before-checkin\" value=\"false\" />\n+        <entry key=\"scan-before-checkin\" value=\"true\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNDM2Mw=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIwNzc5Ng==", "bodyText": "Yes please - while that's possibly a good practice it is probably better if we leave it up to individual contributors for now, not all of whom may even have the Checkstyle plugin installed (I don't remember if that's a default one) :-)\nProbably would be a different project to actually get the Checkstyle config and docs to the point where we could consider doing this for real. We'd want to make sure we have good docs on what a false positive is, for instance, or that might confuse contributors and lead to unrelated \"fixes\" in PRs we then have to ask to have undone \ud83d\ude05", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r559207796", "createdAt": "2021-01-17T16:54:08Z", "author": {"login": "Cervator"}, "path": ".idea/checkstyle-idea.xml", "diffHunk": "@@ -10,7 +10,7 @@\n         <entry key=\"location-1\" value=\"BUNDLED:(bundled):Google Checks\" />\n         <entry key=\"location-2\" value=\"PROJECT_RELATIVE:$PROJECT_DIR$/config/metrics/checkstyle/checkstyle.xml:Terasology\" />\n         <entry key=\"property-2.samedir\" value=\"config/metrics/checkstyle\" />\n-        <entry key=\"scan-before-checkin\" value=\"false\" />\n+        <entry key=\"scan-before-checkin\" value=\"true\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNDM2Mw=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDUxMzAwOA==", "bodyText": "Then we should find a way to ignore these change by default (put .idea into the git-ignored list?). I think if a user changes this setting, it will automatically reflect in a change in this checked-in config file.... =/", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r560513008", "createdAt": "2021-01-19T21:37:36Z", "author": {"login": "skaldarnar"}, "path": ".idea/checkstyle-idea.xml", "diffHunk": "@@ -10,7 +10,7 @@\n         <entry key=\"location-1\" value=\"BUNDLED:(bundled):Google Checks\" />\n         <entry key=\"location-2\" value=\"PROJECT_RELATIVE:$PROJECT_DIR$/config/metrics/checkstyle/checkstyle.xml:Terasology\" />\n         <entry key=\"property-2.samedir\" value=\"config/metrics/checkstyle\" />\n-        <entry key=\"scan-before-checkin\" value=\"false\" />\n+        <entry key=\"scan-before-checkin\" value=\"true\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNDM2Mw=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDUyODkyNA==", "bodyText": "This looks like a topic for another venue. For the purposes of this PR, if it's not obviously the right setting, go ahead and revert the change to this file.", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r560528924", "createdAt": "2021-01-19T22:08:18Z", "author": {"login": "keturn"}, "path": ".idea/checkstyle-idea.xml", "diffHunk": "@@ -10,7 +10,7 @@\n         <entry key=\"location-1\" value=\"BUNDLED:(bundled):Google Checks\" />\n         <entry key=\"location-2\" value=\"PROJECT_RELATIVE:$PROJECT_DIR$/config/metrics/checkstyle/checkstyle.xml:Terasology\" />\n         <entry key=\"property-2.samedir\" value=\"config/metrics/checkstyle\" />\n-        <entry key=\"scan-before-checkin\" value=\"false\" />\n+        <entry key=\"scan-before-checkin\" value=\"true\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNDM2Mw=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5MjMxNw==", "bodyText": "Alright I will revert the change and try to avoid adding those unrelated files by accident \ud83d\ude05", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r565592317", "createdAt": "2021-01-27T19:54:50Z", "author": {"login": "iHDeveloper"}, "path": ".idea/checkstyle-idea.xml", "diffHunk": "@@ -10,7 +10,7 @@\n         <entry key=\"location-1\" value=\"BUNDLED:(bundled):Google Checks\" />\n         <entry key=\"location-2\" value=\"PROJECT_RELATIVE:$PROJECT_DIR$/config/metrics/checkstyle/checkstyle.xml:Terasology\" />\n         <entry key=\"property-2.samedir\" value=\"config/metrics/checkstyle\" />\n-        <entry key=\"scan-before-checkin\" value=\"false\" />\n+        <entry key=\"scan-before-checkin\" value=\"true\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNDM2Mw=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYxMDI4OA==", "bodyText": "Alright I will revert the change and try to avoid adding those unrelated files by accident \ud83d\ude05", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r565610288", "createdAt": "2021-01-27T20:25:55Z", "author": {"login": "iHDeveloper"}, "path": ".idea/checkstyle-idea.xml", "diffHunk": "@@ -10,7 +10,7 @@\n         <entry key=\"location-1\" value=\"BUNDLED:(bundled):Google Checks\" />\n         <entry key=\"location-2\" value=\"PROJECT_RELATIVE:$PROJECT_DIR$/config/metrics/checkstyle/checkstyle.xml:Terasology\" />\n         <entry key=\"property-2.samedir\" value=\"config/metrics/checkstyle\" />\n-        <entry key=\"scan-before-checkin\" value=\"false\" />\n+        <entry key=\"scan-before-checkin\" value=\"true\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNDM2Mw=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5MTMxNjg0OnYy", "diffSide": "RIGHT", "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCSubSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMFQxODoyNzowNFrOIQ6YxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDoyNTo1MVrOIbaHAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNDc0MQ==", "bodyText": "Since we log the start of initializing as INFO, should we also load the success when the thread was started (analog to the case where the integration is disabled).", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r554604741", "createdAt": "2021-01-10T18:27:04Z", "author": {"login": "skaldarnar"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCSubSystem.java", "diffHunk": "@@ -38,281 +31,136 @@\n  * Subsystem that manages Discord RPC in the game client, such as status or connection.\n  * This subsystem can be enhanced further to improve game presentation in rich presence.\n  *\n+ * It communicates with the thread safely using thread-safe shared buffer.\n+ *\n  * @see EngineSubsystem\n  */\n-public class DiscordRPCSubSystem implements EngineSubsystem, IPCListener, Runnable, PropertyChangeListener {\n-\n+public final class DiscordRPCSubSystem implements EngineSubsystem, PropertyChangeListener {\n     private static final Logger logger = LoggerFactory.getLogger(DiscordRPCSubSystem.class);\n-    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;\n-    private static final String DISCORD_APP_LARGE_IMAGE = \"ss_6\";\n-    private static final int RECONNECT_TRIES = 5;\n     private static DiscordRPCSubSystem instance;\n \n-    private IPCClient ipcClient;\n-    private boolean ready;\n-    private boolean autoReconnect;\n-    private Thread reconnectThread;\n-    private RichPresence lastRichPresence;\n-    private boolean reconnecting;\n-    private int reconnectTries = 1;\n-    private boolean connectedBefore;\n     private Config config;\n-    private String lastState;\n-    private boolean dontTryAgain;\n-    private boolean enabled;\n+    private DiscordRPCThread thread;\n \n     public DiscordRPCSubSystem() throws IllegalStateException {\n         if (instance != null) {\n             throw new IllegalStateException(\"More then one instance in the DiscordRPC\");\n         }\n-        lastRichPresence = null;\n-        ipcClient = new IPCClient(DISCORD_APP_CLIENT_ID);\n-        ipcClient.setListener(this);\n-        autoReconnect = true;\n-        reconnectThread = new Thread(this);\n-        reconnectThread.setName(\"DISCORD-RPC-RECONNECT\");\n-        reconnectThread.start();\n-        instance = this;\n-        enabled = false;\n-        dontTryAgain = true;\n-    }\n \n-    public void sendRichPresence(RichPresence richPresence) {\n-        this.lastRichPresence = richPresence;\n-        if (!ready || lastRichPresence == null || !enabled) {\n-            return;\n-        }\n-        ipcClient.sendRichPresence(lastRichPresence);\n+        instance = this;\n     }\n \n     @Override\n-    public void onReady(IPCClient client) {\n-        if (reconnecting) {\n-            logger.info(\"Discord RPC >> Reconnected!\");\n-            reconnectTries = 1;\n-        } else {\n-            logger.info(\"Discord RPC >> Connected!\");\n-            connectedBefore = true;\n-        }\n-        this.ipcClient = client;\n-        if (!ready) {\n-            ready = true;\n-        }\n-        if (lastRichPresence == null) {\n-            RichPresence.Builder builder = new RichPresence.Builder();\n-            builder.setLargeImage(DISCORD_APP_LARGE_IMAGE);\n-            lastRichPresence = builder.build();\n-        }\n-        client.sendRichPresence(lastRichPresence);\n-    }\n+    public void initialise(GameEngine engine, Context rootContext) {\n+        logger.info(\"Initializing...\");\n \n-    @Override\n-    public void onDisconnect(IPCClient client, Throwable t) {\n-        if (ready) {\n-            ready = false;\n+        thread = new DiscordRPCThread();\n+        thread.getBuffer().setState(\"In Main Menu\");\n+\n+        config = rootContext.get(Config.class);\n+\n+        if (config.getPlayer().isDiscordPresence()) {\n+            thread.enable();\n+        } else {\n+            logger.info(\"Discord RPC is disabled! No connection is being made during initialization.\");\n+            thread.disable();\n         }\n-        logger.info(\"Discord RPC >> Disconnected!\");\n+        thread.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYxMDI0MQ==", "bodyText": "The purpose of the thread is to be alive all the time until the game shuts down. But if the user disabled the RPC the thread will be in the sleeping mode until something changes and notifies it. When the thread gets notified it tries to connect to the IPC server. If it fails to connect 5 times at maximum then the thread will go sleep again.", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r565610241", "createdAt": "2021-01-27T20:25:51Z", "author": {"login": "iHDeveloper"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCSubSystem.java", "diffHunk": "@@ -38,281 +31,136 @@\n  * Subsystem that manages Discord RPC in the game client, such as status or connection.\n  * This subsystem can be enhanced further to improve game presentation in rich presence.\n  *\n+ * It communicates with the thread safely using thread-safe shared buffer.\n+ *\n  * @see EngineSubsystem\n  */\n-public class DiscordRPCSubSystem implements EngineSubsystem, IPCListener, Runnable, PropertyChangeListener {\n-\n+public final class DiscordRPCSubSystem implements EngineSubsystem, PropertyChangeListener {\n     private static final Logger logger = LoggerFactory.getLogger(DiscordRPCSubSystem.class);\n-    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;\n-    private static final String DISCORD_APP_LARGE_IMAGE = \"ss_6\";\n-    private static final int RECONNECT_TRIES = 5;\n     private static DiscordRPCSubSystem instance;\n \n-    private IPCClient ipcClient;\n-    private boolean ready;\n-    private boolean autoReconnect;\n-    private Thread reconnectThread;\n-    private RichPresence lastRichPresence;\n-    private boolean reconnecting;\n-    private int reconnectTries = 1;\n-    private boolean connectedBefore;\n     private Config config;\n-    private String lastState;\n-    private boolean dontTryAgain;\n-    private boolean enabled;\n+    private DiscordRPCThread thread;\n \n     public DiscordRPCSubSystem() throws IllegalStateException {\n         if (instance != null) {\n             throw new IllegalStateException(\"More then one instance in the DiscordRPC\");\n         }\n-        lastRichPresence = null;\n-        ipcClient = new IPCClient(DISCORD_APP_CLIENT_ID);\n-        ipcClient.setListener(this);\n-        autoReconnect = true;\n-        reconnectThread = new Thread(this);\n-        reconnectThread.setName(\"DISCORD-RPC-RECONNECT\");\n-        reconnectThread.start();\n-        instance = this;\n-        enabled = false;\n-        dontTryAgain = true;\n-    }\n \n-    public void sendRichPresence(RichPresence richPresence) {\n-        this.lastRichPresence = richPresence;\n-        if (!ready || lastRichPresence == null || !enabled) {\n-            return;\n-        }\n-        ipcClient.sendRichPresence(lastRichPresence);\n+        instance = this;\n     }\n \n     @Override\n-    public void onReady(IPCClient client) {\n-        if (reconnecting) {\n-            logger.info(\"Discord RPC >> Reconnected!\");\n-            reconnectTries = 1;\n-        } else {\n-            logger.info(\"Discord RPC >> Connected!\");\n-            connectedBefore = true;\n-        }\n-        this.ipcClient = client;\n-        if (!ready) {\n-            ready = true;\n-        }\n-        if (lastRichPresence == null) {\n-            RichPresence.Builder builder = new RichPresence.Builder();\n-            builder.setLargeImage(DISCORD_APP_LARGE_IMAGE);\n-            lastRichPresence = builder.build();\n-        }\n-        client.sendRichPresence(lastRichPresence);\n-    }\n+    public void initialise(GameEngine engine, Context rootContext) {\n+        logger.info(\"Initializing...\");\n \n-    @Override\n-    public void onDisconnect(IPCClient client, Throwable t) {\n-        if (ready) {\n-            ready = false;\n+        thread = new DiscordRPCThread();\n+        thread.getBuffer().setState(\"In Main Menu\");\n+\n+        config = rootContext.get(Config.class);\n+\n+        if (config.getPlayer().isDiscordPresence()) {\n+            thread.enable();\n+        } else {\n+            logger.info(\"Discord RPC is disabled! No connection is being made during initialization.\");\n+            thread.disable();\n         }\n-        logger.info(\"Discord RPC >> Disconnected!\");\n+        thread.start();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNDc0MQ=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5MTMxOTAyOnYy", "diffSide": "RIGHT", "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMFQxODoyOToxOFrOIQ6ZyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDoxNTo0N1rOIbZvug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNTAwMQ==", "bodyText": "Is this a random number or something assigned to us in some way?", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r554605001", "createdAt": "2021-01-10T18:29:18Z", "author": {"login": "skaldarnar"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA3ODc3OA==", "bodyText": "This random represents the client ID of the Discord application. Discord client needs this ID to fetch information and assets about the application to display it to the rich presence.", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r559078778", "createdAt": "2021-01-17T05:01:06Z", "author": {"login": "iHDeveloper"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNTAwMQ=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIwNzkwMg==", "bodyText": "Yeah I think that might be associated with our registered app on Discord, which I originally set up. Nowadays the app is owned by a team with several of us having access \ud83d\udc4d", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r559207902", "createdAt": "2021-01-17T16:55:01Z", "author": {"login": "Cervator"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNTAwMQ=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDUxMzY3Nw==", "bodyText": "Is that sensitive information (like an access token) or more of a global identifier?", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r560513677", "createdAt": "2021-01-19T21:38:48Z", "author": {"login": "skaldarnar"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNTAwMQ=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDY1OTkzNQ==", "bodyText": "Just an identifier \ud83d\udc4d There's also a secret but I don't think it is needed for anything in this case.\nIncidentally you should have access to it via https://discord.com/developers/teams/781638052501520417 although it looks like you might have gotten an invite and not accepted it yet (Nira is in)", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r560659935", "createdAt": "2021-01-20T04:02:15Z", "author": {"login": "Cervator"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNTAwMQ=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwNDI4Mg==", "bodyText": "Yep as Cervator said it's an identifier so it's not sensitive information. And, about the secret, it's mostly used in OAuth2 applications which I think we don't need soon.\nI agree with what Cervator said. And about the secret, it's mostly used in OAuth2 applications which I don't think we will need soon.", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r565604282", "createdAt": "2021-01-27T20:15:47Z", "author": {"login": "iHDeveloper"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNTAwMQ=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5MTMyMDU3OnYy", "diffSide": "RIGHT", "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMFQxODozMToyM1rOIQ6aoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDoyMzowOVrOIbaAng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNTIxNg==", "bodyText": "How much will this actually log on the INFO level? I'm cautious when I see logger.info in combination with loops or frequently called methods as this might spam the log.", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r554605216", "createdAt": "2021-01-10T18:31:23Z", "author": {"login": "skaldarnar"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;\n+    private static final String DISCORD_APP_DEFAULT_IMAGE = \"ss_6\";\n+    private static final int MAX_RECONNECT_TRIES = 5;\n+\n+    private final Thread thread;\n+    private final IPCClient ipcClient;\n+    private final DiscordRPCBuffer buffer;\n+    private RichPresence lastRichPresence;\n+\n+    private int tries;\n+\n+    private boolean enabled;\n+    private boolean waiting;\n+    private boolean connectedBefore;\n+    private boolean connected;\n+    private boolean autoReconnect;\n+\n+    public DiscordRPCThread() {\n+        thread = new Thread(this);\n+        thread.setName(\"DISCORD-RPC-THREAD\");\n+\n+        ipcClient = new IPCClient(DISCORD_APP_CLIENT_ID);\n+        ipcClient.setListener(this);\n+\n+        buffer = new DiscordRPCBuffer();\n+\n+        lastRichPresence = null;\n+\n+        tries = 0;\n+\n+        enabled = false;\n+        waiting = false;\n+        connectedBefore = false;\n+        connected = false;\n+        autoReconnect = false;\n+    }\n+\n+    public void start() {\n+        thread.start();\n+    }\n+\n+    public synchronized void stop() {\n+        synchronized (thread) {\n+            thread.interrupt();\n+        }\n+    }\n+\n+    public synchronized void discover() {\n+        if (enabled && connected) {\n+            return;\n+        }\n+\n+        reset(true);\n+\n+        connectedBefore = true;\n+    }\n+\n+    public synchronized void enable() {\n+        if (enabled) {\n+            return;\n+        }\n+\n+        enabled = true;\n+        autoReconnect = true;\n+\n+        if (waiting && thread.isAlive()) {\n+            synchronized (thread) {\n+                thread.notify();\n+            }\n+        }\n+    }\n+\n+    public synchronized void disable() {\n+        disable(false);\n+    }\n+\n+    public synchronized void disable(boolean keepConnectionAlive) {\n+        if (!enabled) {\n+            return;\n+        }\n+\n+        enabled = false;\n+\n+        reset(!keepConnectionAlive);\n+        if (!keepConnectionAlive) {\n+            autoReconnect = false;\n+        }\n+\n+        if (waiting && thread.isAlive()) {\n+            synchronized (thread) {\n+                thread.notify();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onReady(IPCClient ignored) {\n+        if (connectedBefore) {\n+            logger.info(\"Re-connected to Discord RPC!\");\n+        } else {\n+            logger.info(\"Connected to Discord RPC!\");\n+        }\n+\n+        connectedBefore = true;\n+        connected = true;\n+    }\n+\n+    @Override\n+    public void onDisconnect(IPCClient client, Throwable t) {\n+        connected = false;\n+        logger.info(\"Discord RPC lost connection: Disconnected!\");\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (true) {\n+            logger.info(\"Waiting for auto-connecting...\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA3OTUxOQ==", "bodyText": "The purpose of the loop is to keep the thread alive. It's rare for this auto-connect log to appear.\nIt will appear by one of these conditions below:\n\nOnce on the start\nEvery time the player disables the rich presence from the player settings (if the player doesn't have the Discord client)\nWhen the thread tries to find the Discord client but still couldn't connect to it.", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r559079519", "createdAt": "2021-01-17T05:12:06Z", "author": {"login": "iHDeveloper"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;\n+    private static final String DISCORD_APP_DEFAULT_IMAGE = \"ss_6\";\n+    private static final int MAX_RECONNECT_TRIES = 5;\n+\n+    private final Thread thread;\n+    private final IPCClient ipcClient;\n+    private final DiscordRPCBuffer buffer;\n+    private RichPresence lastRichPresence;\n+\n+    private int tries;\n+\n+    private boolean enabled;\n+    private boolean waiting;\n+    private boolean connectedBefore;\n+    private boolean connected;\n+    private boolean autoReconnect;\n+\n+    public DiscordRPCThread() {\n+        thread = new Thread(this);\n+        thread.setName(\"DISCORD-RPC-THREAD\");\n+\n+        ipcClient = new IPCClient(DISCORD_APP_CLIENT_ID);\n+        ipcClient.setListener(this);\n+\n+        buffer = new DiscordRPCBuffer();\n+\n+        lastRichPresence = null;\n+\n+        tries = 0;\n+\n+        enabled = false;\n+        waiting = false;\n+        connectedBefore = false;\n+        connected = false;\n+        autoReconnect = false;\n+    }\n+\n+    public void start() {\n+        thread.start();\n+    }\n+\n+    public synchronized void stop() {\n+        synchronized (thread) {\n+            thread.interrupt();\n+        }\n+    }\n+\n+    public synchronized void discover() {\n+        if (enabled && connected) {\n+            return;\n+        }\n+\n+        reset(true);\n+\n+        connectedBefore = true;\n+    }\n+\n+    public synchronized void enable() {\n+        if (enabled) {\n+            return;\n+        }\n+\n+        enabled = true;\n+        autoReconnect = true;\n+\n+        if (waiting && thread.isAlive()) {\n+            synchronized (thread) {\n+                thread.notify();\n+            }\n+        }\n+    }\n+\n+    public synchronized void disable() {\n+        disable(false);\n+    }\n+\n+    public synchronized void disable(boolean keepConnectionAlive) {\n+        if (!enabled) {\n+            return;\n+        }\n+\n+        enabled = false;\n+\n+        reset(!keepConnectionAlive);\n+        if (!keepConnectionAlive) {\n+            autoReconnect = false;\n+        }\n+\n+        if (waiting && thread.isAlive()) {\n+            synchronized (thread) {\n+                thread.notify();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onReady(IPCClient ignored) {\n+        if (connectedBefore) {\n+            logger.info(\"Re-connected to Discord RPC!\");\n+        } else {\n+            logger.info(\"Connected to Discord RPC!\");\n+        }\n+\n+        connectedBefore = true;\n+        connected = true;\n+    }\n+\n+    @Override\n+    public void onDisconnect(IPCClient client, Throwable t) {\n+        connected = false;\n+        logger.info(\"Discord RPC lost connection: Disconnected!\");\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (true) {\n+            logger.info(\"Waiting for auto-connecting...\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNTIxNg=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIwODQwMA==", "bodyText": "Likewise a bit concerned here, it doesn't seem overly far fetched that a connectivity issue could appear then suddenly the log is being filled by junk due to a decidedly optional extra that you could play without perfectly fine otherwise :-)\nIn other words: if the Discord integration breaks or is in a bad state it shouldn't be too loud about it - ideally just log once per \"incident\" however we define that", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r559208400", "createdAt": "2021-01-17T16:58:00Z", "author": {"login": "Cervator"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;\n+    private static final String DISCORD_APP_DEFAULT_IMAGE = \"ss_6\";\n+    private static final int MAX_RECONNECT_TRIES = 5;\n+\n+    private final Thread thread;\n+    private final IPCClient ipcClient;\n+    private final DiscordRPCBuffer buffer;\n+    private RichPresence lastRichPresence;\n+\n+    private int tries;\n+\n+    private boolean enabled;\n+    private boolean waiting;\n+    private boolean connectedBefore;\n+    private boolean connected;\n+    private boolean autoReconnect;\n+\n+    public DiscordRPCThread() {\n+        thread = new Thread(this);\n+        thread.setName(\"DISCORD-RPC-THREAD\");\n+\n+        ipcClient = new IPCClient(DISCORD_APP_CLIENT_ID);\n+        ipcClient.setListener(this);\n+\n+        buffer = new DiscordRPCBuffer();\n+\n+        lastRichPresence = null;\n+\n+        tries = 0;\n+\n+        enabled = false;\n+        waiting = false;\n+        connectedBefore = false;\n+        connected = false;\n+        autoReconnect = false;\n+    }\n+\n+    public void start() {\n+        thread.start();\n+    }\n+\n+    public synchronized void stop() {\n+        synchronized (thread) {\n+            thread.interrupt();\n+        }\n+    }\n+\n+    public synchronized void discover() {\n+        if (enabled && connected) {\n+            return;\n+        }\n+\n+        reset(true);\n+\n+        connectedBefore = true;\n+    }\n+\n+    public synchronized void enable() {\n+        if (enabled) {\n+            return;\n+        }\n+\n+        enabled = true;\n+        autoReconnect = true;\n+\n+        if (waiting && thread.isAlive()) {\n+            synchronized (thread) {\n+                thread.notify();\n+            }\n+        }\n+    }\n+\n+    public synchronized void disable() {\n+        disable(false);\n+    }\n+\n+    public synchronized void disable(boolean keepConnectionAlive) {\n+        if (!enabled) {\n+            return;\n+        }\n+\n+        enabled = false;\n+\n+        reset(!keepConnectionAlive);\n+        if (!keepConnectionAlive) {\n+            autoReconnect = false;\n+        }\n+\n+        if (waiting && thread.isAlive()) {\n+            synchronized (thread) {\n+                thread.notify();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onReady(IPCClient ignored) {\n+        if (connectedBefore) {\n+            logger.info(\"Re-connected to Discord RPC!\");\n+        } else {\n+            logger.info(\"Connected to Discord RPC!\");\n+        }\n+\n+        connectedBefore = true;\n+        connected = true;\n+    }\n+\n+    @Override\n+    public void onDisconnect(IPCClient client, Throwable t) {\n+        connected = false;\n+        logger.info(\"Discord RPC lost connection: Disconnected!\");\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (true) {\n+            logger.info(\"Waiting for auto-connecting...\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNTIxNg=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDUxNDMxNQ==", "bodyText": "So what happens if the discord servers are down, or the player just does not have an active internet connection?", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r560514315", "createdAt": "2021-01-19T21:40:00Z", "author": {"login": "skaldarnar"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;\n+    private static final String DISCORD_APP_DEFAULT_IMAGE = \"ss_6\";\n+    private static final int MAX_RECONNECT_TRIES = 5;\n+\n+    private final Thread thread;\n+    private final IPCClient ipcClient;\n+    private final DiscordRPCBuffer buffer;\n+    private RichPresence lastRichPresence;\n+\n+    private int tries;\n+\n+    private boolean enabled;\n+    private boolean waiting;\n+    private boolean connectedBefore;\n+    private boolean connected;\n+    private boolean autoReconnect;\n+\n+    public DiscordRPCThread() {\n+        thread = new Thread(this);\n+        thread.setName(\"DISCORD-RPC-THREAD\");\n+\n+        ipcClient = new IPCClient(DISCORD_APP_CLIENT_ID);\n+        ipcClient.setListener(this);\n+\n+        buffer = new DiscordRPCBuffer();\n+\n+        lastRichPresence = null;\n+\n+        tries = 0;\n+\n+        enabled = false;\n+        waiting = false;\n+        connectedBefore = false;\n+        connected = false;\n+        autoReconnect = false;\n+    }\n+\n+    public void start() {\n+        thread.start();\n+    }\n+\n+    public synchronized void stop() {\n+        synchronized (thread) {\n+            thread.interrupt();\n+        }\n+    }\n+\n+    public synchronized void discover() {\n+        if (enabled && connected) {\n+            return;\n+        }\n+\n+        reset(true);\n+\n+        connectedBefore = true;\n+    }\n+\n+    public synchronized void enable() {\n+        if (enabled) {\n+            return;\n+        }\n+\n+        enabled = true;\n+        autoReconnect = true;\n+\n+        if (waiting && thread.isAlive()) {\n+            synchronized (thread) {\n+                thread.notify();\n+            }\n+        }\n+    }\n+\n+    public synchronized void disable() {\n+        disable(false);\n+    }\n+\n+    public synchronized void disable(boolean keepConnectionAlive) {\n+        if (!enabled) {\n+            return;\n+        }\n+\n+        enabled = false;\n+\n+        reset(!keepConnectionAlive);\n+        if (!keepConnectionAlive) {\n+            autoReconnect = false;\n+        }\n+\n+        if (waiting && thread.isAlive()) {\n+            synchronized (thread) {\n+                thread.notify();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onReady(IPCClient ignored) {\n+        if (connectedBefore) {\n+            logger.info(\"Re-connected to Discord RPC!\");\n+        } else {\n+            logger.info(\"Connected to Discord RPC!\");\n+        }\n+\n+        connectedBefore = true;\n+        connected = true;\n+    }\n+\n+    @Override\n+    public void onDisconnect(IPCClient client, Throwable t) {\n+        connected = false;\n+        logger.info(\"Discord RPC lost connection: Disconnected!\");\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (true) {\n+            logger.info(\"Waiting for auto-connecting...\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNTIxNg=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwODYwNg==", "bodyText": "The Discord client hosts a local IPC server for the applications to connect it.\nWhen the application connects it exchanges information with the server to identify the application.\nAnd then the application can send RPC information every x amount of time to update it.\nThe Discord client decides which application RPC will be shown depends on different factors.\nIf something happens in the Discord servers the only affected side is going to be the Discord client.\nThe Discord Client runs the IPC server when the client starts. And it doesn't stop until the client is being shutdown.\nAnd until that happens it's going to stay listening to application RPCs whether the Discord server is down or not.", "url": "https://github.com/MovingBlocks/Terasology/pull/4271#discussion_r565608606", "createdAt": "2021-01-27T20:23:09Z", "author": {"login": "iHDeveloper"}, "path": "subsystems/DiscordRPC/src/main/java/org/terasology/engine/subsystem/discordrpc/DiscordRPCThread.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem.discordrpc;\n+\n+import com.jagrosh.discordipc.IPCClient;\n+import com.jagrosh.discordipc.IPCListener;\n+import com.jagrosh.discordipc.entities.RichPresence;\n+import com.jagrosh.discordipc.exceptions.NoDiscordClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DiscordRPCThread implements IPCListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(DiscordRPCThread.class);\n+    private static final long DISCORD_APP_CLIENT_ID = 515274721080639504L;\n+    private static final String DISCORD_APP_DEFAULT_IMAGE = \"ss_6\";\n+    private static final int MAX_RECONNECT_TRIES = 5;\n+\n+    private final Thread thread;\n+    private final IPCClient ipcClient;\n+    private final DiscordRPCBuffer buffer;\n+    private RichPresence lastRichPresence;\n+\n+    private int tries;\n+\n+    private boolean enabled;\n+    private boolean waiting;\n+    private boolean connectedBefore;\n+    private boolean connected;\n+    private boolean autoReconnect;\n+\n+    public DiscordRPCThread() {\n+        thread = new Thread(this);\n+        thread.setName(\"DISCORD-RPC-THREAD\");\n+\n+        ipcClient = new IPCClient(DISCORD_APP_CLIENT_ID);\n+        ipcClient.setListener(this);\n+\n+        buffer = new DiscordRPCBuffer();\n+\n+        lastRichPresence = null;\n+\n+        tries = 0;\n+\n+        enabled = false;\n+        waiting = false;\n+        connectedBefore = false;\n+        connected = false;\n+        autoReconnect = false;\n+    }\n+\n+    public void start() {\n+        thread.start();\n+    }\n+\n+    public synchronized void stop() {\n+        synchronized (thread) {\n+            thread.interrupt();\n+        }\n+    }\n+\n+    public synchronized void discover() {\n+        if (enabled && connected) {\n+            return;\n+        }\n+\n+        reset(true);\n+\n+        connectedBefore = true;\n+    }\n+\n+    public synchronized void enable() {\n+        if (enabled) {\n+            return;\n+        }\n+\n+        enabled = true;\n+        autoReconnect = true;\n+\n+        if (waiting && thread.isAlive()) {\n+            synchronized (thread) {\n+                thread.notify();\n+            }\n+        }\n+    }\n+\n+    public synchronized void disable() {\n+        disable(false);\n+    }\n+\n+    public synchronized void disable(boolean keepConnectionAlive) {\n+        if (!enabled) {\n+            return;\n+        }\n+\n+        enabled = false;\n+\n+        reset(!keepConnectionAlive);\n+        if (!keepConnectionAlive) {\n+            autoReconnect = false;\n+        }\n+\n+        if (waiting && thread.isAlive()) {\n+            synchronized (thread) {\n+                thread.notify();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onReady(IPCClient ignored) {\n+        if (connectedBefore) {\n+            logger.info(\"Re-connected to Discord RPC!\");\n+        } else {\n+            logger.info(\"Connected to Discord RPC!\");\n+        }\n+\n+        connectedBefore = true;\n+        connected = true;\n+    }\n+\n+    @Override\n+    public void onDisconnect(IPCClient client, Throwable t) {\n+        connected = false;\n+        logger.info(\"Discord RPC lost connection: Disconnected!\");\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (true) {\n+            logger.info(\"Waiting for auto-connecting...\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYwNTIxNg=="}, "originalCommit": {"oid": "e3b8063267dd0eb608e1f447e8fd18100e4fb5f2"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 278, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}