{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1NzU1MzU1", "number": 4335, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxMDo1ODo0MVrOFMyTWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxMTowNzo1MFrOFMybyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTUxMzg0OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/world/internal/ChunkViewCoreImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxMDo1ODo0MVrOIQsSdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxMDo1ODo0MVrOIQsSdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDM3Mzc1MA==", "bodyText": "Should this be Chunks.toRelative or something like that?", "url": "https://github.com/MovingBlocks/Terasology/pull/4335#discussion_r554373750", "createdAt": "2021-01-09T10:58:41Z", "author": {"login": "skaldarnar"}, "path": "engine/src/main/java/org/terasology/world/internal/ChunkViewCoreImpl.java", "diffHunk": "@@ -107,87 +109,77 @@ public byte getLight(Vector3i pos) {\n \n     @Override\n     public byte getSunlight(int blockX, int blockY, int blockZ) {\n-        if (!blockRegion.encompasses(blockX, blockY, blockZ)) {\n+        if (!blockRegion.contains(blockX, blockY, blockZ)) {\n             return 0;\n         }\n \n         int chunkIndex = relChunkIndex(blockX, blockY, blockZ);\n-        return chunks[chunkIndex].getSunlight(ChunkMath.calcRelativeBlockPos(blockX, blockY, blockZ, chunkFilterSize));\n+        return chunks[chunkIndex].getSunlight(JomlUtil.from(ChunkMath.calcRelativeBlockPos(blockX, blockY, blockZ, chunkFilterSize, new Vector3i())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "345396311095b2840420771d1592a7fbee6b8038"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTUxNTAwOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/world/internal/ChunkViewCoreImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxMDo1OTowMlrOIQsTGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxMDo1OTowMlrOIQsTGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDM3MzkxMw==", "bodyText": "same here?", "url": "https://github.com/MovingBlocks/Terasology/pull/4335#discussion_r554373913", "createdAt": "2021-01-09T10:59:02Z", "author": {"login": "skaldarnar"}, "path": "engine/src/main/java/org/terasology/world/internal/ChunkViewCoreImpl.java", "diffHunk": "@@ -107,87 +109,77 @@ public byte getLight(Vector3i pos) {\n \n     @Override\n     public byte getSunlight(int blockX, int blockY, int blockZ) {\n-        if (!blockRegion.encompasses(blockX, blockY, blockZ)) {\n+        if (!blockRegion.contains(blockX, blockY, blockZ)) {\n             return 0;\n         }\n \n         int chunkIndex = relChunkIndex(blockX, blockY, blockZ);\n-        return chunks[chunkIndex].getSunlight(ChunkMath.calcRelativeBlockPos(blockX, blockY, blockZ, chunkFilterSize));\n+        return chunks[chunkIndex].getSunlight(JomlUtil.from(ChunkMath.calcRelativeBlockPos(blockX, blockY, blockZ, chunkFilterSize, new Vector3i())));\n     }\n \n     @Override\n     public byte getLight(int blockX, int blockY, int blockZ) {\n-        if (!blockRegion.encompasses(blockX, blockY, blockZ)) {\n+        if (!blockRegion.contains(blockX, blockY, blockZ)) {\n             return 0;\n         }\n \n         int chunkIndex = relChunkIndex(blockX, blockY, blockZ);\n-        return chunks[chunkIndex].getLight(ChunkMath.calcRelativeBlockPos(blockX, blockY, blockZ, chunkFilterSize));\n+        return chunks[chunkIndex].getLight(JomlUtil.from(ChunkMath.calcRelativeBlockPos(blockX, blockY, blockZ, chunkFilterSize, new Vector3i())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "345396311095b2840420771d1592a7fbee6b8038"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTUzNTQ3OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/world/internal/ChunkViewCoreImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxMTowNzo1MFrOIQsg2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxMToxMTo1NlrOIQsnBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDM3NzQzNA==", "bodyText": "Isn't this the same as:\nVector3i tmp = new Vector3i();\nBlockRegion expandedRegion = new BlockRegion(region).expand(1, 1, 1);\n\nVector3i minChunk = ChunkMath.calcChunkPos(expandedRegion.getMin(tmp), chunkPower);\nVector3i maxChunk = ChunkMath.calcChunkPos(expandedRegion.getMax(tmp), chunkPower);\nThis might get a bit esoteric here, but I'd love to write something like:\nBlockRegion chunkRegion = region.expand(1, 1, 1).map(corner -> ChunkMath.calcChunkPos(corner, chunkPower);\nAnd is there an alternative to ChunkMath.calcChunkPos(pos, power) in Chunks? I at least don't see one which takes vectors for both arguments when looking at Chunks.toChunkPos.", "url": "https://github.com/MovingBlocks/Terasology/pull/4335#discussion_r554377434", "createdAt": "2021-01-09T11:07:50Z", "author": {"login": "skaldarnar"}, "path": "engine/src/main/java/org/terasology/world/internal/ChunkViewCoreImpl.java", "diffHunk": "@@ -211,24 +203,24 @@ public void setExtraData(int index, int blockX, int blockY, int blockZ, int valu\n     }\n \n     @Override\n-    public void setDirtyAround(Vector3i blockPos) {\n-        for (Vector3i pos : ChunkMath.getChunkRegionAroundWorldPos(blockPos, 1)) {\n-            chunks[pos.x + offset.x + chunkRegion.size().x * (pos.z + offset.z)].setDirty(true);\n+    public void setDirtyAround(Vector3ic blockPos) {\n+        for (Vector3ic pos : ChunkMath.getChunkRegionAroundWorldPos(blockPos, 1)) {\n+            chunks[pos.x() + offset.x + chunkRegion.getSizeX() * (pos.z() + offset.z)].setDirty(true);\n         }\n     }\n \n     @Override\n-    public void setDirtyAround(Region3i region) {\n-        Vector3i minPos = new Vector3i(region.min());\n+    public void setDirtyAround(BlockRegionc region) {\n+        Vector3i minPos = region.getMin(new Vector3i());\n         minPos.sub(1, 1, 1);\n-        Vector3i maxPos = new Vector3i(region.max());\n+        Vector3i maxPos = region.getMax(new Vector3i());\n         maxPos.add(1, 1, 1);\n \n         Vector3i minChunk = ChunkMath.calcChunkPos(minPos, chunkPower);\n         Vector3i maxChunk = ChunkMath.calcChunkPos(maxPos, chunkPower);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "345396311095b2840420771d1592a7fbee6b8038"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDM3OTAxMw==", "bodyText": "On a second look, we introduced toChunkRegion(BlockRegion region, Vector3ic chunkPower, BlockRegion dest), which I guess can (or even should) be used here:\n        BlockRegion expandedRegion = new BlockRegion(region).expand(1, 1, 1);\n        for (Vector3ic pos : Chunks.toChunkRegion(expandedRegion, chunkPower, expandedRegion) {\n            chunks[pos.x() + offset.x + chunkRegion.getSizeX() * (pos.z() + offset.z)].setDirty(true);\n        }", "url": "https://github.com/MovingBlocks/Terasology/pull/4335#discussion_r554379013", "createdAt": "2021-01-09T11:11:56Z", "author": {"login": "skaldarnar"}, "path": "engine/src/main/java/org/terasology/world/internal/ChunkViewCoreImpl.java", "diffHunk": "@@ -211,24 +203,24 @@ public void setExtraData(int index, int blockX, int blockY, int blockZ, int valu\n     }\n \n     @Override\n-    public void setDirtyAround(Vector3i blockPos) {\n-        for (Vector3i pos : ChunkMath.getChunkRegionAroundWorldPos(blockPos, 1)) {\n-            chunks[pos.x + offset.x + chunkRegion.size().x * (pos.z + offset.z)].setDirty(true);\n+    public void setDirtyAround(Vector3ic blockPos) {\n+        for (Vector3ic pos : ChunkMath.getChunkRegionAroundWorldPos(blockPos, 1)) {\n+            chunks[pos.x() + offset.x + chunkRegion.getSizeX() * (pos.z() + offset.z)].setDirty(true);\n         }\n     }\n \n     @Override\n-    public void setDirtyAround(Region3i region) {\n-        Vector3i minPos = new Vector3i(region.min());\n+    public void setDirtyAround(BlockRegionc region) {\n+        Vector3i minPos = region.getMin(new Vector3i());\n         minPos.sub(1, 1, 1);\n-        Vector3i maxPos = new Vector3i(region.max());\n+        Vector3i maxPos = region.getMax(new Vector3i());\n         maxPos.add(1, 1, 1);\n \n         Vector3i minChunk = ChunkMath.calcChunkPos(minPos, chunkPower);\n         Vector3i maxChunk = ChunkMath.calcChunkPos(maxPos, chunkPower);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDM3NzQzNA=="}, "originalCommit": {"oid": "345396311095b2840420771d1592a7fbee6b8038"}, "originalPosition": 220}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 202, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}