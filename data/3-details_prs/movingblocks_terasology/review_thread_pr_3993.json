{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzNDM1MzM5", "number": 3993, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDozMjowNVrOD_1mRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzo0Mjo0M1rOD_-NFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjY1MDMxOnYy", "diffSide": "LEFT", "path": "buildSrc/src/main/kotlin/terasology-module.gradle.kts", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDozMjowNVrOGavRqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDozMjowNVrOGavRqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5MDczMQ==", "bodyText": "Oh, so there is one feature I didn't preserve. The extra styling on the please remove -SNAPSHOT message. I was afraid it was using some groovy-specific formatter or something.\nIn hindsight, it looks like it's probably not groovy-specific? So I guess I probably could put it back.\nOn the other hand, it is importing from an .internal package.", "url": "https://github.com/MovingBlocks/Terasology/pull/3993#discussion_r430690731", "createdAt": "2020-05-26T20:32:05Z", "author": {"login": "keturn"}, "path": "buildSrc/src/main/kotlin/terasology-module.gradle.kts", "diffHunk": "@@ -16,89 +16,69 @@\n \n // Simple build file for modules - the one under the Core module is the template, will be copied as needed to modules\n \n-// Dependencies needed for what our Gradle scripts themselves use. It cannot be included via an external Gradle file :-(\n-buildscript {\n-    repositories {\n-        // External libs - jcenter is Bintray and is supposed to be a superset of Maven Central, but do both just in case\n-        jcenter()\n-        mavenCentral()\n-        gradlePluginPortal()\n-    }\n-\n-    dependencies {\n-        // Needed for caching reflected data during builds\n-        classpath(\"org.reflections:reflections:0.9.10\")\n-        classpath(\"dom4j:dom4j:1.6.1\")\n-\n-        //Spotbugs\n-        classpath(\"gradle.plugin.com.github.spotbugs.snom:spotbugs-gradle-plugin:4.0.0\")\n-\n-        // SonarQube / Cloud scanning\n-        classpath(\"org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.8\")\n-    }\n-}\n-\n import groovy.json.JsonSlurper\n+import org.gradle.plugins.ide.eclipse.model.EclipseModel\n+import org.gradle.plugins.ide.idea.model.IdeaModel\n import org.reflections.Reflections\n-import org.reflections.util.FilterBuilder\n import org.reflections.scanners.SubTypesScanner\n import org.reflections.scanners.TypeAnnotationsScanner\n import org.reflections.util.ConfigurationBuilder\n+import org.reflections.util.FilterBuilder\n+\n \n-ext {\n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n-\n-    // This is a fun one ... when versions switched to dynamic -SNAPSHOT or not based on branch existing modules using `master` would suddenly try publishing releases\n-    // This won't work without additionally doing constant version bumps (perhaps via Git tags) - but too much work to switch around all modules at once\n-    // Complicating things more the use of publish.gradle to centralize logic means modules and engine bits are treated the same, yet we need to vary modules\n-    // Temporary workaround: default modules to bypass release management: master branch builds will still make snapshot builds for the snapshot repo\n-    // If a module actually wants release management simply include `\"isReleaseManaged\" : true` in module.txt - this is needed for the engine repo embedded modules\n-    // One option would be to slowly convert modulespace to default to a `develop` + `master` setup living in harmony with associated automation/github tweaks\n-    // Alternatively one more round of refactoring could switch to Git tags, a single `master` branch, and possible other things to help match snaps/PR builds somehow?\n-    bypassModuleReleaseManagement = \"true\"\n+plugins {\n+    id(\"java\")\n+    id(\"idea\")\n+    id(\"eclipse\")\n }\n \n-def moduleDepends = [];\n-def moduleFile = file(\"module.txt\")\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env by extra { System.getenv( )}\n+// This is a fun one ... when versions switched to dynamic -SNAPSHOT or not based on branch existing modules using `master` would suddenly try publishing releases\n+// This won't work without additionally doing constant version bumps (perhaps via Git tags) - but too much work to switch around all modules at once\n+// Complicating things more the use of publish.gradle to centralize logic means modules and engine bits are treated the same, yet we need to vary modules\n+// Temporary workaround: default modules to bypass release management: master branch builds will still make snapshot builds for the snapshot repo\n+// If a module actually wants release management simply include `\"isReleaseManaged\" : true` in module.txt - this is needed for the engine repo embedded modules\n+// One option would be to slowly convert modulespace to default to a `develop` + `master` setup living in harmony with associated automation/github tweaks\n+// Alternatively one more round of refactoring could switch to Git tags, a single `master` branch, and possible other things to help match snaps/PR builds somehow?\n+val bypassModuleReleaseManagement by extra(\"true\")\n+\n+val moduleDepends = mutableListOf<String>()\n+val moduleFile = file(\"module.txt\")\n \n // The module file should always exist if the module was correctly created or cloned using Gradle\n if (!moduleFile.exists()) {\n     println(\"Y U NO EXIST MODULE.TXT!\")\n-    throw new GradleException(\"Failed to find module.txt for \" + project.name)\n+    throw GradleException(\"Failed to find module.txt for \" + project.name)\n }\n \n //println \"Scanning for dependencies in module.txt for \" + project.name\n-def slurper = new JsonSlurper()\n-def moduleConfig = slurper.parseText(moduleFile.text)\n-for (dependency in moduleConfig.dependencies) {\n-    if (dependency.id != \"engine\") {\n-        moduleDepends += dependency.id\n+val slurper = JsonSlurper()  // \ud83d\ude02 using groovy's json parser in kotlin\n+val moduleConfig: Map<String, Any> = slurper.parseText(moduleFile.readText())!! as Map<String, Any>\n+for (dependency in moduleConfig[\"dependencies\"] as List<Map<String, String>>) {\n+    if (dependency[\"id\"] != \"engine\") {\n+        moduleDepends.add(dependency[\"id\"]!!)\n     }\n }\n \n // Gradle uses the magic version variable when creating the jar name (unless explicitly set somewhere else I guess)\n-version = moduleConfig.version\n-\n-import org.gradle.internal.logging.text.StyledTextOutputFactory\n-import static org.gradle.internal.logging.text.StyledTextOutput.Style\n+version = moduleConfig[\"version\"] as String\n \n // Check for an outright -SNAPSHOT in the loaded version - for ease of use we want to get rid of that everywhere, so warn about it and remove for the variable\n-def undesiredSnapshotTag = version.endsWith(\"-SNAPSHOT\")\n+val undesiredSnapshotTag = version.toString().endsWith(\"-SNAPSHOT\")\n if (undesiredSnapshotTag) {\n     println(\"Taking off undesired -SNAPSHOT\")\n-    version -= \"-SNAPSHOT\"\n-    def out = services.get(StyledTextOutputFactory).create(\"an-ouput\")\n-    out.withStyle(Style.FailureHeader).println(\"WARNING: Module \" + project.name + \" is explicitly versioned as a snapshot in module.txt, please remove '-SNAPSHOT'\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a352a72c887e16077f95b91c6f56937b06c4b90"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDA2MDM5OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/kotlin/terasology-module.gradle.kts", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzo0Mjo0M1rOGa9LlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNDoyNDoyMFrOGbMsbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxODU0OA==", "bodyText": "you have extra quotes :D", "url": "https://github.com/MovingBlocks/Terasology/pull/3993#discussion_r430918548", "createdAt": "2020-05-27T07:42:43Z", "author": {"login": "DarkWeird"}, "path": "buildSrc/src/main/kotlin/terasology-module.gradle.kts", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// Simple build file for modules - the one under the Core module is the template, will be copied as needed to modules\n+\n+import groovy.json.JsonSlurper\n+import org.gradle.plugins.ide.eclipse.model.EclipseModel\n+import org.gradle.plugins.ide.idea.model.IdeaModel\n+import org.reflections.Reflections\n+import org.reflections.scanners.SubTypesScanner\n+import org.reflections.scanners.TypeAnnotationsScanner\n+import org.reflections.util.ConfigurationBuilder\n+import org.reflections.util.FilterBuilder\n+\n+\n+plugins {\n+    id(\"java\")\n+    id(\"idea\")\n+    id(\"eclipse\")\n+}\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env by extra { System.getenv( )}\n+// This is a fun one ... when versions switched to dynamic -SNAPSHOT or not based on branch existing modules using `master` would suddenly try publishing releases\n+// This won't work without additionally doing constant version bumps (perhaps via Git tags) - but too much work to switch around all modules at once\n+// Complicating things more the use of publish.gradle to centralize logic means modules and engine bits are treated the same, yet we need to vary modules\n+// Temporary workaround: default modules to bypass release management: master branch builds will still make snapshot builds for the snapshot repo\n+// If a module actually wants release management simply include `\"isReleaseManaged\" : true` in module.txt - this is needed for the engine repo embedded modules\n+// One option would be to slowly convert modulespace to default to a `develop` + `master` setup living in harmony with associated automation/github tweaks\n+// Alternatively one more round of refactoring could switch to Git tags, a single `master` branch, and possible other things to help match snaps/PR builds somehow?\n+val bypassModuleReleaseManagement by extra(\"true\")\n+\n+val moduleDepends = mutableListOf<String>()\n+val moduleFile = file(\"module.txt\")\n+\n+// The module file should always exist if the module was correctly created or cloned using Gradle\n+if (!moduleFile.exists()) {\n+    println(\"Y U NO EXIST MODULE.TXT!\")\n+    throw GradleException(\"Failed to find module.txt for \" + project.name)\n+}\n+\n+//println \"Scanning for dependencies in module.txt for \" + project.name\n+val slurper = JsonSlurper()  // \ud83d\ude02 using groovy's json parser in kotlin\n+val moduleConfig: Map<String, Any> = slurper.parseText(moduleFile.readText())!! as Map<String, Any>\n+for (dependency in moduleConfig[\"dependencies\"] as List<Map<String, String>>) {\n+    if (dependency[\"id\"] != \"engine\") {\n+        moduleDepends.add(dependency[\"id\"]!!)\n+    }\n+}\n+\n+// Gradle uses the magic version variable when creating the jar name (unless explicitly set somewhere else I guess)\n+version = moduleConfig[\"version\"] as String\n+\n+// Check for an outright -SNAPSHOT in the loaded version - for ease of use we want to get rid of that everywhere, so warn about it and remove for the variable\n+val undesiredSnapshotTag = version.toString().endsWith(\"-SNAPSHOT\")\n+if (undesiredSnapshotTag) {\n+    println(\"Taking off undesired -SNAPSHOT\")\n+    version = version.toString().removeSuffix(\"-SNAPSHOT\")\n+    println(\"WARNING: Module ${project.name} is explicitly versioned as a snapshot in module.txt, please remove '-SNAPSHOT'\")\n+}\n+\n+// The only case in which we make module non-snapshots is if release management is enabled and BRANCH_NAME is \"master\"\n+if (moduleConfig[\"isReleaseManaged\"].toString().toBoolean() && env[\"BRANCH_NAME\"] == \"master\") {\n+    // This is mildly awkward since we need to bypass by default, yet if release management is on (true) then we set the bypass to false ..\n+    val bypassModuleReleaseManagement by extra(false)\n+} else {\n+    // In the case where we actually are building a snapshot we load -SNAPSHOT into the version variable, even if it wasn't there in module.txt\n+    version = \"${version}-SNAPSHOT\"\n+}\n+\n+// Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n+group = \"org.terasology.modules\"\n+\n+println(\"Version for $project.name loaded as $version for group $group\")\n+\n+// Grab all the common stuff like plugins to use, artifact repositories, code analysis config, Artifactory settings, Git magic\n+// Note that this statement is down a ways because it is affected by the stuff higher in this file like setting versioning\n+apply(from = \"$rootDir/config/gradle/publish.gradle\")\n+\n+// Handle some logic related to where what is\n+configure<SourceSetContainer> {\n+    named(\"main\") {\n+        java.outputDir = File(\"$buildDir/classes\")\n+    }\n+    named(\"test\") {\n+        java.outputDir = File(\"$buildDir/testClasses\")\n+    }\n+}\n+val convention = project.getConvention().getPlugin(JavaPluginConvention::class)\n+val mainSourceSet = convention.getSourceSets().getByName(\"main\");\n+\n+// TODO: Remove when we don't need to rely on snapshots. Needed here for solo builds in Jenkins\n+configurations.all {\n+    resolutionStrategy.cacheChangingModulesFor(0, \"seconds\")\n+}\n+\n+// Set dependencies. Note that the dependency information from module.txt is used for other Terasology modules\n+dependencies {\n+    // Check to see if this module is not the root Gradle project - if so we are in a multi-project workspace\n+    \"implementation\"(group = \"org.terasology.engine\", name = \"engine\", version = \"+\") { isChanging = true }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2f00d0c7cad9beca3a1cb28acb902729937d2dd"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTEyMDU1NQ==", "bodyText": "Cerv asked about that too. I tried taking them out, and gradle seems just fine with that, but IDEA's gradle sync broke on me at that point. \ud83d\ude1e  I asked about it on the gradle forum, I'll report back if I hear anything.", "url": "https://github.com/MovingBlocks/Terasology/pull/3993#discussion_r431120555", "createdAt": "2020-05-27T13:17:35Z", "author": {"login": "keturn"}, "path": "buildSrc/src/main/kotlin/terasology-module.gradle.kts", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// Simple build file for modules - the one under the Core module is the template, will be copied as needed to modules\n+\n+import groovy.json.JsonSlurper\n+import org.gradle.plugins.ide.eclipse.model.EclipseModel\n+import org.gradle.plugins.ide.idea.model.IdeaModel\n+import org.reflections.Reflections\n+import org.reflections.scanners.SubTypesScanner\n+import org.reflections.scanners.TypeAnnotationsScanner\n+import org.reflections.util.ConfigurationBuilder\n+import org.reflections.util.FilterBuilder\n+\n+\n+plugins {\n+    id(\"java\")\n+    id(\"idea\")\n+    id(\"eclipse\")\n+}\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env by extra { System.getenv( )}\n+// This is a fun one ... when versions switched to dynamic -SNAPSHOT or not based on branch existing modules using `master` would suddenly try publishing releases\n+// This won't work without additionally doing constant version bumps (perhaps via Git tags) - but too much work to switch around all modules at once\n+// Complicating things more the use of publish.gradle to centralize logic means modules and engine bits are treated the same, yet we need to vary modules\n+// Temporary workaround: default modules to bypass release management: master branch builds will still make snapshot builds for the snapshot repo\n+// If a module actually wants release management simply include `\"isReleaseManaged\" : true` in module.txt - this is needed for the engine repo embedded modules\n+// One option would be to slowly convert modulespace to default to a `develop` + `master` setup living in harmony with associated automation/github tweaks\n+// Alternatively one more round of refactoring could switch to Git tags, a single `master` branch, and possible other things to help match snaps/PR builds somehow?\n+val bypassModuleReleaseManagement by extra(\"true\")\n+\n+val moduleDepends = mutableListOf<String>()\n+val moduleFile = file(\"module.txt\")\n+\n+// The module file should always exist if the module was correctly created or cloned using Gradle\n+if (!moduleFile.exists()) {\n+    println(\"Y U NO EXIST MODULE.TXT!\")\n+    throw GradleException(\"Failed to find module.txt for \" + project.name)\n+}\n+\n+//println \"Scanning for dependencies in module.txt for \" + project.name\n+val slurper = JsonSlurper()  // \ud83d\ude02 using groovy's json parser in kotlin\n+val moduleConfig: Map<String, Any> = slurper.parseText(moduleFile.readText())!! as Map<String, Any>\n+for (dependency in moduleConfig[\"dependencies\"] as List<Map<String, String>>) {\n+    if (dependency[\"id\"] != \"engine\") {\n+        moduleDepends.add(dependency[\"id\"]!!)\n+    }\n+}\n+\n+// Gradle uses the magic version variable when creating the jar name (unless explicitly set somewhere else I guess)\n+version = moduleConfig[\"version\"] as String\n+\n+// Check for an outright -SNAPSHOT in the loaded version - for ease of use we want to get rid of that everywhere, so warn about it and remove for the variable\n+val undesiredSnapshotTag = version.toString().endsWith(\"-SNAPSHOT\")\n+if (undesiredSnapshotTag) {\n+    println(\"Taking off undesired -SNAPSHOT\")\n+    version = version.toString().removeSuffix(\"-SNAPSHOT\")\n+    println(\"WARNING: Module ${project.name} is explicitly versioned as a snapshot in module.txt, please remove '-SNAPSHOT'\")\n+}\n+\n+// The only case in which we make module non-snapshots is if release management is enabled and BRANCH_NAME is \"master\"\n+if (moduleConfig[\"isReleaseManaged\"].toString().toBoolean() && env[\"BRANCH_NAME\"] == \"master\") {\n+    // This is mildly awkward since we need to bypass by default, yet if release management is on (true) then we set the bypass to false ..\n+    val bypassModuleReleaseManagement by extra(false)\n+} else {\n+    // In the case where we actually are building a snapshot we load -SNAPSHOT into the version variable, even if it wasn't there in module.txt\n+    version = \"${version}-SNAPSHOT\"\n+}\n+\n+// Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n+group = \"org.terasology.modules\"\n+\n+println(\"Version for $project.name loaded as $version for group $group\")\n+\n+// Grab all the common stuff like plugins to use, artifact repositories, code analysis config, Artifactory settings, Git magic\n+// Note that this statement is down a ways because it is affected by the stuff higher in this file like setting versioning\n+apply(from = \"$rootDir/config/gradle/publish.gradle\")\n+\n+// Handle some logic related to where what is\n+configure<SourceSetContainer> {\n+    named(\"main\") {\n+        java.outputDir = File(\"$buildDir/classes\")\n+    }\n+    named(\"test\") {\n+        java.outputDir = File(\"$buildDir/testClasses\")\n+    }\n+}\n+val convention = project.getConvention().getPlugin(JavaPluginConvention::class)\n+val mainSourceSet = convention.getSourceSets().getByName(\"main\");\n+\n+// TODO: Remove when we don't need to rely on snapshots. Needed here for solo builds in Jenkins\n+configurations.all {\n+    resolutionStrategy.cacheChangingModulesFor(0, \"seconds\")\n+}\n+\n+// Set dependencies. Note that the dependency information from module.txt is used for other Terasology modules\n+dependencies {\n+    // Check to see if this module is not the root Gradle project - if so we are in a multi-project workspace\n+    \"implementation\"(group = \"org.terasology.engine\", name = \"engine\", version = \"+\") { isChanging = true }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxODU0OA=="}, "originalCommit": {"oid": "b2f00d0c7cad9beca3a1cb28acb902729937d2dd"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTEzNjA3NA==", "bodyText": "hmm. It is worked for me :/", "url": "https://github.com/MovingBlocks/Terasology/pull/3993#discussion_r431136074", "createdAt": "2020-05-27T13:36:24Z", "author": {"login": "DarkWeird"}, "path": "buildSrc/src/main/kotlin/terasology-module.gradle.kts", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// Simple build file for modules - the one under the Core module is the template, will be copied as needed to modules\n+\n+import groovy.json.JsonSlurper\n+import org.gradle.plugins.ide.eclipse.model.EclipseModel\n+import org.gradle.plugins.ide.idea.model.IdeaModel\n+import org.reflections.Reflections\n+import org.reflections.scanners.SubTypesScanner\n+import org.reflections.scanners.TypeAnnotationsScanner\n+import org.reflections.util.ConfigurationBuilder\n+import org.reflections.util.FilterBuilder\n+\n+\n+plugins {\n+    id(\"java\")\n+    id(\"idea\")\n+    id(\"eclipse\")\n+}\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env by extra { System.getenv( )}\n+// This is a fun one ... when versions switched to dynamic -SNAPSHOT or not based on branch existing modules using `master` would suddenly try publishing releases\n+// This won't work without additionally doing constant version bumps (perhaps via Git tags) - but too much work to switch around all modules at once\n+// Complicating things more the use of publish.gradle to centralize logic means modules and engine bits are treated the same, yet we need to vary modules\n+// Temporary workaround: default modules to bypass release management: master branch builds will still make snapshot builds for the snapshot repo\n+// If a module actually wants release management simply include `\"isReleaseManaged\" : true` in module.txt - this is needed for the engine repo embedded modules\n+// One option would be to slowly convert modulespace to default to a `develop` + `master` setup living in harmony with associated automation/github tweaks\n+// Alternatively one more round of refactoring could switch to Git tags, a single `master` branch, and possible other things to help match snaps/PR builds somehow?\n+val bypassModuleReleaseManagement by extra(\"true\")\n+\n+val moduleDepends = mutableListOf<String>()\n+val moduleFile = file(\"module.txt\")\n+\n+// The module file should always exist if the module was correctly created or cloned using Gradle\n+if (!moduleFile.exists()) {\n+    println(\"Y U NO EXIST MODULE.TXT!\")\n+    throw GradleException(\"Failed to find module.txt for \" + project.name)\n+}\n+\n+//println \"Scanning for dependencies in module.txt for \" + project.name\n+val slurper = JsonSlurper()  // \ud83d\ude02 using groovy's json parser in kotlin\n+val moduleConfig: Map<String, Any> = slurper.parseText(moduleFile.readText())!! as Map<String, Any>\n+for (dependency in moduleConfig[\"dependencies\"] as List<Map<String, String>>) {\n+    if (dependency[\"id\"] != \"engine\") {\n+        moduleDepends.add(dependency[\"id\"]!!)\n+    }\n+}\n+\n+// Gradle uses the magic version variable when creating the jar name (unless explicitly set somewhere else I guess)\n+version = moduleConfig[\"version\"] as String\n+\n+// Check for an outright -SNAPSHOT in the loaded version - for ease of use we want to get rid of that everywhere, so warn about it and remove for the variable\n+val undesiredSnapshotTag = version.toString().endsWith(\"-SNAPSHOT\")\n+if (undesiredSnapshotTag) {\n+    println(\"Taking off undesired -SNAPSHOT\")\n+    version = version.toString().removeSuffix(\"-SNAPSHOT\")\n+    println(\"WARNING: Module ${project.name} is explicitly versioned as a snapshot in module.txt, please remove '-SNAPSHOT'\")\n+}\n+\n+// The only case in which we make module non-snapshots is if release management is enabled and BRANCH_NAME is \"master\"\n+if (moduleConfig[\"isReleaseManaged\"].toString().toBoolean() && env[\"BRANCH_NAME\"] == \"master\") {\n+    // This is mildly awkward since we need to bypass by default, yet if release management is on (true) then we set the bypass to false ..\n+    val bypassModuleReleaseManagement by extra(false)\n+} else {\n+    // In the case where we actually are building a snapshot we load -SNAPSHOT into the version variable, even if it wasn't there in module.txt\n+    version = \"${version}-SNAPSHOT\"\n+}\n+\n+// Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n+group = \"org.terasology.modules\"\n+\n+println(\"Version for $project.name loaded as $version for group $group\")\n+\n+// Grab all the common stuff like plugins to use, artifact repositories, code analysis config, Artifactory settings, Git magic\n+// Note that this statement is down a ways because it is affected by the stuff higher in this file like setting versioning\n+apply(from = \"$rootDir/config/gradle/publish.gradle\")\n+\n+// Handle some logic related to where what is\n+configure<SourceSetContainer> {\n+    named(\"main\") {\n+        java.outputDir = File(\"$buildDir/classes\")\n+    }\n+    named(\"test\") {\n+        java.outputDir = File(\"$buildDir/testClasses\")\n+    }\n+}\n+val convention = project.getConvention().getPlugin(JavaPluginConvention::class)\n+val mainSourceSet = convention.getSourceSets().getByName(\"main\");\n+\n+// TODO: Remove when we don't need to rely on snapshots. Needed here for solo builds in Jenkins\n+configurations.all {\n+    resolutionStrategy.cacheChangingModulesFor(0, \"seconds\")\n+}\n+\n+// Set dependencies. Note that the dependency information from module.txt is used for other Terasology modules\n+dependencies {\n+    // Check to see if this module is not the root Gradle project - if so we are in a multi-project workspace\n+    \"implementation\"(group = \"org.terasology.engine\", name = \"engine\", version = \"+\") { isChanging = true }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxODU0OA=="}, "originalCommit": {"oid": "b2f00d0c7cad9beca3a1cb28acb902729937d2dd"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE2ODg3Nw==", "bodyText": "Oh, that's good to know.\nI hit \"Invalidate Caches and Restart\" and after a rebuild and a bit that part works here too. \ud83d\udc4d", "url": "https://github.com/MovingBlocks/Terasology/pull/3993#discussion_r431168877", "createdAt": "2020-05-27T14:19:30Z", "author": {"login": "keturn"}, "path": "buildSrc/src/main/kotlin/terasology-module.gradle.kts", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// Simple build file for modules - the one under the Core module is the template, will be copied as needed to modules\n+\n+import groovy.json.JsonSlurper\n+import org.gradle.plugins.ide.eclipse.model.EclipseModel\n+import org.gradle.plugins.ide.idea.model.IdeaModel\n+import org.reflections.Reflections\n+import org.reflections.scanners.SubTypesScanner\n+import org.reflections.scanners.TypeAnnotationsScanner\n+import org.reflections.util.ConfigurationBuilder\n+import org.reflections.util.FilterBuilder\n+\n+\n+plugins {\n+    id(\"java\")\n+    id(\"idea\")\n+    id(\"eclipse\")\n+}\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env by extra { System.getenv( )}\n+// This is a fun one ... when versions switched to dynamic -SNAPSHOT or not based on branch existing modules using `master` would suddenly try publishing releases\n+// This won't work without additionally doing constant version bumps (perhaps via Git tags) - but too much work to switch around all modules at once\n+// Complicating things more the use of publish.gradle to centralize logic means modules and engine bits are treated the same, yet we need to vary modules\n+// Temporary workaround: default modules to bypass release management: master branch builds will still make snapshot builds for the snapshot repo\n+// If a module actually wants release management simply include `\"isReleaseManaged\" : true` in module.txt - this is needed for the engine repo embedded modules\n+// One option would be to slowly convert modulespace to default to a `develop` + `master` setup living in harmony with associated automation/github tweaks\n+// Alternatively one more round of refactoring could switch to Git tags, a single `master` branch, and possible other things to help match snaps/PR builds somehow?\n+val bypassModuleReleaseManagement by extra(\"true\")\n+\n+val moduleDepends = mutableListOf<String>()\n+val moduleFile = file(\"module.txt\")\n+\n+// The module file should always exist if the module was correctly created or cloned using Gradle\n+if (!moduleFile.exists()) {\n+    println(\"Y U NO EXIST MODULE.TXT!\")\n+    throw GradleException(\"Failed to find module.txt for \" + project.name)\n+}\n+\n+//println \"Scanning for dependencies in module.txt for \" + project.name\n+val slurper = JsonSlurper()  // \ud83d\ude02 using groovy's json parser in kotlin\n+val moduleConfig: Map<String, Any> = slurper.parseText(moduleFile.readText())!! as Map<String, Any>\n+for (dependency in moduleConfig[\"dependencies\"] as List<Map<String, String>>) {\n+    if (dependency[\"id\"] != \"engine\") {\n+        moduleDepends.add(dependency[\"id\"]!!)\n+    }\n+}\n+\n+// Gradle uses the magic version variable when creating the jar name (unless explicitly set somewhere else I guess)\n+version = moduleConfig[\"version\"] as String\n+\n+// Check for an outright -SNAPSHOT in the loaded version - for ease of use we want to get rid of that everywhere, so warn about it and remove for the variable\n+val undesiredSnapshotTag = version.toString().endsWith(\"-SNAPSHOT\")\n+if (undesiredSnapshotTag) {\n+    println(\"Taking off undesired -SNAPSHOT\")\n+    version = version.toString().removeSuffix(\"-SNAPSHOT\")\n+    println(\"WARNING: Module ${project.name} is explicitly versioned as a snapshot in module.txt, please remove '-SNAPSHOT'\")\n+}\n+\n+// The only case in which we make module non-snapshots is if release management is enabled and BRANCH_NAME is \"master\"\n+if (moduleConfig[\"isReleaseManaged\"].toString().toBoolean() && env[\"BRANCH_NAME\"] == \"master\") {\n+    // This is mildly awkward since we need to bypass by default, yet if release management is on (true) then we set the bypass to false ..\n+    val bypassModuleReleaseManagement by extra(false)\n+} else {\n+    // In the case where we actually are building a snapshot we load -SNAPSHOT into the version variable, even if it wasn't there in module.txt\n+    version = \"${version}-SNAPSHOT\"\n+}\n+\n+// Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n+group = \"org.terasology.modules\"\n+\n+println(\"Version for $project.name loaded as $version for group $group\")\n+\n+// Grab all the common stuff like plugins to use, artifact repositories, code analysis config, Artifactory settings, Git magic\n+// Note that this statement is down a ways because it is affected by the stuff higher in this file like setting versioning\n+apply(from = \"$rootDir/config/gradle/publish.gradle\")\n+\n+// Handle some logic related to where what is\n+configure<SourceSetContainer> {\n+    named(\"main\") {\n+        java.outputDir = File(\"$buildDir/classes\")\n+    }\n+    named(\"test\") {\n+        java.outputDir = File(\"$buildDir/testClasses\")\n+    }\n+}\n+val convention = project.getConvention().getPlugin(JavaPluginConvention::class)\n+val mainSourceSet = convention.getSourceSets().getByName(\"main\");\n+\n+// TODO: Remove when we don't need to rely on snapshots. Needed here for solo builds in Jenkins\n+configurations.all {\n+    resolutionStrategy.cacheChangingModulesFor(0, \"seconds\")\n+}\n+\n+// Set dependencies. Note that the dependency information from module.txt is used for other Terasology modules\n+dependencies {\n+    // Check to see if this module is not the root Gradle project - if so we are in a multi-project workspace\n+    \"implementation\"(group = \"org.terasology.engine\", name = \"engine\", version = \"+\") { isChanging = true }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxODU0OA=="}, "originalCommit": {"oid": "b2f00d0c7cad9beca3a1cb28acb902729937d2dd"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3MjcxNw==", "bodyText": "We need hit this button often, after .idea PR :(", "url": "https://github.com/MovingBlocks/Terasology/pull/3993#discussion_r431172717", "createdAt": "2020-05-27T14:24:20Z", "author": {"login": "DarkWeird"}, "path": "buildSrc/src/main/kotlin/terasology-module.gradle.kts", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// Simple build file for modules - the one under the Core module is the template, will be copied as needed to modules\n+\n+import groovy.json.JsonSlurper\n+import org.gradle.plugins.ide.eclipse.model.EclipseModel\n+import org.gradle.plugins.ide.idea.model.IdeaModel\n+import org.reflections.Reflections\n+import org.reflections.scanners.SubTypesScanner\n+import org.reflections.scanners.TypeAnnotationsScanner\n+import org.reflections.util.ConfigurationBuilder\n+import org.reflections.util.FilterBuilder\n+\n+\n+plugins {\n+    id(\"java\")\n+    id(\"idea\")\n+    id(\"eclipse\")\n+}\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env by extra { System.getenv( )}\n+// This is a fun one ... when versions switched to dynamic -SNAPSHOT or not based on branch existing modules using `master` would suddenly try publishing releases\n+// This won't work without additionally doing constant version bumps (perhaps via Git tags) - but too much work to switch around all modules at once\n+// Complicating things more the use of publish.gradle to centralize logic means modules and engine bits are treated the same, yet we need to vary modules\n+// Temporary workaround: default modules to bypass release management: master branch builds will still make snapshot builds for the snapshot repo\n+// If a module actually wants release management simply include `\"isReleaseManaged\" : true` in module.txt - this is needed for the engine repo embedded modules\n+// One option would be to slowly convert modulespace to default to a `develop` + `master` setup living in harmony with associated automation/github tweaks\n+// Alternatively one more round of refactoring could switch to Git tags, a single `master` branch, and possible other things to help match snaps/PR builds somehow?\n+val bypassModuleReleaseManagement by extra(\"true\")\n+\n+val moduleDepends = mutableListOf<String>()\n+val moduleFile = file(\"module.txt\")\n+\n+// The module file should always exist if the module was correctly created or cloned using Gradle\n+if (!moduleFile.exists()) {\n+    println(\"Y U NO EXIST MODULE.TXT!\")\n+    throw GradleException(\"Failed to find module.txt for \" + project.name)\n+}\n+\n+//println \"Scanning for dependencies in module.txt for \" + project.name\n+val slurper = JsonSlurper()  // \ud83d\ude02 using groovy's json parser in kotlin\n+val moduleConfig: Map<String, Any> = slurper.parseText(moduleFile.readText())!! as Map<String, Any>\n+for (dependency in moduleConfig[\"dependencies\"] as List<Map<String, String>>) {\n+    if (dependency[\"id\"] != \"engine\") {\n+        moduleDepends.add(dependency[\"id\"]!!)\n+    }\n+}\n+\n+// Gradle uses the magic version variable when creating the jar name (unless explicitly set somewhere else I guess)\n+version = moduleConfig[\"version\"] as String\n+\n+// Check for an outright -SNAPSHOT in the loaded version - for ease of use we want to get rid of that everywhere, so warn about it and remove for the variable\n+val undesiredSnapshotTag = version.toString().endsWith(\"-SNAPSHOT\")\n+if (undesiredSnapshotTag) {\n+    println(\"Taking off undesired -SNAPSHOT\")\n+    version = version.toString().removeSuffix(\"-SNAPSHOT\")\n+    println(\"WARNING: Module ${project.name} is explicitly versioned as a snapshot in module.txt, please remove '-SNAPSHOT'\")\n+}\n+\n+// The only case in which we make module non-snapshots is if release management is enabled and BRANCH_NAME is \"master\"\n+if (moduleConfig[\"isReleaseManaged\"].toString().toBoolean() && env[\"BRANCH_NAME\"] == \"master\") {\n+    // This is mildly awkward since we need to bypass by default, yet if release management is on (true) then we set the bypass to false ..\n+    val bypassModuleReleaseManagement by extra(false)\n+} else {\n+    // In the case where we actually are building a snapshot we load -SNAPSHOT into the version variable, even if it wasn't there in module.txt\n+    version = \"${version}-SNAPSHOT\"\n+}\n+\n+// Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n+group = \"org.terasology.modules\"\n+\n+println(\"Version for $project.name loaded as $version for group $group\")\n+\n+// Grab all the common stuff like plugins to use, artifact repositories, code analysis config, Artifactory settings, Git magic\n+// Note that this statement is down a ways because it is affected by the stuff higher in this file like setting versioning\n+apply(from = \"$rootDir/config/gradle/publish.gradle\")\n+\n+// Handle some logic related to where what is\n+configure<SourceSetContainer> {\n+    named(\"main\") {\n+        java.outputDir = File(\"$buildDir/classes\")\n+    }\n+    named(\"test\") {\n+        java.outputDir = File(\"$buildDir/testClasses\")\n+    }\n+}\n+val convention = project.getConvention().getPlugin(JavaPluginConvention::class)\n+val mainSourceSet = convention.getSourceSets().getByName(\"main\");\n+\n+// TODO: Remove when we don't need to rely on snapshots. Needed here for solo builds in Jenkins\n+configurations.all {\n+    resolutionStrategy.cacheChangingModulesFor(0, \"seconds\")\n+}\n+\n+// Set dependencies. Note that the dependency information from module.txt is used for other Terasology modules\n+dependencies {\n+    // Check to see if this module is not the root Gradle project - if so we are in a multi-project workspace\n+    \"implementation\"(group = \"org.terasology.engine\", name = \"engine\", version = \"+\") { isChanging = true }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxODU0OA=="}, "originalCommit": {"oid": "b2f00d0c7cad9beca3a1cb28acb902729937d2dd"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 470, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}