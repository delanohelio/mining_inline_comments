{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1MDQzMzE1", "number": 4139, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzowNjoyNFrOEddSRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNDoxNTo1M1rOEg8-qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzIzOTcyOnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzowNjoyNFrOHIn8mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzowNjoyNFrOHIn8mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwNTE0NA==", "bodyText": "Dupe, already there a couple lines up", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478805144", "createdAt": "2020-08-28T03:06:24Z", "author": {"login": "Cervator"}, "path": "build.gradle", "diffHunk": "@@ -73,6 +73,8 @@ repositories {\n     mavenCentral()\n     mavenLocal()\n \n+    mavenLocal()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI0OTI0OnYy", "diffSide": "RIGHT", "path": "engine-tests/src/test/java/org/terasology/world/block/shape/BlockShapeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoxMjoxM1rOHIoB4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoxMjoxM1rOHIoB4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwNjQ5OA==", "bodyText": "Commented out? Better to either leave a TODO for why / how to restore, or just take it out if it is no longer relevant.", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478806498", "createdAt": "2020-08-28T03:12:13Z", "author": {"login": "Cervator"}, "path": "engine-tests/src/test/java/org/terasology/world/block/shape/BlockShapeTest.java", "diffHunk": "@@ -44,46 +42,43 @@\n     public void setup() throws Exception {\n         super.setup();\n \n-        AssetManager assetManager = CoreRegistry.get(AssetManager.class);\n+        this.assetManager = CoreRegistry.get(AssetManager.class);\n         blockManager = new BlockManagerImpl(new NullWorldAtlas(), assetManager);\n         CoreRegistry.put(BlockManager.class, blockManager);\n-        this.assetManager = assetManager;\n \n     }\n \n     @Test\n     public void testConvexHull() {\n-        BlockShape blockShape =  assetManager.getAsset(\"engine:halfSlope\", BlockShape.class).get();\n+        BlockShape blockShape = assetManager.getAsset(\"engine:halfSlope\", BlockShape.class).get();\n         CollisionShape shape = blockShape.getCollisionShape(Rotation.rotate(Yaw.CLOCKWISE_90));\n \n         assertTrue(shape instanceof ConvexHullShape);\n         Vector3f[] test = new Vector3f[]{new Vector3f(0.49999997f, 0.0f, 0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n-                new Vector3f(0.49999997f, 0.0f, 0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(0.49999997f, 0.0f, 0.49999997f)};\n+            new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n+            new Vector3f(0.49999997f, 0.0f, 0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n+            new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(0.49999997f, 0.0f, 0.49999997f)};\n \n         BulletConvexHullShape bulletConvexHullShape = (BulletConvexHullShape) shape;\n \n-        ObjectArrayList<javax.vecmath.Vector3f> points = ((com.bulletphysics.collision.shapes.ConvexHullShape) bulletConvexHullShape.underlyingShape).getPoints();\n-        for (int x = 0; x < points.size(); x++) {\n-            fuzzVectorTest(test[x], VecMath.from(points.get(x)));\n-\n-        }\n-\n+//        Vector3f[] points = ((ConvexHullShape) bulletConvexHullShape.underlyingShape).getVertices();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI1MTMwOnYy", "diffSide": "RIGHT", "path": "engine/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoxMzo1NFrOHIoDLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoxMzo1NFrOHIoDLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwNjgzMQ==", "bodyText": "Being that this is one of our internal deps shouldn't it be back in the group where tera-bullet was? Also, compile is deprecated - should either be implementation or api", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478806831", "createdAt": "2020-08-28T03:13:54Z", "author": {"login": "Cervator"}, "path": "engine/build.gradle", "diffHunk": "@@ -110,6 +110,8 @@ dependencies {\n     api group: 'com.miglayout', name: 'miglayout-core', version: '5.0'\n     implementation group: 'de.matthiasmann.twl', name: 'PNGDecoder', version: '1111'\n \n+    compile group: 'org.terasology', name: 'JNBullet', version: '0.3.2-SNAPSHOT'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI1MzM0OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/engine/subsystem/lwjgl/BaseLwjglSubsystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoxNTowOVrOHIoEWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoxNTowOVrOHIoEWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwNzEzMA==", "bodyText": "Just looking on GitHub, but it doesn't seem like this import gets used? Also is a LWJGL subsystem the best place for physics? It might be, but it the physics isn't strictly related to LWJGL.", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478807130", "createdAt": "2020-08-28T03:15:09Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/engine/subsystem/lwjgl/BaseLwjglSubsystem.java", "diffHunk": "@@ -15,6 +15,8 @@\n  */\n package org.terasology.engine.subsystem.lwjgl;\n \n+import com.badlogic.gdx.physics.bullet.Bullet;\n+import com.badlogic.gdx.physics.bullet.BulletBase;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI1NjQzOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/logic/characters/KinematicCharacterMover.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoxNzowNlrOHIoF_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoxNzowNlrOHIoF_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwNzU1MA==", "bodyText": "Oh boy, we still had bare ifs? Yikes :-)\nTrivial: One more space needed here", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478807550", "createdAt": "2020-08-28T03:17:06Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/logic/characters/KinematicCharacterMover.java", "diffHunk": "@@ -459,8 +459,9 @@ private boolean moveHorizontal(Vector3f horizMove, CharacterCollider collider, V\n         }\n         boolean horizontalHit = false;\n         Vector3f normalizedDir = horizMove.normalize();\n-        if(!normalizedDir.isFinite())\n+        if(!normalizedDir.isFinite()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI2MzAxOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyMToxNFrOHIoJyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyMToxNFrOHIoJyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwODUyMQ==", "bodyText": "Wut. This constant's name is probably sensible enough, but most people probably won't know what that means anyway (I'm one of them). Might be good with with a one-liner javadoc to explain this field?", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478808521", "createdAt": "2020-08-28T03:21:14Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -96,59 +96,55 @@\n /**\n  * Physics engine implementation using TeraBullet (a customised version of JBullet).\n  */\n+@RegisterSystem\n public class BulletPhysics implements PhysicsEngine {\n+    public static final int AABB_SIZE = Integer.MAX_VALUE;\n+\n+    public static final float SIMD_EPSILON = 1.1920929E-7F;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI2OTg0OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyNDo1OVrOHIoNag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyNDo1OVrOHIoNag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwOTQ1MA==", "bodyText": "How does this relate with the constant in this class that's also about Epsilon, and in fact shares the same name as the old version of the getter? Same thing? This seems a very magic number", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478809450", "createdAt": "2020-08-28T03:24:59Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -429,31 +450,30 @@ public boolean hasCharacterCollider(EntityRef entity) {\n         return entityRigidBodies.keySet().iterator();\n     }\n \n-    @Override\n-    public void awakenArea(org.terasology.math.geom.Vector3f pos, float radius) {\n-        Vector3f min = new Vector3f(VecMath.to(pos));\n-        min.sub(new Vector3f(0.6f, 0.6f, 0.6f));\n-        Vector3f max = new Vector3f(VecMath.to(pos));\n-        max.add(new Vector3f(0.6f, 0.6f, 0.6f));\n-        discreteDynamicsWorld.awakenRigidBodiesInArea(min, max);\n-    }\n-\n     @Override\n     public void awakenArea(Vector3fc pos, float radius) {\n-        Vector3f min = new Vector3f(VecMath.to(pos));\n-        min.sub(new Vector3f(0.6f, 0.6f, 0.6f));\n-        Vector3f max = new Vector3f(VecMath.to(pos));\n-        max.add(new Vector3f(0.6f, 0.6f, 0.6f));\n-        discreteDynamicsWorld.awakenRigidBodiesInArea(min, max);\n+        btPairCachingGhostObject ghost = new btPairCachingGhostObject();\n+        btSphereShape shape = new btSphereShape(radius);\n+        ghost.setCollisionShape(shape);\n+        ghost.setWorldTransform(new Matrix4f().translationRotateScale(pos, new Quaternionf(), 1.0f));\n+\n+        discreteDynamicsWorld.addCollisionObject(ghost, (short) -1, (short) -1);\n+        for (int i = 0; i < ghost.getNumOverlappingObjects(); ++i) {\n+            btCollisionObject other = ghost.getOverlappingObject(i);\n+            other.activate(true);\n+        }\n+        discreteDynamicsWorld.removeCollisionObject(ghost);\n     }\n \n     @Override\n     public float getEpsilon() {\n-        return BulletGlobals.SIMD_EPSILON;\n+        //TODO: figure out how access this from libgdx\n+        return 1.19209290e-07f;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 466}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI3MDcwOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyNToyMVrOHIoN2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNjo0NToxN1rOHIrh2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwOTU2MQ==", "bodyText": "Use the getter, or the constant directly?", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478809561", "createdAt": "2020-08-28T03:25:21Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -308,13 +327,13 @@ public boolean updateRigidBody(EntityRef entity) {\n             return false;\n         } else if (rigidBody != null) {\n             float scale = location.getWorldScale();\n-            if (Math.abs(rigidBody.rb.getCollisionShape().getLocalScaling(new Vector3f()).x - scale) > BulletGlobals.SIMD_EPSILON\n+            if (Math.abs(rigidBody.rb.getCollisionShape().getLocalScaling().x - scale) > this.getEpsilon()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 379}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MzgzMw==", "bodyText": "My opinion: use constant directly - it is constant, it is local and it can be inline at compile time(save several CPU ticks).", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478863833", "createdAt": "2020-08-28T06:45:17Z", "author": {"login": "DarkWeird"}, "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -308,13 +327,13 @@ public boolean updateRigidBody(EntityRef entity) {\n             return false;\n         } else if (rigidBody != null) {\n             float scale = location.getWorldScale();\n-            if (Math.abs(rigidBody.rb.getCollisionShape().getLocalScaling(new Vector3f()).x - scale) > BulletGlobals.SIMD_EPSILON\n+            if (Math.abs(rigidBody.rb.getCollisionShape().getLocalScaling().x - scale) > this.getEpsilon()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwOTU2MQ=="}, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 379}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI3MTgyOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyNjowM1rOHIoOfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyNjowM1rOHIoOfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwOTcyNA==", "bodyText": "Trivial: code style (missing space) - more of them too, won't comment on each, but may want to run the Checkstyle plugin on each modified file to catch these :-)", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478809724", "createdAt": "2020-08-28T03:26:03Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -597,7 +620,11 @@ private synchronized void processQueuedBodies() {\n         }\n         while (!removalQueue.isEmpty()) {\n             BulletRigidBody body = removalQueue.poll();\n+            if(body.isDisposed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 600}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI3Mzk4OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyNzoyOVrOHIoPtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyNzoyOVrOHIoPtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMDAzOA==", "bodyText": "Is this TODO still valid? If so maybe could it be expanded on a bit to make it clear what it means?", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478810038", "createdAt": "2020-08-28T03:27:29Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -646,62 +677,66 @@ private void removeRigidBody(BulletRigidBody body) {\n      * <br><br>\n      * TODO: Flyweight this (take scale as parameter)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 647}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI3NTM4OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyODoyNVrOHIoQjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyODoyNVrOHIoQjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMDI1NQ==", "bodyText": "More meaningful variable names than a1 2 and 3? Seeing more, than those three as well", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478810255", "createdAt": "2020-08-28T03:28:25Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -710,72 +745,78 @@ private PairCachingGhostObject createCollider(Vector3f pos, ConvexShape shape, s\n     }\n \n     private Collection<? extends PhysicsSystem.CollisionPair> getNewCollisionPairs() {\n+        discreteDynamicsWorld.getCollisionWorld().performDiscreteCollisionDetection();\n+\n         List<PhysicsSystem.CollisionPair> collisionPairs = Lists.newArrayList();\n \n-        DynamicsWorld world = discreteDynamicsWorld;\n-        ObjectArrayList<PersistentManifold> manifolds = new ObjectArrayList<>();\n-        for (PairCachingGhostObject trigger : entityTriggers.values()) {\n-            EntityRef entity = (EntityRef) trigger.getUserPointer();\n-            for (BroadphasePair initialPair : trigger.getOverlappingPairCache().getOverlappingPairArray()) {\n+        for (btPairCachingGhostObject trigger : entityTriggers.values()) {\n+            EntityRef entity = (EntityRef) trigger.userData;\n+            btBroadphasePairArray pairs = trigger.getOverlappingPairCache().getOverlappingPairArray();\n+            for (int x = 0; x < pairs.size(); x++) {\n+                btBroadphasePair initialPair = pairs.at(x);\n                 EntityRef otherEntity = null;\n-                if (initialPair.pProxy0.clientObject == trigger) {\n-                    if (((CollisionObject) initialPair.pProxy1.clientObject).getUserPointer() instanceof EntityRef) {\n-                        otherEntity = (EntityRef) ((CollisionObject) initialPair.pProxy1.clientObject).getUserPointer();\n+                btBroadphaseProxy p0 = btBroadphaseProxy.obtain(initialPair.getPProxy0().getCPointer(), false);\n+                btBroadphaseProxy p1 = btBroadphaseProxy.obtain(initialPair.getPProxy1().getCPointer(), false);\n+\n+                if (p0.getClientObject() == trigger.getCPointer()) {\n+\n+                    btCollisionObject other = btCollisionObject.getInstance(p1.getClientObject());\n+                    if (other.userData instanceof EntityRef) {\n+                        otherEntity = (EntityRef) other.userData;\n                     }\n                 } else {\n-                    if (((CollisionObject) initialPair.pProxy0.clientObject).getUserPointer() instanceof EntityRef) {\n-                        otherEntity = (EntityRef) ((CollisionObject) initialPair.pProxy0.clientObject).getUserPointer();\n+                    btCollisionObject other = btCollisionObject.getInstance(p0.getClientObject());\n+                    if (other.userData instanceof EntityRef) {\n+                        otherEntity = (EntityRef) other.userData;\n                     }\n                 }\n                 if (otherEntity == null || otherEntity == EntityRef.NULL) {\n                     continue;\n                 }\n-                BroadphasePair pair = world.getPairCache().findPair(initialPair.pProxy0, initialPair.pProxy1);\n+                btBroadphasePair pair = discreteDynamicsWorld.getPairCache().findPair(p0, p1);\n                 if (pair == null) {\n                     continue;\n                 }\n+\n                 manifolds.clear();\n-                if (pair.algorithm != null) {\n-                    pair.algorithm.getAllContactManifolds(manifolds);\n+                if (pair.getAlgorithm() != null) {\n+                    pair.getAlgorithm().getAllContactManifolds(manifolds);\n                 }\n-                for (PersistentManifold manifold : manifolds) {\n+                for (int y = 0; y < manifolds.size(); y++) {\n+\n+                    btPersistentManifold manifold = manifolds.atConst(y);\n                     for (int point = 0; point < manifold.getNumContacts(); ++point) {\n-                        ManifoldPoint manifoldPoint = manifold.getContactPoint(point);\n-                        if (manifoldPoint.getDistance() < 0) {\n+                        btManifoldPoint manifoldPoint = manifold.getContactPoint(point);\n+                        if (manifoldPoint.getDistance() < 0.f) {\n+                            Vector3f a1 = new Vector3f();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 806}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI3ODA4OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyOTo1NFrOHIoSDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzoyOTo1NFrOHIoSDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMDYzNg==", "bodyText": "More commented out code - either remove if it is no longer needed or put a comment / TODO to explain why it is still there please :-)\nSeeing at least one more of these, will skip commenting on any more", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478810636", "createdAt": "2020-08-28T03:29:54Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -790,128 +831,151 @@ public boolean needsCollision(BroadphaseProxy proxy0) {\n \n     private static class BulletRigidBody implements RigidBody {\n \n-        public final com.bulletphysics.dynamics.RigidBody rb;\n+        public final btRigidBody rb;\n+        public final btRigidBody.btRigidBodyConstructionInfo info;\n         public short collidesWith;\n-        private final Transform pooledTransform = new Transform();\n+        public boolean isDisposed;\n+        //  private final Transform pooledTransform = new Transform();\n         private final Vector3f pendingImpulse = new Vector3f();\n         private final Vector3f pendingForce = new Vector3f();\n \n-        BulletRigidBody(RigidBodyConstructionInfo info) {\n-            rb = new com.bulletphysics.dynamics.RigidBody(info);\n+        BulletRigidBody(btRigidBody.btRigidBodyConstructionInfo info) {\n+            this.info = info;\n+            rb = new btRigidBody(info);\n+            isDisposed = false;\n         }\n \n         @Override\n-        public void applyImpulse(org.terasology.math.geom.Vector3f impulse) {\n-            pendingImpulse.add(VecMath.to(impulse));\n+        public void applyImpulse(Vector3f impulse) {\n+            pendingImpulse.add(impulse);\n         }\n \n         @Override\n-        public void applyForce(org.terasology.math.geom.Vector3f force) {\n-            pendingForce.add(VecMath.to(force));\n+        public void applyForce(Vector3f force) {\n+            pendingForce.add(force);\n         }\n \n         @Override\n-        public void translate(org.terasology.math.geom.Vector3f translation) {\n-            rb.translate(VecMath.to(translation));\n+        public void translate(Vector3f translation) {\n+            rb.translate(translation);\n         }\n \n         @Override\n-        public org.terasology.math.geom.Quat4f getOrientation(org.terasology.math.geom.Quat4f out) {\n-            Quat4f vm = VecMath.to(out);\n-            rb.getOrientation(vm);\n-            out.set(vm.x, vm.y, vm.z, vm.w);\n-            return out;\n+        public Quaternionf getOrientation(Quaternionf out) {\n+            return out.setFromUnnormalized(rb.getWorldTransform());\n         }\n \n         @Override\n-        public org.terasology.math.geom.Vector3f getLocation(org.terasology.math.geom.Vector3f out) {\n-            Vector3f vm = VecMath.to(out);\n-            rb.getCenterOfMassPosition(vm);\n-            out.set(vm.x, vm.y, vm.z);\n+        public Vector3f getLocation(Vector3f out) {\n+            Vector3f result = rb.getWorldTransform().getTranslation(new Vector3f());\n+            out.x = result.x;\n+            out.y = result.y;\n+            out.z = result.z;\n             return out;\n         }\n \n         @Override\n-        public org.terasology.math.geom.Vector3f getLinearVelocity(org.terasology.math.geom.Vector3f out) {\n-            Vector3f vm = VecMath.to(out);\n-            rb.getLinearVelocity(vm);\n-            out.set(vm.x, vm.y, vm.z);\n-            return out;\n+        public Matrix4f getWorldTransform() {\n+            return rb.getWorldTransform();\n         }\n \n         @Override\n-        public org.terasology.math.geom.Vector3f getAngularVelocity(org.terasology.math.geom.Vector3f out) {\n-            Vector3f vm = VecMath.to(out);\n-            rb.getAngularVelocity(vm);\n-            out.set(vm.x, vm.y, vm.z);\n-            return out;\n+        public Matrix4f setWorldTransform(Matrix4f trans) {\n+            rb.setWorldTransform(trans);\n+            return trans;\n         }\n \n         @Override\n-        public void setLinearVelocity(org.terasology.math.geom.Vector3f value) {\n-            rb.setLinearVelocity(VecMath.to(value));\n+        public Vector3f getLinearVelocity(Vector3f out) {\n+            return rb.getLinearVelocity();\n         }\n \n         @Override\n-        public void setAngularVelocity(org.terasology.math.geom.Vector3f value) {\n-            rb.setAngularVelocity(VecMath.to(value));\n+        public Vector3f getAngularVelocity(Vector3f out) {\n+            return rb.getAngularVelocity();// out;\n         }\n \n         @Override\n-        public void setOrientation(org.terasology.math.geom.Quat4f orientation) {\n-            rb.getWorldTransform(pooledTransform);\n-            pooledTransform.setRotation(VecMath.to(orientation));\n-            rb.proceedToTransform(pooledTransform);\n+        public void setLinearVelocity(Vector3f value) {\n+            rb.setLinearVelocity(value);\n         }\n \n         @Override\n-        public void setLocation(org.terasology.math.geom.Vector3f location) {\n-            rb.getWorldTransform(pooledTransform);\n-            pooledTransform.origin.set(VecMath.to(location));\n-            rb.proceedToTransform(pooledTransform);\n+        public void setAngularVelocity(Vector3f value) {\n+            rb.setAngularVelocity(value);\n         }\n \n         @Override\n-        public void setVelocity(org.terasology.math.geom.Vector3f linear, org.terasology.math.geom.Vector3f angular) {\n-            rb.setLinearVelocity(VecMath.to(linear));\n-            rb.setAngularVelocity(VecMath.to(angular));\n+        public void setOrientation(Quaternionf orientation) {\n+            Matrix4f transform = rb.getWorldTransform();\n+            rb.setWorldTransform(new Matrix4f().translationRotateScale(transform.getTranslation(new Vector3f()), orientation, 1.0f));\n         }\n \n         @Override\n-        public void setTransform(org.terasology.math.geom.Vector3f location, org.terasology.math.geom.Quat4f orientation) {\n-            rb.getWorldTransform(pooledTransform);\n-            pooledTransform.origin.set(VecMath.to(location));\n-            pooledTransform.setRotation(VecMath.to(orientation));\n-            rb.proceedToTransform(pooledTransform);\n+        public void setLocation(Vector3f location) {\n+            Matrix4f translation = rb.getWorldTransform();\n+            Quaternionf quaternion = new Quaternionf().setFromUnnormalized(translation);\n+\n+//            Quat4f quaternion = new Quat4f();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 998}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI4MzkyOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/bullet/shapes/BulletConvexHullShape.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozMzoyM1rOHIoVYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozMzoyM1rOHIoVYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMTQ4OA==", "bodyText": "Any reason this isn't just one line instead of two? Assigning this Vector3f to verts next", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478811488", "createdAt": "2020-08-28T03:33:23Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/bullet/shapes/BulletConvexHullShape.java", "diffHunk": "@@ -15,47 +15,58 @@\n  */\n package org.terasology.physics.bullet.shapes;\n \n-import com.bulletphysics.collision.shapes.ConvexHullShape;\n-import com.bulletphysics.util.ObjectArrayList;\n-import org.terasology.math.VecMath;\n-import org.terasology.math.geom.Quat4f;\n-import org.terasology.math.geom.Vector3f;\n+import com.badlogic.gdx.physics.bullet.collision.btConvexHullShape;\n+import com.google.common.collect.Lists;\n+import org.joml.Quaternionf;\n+import org.joml.Vector3f;\n+import org.lwjgl.BufferUtils;\n import org.terasology.physics.shapes.CollisionShape;\n+import org.terasology.physics.shapes.ConvexHullShape;\n \n+import java.nio.FloatBuffer;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n-public class BulletConvexHullShape extends BulletCollisionShape implements org.terasology.physics.shapes.ConvexHullShape {\n+\n+public class BulletConvexHullShape extends BulletCollisionShape implements ConvexHullShape {\n     // TODO: Handle scale\n-    private final ConvexHullShape convexHullShape;\n+    private final btConvexHullShape convexHullShape;\n \n     public BulletConvexHullShape(List<Vector3f> vertices) {\n-        ObjectArrayList<javax.vecmath.Vector3f> vertexList = new ObjectArrayList<>();\n-\n-        vertexList.addAll(vertices.stream().map(VecMath::to).collect(Collectors.toList()));\n-\n-        convexHullShape = new ConvexHullShape(vertexList);\n-        underlyingShape = convexHullShape;\n+        FloatBuffer buffer = BufferUtils.createFloatBuffer(vertices.size() * 3);\n+        for(int i = 0; i < vertices.size(); i++){\n+            Vector3f vertex = vertices.get(i);\n+            buffer.put(vertex.x);\n+            buffer.put(vertex.y);\n+            buffer.put(vertex.z);\n+        }\n+        this.convexHullShape = new btConvexHullShape(buffer,vertices.size(),3 * Float.BYTES);\n+        this.underlyingShape = convexHullShape;\n     }\n \n-    private BulletConvexHullShape(ObjectArrayList<javax.vecmath.Vector3f> vertexList) {\n-        convexHullShape = new ConvexHullShape(vertexList);\n-        underlyingShape = convexHullShape;\n+    public BulletConvexHullShape(FloatBuffer buffer,int numPoints,int stride){\n+        this.convexHullShape = new btConvexHullShape(buffer,numPoints,stride);\n+        this.underlyingShape = convexHullShape;\n     }\n \n     @Override\n-    public CollisionShape rotate(Quat4f rot) {\n-        ObjectArrayList<javax.vecmath.Vector3f> transformedVerts = new ObjectArrayList<>();\n-        for (javax.vecmath.Vector3f vert : convexHullShape.getPoints()) {\n-            transformedVerts.add(com.bulletphysics.linearmath.QuaternionUtil.quatRotate(VecMath.to(rot), vert, new javax.vecmath.Vector3f()));\n+    public CollisionShape rotate(Quaternionf rot) {\n+        List<Vector3f> verts = Lists.newArrayList();\n+        for(int x = 0; x < convexHullShape.getNumPoints(); x++){\n+            Vector3f p = convexHullShape.getScaledPoint(x);\n+            p.rotate(rot);\n+\n+            verts.add(p);\n         }\n-        return new BulletConvexHullShape(transformedVerts);\n+        return new BulletConvexHullShape(verts);\n     }\n \n     @Override\n     public Vector3f[] getVertices() {\n-        return convexHullShape.getPoints().stream()\n-                .map(VecMath::from)\n-                .toArray(Vector3f[]::new);\n+        Vector3f[] verts = new Vector3f[convexHullShape.getNumPoints()];\n+        for(int x = 0; x < convexHullShape.getNumPoints(); x++){\n+            Vector3f p = convexHullShape.getScaledPoint(x);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI4NDM2OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/bullet/shapes/BulletCylinderShape.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozMzo0MlrOHIoVpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozMzo0MlrOHIoVpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMTU1Ng==", "bodyText": "Outdated copyright statements (new one can be generated from within IntelliJ)", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478811556", "createdAt": "2020-08-28T03:33:42Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/bullet/shapes/BulletCylinderShape.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2018 MovingBlocks", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI4ODgzOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/engine/PhysicsEngineManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozNjoxOFrOHIoYGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzowMTo1MFrOHIr7OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMjE4NA==", "bodyText": "This seems like a change that might be meaningful to explain: as per the name of this method it could make perfect sense to return a new physics engine, but what did adding the WorldProvider before achieve that isn't needed now? And if we don't need the Context here should that be removed as a method param?", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478812184", "createdAt": "2020-08-28T03:36:18Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/engine/PhysicsEngineManager.java", "diffHunk": "@@ -39,6 +41,6 @@\n      * @return The created {@link PhysicsEngine} instance.\n      */\n     public static PhysicsEngine getNewPhysicsEngine(Context context) {\n-        return new BulletPhysics(context.get(WorldProvider.class));\n+        return new BulletPhysics();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3MDMyOQ==", "bodyText": "world used by LiquidWorldWrapper and PhysicsWorldWrapper.\nis handles \"static body collision\" (?)\nI don't known how this doing now :D\ncandidates for check", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478870329", "createdAt": "2020-08-28T07:01:50Z", "author": {"login": "DarkWeird"}, "path": "engine/src/main/java/org/terasology/physics/engine/PhysicsEngineManager.java", "diffHunk": "@@ -39,6 +41,6 @@\n      * @return The created {@link PhysicsEngine} instance.\n      */\n     public static PhysicsEngine getNewPhysicsEngine(Context context) {\n-        return new BulletPhysics(context.get(WorldProvider.class));\n+        return new BulletPhysics();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMjE4NA=="}, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI5MDY5OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/engine/PhysicsSystem.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozNzozNlrOHIoZPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozNzozNlrOHIoZPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMjQ3Ng==", "bodyText": "Unnecessarily qualified class? I see the old Vector3f import get removed, so is this needed? Haven't asked my IDE tho", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478812476", "createdAt": "2020-08-28T03:37:36Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/engine/PhysicsSystem.java", "diffHunk": "@@ -146,7 +147,7 @@ public void updateRigidBody(OnChangedComponent event, EntityRef entity) {\n \n     @ReceiveEvent(components = {BlockComponent.class})\n     public void onBlockAltered(OnChangedBlock event, EntityRef entity) {\n-        physics.awakenArea(event.getBlockPosition().toVector3f(), 0.6f);\n+        physics.awakenArea(new org.joml.Vector3f(JomlUtil.from(event.getBlockPosition())), 0.6f);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI5MTIxOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/engine/PhysicsEngineManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozNzo1N1rOHIoZiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozNzo1N1rOHIoZiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMjU1Mg==", "bodyText": "Mystery new imports?", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478812552", "createdAt": "2020-08-28T03:37:57Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/engine/PhysicsEngineManager.java", "diffHunk": "@@ -21,6 +21,8 @@\n import org.terasology.physics.shapes.CollisionShape;\n import org.terasology.physics.shapes.CollisionShapeFactory;\n import org.terasology.world.WorldProvider;\n+import org.terasology.world.block.BlockManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzI5NDY5OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozOTo0NVrOHIobaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzozOTo0NVrOHIobaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMzAzNQ==", "bodyText": "This very much looks like the sort of class that could use some solid javadoc :-) And would it make sense to make the @RegisterSystem explicitly ALWAYS ? If that's intended", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478813035", "createdAt": "2020-08-28T03:39:45Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.physics.engine;\n+\n+import com.badlogic.gdx.physics.bullet.collision.VoxelCollisionAlgorithmWrapper;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionObject;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionShape;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelInfo;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelShape;\n+import com.badlogic.gdx.physics.bullet.dynamics.btDiscreteDynamicsWorld;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody.btRigidBodyConstructionInfo;\n+import com.badlogic.gdx.physics.bullet.linearmath.btDefaultMotionState;\n+import gnu.trove.set.hash.TShortHashSet;\n+import org.joml.Matrix4f;\n+import org.joml.Vector3f;\n+import org.terasology.entitySystem.entity.EntityManager;\n+import org.terasology.entitySystem.entity.EntityRef;\n+import org.terasology.entitySystem.event.ReceiveEvent;\n+import org.terasology.entitySystem.systems.BaseComponentSystem;\n+import org.terasology.entitySystem.systems.RegisterSystem;\n+import org.terasology.math.JomlUtil;\n+import org.terasology.math.geom.Vector3i;\n+import org.terasology.physics.StandardCollisionGroup;\n+import org.terasology.physics.bullet.BulletPhysics;\n+import org.terasology.physics.bullet.shapes.BulletCollisionShape;\n+import org.terasology.registry.In;\n+import org.terasology.world.OnChangedBlock;\n+import org.terasology.world.WorldComponent;\n+import org.terasology.world.WorldProvider;\n+import org.terasology.world.block.Block;\n+import org.terasology.world.block.BlockComponent;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.ChunkConstants;\n+import org.terasology.world.chunks.ChunkProvider;\n+import org.terasology.world.chunks.event.BeforeChunkUnload;\n+import org.terasology.world.chunks.event.OnChunkLoaded;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import static org.terasology.physics.bullet.BulletPhysics.AABB_SIZE;\n+\n+@RegisterSystem\n+public class VoxelWorldSystem extends BaseComponentSystem {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzMxNjQ4OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzo1Mzo1MFrOHIooIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzo1Mzo1MFrOHIooIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxNjI5MA==", "bodyText": "This and other bits of code in this class is kinda ... wild. And unusual. It might make sense if you're familiar with native physics code but if not I'd find this pretty opaque. More comments at least, perhaps?", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478816290", "createdAt": "2020-08-28T03:53:50Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.physics.engine;\n+\n+import com.badlogic.gdx.physics.bullet.collision.VoxelCollisionAlgorithmWrapper;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionObject;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionShape;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelInfo;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelShape;\n+import com.badlogic.gdx.physics.bullet.dynamics.btDiscreteDynamicsWorld;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody.btRigidBodyConstructionInfo;\n+import com.badlogic.gdx.physics.bullet.linearmath.btDefaultMotionState;\n+import gnu.trove.set.hash.TShortHashSet;\n+import org.joml.Matrix4f;\n+import org.joml.Vector3f;\n+import org.terasology.entitySystem.entity.EntityManager;\n+import org.terasology.entitySystem.entity.EntityRef;\n+import org.terasology.entitySystem.event.ReceiveEvent;\n+import org.terasology.entitySystem.systems.BaseComponentSystem;\n+import org.terasology.entitySystem.systems.RegisterSystem;\n+import org.terasology.math.JomlUtil;\n+import org.terasology.math.geom.Vector3i;\n+import org.terasology.physics.StandardCollisionGroup;\n+import org.terasology.physics.bullet.BulletPhysics;\n+import org.terasology.physics.bullet.shapes.BulletCollisionShape;\n+import org.terasology.registry.In;\n+import org.terasology.world.OnChangedBlock;\n+import org.terasology.world.WorldComponent;\n+import org.terasology.world.WorldProvider;\n+import org.terasology.world.block.Block;\n+import org.terasology.world.block.BlockComponent;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.ChunkConstants;\n+import org.terasology.world.chunks.ChunkProvider;\n+import org.terasology.world.chunks.event.BeforeChunkUnload;\n+import org.terasology.world.chunks.event.OnChunkLoaded;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import static org.terasology.physics.bullet.BulletPhysics.AABB_SIZE;\n+\n+@RegisterSystem\n+public class VoxelWorldSystem extends BaseComponentSystem {\n+\n+    @In\n+    private PhysicsEngine physics;\n+    @In\n+    private EntityManager entityManager;\n+    @In\n+    private WorldProvider worldProvider;\n+    @In\n+    private ChunkProvider chunkProvider;\n+\n+    private TShortHashSet registred = new TShortHashSet();\n+\n+    private btRigidBodyConstructionInfo blockConsInf;\n+    private btVoxelShape worldShape;\n+    private VoxelCollisionAlgorithmWrapper wrapper;\n+    private btRigidBody rigidBody;\n+\n+    @Override\n+    public void initialise() {\n+        if (physics instanceof BulletPhysics) {\n+            btDiscreteDynamicsWorld discreteDynamicsWorld = ((BulletPhysics) physics).getDiscreteDynamicsWorld();\n+\n+            wrapper = new VoxelCollisionAlgorithmWrapper(ChunkConstants.SIZE_X, ChunkConstants.SIZE_Y, ChunkConstants.SIZE_Z);\n+            worldShape = new btVoxelShape(wrapper, new Vector3f(-AABB_SIZE, -AABB_SIZE, -AABB_SIZE), new Vector3f(AABB_SIZE, AABB_SIZE, AABB_SIZE));\n+\n+            Matrix4f matrix4f = new Matrix4f();\n+            btDefaultMotionState blockMotionState = new btDefaultMotionState(matrix4f);\n+\n+            blockConsInf = new btRigidBodyConstructionInfo(0, blockMotionState, worldShape, new Vector3f());\n+            rigidBody = new btRigidBody(blockConsInf);\n+            rigidBody.setCollisionFlags(btCollisionObject.CollisionFlags.CF_STATIC_OBJECT | rigidBody.getCollisionFlags());\n+            short mask = (short) (~(StandardCollisionGroup.STATIC.getFlag() | StandardCollisionGroup.LIQUID.getFlag()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzMxOTc0OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzo1NTo0N1rOHIop7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzo1NTo0N1rOHIop7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxNjc0OA==", "bodyText": "Really not sure what this does, but it looks expensive. And is it intentional to use the prefix version of ++ ? That sticks out as unusual and therefore bug prone? Especially if not explained well.", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478816748", "createdAt": "2020-08-28T03:55:47Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.physics.engine;\n+\n+import com.badlogic.gdx.physics.bullet.collision.VoxelCollisionAlgorithmWrapper;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionObject;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionShape;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelInfo;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelShape;\n+import com.badlogic.gdx.physics.bullet.dynamics.btDiscreteDynamicsWorld;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody.btRigidBodyConstructionInfo;\n+import com.badlogic.gdx.physics.bullet.linearmath.btDefaultMotionState;\n+import gnu.trove.set.hash.TShortHashSet;\n+import org.joml.Matrix4f;\n+import org.joml.Vector3f;\n+import org.terasology.entitySystem.entity.EntityManager;\n+import org.terasology.entitySystem.entity.EntityRef;\n+import org.terasology.entitySystem.event.ReceiveEvent;\n+import org.terasology.entitySystem.systems.BaseComponentSystem;\n+import org.terasology.entitySystem.systems.RegisterSystem;\n+import org.terasology.math.JomlUtil;\n+import org.terasology.math.geom.Vector3i;\n+import org.terasology.physics.StandardCollisionGroup;\n+import org.terasology.physics.bullet.BulletPhysics;\n+import org.terasology.physics.bullet.shapes.BulletCollisionShape;\n+import org.terasology.registry.In;\n+import org.terasology.world.OnChangedBlock;\n+import org.terasology.world.WorldComponent;\n+import org.terasology.world.WorldProvider;\n+import org.terasology.world.block.Block;\n+import org.terasology.world.block.BlockComponent;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.ChunkConstants;\n+import org.terasology.world.chunks.ChunkProvider;\n+import org.terasology.world.chunks.event.BeforeChunkUnload;\n+import org.terasology.world.chunks.event.OnChunkLoaded;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import static org.terasology.physics.bullet.BulletPhysics.AABB_SIZE;\n+\n+@RegisterSystem\n+public class VoxelWorldSystem extends BaseComponentSystem {\n+\n+    @In\n+    private PhysicsEngine physics;\n+    @In\n+    private EntityManager entityManager;\n+    @In\n+    private WorldProvider worldProvider;\n+    @In\n+    private ChunkProvider chunkProvider;\n+\n+    private TShortHashSet registred = new TShortHashSet();\n+\n+    private btRigidBodyConstructionInfo blockConsInf;\n+    private btVoxelShape worldShape;\n+    private VoxelCollisionAlgorithmWrapper wrapper;\n+    private btRigidBody rigidBody;\n+\n+    @Override\n+    public void initialise() {\n+        if (physics instanceof BulletPhysics) {\n+            btDiscreteDynamicsWorld discreteDynamicsWorld = ((BulletPhysics) physics).getDiscreteDynamicsWorld();\n+\n+            wrapper = new VoxelCollisionAlgorithmWrapper(ChunkConstants.SIZE_X, ChunkConstants.SIZE_Y, ChunkConstants.SIZE_Z);\n+            worldShape = new btVoxelShape(wrapper, new Vector3f(-AABB_SIZE, -AABB_SIZE, -AABB_SIZE), new Vector3f(AABB_SIZE, AABB_SIZE, AABB_SIZE));\n+\n+            Matrix4f matrix4f = new Matrix4f();\n+            btDefaultMotionState blockMotionState = new btDefaultMotionState(matrix4f);\n+\n+            blockConsInf = new btRigidBodyConstructionInfo(0, blockMotionState, worldShape, new Vector3f());\n+            rigidBody = new btRigidBody(blockConsInf);\n+            rigidBody.setCollisionFlags(btCollisionObject.CollisionFlags.CF_STATIC_OBJECT | rigidBody.getCollisionFlags());\n+            short mask = (short) (~(StandardCollisionGroup.STATIC.getFlag() | StandardCollisionGroup.LIQUID.getFlag()));\n+            discreteDynamicsWorld.addRigidBody(rigidBody, physics.combineGroups(StandardCollisionGroup.WORLD), mask);\n+        }\n+\n+        super.initialise();\n+    }\n+\n+    private void tryRegister(Block block) {\n+        short id = block.getId();\n+        if (!registred.contains(id)) {\n+            btCollisionShape shape = ((BulletCollisionShape) block.getCollisionShape()).underlyingShape;\n+            btVoxelInfo info = new btVoxelInfo(shape != null && block.isTargetable(), shape != null && !block.isPenetrable(), id, shape, JomlUtil.from(block.getCollisionOffset()), block.getFriction(), block.getRestitution(), block.getFriction());\n+            wrapper.setVoxelInfo(info);\n+            registred.add(id);\n+        }\n+    }\n+\n+\n+    @ReceiveEvent(components = {BlockComponent.class})\n+    public void onBlockChange(OnChangedBlock event, EntityRef entity) {\n+        tryRegister(event.getNewType());\n+        wrapper.setBlock(event.getBlockPosition().x, event.getBlockPosition().y, event.getBlockPosition().z, event.getNewType().getId());\n+    }\n+\n+    @ReceiveEvent(components = WorldComponent.class)\n+    public void onChunkUloaded(BeforeChunkUnload beforeChunkUnload, EntityRef worldEntity) {\n+        Vector3i chunkPos = beforeChunkUnload.getChunkPos();\n+        wrapper.freeRegion(chunkPos.x, chunkPos.y, chunkPos.z);\n+    }\n+\n+    @ReceiveEvent(components = {WorldComponent.class})\n+    public void onNewChunk(OnChunkLoaded chunkAvailable, EntityRef worldEntity) {\n+        Vector3i chunkPos = chunkAvailable.getChunkPos();\n+        Chunk chunk = chunkProvider.getChunk(chunkPos);\n+        ByteBuffer buffer = ByteBuffer.allocateDirect(2 * (ChunkConstants.SIZE_X * ChunkConstants.SIZE_Y * ChunkConstants.SIZE_Z));\n+        buffer.order(ByteOrder.nativeOrder());\n+        short[] entries = new short[ChunkConstants.SIZE_X * ChunkConstants.SIZE_Y * ChunkConstants.SIZE_Z];\n+        for (int x = 0; x < ChunkConstants.SIZE_X; ++x) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzMyMDIxOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzo1NjowNFrOHIoqJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMzo1NjowNFrOHIoqJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxNjgwNw==", "bodyText": "Why k", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478816807", "createdAt": "2020-08-28T03:56:04Z", "author": {"login": "Cervator"}, "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.physics.engine;\n+\n+import com.badlogic.gdx.physics.bullet.collision.VoxelCollisionAlgorithmWrapper;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionObject;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionShape;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelInfo;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelShape;\n+import com.badlogic.gdx.physics.bullet.dynamics.btDiscreteDynamicsWorld;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody.btRigidBodyConstructionInfo;\n+import com.badlogic.gdx.physics.bullet.linearmath.btDefaultMotionState;\n+import gnu.trove.set.hash.TShortHashSet;\n+import org.joml.Matrix4f;\n+import org.joml.Vector3f;\n+import org.terasology.entitySystem.entity.EntityManager;\n+import org.terasology.entitySystem.entity.EntityRef;\n+import org.terasology.entitySystem.event.ReceiveEvent;\n+import org.terasology.entitySystem.systems.BaseComponentSystem;\n+import org.terasology.entitySystem.systems.RegisterSystem;\n+import org.terasology.math.JomlUtil;\n+import org.terasology.math.geom.Vector3i;\n+import org.terasology.physics.StandardCollisionGroup;\n+import org.terasology.physics.bullet.BulletPhysics;\n+import org.terasology.physics.bullet.shapes.BulletCollisionShape;\n+import org.terasology.registry.In;\n+import org.terasology.world.OnChangedBlock;\n+import org.terasology.world.WorldComponent;\n+import org.terasology.world.WorldProvider;\n+import org.terasology.world.block.Block;\n+import org.terasology.world.block.BlockComponent;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.ChunkConstants;\n+import org.terasology.world.chunks.ChunkProvider;\n+import org.terasology.world.chunks.event.BeforeChunkUnload;\n+import org.terasology.world.chunks.event.OnChunkLoaded;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import static org.terasology.physics.bullet.BulletPhysics.AABB_SIZE;\n+\n+@RegisterSystem\n+public class VoxelWorldSystem extends BaseComponentSystem {\n+\n+    @In\n+    private PhysicsEngine physics;\n+    @In\n+    private EntityManager entityManager;\n+    @In\n+    private WorldProvider worldProvider;\n+    @In\n+    private ChunkProvider chunkProvider;\n+\n+    private TShortHashSet registred = new TShortHashSet();\n+\n+    private btRigidBodyConstructionInfo blockConsInf;\n+    private btVoxelShape worldShape;\n+    private VoxelCollisionAlgorithmWrapper wrapper;\n+    private btRigidBody rigidBody;\n+\n+    @Override\n+    public void initialise() {\n+        if (physics instanceof BulletPhysics) {\n+            btDiscreteDynamicsWorld discreteDynamicsWorld = ((BulletPhysics) physics).getDiscreteDynamicsWorld();\n+\n+            wrapper = new VoxelCollisionAlgorithmWrapper(ChunkConstants.SIZE_X, ChunkConstants.SIZE_Y, ChunkConstants.SIZE_Z);\n+            worldShape = new btVoxelShape(wrapper, new Vector3f(-AABB_SIZE, -AABB_SIZE, -AABB_SIZE), new Vector3f(AABB_SIZE, AABB_SIZE, AABB_SIZE));\n+\n+            Matrix4f matrix4f = new Matrix4f();\n+            btDefaultMotionState blockMotionState = new btDefaultMotionState(matrix4f);\n+\n+            blockConsInf = new btRigidBodyConstructionInfo(0, blockMotionState, worldShape, new Vector3f());\n+            rigidBody = new btRigidBody(blockConsInf);\n+            rigidBody.setCollisionFlags(btCollisionObject.CollisionFlags.CF_STATIC_OBJECT | rigidBody.getCollisionFlags());\n+            short mask = (short) (~(StandardCollisionGroup.STATIC.getFlag() | StandardCollisionGroup.LIQUID.getFlag()));\n+            discreteDynamicsWorld.addRigidBody(rigidBody, physics.combineGroups(StandardCollisionGroup.WORLD), mask);\n+        }\n+\n+        super.initialise();\n+    }\n+\n+    private void tryRegister(Block block) {\n+        short id = block.getId();\n+        if (!registred.contains(id)) {\n+            btCollisionShape shape = ((BulletCollisionShape) block.getCollisionShape()).underlyingShape;\n+            btVoxelInfo info = new btVoxelInfo(shape != null && block.isTargetable(), shape != null && !block.isPenetrable(), id, shape, JomlUtil.from(block.getCollisionOffset()), block.getFriction(), block.getRestitution(), block.getFriction());\n+            wrapper.setVoxelInfo(info);\n+            registred.add(id);\n+        }\n+    }\n+\n+\n+    @ReceiveEvent(components = {BlockComponent.class})\n+    public void onBlockChange(OnChangedBlock event, EntityRef entity) {\n+        tryRegister(event.getNewType());\n+        wrapper.setBlock(event.getBlockPosition().x, event.getBlockPosition().y, event.getBlockPosition().z, event.getNewType().getId());\n+    }\n+\n+    @ReceiveEvent(components = WorldComponent.class)\n+    public void onChunkUloaded(BeforeChunkUnload beforeChunkUnload, EntityRef worldEntity) {\n+        Vector3i chunkPos = beforeChunkUnload.getChunkPos();\n+        wrapper.freeRegion(chunkPos.x, chunkPos.y, chunkPos.z);\n+    }\n+\n+    @ReceiveEvent(components = {WorldComponent.class})\n+    public void onNewChunk(OnChunkLoaded chunkAvailable, EntityRef worldEntity) {\n+        Vector3i chunkPos = chunkAvailable.getChunkPos();\n+        Chunk chunk = chunkProvider.getChunk(chunkPos);\n+        ByteBuffer buffer = ByteBuffer.allocateDirect(2 * (ChunkConstants.SIZE_X * ChunkConstants.SIZE_Y * ChunkConstants.SIZE_Z));\n+        buffer.order(ByteOrder.nativeOrder());\n+        short[] entries = new short[ChunkConstants.SIZE_X * ChunkConstants.SIZE_Y * ChunkConstants.SIZE_Z];\n+        for (int x = 0; x < ChunkConstants.SIZE_X; ++x) {\n+            for (int y = 0; y < ChunkConstants.SIZE_Y; ++y) {\n+                for (int z = 0; z < ChunkConstants.SIZE_Z; ++z) {\n+                    int index = (z * ChunkConstants.SIZE_X * ChunkConstants.SIZE_Y) + (x * ChunkConstants.SIZE_Y) + y;\n+                    Block block = chunk.getBlock(x, y, z);\n+                    short id = block.getId();\n+                    tryRegister(block);\n+                    entries[index] = id;\n+\n+                }\n+            }\n+        }\n+        for (int k = 0; k < entries.length; k++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzYyNjU0OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNjozOToxN1rOHIrZRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNjozOToxN1rOHIrZRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MTYzNg==", "bodyText": "where are you set JNBulletVersion ?", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478861636", "createdAt": "2020-08-28T06:39:17Z", "author": {"login": "DarkWeird"}, "path": "build.gradle", "diffHunk": "@@ -100,6 +100,9 @@ dependencies {\n \n     // Natives for JNLua (Kallisti, KComputers)\n     natives group: 'org.terasology.jnlua', name: 'jnlua_natives', version: '0.1.0-SNAPSHOT', ext: 'zip'\n+\n+    // Natives for JNBullet\n+    natives group: 'org.terasology', name: 'JNBullet', version: \"${JNBulletVersion}\", ext: 'zip'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "feb91f9e01b66a32bacc81f6aa109c67644795a9"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzYzMTY2OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/engine/subsystem/lwjgl/BaseLwjglSubsystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNjo0MToyNVrOHIrcaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNjo0MToyNVrOHIrcaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MjQ0MA==", "bodyText": "There is not right place.", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478862440", "createdAt": "2020-08-28T06:41:25Z", "author": {"login": "DarkWeird"}, "path": "engine/src/main/java/org/terasology/engine/subsystem/lwjgl/BaseLwjglSubsystem.java", "diffHunk": "@@ -38,30 +39,32 @@ public void preInitialise(Context context) {\n         if (!initialised) {\n             initLogger();\n             LWJGLHelper.initNativeLibs();\n+            Bullet.init(true, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "feb91f9e01b66a32bacc81f6aa109c67644795a9"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzY0NDEyOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNjo0NjoyOFrOHIrjkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNjo0NjoyOFrOHIrjkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2NDI3Mg==", "bodyText": "What is it? You salting code? :D", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478864272", "createdAt": "2020-08-28T06:46:28Z", "author": {"login": "DarkWeird"}, "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -364,21 +383,23 @@ public boolean removeTrigger(EntityRef entity) {\n     //TODO: update if detectGroups changed\n     public boolean updateTrigger(EntityRef entity) {\n         LocationComponent location = entity.getComponent(LocationComponent.class);\n-        PairCachingGhostObject triggerObj = entityTriggers.get(entity);\n+        btPairCachingGhostObject triggerObj = entityTriggers.get(entity);\n \n         if (location == null || Float.isNaN(location.getWorldPosition().x)) {\n             logger.warn(\"Trying to update or create trigger of entity that has no LocationComponent?! Entity: {}\", entity);\n             return false;\n         }\n         if (triggerObj != null) {\n             float scale = location.getWorldScale();\n-            if (Math.abs(triggerObj.getCollisionShape().getLocalScaling(new Vector3f()).x - scale) > BulletGlobals.SIMD_EPSILON) {\n+            if (Math.abs(triggerObj.getCollisionShape().getLocalScaling().x - scale) > SIMD_EPSILON) {\n                 discreteDynamicsWorld.removeCollisionObject(triggerObj);\n                 newTrigger(entity);\n             } else {\n-                Quat4f worldRotation = VecMath.to(location.getWorldRotation());\n-                Vector3f worldPosition = VecMath.to(location.getWorldPosition());\n-                triggerObj.setWorldTransform(new Transform(new Matrix4f(worldRotation, worldPosition, 1.0f)));\n+                Quaternionf worldRotation = JomlUtil.from(location.getWorldRotation());\n+                Vector3f worldPosition = JomlUtil.from(location.getWorldPosition());\n+                triggerObj.setWorldTransform(new Matrix4f().translationRotateScale(worldPosition,worldRotation,1.0f));\n+\n+//                triggerObj.setWorldTransform(new Matrix4f(worldRotation, worldPosition, 1.0f));//new Transform(new Matrix4f(worldRotation, worldPosition, 1.0f)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "feb91f9e01b66a32bacc81f6aa109c67644795a9"}, "originalPosition": 425}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTg4MzIxOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/engine/TerasologyEngine.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNDoxNDozNVrOHOA80Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNToyMDowNlrOHOC6ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1NzY4MQ==", "bodyText": "Why there?\nWhat are means booleans?", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r484457681", "createdAt": "2020-09-07T14:14:35Z", "author": {"login": "DarkWeird"}, "path": "engine/src/main/java/org/terasology/engine/TerasologyEngine.java", "diffHunk": "@@ -155,6 +156,9 @@\n      *                   audio and input subsystems.\n      */\n     public TerasologyEngine(TimeSubsystem timeSubsystem, Collection<EngineSubsystem> subsystems) {\n+        // configure native paths\n+        PathManager.getInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63963c12b90efacd8237cfe646a7ec50a97ddf5d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4OTg4Ng==", "bodyText": "when the native paths are defined I also set the java paths. Just calling an instance of PathManager should be enough to set this up. Maybe something should be setup that is more sensible.", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r484489886", "createdAt": "2020-09-07T15:20:06Z", "author": {"login": "pollend"}, "path": "engine/src/main/java/org/terasology/engine/TerasologyEngine.java", "diffHunk": "@@ -155,6 +156,9 @@\n      *                   audio and input subsystems.\n      */\n     public TerasologyEngine(TimeSubsystem timeSubsystem, Collection<EngineSubsystem> subsystems) {\n+        // configure native paths\n+        PathManager.getInstance();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1NzY4MQ=="}, "originalCommit": {"oid": "63963c12b90efacd8237cfe646a7ec50a97ddf5d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTg4OTY4OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/org/terasology/physics/bullet/EntityMotionState.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNDoxNTo1M1rOHOBALQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxOTozMToxMlrOHOGsCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1ODU0MQ==", "bodyText": "Are we using returns  somewhere? in modules?\ngetWorldTransform with returns void - sounds strange..", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r484458541", "createdAt": "2020-09-07T14:15:53Z", "author": {"login": "DarkWeird"}, "path": "engine/src/main/java/org/terasology/physics/bullet/EntityMotionState.java", "diffHunk": "@@ -16,47 +16,55 @@\n \n package org.terasology.physics.bullet;\n \n-import com.bulletphysics.linearmath.MotionState;\n-import com.bulletphysics.linearmath.Transform;\n+import com.badlogic.gdx.physics.bullet.linearmath.btMotionState;\n+import org.joml.Matrix4f;\n+import org.joml.Quaternionf;\n+import org.joml.Vector3f;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.terasology.entitySystem.entity.EntityRef;\n import org.terasology.logic.location.LocationComponent;\n-import org.terasology.math.VecMath;\n+import org.terasology.math.JomlUtil;\n \n /**\n  * This motion state is used to connect rigid body entities to their rigid body in the bullet physics engine.\n  * Bullet reads the initial state of the rigid body out of the entity, and then updates its location and rotation\n  * as it moves under physics.\n  *\n  */\n-public class EntityMotionState extends MotionState {\n+public class EntityMotionState extends btMotionState {\n+    private static final Logger logger = LoggerFactory.getLogger(EntityMotionState.class);\n+\n     private EntityRef entity;\n+    private Quaternionf rot = new Quaternionf();\n+    private Vector3f position = new Vector3f();\n \n     /**\n      * Only the BulletPhysics class is expected to create instances.\n      *\n-     * @param entity The entity to relate this motion state to and set the\n-     *               LocationComponent of.\n+     * @param entity The entity to relate this motion state to and set the LocationComponent of.\n      */\n     EntityMotionState(EntityRef entity) {\n+        super();\n         this.entity = entity;\n     }\n \n     @Override\n-    public Transform getWorldTransform(Transform transform) {\n+    public void getWorldTransform(Matrix4f transform) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63963c12b90efacd8237cfe646a7ec50a97ddf5d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1MTY4OQ==", "bodyText": "this syncs changes between the LocationComponent and the bullet rigid body. this is for the JNI layer and its not exposed to engine. I believe this is generated by swig.", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r484551689", "createdAt": "2020-09-07T19:31:12Z", "author": {"login": "pollend"}, "path": "engine/src/main/java/org/terasology/physics/bullet/EntityMotionState.java", "diffHunk": "@@ -16,47 +16,55 @@\n \n package org.terasology.physics.bullet;\n \n-import com.bulletphysics.linearmath.MotionState;\n-import com.bulletphysics.linearmath.Transform;\n+import com.badlogic.gdx.physics.bullet.linearmath.btMotionState;\n+import org.joml.Matrix4f;\n+import org.joml.Quaternionf;\n+import org.joml.Vector3f;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.terasology.entitySystem.entity.EntityRef;\n import org.terasology.logic.location.LocationComponent;\n-import org.terasology.math.VecMath;\n+import org.terasology.math.JomlUtil;\n \n /**\n  * This motion state is used to connect rigid body entities to their rigid body in the bullet physics engine.\n  * Bullet reads the initial state of the rigid body out of the entity, and then updates its location and rotation\n  * as it moves under physics.\n  *\n  */\n-public class EntityMotionState extends MotionState {\n+public class EntityMotionState extends btMotionState {\n+    private static final Logger logger = LoggerFactory.getLogger(EntityMotionState.class);\n+\n     private EntityRef entity;\n+    private Quaternionf rot = new Quaternionf();\n+    private Vector3f position = new Vector3f();\n \n     /**\n      * Only the BulletPhysics class is expected to create instances.\n      *\n-     * @param entity The entity to relate this motion state to and set the\n-     *               LocationComponent of.\n+     * @param entity The entity to relate this motion state to and set the LocationComponent of.\n      */\n     EntityMotionState(EntityRef entity) {\n+        super();\n         this.entity = entity;\n     }\n \n     @Override\n-    public Transform getWorldTransform(Transform transform) {\n+    public void getWorldTransform(Matrix4f transform) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1ODU0MQ=="}, "originalCommit": {"oid": "63963c12b90efacd8237cfe646a7ec50a97ddf5d"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 358, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}