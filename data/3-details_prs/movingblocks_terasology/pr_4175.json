{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MDE0MDcy", "number": 4175, "title": "chore[build]: convert facades/PC to gradle to kts", "bodyText": "This converts the gradle config from groovy to kotlin.\nThis PR is intended to be a near line-for-line port. Hold any further changes for another branch that won't be so cluttered by the conversion.\nblocking #4157, as it needs to make changes to these JavaExec tasks.\nHow to test\nRun gradlew :facades:PC:tasks for the list of tasks.\n\ntest  the Terasology run tasks\n\nSee Playing#Configuring a Server for information about how to configure the server settings from the gradle command line.\n\n\ntest the Terasology dist tasks\n\ndists should include jar files for all the modules you have sources checked out for in /modules/", "createdAt": "2020-10-02T16:32:49Z", "url": "https://github.com/MovingBlocks/Terasology/pull/4175", "merged": true, "mergeCommit": {"oid": "52a0a52026c9a9b8430643972f7ff525042ece45"}, "closed": true, "closedAt": "2020-10-20T19:11:26Z", "author": {"login": "keturn"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOo0vVgFqTUwMTI4OTAxNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUdrMmgH2gAyNDk3MDE0MDcyOjczNDBmYzAzNjNiNTFkNTM3YjFiMjUzYjI2NzdlNDk3M2VlNjdjZGY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjg5MDE2", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#pullrequestreview-501289016", "createdAt": "2020-10-02T16:42:40Z", "commit": {"oid": "fd4e5ec7d8d4f171dd6fc51ca75134e2e6253234"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0Mjo0MFrOHb0afg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo0Mjo0MFrOHb0afg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMjM1MA==", "bodyText": "This isn't strictly line-for-line compatible because I only kept some of these as gradle \"extra\" properties. Most of them I left as local variables.\nI don't believe it's a problem for the normal build environment, since there's nothing else in the build that interacts with them, but maybe it could be a concern if something like Jenkins has an alternate configuration that sets or uses them differently?", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r498932350", "createdAt": "2020-10-02T16:42:40Z", "author": {"login": "keturn"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd4e5ec7d8d4f171dd6fc51ca75134e2e6253234"}, "originalPosition": 96}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fe680b4035ced40c73ec419be41a9c1cccc32c0", "author": {"user": {"login": "keturn", "name": "Kevin Turner"}}, "url": "https://github.com/MovingBlocks/Terasology/commit/6fe680b4035ced40c73ec419be41a9c1cccc32c0", "committedDate": "2020-10-03T17:06:14Z", "message": "chore[build]: update for application.mainClass property name change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fc9b9570006ce3a70052403d68fe8f939663156", "author": {"user": {"login": "keturn", "name": "Kevin Turner"}}, "url": "https://github.com/MovingBlocks/Terasology/commit/0fc9b9570006ce3a70052403d68fe8f939663156", "committedDate": "2020-10-03T17:06:14Z", "message": "chore[build]: convert facades/PC/build.gradle to kotlin [WIP: move file]"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd4e5ec7d8d4f171dd6fc51ca75134e2e6253234", "author": {"user": {"login": "keturn", "name": "Kevin Turner"}}, "url": "https://github.com/MovingBlocks/Terasology/commit/fd4e5ec7d8d4f171dd6fc51ca75134e2e6253234", "committedDate": "2020-10-02T16:23:36Z", "message": "chore[build]: convert facades/PC/build.gradle to kotlin\n\nconvert syntax and methods\n\nchore[build]: convert facades/PC/build.gradle to kotlin [WIP 7]\n\nreintroduce the other exec tasks"}, "afterCommit": {"oid": "b264d9f1f0271543b33495acdbe9c57ce8944ab5", "author": {"user": {"login": "keturn", "name": "Kevin Turner"}}, "url": "https://github.com/MovingBlocks/Terasology/commit/b264d9f1f0271543b33495acdbe9c57ce8944ab5", "committedDate": "2020-10-03T17:06:14Z", "message": "chore[build]: convert facades/PC/build.gradle to kotlin\n\nconvert syntax and methods\n\nchore[build]: convert facades/PC/build.gradle to kotlin [WIP 7]\n\nreintroduce the other exec tasks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8", "author": {"user": {"login": "keturn", "name": "Kevin Turner"}}, "url": "https://github.com/MovingBlocks/Terasology/commit/05918823233962341bc4f0af3d5c600a071621b8", "committedDate": "2020-10-03T17:43:10Z", "message": "chore[build]: convert facades/PC/build.gradle to kotlin\n\nconvert syntax and methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b264d9f1f0271543b33495acdbe9c57ce8944ab5", "author": {"user": {"login": "keturn", "name": "Kevin Turner"}}, "url": "https://github.com/MovingBlocks/Terasology/commit/b264d9f1f0271543b33495acdbe9c57ce8944ab5", "committedDate": "2020-10-03T17:06:14Z", "message": "chore[build]: convert facades/PC/build.gradle to kotlin\n\nconvert syntax and methods\n\nchore[build]: convert facades/PC/build.gradle to kotlin [WIP 7]\n\nreintroduce the other exec tasks"}, "afterCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8", "author": {"user": {"login": "keturn", "name": "Kevin Turner"}}, "url": "https://github.com/MovingBlocks/Terasology/commit/05918823233962341bc4f0af3d5c600a071621b8", "committedDate": "2020-10-03T17:43:10Z", "message": "chore[build]: convert facades/PC/build.gradle to kotlin\n\nconvert syntax and methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTY0MDg1", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#pullrequestreview-501564085", "createdAt": "2020-10-03T18:09:36Z", "commit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODowOTozNlrOHcC4Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODozMzo0OVrOHcC_wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTM3NA==", "bodyText": "On a side note: https://github.com/ronmamo/reflections is available in 0.9.12 now.", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499169374", "createdAt": "2020-10-03T18:09:36Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTQ0Nw==", "bodyText": "\ud83d\udc4d I like how this can be inlined now \ud83d\ude03", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499169447", "createdAt": "2020-10-03T18:10:33Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTY1MA==", "bodyText": "Hm, so everything else seems to become more (type-)safe, while you reference the dependency via a plain string there? Is there another way to do this in the Kotlin DSL?", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499169650", "createdAt": "2020-10-03T18:12:57Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")\n+        attributes[\"Implementation-Title\"] = \"Terasology-\" + project.name\n+        attributes[\"Implementation-Version\"] = \"\"\"${env[\"BUILD_NUMBER\"]}, ${env[\"GIT_BRANCH\"]}, ${env[\"BUILD_ID\"]}\"\"\"\n     }\n }\n \n configurations {\n-    // for fetching modules for running a server\n-    modules {\n-        transitive = false\n+    register(\"modules\") {\n+        description = \"for fetching modules for running a server\"\n+        isTransitive = false\n     }\n }\n \n-run {\n+tasks.named<JavaExec>(\"run\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n-    args \"-homedir\", \"-noCrashReport\"\n-    jvmArgs \"-Xmx1536m\"\n-    workingDir rootDir\n+    args = listOf(\"-homedir\", \"-noCrashReport\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n+    workingDir = rootDir\n \n-    dependsOn rootProject.moduleClasses\n+    dependsOn(\":moduleClasses\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MDM5MA==", "bodyText": "Would be nice to make this adjustable in the future via some kind of command line argument...", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499170390", "createdAt": "2020-10-03T18:23:37Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")\n+        attributes[\"Implementation-Title\"] = \"Terasology-\" + project.name\n+        attributes[\"Implementation-Version\"] = \"\"\"${env[\"BUILD_NUMBER\"]}, ${env[\"GIT_BRANCH\"]}, ${env[\"BUILD_ID\"]}\"\"\"\n     }\n }\n \n configurations {\n-    // for fetching modules for running a server\n-    modules {\n-        transitive = false\n+    register(\"modules\") {\n+        description = \"for fetching modules for running a server\"\n+        isTransitive = false\n     }\n }\n \n-run {\n+tasks.named<JavaExec>(\"run\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n-    args \"-homedir\", \"-noCrashReport\"\n-    jvmArgs \"-Xmx1536m\"\n-    workingDir rootDir\n+    args = listOf(\"-homedir\", \"-noCrashReport\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n+    workingDir = rootDir\n \n-    dependsOn rootProject.moduleClasses\n+    dependsOn(\":moduleClasses\")\n }\n \n-task game(type:JavaExec) {\n+tasks.register<JavaExec>(\"game\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n     // If there are no actual source modules let the user know, just in case ..\n-    if (project(':modules').subprojects.size() == 0) {\n-        def out = services.get(StyledTextOutputFactory).create(\"an-ouput\")\n-        out.withStyle(StyledTextOutput.Style.FailureHeader).println(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n+    if (project(\":modules\").subprojects.isEmpty()) {\n+        logger.warn(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n     }\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MDkxNA==", "bodyText": "Do we still need this with the new idea setup introduced recently?", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499170914", "createdAt": "2020-10-03T18:29:51Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/build.gradle.kts", "diffHunk": "@@ -30,396 +28,370 @@ dateTimeFormat.timeZone = TimeZone.getTimeZone(\"UTC\")\n  *\n  * @return\n  */\n-def String nativeSubdirectoryName() {\n-    if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-        return \"windows\"\n-    } else if (Os.isFamily(Os.FAMILY_MAC)) {\n-        return \"macosx\"\n-    } else if (Os.isFamily(Os.FAMILY_UNIX)) {\n-        return \"linux\"\n-    } else {\n-        logger.warn(\"What kind of libraries do you use on this? {}\", System.properties[\"os.name\"])\n-        return \"UNKNOWN\"\n+fun nativeSubdirectoryName(): String {\n+    return when {\n+        Os.isFamily(Os.FAMILY_WINDOWS) -> \"windows\"\n+        Os.isFamily(Os.FAMILY_MAC) -> \"macosx\"\n+        Os.isFamily(Os.FAMILY_UNIX) -> \"linux\"\n+        else -> {\n+            logger.warn(\"What kind of libraries do you use on this? {}\", System.getProperty(\"os.name\"))\n+            \"UNKNOWN\"\n+        }\n     }\n }\n \n \n-ext {\n-    // Default path to store server data if running headless via Gradle\n-    localServerDataPath = 'terasology-server'\n+// Default path to store server data if running headless via Gradle\n+val localServerDataPath by extra(\"terasology-server\")\n \n-    // General props\n-    mainClassName = 'org.terasology.engine.Terasology'\n-    subDirLibs = 'libs'\n-    templatesDir = new File(rootDir, 'templates')\n-    rootDirDist = new File(rootDir, 'build/distributions')\n+// General props\n+val mainClassName by extra(\"org.terasology.engine.Terasology\")\n+val subDirLibs = \"libs\"\n+val templatesDir = File(rootDir, \"templates\")\n+val rootDirDist = File(rootDir, \"build/distributions\")\n \n-    // Read environment variables, including variables passed by jenkins continuous integration server\n-    env = System.getenv()\n+// Inherited props\n+val dirNatives: String by rootProject.extra\n+val distsDirectory: DirectoryProperty by project;\n+\n+// Read environment variables, including variables passed by jenkins continuous integration server\n+val env: MutableMap<String, String> = System.getenv()!!\n+\n+// Version related\n+val startDateTimeString = dateTimeFormat.format(Date())!!\n+val versionFileName = \"VERSION\"\n+val versionBase by lazy { File(templatesDir, \"version.txt\").readText().trim() }\n+val displayVersion = versionBase\n \n-    // Version related\n-    startDateTimeString = dateTimeFormat.format(new Date())\n-    versionFileName = 'VERSION'\n-    versionBase = new File(templatesDir, \"version.txt\").text.trim()\n-    displayVersion = versionBase\n-}\n \n application {\n-    mainClass = project.ext.mainClassName\n+    mainClass.set(extra.get(\"mainClassName\") as String)\n }\n \n // Adjust as the Gradle 6 upgrade changed this path a bit\n sourceSets {\n-    main.java.outputDir = new File(\"$buildDir/classes\")\n-    test.java.outputDir = new File(\"$buildDir/testClasses\")\n+    main { java.outputDir = File(\"$buildDir/classes\") }\n+    test { java.outputDir = File(\"$buildDir/testClasses\") }\n }\n \n // Base the engine tests on the same version number as the engine\n-version = project(':engine').version\n-println \"PC VERSION: $version\"\n+version = project(\":engine\").version\n+logger.info(\"PC VERSION: {}\", version)\n \n // Jenkins-Artifactory integration catches on to this as part of the Maven-type descriptor\n-group = 'org.terasology.facades'\n+group = \"org.terasology.facades\"\n \n dependencies {\n-    implementation project(':engine')\n-    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'\n+    implementation(project(\":engine\"))\n+    implementation(group = \"org.reflections\", name = \"reflections\", version = \"0.9.10\")\n \n     // TODO: Consider whether we can move the CR dependency back here from the engine, where it is referenced from the main menu\n-    implementation group: 'org.terasology.crashreporter', name: 'cr-terasology', version: '4.1.0'\n+    implementation(group = \"org.terasology.crashreporter\", name = \"cr-terasology\", version = \"4.1.0\")\n }\n \n // Instructions for packaging a jar file for the PC facade\n-jar {\n+tasks.named<Jar>(\"jar\") {\n     manifest {\n         //TODO: Maybe later add the engine's version number into here?\n-        def manifestClasspath = configurations.runtimeClasspath.collect { it.getName() }.join(\" \")\n-        attributes(\"Main-Class\": mainClassName)\n-        attributes(\"Class-Path\" : manifestClasspath)\n-        attributes(\"Implementation-Title\": \"Terasology-\" + project.name)\n-        attributes(\"Implementation-Version\": env.BUILD_NUMBER + \", \" + env.GIT_BRANCH + \", \" + env.BUILD_ID)\n+        attributes[\"Main-Class\"] = mainClassName\n+        attributes[\"Class-Path\"] = configurations[\"runtimeClasspath\"].map { it.name }.joinToString(\" \")\n+        attributes[\"Implementation-Title\"] = \"Terasology-\" + project.name\n+        attributes[\"Implementation-Version\"] = \"\"\"${env[\"BUILD_NUMBER\"]}, ${env[\"GIT_BRANCH\"]}, ${env[\"BUILD_ID\"]}\"\"\"\n     }\n }\n \n configurations {\n-    // for fetching modules for running a server\n-    modules {\n-        transitive = false\n+    register(\"modules\") {\n+        description = \"for fetching modules for running a server\"\n+        isTransitive = false\n     }\n }\n \n-run {\n+tasks.named<JavaExec>(\"run\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n-    args \"-homedir\", \"-noCrashReport\"\n-    jvmArgs \"-Xmx1536m\"\n-    workingDir rootDir\n+    args = listOf(\"-homedir\", \"-noCrashReport\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n+    workingDir = rootDir\n \n-    dependsOn rootProject.moduleClasses\n+    dependsOn(\":moduleClasses\")\n }\n \n-task game(type:JavaExec) {\n+tasks.register<JavaExec>(\"game\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application\"\n     group = \"terasology run\"\n \n     // If there are no actual source modules let the user know, just in case ..\n-    if (project(':modules').subprojects.size() == 0) {\n-        def out = services.get(StyledTextOutputFactory).create(\"an-ouput\")\n-        out.withStyle(StyledTextOutput.Style.FailureHeader).println(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n+    if (project(\":modules\").subprojects.isEmpty()) {\n+        logger.warn(\"NOTE: You're running the game from source without any source modules - that may be intentional (got jar modules?) but maybe not. Consider running `groovyw init` or a variant (see `groovyw usage`)\")\n     }\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task profile(type:JavaExec) {\n+tasks.register<JavaExec>(\"profile\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application (with Java FlightRecorder profiling)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n-    jvmArgs = [\"-Xms256m\", \"-Xmx1536m\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=filename=terasology.jfr,dumponexit=true\"]\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-homedir\"]\n-    args runArgs\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xms256m\", \"-Xmx1536m\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=filename=terasology.jfr,dumponexit=true\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task debug(type:JavaExec) {\n+tasks.register<JavaExec>(\"debug\") {\n     description = \"Run 'Terasology' to play the game as a standard PC application (in debug mode)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n-    jvmArgs = [\"-Xmx1536m\", \"-Xdebug\", \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\"]\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-homedir\"]\n-    args runArgs\n+    args = listOf(\"-homedir\")\n+    jvmArgs = listOf(\"-Xmx1536m\", \"-Xdebug\", \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-task permissiveNatives(type:JavaExec) {\n+tasks.register<JavaExec>(\"permissiveNatives\") {\n     description = \"Run 'Terasology' with security set to permissive and natives loading a second way (for KComputers)\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    args \"-homedir\", \"-permissiveSecurity\"\n-    jvmArgs [\"-Xmx1536m\"]\n+    args = listOf(\"-homedir\", \"-permissiveSecurity\")\n+    jvmArgs = listOf(\"-Xmx1536m\")\n \n     systemProperty(\"java.library.path\", rootProject.file(dirNatives + \"/\" + nativeSubdirectoryName()))\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n-// By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it\n-// TODO: This is not the Gradle Way. Needs more declared output-fu to determine up-to-date instead of the if\n-task setupServerConfig {\n-    description \"Parses parameters passed via Gradle and writes them to the local run-from-source server dir's config.cfg\"\n-\n-    def json = new JsonBuilder()\n-\n-    def serverRoot = rootProject.file(localServerDataPath);\n-    def config = new File(serverRoot, 'config.cfg')\n-\n-    if (!config.exists()) {\n-\n-        serverRoot.mkdir()\n-        logger.lifecycle(\"Creating config file $config\")\n-\n-        json {\n-            worldGeneration {\n-                if (project.hasProperty('seed')) {\n-                    logger.lifecycle(\"  Seed value: $seed\");\n-                    defaultSeed seed\n-                }\n-                if (project.hasProperty('worldGen')) {\n-                    logger.lifecycle(\"  World Generator: $worldGen\");\n-                    defaultGenerator worldGen\n-                }\n-            }\n-            defaultModSelection {\n-                if (project.hasProperty('extraModules')) {\n-                    logger.lifecycle(\"  Enabling modules: $extraModules\");\n-                    modules extraModules.tokenize(\" ,\")\n-                }\n-            }\n-        }\n-        config.text = json.toPrettyString()\n-    }\n-}\n+apply(from=\"server.build.gradle\")\n \n // TODO: Seems to always be up to date so no modules get copied\n-task setupServerModules(type: Sync) {\n-    description 'Parses \"extraModules\" - a comma-separated list of modules and puts them into ' + localServerDataPath\n+tasks.register<Sync>(\"setupServerModules\") {\n+    description =\n+        \"\"\"Parses \"extraModules\" - a comma-separated list of modules and puts them into $localServerDataPath\"\"\"\n \n-    if (project.hasProperty('extraModules')) {\n+    val extraModules: String? by project;\n+    extraModules?.let {\n         // Grab modules from Artifactory - cheats by declaring them as dependencies\n-        extraModules.tokenize(' ,').each { String module ->\n-            println \"Extra module: \" + module\n+        it.splitToSequence(\",\").forEach {\n+            logger.info(\"Extra module: {}\", it)\n             dependencies {\n-                modules group: 'org.terasology.modules', name: module, version: '+', changing: 'true'\n+                \"modules\"(group = \"org.terasology.modules\", name = it, version = \"+\")\n             }\n         }\n     }\n \n-    from(configurations.modules)\n-    into(new File(rootProject.file(localServerDataPath), \"modules\"))\n+    from(configurations.named(\"modules\"))\n+    into(File(rootProject.file(localServerDataPath), \"modules\"))\n }\n \n // TODO: Make a task to reset server / game data\n-task server(type:JavaExec) {\n-    description \"Starts a headless multiplayer server with data stored in [project-root]/$localServerDataPath\"\n+tasks.register<JavaExec>(\"server\") {\n+    description = \"Starts a headless multiplayer server with data stored in [project-root]/$localServerDataPath\"\n     group = \"terasology run\"\n \n     // Dependencies: natives + all modules & the PC facade itself (which will trigger the engine)\n-    dependsOn rootProject.extractNatives\n-    dependsOn rootProject.moduleClasses\n-    dependsOn classes\n-    dependsOn setupServerConfig\n-    dependsOn setupServerModules\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\":moduleClasses\")\n+    dependsOn(\"classes\")\n+    dependsOn(\"setupServerConfig\")\n+    dependsOn(\"setupServerModules\")\n \n     // Run arguments\n     main = mainClassName\n     workingDir = rootDir\n-    String[] runArgs = [\"-headless\", \"-homedir=$localServerDataPath\"]\n-    args runArgs\n-    jvmArgs [\"-Xmx1536\"]\n+    args = listOf(\"-headless\", \"-homedir=$localServerDataPath\")\n+    jvmArgs = listOf(\"-Xmx1536\")\n \n     // Classpath: PC itself, engine classes, engine dependencies. Not modules or natives since the engine finds those\n-    classpath sourceSets.main.output.classesDirs\n-    classpath sourceSets.main.output.resourcesDir\n-    classpath project(':engine').sourceSets.main.output.classesDirs\n-    classpath project(':engine').sourceSets.main.output.resourcesDir\n-    classpath project(':engine').configurations.runtimeClasspath\n+    classpath(sourceSets[\"main\"].output.classesDirs)\n+    classpath(sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.classesDirs)\n+    classpath(project(\":engine\").sourceSets[\"main\"].output.resourcesDir)\n+    classpath(project(\":engine\").configurations.runtimeClasspath)\n }\n \n // Preps a version file to bundle with PC dists. This eventually goes into the root of a zip file\n-task createVersionFile(type: Copy) {\n-    inputs.property('dateTime', startDateTimeString)\n-    onlyIf { env.BUILD_URL != null }\n-    from templatesDir\n-    into \"$buildDir\"\n-    include versionFileName\n-    expand(buildNumber: env.BUILD_NUMBER, buildUrl: env.BUILD_URL, gitBranch: env.GIT_BRANCH, dateTime: startDateTimeString, displayVersion: displayVersion)\n-    filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+tasks.register<Copy>(\"createVersionFile\") {\n+    inputs.property(\"dateTime\", startDateTimeString)\n+    onlyIf { env[\"BUILD_URL\"] != null }\n+    from(templatesDir)\n+    into(\"$buildDir\")\n+    include(versionFileName)\n+    expand(mapOf(\n+        \"buildNumber\" to env[\"BUILD_NUMBER\"],\n+        \"buildUrl\" to env[\"BUILD_URL\"],\n+        \"gitBranch\" to env[\"GIT_BRANCH\"],\n+        \"dateTime\" to startDateTimeString,\n+        \"displayVersion\" to displayVersion\n+    ))\n+    filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n }\n \n // TODO: This could probably be done more Gradley (engine project resource dir instead of direct path?) and with some variables\n-task copyCreditsFile(type: Copy) {\n-    description \"Copies the credits file into the engine's resource dir where it'll be read at runtime\"\n-    from \"$rootDir/docs\"\n-    into \"$rootDir/engine/src/main/resources\"\n-    include \"Credits.md\"\n+tasks.register<Copy>(\"copyCreditsFile\") {\n+    description = \"Copies the credits file into the engine's resource dir where it'll be read at runtime\"\n+    from(\"$rootDir/docs\")\n+    into(\"$rootDir/engine/src/main/resources\")\n+    include(\"Credits.md\")\n }\n \n // Main application dist target. Does NOT include any modules.\n-task distApp (type: Sync) {\n+tasks.register<Sync>(\"distApp\") {\n     description = \"Creates an application package for distribution\"\n     group = \"terasology dist\"\n \n-    dependsOn createVersionFile\n-    dependsOn copyCreditsFile\n-    dependsOn rootProject.extractNatives\n-    dependsOn jar\n+    dependsOn(\"createVersionFile\")\n+    dependsOn(\"copyCreditsFile\")\n+    dependsOn(\":extractNatives\")\n+    dependsOn(\"jar\")\n \n-    into (\"${distsDirectory.get().asFile}/app\")\n+    into(\"${distsDirectory.get().asFile}/app\")\n     from (\"$rootDir/README.markdown\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n-        rename('README.markdown', 'README')\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        rename(\"README.markdown\", \"README\")\n     }\n     from (\"$rootDir/LICENSE\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n     }\n     from (\"$rootDir/NOTICE\") {\n-        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n+        filter(FixCrLfFilter::class, \"eol\" to FixCrLfFilter.CrLf.newInstance(\"crlf\"))\n     }\n-    from('launchScripts') {\n-        exclude('TeraEd.exe')\n+    from(\"launchScripts\") {\n+        exclude(\"TeraEd.exe\")\n     }\n \n     from(\"$buildDir/$versionFileName\") {}\n \n     into(subDirLibs) {\n-        from configurations.runtimeClasspath\n-        from project(':engine').jar\n-        from (\"$buildDir/libs\") {\n-            include \"*.jar\"\n+        from(configurations.runtimeClasspath)\n+        from(tasks.getByPath(\":engine:jar\"))\n+        from(\"$buildDir/libs\") {\n+            include(\"*.jar\")\n             rename {\n-                'Terasology.jar'\n+                \"Terasology.jar\"\n             }\n         }\n     }\n     into(dirNatives) {\n-        from \"$rootDir/$dirNatives\"\n+        from(\"$rootDir/$dirNatives\")\n     }\n }\n \n // Distribute modules - only grabs Core in Jenkins but locally will grab any present. \"Distros\" now handle Jenkins packs\n-task distModules (type: Sync) {\n+tasks.register<Sync>(\"distModules\") {\n     description = \"Prepares local modules for distribution\"\n-    dependsOn distApp\n-    dependsOn rootProject.moduleJars\n+    dependsOn(\"distApp\")\n+    dependsOn(\":moduleJars\")\n \n     // So this is probably a hack, but it works ;-) It does not work if it is in distApp, default \"into\" quirk ?\n     into(\"${distsDirectory.get().asFile}/app/modules\")\n-    rootProject.terasologyModules().each {\n-        from \"$rootDir/modules/${it.name}/build/libs\"\n-        include \"*.jar\"\n+    // FIXME: duplicating code from /build.gradle:terasologyModules\n+    val terasologyModules = rootProject.subprojects.filter { it.parent?.name == \"modules\" }\n+    terasologyModules.forEach {\n+        from(\"$rootDir/modules/${it.name}/build/libs\")\n+        include(\"*.jar\")\n     }\n }\n \n-task distPCZip (type: Zip) {\n+tasks.register<Zip>(\"distPCZip\") {\n     group = \"terasology dist\"\n-    dependsOn distApp\n-    dependsOn distModules\n-    from \"${distsDirectory.get().asFile}/app\"\n-    archiveFileName = \"Terasology.zip\"\n+    dependsOn(\"distApp\")\n+    dependsOn(\"distModules\")\n+    from(\"${distsDirectory.get().asFile}/app\")\n+    archiveFileName.set(\"Terasology.zip\")\n }\n \n-task distForLauncher (type: Sync) {\n+tasks.register<Sync>(\"distForLauncher\") {\n     group = \"terasology dist\"\n \n-    into rootDirDist\n-    from distPCZip\n+    into(rootDirDist)\n+    from(tasks.getByName(\"distPCZip\"))\n \n-    into (\"../resources/main/org/terasology/version\") {\n-        from (\"$rootDir/engine/build/classes/org/terasology/version\") {\n-            include ('versionInfo.properties')\n+    into(\"../resources/main/org/terasology/version\") {\n+        from(\"$rootDir/engine/build/classes/org/terasology/version\") {\n+            include(\"versionInfo.properties\")\n         }\n     }\n }\n \n // Prep an IntelliJ module for the facade\n-idea {\n+configure<IdeaModel> {\n     module {\n         // Change around the output a bit\n         inheritOutputDirs = false\n-        outputDir = file('build/classes')\n-        testOutputDir = file('build/testClasses')\n+        outputDir = file(\"build/classes\")\n+        testOutputDir = file(\"build/testClasses\")\n     }\n }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 593}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MTI2NQ==", "bodyText": "Is this comment still up to date for the code? There is no notion of << or doLast in the code (neither before nor after the refactoring)...", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r499171265", "createdAt": "2020-10-03T18:33:49Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/server.build.gradle", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+// This is still in Groovy because the embedded Groovy has a JsonBuilder.\n+import groovy.json.JsonBuilder\n+\n+\n+// By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDIxNTQ3", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#pullrequestreview-513021547", "createdAt": "2020-10-20T18:33:17Z", "commit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODozMzoxN1rOHlLpzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODozMzoxN1rOHlLpzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDI4NA==", "bodyText": "At this point we don't know (anymore), so let's remove this.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it", "url": "https://github.com/MovingBlocks/Terasology/pull/4175#discussion_r508750284", "createdAt": "2020-10-20T18:33:17Z", "author": {"login": "skaldarnar"}, "path": "facades/PC/server.build.gradle", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+// This is still in Groovy because the embedded Groovy has a JsonBuilder.\n+import groovy.json.JsonBuilder\n+\n+\n+// By delaying this task to doLast (the << bit) we don't get the headless server dir set up unless actually wanting it", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MTI2NQ=="}, "originalCommit": {"oid": "05918823233962341bc4f0af3d5c600a071621b8"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7340fc0363b51d537b1b253b2677e4973ee67cdf", "author": {"user": {"login": "keturn", "name": "Kevin Turner"}}, "url": "https://github.com/MovingBlocks/Terasology/commit/7340fc0363b51d537b1b253b2677e4973ee67cdf", "committedDate": "2020-10-20T19:10:09Z", "message": "fix (gradle): remove obsolete comment\n\nCo-authored-by: Tobias Nett <skaldarnar@googlemail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1457, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}