{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzMDYwMzYw", "number": 9996, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNTo0N1rOElbu6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MToyN1rOElbweA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3MTQ3OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNTo0N1rOHU7KrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNTo0N1rOHU7KrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMjk1Nw==", "bodyText": "remove the extra blank line", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491702957", "createdAt": "2020-09-20T15:35:47Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3MTY3OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNjowOFrOHU7KxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNjowOFrOHU7KxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMjk4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testUsingLoop(){\n          \n          \n            \n                public void testUsingLoop() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491702981", "createdAt": "2020-09-20T15:36:08Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3MjMzOnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNjo1OFrOHU7LFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNjo1OFrOHU7LFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzA2MA==", "bodyText": "opening brace should be at the end of a line, not on a line by itself", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703060", "createdAt": "2020-09-20T15:36:58Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3MjUzOnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNzoyNFrOHU7LMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNzoyNFrOHU7LMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzA4OQ==", "bodyText": "need a blank line between methods", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703089", "createdAt": "2020-09-20T15:37:24Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3MjU2OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNzozM1rOHU7LNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNzozM1rOHU7LNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzA5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static void testExecutor(){\n          \n          \n            \n                public static void testExecutor() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703093", "createdAt": "2020-09-20T15:37:33Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3MjkyOnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNzo1MVrOHU7LXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNzo1MVrOHU7LXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzEzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testExecutor2(){\n          \n          \n            \n                public void testExecutor2() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703133", "createdAt": "2020-09-20T15:37:51Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3Mjk0OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozODowNFrOHU7LYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozODowNFrOHU7LYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzEzNw==", "bodyText": "reduce to one blank line", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703137", "createdAt": "2020-09-20T15:38:04Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3Mjk5OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozODoxNFrOHU7Lag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozODoxNFrOHU7Lag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzE0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testScheduledExecutor(){\n          \n          \n            \n                public void testScheduledExecutor() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703146", "createdAt": "2020-09-20T15:38:14Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3MzExOnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozODoyNlrOHU7LeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozODoyNlrOHU7LeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzE2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testThreadAndInterrupt(){\n          \n          \n            \n                public void testThreadAndInterrupt() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703160", "createdAt": "2020-09-20T15:38:26Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3MzM0OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozODo0N1rOHU7Llw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozODo0N1rOHU7Llw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzE5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testTimer(){\n          \n          \n            \n                public void testTimer() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703191", "createdAt": "2020-09-20T15:38:47Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3MzQxOnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozODo1OFrOHU7Log==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozODo1OFrOHU7Log==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzIwMg==", "bodyText": "one blank line", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703202", "createdAt": "2020-09-20T15:38:58Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3Mzk2OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozOTo0NFrOHU7L4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozOTo0NFrOHU7L4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzI2NQ==", "bodyText": "separate methods with a blank line", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703265", "createdAt": "2020-09-20T15:39:44Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3NDQ4OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MDowNFrOHU7MGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MDowNFrOHU7MGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzMyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class LongRunningTask implements Runnable{\n          \n          \n            \n                class LongRunningTask implements Runnable {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703321", "createdAt": "2020-09-20T15:40:04Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3NDU5OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MDoxM1rOHU7MJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MDoxM1rOHU7MJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzMzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void longRunningOperation(){\n          \n          \n            \n                    private void longRunningOperation() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703335", "createdAt": "2020-09-20T15:40:13Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3NDc1OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MDoyNlrOHU7MPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MDoyNlrOHU7MPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzM1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        catch (InterruptedException e){\n          \n          \n            \n                        catch (InterruptedException e) {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703357", "createdAt": "2020-09-20T15:40:26Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3NDkyOnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MDozNlrOHU7MUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MDozNlrOHU7MUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzM3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void longRunningSort(){\n          \n          \n            \n                    private void longRunningSort() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703376", "createdAt": "2020-09-20T15:40:36Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3NTI1OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MTowOVrOHU7Mdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MTowOVrOHU7Mdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzQxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }catch (InterruptedException e){\n          \n          \n            \n                        }catch (InterruptedException e) {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703414", "createdAt": "2020-09-20T15:41:09Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){\n+            LOG.info(\"long Running task started\");\n+            // Do you long running calculation here\n+            int len = 100000;\n+            List<Integer> numbers = new ArrayList<>();\n+            try {\n+                for (int i = len; i > 0; i--) {\n+                    //Thread.sleep(5)\n+                    numbers.add(i);\n+                }\n+\n+                int i = 0;\n+                for (i = 0; i < len; i++) {\n+                    int minIndex = i;\n+                    for (int j = i + 1; j < len; j++) {\n+                        if (numbers.get(minIndex) > numbers.get(j))\n+                            minIndex = j;\n+                    }\n+                    if (minIndex != i) {\n+                        int temp = numbers.get(i);\n+                        numbers.set(i, numbers.get(minIndex));\n+                        numbers.set(minIndex, temp);\n+                    }\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+                LOG.info(\"Index position: \" + i);\n+                LOG.info(\"Long running task finished\");\n+            }catch (InterruptedException e){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3NTM1OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MToxOFrOHU7MgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MToxOFrOHU7MgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzQyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void longFileRead() throws InterruptedException{\n          \n          \n            \n                    private void longFileRead() throws InterruptedException {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703425", "createdAt": "2020-09-20T15:41:18Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){\n+            LOG.info(\"long Running task started\");\n+            // Do you long running calculation here\n+            int len = 100000;\n+            List<Integer> numbers = new ArrayList<>();\n+            try {\n+                for (int i = len; i > 0; i--) {\n+                    //Thread.sleep(5)\n+                    numbers.add(i);\n+                }\n+\n+                int i = 0;\n+                for (i = 0; i < len; i++) {\n+                    int minIndex = i;\n+                    for (int j = i + 1; j < len; j++) {\n+                        if (numbers.get(minIndex) > numbers.get(j))\n+                            minIndex = j;\n+                    }\n+                    if (minIndex != i) {\n+                        int temp = numbers.get(i);\n+                        numbers.set(i, numbers.get(minIndex));\n+                        numbers.set(minIndex, temp);\n+                    }\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+                LOG.info(\"Index position: \" + i);\n+                LOG.info(\"Long running task finished\");\n+            }catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longFileRead() throws InterruptedException{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 242}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Njg3NTQ0OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MToyN1rOHU7Miw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MToyN1rOHU7Miw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzQzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void throwExceptionOnThreadInterrupt() throws InterruptedException{\n          \n          \n            \n                    private void throwExceptionOnThreadInterrupt() throws InterruptedException {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703435", "createdAt": "2020-09-20T15:41:27Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){\n+            LOG.info(\"long Running task started\");\n+            // Do you long running calculation here\n+            int len = 100000;\n+            List<Integer> numbers = new ArrayList<>();\n+            try {\n+                for (int i = len; i > 0; i--) {\n+                    //Thread.sleep(5)\n+                    numbers.add(i);\n+                }\n+\n+                int i = 0;\n+                for (i = 0; i < len; i++) {\n+                    int minIndex = i;\n+                    for (int j = i + 1; j < len; j++) {\n+                        if (numbers.get(minIndex) > numbers.get(j))\n+                            minIndex = j;\n+                    }\n+                    if (minIndex != i) {\n+                        int temp = numbers.get(i);\n+                        numbers.set(i, numbers.get(minIndex));\n+                        numbers.set(minIndex, temp);\n+                    }\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+                LOG.info(\"Index position: \" + i);\n+                LOG.info(\"Long running task finished\");\n+            }catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longFileRead() throws InterruptedException{\n+            String file = \"input.txt\";\n+            ClassLoader classloader = getClass().getClassLoader();\n+\n+            try (InputStream inputStream = classloader.getResourceAsStream(file)){\n+                Reader inputStreamReader = new InputStreamReader(inputStream);\n+\n+                int data = inputStreamReader.read();\n+                while (data != -1) {\n+                    char theChar = (char) data;\n+                    data = inputStreamReader.read();\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+            } catch (IOException e){\n+                LOG.error(\"Exception: \", e);\n+            }\n+        }\n+        private void throwExceptionOnThreadInterrupt() throws InterruptedException{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 259}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4235, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}