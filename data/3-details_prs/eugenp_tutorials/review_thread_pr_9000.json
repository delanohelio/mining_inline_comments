{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2MjYyOTYw", "number": 9000, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNTowODowNVrOD76Ryg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToyMToyMFrOD8NFnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTQ3NDAyOnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-advanced-3/src/test/java/com/baeldung/exchanger/ExachangerUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNTowODowNVrOGUhmOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxMToyM1rOGU_0xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NTE2MA==", "bodyText": "it's Exchanger :)", "url": "https://github.com/eugenp/tutorials/pull/9000#discussion_r424175160", "createdAt": "2020-05-13T05:08:05Z", "author": {"login": "pivovarit"}, "path": "core-java-modules/core-java-concurrency-advanced-3/src/test/java/com/baeldung/exchanger/ExachangerUnitTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package com.baeldung.exchanger;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.Exchanger;\n+\n+import org.junit.Test;\n+\n+public class ExachangerUnitTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22517c579a7597616e478acb8dc192bce35b1c7a"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MDQwNA==", "bodyText": "Done fixed", "url": "https://github.com/eugenp/tutorials/pull/9000#discussion_r424670404", "createdAt": "2020-05-13T19:11:23Z", "author": {"login": "dhruba619"}, "path": "core-java-modules/core-java-concurrency-advanced-3/src/test/java/com/baeldung/exchanger/ExachangerUnitTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package com.baeldung.exchanger;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.Exchanger;\n+\n+import org.junit.Test;\n+\n+public class ExachangerUnitTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NTE2MA=="}, "originalCommit": {"oid": "22517c579a7597616e478acb8dc192bce35b1c7a"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTQ4NTU1OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-advanced-3/src/test/java/com/baeldung/exchanger/ExchangerPipeLineUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNToxNDoyN1rOGUhs3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxMjozOFrOGU_3dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3Njg2Mw==", "bodyText": "This is just an instant deadlock, please remove it", "url": "https://github.com/eugenp/tutorials/pull/9000#discussion_r424176863", "createdAt": "2020-05-13T05:14:27Z", "author": {"login": "pivovarit"}, "path": "core-java-modules/core-java-concurrency-advanced-3/src/test/java/com/baeldung/exchanger/ExchangerPipeLineUnitTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.baeldung.exchanger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Exchanger;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+public class ExchangerPipeLineUnitTest {\n+\n+    private static final int BUFFER_SIZE = 100;\n+\n+    @Test\n+    public void givenData_whenPassedThrough_thenCorrect() throws InterruptedException {\n+\n+        Exchanger<Queue<String>> readerExchanger = new Exchanger<>();\n+        Exchanger<Queue<String>> writerExchanger = new Exchanger<>();\n+\n+        Runnable reader = () -> {\n+            Queue<String> readerBuffer = new ConcurrentLinkedQueue<>();\n+            while (true) {\n+                readerBuffer.add(UUID.randomUUID().toString());\n+                if (readerBuffer.size() >= BUFFER_SIZE) {\n+                    try {\n+                        readerBuffer = readerExchanger.exchange(readerBuffer);\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+        };\n+\n+        Runnable processor = () -> {\n+            Queue<String> processorBuffer = new ConcurrentLinkedQueue<>();\n+            Queue<String> writterBuffer = new ConcurrentLinkedQueue<>();\n+            try {\n+                processorBuffer = readerExchanger.exchange(processorBuffer);\n+                while (true) {\n+                    writterBuffer.add(processorBuffer.poll());\n+                    if (processorBuffer.isEmpty()) {\n+                        try {\n+                            processorBuffer = readerExchanger.exchange(processorBuffer);\n+                            writterBuffer = writerExchanger.exchange(writterBuffer);\n+                        } catch (InterruptedException e) {\n+                            Thread.currentThread().interrupt();\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+        };\n+\n+        Runnable writer = () -> {\n+            Queue<String> writterBuffer = new ConcurrentLinkedQueue<>();\n+            try {\n+                writterBuffer = writerExchanger.exchange(writterBuffer);\n+                while (true) {\n+                    System.out.println(writterBuffer.poll());\n+                    if (writterBuffer.isEmpty()) {\n+                        writterBuffer = writerExchanger.exchange(writterBuffer);\n+                    }\n+                }\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+        };\n+\n+        new Thread(reader).start();\n+        new Thread(processor).start();\n+        new Thread(writer).start();\n+        //Thread.currentThread().join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22517c579a7597616e478acb8dc192bce35b1c7a"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MTA5Mw==", "bodyText": "Done fixed, replaced with:\nCompletableFuture.allOf(runAsync(reader), runAsync(processor), runAsync(writer)).get();\nBut left that is commented for the sake build pipeline to stop, else this would run infinitely. To have the test working uncomment the line and execute.", "url": "https://github.com/eugenp/tutorials/pull/9000#discussion_r424671093", "createdAt": "2020-05-13T19:12:38Z", "author": {"login": "dhruba619"}, "path": "core-java-modules/core-java-concurrency-advanced-3/src/test/java/com/baeldung/exchanger/ExchangerPipeLineUnitTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.baeldung.exchanger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Exchanger;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+public class ExchangerPipeLineUnitTest {\n+\n+    private static final int BUFFER_SIZE = 100;\n+\n+    @Test\n+    public void givenData_whenPassedThrough_thenCorrect() throws InterruptedException {\n+\n+        Exchanger<Queue<String>> readerExchanger = new Exchanger<>();\n+        Exchanger<Queue<String>> writerExchanger = new Exchanger<>();\n+\n+        Runnable reader = () -> {\n+            Queue<String> readerBuffer = new ConcurrentLinkedQueue<>();\n+            while (true) {\n+                readerBuffer.add(UUID.randomUUID().toString());\n+                if (readerBuffer.size() >= BUFFER_SIZE) {\n+                    try {\n+                        readerBuffer = readerExchanger.exchange(readerBuffer);\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+        };\n+\n+        Runnable processor = () -> {\n+            Queue<String> processorBuffer = new ConcurrentLinkedQueue<>();\n+            Queue<String> writterBuffer = new ConcurrentLinkedQueue<>();\n+            try {\n+                processorBuffer = readerExchanger.exchange(processorBuffer);\n+                while (true) {\n+                    writterBuffer.add(processorBuffer.poll());\n+                    if (processorBuffer.isEmpty()) {\n+                        try {\n+                            processorBuffer = readerExchanger.exchange(processorBuffer);\n+                            writterBuffer = writerExchanger.exchange(writterBuffer);\n+                        } catch (InterruptedException e) {\n+                            Thread.currentThread().interrupt();\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+        };\n+\n+        Runnable writer = () -> {\n+            Queue<String> writterBuffer = new ConcurrentLinkedQueue<>();\n+            try {\n+                writterBuffer = writerExchanger.exchange(writterBuffer);\n+                while (true) {\n+                    System.out.println(writterBuffer.poll());\n+                    if (writterBuffer.isEmpty()) {\n+                        writterBuffer = writerExchanger.exchange(writterBuffer);\n+                    }\n+                }\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+        };\n+\n+        new Thread(reader).start();\n+        new Thread(processor).start();\n+        new Thread(writer).start();\n+        //Thread.currentThread().join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3Njg2Mw=="}, "originalCommit": {"oid": "22517c579a7597616e478acb8dc192bce35b1c7a"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDU1NTgxOnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-advanced-3/src/test/java/com/baeldung/exchanger/ExchangerUnitTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToyMToyMFrOGVAKDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODo0MTo0MlrOGVSADQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NTg1NA==", "bodyText": "You can just do result.join()", "url": "https://github.com/eugenp/tutorials/pull/9000#discussion_r424675854", "createdAt": "2020-05-13T19:21:20Z", "author": {"login": "pivovarit"}, "path": "core-java-modules/core-java-concurrency-advanced-3/src/test/java/com/baeldung/exchanger/ExchangerUnitTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.baeldung.exchanger;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Exchanger;\n+\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+\n+public class ExchangerUnitTest {\n+    \n+    \n+    @Test\n+    public void givenThreads_whenMessageExchanged_thenCorrect() {\n+        Exchanger<String> exchanger = new Exchanger<>();\n+\n+        Runnable taskA = () -> {\n+            try {\n+                String message = exchanger.exchange(\"from A\");\n+                assertEquals(\"from B\", message);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+        };\n+\n+        Runnable taskB = () -> {\n+            try {\n+                String message = exchanger.exchange(\"from B\");\n+                assertEquals(\"from A\", message);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+        };\n+\n+        CompletableFuture.allOf(runAsync(taskA), runAsync(taskB)).join();\n+    }\n+\n+    @Test\n+    public void givenThread_WhenExchangedMessage_thenCorrect() throws InterruptedException, ExecutionException {\n+        Exchanger<String> exchanger = new Exchanger<>();\n+\n+        Runnable runner = () -> {\n+            try {\n+                String message = exchanger.exchange(\"from runner\");\n+                assertEquals(\"to runner\", message);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+        };\n+\n+        CompletableFuture<Void> result = CompletableFuture.runAsync(runner);\n+        String msg = exchanger.exchange(\"to runner\");\n+        assertEquals(\"from runner\", msg);\n+        CompletableFuture.allOf(result).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95ea758e7d33c4ec6466041c94dbc06bc5e45222"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2ODIwNQ==", "bodyText": "Done Fixed.", "url": "https://github.com/eugenp/tutorials/pull/9000#discussion_r424968205", "createdAt": "2020-05-14T08:41:42Z", "author": {"login": "cornercoding"}, "path": "core-java-modules/core-java-concurrency-advanced-3/src/test/java/com/baeldung/exchanger/ExchangerUnitTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.baeldung.exchanger;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Exchanger;\n+\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+\n+public class ExchangerUnitTest {\n+    \n+    \n+    @Test\n+    public void givenThreads_whenMessageExchanged_thenCorrect() {\n+        Exchanger<String> exchanger = new Exchanger<>();\n+\n+        Runnable taskA = () -> {\n+            try {\n+                String message = exchanger.exchange(\"from A\");\n+                assertEquals(\"from B\", message);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+        };\n+\n+        Runnable taskB = () -> {\n+            try {\n+                String message = exchanger.exchange(\"from B\");\n+                assertEquals(\"from A\", message);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+        };\n+\n+        CompletableFuture.allOf(runAsync(taskA), runAsync(taskB)).join();\n+    }\n+\n+    @Test\n+    public void givenThread_WhenExchangedMessage_thenCorrect() throws InterruptedException, ExecutionException {\n+        Exchanger<String> exchanger = new Exchanger<>();\n+\n+        Runnable runner = () -> {\n+            try {\n+                String message = exchanger.exchange(\"from runner\");\n+                assertEquals(\"to runner\", message);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+        };\n+\n+        CompletableFuture<Void> result = CompletableFuture.runAsync(runner);\n+        String msg = exchanger.exchange(\"to runner\");\n+        assertEquals(\"from runner\", msg);\n+        CompletableFuture.allOf(result).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NTg1NA=="}, "originalCommit": {"oid": "95ea758e7d33c4ec6466041c94dbc06bc5e45222"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4068, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}