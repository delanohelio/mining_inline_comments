{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMTg0NDk3", "number": 9238, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNTozODo0OVrOD61Y6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNTozODo0OVrOD61Y6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMDE4NzI4OnYy", "diffSide": "RIGHT", "path": "core-java-modules/core-java-concurrency-advanced-3/src/main/java/com/baeldung/lockfree/NonBlockingQueue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNTozODo1MFrOGS4pXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNTozODo1MFrOGS4pXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1NTY0NQ==", "bodyText": "I believe that should be final since we should not allow mutation inside a Node class other than for the sake of linking with next/previous Node.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private volatile T value;\n          \n          \n            \n                    private final T value;", "url": "https://github.com/eugenp/tutorials/pull/9238#discussion_r422455645", "createdAt": "2020-05-09T05:38:50Z", "author": {"login": "pivovarit"}, "path": "core-java-modules/core-java-concurrency-advanced-3/src/main/java/com/baeldung/lockfree/NonBlockingQueue.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.baeldung.lockfree;\n+\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class NonBlockingQueue<T> {\n+\n+    private final AtomicReference<Node<T>> head, tail;\n+    private final AtomicInteger size;\n+\n+    public NonBlockingQueue() {\n+        head = new AtomicReference<>(null);\n+        tail = new AtomicReference<>(null);\n+        size = new AtomicInteger();\n+        size.set(0);\n+    }\n+\n+    public void add(T element) {\n+        if (element == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        Node<T> node = new Node<>(element);\n+        Node<T> currentTail;\n+        do {\n+            currentTail = tail.get();\n+            node.setPrevious(currentTail);\n+        } while(!tail.compareAndSet(currentTail, node));\n+\n+        if(node.previous != null) {\n+            node.previous.next = node;\n+        }\n+\n+        head.compareAndSet(null, node); //if we are inserting the first element\n+        size.incrementAndGet();\n+    }\n+\n+    public T get() {\n+        if(head.get() == null) {\n+            throw new NoSuchElementException();\n+        }\n+\n+        Node<T> currentHead;\n+        Node<T> nextNode;\n+        do {\n+            currentHead = head.get();\n+            nextNode = currentHead.getNext();\n+        } while(!head.compareAndSet(currentHead, nextNode));\n+\n+        size.decrementAndGet();\n+        return currentHead.getValue();\n+    }\n+\n+    public int size() {\n+        return this.size.get();\n+    }\n+\n+    private class Node<T> {\n+        private volatile T value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2322ca1033cb440afdc35ee007cfc6c0c2cf47d5"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4008, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}