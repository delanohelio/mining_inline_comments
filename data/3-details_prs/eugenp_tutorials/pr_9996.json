{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzMDYwMzYw", "number": 9996, "title": "BAEL-4558: Article for stopping execution after a certain time", "bodyText": "", "createdAt": "2020-09-09T19:00:13Z", "url": "https://github.com/eugenp/tutorials/pull/9996", "merged": true, "mergeCommit": {"oid": "56e2e3ca09b65bfa526a1e3fd0463d73d879e936"}, "closed": true, "closedAt": "2020-10-24T14:20:20Z", "author": {"login": "sahilsingla112"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHQ4PcgH2gAyNDgzMDYwMzYwOjQ0NDQ3MWE2YTZiODQ3MjdmMmQ4OGUxMzNhMTA3MGFjZDY3NGU2MDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdLa7IJgFqTQ5MzY2MzA2OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "444471a6a6b84727f2d88e133a1070acd674e603", "author": {"user": null}, "url": "https://github.com/eugenp/tutorials/commit/444471a6a6b84727f2d88e133a1070acd674e603", "committedDate": "2020-09-09T18:54:37Z", "message": "BAEL-4558: Article for stopping execution after a certain time"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858", "author": {"user": null}, "url": "https://github.com/eugenp/tutorials/commit/69261078941d7e947638e85f91d8e96b4495d858", "committedDate": "2020-09-09T18:59:18Z", "message": "BAEL-4558: Article for stopping execution after a certain time"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMjAyNTgy", "url": "https://github.com/eugenp/tutorials/pull/9996#pullrequestreview-492202582", "createdAt": "2020-09-20T15:35:46Z", "commit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTozNTo0N1rOHU7KrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxNTo0MToyN1rOHU7Miw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMjk1Nw==", "bodyText": "remove the extra blank line", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491702957", "createdAt": "2020-09-20T15:35:47Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMjk4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testUsingLoop(){\n          \n          \n            \n                public void testUsingLoop() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491702981", "createdAt": "2020-09-20T15:36:08Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzA2MA==", "bodyText": "opening brace should be at the end of a line, not on a line by itself", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703060", "createdAt": "2020-09-20T15:36:58Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzA4OQ==", "bodyText": "need a blank line between methods", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703089", "createdAt": "2020-09-20T15:37:24Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzA5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static void testExecutor(){\n          \n          \n            \n                public static void testExecutor() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703093", "createdAt": "2020-09-20T15:37:33Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzEzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testExecutor2(){\n          \n          \n            \n                public void testExecutor2() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703133", "createdAt": "2020-09-20T15:37:51Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzEzNw==", "bodyText": "reduce to one blank line", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703137", "createdAt": "2020-09-20T15:38:04Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzE0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testScheduledExecutor(){\n          \n          \n            \n                public void testScheduledExecutor() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703146", "createdAt": "2020-09-20T15:38:14Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzE2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testThreadAndInterrupt(){\n          \n          \n            \n                public void testThreadAndInterrupt() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703160", "createdAt": "2020-09-20T15:38:26Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzE5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testTimer(){\n          \n          \n            \n                public void testTimer() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703191", "createdAt": "2020-09-20T15:38:47Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzIwMg==", "bodyText": "one blank line", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703202", "createdAt": "2020-09-20T15:38:58Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzI2NQ==", "bodyText": "separate methods with a blank line", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703265", "createdAt": "2020-09-20T15:39:44Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzMyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class LongRunningTask implements Runnable{\n          \n          \n            \n                class LongRunningTask implements Runnable {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703321", "createdAt": "2020-09-20T15:40:04Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzMzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void longRunningOperation(){\n          \n          \n            \n                    private void longRunningOperation() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703335", "createdAt": "2020-09-20T15:40:13Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzM1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        catch (InterruptedException e){\n          \n          \n            \n                        catch (InterruptedException e) {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703357", "createdAt": "2020-09-20T15:40:26Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzM3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void longRunningSort(){\n          \n          \n            \n                    private void longRunningSort() {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703376", "createdAt": "2020-09-20T15:40:36Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzQxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }catch (InterruptedException e){\n          \n          \n            \n                        }catch (InterruptedException e) {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703414", "createdAt": "2020-09-20T15:41:09Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){\n+            LOG.info(\"long Running task started\");\n+            // Do you long running calculation here\n+            int len = 100000;\n+            List<Integer> numbers = new ArrayList<>();\n+            try {\n+                for (int i = len; i > 0; i--) {\n+                    //Thread.sleep(5)\n+                    numbers.add(i);\n+                }\n+\n+                int i = 0;\n+                for (i = 0; i < len; i++) {\n+                    int minIndex = i;\n+                    for (int j = i + 1; j < len; j++) {\n+                        if (numbers.get(minIndex) > numbers.get(j))\n+                            minIndex = j;\n+                    }\n+                    if (minIndex != i) {\n+                        int temp = numbers.get(i);\n+                        numbers.set(i, numbers.get(minIndex));\n+                        numbers.set(minIndex, temp);\n+                    }\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+                LOG.info(\"Index position: \" + i);\n+                LOG.info(\"Long running task finished\");\n+            }catch (InterruptedException e){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzQyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void longFileRead() throws InterruptedException{\n          \n          \n            \n                    private void longFileRead() throws InterruptedException {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703425", "createdAt": "2020-09-20T15:41:18Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){\n+            LOG.info(\"long Running task started\");\n+            // Do you long running calculation here\n+            int len = 100000;\n+            List<Integer> numbers = new ArrayList<>();\n+            try {\n+                for (int i = len; i > 0; i--) {\n+                    //Thread.sleep(5)\n+                    numbers.add(i);\n+                }\n+\n+                int i = 0;\n+                for (i = 0; i < len; i++) {\n+                    int minIndex = i;\n+                    for (int j = i + 1; j < len; j++) {\n+                        if (numbers.get(minIndex) > numbers.get(j))\n+                            minIndex = j;\n+                    }\n+                    if (minIndex != i) {\n+                        int temp = numbers.get(i);\n+                        numbers.set(i, numbers.get(minIndex));\n+                        numbers.set(minIndex, temp);\n+                    }\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+                LOG.info(\"Index position: \" + i);\n+                LOG.info(\"Long running task finished\");\n+            }catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longFileRead() throws InterruptedException{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzQzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void throwExceptionOnThreadInterrupt() throws InterruptedException{\n          \n          \n            \n                    private void throwExceptionOnThreadInterrupt() throws InterruptedException {", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703435", "createdAt": "2020-09-20T15:41:27Z", "author": {"login": "KevinGilmore"}, "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){\n+            LOG.info(\"long Running task started\");\n+            // Do you long running calculation here\n+            int len = 100000;\n+            List<Integer> numbers = new ArrayList<>();\n+            try {\n+                for (int i = len; i > 0; i--) {\n+                    //Thread.sleep(5)\n+                    numbers.add(i);\n+                }\n+\n+                int i = 0;\n+                for (i = 0; i < len; i++) {\n+                    int minIndex = i;\n+                    for (int j = i + 1; j < len; j++) {\n+                        if (numbers.get(minIndex) > numbers.get(j))\n+                            minIndex = j;\n+                    }\n+                    if (minIndex != i) {\n+                        int temp = numbers.get(i);\n+                        numbers.set(i, numbers.get(minIndex));\n+                        numbers.set(minIndex, temp);\n+                    }\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+                LOG.info(\"Index position: \" + i);\n+                LOG.info(\"Long running task finished\");\n+            }catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longFileRead() throws InterruptedException{\n+            String file = \"input.txt\";\n+            ClassLoader classloader = getClass().getClassLoader();\n+\n+            try (InputStream inputStream = classloader.getResourceAsStream(file)){\n+                Reader inputStreamReader = new InputStreamReader(inputStream);\n+\n+                int data = inputStreamReader.read();\n+                while (data != -1) {\n+                    char theChar = (char) data;\n+                    data = inputStreamReader.read();\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+            } catch (IOException e){\n+                LOG.error(\"Exception: \", e);\n+            }\n+        }\n+        private void throwExceptionOnThreadInterrupt() throws InterruptedException{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69261078941d7e947638e85f91d8e96b4495d858"}, "originalPosition": 259}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "475f156bc2916ccf513dae8965434adc83c5c5b2", "author": {"user": null}, "url": "https://github.com/eugenp/tutorials/commit/475f156bc2916ccf513dae8965434adc83c5c5b2", "committedDate": "2020-09-22T16:48:17Z", "message": "Applied formatter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjYzMDY5", "url": "https://github.com/eugenp/tutorials/pull/9996#pullrequestreview-493663069", "createdAt": "2020-09-22T16:52:31Z", "commit": {"oid": "475f156bc2916ccf513dae8965434adc83c5c5b2"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4291, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}