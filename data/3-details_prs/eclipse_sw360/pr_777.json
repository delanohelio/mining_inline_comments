{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0ODUyODcz", "number": 777, "title": "feat(REST): Trigger FOSSology process and check status.", "bodyText": "Added REST endpoint to Trigger FOSSology process for a release.\nAdded REST endpoint to check status of FOSSology process.\n\nSigned-off-by: Jaideep Palit jaideep.palit@siemens.com", "createdAt": "2020-02-13T12:55:57Z", "url": "https://github.com/eclipse/sw360/pull/777", "merged": true, "mergeCommit": {"oid": "269681cbcde2c6e2916d116b0f8a97dd5e9ce08f"}, "closed": true, "closedAt": "2020-03-10T09:12:33Z", "author": {"login": "JaideepPalit"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIcUqLgBqjMwNzgxNDE0NTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMMlZggFqTM3MTcwNjUxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "79fb115e0f1460f042220825a018c4c9776f7185", "author": {"user": {"login": "JaideepPalit", "name": "Jaideep Palit"}}, "url": "https://github.com/eclipse/sw360/commit/79fb115e0f1460f042220825a018c4c9776f7185", "committedDate": "2020-02-13T12:48:46Z", "message": "feat(REST): Upload sources to FOSSology and download report\n\nSigned-off-by: Jaideep Palit <jaideep.palit@siemens.com>"}, "afterCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "author": {"user": {"login": "JaideepPalit", "name": "Jaideep Palit"}}, "url": "https://github.com/eclipse/sw360/commit/628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "committedDate": "2020-02-27T14:28:59Z", "message": "feat(REST): Trigger FOSSology process and check status.\n\nSigned-off-by: Jaideep Palit <jaideep.palit@siemens.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MTI2MjM1", "url": "https://github.com/eclipse/sw360/pull/777#pullrequestreview-367126235", "createdAt": "2020-03-02T11:24:37Z", "commit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMToyNDozOFrOFwcJgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwODoxMDo0OFrOFyJv6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNzE1NA==", "bodyText": "Kindly remove the extra blank line here.", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r386337154", "createdAt": "2020-03-02T11:24:38Z", "author": {"login": "smrutis1"}, "path": "backend/src/src-fossology/src/main/java/org/eclipse/sw360/fossology/FossologyHandler.java", "diffHunk": "@@ -31,11 +31,13 @@\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Component;\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgzMTU4Mg==", "bodyText": "status code -1 for failure right? I am wondering if it is significant here.", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r386831582", "createdAt": "2020-03-03T07:07:31Z", "author": {"login": "smrutis1"}, "path": "backend/src/src-fossology/src/main/java/org/eclipse/sw360/fossology/FossologyHandler.java", "diffHunk": "@@ -375,8 +382,8 @@ private void handleScanStep(Iface componentClient, Release release, User user,\n         case IN_WORK:\n             // query state\n             int scanningJobId = Integer.valueOf(furthestStep.getProcessStepIdInTool());\n-            int status = fossologyRestClient.checkScanStatus(scanningJobId);\n-            if (status > 0) {\n+            int status = scanStatusCode(fossologyRestClient.checkScanStatus(scanningJobId));\n+            if (status > 0 || status == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3NDMxNg==", "bodyText": "Please add a null check for release.getAttachments() and may be rename the method name as it is returning the attachmentid along with validation.", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388074316", "createdAt": "2020-03-05T04:36:40Z", "author": {"login": "smrutis1"}, "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;\n+\n+        Runnable asyncRunnable = () -> wrapTException(() -> {\n+            ReentrantLock lockObj = locks.apply(releaseId);\n+            ScheduledExecutorService service = null;\n+\n+            try {\n+                if (lockObj.tryLock()) {\n+                    service = Executors.newSingleThreadScheduledExecutor();\n+                    triggerUploadScanAndReportStep(service, fossologyProcessFinal, release, user, attachmentId);\n+                }\n+            } catch (Exception exp) {\n+                log.error(String.format(\"Release : %s .Error occured while triggering Fossology Process . %s\",\n+                        new Object[] { releaseId, exp.getMessage() }));\n+            } finally {\n+                log.info(\"Release : \" + releaseId + \" .Fossology Process exited, removing lock.\");\n+                if (service != null)\n+                    service.shutdownNow();\n+                if (lockObj.isLocked())\n+                    lockObj.unlock();\n+                mapOfLocks.remove(releaseId);\n+            }\n+        });\n+\n+        Thread asyncThread = new Thread(asyncRunnable);\n+        asyncThread.start();\n+    }\n+\n+    private String validateNumberOfSrcAttached(String releaseId, User user) throws TException {\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        List<Attachment> listOfSources = release.getAttachments().parallelStream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5MDI4Mw==", "bodyText": "Kindly consider moving it to the service class.", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388090283", "createdAt": "2020-03-05T05:52:46Z", "author": {"login": "smrutis1"}, "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5MTk2NA==", "bodyText": "Kindly consider extracting the size calculation of attachments to a method .", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388091964", "createdAt": "2020-03-05T05:59:32Z", "author": {"login": "smrutis1"}, "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;\n+\n+        Runnable asyncRunnable = () -> wrapTException(() -> {\n+            ReentrantLock lockObj = locks.apply(releaseId);\n+            ScheduledExecutorService service = null;\n+\n+            try {\n+                if (lockObj.tryLock()) {\n+                    service = Executors.newSingleThreadScheduledExecutor();\n+                    triggerUploadScanAndReportStep(service, fossologyProcessFinal, release, user, attachmentId);\n+                }\n+            } catch (Exception exp) {\n+                log.error(String.format(\"Release : %s .Error occured while triggering Fossology Process . %s\",\n+                        new Object[] { releaseId, exp.getMessage() }));\n+            } finally {\n+                log.info(\"Release : \" + releaseId + \" .Fossology Process exited, removing lock.\");\n+                if (service != null)\n+                    service.shutdownNow();\n+                if (lockObj.isLocked())\n+                    lockObj.unlock();\n+                mapOfLocks.remove(releaseId);\n+            }\n+        });\n+\n+        Thread asyncThread = new Thread(asyncRunnable);\n+        asyncThread.start();\n+    }\n+\n+    private String validateNumberOfSrcAttached(String releaseId, User user) throws TException {\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        List<Attachment> listOfSources = release.getAttachments().parallelStream()\n+                .filter(attachment -> attachment.getAttachmentType() == AttachmentType.SOURCE)\n+                .collect(Collectors.toList());\n+        int noOfSrcAttached = listOfSources.size();\n+\n+        if (noOfSrcAttached != 1) {\n+            throw new HttpMessageNotReadableException(\"There has to be exactly one source attachment, but there are \"\n+                    + noOfSrcAttached + \" at this release. Please come back once you corrected that.\");\n+        }\n+\n+        return listOfSources.get(0).getAttachmentContentId();\n+    }\n+\n+    private void triggerUploadScanAndReportStep(final ScheduledExecutorService service,\n+            final ExternalToolProcess fossologyProcess, final Release release, final User user,\n+            final String attachmentId) throws TException {\n+\n+        int scanStatusCheckCount = 0, scanTriggerRetriesCount = 0, reportGenerateTriggerRetries = 0,\n+                reportGeneratestatusCheckCount = 0,maxRetries=15;\n+        ScheduledFuture<ExternalToolProcess> future = null;\n+        String releaseId = release.getId();\n+        ExternalToolProcess fossologyProcessLocal = fossologyProcess;\n+        byte[] byteArray = new byte[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5MjM3OQ==", "bodyText": "Please remove the unused variable scanCheckCount", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388092379", "createdAt": "2020-03-05T06:01:15Z", "author": {"login": "smrutis1"}, "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;\n+\n+        Runnable asyncRunnable = () -> wrapTException(() -> {\n+            ReentrantLock lockObj = locks.apply(releaseId);\n+            ScheduledExecutorService service = null;\n+\n+            try {\n+                if (lockObj.tryLock()) {\n+                    service = Executors.newSingleThreadScheduledExecutor();\n+                    triggerUploadScanAndReportStep(service, fossologyProcessFinal, release, user, attachmentId);\n+                }\n+            } catch (Exception exp) {\n+                log.error(String.format(\"Release : %s .Error occured while triggering Fossology Process . %s\",\n+                        new Object[] { releaseId, exp.getMessage() }));\n+            } finally {\n+                log.info(\"Release : \" + releaseId + \" .Fossology Process exited, removing lock.\");\n+                if (service != null)\n+                    service.shutdownNow();\n+                if (lockObj.isLocked())\n+                    lockObj.unlock();\n+                mapOfLocks.remove(releaseId);\n+            }\n+        });\n+\n+        Thread asyncThread = new Thread(asyncRunnable);\n+        asyncThread.start();\n+    }\n+\n+    private String validateNumberOfSrcAttached(String releaseId, User user) throws TException {\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        List<Attachment> listOfSources = release.getAttachments().parallelStream()\n+                .filter(attachment -> attachment.getAttachmentType() == AttachmentType.SOURCE)\n+                .collect(Collectors.toList());\n+        int noOfSrcAttached = listOfSources.size();\n+\n+        if (noOfSrcAttached != 1) {\n+            throw new HttpMessageNotReadableException(\"There has to be exactly one source attachment, but there are \"\n+                    + noOfSrcAttached + \" at this release. Please come back once you corrected that.\");\n+        }\n+\n+        return listOfSources.get(0).getAttachmentContentId();\n+    }\n+\n+    private void triggerUploadScanAndReportStep(final ScheduledExecutorService service,\n+            final ExternalToolProcess fossologyProcess, final Release release, final User user,\n+            final String attachmentId) throws TException {\n+\n+        int scanStatusCheckCount = 0, scanTriggerRetriesCount = 0, reportGenerateTriggerRetries = 0,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5MzI0NQ==", "bodyText": "please remove this unnecessary assignment.", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388093245", "createdAt": "2020-03-05T06:04:54Z", "author": {"login": "smrutis1"}, "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;\n+\n+        Runnable asyncRunnable = () -> wrapTException(() -> {\n+            ReentrantLock lockObj = locks.apply(releaseId);\n+            ScheduledExecutorService service = null;\n+\n+            try {\n+                if (lockObj.tryLock()) {\n+                    service = Executors.newSingleThreadScheduledExecutor();\n+                    triggerUploadScanAndReportStep(service, fossologyProcessFinal, release, user, attachmentId);\n+                }\n+            } catch (Exception exp) {\n+                log.error(String.format(\"Release : %s .Error occured while triggering Fossology Process . %s\",\n+                        new Object[] { releaseId, exp.getMessage() }));\n+            } finally {\n+                log.info(\"Release : \" + releaseId + \" .Fossology Process exited, removing lock.\");\n+                if (service != null)\n+                    service.shutdownNow();\n+                if (lockObj.isLocked())\n+                    lockObj.unlock();\n+                mapOfLocks.remove(releaseId);\n+            }\n+        });\n+\n+        Thread asyncThread = new Thread(asyncRunnable);\n+        asyncThread.start();\n+    }\n+\n+    private String validateNumberOfSrcAttached(String releaseId, User user) throws TException {\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        List<Attachment> listOfSources = release.getAttachments().parallelStream()\n+                .filter(attachment -> attachment.getAttachmentType() == AttachmentType.SOURCE)\n+                .collect(Collectors.toList());\n+        int noOfSrcAttached = listOfSources.size();\n+\n+        if (noOfSrcAttached != 1) {\n+            throw new HttpMessageNotReadableException(\"There has to be exactly one source attachment, but there are \"\n+                    + noOfSrcAttached + \" at this release. Please come back once you corrected that.\");\n+        }\n+\n+        return listOfSources.get(0).getAttachmentContentId();\n+    }\n+\n+    private void triggerUploadScanAndReportStep(final ScheduledExecutorService service,\n+            final ExternalToolProcess fossologyProcess, final Release release, final User user,\n+            final String attachmentId) throws TException {\n+\n+        int scanStatusCheckCount = 0, scanTriggerRetriesCount = 0, reportGenerateTriggerRetries = 0,\n+                reportGeneratestatusCheckCount = 0,maxRetries=15;\n+        ScheduledFuture<ExternalToolProcess> future = null;\n+        String releaseId = release.getId();\n+        ExternalToolProcess fossologyProcessLocal = fossologyProcess;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5NDc4NA==", "bodyText": "Please consider removing this assignment, if there is no significant.", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388094784", "createdAt": "2020-03-05T06:11:24Z", "author": {"login": "smrutis1"}, "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyMjUxNg==", "bodyText": "Please remove this unused import ExecutionException or it can be made as import java.util.concurrent.*", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388122516", "createdAt": "2020-03-05T07:43:52Z", "author": {"login": "smrutis1"}, "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -39,21 +46,36 @@\n import org.springframework.http.HttpStatus;\n import org.springframework.http.MediaType;\n import org.springframework.http.ResponseEntity;\n+import org.springframework.http.converter.HttpMessageNotReadableException;\n import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.util.FileCopyUtils;\n import org.springframework.util.MultiValueMap;\n import org.springframework.web.bind.annotation.*;\n import org.springframework.web.multipart.MultipartFile;\n import org.springframework.web.servlet.support.ServletUriComponentsBuilder;\n \n import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyNjE5MQ==", "bodyText": "May be we can use RELEASES_URL constants.", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388126191", "createdAt": "2020-03-05T07:54:01Z", "author": {"login": "smrutis1"}, "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEzMjg0Mw==", "bodyText": "I think from 459-489 can be made extracted to a method and can be made generic.", "url": "https://github.com/eclipse/sw360/pull/777#discussion_r388132843", "createdAt": "2020-03-05T08:10:48Z", "author": {"login": "smrutis1"}, "path": "rest/resource-server/src/main/java/org/eclipse/sw360/rest/resourceserver/release/ReleaseController.java", "diffHunk": "@@ -270,12 +298,314 @@ public void downloadAttachmentFromRelease(\n         attachmentService.downloadAttachmentWithContext(release, attachmentId, response, sw360User);\n     }\n \n+    @RequestMapping(value = RELEASES_URL + \"/{id}/checkFossologyProcessStatus\", method = RequestMethod.GET)\n+    public ResponseEntity<Map<String, Object>> checkFossologyProcessStatus(\n+            @PathVariable(\"id\") String releaseId) throws TException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        Map<String, Object> responseMap = new HashMap<>();\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        if (lock != null && lock.isLocked()) {\n+            responseMap.put(\"status\", RequestStatus.PROCESSING);\n+        } else if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" is complete.\");\n+            responseMap.put(\"status\", RequestStatus.SUCCESS);\n+        } else {\n+            responseMap.put(\"status\", RequestStatus.FAILURE);\n+        }\n+        responseMap.put(\"fossologyProcessInfo\", fossologyProcess);\n+        return new ResponseEntity<>(responseMap, HttpStatus.OK);\n+    }\n+\n+    @RequestMapping(value = RELEASES_URL + \"/{id}/triggerFossologyProcess\", method = RequestMethod.GET)\n+    public ResponseEntity<HalResource> triggerFossologyProcess(@PathVariable(\"id\") String releaseId,\n+            @RequestParam(value = \"markFossologyProcessOutdated\", required = false) boolean markFossologyProcessOutdated,\n+            HttpServletResponse response) throws TException, IOException {\n+        releaseService.checkFossologyConnection();\n+\n+        ReentrantLock lock = mapOfLocks.get(releaseId);\n+        Map<String, String> responseMap = new HashMap<>();\n+        HttpStatus status = null;\n+        if (lock == null || !lock.isLocked()) {\n+            if (mapOfLocks.size() > 10) {\n+                responseMap.put(\"message\",\n+                        \"Max 10 FOSSology Process can be triggered simultaneously. Please try after sometime.\");\n+                status = HttpStatus.TOO_MANY_REQUESTS;\n+            } else {\n+                executeFossologyProcess(releaseId, markFossologyProcessOutdated);\n+                responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId + \" has been triggered.\");\n+                status = HttpStatus.OK;\n+            }\n+\n+        } else {\n+            status = HttpStatus.NOT_ACCEPTABLE;\n+            responseMap.put(\"message\", \"FOSSology Process for Release Id : \" + releaseId\n+                    + \" is already running. Please wait till it is completed.\");\n+        }\n+        HalResource responseResource = new HalResource(responseMap);\n+        Link checkStatusLink = linkTo(ReleaseController.class)\n+                .slash(\"api/releases/\" + releaseId + \"/checkFossologyProcessStatus\").withSelfRel();\n+        responseResource.add(checkStatusLink);\n+\n+        return new ResponseEntity<HalResource>(responseResource, status);\n+    }\n+\n     @Override\n     public RepositoryLinksResource process(RepositoryLinksResource resource) {\n         resource.add(linkTo(ReleaseController.class).slash(\"api\" + RELEASES_URL).withRel(\"releases\"));\n         return resource;\n     }\n \n+    private void executeFossologyProcess(String releaseId, boolean markFossologyProcessOutdated)\n+            throws TException, IOException {\n+        User user = restControllerHelper.getSw360UserFromAuthentication();\n+        String attachmentId = validateNumberOfSrcAttached(releaseId, user);\n+\n+        if (markFossologyProcessOutdated) {\n+            log.info(\"Marking FOSSology process outdated for Release : \" + releaseId);\n+            releaseService.markFossologyProcessOutdated(releaseId, user);\n+        }\n+\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+\n+        ExternalToolProcess fossologyProcess = releaseService.getFossologyProcess(release);\n+        if (fossologyProcess != null && isFOSSologyProcessCompleted(fossologyProcess)) {\n+            log.info(\"FOSSology process for Release : \" + releaseId + \" already completed.\");\n+            return;\n+        }\n+\n+        final ExternalToolProcess fossologyProcessFinal = fossologyProcess;\n+\n+        Runnable asyncRunnable = () -> wrapTException(() -> {\n+            ReentrantLock lockObj = locks.apply(releaseId);\n+            ScheduledExecutorService service = null;\n+\n+            try {\n+                if (lockObj.tryLock()) {\n+                    service = Executors.newSingleThreadScheduledExecutor();\n+                    triggerUploadScanAndReportStep(service, fossologyProcessFinal, release, user, attachmentId);\n+                }\n+            } catch (Exception exp) {\n+                log.error(String.format(\"Release : %s .Error occured while triggering Fossology Process . %s\",\n+                        new Object[] { releaseId, exp.getMessage() }));\n+            } finally {\n+                log.info(\"Release : \" + releaseId + \" .Fossology Process exited, removing lock.\");\n+                if (service != null)\n+                    service.shutdownNow();\n+                if (lockObj.isLocked())\n+                    lockObj.unlock();\n+                mapOfLocks.remove(releaseId);\n+            }\n+        });\n+\n+        Thread asyncThread = new Thread(asyncRunnable);\n+        asyncThread.start();\n+    }\n+\n+    private String validateNumberOfSrcAttached(String releaseId, User user) throws TException {\n+        Release release = releaseService.getReleaseForUserById(releaseId, user);\n+        List<Attachment> listOfSources = release.getAttachments().parallelStream()\n+                .filter(attachment -> attachment.getAttachmentType() == AttachmentType.SOURCE)\n+                .collect(Collectors.toList());\n+        int noOfSrcAttached = listOfSources.size();\n+\n+        if (noOfSrcAttached != 1) {\n+            throw new HttpMessageNotReadableException(\"There has to be exactly one source attachment, but there are \"\n+                    + noOfSrcAttached + \" at this release. Please come back once you corrected that.\");\n+        }\n+\n+        return listOfSources.get(0).getAttachmentContentId();\n+    }\n+\n+    private void triggerUploadScanAndReportStep(final ScheduledExecutorService service,\n+            final ExternalToolProcess fossologyProcess, final Release release, final User user,\n+            final String attachmentId) throws TException {\n+\n+        int scanStatusCheckCount = 0, scanTriggerRetriesCount = 0, reportGenerateTriggerRetries = 0,\n+                reportGeneratestatusCheckCount = 0,maxRetries=15;\n+        ScheduledFuture<ExternalToolProcess> future = null;\n+        String releaseId = release.getId();\n+        ExternalToolProcess fossologyProcessLocal = fossologyProcess;\n+        byte[] byteArray = new byte[0];\n+        try (ByteArrayOutputStream attachmentOutputStream = new ByteArrayOutputStream();\n+                InputStream streamToAttachments = attachmentService.getStreamToAttachments(\n+                        Collections.singleton(attachmentService.getAttachmentContent(attachmentId)), user, release)) {\n+            FileCopyUtils.copy(streamToAttachments, attachmentOutputStream);\n+            byteArray = attachmentOutputStream.toByteArray();\n+        } catch (IOException exp) {\n+            log.error(\"Release : \" + releaseId + \" .Error occured while calculation attachment size.Attachment ID : \"\n+                    + attachmentId);\n+        }\n+\n+        int attachmentSizeinMB = (byteArray.length / 1024) / 1024;\n+        int timeIntervalToCheckUnpackScanStatus = attachmentSizeinMB <= 5 ? 10 : 2 * attachmentSizeinMB;\n+\n+        log.info(String.format(\n+                \"Release : %s .Size of source is %s MB, Time interval to check scan and unpack status %s sec\",\n+                new Object[] { releaseId, attachmentSizeinMB, timeIntervalToCheckUnpackScanStatus }));\n+\n+        Callable<ExternalToolProcess> processRunnable = new Callable<ExternalToolProcess>() {\n+            public ExternalToolProcess call() throws Exception {\n+                return releaseService.fossologyProcess(releaseId, user);\n+            }\n+        };\n+\n+        if (fossologyProcessLocal == null || !isUploadStepCompletedSuccessfully(fossologyProcessLocal, releaseId)) {\n+            log.info(\"Release : \" + releaseId + \" .Triggering Upload Step.\");\n+            fossologyProcessLocal = releaseService.fossologyProcess(releaseId, user);\n+        }\n+\n+        if (isUploadStepCompletedSuccessfully(fossologyProcessLocal, releaseId) && releaseService.isUnpackSuccessFull(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef"}, "originalPosition": 232}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb9f2bad92339d0d8a1b44ccfa92052659f0d76f", "author": {"user": {"login": "JaideepPalit", "name": "Jaideep Palit"}}, "url": "https://github.com/eclipse/sw360/commit/bb9f2bad92339d0d8a1b44ccfa92052659f0d76f", "committedDate": "2020-03-06T11:28:08Z", "message": "feat(REST): Trigger FOSSology process and check status.\n\nSigned-off-by: Jaideep Palit <jaideep.palit@siemens.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "author": {"user": {"login": "JaideepPalit", "name": "Jaideep Palit"}}, "url": "https://github.com/eclipse/sw360/commit/628bb7fc20b0ad95a37acad2a3125cbf7ec589ef", "committedDate": "2020-02-27T14:28:59Z", "message": "feat(REST): Trigger FOSSology process and check status.\n\nSigned-off-by: Jaideep Palit <jaideep.palit@siemens.com>"}, "afterCommit": {"oid": "bb9f2bad92339d0d8a1b44ccfa92052659f0d76f", "author": {"user": {"login": "JaideepPalit", "name": "Jaideep Palit"}}, "url": "https://github.com/eclipse/sw360/commit/bb9f2bad92339d0d8a1b44ccfa92052659f0d76f", "committedDate": "2020-03-06T11:28:08Z", "message": "feat(REST): Trigger FOSSology process and check status.\n\nSigned-off-by: Jaideep Palit <jaideep.palit@siemens.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNzA2NTE4", "url": "https://github.com/eclipse/sw360/pull/777#pullrequestreview-371706518", "createdAt": "2020-03-10T06:32:53Z", "commit": {"oid": "bb9f2bad92339d0d8a1b44ccfa92052659f0d76f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4886, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}