{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5OTc5NjI4", "number": 1512, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNTowMTo1NlrOEtFYmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNTowMTo1NlrOEtFYmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NzA5NTkyOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/Driver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNTowMTo1NlrOHgrS0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNToxOToxOVrOHgsHPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyNTgwOA==", "bodyText": "Please change order of @param to match arguments and also add one for 'command' argument.", "url": "https://github.com/apache/hive/pull/1512#discussion_r504025808", "createdAt": "2020-10-13T15:01:56Z", "author": {"login": "belugabehr"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/Driver.java", "diffHunk": "@@ -588,15 +353,280 @@ private void runInternal(String command, boolean alreadyCompiled) throws Command\n     SessionState.getPerfLogger().cleanupPerfLogMetrics();\n   }\n \n-  @Override\n-  public boolean isFetchingTable() {\n-    return driverContext.getFetchTask() != null;\n+  public void lockAndRespond() throws CommandProcessorException {\n+    // Assumes the query has already been compiled\n+    if (driverContext.getPlan() == null) {\n+      throw new IllegalStateException(\n+          \"No previously compiled query for driver - queryId=\" + driverContext.getQueryState().getQueryId());\n+    }\n+\n+    try {\n+      driverTxnHandler.acquireLocksIfNeeded();\n+    } catch (CommandProcessorException cpe) {\n+      driverTxnHandler.rollback(cpe);\n+      throw cpe;\n+    }\n   }\n \n-  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n   @Override\n-  public boolean getResults(List res) throws IOException {\n-    if (driverState.isDestroyed() || driverState.isClosed()) {\n+  public CommandProcessorResponse compileAndRespond(String command) throws CommandProcessorException {\n+    return compileAndRespond(command, false);\n+  }\n+\n+  public CommandProcessorResponse compileAndRespond(String command, boolean cleanupTxnList)\n+      throws CommandProcessorException {\n+    try {\n+      compileInternal(command, false);\n+      return new CommandProcessorResponse(getSchema(), null);\n+    } catch (CommandProcessorException cpe) {\n+      throw cpe;\n+    } finally {\n+      if (cleanupTxnList) {\n+        // Valid txn list might be generated for a query compiled using this command, thus we need to reset it\n+        driverTxnHandler.cleanupTxnList();\n+      }\n+    }\n+  }\n+\n+  private void compileInternal(String command, boolean deferClose) throws CommandProcessorException {\n+    Metrics metrics = MetricsFactory.getInstance();\n+    if (metrics != null) {\n+      metrics.incrementCounter(MetricsConstant.WAITING_COMPILE_OPS, 1);\n+    }\n+\n+    PerfLogger perfLogger = SessionState.getPerfLogger(true);\n+    perfLogger.perfLogBegin(CLASS_NAME, PerfLogger.WAIT_COMPILE);\n+\n+    try (CompileLock compileLock = CompileLockFactory.newInstance(driverContext.getConf(), command)) {\n+      boolean success = compileLock.tryAcquire();\n+\n+      perfLogger.perfLogEnd(CLASS_NAME, PerfLogger.WAIT_COMPILE);\n+\n+      if (metrics != null) {\n+        metrics.decrementCounter(MetricsConstant.WAITING_COMPILE_OPS, 1);\n+      }\n+      if (!success) {\n+        String errorMessage = ErrorMsg.COMPILE_LOCK_TIMED_OUT.getErrorCodedMsg();\n+        throw DriverUtils.createProcessorException(driverContext, ErrorMsg.COMPILE_LOCK_TIMED_OUT.getErrorCode(),\n+            errorMessage, null, null);\n+      }\n+\n+      try {\n+        compile(command, true, deferClose);\n+      } catch (CommandProcessorException cpe) {\n+        try {\n+          driverTxnHandler.endTransactionAndCleanup(false);\n+        } catch (LockException e) {\n+          LOG.warn(\"Exception in releasing locks. \" + StringUtils.stringifyException(e));\n+        }\n+        throw cpe;\n+      }\n+    }\n+    //Save compile-time PerfLogging for WebUI.\n+    //Execution-time Perf logs are done by either another thread's PerfLogger\n+    //or a reset PerfLogger.\n+    driverContext.getQueryDisplay().setPerfLogStarts(QueryDisplay.Phase.COMPILATION, perfLogger.getStartTimes());\n+    driverContext.getQueryDisplay().setPerfLogEnds(QueryDisplay.Phase.COMPILATION, perfLogger.getEndTimes());\n+  }\n+\n+  /**\n+   * Compiles a new HQL command, but potentially resets taskID counter. Not resetting task counter is useful for\n+   * generating re-entrant QL queries.\n+   *\n+   * @param command  The HiveQL query to compile\n+   * @param resetTaskIds Resets taskID counter if true.\n+   * @return 0 for ok\n+   */\n+  public int compile(String command, boolean resetTaskIds) {\n+    try {\n+      compile(command, resetTaskIds, false);\n+      return 0;\n+    } catch (CommandProcessorException cpr) {\n+      return cpr.getErrorCode();\n+    }\n+  }\n+\n+  /**\n+   * Compiles an HQL command, creates an execution plan for it.\n+   *\n+   * @param deferClose indicates if the close/destroy should be deferred when the process has been interrupted, it\n+   *        should be set to true if the compile is called within another method like runInternal, which defers the\n+   *        close to the called in that method.\n+   * @param resetTaskIds Resets taskID counter if true.\n+   */\n+  @VisibleForTesting\n+  public void compile(String command, boolean resetTaskIds, boolean deferClose) throws CommandProcessorException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9045167c38e3df99ab6f3aee1fd38c31b39d8843"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAzOTIyOQ==", "bodyText": "Thank you @belugabehr, I've fixed these.", "url": "https://github.com/apache/hive/pull/1512#discussion_r504039229", "createdAt": "2020-10-13T15:19:19Z", "author": {"login": "miklosgergely"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/Driver.java", "diffHunk": "@@ -588,15 +353,280 @@ private void runInternal(String command, boolean alreadyCompiled) throws Command\n     SessionState.getPerfLogger().cleanupPerfLogMetrics();\n   }\n \n-  @Override\n-  public boolean isFetchingTable() {\n-    return driverContext.getFetchTask() != null;\n+  public void lockAndRespond() throws CommandProcessorException {\n+    // Assumes the query has already been compiled\n+    if (driverContext.getPlan() == null) {\n+      throw new IllegalStateException(\n+          \"No previously compiled query for driver - queryId=\" + driverContext.getQueryState().getQueryId());\n+    }\n+\n+    try {\n+      driverTxnHandler.acquireLocksIfNeeded();\n+    } catch (CommandProcessorException cpe) {\n+      driverTxnHandler.rollback(cpe);\n+      throw cpe;\n+    }\n   }\n \n-  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n   @Override\n-  public boolean getResults(List res) throws IOException {\n-    if (driverState.isDestroyed() || driverState.isClosed()) {\n+  public CommandProcessorResponse compileAndRespond(String command) throws CommandProcessorException {\n+    return compileAndRespond(command, false);\n+  }\n+\n+  public CommandProcessorResponse compileAndRespond(String command, boolean cleanupTxnList)\n+      throws CommandProcessorException {\n+    try {\n+      compileInternal(command, false);\n+      return new CommandProcessorResponse(getSchema(), null);\n+    } catch (CommandProcessorException cpe) {\n+      throw cpe;\n+    } finally {\n+      if (cleanupTxnList) {\n+        // Valid txn list might be generated for a query compiled using this command, thus we need to reset it\n+        driverTxnHandler.cleanupTxnList();\n+      }\n+    }\n+  }\n+\n+  private void compileInternal(String command, boolean deferClose) throws CommandProcessorException {\n+    Metrics metrics = MetricsFactory.getInstance();\n+    if (metrics != null) {\n+      metrics.incrementCounter(MetricsConstant.WAITING_COMPILE_OPS, 1);\n+    }\n+\n+    PerfLogger perfLogger = SessionState.getPerfLogger(true);\n+    perfLogger.perfLogBegin(CLASS_NAME, PerfLogger.WAIT_COMPILE);\n+\n+    try (CompileLock compileLock = CompileLockFactory.newInstance(driverContext.getConf(), command)) {\n+      boolean success = compileLock.tryAcquire();\n+\n+      perfLogger.perfLogEnd(CLASS_NAME, PerfLogger.WAIT_COMPILE);\n+\n+      if (metrics != null) {\n+        metrics.decrementCounter(MetricsConstant.WAITING_COMPILE_OPS, 1);\n+      }\n+      if (!success) {\n+        String errorMessage = ErrorMsg.COMPILE_LOCK_TIMED_OUT.getErrorCodedMsg();\n+        throw DriverUtils.createProcessorException(driverContext, ErrorMsg.COMPILE_LOCK_TIMED_OUT.getErrorCode(),\n+            errorMessage, null, null);\n+      }\n+\n+      try {\n+        compile(command, true, deferClose);\n+      } catch (CommandProcessorException cpe) {\n+        try {\n+          driverTxnHandler.endTransactionAndCleanup(false);\n+        } catch (LockException e) {\n+          LOG.warn(\"Exception in releasing locks. \" + StringUtils.stringifyException(e));\n+        }\n+        throw cpe;\n+      }\n+    }\n+    //Save compile-time PerfLogging for WebUI.\n+    //Execution-time Perf logs are done by either another thread's PerfLogger\n+    //or a reset PerfLogger.\n+    driverContext.getQueryDisplay().setPerfLogStarts(QueryDisplay.Phase.COMPILATION, perfLogger.getStartTimes());\n+    driverContext.getQueryDisplay().setPerfLogEnds(QueryDisplay.Phase.COMPILATION, perfLogger.getEndTimes());\n+  }\n+\n+  /**\n+   * Compiles a new HQL command, but potentially resets taskID counter. Not resetting task counter is useful for\n+   * generating re-entrant QL queries.\n+   *\n+   * @param command  The HiveQL query to compile\n+   * @param resetTaskIds Resets taskID counter if true.\n+   * @return 0 for ok\n+   */\n+  public int compile(String command, boolean resetTaskIds) {\n+    try {\n+      compile(command, resetTaskIds, false);\n+      return 0;\n+    } catch (CommandProcessorException cpr) {\n+      return cpr.getErrorCode();\n+    }\n+  }\n+\n+  /**\n+   * Compiles an HQL command, creates an execution plan for it.\n+   *\n+   * @param deferClose indicates if the close/destroy should be deferred when the process has been interrupted, it\n+   *        should be set to true if the compile is called within another method like runInternal, which defers the\n+   *        close to the called in that method.\n+   * @param resetTaskIds Resets taskID counter if true.\n+   */\n+  @VisibleForTesting\n+  public void compile(String command, boolean resetTaskIds, boolean deferClose) throws CommandProcessorException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyNTgwOA=="}, "originalCommit": {"oid": "9045167c38e3df99ab6f3aee1fd38c31b39d8843"}, "originalPosition": 388}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 279, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}