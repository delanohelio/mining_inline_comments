{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5NjkzMjE0", "number": 1470, "title": "HIVE-24120 Plugin for external DatabaseProduct in standalone HMS", "bodyText": "This PR implements the design outlined in this doc:\nhttps://docs.google.com/document/d/1lR2IDiqjMiG1zb7o_4sEa6wULzH1CvtRodsghCtxYWY/edit#heading=h.imzjzzvayyi1\nQuoting from the design doc:\nGoals\nIntroduce a way to load a custom jar in metastore which can override database specific DatabaseProduct which provides the database specific SQL code execution in Hive Metastore.\nNon-goals\nWe do not want to evolve metastore into a Datanucleus (ORM) like software which transparently handles all the different nuances of supporting multiple database types. The pluggable custom instance of the DatabaseProduct must be ANSI SQL compliant since the MetastoreDirectSQL and SqlGenerator assumes that. We would like to keep the changes to MetastoreDirectSQL at minimum and assume that all the supported databases are ANSI SQL compliant.\nUpgrade and performance testing of custom implementations.\nSchematool to be able to load this custom jar to execute schema initialization and upgrade scripts. This is not currently in scope of this document.\nAbout this PR\nAs per the design, DatabaseProduct has been refactored as a class.\nIt's a singleton class, which gets instantiated the first time method determineDatabaseProduct is invoked.\nExisting SQL logic that was scattered around other classes has been moved to methods in this class. This makes it\npossible for an external plugin to override the existing SQL logic.\n@vihangk1 @thejasmn @nrg4878", "createdAt": "2020-09-04T13:35:35Z", "url": "https://github.com/apache/hive/pull/1470", "merged": true, "mergeCommit": {"oid": "5af8a612f844482a02fd8e59aec25c854ba8a175"}, "closed": true, "closedAt": "2020-10-19T20:04:08Z", "author": {"login": "gatorblue"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdEoBHMgH2gAyNDc5NjkzMjE0OmIzY2NlODdlZmFmZTA1M2JmY2UwYmQxNDFiM2JjMDczMzdkZjZkM2Q=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUJ3JVAFqTUwNjAzNjI0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b3cce87efafe053bfce0bd141b3bc07337df6d3d", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/b3cce87efafe053bfce0bd141b3bc07337df6d3d", "committedDate": "2020-09-01T14:10:21Z", "message": "new configs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e8a05ac44d12861b7cfdcbb0426e0ca16b28afb", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/8e8a05ac44d12861b7cfdcbb0426e0ca16b28afb", "committedDate": "2020-09-02T14:23:17Z", "message": "refactor DatabaseProduct"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d309193379edca9369a4d407de8d865541659308", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/d309193379edca9369a4d407de8d865541659308", "committedDate": "2020-09-02T15:23:16Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1506264af89c51a9b8f029e06f0e13550d56fe0", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/d1506264af89c51a9b8f029e06f0e13550d56fe0", "committedDate": "2020-09-02T15:55:50Z", "message": "changes for EXTERNAL product"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6ec00ee04acbbac8452fa770b5c2d2376f74ea6", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/a6ec00ee04acbbac8452fa770b5c2d2376f74ea6", "committedDate": "2020-09-02T16:03:55Z", "message": "rename ProductId as DbType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e20de878e3447df95a608da5f723c73d40ca72a", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/4e20de878e3447df95a608da5f723c73d40ca72a", "committedDate": "2020-09-02T16:26:45Z", "message": "account for EXTERNAL in SQL generator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b37739038473f2f980ac312e969e16ef1c32e60", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/5b37739038473f2f980ac312e969e16ef1c32e60", "committedDate": "2020-09-03T15:58:14Z", "message": "Add overridable methods to class DatabaseProduct"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6abd2cd96a86655449a452033922abdbe134fe4", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/c6abd2cd96a86655449a452033922abdbe134fe4", "committedDate": "2020-09-03T16:34:30Z", "message": "Use new methods in DatabaseProduct consistently"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0d3ba72e39f986027425cce3cde6ac431376a2b", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/e0d3ba72e39f986027425cce3cde6ac431376a2b", "committedDate": "2020-09-03T18:02:09Z", "message": "add method to get database properties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57388e2d3a6ed8802c2b8cb0bcc94532c87d0b78", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/57388e2d3a6ed8802c2b8cb0bcc94532c87d0b78", "committedDate": "2020-09-04T03:34:32Z", "message": "Address TODO and cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b8c0ba8aeeb427489e0921a39b65fde86cfbfda", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/2b8c0ba8aeeb427489e0921a39b65fde86cfbfda", "committedDate": "2020-09-04T12:55:40Z", "message": "remove conf field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7b10a68adc98a702362d36096a574fc7f67cffc", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/c7b10a68adc98a702362d36096a574fc7f67cffc", "committedDate": "2020-09-04T15:32:03Z", "message": "update references to Derby and MySQL in hcatalog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/4bfb30c5f7a80bbc5f6d5323075ed15359afcc92", "committedDate": "2020-09-04T18:48:18Z", "message": "Simplify instantiation logic and accoung for concurrency"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MTMzMzA3", "url": "https://github.com/apache/hive/pull/1470#pullrequestreview-489133307", "createdAt": "2020-09-15T21:51:15Z", "commit": {"oid": "b3cce87efafe053bfce0bd141b3bc07337df6d3d"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMTo1MToxNVrOHSWN_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMjozMDowNVrOHSYHMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAwMDQ0NQ==", "bodyText": "nit, can you fix the formatting here?", "url": "https://github.com/apache/hive/pull/1470#discussion_r489000445", "createdAt": "2020-09-15T21:51:15Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-common/src/main/java/org/apache/hadoop/hive/metastore/conf/MetastoreConf.java", "diffHunk": "@@ -1337,6 +1337,13 @@ public static ConfVars getMetaConf(String name) {\n     HIVE_TXN_STATS_ENABLED(\"hive.txn.stats.enabled\", \"hive.txn.stats.enabled\", true,\n         \"Whether Hive supports transactional stats (accurate stats for transactional tables)\"),\n \n+    // External RDBMS support\n+    USE_CUSTOM_RDBMS(\"metastore.use.custom.database.product\",\n+            \"hive.metastore.use.custom.database.product\", false,\n+            \"Use an external RDBMS for the metastore\"),\n+    CUSTOM_RDBMS_CLASSNAME(\"metastore.custom.database.product.classname\", \"hive.metastore.custom.database.product.classname\", \"none\",\n+          \"Hook for external RDBMS. This class will be instantiated only when metastore.use.custom.database.product is set to true.\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3cce87efafe053bfce0bd141b3bc07337df6d3d"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAyNDc0Ng==", "bodyText": "I think instead of this getting initialized in the static block, it would be better to pass the configuration object from the HiveMetastore.java in a constructor", "url": "https://github.com/apache/hive/pull/1470#discussion_r489024746", "createdAt": "2020-09-15T22:21:12Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,646 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, EXTERNAL, OTHER};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  static {\n+    final Configuration conf = MetastoreConf.newMetastoreConf();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAyNzQzNw==", "bodyText": "Its getting a bit confusing with the usage of external, other, custom. Can this be avoided? If not, we should document it somewhere in this class.", "url": "https://github.com/apache/hive/pull/1470#discussion_r489027437", "createdAt": "2020-09-15T22:24:42Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,646 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, EXTERNAL, OTHER};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  static {\n+    final Configuration conf = MetastoreConf.newMetastoreConf();\n+    // Check if we are using an external database product\n+    boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+    if (isExternal) {\n+      // The DatabaseProduct will be created by instantiating an external class via\n+      // reflection. The external class can override any method in the current class\n+      String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+      \n+      if (className != null) {\n+        try {\n+          theDatabaseProduct = (DatabaseProduct)\n+              ReflectionUtils.newInstance(Class.forName(className), conf);\n+\n+          theDatabaseProduct.dbType = DbType.EXTERNAL;\n+        }catch (Exception e) {\n+          LOG.warn(\"Unable to instantiate custom database product. Reverting to default\", e);\n+        }\n+      }\n+      else {\n+        LOG.warn(\"metastore.use.custom.database.product was set, \" +\n+                 \"but metastore.custom.database.product.classname was not. Reverting to default\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Private constructor for singleton class\n+   * @param id\n+   */\n+  private DatabaseProduct() {}\n+  \n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String OTHER_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n+  public static DatabaseProduct determineDatabaseProduct(String productName) {\n+    DbType dbt;\n+\n     if (productName == null) {\n-      return OTHER;\n+      productName = OTHER_NAME;\n     }\n+\n     productName = productName.toLowerCase();\n-    if (productName.contains(\"derby\")) {\n-      return DERBY;\n-    } else if (productName.contains(\"microsoft sql server\")) {\n-      return SQLSERVER;\n-    } else if (productName.contains(\"mysql\")) {\n-      return MYSQL;\n-    } else if (productName.contains(\"oracle\")) {\n-      return ORACLE;\n-    } else if (productName.contains(\"postgresql\")) {\n-      return POSTGRES;\n+\n+    if (productName.contains(DERBY_NAME)) {\n+      dbt = DbType.DERBY;\n+    } else if (productName.contains(SQL_SERVER_NAME)) {\n+      dbt = DbType.SQLSERVER;\n+    } else if (productName.contains(MYSQL_NAME)) {\n+      dbt = DbType.MYSQL;\n+    } else if (productName.contains(ORACLE_NAME)) {\n+      dbt = DbType.ORACLE;\n+    } else if (productName.contains(POSTGRESQL_NAME)) {\n+      dbt = DbType.POSTGRES;\n     } else {\n-      return OTHER;\n+      dbt = DbType.OTHER;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+      if (theDatabaseProduct == null) {\n+        theDatabaseProduct = new DatabaseProduct();\n+      }\n+  \n+      theDatabaseProduct.dbType = dbt;\n+    }\n+    return theDatabaseProduct;\n+  }\n+\n+  public final boolean isDERBY() {\n+    return dbType == DbType.DERBY;\n+  }\n+\n+  public final boolean isMYSQL() {\n+    return dbType == DbType.MYSQL;\n   }\n \n-  public static boolean isDeadlock(DatabaseProduct dbProduct, SQLException e) {\n+  public final boolean isORACLE() {\n+    return dbType == DbType.ORACLE;\n+  }\n+\n+  public final boolean isSQLSERVER() {\n+    return dbType == DbType.SQLSERVER;\n+  }\n+\n+  public final boolean isPOSTGRES() {\n+    return dbType == DbType.POSTGRES;\n+  }\n+\n+  public final boolean isEXTERNAL() {\n+    return dbType == DbType.EXTERNAL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAyOTU4OQ==", "bodyText": "why not add a happy path check on line 100 which returns theDatabaseProduct if it is not null.", "url": "https://github.com/apache/hive/pull/1470#discussion_r489029589", "createdAt": "2020-09-15T22:27:38Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,646 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, EXTERNAL, OTHER};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  static {\n+    final Configuration conf = MetastoreConf.newMetastoreConf();\n+    // Check if we are using an external database product\n+    boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+    if (isExternal) {\n+      // The DatabaseProduct will be created by instantiating an external class via\n+      // reflection. The external class can override any method in the current class\n+      String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+      \n+      if (className != null) {\n+        try {\n+          theDatabaseProduct = (DatabaseProduct)\n+              ReflectionUtils.newInstance(Class.forName(className), conf);\n+\n+          theDatabaseProduct.dbType = DbType.EXTERNAL;\n+        }catch (Exception e) {\n+          LOG.warn(\"Unable to instantiate custom database product. Reverting to default\", e);\n+        }\n+      }\n+      else {\n+        LOG.warn(\"metastore.use.custom.database.product was set, \" +\n+                 \"but metastore.custom.database.product.classname was not. Reverting to default\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Private constructor for singleton class\n+   * @param id\n+   */\n+  private DatabaseProduct() {}\n+  \n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String OTHER_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n+  public static DatabaseProduct determineDatabaseProduct(String productName) {\n+    DbType dbt;\n+\n     if (productName == null) {\n-      return OTHER;\n+      productName = OTHER_NAME;\n     }\n+\n     productName = productName.toLowerCase();\n-    if (productName.contains(\"derby\")) {\n-      return DERBY;\n-    } else if (productName.contains(\"microsoft sql server\")) {\n-      return SQLSERVER;\n-    } else if (productName.contains(\"mysql\")) {\n-      return MYSQL;\n-    } else if (productName.contains(\"oracle\")) {\n-      return ORACLE;\n-    } else if (productName.contains(\"postgresql\")) {\n-      return POSTGRES;\n+\n+    if (productName.contains(DERBY_NAME)) {\n+      dbt = DbType.DERBY;\n+    } else if (productName.contains(SQL_SERVER_NAME)) {\n+      dbt = DbType.SQLSERVER;\n+    } else if (productName.contains(MYSQL_NAME)) {\n+      dbt = DbType.MYSQL;\n+    } else if (productName.contains(ORACLE_NAME)) {\n+      dbt = DbType.ORACLE;\n+    } else if (productName.contains(POSTGRESQL_NAME)) {\n+      dbt = DbType.POSTGRES;\n     } else {\n-      return OTHER;\n+      dbt = DbType.OTHER;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAzMDgxNg==", "bodyText": "Can we refactor these lines (108-119) into a separate private method which can be used like below at line 100?\nif (theDatabaseProduct != null) {\nPreconditions.checkState(this.dbType == getDbType(productName));\nreturn theDatabaseProduct;\n}", "url": "https://github.com/apache/hive/pull/1470#discussion_r489030816", "createdAt": "2020-09-15T22:29:12Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,646 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, EXTERNAL, OTHER};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  static {\n+    final Configuration conf = MetastoreConf.newMetastoreConf();\n+    // Check if we are using an external database product\n+    boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+    if (isExternal) {\n+      // The DatabaseProduct will be created by instantiating an external class via\n+      // reflection. The external class can override any method in the current class\n+      String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+      \n+      if (className != null) {\n+        try {\n+          theDatabaseProduct = (DatabaseProduct)\n+              ReflectionUtils.newInstance(Class.forName(className), conf);\n+\n+          theDatabaseProduct.dbType = DbType.EXTERNAL;\n+        }catch (Exception e) {\n+          LOG.warn(\"Unable to instantiate custom database product. Reverting to default\", e);\n+        }\n+      }\n+      else {\n+        LOG.warn(\"metastore.use.custom.database.product was set, \" +\n+                 \"but metastore.custom.database.product.classname was not. Reverting to default\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Private constructor for singleton class\n+   * @param id\n+   */\n+  private DatabaseProduct() {}\n+  \n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String OTHER_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n+  public static DatabaseProduct determineDatabaseProduct(String productName) {\n+    DbType dbt;\n+\n     if (productName == null) {\n-      return OTHER;\n+      productName = OTHER_NAME;\n     }\n+\n     productName = productName.toLowerCase();\n-    if (productName.contains(\"derby\")) {\n-      return DERBY;\n-    } else if (productName.contains(\"microsoft sql server\")) {\n-      return SQLSERVER;\n-    } else if (productName.contains(\"mysql\")) {\n-      return MYSQL;\n-    } else if (productName.contains(\"oracle\")) {\n-      return ORACLE;\n-    } else if (productName.contains(\"postgresql\")) {\n-      return POSTGRES;\n+\n+    if (productName.contains(DERBY_NAME)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAzMTQ3NQ==", "bodyText": "Curious to know why we would need this? If we don't do this may be we can make theDatabaseProduct as a final variable.", "url": "https://github.com/apache/hive/pull/1470#discussion_r489031475", "createdAt": "2020-09-15T22:30:05Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,646 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, EXTERNAL, OTHER};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  static {\n+    final Configuration conf = MetastoreConf.newMetastoreConf();\n+    // Check if we are using an external database product\n+    boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+    if (isExternal) {\n+      // The DatabaseProduct will be created by instantiating an external class via\n+      // reflection. The external class can override any method in the current class\n+      String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+      \n+      if (className != null) {\n+        try {\n+          theDatabaseProduct = (DatabaseProduct)\n+              ReflectionUtils.newInstance(Class.forName(className), conf);\n+\n+          theDatabaseProduct.dbType = DbType.EXTERNAL;\n+        }catch (Exception e) {\n+          LOG.warn(\"Unable to instantiate custom database product. Reverting to default\", e);\n+        }\n+      }\n+      else {\n+        LOG.warn(\"metastore.use.custom.database.product was set, \" +\n+                 \"but metastore.custom.database.product.classname was not. Reverting to default\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Private constructor for singleton class\n+   * @param id\n+   */\n+  private DatabaseProduct() {}\n+  \n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String OTHER_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n+  public static DatabaseProduct determineDatabaseProduct(String productName) {\n+    DbType dbt;\n+\n     if (productName == null) {\n-      return OTHER;\n+      productName = OTHER_NAME;\n     }\n+\n     productName = productName.toLowerCase();\n-    if (productName.contains(\"derby\")) {\n-      return DERBY;\n-    } else if (productName.contains(\"microsoft sql server\")) {\n-      return SQLSERVER;\n-    } else if (productName.contains(\"mysql\")) {\n-      return MYSQL;\n-    } else if (productName.contains(\"oracle\")) {\n-      return ORACLE;\n-    } else if (productName.contains(\"postgresql\")) {\n-      return POSTGRES;\n+\n+    if (productName.contains(DERBY_NAME)) {\n+      dbt = DbType.DERBY;\n+    } else if (productName.contains(SQL_SERVER_NAME)) {\n+      dbt = DbType.SQLSERVER;\n+    } else if (productName.contains(MYSQL_NAME)) {\n+      dbt = DbType.MYSQL;\n+    } else if (productName.contains(ORACLE_NAME)) {\n+      dbt = DbType.ORACLE;\n+    } else if (productName.contains(POSTGRESQL_NAME)) {\n+      dbt = DbType.POSTGRES;\n     } else {\n-      return OTHER;\n+      dbt = DbType.OTHER;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+      if (theDatabaseProduct == null) {\n+        theDatabaseProduct = new DatabaseProduct();\n+      }\n+  \n+      theDatabaseProduct.dbType = dbt;\n+    }\n+    return theDatabaseProduct;\n+  }\n+\n+  public final boolean isDERBY() {\n+    return dbType == DbType.DERBY;\n+  }\n+\n+  public final boolean isMYSQL() {\n+    return dbType == DbType.MYSQL;\n   }\n \n-  public static boolean isDeadlock(DatabaseProduct dbProduct, SQLException e) {\n+  public final boolean isORACLE() {\n+    return dbType == DbType.ORACLE;\n+  }\n+\n+  public final boolean isSQLSERVER() {\n+    return dbType == DbType.SQLSERVER;\n+  }\n+\n+  public final boolean isPOSTGRES() {\n+    return dbType == DbType.POSTGRES;\n+  }\n+\n+  public final boolean isEXTERNAL() {\n+    return dbType == DbType.EXTERNAL;\n+  }\n+\n+  public final boolean isOTHER() {\n+    return dbType == DbType.OTHER;\n+  }\n+\n+  public boolean isDeadlock(SQLException e) {\n     return e instanceof SQLTransactionRollbackException\n-        || ((dbProduct == MYSQL || dbProduct == POSTGRES || dbProduct == SQLSERVER)\n+        || ((isMYSQL() || isPOSTGRES() || isSQLSERVER() || isEXTERNAL())\n             && \"40001\".equals(e.getSQLState()))\n-        || (dbProduct == POSTGRES && \"40P01\".equals(e.getSQLState()))\n-        || (dbProduct == ORACLE && (e.getMessage() != null && (e.getMessage().contains(\"deadlock detected\")\n+        || (isPOSTGRES() && \"40P01\".equals(e.getSQLState()))\n+        || (isORACLE() && (e.getMessage() != null && (e.getMessage().contains(\"deadlock detected\")\n             || e.getMessage().contains(\"can't serialize access for this transaction\"))));\n   }\n \n   /**\n    * Whether the RDBMS has restrictions on IN list size (explicit, or poor perf-based).\n    */\n-  public static boolean needsInBatching(DatabaseProduct dbType) {\n-    return dbType == ORACLE || dbType == SQLSERVER;\n+  protected boolean needsInBatching() {\n+    return isORACLE() || isSQLSERVER();\n   }\n \n   /**\n    * Whether the RDBMS has a bug in join and filter operation order described in DERBY-6358.\n    */\n-  public static boolean hasJoinOperationOrderBug(DatabaseProduct dbType) {\n-    return dbType == DERBY || dbType == ORACLE || dbType == POSTGRES;\n+  protected boolean hasJoinOperationOrderBug() {\n+    return isDERBY() || isORACLE() || isPOSTGRES();\n   }\n \n-  public static String getHiveSchemaPostfix(DatabaseProduct dbType) {\n+  public String getHiveSchemaPostfix() {\n     switch (dbType) {\n     case SQLSERVER:\n       return \"mssql\";\n     case DERBY:\n     case MYSQL:\n     case POSTGRES:\n     case ORACLE:\n+    case EXTERNAL:\n       return dbType.name().toLowerCase();\n     case OTHER:\n     default:\n       return null;\n     }\n   }\n+\n+  public static void reset() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92"}, "originalPosition": 206}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14a2f1bd15dd8377f00a55a49528c3ee2c3b1457", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/14a2f1bd15dd8377f00a55a49528c3ee2c3b1457", "committedDate": "2020-09-19T13:31:02Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/6d5a9424e55074a9625b76c1bffc1a201b3b1b8a", "committedDate": "2020-09-19T14:33:37Z", "message": "Add unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NjY5NDcx", "url": "https://github.com/apache/hive/pull/1470#pullrequestreview-498669471", "createdAt": "2020-09-29T16:26:04Z", "commit": {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMDo1NjoyNVrOHctfwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMTowOToxN1rOHct4zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NzU4NQ==", "bodyText": "Its interesting that I don't see \"hive.metastore.db.type\" configuration in MetastoreConf which I think is an unrelated bug. It would be great if you could add more details here. May be say \"Use a external RDBMS which not in the list of natively supported databases eg. Derby, Mysql, Oracle, Postgres, MSSQL as defined by hive.metastore.db.type. If this configuration is true the metastore.custom.database.product.classname must be set to a valid classname.\"", "url": "https://github.com/apache/hive/pull/1470#discussion_r499867585", "createdAt": "2020-10-05T20:56:25Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-common/src/main/java/org/apache/hadoop/hive/metastore/conf/MetastoreConf.java", "diffHunk": "@@ -1337,6 +1337,15 @@ public static ConfVars getMetaConf(String name) {\n     HIVE_TXN_STATS_ENABLED(\"hive.txn.stats.enabled\", \"hive.txn.stats.enabled\", true,\n         \"Whether Hive supports transactional stats (accurate stats for transactional tables)\"),\n \n+    // External RDBMS support\n+    USE_CUSTOM_RDBMS(\"metastore.use.custom.database.product\",\n+            \"hive.metastore.use.custom.database.product\", false,\n+            \"Use an external RDBMS for the metastore\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2OTEyNw==", "bodyText": "The Overriding DbType: is bit confusing. Why is that log useful?", "url": "https://github.com/apache/hive/pull/1470#discussion_r499869127", "createdAt": "2020-10-05T20:59:12Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,666 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import com.google.common.base.Preconditions;\n+\n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, CUSTOM, UNDEFINED};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  Configuration myConf;\n+  /**\n+   * Protected constructor for singleton class\n+   * @param id\n+   */\n+  protected DatabaseProduct() {}\n+\n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String UNDEFINED_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n-    if (productName == null) {\n-      return OTHER;\n+  public static DatabaseProduct determineDatabaseProduct(String productName, Configuration c) {\n+    DbType dbt;\n+\n+    if (theDatabaseProduct != null) {\n+      Preconditions.checkState(theDatabaseProduct.dbType == getDbType(productName));\n+      return theDatabaseProduct;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+\n+      if (productName == null) {\n+        productName = UNDEFINED_NAME;\n+      }\n+\n+      dbt = getDbType(productName);\n+\n+      // Check for null again in case of race condition\n+      if (theDatabaseProduct == null) {\n+        final Configuration conf = c!= null ? c : MetastoreConf.newMetastoreConf();\n+        // Check if we are using an external database product\n+        boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+        if (isExternal) {\n+          // The DatabaseProduct will be created by instantiating an external class via\n+          // reflection. The external class can override any method in the current class\n+          String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+          \n+          if (className != null) {\n+            try {\n+              theDatabaseProduct = (DatabaseProduct)\n+                  ReflectionUtils.newInstance(Class.forName(className), conf);\n+  \n+              LOG.info(String.format(\"Using custom RDBMS %s. Overriding DbType: %s\", className, dbt));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2OTY5Nw==", "bodyText": "nit, the else could go in the same line as 113 as per the coding conventions.", "url": "https://github.com/apache/hive/pull/1470#discussion_r499869697", "createdAt": "2020-10-05T21:00:15Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,666 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import com.google.common.base.Preconditions;\n+\n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, CUSTOM, UNDEFINED};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  Configuration myConf;\n+  /**\n+   * Protected constructor for singleton class\n+   * @param id\n+   */\n+  protected DatabaseProduct() {}\n+\n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String UNDEFINED_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n-    if (productName == null) {\n-      return OTHER;\n+  public static DatabaseProduct determineDatabaseProduct(String productName, Configuration c) {\n+    DbType dbt;\n+\n+    if (theDatabaseProduct != null) {\n+      Preconditions.checkState(theDatabaseProduct.dbType == getDbType(productName));\n+      return theDatabaseProduct;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+\n+      if (productName == null) {\n+        productName = UNDEFINED_NAME;\n+      }\n+\n+      dbt = getDbType(productName);\n+\n+      // Check for null again in case of race condition\n+      if (theDatabaseProduct == null) {\n+        final Configuration conf = c!= null ? c : MetastoreConf.newMetastoreConf();\n+        // Check if we are using an external database product\n+        boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+        if (isExternal) {\n+          // The DatabaseProduct will be created by instantiating an external class via\n+          // reflection. The external class can override any method in the current class\n+          String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+          \n+          if (className != null) {\n+            try {\n+              theDatabaseProduct = (DatabaseProduct)\n+                  ReflectionUtils.newInstance(Class.forName(className), conf);\n+  \n+              LOG.info(String.format(\"Using custom RDBMS %s. Overriding DbType: %s\", className, dbt));\n+              dbt = DbType.CUSTOM;\n+            }catch (Exception e) {\n+              LOG.warn(\"Caught exception instantiating custom database product. Reverting to \" + dbt, e);\n+            }\n+          }\n+          else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MDA5Mw==", "bodyText": "I believe its better to throw an exception here with the appropriate message.", "url": "https://github.com/apache/hive/pull/1470#discussion_r499870093", "createdAt": "2020-10-05T21:01:02Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,666 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import com.google.common.base.Preconditions;\n+\n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, CUSTOM, UNDEFINED};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  Configuration myConf;\n+  /**\n+   * Protected constructor for singleton class\n+   * @param id\n+   */\n+  protected DatabaseProduct() {}\n+\n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String UNDEFINED_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n-    if (productName == null) {\n-      return OTHER;\n+  public static DatabaseProduct determineDatabaseProduct(String productName, Configuration c) {\n+    DbType dbt;\n+\n+    if (theDatabaseProduct != null) {\n+      Preconditions.checkState(theDatabaseProduct.dbType == getDbType(productName));\n+      return theDatabaseProduct;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+\n+      if (productName == null) {\n+        productName = UNDEFINED_NAME;\n+      }\n+\n+      dbt = getDbType(productName);\n+\n+      // Check for null again in case of race condition\n+      if (theDatabaseProduct == null) {\n+        final Configuration conf = c!= null ? c : MetastoreConf.newMetastoreConf();\n+        // Check if we are using an external database product\n+        boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+        if (isExternal) {\n+          // The DatabaseProduct will be created by instantiating an external class via\n+          // reflection. The external class can override any method in the current class\n+          String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+          \n+          if (className != null) {\n+            try {\n+              theDatabaseProduct = (DatabaseProduct)\n+                  ReflectionUtils.newInstance(Class.forName(className), conf);\n+  \n+              LOG.info(String.format(\"Using custom RDBMS %s. Overriding DbType: %s\", className, dbt));\n+              dbt = DbType.CUSTOM;\n+            }catch (Exception e) {\n+              LOG.warn(\"Caught exception instantiating custom database product. Reverting to \" + dbt, e);\n+            }\n+          }\n+          else {\n+            LOG.warn(\"Unexpected: metastore.use.custom.database.product was set, \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MDQ3NQ==", "bodyText": "Is there a good reason to catch the exception and reverting the dbt? Should'nt we throw a MetaException so that HMS doesn't start if the configuration is invalid.", "url": "https://github.com/apache/hive/pull/1470#discussion_r499870475", "createdAt": "2020-10-05T21:01:52Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,666 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import com.google.common.base.Preconditions;\n+\n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, CUSTOM, UNDEFINED};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  Configuration myConf;\n+  /**\n+   * Protected constructor for singleton class\n+   * @param id\n+   */\n+  protected DatabaseProduct() {}\n+\n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String UNDEFINED_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n-    if (productName == null) {\n-      return OTHER;\n+  public static DatabaseProduct determineDatabaseProduct(String productName, Configuration c) {\n+    DbType dbt;\n+\n+    if (theDatabaseProduct != null) {\n+      Preconditions.checkState(theDatabaseProduct.dbType == getDbType(productName));\n+      return theDatabaseProduct;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+\n+      if (productName == null) {\n+        productName = UNDEFINED_NAME;\n+      }\n+\n+      dbt = getDbType(productName);\n+\n+      // Check for null again in case of race condition\n+      if (theDatabaseProduct == null) {\n+        final Configuration conf = c!= null ? c : MetastoreConf.newMetastoreConf();\n+        // Check if we are using an external database product\n+        boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+        if (isExternal) {\n+          // The DatabaseProduct will be created by instantiating an external class via\n+          // reflection. The external class can override any method in the current class\n+          String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+          \n+          if (className != null) {\n+            try {\n+              theDatabaseProduct = (DatabaseProduct)\n+                  ReflectionUtils.newInstance(Class.forName(className), conf);\n+  \n+              LOG.info(String.format(\"Using custom RDBMS %s. Overriding DbType: %s\", className, dbt));\n+              dbt = DbType.CUSTOM;\n+            }catch (Exception e) {\n+              LOG.warn(\"Caught exception instantiating custom database product. Reverting to \" + dbt, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MTM3Mg==", "bodyText": "Thanks for the context. In such a case I think it would be good to annotate this method as @VisibleForTesting", "url": "https://github.com/apache/hive/pull/1470#discussion_r499871372", "createdAt": "2020-10-05T21:03:39Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,646 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, EXTERNAL, OTHER};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  static {\n+    final Configuration conf = MetastoreConf.newMetastoreConf();\n+    // Check if we are using an external database product\n+    boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+    if (isExternal) {\n+      // The DatabaseProduct will be created by instantiating an external class via\n+      // reflection. The external class can override any method in the current class\n+      String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+      \n+      if (className != null) {\n+        try {\n+          theDatabaseProduct = (DatabaseProduct)\n+              ReflectionUtils.newInstance(Class.forName(className), conf);\n+\n+          theDatabaseProduct.dbType = DbType.EXTERNAL;\n+        }catch (Exception e) {\n+          LOG.warn(\"Unable to instantiate custom database product. Reverting to default\", e);\n+        }\n+      }\n+      else {\n+        LOG.warn(\"metastore.use.custom.database.product was set, \" +\n+                 \"but metastore.custom.database.product.classname was not. Reverting to default\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Private constructor for singleton class\n+   * @param id\n+   */\n+  private DatabaseProduct() {}\n+  \n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String OTHER_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n+  public static DatabaseProduct determineDatabaseProduct(String productName) {\n+    DbType dbt;\n+\n     if (productName == null) {\n-      return OTHER;\n+      productName = OTHER_NAME;\n     }\n+\n     productName = productName.toLowerCase();\n-    if (productName.contains(\"derby\")) {\n-      return DERBY;\n-    } else if (productName.contains(\"microsoft sql server\")) {\n-      return SQLSERVER;\n-    } else if (productName.contains(\"mysql\")) {\n-      return MYSQL;\n-    } else if (productName.contains(\"oracle\")) {\n-      return ORACLE;\n-    } else if (productName.contains(\"postgresql\")) {\n-      return POSTGRES;\n+\n+    if (productName.contains(DERBY_NAME)) {\n+      dbt = DbType.DERBY;\n+    } else if (productName.contains(SQL_SERVER_NAME)) {\n+      dbt = DbType.SQLSERVER;\n+    } else if (productName.contains(MYSQL_NAME)) {\n+      dbt = DbType.MYSQL;\n+    } else if (productName.contains(ORACLE_NAME)) {\n+      dbt = DbType.ORACLE;\n+    } else if (productName.contains(POSTGRESQL_NAME)) {\n+      dbt = DbType.POSTGRES;\n     } else {\n-      return OTHER;\n+      dbt = DbType.OTHER;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+      if (theDatabaseProduct == null) {\n+        theDatabaseProduct = new DatabaseProduct();\n+      }\n+  \n+      theDatabaseProduct.dbType = dbt;\n+    }\n+    return theDatabaseProduct;\n+  }\n+\n+  public final boolean isDERBY() {\n+    return dbType == DbType.DERBY;\n+  }\n+\n+  public final boolean isMYSQL() {\n+    return dbType == DbType.MYSQL;\n   }\n \n-  public static boolean isDeadlock(DatabaseProduct dbProduct, SQLException e) {\n+  public final boolean isORACLE() {\n+    return dbType == DbType.ORACLE;\n+  }\n+\n+  public final boolean isSQLSERVER() {\n+    return dbType == DbType.SQLSERVER;\n+  }\n+\n+  public final boolean isPOSTGRES() {\n+    return dbType == DbType.POSTGRES;\n+  }\n+\n+  public final boolean isEXTERNAL() {\n+    return dbType == DbType.EXTERNAL;\n+  }\n+\n+  public final boolean isOTHER() {\n+    return dbType == DbType.OTHER;\n+  }\n+\n+  public boolean isDeadlock(SQLException e) {\n     return e instanceof SQLTransactionRollbackException\n-        || ((dbProduct == MYSQL || dbProduct == POSTGRES || dbProduct == SQLSERVER)\n+        || ((isMYSQL() || isPOSTGRES() || isSQLSERVER() || isEXTERNAL())\n             && \"40001\".equals(e.getSQLState()))\n-        || (dbProduct == POSTGRES && \"40P01\".equals(e.getSQLState()))\n-        || (dbProduct == ORACLE && (e.getMessage() != null && (e.getMessage().contains(\"deadlock detected\")\n+        || (isPOSTGRES() && \"40P01\".equals(e.getSQLState()))\n+        || (isORACLE() && (e.getMessage() != null && (e.getMessage().contains(\"deadlock detected\")\n             || e.getMessage().contains(\"can't serialize access for this transaction\"))));\n   }\n \n   /**\n    * Whether the RDBMS has restrictions on IN list size (explicit, or poor perf-based).\n    */\n-  public static boolean needsInBatching(DatabaseProduct dbType) {\n-    return dbType == ORACLE || dbType == SQLSERVER;\n+  protected boolean needsInBatching() {\n+    return isORACLE() || isSQLSERVER();\n   }\n \n   /**\n    * Whether the RDBMS has a bug in join and filter operation order described in DERBY-6358.\n    */\n-  public static boolean hasJoinOperationOrderBug(DatabaseProduct dbType) {\n-    return dbType == DERBY || dbType == ORACLE || dbType == POSTGRES;\n+  protected boolean hasJoinOperationOrderBug() {\n+    return isDERBY() || isORACLE() || isPOSTGRES();\n   }\n \n-  public static String getHiveSchemaPostfix(DatabaseProduct dbType) {\n+  public String getHiveSchemaPostfix() {\n     switch (dbType) {\n     case SQLSERVER:\n       return \"mssql\";\n     case DERBY:\n     case MYSQL:\n     case POSTGRES:\n     case ORACLE:\n+    case EXTERNAL:\n       return dbType.name().toLowerCase();\n     case OTHER:\n     default:\n       return null;\n     }\n   }\n+\n+  public static void reset() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAzMTQ3NQ=="}, "originalCommit": {"oid": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3Mzk5OQ==", "bodyText": "It looks like when this line is executed the dbType is null. Do you need to initialize a default value of dbType = UNDEFINED?", "url": "https://github.com/apache/hive/pull/1470#discussion_r499873999", "createdAt": "2020-10-05T21:09:17Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,666 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import com.google.common.base.Preconditions;\n+\n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, CUSTOM, UNDEFINED};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  Configuration myConf;\n+  /**\n+   * Protected constructor for singleton class\n+   * @param id\n+   */\n+  protected DatabaseProduct() {}\n+\n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String UNDEFINED_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n-    if (productName == null) {\n-      return OTHER;\n+  public static DatabaseProduct determineDatabaseProduct(String productName, Configuration c) {\n+    DbType dbt;\n+\n+    if (theDatabaseProduct != null) {\n+      Preconditions.checkState(theDatabaseProduct.dbType == getDbType(productName));\n+      return theDatabaseProduct;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+\n+      if (productName == null) {\n+        productName = UNDEFINED_NAME;\n+      }\n+\n+      dbt = getDbType(productName);\n+\n+      // Check for null again in case of race condition\n+      if (theDatabaseProduct == null) {\n+        final Configuration conf = c!= null ? c : MetastoreConf.newMetastoreConf();\n+        // Check if we are using an external database product\n+        boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+        if (isExternal) {\n+          // The DatabaseProduct will be created by instantiating an external class via\n+          // reflection. The external class can override any method in the current class\n+          String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+          \n+          if (className != null) {\n+            try {\n+              theDatabaseProduct = (DatabaseProduct)\n+                  ReflectionUtils.newInstance(Class.forName(className), conf);\n+  \n+              LOG.info(String.format(\"Using custom RDBMS %s. Overriding DbType: %s\", className, dbt));\n+              dbt = DbType.CUSTOM;\n+            }catch (Exception e) {\n+              LOG.warn(\"Caught exception instantiating custom database product. Reverting to \" + dbt, e);\n+            }\n+          }\n+          else {\n+            LOG.warn(\"Unexpected: metastore.use.custom.database.product was set, \" +\n+                     \"but metastore.custom.database.product.classname was not. Reverting to \" + dbt);\n+          }\n+        }\n+\n+        if (theDatabaseProduct == null) {\n+          theDatabaseProduct = new DatabaseProduct();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a"}, "originalPosition": 108}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d02aa1dc0835ca1875da64660f3b6389f65656c1", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/d02aa1dc0835ca1875da64660f3b6389f65656c1", "committedDate": "2020-10-09T22:23:48Z", "message": "Address more review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27e9feb20cbd734a4cfdcab4653caa5935e879a8", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/27e9feb20cbd734a4cfdcab4653caa5935e879a8", "committedDate": "2020-10-14T21:47:24Z", "message": "Vihang's changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a65c6cf9cb552e7c34bfb449a419abfde0a58b6", "author": {"user": {"login": "gatorblue", "name": null}}, "url": "https://github.com/apache/hive/commit/3a65c6cf9cb552e7c34bfb449a419abfde0a58b6", "committedDate": "2020-10-15T12:21:54Z", "message": "Cleanup conf in unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MDM2MjQy", "url": "https://github.com/apache/hive/pull/1470#pullrequestreview-506036242", "createdAt": "2020-10-09T23:29:08Z", "commit": {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzoyOTowOFrOHfbETw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMDozODowMFrOHhkKzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMTM3NQ==", "bodyText": "Sorry, may be should have been clearer. I meant adding the text \"Use an external RDBMS which is not in the list of natively supported databases (e.g. Derby, Mysql, Oracle, Postgres, MSSQL), as defined by hive.metastore.db.type. If this configuration is true, the metastore.custom.database.product.classname must be set to a valid class name\" as the fourth argument in the USE_CUSTOM_RDBMS. IIRC this description is used to generate the template for default hive-site.xml so that the description is present in the xml file itself.", "url": "https://github.com/apache/hive/pull/1470#discussion_r502711375", "createdAt": "2020-10-09T23:29:08Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-common/src/main/java/org/apache/hadoop/hive/metastore/conf/MetastoreConf.java", "diffHunk": "@@ -1337,6 +1337,15 @@ public static ConfVars getMetaConf(String name) {\n     HIVE_TXN_STATS_ENABLED(\"hive.txn.stats.enabled\", \"hive.txn.stats.enabled\", true,\n         \"Whether Hive supports transactional stats (accurate stats for transactional tables)\"),\n \n+    // External RDBMS support\n+    USE_CUSTOM_RDBMS(\"metastore.use.custom.database.product\",\n+            \"hive.metastore.use.custom.database.product\", false,\n+            \"Use an external RDBMS for the metastore\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NzU4NQ=="}, "originalCommit": {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1NzY0Nw==", "bodyText": "line 91 is initializing a local variable dbt. I see that theDatabaseProducte.dbType = dbt is executed outside synchronized block later below. We should probably move it in the synchronized block.", "url": "https://github.com/apache/hive/pull/1470#discussion_r504957647", "createdAt": "2020-10-14T20:38:00Z", "author": {"login": "vihangk1"}, "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,666 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import com.google.common.base.Preconditions;\n+\n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, CUSTOM, UNDEFINED};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  Configuration myConf;\n+  /**\n+   * Protected constructor for singleton class\n+   * @param id\n+   */\n+  protected DatabaseProduct() {}\n+\n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String UNDEFINED_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n-    if (productName == null) {\n-      return OTHER;\n+  public static DatabaseProduct determineDatabaseProduct(String productName, Configuration c) {\n+    DbType dbt;\n+\n+    if (theDatabaseProduct != null) {\n+      Preconditions.checkState(theDatabaseProduct.dbType == getDbType(productName));\n+      return theDatabaseProduct;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+\n+      if (productName == null) {\n+        productName = UNDEFINED_NAME;\n+      }\n+\n+      dbt = getDbType(productName);\n+\n+      // Check for null again in case of race condition\n+      if (theDatabaseProduct == null) {\n+        final Configuration conf = c!= null ? c : MetastoreConf.newMetastoreConf();\n+        // Check if we are using an external database product\n+        boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+        if (isExternal) {\n+          // The DatabaseProduct will be created by instantiating an external class via\n+          // reflection. The external class can override any method in the current class\n+          String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+          \n+          if (className != null) {\n+            try {\n+              theDatabaseProduct = (DatabaseProduct)\n+                  ReflectionUtils.newInstance(Class.forName(className), conf);\n+  \n+              LOG.info(String.format(\"Using custom RDBMS %s. Overriding DbType: %s\", className, dbt));\n+              dbt = DbType.CUSTOM;\n+            }catch (Exception e) {\n+              LOG.warn(\"Caught exception instantiating custom database product. Reverting to \" + dbt, e);\n+            }\n+          }\n+          else {\n+            LOG.warn(\"Unexpected: metastore.use.custom.database.product was set, \" +\n+                     \"but metastore.custom.database.product.classname was not. Reverting to \" + dbt);\n+          }\n+        }\n+\n+        if (theDatabaseProduct == null) {\n+          theDatabaseProduct = new DatabaseProduct();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3Mzk5OQ=="}, "originalCommit": {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a"}, "originalPosition": 108}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3284, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}