{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2MDgyOTg3", "number": 1492, "title": "HIVE-24154: Missing simplification opportunity with IN and EQUALS cla\u2026", "bodyText": "\u2026uses\n\nWhat changes were proposed in this pull request?\n\nWhy are the changes needed?\n\nDoes this PR introduce any user-facing change?\n\nHow was this patch tested?", "createdAt": "2020-09-13T01:24:38Z", "url": "https://github.com/apache/hive/pull/1492", "merged": true, "mergeCommit": {"oid": "94093e86e96786e36756fef802938cd65ef4fd0e"}, "closed": true, "closedAt": "2020-09-30T20:07:31Z", "author": {"login": "jcamachor"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdIYCOhgH2gAyNDg2MDgyOTg3OmE0MDZmMTA0ZGJjOTI5ZWE3ZjA5MjE5OGJmM2JlNjhhNDg3NDRjNmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdN5U2mgFqTQ5OTI0NDQxNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/a406f104dbc929ea7f092198bf3be68a48744c6d", "committedDate": "2020-09-13T05:48:47Z", "message": "HIVE-24154: Missing simplification opportunity with IN and EQUALS clauses"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eaa9b23157d2edad344200b19756ae59ef113b7f", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/eaa9b23157d2edad344200b19756ae59ef113b7f", "committedDate": "2020-09-13T05:42:00Z", "message": "moving internal class"}, "afterCommit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/a406f104dbc929ea7f092198bf3be68a48744c6d", "committedDate": "2020-09-13T05:48:47Z", "message": "HIVE-24154: Missing simplification opportunity with IN and EQUALS clauses"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MjkzOTY3", "url": "https://github.com/apache/hive/pull/1492#pullrequestreview-487293967", "createdAt": "2020-09-13T10:23:03Z", "commit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxMDoyMzowM1rOHQ7TJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxMDoyNzowMlrOHQ7UwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMDgyMw==", "bodyText": "oh my; Constrain had it's constructor arguments swapped! what a typo!", "url": "https://github.com/apache/hive/pull/1492#discussion_r487510823", "createdAt": "2020-09-13T10:23:03Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -599,7 +587,7 @@ public ConstraintGroup(RexNode rexNode) {\n           if (constraint == null) {\n             throw new SemanticException(\"Unable to find constraint which was earlier added.\");\n           }\n-          ret.add(constraint.exprNode);\n+          ret.add(constraint.constNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMTE2OQ==", "bodyText": "I see that this patch works - but would have thinked that we didn't need something like this anymore - because IN is opened in an early phase - so Calcite should see a bunch of ANDs and ORs - and if that's true - RexSimplify could make this simplification - and there would be no need to enhance PointLookup...\nI wonder how the IN was retained ...or re-created...", "url": "https://github.com/apache/hive/pull/1492#discussion_r487511169", "createdAt": "2020-09-13T10:26:23Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/test/results/clientpositive/perf/tez/constraints/cbo_query74.q.out", "diffHunk": "@@ -147,7 +147,7 @@ HiveSortLimit(sort0=[$2], sort1=[$0], sort2=[$1], dir0=[ASC], dir1=[ASC], dir2=[\n                           HiveProject(ss_sold_date_sk=[$0], ss_customer_sk=[$3], ss_net_paid=[$20])\n                             HiveTableScan(table=[[default, store_sales]], table:alias=[store_sales])\n                       HiveProject(d_date_sk=[$0])\n-                        HiveFilter(condition=[AND(=($1, 1999), IN($1, 1998, 1999))])\n+                        HiveFilter(condition=[=($1, 1999)])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMTIzMw==", "bodyText": "note: we have RexNode-s are comparable; this string2expr stuff is not neccessarily needed anymore", "url": "https://github.com/apache/hive/pull/1492#discussion_r487511233", "createdAt": "2020-09-13T10:27:02Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -734,6 +721,30 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n               }\n               operands.remove(i);\n               --i;\n+            } else if (operand.getKind() == SqlKind.EQUALS) {\n+              Constraint c = Constraint.of(operand);\n+              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+                continue;\n+              }\n+              String ref = c.exprNode.toString();\n+              stringToExpr.put(ref, c.exprNode);\n+              if (inLHSExprToRHSExprs.containsKey(ref)) {\n+                String expr = c.constNode.toString();\n+                stringToExpr.put(expr, c.constNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d"}, "originalPosition": 333}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db4dfda745b761bbb103eed87f2e7680f454b234", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/db4dfda745b761bbb103eed87f2e7680f454b234", "committedDate": "2020-09-13T16:34:25Z", "message": "q file updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a0e9aca03d96186a54cbd2edaa15df37f8701b7", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/5a0e9aca03d96186a54cbd2edaa15df37f8701b7", "committedDate": "2020-09-13T16:45:49Z", "message": "removing string-based mapping"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4ODE0MDIy", "url": "https://github.com/apache/hive/pull/1492#pullrequestreview-488814022", "createdAt": "2020-09-15T15:36:54Z", "commit": {"oid": "5a0e9aca03d96186a54cbd2edaa15df37f8701b7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTozNjo1NFrOHSH6cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTozNjo1NFrOHSH6cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2NjA2Ng==", "bodyText": "I think this may not neccessarily false; consider:\nx=1 and x=2\n\nwhich is not true; but in case x is null - the result of the AND will be null\ninstead of false this could be only rewritten to x is null and null; but even in that case there could be other stuff which might affect null/false;\nso I think we may not do a return here.", "url": "https://github.com/apache/hive/pull/1492#discussion_r488766066", "createdAt": "2020-09-15T15:36:54Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -727,44 +708,58 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n                 }\n               } else {\n                 for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  String expr = inCall.getOperands().get(j).toString();\n-                  inLHSExprToRHSExprs.put(ref, expr);\n-                  stringToExpr.put(expr, inCall.getOperands().get(j));\n+                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+                }\n+              }\n+              operands.remove(i);\n+              --i;\n+            } else if (operand.getKind() == SqlKind.EQUALS) {\n+              Constraint c = Constraint.of(operand);\n+              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+                continue;\n+              }\n+              RexNode ref = c.exprNode;\n+              if (inLHSExprToRHSExprs.containsKey(ref)) {\n+                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n+                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+                  // Note that Multimap does not keep a key if all its values are removed.\n+                  // Hence, since there are no common expressions and it is within an AND,\n+                  // we should return false\n+                  return rexBuilder.makeLiteral(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0e9aca03d96186a54cbd2edaa15df37f8701b7"}, "originalPosition": 385}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e206afc08bb0845333a8088a8a4223ae32bdfc60", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/e206afc08bb0845333a8088a8a4223ae32bdfc60", "committedDate": "2020-09-15T18:36:32Z", "message": "addressing review comment : nullability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "beeefbfccd764e22e146b95baadf966e708f1d0d", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/beeefbfccd764e22e146b95baadf966e708f1d0d", "committedDate": "2020-09-15T19:07:19Z", "message": "Revert \"addressing review comment : nullability\"\n\nThis reverts commit e206afc08bb0845333a8088a8a4223ae32bdfc60."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2e443e4e0b686bc2fe0f164f84d8863300ac33e", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/a2e443e4e0b686bc2fe0f164f84d8863300ac33e", "committedDate": "2020-09-15T19:59:21Z", "message": "addressing review comment : nullability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db45b1d73397dea3699811bb43f7083486241be7", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/db45b1d73397dea3699811bb43f7083486241be7", "committedDate": "2020-09-15T20:15:05Z", "message": "Merge remote-tracking branch 'apache/master' into HIVE-24154"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NTkxODU1", "url": "https://github.com/apache/hive/pull/1492#pullrequestreview-489591855", "createdAt": "2020-09-16T12:53:08Z", "commit": {"oid": "db45b1d73397dea3699811bb43f7083486241be7"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjo1MzowOFrOHSvXYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMzowNDoyN1rOHSv0zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxMjQ0OQ==", "bodyText": "I believe this would not need to be a CASE it could be an AND as well\n(x IS NULL OR y IS NULL) AND null\n\nbut I know - it won't make much difference - the CASE might be more readbale :)", "url": "https://github.com/apache/hive/pull/1492#discussion_r489412449", "createdAt": "2020-09-16T12:53:08Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);\n+            }\n+          } else {\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              inLHSExprToRHSExprs.put(ref, constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              operands.remove(i);\n-              --i;\n             }\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n-          break;\n-        case OR:\n-          // IN clauses need to be combined by keeping all elements\n-          operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-              }\n-              operands.remove(i);\n-              --i;\n+          operands.remove(i);\n+          --i;\n+        } else if (operand.getKind() == SqlKind.EQUALS) {\n+          Constraint c = Constraint.of(operand);\n+          if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+            continue;\n+          }\n+          if (c.exprNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.exprNode);\n+          }\n+          if (c.constNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.constNode);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+            inLHSExprToRHSExprs.get(c.exprNode).retainAll(Collections.singleton(c.constNode));\n+            if (!inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, c.exprNode, inLHSExprToRHSNullableExprs);\n             }\n+          } else {\n+            inLHSExprToRHSExprs.put(c.exprNode, c.constNode);\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n-          break;\n-        default:\n-          return super.visitCall(call);\n+          operands.remove(i);\n+          --i;\n+        }\n       }\n-      return node;\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode handleOR(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping all elements\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          for (int j = 1; j < inCall.getOperands().size(); j++) {\n+            inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+          }\n+          operands.remove(i);\n+          --i;\n+        }\n+      }\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode createResultFromEmptySet(RexBuilder rexBuilder,\n+        RexNode ref, Multimap<RexNode, RexNode> inLHSExprToRHSNullableExprs) {\n+      if (inLHSExprToRHSNullableExprs.containsKey(ref)) {\n+        // We handle possible null values in the expressions.\n+        List<RexNode> nullableExprs =\n+            inLHSExprToRHSNullableExprs.get(ref)\n+                .stream()\n+                .map(n -> rexBuilder.makeCall(SqlStdOperatorTable.IS_NULL, ImmutableList.of(n)))\n+                .collect(Collectors.toList());\n+        return rexBuilder.makeCall(SqlStdOperatorTable.CASE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db45b1d73397dea3699811bb43f7083486241be7"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxMzU4Mg==", "bodyText": "at this point - aren't we in the middle of processing all the operands of the AND?\nx IN (1,2) AND x IN (3,4) AND y IN (1,2)\n\nI suspect for the above expression we don't know anything about y (yet) - isn't that a problem?", "url": "https://github.com/apache/hive/pull/1492#discussion_r489413582", "createdAt": "2020-09-16T12:54:56Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db45b1d73397dea3699811bb43f7083486241be7"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxOTk4Mg==", "bodyText": "right now I don't fully agree with this logic - if we have an expression like:\nx IN (1,2) AND x in (3,4) and y IN (5,6)\n\nit's clear that we may only return false or null; but I think we may still need to choose false based on the other expressions; for the above:\n\nwhen x is null, y=5 then the result will be null\nbut when x is null, y=1 then the result will be false\n\nin light of this reasoning it seem to me that this starts looking more and more sophisticated....\nI think it might worth a try to see if these \"early-return-type\" simplifications kick-in a lot or not - and as an alternative approach consider removing them instead of saving them.\nI think at some point we should run the simplification earlier when the ORs are still open - so that it could analyze-it properly", "url": "https://github.com/apache/hive/pull/1492#discussion_r489419982", "createdAt": "2020-09-16T13:04:27Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);\n+            }\n+          } else {\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              inLHSExprToRHSExprs.put(ref, constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              operands.remove(i);\n-              --i;\n             }\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n-          break;\n-        case OR:\n-          // IN clauses need to be combined by keeping all elements\n-          operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-              }\n-              operands.remove(i);\n-              --i;\n+          operands.remove(i);\n+          --i;\n+        } else if (operand.getKind() == SqlKind.EQUALS) {\n+          Constraint c = Constraint.of(operand);\n+          if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+            continue;\n+          }\n+          if (c.exprNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.exprNode);\n+          }\n+          if (c.constNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.constNode);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+            inLHSExprToRHSExprs.get(c.exprNode).retainAll(Collections.singleton(c.constNode));\n+            if (!inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, c.exprNode, inLHSExprToRHSNullableExprs);\n             }\n+          } else {\n+            inLHSExprToRHSExprs.put(c.exprNode, c.constNode);\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n-          break;\n-        default:\n-          return super.visitCall(call);\n+          operands.remove(i);\n+          --i;\n+        }\n       }\n-      return node;\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode handleOR(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping all elements\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          for (int j = 1; j < inCall.getOperands().size(); j++) {\n+            inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+          }\n+          operands.remove(i);\n+          --i;\n+        }\n+      }\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode createResultFromEmptySet(RexBuilder rexBuilder,\n+        RexNode ref, Multimap<RexNode, RexNode> inLHSExprToRHSNullableExprs) {\n+      if (inLHSExprToRHSNullableExprs.containsKey(ref)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db45b1d73397dea3699811bb43f7083486241be7"}, "originalPosition": 205}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b140c78d5a5a08aea2f198af546ac961a9c470f6", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/b140c78d5a5a08aea2f198af546ac961a9c470f6", "committedDate": "2020-09-16T14:53:53Z", "message": "Merge remote-tracking branch 'apache/master' into HIVE-24154"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "193fb77a8d425c68e5e4c8848fcaf68f9bb863f6", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/193fb77a8d425c68e5e4c8848fcaf68f9bb863f6", "committedDate": "2020-09-16T19:50:44Z", "message": "addressing latest comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Mzg2MzM0", "url": "https://github.com/apache/hive/pull/1492#pullrequestreview-497386334", "createdAt": "2020-09-28T10:34:06Z", "commit": {"oid": "193fb77a8d425c68e5e4c8848fcaf68f9bb863f6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMDozNDowNlrOHY33QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMDozNDowNlrOHY33QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg0MzEzNw==", "bodyText": "Is there any particular reason why do we need this? (I think it was not needed before)\nI believe this will at most only add a cast to wieden nullability", "url": "https://github.com/apache/hive/pull/1492#discussion_r495843137", "createdAt": "2020-09-28T10:34:06Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -757,10 +752,15 @@ private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n         }\n       }\n       // Create IN clauses\n-      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      final List<RexNode> newOperands = createInClauses(rexBuilder,\n+          visitedRefs, inLHSExprToRHSExprs, inLHSExprToRHSNullableExprs);\n       newOperands.addAll(operands);\n       // Return node\n-      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+      RexNode result = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+      if (!result.getType().equals(call.getType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "193fb77a8d425c68e5e4c8848fcaf68f9bb863f6"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c20fb1edb1f4ffc34249b263c02ed1cc9f78110", "author": {"user": {"login": "jcamachor", "name": "Jes\u00fas Camacho Rodr\u00edguez"}}, "url": "https://github.com/apache/hive/commit/8c20fb1edb1f4ffc34249b263c02ed1cc9f78110", "committedDate": "2020-09-28T17:18:39Z", "message": "remove simplification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5MjQ0NDE0", "url": "https://github.com/apache/hive/pull/1492#pullrequestreview-499244414", "createdAt": "2020-09-30T09:25:37Z", "commit": {"oid": "8c20fb1edb1f4ffc34249b263c02ed1cc9f78110"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3312, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}