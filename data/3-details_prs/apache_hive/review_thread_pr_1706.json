{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NDA3MjI0", "number": 1706, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMzoyMDo1NFrOFDL8Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxNDo1OFrOFDN_vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODg1NzMxOnYy", "diffSide": "RIGHT", "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMzoyMDo1NFrOICuAtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzoxMTozNVrOIC6aQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMTkxMA==", "bodyText": "Let's make it shorter: hive.materializedview.rewriting.query.text -> hive.materializedview.rewriting.text or hive.materializedview.rewriting.sql ?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539721910", "createdAt": "2020-12-09T23:20:54Z", "author": {"login": "jcamachor"}, "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "diffHunk": "@@ -1844,6 +1844,9 @@ private static void populateLlapDaemonVarsSet(Set<String> llapDaemonVarsSetLocal\n     // materialized views\n     HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING(\"hive.materializedview.rewriting\", true,\n         \"Whether to try to rewrite queries using the materialized views enabled for rewriting\"),\n+    HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING_QUERY_TEXT(\"hive.materializedview.rewriting.query.text\", true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkyNTA1Nw==", "bodyText": "renamed to hive.materializedview.rewriting.sql", "url": "https://github.com/apache/hive/pull/1706#discussion_r539925057", "createdAt": "2020-12-10T07:11:35Z", "author": {"login": "kasakrisz"}, "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "diffHunk": "@@ -1844,6 +1844,9 @@ private static void populateLlapDaemonVarsSet(Set<String> llapDaemonVarsSetLocal\n     // materialized views\n     HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING(\"hive.materializedview.rewriting\", true,\n         \"Whether to try to rewrite queries using the materialized views enabled for rewriting\"),\n+    HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING_QUERY_TEXT(\"hive.materializedview.rewriting.query.text\", true,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMTkxMA=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODkxMzM1OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/Context.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMzozODoyMVrOICufaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODozNDoxNlrOIC9T4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyOTc2OQ==", "bodyText": "Can we add a comment why we are only enabling this when this config value is true? enableUnparse documentation has a description on why it is not enabled in general. However, it is worth having a comment here, since it is difficult to establish the connection between the config property and the variable.", "url": "https://github.com/apache/hive/pull/1706#discussion_r539729769", "createdAt": "2020-12-09T23:38:21Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/Context.java", "diffHunk": "@@ -336,6 +344,9 @@ private Context(Configuration conf, String executionId)  {\n     opContext = new CompilationOpContext();\n \n     viewsTokenRewriteStreams = new HashMap<>();\n+    enableUnparse =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3MjU3OQ==", "bodyText": "added", "url": "https://github.com/apache/hive/pull/1706#discussion_r539972579", "createdAt": "2020-12-10T08:34:16Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/Context.java", "diffHunk": "@@ -336,6 +344,9 @@ private Context(Configuration conf, String executionId)  {\n     opContext = new CompilationOpContext();\n \n     viewsTokenRewriteStreams = new HashMap<>();\n+    enableUnparse =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyOTc2OQ=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODkxNzI5OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/view/materialized/alter/rebuild/AlterMaterializedViewRebuildAnalyzer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMzozOTozOVrOICuhhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODozNDoyOVrOIC9UeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMDMwOQ==", "bodyText": "Can we add a comment (I know that the code was not added in this patch but it is useful to have some clarification on why this is being done)?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539730309", "createdAt": "2020-12-09T23:39:39Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/view/materialized/alter/rebuild/AlterMaterializedViewRebuildAnalyzer.java", "diffHunk": "@@ -57,7 +57,7 @@ public void analyzeInternal(ASTNode root) throws SemanticException {\n \n     ASTNode tableTree = (ASTNode) root.getChild(0);\n     TableName tableName = getQualifiedTableName(tableTree);\n-    if (ctx.enableUnparse()) {\n+    if (ctx.isScheduledQuery()) {\n       unparseTranslator.addTableNameTranslation(tableTree, SessionState.get().getCurrentDatabase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3MjcyOQ==", "bodyText": "added", "url": "https://github.com/apache/hive/pull/1706#discussion_r539972729", "createdAt": "2020-12-10T08:34:29Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/view/materialized/alter/rebuild/AlterMaterializedViewRebuildAnalyzer.java", "diffHunk": "@@ -57,7 +57,7 @@ public void analyzeInternal(ASTNode root) throws SemanticException {\n \n     ASTNode tableTree = (ASTNode) root.getChild(0);\n     TableName tableName = getQualifiedTableName(tableTree);\n-    if (ctx.enableUnparse()) {\n+    if (ctx.isScheduledQuery()) {\n       unparseTranslator.addTableNameTranslation(tableTree, SessionState.get().getCurrentDatabase());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMDMwOQ=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODkyODI3OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMzo0Mjo0NFrOICunlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODo0NzoxOFrOIC90Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMTg2MQ==", "bodyText": "add javadoc?\nAlso, should this method be renamed to getSQLMatchingMaterializedView or anything more descriptive?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539731861", "createdAt": "2020-12-09T23:42:44Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java", "diffHunk": "@@ -1945,6 +1945,18 @@ public RelOptMaterialization getMaterializedViewForRebuild(String dbName, String\n     }\n   }\n \n+  public List<RelOptMaterialization> getMaterialization(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3Mjk5OQ==", "bodyText": "added comment.", "url": "https://github.com/apache/hive/pull/1706#discussion_r539972999", "createdAt": "2020-12-10T08:34:51Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java", "diffHunk": "@@ -1945,6 +1945,18 @@ public RelOptMaterialization getMaterializedViewForRebuild(String dbName, String\n     }\n   }\n \n+  public List<RelOptMaterialization> getMaterialization(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMTg2MQ=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4MDg3MQ==", "bodyText": "renamed", "url": "https://github.com/apache/hive/pull/1706#discussion_r539980871", "createdAt": "2020-12-10T08:47:18Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java", "diffHunk": "@@ -1945,6 +1945,18 @@ public RelOptMaterialization getMaterializedViewForRebuild(String dbName, String\n     }\n   }\n \n+  public List<RelOptMaterialization> getMaterialization(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMTg2MQ=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODk0Njc4OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMzo0Nzo0MVrOICuyCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMDozMjozNlrOIDCaQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNDUzNw==", "bodyText": "filterAugmentMaterializedViews contains logic that is relevant to incremental computation of MVs, as well as other logic that works specifically for certain plan patterns. For instance, I am not sure we should be calling deriveGroupingSetsMaterializedViews for textual queries, e.g., whether it could lead to incorrect results.\nInstead, should we call getValidMaterializedViews(materializedViews, tablesUsed, false, false, txnMgr)? The caveat is that you will also need to create a method\n  private List<RelOptMaterialization> getValidMaterializedViews(List<Table> materializedViewTables,\n      List<String> tablesUsed, boolean forceMVContentsUpToDate, *boolean tryIncrementalRewriting*,\n      boolean expandGroupingSets, HiveTxnManager txnMgr) throws HiveException {\n\nFor the former calls, you can pass the value of the property HiveConf.getBoolVar(conf, HiveConf.ConfVars.HIVE_MATERIALIZED_VIEW_REWRITING_INCREMENTAL) for tryIncrementalRewriting. For the new call from this method, you should pass false. This will effectively lead to ignoring the MVs if they are outdated.", "url": "https://github.com/apache/hive/pull/1706#discussion_r539734537", "createdAt": "2020-12-09T23:47:41Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java", "diffHunk": "@@ -1945,6 +1945,18 @@ public RelOptMaterialization getMaterializedViewForRebuild(String dbName, String\n     }\n   }\n \n+  public List<RelOptMaterialization> getMaterialization(\n+          String queryString, List<String> tablesUsed, HiveTxnManager txnMgr) throws HiveException {\n+\n+    List<RelOptMaterialization> materializedViews =\n+            HiveMaterializedViewsRegistry.get().getRewritingMaterializedViews(queryString);\n+    if (materializedViews.isEmpty()) {\n+      return Collections.emptyList();\n+    }\n+\n+    return filterAugmentMaterializedViews(materializedViews, tablesUsed, txnMgr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA1NjEyOA==", "bodyText": "refactored this method: instead of calling filterAugmentMaterializedViews iterate through the mvs got from the registry and call HiveMaterializedViewUtils.isOutdatedMaterializedView for each of them. If it returns null or true filter out.\nThe majority of the code in getValidMaterializedViews can be ignored in this scenario because:\n\nall boolean parameters of getValidMaterializedViews is false\nWe pull the MVs from the registry so all of them must exists in the registry\n\nIn case of multiple HS2 instances the registry may not contains all the possible MVs for rewrite but we initiate the lookup using the registry.\nI would extend this sql text based rewrite functionality to able to lookup from the metastore in a follow up patch.", "url": "https://github.com/apache/hive/pull/1706#discussion_r540056128", "createdAt": "2020-12-10T10:32:36Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java", "diffHunk": "@@ -1945,6 +1945,18 @@ public RelOptMaterialization getMaterializedViewForRebuild(String dbName, String\n     }\n   }\n \n+  public List<RelOptMaterialization> getMaterialization(\n+          String queryString, List<String> tablesUsed, HiveTxnManager txnMgr) throws HiveException {\n+\n+    List<RelOptMaterialization> materializedViews =\n+            HiveMaterializedViewsRegistry.get().getRewritingMaterializedViews(queryString);\n+    if (materializedViews.isEmpty()) {\n+      return Collections.emptyList();\n+    }\n+\n+    return filterAugmentMaterializedViews(materializedViews, tablesUsed, txnMgr);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNDUzNw=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTA3MzY1OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/MaterializedViewsCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDozMToyMFrOICv3SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNzoxODozNFrOIDsEww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MjI2NQ==", "bodyText": "We should not call toLowerCase. For instance, it would transform literal values that should be different and then consider them equal, e.g., col1='AaAa' vs col1='Aaaa'.\nIn addition to applying the change, can you add a test for this case to see that rewriting is triggered vs not-triggered?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539752265", "createdAt": "2020-12-10T00:31:20Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/MaterializedViewsCache.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.metadata;\n+\n+import org.apache.calcite.plan.RelOptMaterialization;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiFunction;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Collection for storing {@link RelOptMaterialization}s.\n+ * RelOptMaterialization can be lookup by\n+ * - the Materialized View fully qualified name\n+ * - query text.\n+ * This implementation contains two {@link ConcurrentHashMap} one for name based and one for query text based lookup.\n+ * The map contents are synchronized during each dml operation: Dml operations are performed initially on the map\n+ * which provides name based lookup. The map which provides query text based lookup is updated by lambda expressions\n+ * passed to {@link ConcurrentHashMap#compute(Object, BiFunction)}.\n+ */\n+public class MaterializedViewsCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(MaterializedViewsCache.class);\n+\n+  // Key is the database name. Value a map from the qualified name to the view object.\n+  private final ConcurrentMap<String, ConcurrentMap<String, RelOptMaterialization>> materializedViews =\n+          new ConcurrentHashMap<>();\n+  // Map for looking up materialization by view query text\n+  private final Map<String, List<RelOptMaterialization>> sqlToMaterializedView = new ConcurrentHashMap<>();\n+\n+\n+  public void putIfAbsent(Table materializedViewTable, RelOptMaterialization materialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    // You store the materialized view\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, relOptMaterialization) -> {\n+      List<RelOptMaterialization> materializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+      materializationList.add(materialization);\n+      return materialization;\n+    });\n+\n+    LOG.debug(\"Materialized view {}.{} added to registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  private ConcurrentMap<String, RelOptMaterialization> ensureDbMap(Table materializedViewTable) {\n+    // We are going to create the map for each view in the given database\n+    ConcurrentMap<String, RelOptMaterialization> dbMap =\n+            new ConcurrentHashMap<String, RelOptMaterialization>();\n+    // If we are caching the MV, we include it in the cache\n+    final ConcurrentMap<String, RelOptMaterialization> prevDbMap = materializedViews.putIfAbsent(\n+            materializedViewTable.getDbName(), dbMap);\n+    if (prevDbMap != null) {\n+      dbMap = prevDbMap;\n+    }\n+    return dbMap;\n+  }\n+\n+  public void refresh(\n+          Table oldMaterializedViewTable, Table materializedViewTable, RelOptMaterialization newMaterialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, existingMaterialization) -> {\n+      List<RelOptMaterialization> optMaterializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+\n+      if (existingMaterialization == null) {\n+        // If it was not existing, we just create it\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      Table existingMaterializedViewTable = HiveMaterializedViewUtils.extractTable(existingMaterialization);\n+      if (existingMaterializedViewTable.equals(oldMaterializedViewTable)) {\n+        // If the old version is the same, we replace it\n+        optMaterializationList.remove(existingMaterialization);\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      // Otherwise, we return existing materialization\n+      return existingMaterialization;\n+    });\n+\n+    LOG.debug(\"Refreshed materialized view {}.{} -> {}.{}\",\n+            oldMaterializedViewTable.getDbName(), oldMaterializedViewTable.getTableName(),\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(Table materializedViewTable) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(materializedViewTable.getDbName());\n+    if (dbMap != null) {\n+      // Delete only if the create time for the input materialized view table and the table\n+      // in the map match. Otherwise, keep the one in the map.\n+      dbMap.computeIfPresent(materializedViewTable.getTableName(), (mvTableName, oldMaterialization) -> {\n+        if (HiveMaterializedViewUtils.extractTable(oldMaterialization).equals(materializedViewTable)) {\n+          List<RelOptMaterialization> materializationList =\n+                  sqlToMaterializedView.get(materializedViewTable.getViewExpandedText().toLowerCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczODc1NQ==", "bodyText": "removed toLoverCase() calls.\nAdded test which confirms that lookup is case sensitive now.", "url": "https://github.com/apache/hive/pull/1706#discussion_r540738755", "createdAt": "2020-12-11T07:18:34Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/MaterializedViewsCache.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.metadata;\n+\n+import org.apache.calcite.plan.RelOptMaterialization;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiFunction;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Collection for storing {@link RelOptMaterialization}s.\n+ * RelOptMaterialization can be lookup by\n+ * - the Materialized View fully qualified name\n+ * - query text.\n+ * This implementation contains two {@link ConcurrentHashMap} one for name based and one for query text based lookup.\n+ * The map contents are synchronized during each dml operation: Dml operations are performed initially on the map\n+ * which provides name based lookup. The map which provides query text based lookup is updated by lambda expressions\n+ * passed to {@link ConcurrentHashMap#compute(Object, BiFunction)}.\n+ */\n+public class MaterializedViewsCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(MaterializedViewsCache.class);\n+\n+  // Key is the database name. Value a map from the qualified name to the view object.\n+  private final ConcurrentMap<String, ConcurrentMap<String, RelOptMaterialization>> materializedViews =\n+          new ConcurrentHashMap<>();\n+  // Map for looking up materialization by view query text\n+  private final Map<String, List<RelOptMaterialization>> sqlToMaterializedView = new ConcurrentHashMap<>();\n+\n+\n+  public void putIfAbsent(Table materializedViewTable, RelOptMaterialization materialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    // You store the materialized view\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, relOptMaterialization) -> {\n+      List<RelOptMaterialization> materializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+      materializationList.add(materialization);\n+      return materialization;\n+    });\n+\n+    LOG.debug(\"Materialized view {}.{} added to registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  private ConcurrentMap<String, RelOptMaterialization> ensureDbMap(Table materializedViewTable) {\n+    // We are going to create the map for each view in the given database\n+    ConcurrentMap<String, RelOptMaterialization> dbMap =\n+            new ConcurrentHashMap<String, RelOptMaterialization>();\n+    // If we are caching the MV, we include it in the cache\n+    final ConcurrentMap<String, RelOptMaterialization> prevDbMap = materializedViews.putIfAbsent(\n+            materializedViewTable.getDbName(), dbMap);\n+    if (prevDbMap != null) {\n+      dbMap = prevDbMap;\n+    }\n+    return dbMap;\n+  }\n+\n+  public void refresh(\n+          Table oldMaterializedViewTable, Table materializedViewTable, RelOptMaterialization newMaterialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, existingMaterialization) -> {\n+      List<RelOptMaterialization> optMaterializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+\n+      if (existingMaterialization == null) {\n+        // If it was not existing, we just create it\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      Table existingMaterializedViewTable = HiveMaterializedViewUtils.extractTable(existingMaterialization);\n+      if (existingMaterializedViewTable.equals(oldMaterializedViewTable)) {\n+        // If the old version is the same, we replace it\n+        optMaterializationList.remove(existingMaterialization);\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      // Otherwise, we return existing materialization\n+      return existingMaterialization;\n+    });\n+\n+    LOG.debug(\"Refreshed materialized view {}.{} -> {}.{}\",\n+            oldMaterializedViewTable.getDbName(), oldMaterializedViewTable.getTableName(),\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(Table materializedViewTable) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(materializedViewTable.getDbName());\n+    if (dbMap != null) {\n+      // Delete only if the create time for the input materialized view table and the table\n+      // in the map match. Otherwise, keep the one in the map.\n+      dbMap.computeIfPresent(materializedViewTable.getTableName(), (mvTableName, oldMaterialization) -> {\n+        if (HiveMaterializedViewUtils.extractTable(oldMaterialization).equals(materializedViewTable)) {\n+          List<RelOptMaterialization> materializationList =\n+                  sqlToMaterializedView.get(materializedViewTable.getViewExpandedText().toLowerCase());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MjI2NQ=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTA3OTkxOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/MaterializedViewsCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDozMzoyN1rOICv6lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzowNjo1MFrOIDIWTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MzEwOQ==", "bodyText": "This will print the full query which will be very verbose. Maybe move printing the query text to TRACE level and simply print No materialized view with similar query text found in registry in DEBUG mode.", "url": "https://github.com/apache/hive/pull/1706#discussion_r539753109", "createdAt": "2020-12-10T00:33:27Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/MaterializedViewsCache.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.metadata;\n+\n+import org.apache.calcite.plan.RelOptMaterialization;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiFunction;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Collection for storing {@link RelOptMaterialization}s.\n+ * RelOptMaterialization can be lookup by\n+ * - the Materialized View fully qualified name\n+ * - query text.\n+ * This implementation contains two {@link ConcurrentHashMap} one for name based and one for query text based lookup.\n+ * The map contents are synchronized during each dml operation: Dml operations are performed initially on the map\n+ * which provides name based lookup. The map which provides query text based lookup is updated by lambda expressions\n+ * passed to {@link ConcurrentHashMap#compute(Object, BiFunction)}.\n+ */\n+public class MaterializedViewsCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(MaterializedViewsCache.class);\n+\n+  // Key is the database name. Value a map from the qualified name to the view object.\n+  private final ConcurrentMap<String, ConcurrentMap<String, RelOptMaterialization>> materializedViews =\n+          new ConcurrentHashMap<>();\n+  // Map for looking up materialization by view query text\n+  private final Map<String, List<RelOptMaterialization>> sqlToMaterializedView = new ConcurrentHashMap<>();\n+\n+\n+  public void putIfAbsent(Table materializedViewTable, RelOptMaterialization materialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    // You store the materialized view\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, relOptMaterialization) -> {\n+      List<RelOptMaterialization> materializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+      materializationList.add(materialization);\n+      return materialization;\n+    });\n+\n+    LOG.debug(\"Materialized view {}.{} added to registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  private ConcurrentMap<String, RelOptMaterialization> ensureDbMap(Table materializedViewTable) {\n+    // We are going to create the map for each view in the given database\n+    ConcurrentMap<String, RelOptMaterialization> dbMap =\n+            new ConcurrentHashMap<String, RelOptMaterialization>();\n+    // If we are caching the MV, we include it in the cache\n+    final ConcurrentMap<String, RelOptMaterialization> prevDbMap = materializedViews.putIfAbsent(\n+            materializedViewTable.getDbName(), dbMap);\n+    if (prevDbMap != null) {\n+      dbMap = prevDbMap;\n+    }\n+    return dbMap;\n+  }\n+\n+  public void refresh(\n+          Table oldMaterializedViewTable, Table materializedViewTable, RelOptMaterialization newMaterialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, existingMaterialization) -> {\n+      List<RelOptMaterialization> optMaterializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+\n+      if (existingMaterialization == null) {\n+        // If it was not existing, we just create it\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      Table existingMaterializedViewTable = HiveMaterializedViewUtils.extractTable(existingMaterialization);\n+      if (existingMaterializedViewTable.equals(oldMaterializedViewTable)) {\n+        // If the old version is the same, we replace it\n+        optMaterializationList.remove(existingMaterialization);\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      // Otherwise, we return existing materialization\n+      return existingMaterialization;\n+    });\n+\n+    LOG.debug(\"Refreshed materialized view {}.{} -> {}.{}\",\n+            oldMaterializedViewTable.getDbName(), oldMaterializedViewTable.getTableName(),\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(Table materializedViewTable) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(materializedViewTable.getDbName());\n+    if (dbMap != null) {\n+      // Delete only if the create time for the input materialized view table and the table\n+      // in the map match. Otherwise, keep the one in the map.\n+      dbMap.computeIfPresent(materializedViewTable.getTableName(), (mvTableName, oldMaterialization) -> {\n+        if (HiveMaterializedViewUtils.extractTable(oldMaterialization).equals(materializedViewTable)) {\n+          List<RelOptMaterialization> materializationList =\n+                  sqlToMaterializedView.get(materializedViewTable.getViewExpandedText().toLowerCase());\n+          materializationList.remove(oldMaterialization);\n+          return null;\n+        }\n+        return oldMaterialization;\n+      });\n+    }\n+\n+    LOG.debug(\"Materialized view {}.{} removed from registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(String dbName, String tableName) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(dbName);\n+    if (dbMap != null) {\n+      dbMap.computeIfPresent(tableName, (mvTableName, relOptMaterialization) -> {\n+        String queryText = HiveMaterializedViewUtils.extractTable(relOptMaterialization).getViewExpandedText();\n+        List<RelOptMaterialization> materializationList = sqlToMaterializedView.get(queryText.toLowerCase());\n+        materializationList.remove(relOptMaterialization);\n+        return null;\n+      });\n+\n+      LOG.debug(\"Materialized view {}.{} removed from registry\", dbName, tableName);\n+    }\n+  }\n+\n+  public List<RelOptMaterialization> values() {\n+    List<RelOptMaterialization> result = new ArrayList<>();\n+    materializedViews.forEach((dbName, mvs) -> result.addAll(mvs.values()));\n+    return unmodifiableList(result);\n+  }\n+\n+  RelOptMaterialization get(String dbName, String viewName) {\n+    if (materializedViews.get(dbName) != null) {\n+      LOG.debug(\"Found materialized view {}.{} in registry\", dbName, viewName);\n+      return materializedViews.get(dbName).get(viewName);\n+    }\n+    LOG.debug(\"Materialized view {}.{} not found in registry\", dbName, viewName);\n+    return null;\n+  }\n+\n+  public List<RelOptMaterialization> get(String queryText) {\n+    List<RelOptMaterialization> relOptMaterializationList = sqlToMaterializedView.get(queryText.toLowerCase());\n+    if (relOptMaterializationList == null) {\n+      LOG.debug(\"No materialized view with query text '{}' found in registry\", queryText);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1MzQyMQ==", "bodyText": "moved to trace level", "url": "https://github.com/apache/hive/pull/1706#discussion_r540153421", "createdAt": "2020-12-10T13:06:50Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/MaterializedViewsCache.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.metadata;\n+\n+import org.apache.calcite.plan.RelOptMaterialization;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiFunction;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Collection for storing {@link RelOptMaterialization}s.\n+ * RelOptMaterialization can be lookup by\n+ * - the Materialized View fully qualified name\n+ * - query text.\n+ * This implementation contains two {@link ConcurrentHashMap} one for name based and one for query text based lookup.\n+ * The map contents are synchronized during each dml operation: Dml operations are performed initially on the map\n+ * which provides name based lookup. The map which provides query text based lookup is updated by lambda expressions\n+ * passed to {@link ConcurrentHashMap#compute(Object, BiFunction)}.\n+ */\n+public class MaterializedViewsCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(MaterializedViewsCache.class);\n+\n+  // Key is the database name. Value a map from the qualified name to the view object.\n+  private final ConcurrentMap<String, ConcurrentMap<String, RelOptMaterialization>> materializedViews =\n+          new ConcurrentHashMap<>();\n+  // Map for looking up materialization by view query text\n+  private final Map<String, List<RelOptMaterialization>> sqlToMaterializedView = new ConcurrentHashMap<>();\n+\n+\n+  public void putIfAbsent(Table materializedViewTable, RelOptMaterialization materialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    // You store the materialized view\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, relOptMaterialization) -> {\n+      List<RelOptMaterialization> materializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+      materializationList.add(materialization);\n+      return materialization;\n+    });\n+\n+    LOG.debug(\"Materialized view {}.{} added to registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  private ConcurrentMap<String, RelOptMaterialization> ensureDbMap(Table materializedViewTable) {\n+    // We are going to create the map for each view in the given database\n+    ConcurrentMap<String, RelOptMaterialization> dbMap =\n+            new ConcurrentHashMap<String, RelOptMaterialization>();\n+    // If we are caching the MV, we include it in the cache\n+    final ConcurrentMap<String, RelOptMaterialization> prevDbMap = materializedViews.putIfAbsent(\n+            materializedViewTable.getDbName(), dbMap);\n+    if (prevDbMap != null) {\n+      dbMap = prevDbMap;\n+    }\n+    return dbMap;\n+  }\n+\n+  public void refresh(\n+          Table oldMaterializedViewTable, Table materializedViewTable, RelOptMaterialization newMaterialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, existingMaterialization) -> {\n+      List<RelOptMaterialization> optMaterializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+\n+      if (existingMaterialization == null) {\n+        // If it was not existing, we just create it\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      Table existingMaterializedViewTable = HiveMaterializedViewUtils.extractTable(existingMaterialization);\n+      if (existingMaterializedViewTable.equals(oldMaterializedViewTable)) {\n+        // If the old version is the same, we replace it\n+        optMaterializationList.remove(existingMaterialization);\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      // Otherwise, we return existing materialization\n+      return existingMaterialization;\n+    });\n+\n+    LOG.debug(\"Refreshed materialized view {}.{} -> {}.{}\",\n+            oldMaterializedViewTable.getDbName(), oldMaterializedViewTable.getTableName(),\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(Table materializedViewTable) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(materializedViewTable.getDbName());\n+    if (dbMap != null) {\n+      // Delete only if the create time for the input materialized view table and the table\n+      // in the map match. Otherwise, keep the one in the map.\n+      dbMap.computeIfPresent(materializedViewTable.getTableName(), (mvTableName, oldMaterialization) -> {\n+        if (HiveMaterializedViewUtils.extractTable(oldMaterialization).equals(materializedViewTable)) {\n+          List<RelOptMaterialization> materializationList =\n+                  sqlToMaterializedView.get(materializedViewTable.getViewExpandedText().toLowerCase());\n+          materializationList.remove(oldMaterialization);\n+          return null;\n+        }\n+        return oldMaterialization;\n+      });\n+    }\n+\n+    LOG.debug(\"Materialized view {}.{} removed from registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(String dbName, String tableName) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(dbName);\n+    if (dbMap != null) {\n+      dbMap.computeIfPresent(tableName, (mvTableName, relOptMaterialization) -> {\n+        String queryText = HiveMaterializedViewUtils.extractTable(relOptMaterialization).getViewExpandedText();\n+        List<RelOptMaterialization> materializationList = sqlToMaterializedView.get(queryText.toLowerCase());\n+        materializationList.remove(relOptMaterialization);\n+        return null;\n+      });\n+\n+      LOG.debug(\"Materialized view {}.{} removed from registry\", dbName, tableName);\n+    }\n+  }\n+\n+  public List<RelOptMaterialization> values() {\n+    List<RelOptMaterialization> result = new ArrayList<>();\n+    materializedViews.forEach((dbName, mvs) -> result.addAll(mvs.values()));\n+    return unmodifiableList(result);\n+  }\n+\n+  RelOptMaterialization get(String dbName, String viewName) {\n+    if (materializedViews.get(dbName) != null) {\n+      LOG.debug(\"Found materialized view {}.{} in registry\", dbName, viewName);\n+      return materializedViews.get(dbName).get(viewName);\n+    }\n+    LOG.debug(\"Materialized view {}.{} not found in registry\", dbName, viewName);\n+    return null;\n+  }\n+\n+  public List<RelOptMaterialization> get(String queryText) {\n+    List<RelOptMaterialization> relOptMaterializationList = sqlToMaterializedView.get(queryText.toLowerCase());\n+    if (relOptMaterializationList == null) {\n+      LOG.debug(\"No materialized view with query text '{}' found in registry\", queryText);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MzEwOQ=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTExMjI4OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDo0NDoyNlrOICwLyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNDoyNToyN1rOIDLyTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1NzUxMw==", "bodyText": "could this be private?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539757513", "createdAt": "2020-12-10T00:44:26Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -345,9 +345,19 @@\n \n import javax.sql.DataSource;\n \n+import static java.util.Collections.singletonList;\n+import static org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils.extractTable;\n+\n \n public class CalcitePlanner extends SemanticAnalyzer {\n \n+  /**\n+   * {@link org.antlr.runtime.TokenRewriteStream} offers the opportunity of multiple rewrites of the same\n+   * input text (in our case the sql query text). These rewrites are called programs and identified by a string.\n+   * EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM is for identifying the program which replaces all identifiers in the\n+   * query with fully qualified identifiers.\n+   */\n+  public static final String EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM = \"EXPANDED_QUERY_PROGRAM\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIwOTc0MQ==", "bodyText": "done", "url": "https://github.com/apache/hive/pull/1706#discussion_r540209741", "createdAt": "2020-12-10T14:25:27Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -345,9 +345,19 @@\n \n import javax.sql.DataSource;\n \n+import static java.util.Collections.singletonList;\n+import static org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils.extractTable;\n+\n \n public class CalcitePlanner extends SemanticAnalyzer {\n \n+  /**\n+   * {@link org.antlr.runtime.TokenRewriteStream} offers the opportunity of multiple rewrites of the same\n+   * input text (in our case the sql query text). These rewrites are called programs and identified by a string.\n+   * EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM is for identifying the program which replaces all identifiers in the\n+   * query with fully qualified identifiers.\n+   */\n+  public static final String EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM = \"EXPANDED_QUERY_PROGRAM\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1NzUxMw=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTEyNTUwOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDo0OTowMFrOICwSug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNDo0NjoyNFrOIDMy1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1OTI5MA==", "bodyText": "Can we move this to HiveMaterializedViewsUtils.java? I think there is a single other place where we call _ copyNodeNewCluster_ and it's to create a new materialization too. Maybe you can make _ copyNodeNewCluster_ private, make _ copyMaterializationToNewCluster_ in HiveMaterializedViewsUtils.java, and only call the latter.", "url": "https://github.com/apache/hive/pull/1706#discussion_r539759290", "createdAt": "2020-12-10T00:49:00Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -2349,6 +2362,50 @@ private RelNode applyMaterializedViewRewriting(RelOptPlanner planner, RelNode ba\n       return basePlan;\n     }\n \n+    private RelOptMaterialization copyMaterializationToNewCluster(RelOptCluster optCluster, RelOptMaterialization materialization) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyNjI2Mg==", "bodyText": "moved", "url": "https://github.com/apache/hive/pull/1706#discussion_r540226262", "createdAt": "2020-12-10T14:46:24Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -2349,6 +2362,50 @@ private RelNode applyMaterializedViewRewriting(RelOptPlanner planner, RelNode ba\n       return basePlan;\n     }\n \n+    private RelOptMaterialization copyMaterializationToNewCluster(RelOptCluster optCluster, RelOptMaterialization materialization) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1OTI5MA=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE0OTM3OnYy", "diffSide": "RIGHT", "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite.q", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDo1Nzo0OVrOICwfxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNTo1MToxM1rOIDQGGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2MjYzMQ==", "bodyText": "Why do we disable it here?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539762631", "createdAt": "2020-12-10T00:57:49Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite.q", "diffHunk": "@@ -5,6 +5,7 @@ set hive.support.concurrency=true;\n set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4MDM0NQ==", "bodyText": "This test was written for calcite based rewrite and contains statements:\ncreate materialized view if not exists cmv_mat_view2_n4\nas select a, c from cmv_basetable_n10 where a = 3;\n...\nexplain\nselect a, c from cmv_basetable_n10 where a = 3;\n\nIf hive.materializedview.rewriting.query.text is enabled text based rewrite will rewrites this query and code execution never reaches calcite based rewrite logic. So the would lose its original purpose.", "url": "https://github.com/apache/hive/pull/1706#discussion_r540280345", "createdAt": "2020-12-10T15:51:13Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite.q", "diffHunk": "@@ -5,6 +5,7 @@ set hive.support.concurrency=true;\n set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2MjYzMQ=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE1MzkwOnYy", "diffSide": "RIGHT", "path": "ql/src/test/results/clientpositive/llap/materialized_view_rewrite_window.q.out", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDo1OTozNVrOICwiTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNToyMToxM1rOIDplHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2MzI3OQ==", "bodyText": "Is this the new test that you had added to verify that the casting is matching correctly now?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539763279", "createdAt": "2020-12-10T00:59:35Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/results/clientpositive/llap/materialized_view_rewrite_window.q.out", "diffHunk": "@@ -1047,6 +1047,7 @@ PREHOOK: query: select\n   program\n from tv_view_data\n PREHOOK: type: QUERY\n+PREHOOK: Input: arc_view@mv_tv_view_data_av2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY5Nzg4NQ==", "bodyText": "No this test was added for testing calcite based rewrite. The text based rewrite modified the plan because I forgot to turn it off in this test case.\nTurned off and reverted the out.", "url": "https://github.com/apache/hive/pull/1706#discussion_r540697885", "createdAt": "2020-12-11T05:21:13Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/results/clientpositive/llap/materialized_view_rewrite_window.q.out", "diffHunk": "@@ -1047,6 +1047,7 @@ PREHOOK: query: select\n   program\n from tv_view_data\n PREHOOK: type: QUERY\n+PREHOOK: Input: arc_view@mv_tv_view_data_av2", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2MzI3OQ=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE2MTYxOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMTowMjoyM1rOICwmXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwODo1Nzo1OVrOIDvKCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NDMxOA==", "bodyText": "Can you add a few masking tests that match / do not match based on exact SQL text?\nThere are positive and negative tests for current rewriting (masking_mv in both cases):\n873d31f#diff-3ae6a10ec619425775eeff0c135ace87cfe2c8dfbaea22f99278d7cd5d9bc330", "url": "https://github.com/apache/hive/pull/1706#discussion_r539764318", "createdAt": "2020-12-10T01:02:23Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java", "diffHunk": "@@ -12565,15 +12566,17 @@ void analyzeInternal(ASTNode ast, Supplier<PlannerContext> pcf) throws SemanticE\n     sinkOp = genOPTree(ast, plannerCtx);\n \n     boolean usesMasking = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc4OTI1Ng==", "bodyText": "added tests", "url": "https://github.com/apache/hive/pull/1706#discussion_r540789256", "createdAt": "2020-12-11T08:57:59Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java", "diffHunk": "@@ -12565,15 +12566,17 @@ void analyzeInternal(ASTNode ast, Supplier<PlannerContext> pcf) throws SemanticE\n     sinkOp = genOPTree(ast, plannerCtx);\n \n     boolean usesMasking = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NDMxOA=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE2NTE0OnYy", "diffSide": "RIGHT", "path": "ql/src/test/results/clientpositive/llap/materialized_view_rewrite_by_text_2.q.out", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMTowMzo1OFrOICwoYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwOTowNTowNFrOIDvamQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NDgzMw==", "bodyText": "Can we also add some tests with inserts on the based tables (i.e., the MVs become outdated and are not used), then rebuild, then verify the MV is used again? You can see different such scenarios in current materialized_view* tests.", "url": "https://github.com/apache/hive/pull/1706#discussion_r539764833", "createdAt": "2020-12-10T01:03:58Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/results/clientpositive/llap/materialized_view_rewrite_by_text_2.q.out", "diffHunk": "@@ -0,0 +1,334 @@\n+PREHOOK: query: create table cmv_basetable_n0 (a int, b varchar(256), c decimal(10,2), d int) stored as orc TBLPROPERTIES ('transactional'='true')\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@cmv_basetable_n0\n+POSTHOOK: query: create table cmv_basetable_n0 (a int, b varchar(256), c decimal(10,2), d int) stored as orc TBLPROPERTIES ('transactional'='true')\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@cmv_basetable_n0\n+PREHOOK: query: insert into cmv_basetable_n0 values\n+ (1, 'alfred', 10.30, 2),\n+ (2, 'bob', 3.14, 3),\n+ (2, 'bonnie', 172342.2, 3),\n+ (3, 'calvin', 978.76, 3),\n+ (3, 'charlie', 9.8, 1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@cmv_basetable_n0\n+POSTHOOK: query: insert into cmv_basetable_n0 values\n+ (1, 'alfred', 10.30, 2),\n+ (2, 'bob', 3.14, 3),\n+ (2, 'bonnie', 172342.2, 3),\n+ (3, 'calvin', 978.76, 3),\n+ (3, 'charlie', 9.8, 1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@cmv_basetable_n0\n+POSTHOOK: Lineage: cmv_basetable_n0.a SCRIPT []\n+POSTHOOK: Lineage: cmv_basetable_n0.b SCRIPT []\n+POSTHOOK: Lineage: cmv_basetable_n0.c SCRIPT []\n+POSTHOOK: Lineage: cmv_basetable_n0.d SCRIPT []\n+PREHOOK: query: create materialized view cmv_mat_view_n0\n+as select a, b, c from cmv_basetable_n0 where a = 2\n+PREHOOK: type: CREATE_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@cmv_mat_view_n0\n+POSTHOOK: query: create materialized view cmv_mat_view_n0\n+as select a, b, c from cmv_basetable_n0 where a = 2\n+POSTHOOK: type: CREATE_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@cmv_mat_view_n0\n+PREHOOK: query: select * from cmv_mat_view_n0\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_mat_view_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: select * from cmv_mat_view_n0\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_mat_view_n0\n+#### A masked pattern was here ####\n+2\tbob\t3.14\n+2\tbonnie\t172342.20\n+PREHOOK: query: show tblproperties cmv_mat_view_n0\n+PREHOOK: type: SHOW_TBLPROPERTIES\n+POSTHOOK: query: show tblproperties cmv_mat_view_n0\n+POSTHOOK: type: SHOW_TBLPROPERTIES\n+COLUMN_STATS_ACCURATE\t{\"BASIC_STATS\":\"true\",\"COLUMN_STATS\":{\"a\":\"true\",\"b\":\"true\",\"c\":\"true\"}}\n+bucketing_version\t2\n+numFiles\t1\n+numFilesErasureCoded\t0\n+numRows\t2\n+rawDataSize\t408\n+totalSize\t468\n+#### A masked pattern was here ####\n+PREHOOK: query: create materialized view if not exists cmv_mat_view2\n+as select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: CREATE_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: create materialized view if not exists cmv_mat_view2\n+as select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: CREATE_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: select * from cmv_mat_view2\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: select * from cmv_mat_view2\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: show tblproperties cmv_mat_view2\n+PREHOOK: type: SHOW_TBLPROPERTIES\n+POSTHOOK: query: show tblproperties cmv_mat_view2\n+POSTHOOK: type: SHOW_TBLPROPERTIES\n+COLUMN_STATS_ACCURATE\t{\"BASIC_STATS\":\"true\",\"COLUMN_STATS\":{\"a\":\"true\",\"c\":\"true\"}}\n+bucketing_version\t2\n+numFiles\t1\n+numFilesErasureCoded\t0\n+numRows\t2\n+rawDataSize\t232\n+totalSize\t334\n+#### A masked pattern was here ####\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: default.cmv_mat_view2\n+          Select Operator\n+            expressions: a (type: int), c (type: decimal(10,2))\n+            outputColumnNames: _col0, _col1\n+            ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: explain\n+alter materialized view cmv_mat_view2 disable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: explain\n+alter materialized view cmv_mat_view2 disable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+  Stage-1 depends on stages: Stage-0\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Alter Materialized View Rewrite\n+      name: default.cmv_mat_view2\n+      disable: true\n+\n+  Stage: Stage-1\n+    Materialized View Update\n+      name: default.cmv_mat_view2\n+      disable rewrite: true\n+\n+PREHOOK: query: alter materialized view cmv_mat_view2 disable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: alter materialized view cmv_mat_view2 disable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: cmv_basetable_n0\n+          filterExpr: (a = 3) (type: boolean)\n+          Filter Operator\n+            predicate: (a = 3) (type: boolean)\n+            Select Operator\n+              expressions: 3 (type: int), c (type: decimal(10,2))\n+              outputColumnNames: _col0, _col1\n+              ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: explain\n+alter materialized view cmv_mat_view2 enable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: explain\n+alter materialized view cmv_mat_view2 enable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+  Stage-1 depends on stages: Stage-0\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Alter Materialized View Rewrite\n+      name: default.cmv_mat_view2\n+      enable: true\n+\n+  Stage: Stage-1\n+    Materialized View Update\n+      name: default.cmv_mat_view2\n+      retrieve and include: true\n+\n+PREHOOK: query: alter materialized view cmv_mat_view2 enable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: alter materialized view cmv_mat_view2 enable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: default.cmv_mat_view2\n+          Select Operator\n+            expressions: a (type: int), c (type: decimal(10,2))\n+            outputColumnNames: _col0, _col1\n+            ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: drop materialized view cmv_mat_view2\n+PREHOOK: type: DROP_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: drop materialized view cmv_mat_view2\n+POSTHOOK: type: DROP_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: cmv_basetable_n0\n+          filterExpr: (a = 3) (type: boolean)\n+          Filter Operator\n+            predicate: (a = 3) (type: boolean)\n+            Select Operator\n+              expressions: 3 (type: int), c (type: decimal(10,2))\n+              outputColumnNames: _col0, _col1\n+              ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: drop materialized view cmv_mat_view_n0\n+PREHOOK: type: DROP_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_mat_view_n0\n+PREHOOK: Output: default@cmv_mat_view_n0\n+POSTHOOK: query: drop materialized view cmv_mat_view_n0\n+POSTHOOK: type: DROP_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_mat_view_n0\n+POSTHOOK: Output: default@cmv_mat_view_n0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5MzQ5Nw==", "bodyText": "added", "url": "https://github.com/apache/hive/pull/1706#discussion_r540793497", "createdAt": "2020-12-11T09:05:04Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/results/clientpositive/llap/materialized_view_rewrite_by_text_2.q.out", "diffHunk": "@@ -0,0 +1,334 @@\n+PREHOOK: query: create table cmv_basetable_n0 (a int, b varchar(256), c decimal(10,2), d int) stored as orc TBLPROPERTIES ('transactional'='true')\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@cmv_basetable_n0\n+POSTHOOK: query: create table cmv_basetable_n0 (a int, b varchar(256), c decimal(10,2), d int) stored as orc TBLPROPERTIES ('transactional'='true')\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@cmv_basetable_n0\n+PREHOOK: query: insert into cmv_basetable_n0 values\n+ (1, 'alfred', 10.30, 2),\n+ (2, 'bob', 3.14, 3),\n+ (2, 'bonnie', 172342.2, 3),\n+ (3, 'calvin', 978.76, 3),\n+ (3, 'charlie', 9.8, 1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@cmv_basetable_n0\n+POSTHOOK: query: insert into cmv_basetable_n0 values\n+ (1, 'alfred', 10.30, 2),\n+ (2, 'bob', 3.14, 3),\n+ (2, 'bonnie', 172342.2, 3),\n+ (3, 'calvin', 978.76, 3),\n+ (3, 'charlie', 9.8, 1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@cmv_basetable_n0\n+POSTHOOK: Lineage: cmv_basetable_n0.a SCRIPT []\n+POSTHOOK: Lineage: cmv_basetable_n0.b SCRIPT []\n+POSTHOOK: Lineage: cmv_basetable_n0.c SCRIPT []\n+POSTHOOK: Lineage: cmv_basetable_n0.d SCRIPT []\n+PREHOOK: query: create materialized view cmv_mat_view_n0\n+as select a, b, c from cmv_basetable_n0 where a = 2\n+PREHOOK: type: CREATE_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@cmv_mat_view_n0\n+POSTHOOK: query: create materialized view cmv_mat_view_n0\n+as select a, b, c from cmv_basetable_n0 where a = 2\n+POSTHOOK: type: CREATE_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@cmv_mat_view_n0\n+PREHOOK: query: select * from cmv_mat_view_n0\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_mat_view_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: select * from cmv_mat_view_n0\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_mat_view_n0\n+#### A masked pattern was here ####\n+2\tbob\t3.14\n+2\tbonnie\t172342.20\n+PREHOOK: query: show tblproperties cmv_mat_view_n0\n+PREHOOK: type: SHOW_TBLPROPERTIES\n+POSTHOOK: query: show tblproperties cmv_mat_view_n0\n+POSTHOOK: type: SHOW_TBLPROPERTIES\n+COLUMN_STATS_ACCURATE\t{\"BASIC_STATS\":\"true\",\"COLUMN_STATS\":{\"a\":\"true\",\"b\":\"true\",\"c\":\"true\"}}\n+bucketing_version\t2\n+numFiles\t1\n+numFilesErasureCoded\t0\n+numRows\t2\n+rawDataSize\t408\n+totalSize\t468\n+#### A masked pattern was here ####\n+PREHOOK: query: create materialized view if not exists cmv_mat_view2\n+as select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: CREATE_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: create materialized view if not exists cmv_mat_view2\n+as select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: CREATE_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: select * from cmv_mat_view2\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: select * from cmv_mat_view2\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: show tblproperties cmv_mat_view2\n+PREHOOK: type: SHOW_TBLPROPERTIES\n+POSTHOOK: query: show tblproperties cmv_mat_view2\n+POSTHOOK: type: SHOW_TBLPROPERTIES\n+COLUMN_STATS_ACCURATE\t{\"BASIC_STATS\":\"true\",\"COLUMN_STATS\":{\"a\":\"true\",\"c\":\"true\"}}\n+bucketing_version\t2\n+numFiles\t1\n+numFilesErasureCoded\t0\n+numRows\t2\n+rawDataSize\t232\n+totalSize\t334\n+#### A masked pattern was here ####\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: default.cmv_mat_view2\n+          Select Operator\n+            expressions: a (type: int), c (type: decimal(10,2))\n+            outputColumnNames: _col0, _col1\n+            ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: explain\n+alter materialized view cmv_mat_view2 disable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: explain\n+alter materialized view cmv_mat_view2 disable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+  Stage-1 depends on stages: Stage-0\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Alter Materialized View Rewrite\n+      name: default.cmv_mat_view2\n+      disable: true\n+\n+  Stage: Stage-1\n+    Materialized View Update\n+      name: default.cmv_mat_view2\n+      disable rewrite: true\n+\n+PREHOOK: query: alter materialized view cmv_mat_view2 disable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: alter materialized view cmv_mat_view2 disable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: cmv_basetable_n0\n+          filterExpr: (a = 3) (type: boolean)\n+          Filter Operator\n+            predicate: (a = 3) (type: boolean)\n+            Select Operator\n+              expressions: 3 (type: int), c (type: decimal(10,2))\n+              outputColumnNames: _col0, _col1\n+              ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: explain\n+alter materialized view cmv_mat_view2 enable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: explain\n+alter materialized view cmv_mat_view2 enable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+  Stage-1 depends on stages: Stage-0\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Alter Materialized View Rewrite\n+      name: default.cmv_mat_view2\n+      enable: true\n+\n+  Stage: Stage-1\n+    Materialized View Update\n+      name: default.cmv_mat_view2\n+      retrieve and include: true\n+\n+PREHOOK: query: alter materialized view cmv_mat_view2 enable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: alter materialized view cmv_mat_view2 enable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: default.cmv_mat_view2\n+          Select Operator\n+            expressions: a (type: int), c (type: decimal(10,2))\n+            outputColumnNames: _col0, _col1\n+            ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: drop materialized view cmv_mat_view2\n+PREHOOK: type: DROP_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: drop materialized view cmv_mat_view2\n+POSTHOOK: type: DROP_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: cmv_basetable_n0\n+          filterExpr: (a = 3) (type: boolean)\n+          Filter Operator\n+            predicate: (a = 3) (type: boolean)\n+            Select Operator\n+              expressions: 3 (type: int), c (type: decimal(10,2))\n+              outputColumnNames: _col0, _col1\n+              ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: drop materialized view cmv_mat_view_n0\n+PREHOOK: type: DROP_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_mat_view_n0\n+PREHOOK: Output: default@cmv_mat_view_n0\n+POSTHOOK: query: drop materialized view cmv_mat_view_n0\n+POSTHOOK: type: DROP_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_mat_view_n0\n+POSTHOOK: Output: default@cmv_mat_view_n0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NDgzMw=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE3NzIwOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMTowODo0NFrOICwvGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDo0OTozNFrOIDzaIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NjU1Mg==", "bodyText": "Another validation is needed here to confirm whether current user has access to such MV. See HiveMaterializedViewUtils.checkPrivilegeForMaterializedViews (cf4463e)\nPlease, add a test such as the one included in the cf4463e .", "url": "https://github.com/apache/hive/pull/1706#discussion_r539766552", "createdAt": "2020-12-10T01:08:44Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -2349,6 +2362,50 @@ private RelNode applyMaterializedViewRewriting(RelOptPlanner planner, RelNode ba\n       return basePlan;\n     }\n \n+    private RelOptMaterialization copyMaterializationToNewCluster(RelOptCluster optCluster, RelOptMaterialization materialization) {\n+      final RelNode viewScan = materialization.tableRel;\n+      final RelNode newViewScan = HiveMaterializedViewUtils.copyNodeNewCluster(\n+              optCluster, viewScan);\n+      return new RelOptMaterialization(newViewScan, materialization.queryRel, null,\n+              materialization.qualifiedTableName);\n+    }\n+\n+    private boolean isMaterializedViewRewritingByTextEnabled() {\n+      return conf.getBoolVar(ConfVars.HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING_QUERY_TEXT) &&\n+              mvRebuildMode == MaterializationRebuildMode.NONE &&\n+              !getQB().isMaterializedView() && !ctx.isLoadingMaterializedView() && !getQB().isCTAS() &&\n+              getQB().getIsQuery() &&\n+              getQB().hasTableDefined();\n+    }\n+\n+    private RelNode applyMaterializedViewRewritingByText(RelNode calciteGenPlan, RelOptCluster optCluster) {\n+      unparseTranslator.applyTranslations(ctx.getTokenRewriteStream(), EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM);\n+      String expandedQueryText = ctx.getTokenRewriteStream()\n+              .toString(EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM, ast.getTokenStartIndex(), ast.getTokenStopIndex());\n+      try {\n+        List<RelOptMaterialization> relOptMaterializationList = db.getMaterialization(\n+                expandedQueryText, getTablesUsed(calciteGenPlan), getTxnMgr());\n+        for (RelOptMaterialization relOptMaterialization : relOptMaterializationList) {\n+          try {\n+            Table hiveTableMD = extractTable(relOptMaterialization);\n+            if (db.validateMaterializedViewsFromRegistry(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1ODkxMw==", "bodyText": "added check, and tests", "url": "https://github.com/apache/hive/pull/1706#discussion_r540858913", "createdAt": "2020-12-11T10:49:34Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -2349,6 +2362,50 @@ private RelNode applyMaterializedViewRewriting(RelOptPlanner planner, RelNode ba\n       return basePlan;\n     }\n \n+    private RelOptMaterialization copyMaterializationToNewCluster(RelOptCluster optCluster, RelOptMaterialization materialization) {\n+      final RelNode viewScan = materialization.tableRel;\n+      final RelNode newViewScan = HiveMaterializedViewUtils.copyNodeNewCluster(\n+              optCluster, viewScan);\n+      return new RelOptMaterialization(newViewScan, materialization.queryRel, null,\n+              materialization.qualifiedTableName);\n+    }\n+\n+    private boolean isMaterializedViewRewritingByTextEnabled() {\n+      return conf.getBoolVar(ConfVars.HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING_QUERY_TEXT) &&\n+              mvRebuildMode == MaterializationRebuildMode.NONE &&\n+              !getQB().isMaterializedView() && !ctx.isLoadingMaterializedView() && !getQB().isCTAS() &&\n+              getQB().getIsQuery() &&\n+              getQB().hasTableDefined();\n+    }\n+\n+    private RelNode applyMaterializedViewRewritingByText(RelNode calciteGenPlan, RelOptCluster optCluster) {\n+      unparseTranslator.applyTranslations(ctx.getTokenRewriteStream(), EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM);\n+      String expandedQueryText = ctx.getTokenRewriteStream()\n+              .toString(EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM, ast.getTokenStartIndex(), ast.getTokenStopIndex());\n+      try {\n+        List<RelOptMaterialization> relOptMaterializationList = db.getMaterialization(\n+                expandedQueryText, getTablesUsed(calciteGenPlan), getTxnMgr());\n+        for (RelOptMaterialization relOptMaterialization : relOptMaterializationList) {\n+          try {\n+            Table hiveTableMD = extractTable(relOptMaterialization);\n+            if (db.validateMaterializedViewsFromRegistry(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NjU1Mg=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE4MTQxOnYy", "diffSide": "RIGHT", "path": "ql/src/test/org/apache/hadoop/hive/ql/metadata/TestMaterializedViewsCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxMDoxNlrOICwxaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxMDoxNlrOICwxaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NzE0Nw==", "bodyText": "Neat, thanks for adding these tests!!", "url": "https://github.com/apache/hive/pull/1706#discussion_r539767147", "createdAt": "2020-12-10T01:10:16Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/org/apache/hadoop/hive/ql/metadata/TestMaterializedViewsCache.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.metadata;\n+\n+import org.apache.calcite.plan.Convention;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptMaterialization;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptQuery;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelShuttle;\n+import org.apache.calcite.rel.RelVisitor;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.CorrelationId;\n+import org.apache.calcite.rel.metadata.Metadata;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.util.ImmutableBitSet;\n+import org.apache.calcite.util.Litmus;\n+import org.apache.calcite.util.Pair;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.RelOptHiveTable;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/**\n+ * Functional and parallel execution tests for {@link MaterializedViewsCache}.\n+ * Parallel execution test is disabled by default.\n+ */\n+class TestMaterializedViewsCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE4NzAzOnYy", "diffSide": "LEFT", "path": "ql/src/test/queries/clientnegative/materialized_view_no_cbo_rewrite.q", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxMjozMVrOICw0iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNzo1Mzo0NlrOIFc1sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2Nzk0Nw==", "bodyText": "Would this still fail for queries that do not go through CBO due to missing support for some features/constructs? We do not have many of those queries left but maybe we should add the negative test (if it is not already there)", "url": "https://github.com/apache/hive/pull/1706#discussion_r539767947", "createdAt": "2020-12-10T01:12:31Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientnegative/materialized_view_no_cbo_rewrite.q", "diffHunk": "@@ -1,11 +0,0 @@\n-set hive.support.concurrency=true;\n-set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n-set hive.strict.checks.cartesian.product=false;\n-set hive.materializedview.rewriting=true;\n-\n-create table cmv_basetable (a int, b varchar(256), c decimal(10,2))\n-stored as orc TBLPROPERTIES ('transactional'='true');\n-\n-insert into cmv_basetable values (1, 'alfred', 10.30),(2, 'bob', 3.14),(2, 'bonnie', 172342.2),(3, 'calvin', 978.76),(3, 'charlie', 9.8);\n-\n-create materialized view cmv_mat_view as select a, b, c from cmv_basetable sort by a;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk1Nzg1OQ==", "bodyText": "Could you please describe this.\nI checked locally that If CBO is turned off materialized view creation will fail with SemanticException: Cannot enable automatic rewriting for materialized view. No matter what was the query definition.\nShould a general negative test be added? like\nset hive.cbo.enable=false;\ncreate materialized view mat1 as select col from t;\n\nI haven't found tests targeting this.", "url": "https://github.com/apache/hive/pull/1706#discussion_r540957859", "createdAt": "2020-12-11T13:46:58Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/queries/clientnegative/materialized_view_no_cbo_rewrite.q", "diffHunk": "@@ -1,11 +0,0 @@\n-set hive.support.concurrency=true;\n-set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n-set hive.strict.checks.cartesian.product=false;\n-set hive.materializedview.rewriting=true;\n-\n-create table cmv_basetable (a int, b varchar(256), c decimal(10,2))\n-stored as orc TBLPROPERTIES ('transactional'='true');\n-\n-insert into cmv_basetable values (1, 'alfred', 10.30),(2, 'bob', 3.14),(2, 'bonnie', 172342.2),(3, 'calvin', 978.76),(3, 'charlie', 9.8);\n-\n-create materialized view cmv_mat_view as select a, b, c from cmv_basetable sort by a;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2Nzk0Nw=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU4NjI4OA==", "bodyText": "Added test described above.", "url": "https://github.com/apache/hive/pull/1706#discussion_r542586288", "createdAt": "2020-12-14T17:53:46Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/queries/clientnegative/materialized_view_no_cbo_rewrite.q", "diffHunk": "@@ -1,11 +0,0 @@\n-set hive.support.concurrency=true;\n-set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n-set hive.strict.checks.cartesian.product=false;\n-set hive.materializedview.rewriting=true;\n-\n-create table cmv_basetable (a int, b varchar(256), c decimal(10,2))\n-stored as orc TBLPROPERTIES ('transactional'='true');\n-\n-insert into cmv_basetable values (1, 'alfred', 10.30),(2, 'bob', 3.14),(2, 'bonnie', 172342.2),(3, 'calvin', 978.76),(3, 'charlie', 9.8);\n-\n-create materialized view cmv_mat_view as select a, b, c from cmv_basetable sort by a;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2Nzk0Nw=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE4ODk5OnYy", "diffSide": "RIGHT", "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite_dummy.q", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxMzoxNlrOICw1qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMzoxNToyMlrOID4Rhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODIzNA==", "bodyText": "Why is this disabled now? Does the test change?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539768234", "createdAt": "2020-12-10T01:13:16Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite_dummy.q", "diffHunk": "@@ -6,6 +6,7 @@ set hive.support.concurrency=true;\n set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkzODYzMQ==", "bodyText": "This test was written for calcite based rewrite.", "url": "https://github.com/apache/hive/pull/1706#discussion_r540938631", "createdAt": "2020-12-11T13:15:22Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite_dummy.q", "diffHunk": "@@ -6,6 +6,7 @@ set hive.support.concurrency=true;\n set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODIzNA=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE4OTIzOnYy", "diffSide": "RIGHT", "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite_multi_db.q", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxMzoyM1rOICw1zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMzoxNToyOVrOID4Rvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODI3MA==", "bodyText": "Why is this disabled now? Does the test change?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539768270", "createdAt": "2020-12-10T01:13:23Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite_multi_db.q", "diffHunk": "@@ -3,6 +3,7 @@ set hive.support.concurrency=true;\n set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkzODY4Ng==", "bodyText": "This test was written for calcite based rewrite", "url": "https://github.com/apache/hive/pull/1706#discussion_r540938686", "createdAt": "2020-12-11T13:15:29Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite_multi_db.q", "diffHunk": "@@ -3,6 +3,7 @@ set hive.support.concurrency=true;\n set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODI3MA=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE4OTMzOnYy", "diffSide": "RIGHT", "path": "ql/src/test/queries/clientpositive/materialized_view_rewrite_1.q", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxMzoyOFrOICw13w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMzoxNTozNlrOID4R8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODI4Nw==", "bodyText": "Why is this disabled now? Does the test change?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539768287", "createdAt": "2020-12-10T01:13:28Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/materialized_view_rewrite_1.q", "diffHunk": "@@ -5,6 +5,7 @@ set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.stats.fetch.column.stats=true;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkzODczNw==", "bodyText": "This test was written for calcite based rewrite", "url": "https://github.com/apache/hive/pull/1706#discussion_r540938737", "createdAt": "2020-12-11T13:15:36Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/queries/clientpositive/materialized_view_rewrite_1.q", "diffHunk": "@@ -5,6 +5,7 @@ set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.stats.fetch.column.stats=true;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODI4Nw=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE5MTk2OnYy", "diffSide": "RIGHT", "path": "ql/src/test/queries/clientpositive/materialized_view_rewrite_by_text_2.q", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxNDozMVrOICw3Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMzowNDoxNFrOID348Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODY2Nw==", "bodyText": "No need, this is true by default?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539768667", "createdAt": "2020-12-10T01:14:31Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/materialized_view_rewrite_by_text_2.q", "diffHunk": "@@ -0,0 +1,65 @@\n+-- SORT_QUERY_RESULTS\n+\n+SET hive.vectorized.execution.enabled=false;\n+set hive.server2.materializedviews.registry.impl=DUMMY;\n+set hive.support.concurrency=true;\n+set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n+set hive.strict.checks.cartesian.product=false;\n+set hive.materializedview.rewriting.query.text=true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkzMjMzNw==", "bodyText": "yes. removed this line.", "url": "https://github.com/apache/hive/pull/1706#discussion_r540932337", "createdAt": "2020-12-11T13:04:14Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/queries/clientpositive/materialized_view_rewrite_by_text_2.q", "diffHunk": "@@ -0,0 +1,65 @@\n+-- SORT_QUERY_RESULTS\n+\n+SET hive.vectorized.execution.enabled=false;\n+set hive.server2.materializedviews.registry.impl=DUMMY;\n+set hive.support.concurrency=true;\n+set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n+set hive.strict.checks.cartesian.product=false;\n+set hive.materializedview.rewriting.query.text=true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODY2Nw=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE5MzU3OnYy", "diffSide": "RIGHT", "path": "ql/src/test/results/clientpositive/llap/avrotblsjoin.q.out", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxNDo1OVrOICw4Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMzoxNDoyNFrOID4PPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODg3NA==", "bodyText": "Is this expected? Same question for the same WARNING messages in q files below (I assume root cause is the same).", "url": "https://github.com/apache/hive/pull/1706#discussion_r539768874", "createdAt": "2020-12-10T01:14:59Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/results/clientpositive/llap/avrotblsjoin.q.out", "diffHunk": "@@ -73,6 +73,7 @@ POSTHOOK: Lineage: table1_1.col1 SCRIPT []\n POSTHOOK: Lineage: table1_1.col2 SCRIPT []\n WARNING: Comparing a bigint and a string may result in a loss of precision.\n WARNING: Comparing a bigint and a string may result in a loss of precision.\n+WARNING: Comparing a bigint and a string may result in a loss of precision.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkzODA0Ng==", "bodyText": "It is a side effect of unparsing is enable for all queries.\nWhen the calcite plan is generated genJoinRelNode is called and it calls genAllExprNodeDesc because unparsing is enabled which is required for expanded query text.\n        } else if (unparseTranslator != null && unparseTranslator.isEnabled()) {\n          genAllExprNodeDesc(joinCond, input, jCtx);\n        }", "url": "https://github.com/apache/hive/pull/1706#discussion_r540938046", "createdAt": "2020-12-11T13:14:24Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/results/clientpositive/llap/avrotblsjoin.q.out", "diffHunk": "@@ -73,6 +73,7 @@ POSTHOOK: Lineage: table1_1.col1 SCRIPT []\n POSTHOOK: Lineage: table1_1.col2 SCRIPT []\n WARNING: Comparing a bigint and a string may result in a loss of precision.\n WARNING: Comparing a bigint and a string may result in a loss of precision.\n+WARNING: Comparing a bigint and a string may result in a loss of precision.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODg3NA=="}, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 275, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}