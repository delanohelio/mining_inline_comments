{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxNTQwOTAx", "number": 1031, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDozMDo0NFrOEAqjnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo1MzoyMFrOEDSwKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTMyNzAxOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/DataSketchesFunctions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDozMDo0NFrOGcFpIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDozMDo0NFrOGcFpIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEwNTc2MQ==", "bodyText": "nit. indentation", "url": "https://github.com/apache/hive/pull/1031#discussion_r432105761", "createdAt": "2020-05-28T20:30:44Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/DataSketchesFunctions.java", "diffHunk": "@@ -235,12 +232,21 @@ public String getFunctionName() {\n         return Optional.empty();\n       } else {\n         JavaTypeFactoryImpl typeFactory = new JavaTypeFactoryImpl(new HiveTypeSystemImpl());\n+        Type type = returnType;\n+        if (type instanceof ParameterizedType) {\n+          ParameterizedType parameterizedType = (ParameterizedType) type;\n+          if (parameterizedType.getRawType() == List.class) {\n+          final RelDataType componentRelType = typeFactory.createType(parameterizedType.getActualTypeArguments()[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTMzMjc3OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/DataSketchesFunctions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDozMjozM1rOGcFsmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDozMjozM1rOGcFsmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEwNjY1MA==", "bodyText": "Is this variable needed? It seems to me its same as returnType.", "url": "https://github.com/apache/hive/pull/1031#discussion_r432106650", "createdAt": "2020-05-28T20:32:33Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/DataSketchesFunctions.java", "diffHunk": "@@ -235,12 +232,21 @@ public String getFunctionName() {\n         return Optional.empty();\n       } else {\n         JavaTypeFactoryImpl typeFactory = new JavaTypeFactoryImpl(new HiveTypeSystemImpl());\n+        Type type = returnType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTM5MTEyOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/DataSketchesFunctions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDo1MTo0NVrOGcGRXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTowMjoyM1rOGeABuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNjA2Mw==", "bodyText": "What if it is a parameterized type but it is not a list? Should we throw an exception just to make sure?", "url": "https://github.com/apache/hive/pull/1031#discussion_r432116063", "createdAt": "2020-05-28T20:51:45Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/DataSketchesFunctions.java", "diffHunk": "@@ -235,12 +232,21 @@ public String getFunctionName() {\n         return Optional.empty();\n       } else {\n         JavaTypeFactoryImpl typeFactory = new JavaTypeFactoryImpl(new HiveTypeSystemImpl());\n+        Type type = returnType;\n+        if (type instanceof ParameterizedType) {\n+          ParameterizedType parameterizedType = (ParameterizedType) type;\n+          if (parameterizedType.getRawType() == List.class) {\n+          final RelDataType componentRelType = typeFactory.createType(parameterizedType.getActualTypeArguments()[0]);\n+          return Optional\n+              .of(typeFactory.createArrayType(typeFactory.createTypeWithNullability(componentRelType, true), -1));\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExMDkwNw==", "bodyText": "idea was to leave \"typeFactory\" to handle it - although it will return something - but it will not work properly\nreturned Optional.empty()", "url": "https://github.com/apache/hive/pull/1031#discussion_r434110907", "createdAt": "2020-06-02T19:02:23Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/DataSketchesFunctions.java", "diffHunk": "@@ -235,12 +232,21 @@ public String getFunctionName() {\n         return Optional.empty();\n       } else {\n         JavaTypeFactoryImpl typeFactory = new JavaTypeFactoryImpl(new HiveTypeSystemImpl());\n+        Type type = returnType;\n+        if (type instanceof ParameterizedType) {\n+          ParameterizedType parameterizedType = (ParameterizedType) type;\n+          if (parameterizedType.getRawType() == List.class) {\n+          final RelDataType componentRelType = typeFactory.createType(parameterizedType.getActualTypeArguments()[0]);\n+          return Optional\n+              .of(typeFactory.createArrayType(typeFactory.createTypeWithNullability(componentRelType, true), -1));\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNjA2Mw=="}, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTQwNDg3OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/DataSketchesFunctions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDo1NTo1NVrOGcGZxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMzoyMzoxNlrOGccbKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExODIxMg==", "bodyText": "I have a general comment about the approach we are taking in these methods to infer the return type.\nI think we should rethink inferring the return type from the Java returned object from 'evaluate' and we could possibly take a step back.\nOne option could be create the necessary SqlReturnTypeInference strategies to be able to return the correct type depending on the functions. If the inference is simple, we could hardcode some of those return types. This is the general approach taken by Calcite functions. I think that will help simplifying this code a lot.\nWhat do you think? Do you have any other ideas?", "url": "https://github.com/apache/hive/pull/1031#discussion_r432118212", "createdAt": "2020-05-28T20:55:55Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/DataSketchesFunctions.java", "diffHunk": "@@ -235,12 +232,21 @@ public String getFunctionName() {\n         return Optional.empty();\n       } else {\n         JavaTypeFactoryImpl typeFactory = new JavaTypeFactoryImpl(new HiveTypeSystemImpl());\n+        Type type = returnType;\n+        if (type instanceof ParameterizedType) {\n+          ParameterizedType parameterizedType = (ParameterizedType) type;\n+          if (parameterizedType.getRawType() == List.class) {\n+          final RelDataType componentRelType = typeFactory.createType(parameterizedType.getActualTypeArguments()[0]);\n+          return Optional\n+              .of(typeFactory.createArrayType(typeFactory.createTypeWithNullability(componentRelType, true), -1));\n+          }\n+        }\n         return Optional.of(typeFactory.createType(returnType));\n       }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ3OTAxNw==", "bodyText": "yes; I also wanted to use this only temporarily - because this approach would not work for GenericUDF - but instead of hardcoding stuff; I think the best would be to create a SqlReturnTypeInference  which could translate the opbindings to things which could be processed by GenericUDF#initialize\nopened: HIVE-23579", "url": "https://github.com/apache/hive/pull/1031#discussion_r432479017", "createdAt": "2020-05-29T13:23:16Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/DataSketchesFunctions.java", "diffHunk": "@@ -235,12 +232,21 @@ public String getFunctionName() {\n         return Optional.empty();\n       } else {\n         JavaTypeFactoryImpl typeFactory = new JavaTypeFactoryImpl(new HiveTypeSystemImpl());\n+        Type type = returnType;\n+        if (type instanceof ParameterizedType) {\n+          ParameterizedType parameterizedType = (ParameterizedType) type;\n+          if (parameterizedType.getRawType() == List.class) {\n+          final RelDataType componentRelType = typeFactory.createType(parameterizedType.getActualTypeArguments()[0]);\n+          return Optional\n+              .of(typeFactory.createArrayType(typeFactory.createTypeWithNullability(componentRelType, true), -1));\n+          }\n+        }\n         return Optional.of(typeFactory.createType(returnType));\n       }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExODIxMg=="}, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTQwOTE5OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDo1NzoyNVrOGcGcqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDo1NzoyNVrOGcGcqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExODk1NQ==", "bodyText": "Probably you want to delete CUME_DIST() OVER (ORDER BY id), in L88, since we are providing the equivalent rewriting.", "url": "https://github.com/apache/hive/pull/1031#discussion_r432118955", "createdAt": "2020-05-28T20:57:25Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -68,25 +82,33 @@\n  *       \u21d2 SELECT ds_kll_quantile(ds_kll_sketch(CAST(id AS FLOAT)), 0.2) FROM sketch_input;\n  *    </pre>\n  *  </li>\n+ *  <li>{@code cume_dist() over (order by id)}\n+ *    <pre>\n+ *     SELECT id, CUME_DIST() OVER (ORDER BY id) FROM sketch_input;\n+ *       \u21d2 SELECT id, CUME_DIST() OVER (ORDER BY id),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTQzOTk0OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTowNzoxNFrOGcGv_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTowNzoxNFrOGcGv_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyMzkwMw==", "bodyText": "Why are we overriding this on Hive side? Could we leave a comment?", "url": "https://github.com/apache/hive/pull/1031#discussion_r432123903", "createdAt": "2020-05-28T21:07:14Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelBuilder.java", "diffHunk": "@@ -157,6 +159,12 @@ public static SqlAggFunction getRollup(SqlAggFunction aggregation) {\n     return null;\n   }\n \n+  @Override\n+  public AggCall aggregateCall(SqlAggFunction aggFunction, boolean distinct, boolean approximate, boolean ignoreNulls,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTQ0MTAwOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTowNzozNlrOGcGwqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODowODoyMVrOGcS7EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNDA3Mg==", "bodyText": "I did not know AggregateCall already had an approximate flag. Do you know what this is used for in Calcite?", "url": "https://github.com/apache/hive/pull/1031#discussion_r432124072", "createdAt": "2020-05-28T21:07:36Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelBuilder.java", "diffHunk": "@@ -157,6 +159,12 @@ public static SqlAggFunction getRollup(SqlAggFunction aggregation) {\n     return null;\n   }\n \n+  @Override\n+  public AggCall aggregateCall(SqlAggFunction aggFunction, boolean distinct, boolean approximate, boolean ignoreNulls,\n+      RexNode filter, ImmutableList<RexNode> orderKeys, String alias, ImmutableList<RexNode> operands) {\n+    return super.aggregateCall(aggFunction, distinct, approximate, ignoreNulls, filter, orderKeys, alias, operands);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzM0NA==", "bodyText": "actually AggregateCall#isApproximate is only used at one place - to decide to merge or not aggregates (in AggregateMergeRule); I now think that I've incorrectly set it to true - although the sketch will collect some features of the dataset; the approximation will be done by the sketch_estimate function", "url": "https://github.com/apache/hive/pull/1031#discussion_r432323344", "createdAt": "2020-05-29T08:08:21Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelBuilder.java", "diffHunk": "@@ -157,6 +159,12 @@ public static SqlAggFunction getRollup(SqlAggFunction aggregation) {\n     return null;\n   }\n \n+  @Override\n+  public AggCall aggregateCall(SqlAggFunction aggFunction, boolean distinct, boolean approximate, boolean ignoreNulls,\n+      RexNode filter, ImmutableList<RexNode> orderKeys, String alias, ImmutableList<RexNode> operands) {\n+    return super.aggregateCall(aggFunction, distinct, approximate, ignoreNulls, filter, orderKeys, alias, operands);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNDA3Mg=="}, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTQ0NDQwOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTowODozNVrOGcGywQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTowODozNVrOGcGywQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNDYwOQ==", "bodyText": "nit. Indentation", "url": "https://github.com/apache/hive/pull/1031#discussion_r432124609", "createdAt": "2020-05-28T21:08:35Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected RelNode processProject(Project project) {\n+        relBuilder.push(project.getInput());\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+                newProjects.add(expr.accept(shuttle));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTQ0NzQyOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTowOTo0NFrOGcG0wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTowODowNFrOGeAOrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNTEyMg==", "bodyText": "We should add a new type to Calcite for this function too.", "url": "https://github.com/apache/hive/pull/1031#discussion_r432125122", "createdAt": "2020-05-28T21:09:44Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected RelNode processProject(Project project) {\n+        relBuilder.push(project.getInput());\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+                newProjects.add(expr.accept(shuttle));\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNDIyMw==", "bodyText": "sure; I've opened HIVE-23594 for this - as it also needs a new class/etc", "url": "https://github.com/apache/hive/pull/1031#discussion_r434114223", "createdAt": "2020-06-02T19:08:04Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected RelNode processProject(Project project) {\n+        relBuilder.push(project.getInput());\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+                newProjects.add(expr.accept(shuttle));\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNTEyMg=="}, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTQ1MDU5OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMToxMDo0NFrOGcG2sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMToxMDo0NFrOGcG2sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNTYxOA==", "bodyText": "nit. newline", "url": "https://github.com/apache/hive/pull/1031#discussion_r432125618", "createdAt": "2020-05-28T21:10:44Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected RelNode processProject(Project project) {\n+        relBuilder.push(project.getInput());\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+                newProjects.add(expr.accept(shuttle));\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1\n+            && window.getLowerBound().isUnbounded() && window.getUpperBound().isUnbounded()) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      @Override\n+      RexNode rewrite(RexOver over) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTQ1MDkyOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMToxMDo1MlrOGcG27A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMToxMDo1MlrOGcG27A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNTY3Ng==", "bodyText": "nit. newline", "url": "https://github.com/apache/hive/pull/1031#discussion_r432125676", "createdAt": "2020-05-28T21:10:52Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTQ2ODgxOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMToxNjo0NFrOGcHCJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMzoyNToxOVrOGccgLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODU1MQ==", "bodyText": "I think this check could be done more efficiently, avoiding traversing all the expressions.\nWe need to make sure we only create a new project when there are rewritings in the RexNode expressions:\n\nIn the for loop in processProject, check for each expression whether it was modified by ProcessShuttle (==).\nOnly create a new Project operator if any of the expressions changed.\nCheck here newProject == project.", "url": "https://github.com/apache/hive/pull/1031#discussion_r432128551", "createdAt": "2020-05-28T21:16:44Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ4MDMwMg==", "bodyText": "done it a bit differently - but the end result is the same", "url": "https://github.com/apache/hive/pull/1031#discussion_r432480302", "createdAt": "2020-05-29T13:25:19Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODU1MQ=="}, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTQ3NDQwOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMToxODo0N1rOGcHFwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzo0MzoxOVrOGcSKUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTQ3Mw==", "bodyText": "Is this needed?", "url": "https://github.com/apache/hive/pull/1031#discussion_r432129473", "createdAt": "2020-05-28T21:18:47Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected RelNode processProject(Project project) {\n+        relBuilder.push(project.getInput());\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+                newProjects.add(expr.accept(shuttle));\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1\n+            && window.getLowerBound().isUnbounded() && window.getUpperBound().isUnbounded()) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      @Override\n+      RexNode rewrite(RexOver over) {\n+\n+        over.getOperands();\n+        RexWindow w = over.getWindow();\n+\n+        RexFieldCollation orderKey = w.orderKeys.get(0);\n+        // we don't really support nulls in aggregate/etc...they are actually ignored\n+        // so some hack will be needed for NULLs anyway..\n+        ImmutableList<RexNode> partitionKeys = w.partitionKeys;\n+\n+        relBuilder.push(relBuilder.peek());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMDg2Ng==", "bodyText": "yes; this is the point where the other side of the join is getting started to being built\nadded some explanation to the #rewrite method about this", "url": "https://github.com/apache/hive/pull/1031#discussion_r432310866", "createdAt": "2020-05-29T07:43:19Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected RelNode processProject(Project project) {\n+        relBuilder.push(project.getInput());\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+                newProjects.add(expr.accept(shuttle));\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1\n+            && window.getLowerBound().isUnbounded() && window.getUpperBound().isUnbounded()) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      @Override\n+      RexNode rewrite(RexOver over) {\n+\n+        over.getOperands();\n+        RexWindow w = over.getWindow();\n+\n+        RexFieldCollation orderKey = w.orderKeys.get(0);\n+        // we don't really support nulls in aggregate/etc...they are actually ignored\n+        // so some hack will be needed for NULLs anyway..\n+        ImmutableList<RexNode> partitionKeys = w.partitionKeys;\n+\n+        relBuilder.push(relBuilder.peek());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTQ3Mw=="}, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTUzNjIyOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTozOTowOFrOGcHsHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOToxMDozM1rOGeAUZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzOTI5NQ==", "bodyText": "Maybe it would have been easier to rely on the agg function in the relBuilder?", "url": "https://github.com/apache/hive/pull/1031#discussion_r432139295", "createdAt": "2020-05-28T21:39:08Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected RelNode processProject(Project project) {\n+        relBuilder.push(project.getInput());\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+                newProjects.add(expr.accept(shuttle));\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1\n+            && window.getLowerBound().isUnbounded() && window.getUpperBound().isUnbounded()) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      @Override\n+      RexNode rewrite(RexOver over) {\n+\n+        over.getOperands();\n+        RexWindow w = over.getWindow();\n+\n+        RexFieldCollation orderKey = w.orderKeys.get(0);\n+        // we don't really support nulls in aggregate/etc...they are actually ignored\n+        // so some hack will be needed for NULLs anyway..\n+        ImmutableList<RexNode> partitionKeys = w.partitionKeys;\n+\n+        relBuilder.push(relBuilder.peek());\n+        // the CDF function utilizes the '<' operator;\n+        // negating the input will mirror the values on the x axis\n+        // by using 1-CDF(-x) we could get a <= operator\n+        RexNode key = orderKey.getKey();\n+        key = rexBuilder.makeCall(SqlStdOperatorTable.UNARY_MINUS, key);\n+        key = rexBuilder.makeCast(getFloatType(), key);\n+\n+        ImmutableList<RexNode> projExprs = ImmutableList.<RexNode>builder().addAll(partitionKeys).add(key).build();\n+        relBuilder.project(projExprs);\n+        ImmutableBitSet groupSets = ImmutableBitSet.range(partitionKeys.size());\n+\n+        SqlAggFunction aggFunction = (SqlAggFunction) getSqlOperator(DataSketchesFunctions.DATA_TO_SKETCH);\n+        boolean distinct = false;\n+        boolean approximate = true;\n+        boolean ignoreNulls = true;\n+        List<Integer> argList = Lists.newArrayList(partitionKeys.size());\n+        int filterArg = -1;\n+        RelCollation collation = RelCollations.EMPTY;\n+        RelDataType type = rexBuilder.deriveReturnType(aggFunction, Collections.emptyList());\n+        String name = aggFunction.getName();\n+        AggregateCall newAgg = AggregateCall.create(aggFunction, distinct, approximate, ignoreNulls, argList, filterArg,\n+                      collation, type, name);\n+\n+        RelNode agg = HiveRelFactories.HIVE_AGGREGATE_FACTORY.createAggregate(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTY4Ng==", "bodyText": "I've tried this when I was not yet ready with the patch - then I abandoned it.\nNow that everything was working it was possible to do also do this.\nNote that this needs a few small changes including one in HiveRelBuilder to expose the more advanced aggregate method as public", "url": "https://github.com/apache/hive/pull/1031#discussion_r434115686", "createdAt": "2020-06-02T19:10:33Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected RelNode processProject(Project project) {\n+        relBuilder.push(project.getInput());\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+                newProjects.add(expr.accept(shuttle));\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1\n+            && window.getLowerBound().isUnbounded() && window.getUpperBound().isUnbounded()) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      @Override\n+      RexNode rewrite(RexOver over) {\n+\n+        over.getOperands();\n+        RexWindow w = over.getWindow();\n+\n+        RexFieldCollation orderKey = w.orderKeys.get(0);\n+        // we don't really support nulls in aggregate/etc...they are actually ignored\n+        // so some hack will be needed for NULLs anyway..\n+        ImmutableList<RexNode> partitionKeys = w.partitionKeys;\n+\n+        relBuilder.push(relBuilder.peek());\n+        // the CDF function utilizes the '<' operator;\n+        // negating the input will mirror the values on the x axis\n+        // by using 1-CDF(-x) we could get a <= operator\n+        RexNode key = orderKey.getKey();\n+        key = rexBuilder.makeCall(SqlStdOperatorTable.UNARY_MINUS, key);\n+        key = rexBuilder.makeCast(getFloatType(), key);\n+\n+        ImmutableList<RexNode> projExprs = ImmutableList.<RexNode>builder().addAll(partitionKeys).add(key).build();\n+        relBuilder.project(projExprs);\n+        ImmutableBitSet groupSets = ImmutableBitSet.range(partitionKeys.size());\n+\n+        SqlAggFunction aggFunction = (SqlAggFunction) getSqlOperator(DataSketchesFunctions.DATA_TO_SKETCH);\n+        boolean distinct = false;\n+        boolean approximate = true;\n+        boolean ignoreNulls = true;\n+        List<Integer> argList = Lists.newArrayList(partitionKeys.size());\n+        int filterArg = -1;\n+        RelCollation collation = RelCollations.EMPTY;\n+        RelDataType type = rexBuilder.deriveReturnType(aggFunction, Collections.emptyList());\n+        String name = aggFunction.getName();\n+        AggregateCall newAgg = AggregateCall.create(aggFunction, distinct, approximate, ignoreNulls, argList, filterArg,\n+                      collation, type, name);\n+\n+        RelNode agg = HiveRelFactories.HIVE_AGGREGATE_FACTORY.createAggregate(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzOTI5NQ=="}, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTU0ODA1OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0MzozMFrOGcHzeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0MzozMFrOGcHzeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MTE3Nw==", "bodyText": "nit. newline", "url": "https://github.com/apache/hive/pull/1031#discussion_r432141177", "createdAt": "2020-05-28T21:43:30Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected RelNode processProject(Project project) {\n+        relBuilder.push(project.getInput());\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+                newProjects.add(expr.accept(shuttle));\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1\n+            && window.getLowerBound().isUnbounded() && window.getUpperBound().isUnbounded()) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      @Override\n+      RexNode rewrite(RexOver over) {\n+\n+        over.getOperands();\n+        RexWindow w = over.getWindow();\n+\n+        RexFieldCollation orderKey = w.orderKeys.get(0);\n+        // we don't really support nulls in aggregate/etc...they are actually ignored\n+        // so some hack will be needed for NULLs anyway..\n+        ImmutableList<RexNode> partitionKeys = w.partitionKeys;\n+\n+        relBuilder.push(relBuilder.peek());\n+        // the CDF function utilizes the '<' operator;\n+        // negating the input will mirror the values on the x axis\n+        // by using 1-CDF(-x) we could get a <= operator\n+        RexNode key = orderKey.getKey();\n+        key = rexBuilder.makeCall(SqlStdOperatorTable.UNARY_MINUS, key);\n+        key = rexBuilder.makeCast(getFloatType(), key);\n+\n+        ImmutableList<RexNode> projExprs = ImmutableList.<RexNode>builder().addAll(partitionKeys).add(key).build();\n+        relBuilder.project(projExprs);\n+        ImmutableBitSet groupSets = ImmutableBitSet.range(partitionKeys.size());\n+\n+        SqlAggFunction aggFunction = (SqlAggFunction) getSqlOperator(DataSketchesFunctions.DATA_TO_SKETCH);\n+        boolean distinct = false;\n+        boolean approximate = true;\n+        boolean ignoreNulls = true;\n+        List<Integer> argList = Lists.newArrayList(partitionKeys.size());\n+        int filterArg = -1;\n+        RelCollation collation = RelCollations.EMPTY;\n+        RelDataType type = rexBuilder.deriveReturnType(aggFunction, Collections.emptyList());\n+        String name = aggFunction.getName();\n+        AggregateCall newAgg = AggregateCall.create(aggFunction, distinct, approximate, ignoreNulls, argList, filterArg,\n+                      collation, type, name);\n+\n+        RelNode agg = HiveRelFactories.HIVE_AGGREGATE_FACTORY.createAggregate(\n+            relBuilder.build(),\n+            groupSets, ImmutableList.of(groupSets),\n+            Lists.newArrayList(newAgg));\n+        relBuilder.push(agg);\n+\n+        List<RexNode> joinConditions;\n+        joinConditions = Ord.zip(partitionKeys).stream().map(o -> {\n+          RexNode f = relBuilder.field(2, 1, o.i);\n+          return rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, o.e, f);\n+        }).collect(Collectors.toList());\n+        relBuilder.join(JoinRelType.INNER, joinConditions);\n+\n+        int sketchFieldIndex = relBuilder.peek().getRowType().getFieldCount() - 1;\n+        RexInputRef sketchInputRef = relBuilder.field(sketchFieldIndex);\n+        SqlOperator projectOperator = getSqlOperator(DataSketchesFunctions.GET_CDF);\n+\n+        // NULLs will be replaced by this value - to be before / after the other values\n+        // note: the sketch will ignore NULLs entirely but they will be placed at 0.0 or 1.0\n+        final RexNode nullReplacement =\n+            relBuilder.literal(orderKey.getNullDirection() == NullDirection.FIRST ? Float.MAX_VALUE : -Float.MAX_VALUE);\n+\n+        // long story short: CAST(1.0f-CDF(CAST(COALESCE(-X, nullReplacement) AS FLOAT))[0] AS targetType)\n+        RexNode projRex = key;\n+        projRex = rexBuilder.makeCall(SqlStdOperatorTable.COALESCE, key, nullReplacement);\n+        projRex = rexBuilder.makeCast(getFloatType(), projRex);\n+        projRex = rexBuilder.makeCall(projectOperator, ImmutableList.of(sketchInputRef, projRex));\n+        projRex = makeItemCall(projRex, relBuilder.literal(0));\n+        projRex = rexBuilder.makeCall(SqlStdOperatorTable.MINUS, relBuilder.literal(1.0f), projRex);\n+        projRex = rexBuilder.makeCast(over.getType(), projRex);\n+\n+        return projRex;\n+      }\n+\n+      private RexNode makeItemCall(RexNode arr, RexNode offset) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTU0OTQ0OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0NDowM1rOGcH0YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzo1Mjo0OFrOGcScXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MTQwOA==", "bodyText": "??", "url": "https://github.com/apache/hive/pull/1031#discussion_r432141408", "createdAt": "2020-05-28T21:44:03Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected RelNode processProject(Project project) {\n+        relBuilder.push(project.getInput());\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+                newProjects.add(expr.accept(shuttle));\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1\n+            && window.getLowerBound().isUnbounded() && window.getUpperBound().isUnbounded()) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      @Override\n+      RexNode rewrite(RexOver over) {\n+\n+        over.getOperands();\n+        RexWindow w = over.getWindow();\n+\n+        RexFieldCollation orderKey = w.orderKeys.get(0);\n+        // we don't really support nulls in aggregate/etc...they are actually ignored\n+        // so some hack will be needed for NULLs anyway..\n+        ImmutableList<RexNode> partitionKeys = w.partitionKeys;\n+\n+        relBuilder.push(relBuilder.peek());\n+        // the CDF function utilizes the '<' operator;\n+        // negating the input will mirror the values on the x axis\n+        // by using 1-CDF(-x) we could get a <= operator\n+        RexNode key = orderKey.getKey();\n+        key = rexBuilder.makeCall(SqlStdOperatorTable.UNARY_MINUS, key);\n+        key = rexBuilder.makeCast(getFloatType(), key);\n+\n+        ImmutableList<RexNode> projExprs = ImmutableList.<RexNode>builder().addAll(partitionKeys).add(key).build();\n+        relBuilder.project(projExprs);\n+        ImmutableBitSet groupSets = ImmutableBitSet.range(partitionKeys.size());\n+\n+        SqlAggFunction aggFunction = (SqlAggFunction) getSqlOperator(DataSketchesFunctions.DATA_TO_SKETCH);\n+        boolean distinct = false;\n+        boolean approximate = true;\n+        boolean ignoreNulls = true;\n+        List<Integer> argList = Lists.newArrayList(partitionKeys.size());\n+        int filterArg = -1;\n+        RelCollation collation = RelCollations.EMPTY;\n+        RelDataType type = rexBuilder.deriveReturnType(aggFunction, Collections.emptyList());\n+        String name = aggFunction.getName();\n+        AggregateCall newAgg = AggregateCall.create(aggFunction, distinct, approximate, ignoreNulls, argList, filterArg,\n+                      collation, type, name);\n+\n+        RelNode agg = HiveRelFactories.HIVE_AGGREGATE_FACTORY.createAggregate(\n+            relBuilder.build(),\n+            groupSets, ImmutableList.of(groupSets),\n+            Lists.newArrayList(newAgg));\n+        relBuilder.push(agg);\n+\n+        List<RexNode> joinConditions;\n+        joinConditions = Ord.zip(partitionKeys).stream().map(o -> {\n+          RexNode f = relBuilder.field(2, 1, o.i);\n+          return rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, o.e, f);\n+        }).collect(Collectors.toList());\n+        relBuilder.join(JoinRelType.INNER, joinConditions);\n+\n+        int sketchFieldIndex = relBuilder.peek().getRowType().getFieldCount() - 1;\n+        RexInputRef sketchInputRef = relBuilder.field(sketchFieldIndex);\n+        SqlOperator projectOperator = getSqlOperator(DataSketchesFunctions.GET_CDF);\n+\n+        // NULLs will be replaced by this value - to be before / after the other values\n+        // note: the sketch will ignore NULLs entirely but they will be placed at 0.0 or 1.0\n+        final RexNode nullReplacement =\n+            relBuilder.literal(orderKey.getNullDirection() == NullDirection.FIRST ? Float.MAX_VALUE : -Float.MAX_VALUE);\n+\n+        // long story short: CAST(1.0f-CDF(CAST(COALESCE(-X, nullReplacement) AS FLOAT))[0] AS targetType)\n+        RexNode projRex = key;\n+        projRex = rexBuilder.makeCall(SqlStdOperatorTable.COALESCE, key, nullReplacement);\n+        projRex = rexBuilder.makeCast(getFloatType(), projRex);\n+        projRex = rexBuilder.makeCall(projectOperator, ImmutableList.of(sketchInputRef, projRex));\n+        projRex = makeItemCall(projRex, relBuilder.literal(0));\n+        projRex = rexBuilder.makeCall(SqlStdOperatorTable.MINUS, relBuilder.literal(1.0f), projRex);\n+        projRex = rexBuilder.makeCast(over.getType(), projRex);\n+\n+        return projRex;\n+      }\n+\n+      private RexNode makeItemCall(RexNode arr, RexNode offset) {\n+\n+        if(getClass().desiredAssertionStatus()) {\n+          try {\n+            SqlKind.class.getField(\"ITEM\");\n+            throw new RuntimeException(\"bind SqlKind.ITEM instead of this workaround - C1.23 a02155a70a\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNTQ4Ng==", "bodyText": "SqlKind.ITEM was introduced only recently in 1.23...this check is here to throw an error after we've upgraded\nall these things in this method would be unneccessary if SqlKind.ITEM would be available...\na simple rexBuilder.makeCall(SqlStdOperatorTable.ITEM, arr, offset)", "url": "https://github.com/apache/hive/pull/1031#discussion_r432315486", "createdAt": "2020-05-29T07:52:48Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +389,216 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()));\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject instanceof Project && ((Project) newProject).getChildExps().equals(project.getChildExps())) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected RelNode processProject(Project project) {\n+        relBuilder.push(project.getInput());\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+                newProjects.add(expr.accept(shuttle));\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1\n+            && window.getLowerBound().isUnbounded() && window.getUpperBound().isUnbounded()) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      @Override\n+      RexNode rewrite(RexOver over) {\n+\n+        over.getOperands();\n+        RexWindow w = over.getWindow();\n+\n+        RexFieldCollation orderKey = w.orderKeys.get(0);\n+        // we don't really support nulls in aggregate/etc...they are actually ignored\n+        // so some hack will be needed for NULLs anyway..\n+        ImmutableList<RexNode> partitionKeys = w.partitionKeys;\n+\n+        relBuilder.push(relBuilder.peek());\n+        // the CDF function utilizes the '<' operator;\n+        // negating the input will mirror the values on the x axis\n+        // by using 1-CDF(-x) we could get a <= operator\n+        RexNode key = orderKey.getKey();\n+        key = rexBuilder.makeCall(SqlStdOperatorTable.UNARY_MINUS, key);\n+        key = rexBuilder.makeCast(getFloatType(), key);\n+\n+        ImmutableList<RexNode> projExprs = ImmutableList.<RexNode>builder().addAll(partitionKeys).add(key).build();\n+        relBuilder.project(projExprs);\n+        ImmutableBitSet groupSets = ImmutableBitSet.range(partitionKeys.size());\n+\n+        SqlAggFunction aggFunction = (SqlAggFunction) getSqlOperator(DataSketchesFunctions.DATA_TO_SKETCH);\n+        boolean distinct = false;\n+        boolean approximate = true;\n+        boolean ignoreNulls = true;\n+        List<Integer> argList = Lists.newArrayList(partitionKeys.size());\n+        int filterArg = -1;\n+        RelCollation collation = RelCollations.EMPTY;\n+        RelDataType type = rexBuilder.deriveReturnType(aggFunction, Collections.emptyList());\n+        String name = aggFunction.getName();\n+        AggregateCall newAgg = AggregateCall.create(aggFunction, distinct, approximate, ignoreNulls, argList, filterArg,\n+                      collation, type, name);\n+\n+        RelNode agg = HiveRelFactories.HIVE_AGGREGATE_FACTORY.createAggregate(\n+            relBuilder.build(),\n+            groupSets, ImmutableList.of(groupSets),\n+            Lists.newArrayList(newAgg));\n+        relBuilder.push(agg);\n+\n+        List<RexNode> joinConditions;\n+        joinConditions = Ord.zip(partitionKeys).stream().map(o -> {\n+          RexNode f = relBuilder.field(2, 1, o.i);\n+          return rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, o.e, f);\n+        }).collect(Collectors.toList());\n+        relBuilder.join(JoinRelType.INNER, joinConditions);\n+\n+        int sketchFieldIndex = relBuilder.peek().getRowType().getFieldCount() - 1;\n+        RexInputRef sketchInputRef = relBuilder.field(sketchFieldIndex);\n+        SqlOperator projectOperator = getSqlOperator(DataSketchesFunctions.GET_CDF);\n+\n+        // NULLs will be replaced by this value - to be before / after the other values\n+        // note: the sketch will ignore NULLs entirely but they will be placed at 0.0 or 1.0\n+        final RexNode nullReplacement =\n+            relBuilder.literal(orderKey.getNullDirection() == NullDirection.FIRST ? Float.MAX_VALUE : -Float.MAX_VALUE);\n+\n+        // long story short: CAST(1.0f-CDF(CAST(COALESCE(-X, nullReplacement) AS FLOAT))[0] AS targetType)\n+        RexNode projRex = key;\n+        projRex = rexBuilder.makeCall(SqlStdOperatorTable.COALESCE, key, nullReplacement);\n+        projRex = rexBuilder.makeCast(getFloatType(), projRex);\n+        projRex = rexBuilder.makeCall(projectOperator, ImmutableList.of(sketchInputRef, projRex));\n+        projRex = makeItemCall(projRex, relBuilder.literal(0));\n+        projRex = rexBuilder.makeCall(SqlStdOperatorTable.MINUS, relBuilder.literal(1.0f), projRex);\n+        projRex = rexBuilder.makeCast(over.getType(), projRex);\n+\n+        return projRex;\n+      }\n+\n+      private RexNode makeItemCall(RexNode arr, RexNode offset) {\n+\n+        if(getClass().desiredAssertionStatus()) {\n+          try {\n+            SqlKind.class.getField(\"ITEM\");\n+            throw new RuntimeException(\"bind SqlKind.ITEM instead of this workaround - C1.23 a02155a70a\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MTQwOA=="}, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTU1Mzk5OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/translator/SqlFunctionConverter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0NTo0NlrOGcH3NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0NTo0NlrOGcH3NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjEzMw==", "bodyText": "Should this be removed?", "url": "https://github.com/apache/hive/pull/1031#discussion_r432142133", "createdAt": "2020-05-28T21:45:46Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/translator/SqlFunctionConverter.java", "diffHunk": "@@ -672,6 +673,15 @@ public static SqlAggFunction getCalciteAggFn(String hiveUdfName, boolean isDisti\n             udfInfo.operandTypeInference,\n             udfInfo.operandTypeChecker);\n         break;\n+      case \"cume_dist\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bde236e6c5bcd744baf878ba7f1377dbc81f1d1"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjU5ODY1OnYy", "diffSide": "RIGHT", "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo1NzoyOFrOGeYgfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo1NzoyOFrOGeYgfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxMTk5Ng==", "bodyText": "about enabling other sketches for count-distinct: I think they should just work - however they might need a little testing; probably more important would be to provide some way to change sketch construction parameters...actually for our rewrites the sketch type could be considered as part of the parameters\nopened: HIVE-23600", "url": "https://github.com/apache/hive/pull/1031#discussion_r434511996", "createdAt": "2020-06-03T11:57:28Z", "author": {"login": "kgyrtkirk"}, "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "diffHunk": "@@ -2495,19 +2495,22 @@ private static void populateLlapDaemonVarsSet(Set<String> llapDaemonVarsSetLocal\n     HIVE_OPTIMIZE_BI_REWRITE_COUNTDISTINCT_ENABLED(\"hive.optimize.bi.rewrite.countdistinct.enabled\",\n         true,\n         \"Enables to rewrite COUNT(DISTINCT(X)) queries to be rewritten to use sketch functions.\"),\n-    HIVE_OPTIMIZE_BI_REWRITE_COUNT_DISTINCT_SKETCH(\n-        \"hive.optimize.bi.rewrite.countdistinct.sketch\", \"hll\",\n+    HIVE_OPTIMIZE_BI_REWRITE_COUNT_DISTINCT_SKETCH(\"hive.optimize.bi.rewrite.countdistinct.sketch\", \"hll\",\n         new StringSet(\"hll\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50b616456bafcfcc15b80adf0af2dfba94d92012"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjYwMzE3OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo1OTowNFrOGeYjnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo1OTowNFrOGeYjnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxMjc5Nw==", "bodyText": "this method is needed to use the relbuilder to create aggregates;\nthe overriden method is protected...and there is no way to access this level of detail without exposing it", "url": "https://github.com/apache/hive/pull/1031#discussion_r434512797", "createdAt": "2020-06-03T11:59:04Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelBuilder.java", "diffHunk": "@@ -165,4 +166,10 @@ protected boolean shouldMergeProject() {\n     return false;\n   }\n \n+  /** Make the method visible */\n+  @Override\n+  public AggCall aggregateCall(SqlAggFunction aggFunction, boolean distinct, boolean approximate, boolean ignoreNulls,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50b616456bafcfcc15b80adf0af2dfba94d92012"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjYwODE1OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowMDoyN1rOGeYmyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowMDoyN1rOGeYmyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxMzYwOQ==", "bodyText": "I think these apidoc could be moved to the rewrite-rules - but they also have there meaning here as well...maybe move them and add a more brief description here?", "url": "https://github.com/apache/hive/pull/1031#discussion_r434513609", "createdAt": "2020-06-03T12:00:27Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -68,25 +82,32 @@\n  *       \u21d2 SELECT ds_kll_quantile(ds_kll_sketch(CAST(id AS FLOAT)), 0.2) FROM sketch_input;\n  *    </pre>\n  *  </li>\n+ *  <li>{@code cume_dist() over (order by id)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50b616456bafcfcc15b80adf0af2dfba94d92012"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjYzMDgxOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowNzo0OVrOGeY1oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowNzo0OVrOGeY1oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNzQwOA==", "bodyText": "interestingly: CUME_DIST returns NULLs when the partitioning coulmn is null - but the sketch based estimation (and postgres doesn't)\nopened HIVE-23599\nsince this is not a simple '=' we could possibly loose some optimizations...", "url": "https://github.com/apache/hive/pull/1031#discussion_r434517408", "createdAt": "2020-06-03T12:07:49Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +388,210 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()), HiveRelFactories.HIVE_BUILDER, null);\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject == project) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected final RelNode processProject(Project project) {\n+        RelNode origInput = project.getInput();\n+        relBuilder.push(origInput);\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+          newProjects.add(expr.accept(shuttle));\n+        }\n+        if (relBuilder.peek() == origInput) {\n+          relBuilder.clear();\n+          return project;\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      /**\n+       * Do the rewrite for the given expression.\n+       *\n+       * When this method is invoked the {@link #relBuilder} will only contain the current input.\n+       * Expectation is to leave the new input there after the method finishes.\n+       */\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1\n+            && window.getLowerBound().isUnbounded() && window.getUpperBound().isUnbounded()) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      @Override\n+      RexNode rewrite(RexOver over) {\n+        RexWindow w = over.getWindow();\n+        RexFieldCollation orderKey = w.orderKeys.get(0);\n+        // we don't really support nulls in aggregate/etc...they are actually ignored\n+        // so some hack will be needed for NULLs anyway..\n+        ImmutableList<RexNode> partitionKeys = w.partitionKeys;\n+\n+        relBuilder.push(relBuilder.peek());\n+        // the CDF function utilizes the '<' operator;\n+        // negating the input will mirror the values on the x axis\n+        // by using 1-CDF(-x) we could get a <= operator\n+        RexNode key = orderKey.getKey();\n+        key = rexBuilder.makeCall(SqlStdOperatorTable.UNARY_MINUS, key);\n+        key = rexBuilder.makeCast(getFloatType(), key);\n+\n+        AggCall aggCall = ((HiveRelBuilder) relBuilder).aggregateCall(\n+            (SqlAggFunction) getSqlOperator(DataSketchesFunctions.DATA_TO_SKETCH),\n+            /* distinct */ false,\n+            /* approximate */ false,\n+            /* ignoreNulls */ true,\n+            null,\n+            ImmutableList.of(),\n+            null,\n+            ImmutableList.of(key));\n+\n+        relBuilder.aggregate(relBuilder.groupKey(partitionKeys), aggCall);\n+\n+        List<RexNode> joinConditions;\n+        joinConditions = Ord.zip(partitionKeys).stream().map(o -> {\n+          RexNode f = relBuilder.field(2, 1, o.i);\n+          return rexBuilder.makeCall(SqlStdOperatorTable.IS_NOT_DISTINCT_FROM, o.e, f);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50b616456bafcfcc15b80adf0af2dfba94d92012"}, "originalPosition": 277}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjY0MTgxOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxMTowMVrOGeY8ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxMTowMVrOGeY8ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxOTE2Mw==", "bodyText": "I don't 100% like this approach - let's see if we could service everything this way...", "url": "https://github.com/apache/hive/pull/1031#discussion_r434519163", "createdAt": "2020-06-03T12:11:01Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRewriteToDataSketchesRules.java", "diffHunk": "@@ -368,4 +388,210 @@ void rewrite(AggregateCall aggCall) {\n       }\n     }\n   }\n+\n+  /**\n+   * Generic support for rewriting Windowing expression into a different form usually using joins.\n+   */\n+  private static abstract class WindowingToProjectAggregateJoinProject extends RelOptRule {\n+\n+    protected final String sketchType;\n+\n+    public WindowingToProjectAggregateJoinProject(String sketchType) {\n+      super(operand(HiveProject.class, any()), HiveRelFactories.HIVE_BUILDER, null);\n+      this.sketchType = sketchType;\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+      final Project project = call.rel(0);\n+\n+      VbuilderPAP vb = buildProcessor(call);\n+      RelNode newProject = vb.processProject(project);\n+\n+      if (newProject == project) {\n+        return;\n+      } else {\n+        call.transformTo(newProject);\n+      }\n+    }\n+\n+    protected abstract VbuilderPAP buildProcessor(RelOptRuleCall call);\n+\n+    protected static abstract class VbuilderPAP {\n+      private final String sketchClass;\n+      protected final RelBuilder relBuilder;\n+      protected final RexBuilder rexBuilder;\n+\n+      protected VbuilderPAP(String sketchClass, RelBuilder relBuilder) {\n+        this.sketchClass = sketchClass;\n+        this.relBuilder = relBuilder;\n+        rexBuilder = relBuilder.getRexBuilder();\n+      }\n+\n+      final class ProcessShuttle extends RexShuttle {\n+        public RexNode visitOver(RexOver over) {\n+          return processCall(over);\n+        }\n+      };\n+\n+      protected final RelNode processProject(Project project) {\n+        RelNode origInput = project.getInput();\n+        relBuilder.push(origInput);\n+        RexShuttle shuttle = new ProcessShuttle();\n+        List<RexNode> newProjects = new ArrayList<RexNode>();\n+        for (RexNode expr : project.getChildExps()) {\n+          newProjects.add(expr.accept(shuttle));\n+        }\n+        if (relBuilder.peek() == origInput) {\n+          relBuilder.clear();\n+          return project;\n+        }\n+        relBuilder.project(newProjects);\n+        return relBuilder.build();\n+      }\n+\n+      private final RexNode processCall(RexNode expr) {\n+        if (expr instanceof RexOver) {\n+          RexOver over = (RexOver) expr;\n+          if (isApplicable(over)) {\n+            return rewrite(over);\n+          }\n+        }\n+        return expr;\n+      }\n+\n+      protected final SqlOperator getSqlOperator(String fnName) {\n+        UDFDescriptor fn = DataSketchesFunctions.INSTANCE.getSketchFunction(sketchClass, fnName);\n+        if (!fn.getCalciteFunction().isPresent()) {\n+          throw new RuntimeException(fn.toString() + \" doesn't have a Calcite function associated with it\");\n+        }\n+        return fn.getCalciteFunction().get();\n+      }\n+\n+      /**\n+       * Do the rewrite for the given expression.\n+       *\n+       * When this method is invoked the {@link #relBuilder} will only contain the current input.\n+       * Expectation is to leave the new input there after the method finishes.\n+       */\n+      abstract RexNode rewrite(RexOver expr);\n+\n+      abstract boolean isApplicable(RexOver expr);\n+\n+    }\n+  }\n+\n+  public static class CumeDistRewrite extends WindowingToProjectAggregateJoinProject {\n+\n+    public CumeDistRewrite(String sketchType) {\n+      super(sketchType);\n+    }\n+\n+    @Override\n+    protected VbuilderPAP buildProcessor(RelOptRuleCall call) {\n+      return new VB(sketchType, call.builder());\n+    }\n+\n+    private static class VB extends VbuilderPAP {\n+\n+      protected VB(String sketchClass, RelBuilder relBuilder) {\n+        super(sketchClass, relBuilder);\n+      }\n+\n+      @Override\n+      boolean isApplicable(RexOver over) {\n+        SqlAggFunction aggOp = over.getAggOperator();\n+        RexWindow window = over.getWindow();\n+        if (aggOp.getName().equalsIgnoreCase(\"cume_dist\") && window.orderKeys.size() == 1\n+            && window.getLowerBound().isUnbounded() && window.getUpperBound().isUnbounded()) {\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      @Override\n+      RexNode rewrite(RexOver over) {\n+        RexWindow w = over.getWindow();\n+        RexFieldCollation orderKey = w.orderKeys.get(0);\n+        // we don't really support nulls in aggregate/etc...they are actually ignored\n+        // so some hack will be needed for NULLs anyway..\n+        ImmutableList<RexNode> partitionKeys = w.partitionKeys;\n+\n+        relBuilder.push(relBuilder.peek());\n+        // the CDF function utilizes the '<' operator;\n+        // negating the input will mirror the values on the x axis\n+        // by using 1-CDF(-x) we could get a <= operator\n+        RexNode key = orderKey.getKey();\n+        key = rexBuilder.makeCall(SqlStdOperatorTable.UNARY_MINUS, key);\n+        key = rexBuilder.makeCast(getFloatType(), key);\n+\n+        AggCall aggCall = ((HiveRelBuilder) relBuilder).aggregateCall(\n+            (SqlAggFunction) getSqlOperator(DataSketchesFunctions.DATA_TO_SKETCH),\n+            /* distinct */ false,\n+            /* approximate */ false,\n+            /* ignoreNulls */ true,\n+            null,\n+            ImmutableList.of(),\n+            null,\n+            ImmutableList.of(key));\n+\n+        relBuilder.aggregate(relBuilder.groupKey(partitionKeys), aggCall);\n+\n+        List<RexNode> joinConditions;\n+        joinConditions = Ord.zip(partitionKeys).stream().map(o -> {\n+          RexNode f = relBuilder.field(2, 1, o.i);\n+          return rexBuilder.makeCall(SqlStdOperatorTable.IS_NOT_DISTINCT_FROM, o.e, f);\n+        }).collect(Collectors.toList());\n+        relBuilder.join(JoinRelType.INNER, joinConditions);\n+\n+        int sketchFieldIndex = relBuilder.peek().getRowType().getFieldCount() - 1;\n+        RexInputRef sketchInputRef = relBuilder.field(sketchFieldIndex);\n+        SqlOperator projectOperator = getSqlOperator(DataSketchesFunctions.GET_CDF);\n+\n+        // NULLs will be replaced by this value - to be before / after the other values\n+        // note: the sketch will ignore NULLs entirely but they will be placed at 0.0 or 1.0\n+        final RexNode nullReplacement =\n+            relBuilder.literal(orderKey.getNullDirection() == NullDirection.FIRST ? Float.MAX_VALUE : -Float.MAX_VALUE);\n+\n+        // long story short: CAST(1.0f-CDF(CAST(COALESCE(-X, nullReplacement) AS FLOAT))[0] AS targetType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50b616456bafcfcc15b80adf0af2dfba94d92012"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjY0NTQ3OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxMjowN1rOGeY-wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxMjowN1rOGeY-wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxOTc0Ng==", "bodyText": "remove this line", "url": "https://github.com/apache/hive/pull/1031#discussion_r434519746", "createdAt": "2020-06-03T12:12:07Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -1974,13 +1974,19 @@ private RelNode applyPreJoinOrderingTransforms(RelNode basePlan, RelMetadataProv\n       if (!isMaterializedViewMaintenance() && conf.getBoolVar(ConfVars.HIVE_OPTIMIZE_BI_ENABLED)) {\n         // Rewrite to datasketches if enabled\n         if (conf.getBoolVar(ConfVars.HIVE_OPTIMIZE_BI_REWRITE_COUNTDISTINCT_ENABLED)) {\n-          String countDistinctSketchType = conf.getVar(ConfVars.HIVE_OPTIMIZE_BI_REWRITE_COUNT_DISTINCT_SKETCH);\n-          RelOptRule rule = new HiveRewriteToDataSketchesRules.CountDistinctRewrite(countDistinctSketchType);\n+          String sketchType = conf.getVar(ConfVars.HIVE_OPTIMIZE_BI_REWRITE_COUNT_DISTINCT_SKETCH);\n+          RelOptRule rule = new HiveRewriteToDataSketchesRules.CountDistinctRewrite(sketchType);\n           generatePartialProgram(program, true, HepMatchOrder.TOP_DOWN, rule);\n         }\n         if (conf.getBoolVar(ConfVars.HIVE_OPTIMIZE_BI_REWRITE_PERCENTILE_DISC_ENABLED)) {\n-          String percentileDiscSketchType = conf.getVar(ConfVars.HIVE_OPTIMIZE_BI_REWRITE_PERCENTILE_DISC_SKETCH);\n-          RelOptRule rule = new HiveRewriteToDataSketchesRules.PercentileDiscRewrite(percentileDiscSketchType);\n+          String sketchType = conf.getVar(ConfVars.HIVE_OPTIMIZE_BI_REWRITE_PERCENTILE_DISC_SKETCH);\n+          RelOptRule rule = new HiveRewriteToDataSketchesRules.PercentileDiscRewrite(sketchType);\n+          generatePartialProgram(program, true, HepMatchOrder.TOP_DOWN, rule);\n+        }\n+        if (conf.getBoolVar(ConfVars.HIVE_OPTIMIZE_BI_REWRITE_CUME_DIST_ENABLED)) {\n+          String sketchType = conf.getVar(ConfVars.HIVE_OPTIMIZE_BI_REWRITE_CUME_DIST_SKETCH);\n+          //          RelBuilderFactory factory=HiveRelFactories.HIVE_BUILDER.create(basePlan.getCluster(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50b616456bafcfcc15b80adf0af2dfba94d92012"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjY0OTkwOnYy", "diffSide": "RIGHT", "path": "ql/src/test/queries/clientpositive/sketches_materialized_view_cume_dist.q", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxMzoyNlrOGeZBkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxMzoyNlrOGeZBkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMDQ2Ng==", "bodyText": "this table should be put into a dataset or something in the next patch...", "url": "https://github.com/apache/hive/pull/1031#discussion_r434520466", "createdAt": "2020-06-03T12:13:26Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/test/queries/clientpositive/sketches_materialized_view_cume_dist.q", "diffHunk": "@@ -0,0 +1,54 @@\n+--! qt:transactional\n+set hive.fetch.task.conversion=none;\n+\n+create table sketch_input (id int, category char(1))\n+STORED AS ORC\n+TBLPROPERTIES ('transactional'='true');\n+\n+insert into table sketch_input values", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50b616456bafcfcc15b80adf0af2dfba94d92012"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjY2Njc2OnYy", "diffSide": "RIGHT", "path": "ql/src/test/queries/clientpositive/sketches_materialized_view_cume_dist.q", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxODoyOVrOGeZMHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo0Mjo1N1rOGgOZ0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMzE2NQ==", "bodyText": "it would be handy to introduce an instruction that the next sql statement \"must\" touch the table \"mv_1\"\n--! qt:plan:mustreadtable:mv_1\n\nI don't know implementing something like this is how much of a science fiction - it's certainly possible; however wiring that in might be tricky...", "url": "https://github.com/apache/hive/pull/1031#discussion_r434523165", "createdAt": "2020-06-03T12:18:29Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/test/queries/clientpositive/sketches_materialized_view_cume_dist.q", "diffHunk": "@@ -0,0 +1,54 @@\n+--! qt:transactional\n+set hive.fetch.task.conversion=none;\n+\n+create table sketch_input (id int, category char(1))\n+STORED AS ORC\n+TBLPROPERTIES ('transactional'='true');\n+\n+insert into table sketch_input values\n+  (1,'a'),(1, 'a'), (2, 'a'), (3, 'a'), (4, 'a'), (5, 'a'), (6, 'a'), (7, 'a'), (8, 'a'), (9, 'a'), (10, 'a'),\n+  (6,'b'),(6, 'b'), (7, 'b'), (8, 'b'), (9, 'b'), (10, 'b'), (11, 'b'), (12, 'b'), (13, 'b'), (14, 'b'), (15, 'b')\n+; \n+\n+-- create an mv for the intermediate results\n+create  materialized view mv_1 as\n+  select category,ds_kll_sketch(cast(-id as float)) from sketch_input group by category;\n+\n+-- bi mode on\n+set hive.optimize.bi.enabled=true;\n+\n+explain\n+select 'rewrite; mv matching', id, cume_dist() over (order by id) from sketch_input order by id;\n+select 'rewrite; mv matching', id, cume_dist() over (order by id) from sketch_input order by id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50b616456bafcfcc15b80adf0af2dfba94d92012"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MzYwMA==", "bodyText": "Yes, that's certainly useful. Something that may help for explain plans is to use explain cbo as it is definitely less verbose.", "url": "https://github.com/apache/hive/pull/1031#discussion_r436443600", "createdAt": "2020-06-08T03:42:57Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/sketches_materialized_view_cume_dist.q", "diffHunk": "@@ -0,0 +1,54 @@\n+--! qt:transactional\n+set hive.fetch.task.conversion=none;\n+\n+create table sketch_input (id int, category char(1))\n+STORED AS ORC\n+TBLPROPERTIES ('transactional'='true');\n+\n+insert into table sketch_input values\n+  (1,'a'),(1, 'a'), (2, 'a'), (3, 'a'), (4, 'a'), (5, 'a'), (6, 'a'), (7, 'a'), (8, 'a'), (9, 'a'), (10, 'a'),\n+  (6,'b'),(6, 'b'), (7, 'b'), (8, 'b'), (9, 'b'), (10, 'b'), (11, 'b'), (12, 'b'), (13, 'b'), (14, 'b'), (15, 'b')\n+; \n+\n+-- create an mv for the intermediate results\n+create  materialized view mv_1 as\n+  select category,ds_kll_sketch(cast(-id as float)) from sketch_input group by category;\n+\n+-- bi mode on\n+set hive.optimize.bi.enabled=true;\n+\n+explain\n+select 'rewrite; mv matching', id, cume_dist() over (order by id) from sketch_input order by id;\n+select 'rewrite; mv matching', id, cume_dist() over (order by id) from sketch_input order by id;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMzE2NQ=="}, "originalCommit": {"oid": "50b616456bafcfcc15b80adf0af2dfba94d92012"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjY3MzI2OnYy", "diffSide": "RIGHT", "path": "ql/src/test/queries/clientpositive/sketches_rewrite_cume_dist.q", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoyMDoyMFrOGeZQHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoyMDoyMFrOGeZQHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyNDE4OQ==", "bodyText": "these commands nicely show the original expression and the rewritten one alongside to eachother - it would be nice to also add an assertion that they are in the same neightbourhood", "url": "https://github.com/apache/hive/pull/1031#discussion_r434524189", "createdAt": "2020-06-03T12:20:20Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/test/queries/clientpositive/sketches_rewrite_cume_dist.q", "diffHunk": "@@ -0,0 +1,47 @@\n+--! qt:transactional\n+\n+\n+create table sketch_input (id int, category char(1))\n+STORED AS ORC\n+TBLPROPERTIES ('transactional'='true');\n+\n+insert into table sketch_input values\n+  (1,'a'),(1, 'a'), (2, 'a'), (3, 'a'), (4, 'a'), (5, 'a'), (6, 'a'), (7, 'a'), (8, 'a'), (9, 'a'), (10, 'a'),\n+  (6,'b'),(6, 'b'), (7, 'b'), (8, 'b'), (9, 'b'), (10, 'b'), (11, 'b'), (12, 'b'), (13, 'b'), (14, 'b'), (15, 'b')\n+; \n+\n+select id,cume_dist() over (order by id) from sketch_input;\n+\n+select id,cume_dist() over (order by id),1.0-ds_kll_cdf(ds, CAST(-id AS FLOAT) )[0]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50b616456bafcfcc15b80adf0af2dfba94d92012"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg3OTcxOnYy", "diffSide": "LEFT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/translator/SqlFunctionConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo0OToyOFrOGgOeDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMTozOTowM1rOGhw4ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDY4NA==", "bodyText": "Just to confirm, does this mean that is not distinct from was never used?", "url": "https://github.com/apache/hive/pull/1031#discussion_r436444684", "createdAt": "2020-06-08T03:49:28Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/translator/SqlFunctionConverter.java", "diffHunk": "@@ -392,10 +392,11 @@ private static String getName(GenericUDF hiveUDF) {\n       registerFunction(\"istrue\", SqlStdOperatorTable.IS_TRUE, hToken(HiveParser.Identifier, \"istrue\"));\n       registerFunction(\"isnotfalse\", SqlStdOperatorTable.IS_NOT_FALSE, hToken(HiveParser.Identifier, \"isnotfalse\"));\n       registerFunction(\"isfalse\", SqlStdOperatorTable.IS_FALSE, hToken(HiveParser.Identifier, \"isfalse\"));\n-      registerFunction(\"is not distinct from\", SqlStdOperatorTable.IS_NOT_DISTINCT_FROM, hToken(HiveParser.EQUAL_NS, \"<=>\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf96ee85156125986d366858a52c484087993a8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1NzA4Mw==", "bodyText": "the calcite2hive translation was not working - and thrown an exception\nI'm not sure about hive2calcite ; I've made a note on HIVE-23594 to check out what was happening", "url": "https://github.com/apache/hive/pull/1031#discussion_r438057083", "createdAt": "2020-06-10T11:39:03Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/translator/SqlFunctionConverter.java", "diffHunk": "@@ -392,10 +392,11 @@ private static String getName(GenericUDF hiveUDF) {\n       registerFunction(\"istrue\", SqlStdOperatorTable.IS_TRUE, hToken(HiveParser.Identifier, \"istrue\"));\n       registerFunction(\"isnotfalse\", SqlStdOperatorTable.IS_NOT_FALSE, hToken(HiveParser.Identifier, \"isnotfalse\"));\n       registerFunction(\"isfalse\", SqlStdOperatorTable.IS_FALSE, hToken(HiveParser.Identifier, \"isfalse\"));\n-      registerFunction(\"is not distinct from\", SqlStdOperatorTable.IS_NOT_DISTINCT_FROM, hToken(HiveParser.EQUAL_NS, \"<=>\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDY4NA=="}, "originalCommit": {"oid": "1cf96ee85156125986d366858a52c484087993a8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg4NDI1OnYy", "diffSide": "RIGHT", "path": "ql/src/test/results/clientpositive/llap/cbo_rp_windowing_2.q.out", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo1MzoyMFrOGgOguw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo1NDo0MlrOGgOhmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTM3MQ==", "bodyText": "What has caused this result change? Is it the change in the function helper? We should keep track in case we need to backport to older branches, it seems it is an important correctness issue.", "url": "https://github.com/apache/hive/pull/1031#discussion_r436445371", "createdAt": "2020-06-08T03:53:20Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/results/clientpositive/llap/cbo_rp_windowing_2.q.out", "diffHunk": "@@ -625,32 +625,32 @@ window w1 as (distribute by p_mfgr sort by p_mfgr, p_name rows between 2 precedi\n POSTHOOK: type: QUERY\n POSTHOOK: Input: default@part\n #### A masked pattern was here ####\n-Manufacturer#1\talmond antique burnished rose metallic\t2\t1\t1\t0\t0.0\t1\t2\t2.0\t0.0\t2\t2\t2\n-Manufacturer#1\talmond antique burnished rose metallic\t2\t1\t1\t0\t0.0\t1\t2\t2.0\t0.0\t2\t2\t2\n-Manufacturer#1\talmond antique chartreuse lavender yellow\t34\t3\t2\t0\t0.4\t2\t3\t12.666666666666666\t15.084944665313014\t2\t34\t2\n-Manufacturer#1\talmond antique salmon chartreuse burlywood\t6\t4\t3\t0\t0.6\t2\t4\t11.0\t13.379088160259652\t2\t6\t2\n-Manufacturer#1\talmond aquamarine burnished black steel\t28\t5\t4\t0\t0.8\t3\t5\t14.4\t13.763720427268202\t2\t28\t34\n-Manufacturer#1\talmond aquamarine pink moccasin thistle\t42\t6\t5\t1\t1.0\t3\t6\t19.0\t16.237815945091466\t2\t42\t6\n-Manufacturer#2\talmond antique violet chocolate turquoise\t14\t1\t1\t0\t0.0\t1\t1\t14.0\t0.0\t4\t14\t14\n-Manufacturer#2\talmond antique violet turquoise frosted\t40\t2\t2\t0\t0.25\t1\t2\t27.0\t13.0\t4\t40\t14\n-Manufacturer#2\talmond aquamarine midnight light salmon\t2\t3\t3\t0\t0.5\t2\t3\t18.666666666666668\t15.86050300449376\t4\t2\t14\n-Manufacturer#2\talmond aquamarine rose maroon antique\t25\t4\t4\t0\t0.75\t2\t4\t20.25\t14.00669482783144\t4\t25\t40\n-Manufacturer#2\talmond aquamarine sandy cyan gainsboro\t18\t5\t5\t1\t1.0\t3\t5\t19.8\t12.560254774486067\t4\t18\t2\n-Manufacturer#3\talmond antique chartreuse khaki white\t17\t1\t1\t0\t0.0\t1\t1\t17.0\t0.0\t2\t17\t17\n-Manufacturer#3\talmond antique forest lavender goldenrod\t14\t2\t2\t0\t0.25\t1\t2\t15.5\t1.5\t2\t14\t17\n-Manufacturer#3\talmond antique metallic orange dim\t19\t3\t3\t0\t0.5\t2\t3\t16.666666666666668\t2.0548046676563256\t2\t19\t17\n-Manufacturer#3\talmond antique misty red olive\t1\t4\t4\t0\t0.75\t2\t4\t12.75\t7.013380069552769\t2\t1\t14\n-Manufacturer#3\talmond antique olive coral navajo\t45\t5\t5\t1\t1.0\t3\t5\t19.2\t14.344336861632886\t2\t45\t19\n-Manufacturer#4\talmond antique gainsboro frosted violet\t10\t1\t1\t0\t0.0\t1\t1\t10.0\t0.0\t0\t10\t10\n-Manufacturer#4\talmond antique violet mint lemon\t39\t2\t2\t0\t0.25\t1\t2\t24.5\t14.5\t0\t39\t10\n-Manufacturer#4\talmond aquamarine floral ivory bisque\t27\t3\t3\t0\t0.5\t2\t3\t25.333333333333332\t11.897712198383164\t0\t27\t10\n-Manufacturer#4\talmond aquamarine yellow dodger mint\t7\t4\t4\t0\t0.75\t2\t4\t20.75\t13.007209539328564\t0\t7\t39\n-Manufacturer#4\talmond azure aquamarine papaya violet\t12\t5\t5\t1\t1.0\t3\t5\t19.0\t12.149074038789951\t0\t12\t27\n-Manufacturer#5\talmond antique blue firebrick mint\t31\t1\t1\t0\t0.0\t1\t1\t31.0\t0.0\t1\t31\t31\n-Manufacturer#5\talmond antique medium spring khaki\t6\t2\t2\t0\t0.25\t1\t2\t18.5\t12.5\t1\t6\t31\n-Manufacturer#5\talmond antique sky peru orange\t2\t3\t3\t0\t0.5\t2\t3\t13.0\t12.832251036613439\t1\t2\t31\n-Manufacturer#5\talmond aquamarine dodger light gainsboro\t46\t4\t4\t0\t0.75\t2\t4\t21.25\t18.102140757380052\t1\t46\t6\n-Manufacturer#5\talmond azure blanched chiffon midnight\t23\t5\t5\t1\t1.0\t3\t5\t21.6\t16.206171663906314\t1\t23\t2\n+Manufacturer#1\talmond antique burnished rose metallic\t2\t1\t1\t0.3333333333333333\t0.0\t1\t2\t2.0\t0.0\t2\t2\t2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf96ee85156125986d366858a52c484087993a8"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTU5NQ==", "bodyText": "OK, I just saw you referred to it in the JIRA comment (HIVE-23527). Thanks", "url": "https://github.com/apache/hive/pull/1031#discussion_r436445595", "createdAt": "2020-06-08T03:54:42Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/results/clientpositive/llap/cbo_rp_windowing_2.q.out", "diffHunk": "@@ -625,32 +625,32 @@ window w1 as (distribute by p_mfgr sort by p_mfgr, p_name rows between 2 precedi\n POSTHOOK: type: QUERY\n POSTHOOK: Input: default@part\n #### A masked pattern was here ####\n-Manufacturer#1\talmond antique burnished rose metallic\t2\t1\t1\t0\t0.0\t1\t2\t2.0\t0.0\t2\t2\t2\n-Manufacturer#1\talmond antique burnished rose metallic\t2\t1\t1\t0\t0.0\t1\t2\t2.0\t0.0\t2\t2\t2\n-Manufacturer#1\talmond antique chartreuse lavender yellow\t34\t3\t2\t0\t0.4\t2\t3\t12.666666666666666\t15.084944665313014\t2\t34\t2\n-Manufacturer#1\talmond antique salmon chartreuse burlywood\t6\t4\t3\t0\t0.6\t2\t4\t11.0\t13.379088160259652\t2\t6\t2\n-Manufacturer#1\talmond aquamarine burnished black steel\t28\t5\t4\t0\t0.8\t3\t5\t14.4\t13.763720427268202\t2\t28\t34\n-Manufacturer#1\talmond aquamarine pink moccasin thistle\t42\t6\t5\t1\t1.0\t3\t6\t19.0\t16.237815945091466\t2\t42\t6\n-Manufacturer#2\talmond antique violet chocolate turquoise\t14\t1\t1\t0\t0.0\t1\t1\t14.0\t0.0\t4\t14\t14\n-Manufacturer#2\talmond antique violet turquoise frosted\t40\t2\t2\t0\t0.25\t1\t2\t27.0\t13.0\t4\t40\t14\n-Manufacturer#2\talmond aquamarine midnight light salmon\t2\t3\t3\t0\t0.5\t2\t3\t18.666666666666668\t15.86050300449376\t4\t2\t14\n-Manufacturer#2\talmond aquamarine rose maroon antique\t25\t4\t4\t0\t0.75\t2\t4\t20.25\t14.00669482783144\t4\t25\t40\n-Manufacturer#2\talmond aquamarine sandy cyan gainsboro\t18\t5\t5\t1\t1.0\t3\t5\t19.8\t12.560254774486067\t4\t18\t2\n-Manufacturer#3\talmond antique chartreuse khaki white\t17\t1\t1\t0\t0.0\t1\t1\t17.0\t0.0\t2\t17\t17\n-Manufacturer#3\talmond antique forest lavender goldenrod\t14\t2\t2\t0\t0.25\t1\t2\t15.5\t1.5\t2\t14\t17\n-Manufacturer#3\talmond antique metallic orange dim\t19\t3\t3\t0\t0.5\t2\t3\t16.666666666666668\t2.0548046676563256\t2\t19\t17\n-Manufacturer#3\talmond antique misty red olive\t1\t4\t4\t0\t0.75\t2\t4\t12.75\t7.013380069552769\t2\t1\t14\n-Manufacturer#3\talmond antique olive coral navajo\t45\t5\t5\t1\t1.0\t3\t5\t19.2\t14.344336861632886\t2\t45\t19\n-Manufacturer#4\talmond antique gainsboro frosted violet\t10\t1\t1\t0\t0.0\t1\t1\t10.0\t0.0\t0\t10\t10\n-Manufacturer#4\talmond antique violet mint lemon\t39\t2\t2\t0\t0.25\t1\t2\t24.5\t14.5\t0\t39\t10\n-Manufacturer#4\talmond aquamarine floral ivory bisque\t27\t3\t3\t0\t0.5\t2\t3\t25.333333333333332\t11.897712198383164\t0\t27\t10\n-Manufacturer#4\talmond aquamarine yellow dodger mint\t7\t4\t4\t0\t0.75\t2\t4\t20.75\t13.007209539328564\t0\t7\t39\n-Manufacturer#4\talmond azure aquamarine papaya violet\t12\t5\t5\t1\t1.0\t3\t5\t19.0\t12.149074038789951\t0\t12\t27\n-Manufacturer#5\talmond antique blue firebrick mint\t31\t1\t1\t0\t0.0\t1\t1\t31.0\t0.0\t1\t31\t31\n-Manufacturer#5\talmond antique medium spring khaki\t6\t2\t2\t0\t0.25\t1\t2\t18.5\t12.5\t1\t6\t31\n-Manufacturer#5\talmond antique sky peru orange\t2\t3\t3\t0\t0.5\t2\t3\t13.0\t12.832251036613439\t1\t2\t31\n-Manufacturer#5\talmond aquamarine dodger light gainsboro\t46\t4\t4\t0\t0.75\t2\t4\t21.25\t18.102140757380052\t1\t46\t6\n-Manufacturer#5\talmond azure blanched chiffon midnight\t23\t5\t5\t1\t1.0\t3\t5\t21.6\t16.206171663906314\t1\t23\t2\n+Manufacturer#1\talmond antique burnished rose metallic\t2\t1\t1\t0.3333333333333333\t0.0\t1\t2\t2.0\t0.0\t2\t2\t2", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTM3MQ=="}, "originalCommit": {"oid": "1cf96ee85156125986d366858a52c484087993a8"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 714, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}