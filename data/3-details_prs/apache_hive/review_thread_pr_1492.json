{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2MDgyOTg3", "number": 1492, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxMDoyMzowM1rOEi3CBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMDozNDowNlrOEoBRPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTg4Njc4OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxMDoyMzowM1rOHQ7TJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNTo0ODozN1rOHQ9ZaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMDgyMw==", "bodyText": "oh my; Constrain had it's constructor arguments swapped! what a typo!", "url": "https://github.com/apache/hive/pull/1492#discussion_r487510823", "createdAt": "2020-09-13T10:23:03Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -599,7 +587,7 @@ public ConstraintGroup(RexNode rexNode) {\n           if (constraint == null) {\n             throw new SemanticException(\"Unable to find constraint which was earlier added.\");\n           }\n-          ret.add(constraint.exprNode);\n+          ret.add(constraint.constNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU0NTE5Mw==", "bodyText": "I was also surprised we did not catch it before! But that's OK, it was working as expected and now they are swapped back!", "url": "https://github.com/apache/hive/pull/1492#discussion_r487545193", "createdAt": "2020-09-13T15:48:37Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -599,7 +587,7 @@ public ConstraintGroup(RexNode rexNode) {\n           if (constraint == null) {\n             throw new SemanticException(\"Unable to find constraint which was earlier added.\");\n           }\n-          ret.add(constraint.exprNode);\n+          ret.add(constraint.constNode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMDgyMw=="}, "originalCommit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d"}, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTg4OTcyOnYy", "diffSide": "RIGHT", "path": "ql/src/test/results/clientpositive/perf/tez/constraints/cbo_query74.q.out", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxMDoyNjoyM1rOHQ7UgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNjowMjo1MlrOHQ9fFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMTE2OQ==", "bodyText": "I see that this patch works - but would have thinked that we didn't need something like this anymore - because IN is opened in an early phase - so Calcite should see a bunch of ANDs and ORs - and if that's true - RexSimplify could make this simplification - and there would be no need to enhance PointLookup...\nI wonder how the IN was retained ...or re-created...", "url": "https://github.com/apache/hive/pull/1492#discussion_r487511169", "createdAt": "2020-09-13T10:26:23Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/test/results/clientpositive/perf/tez/constraints/cbo_query74.q.out", "diffHunk": "@@ -147,7 +147,7 @@ HiveSortLimit(sort0=[$2], sort1=[$0], sort2=[$1], dir0=[ASC], dir1=[ASC], dir2=[\n                           HiveProject(ss_sold_date_sk=[$0], ss_customer_sk=[$3], ss_net_paid=[$20])\n                             HiveTableScan(table=[[default, store_sales]], table:alias=[store_sales])\n                       HiveProject(d_date_sk=[$0])\n-                        HiveFilter(condition=[AND(=($1, 1999), IN($1, 1998, 1999))])\n+                        HiveFilter(condition=[=($1, 1999)])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU0NjY0Ng==", "bodyText": "What seems to happen is that we close these IN clauses before we call the join propagation rule, which leads to the inference of new predicates. Then the RexSimplify does not deal with the IN+EQUALS clauses and the HivePointLookup cannot deal with the EQUALS.\nWe could possibly change the rules order too but I was not brave enough to do that :) Plus I think supporting the degenerate case of EQUALS in HivePointLookup should be fine.\nIirc there is work going on in Calcite to finally have more extensive support for IN in RexSimplify, which you suggested some time ago... I hope that work goes in and we can simplify this whole code path.", "url": "https://github.com/apache/hive/pull/1492#discussion_r487546646", "createdAt": "2020-09-13T16:02:52Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/results/clientpositive/perf/tez/constraints/cbo_query74.q.out", "diffHunk": "@@ -147,7 +147,7 @@ HiveSortLimit(sort0=[$2], sort1=[$0], sort2=[$1], dir0=[ASC], dir1=[ASC], dir2=[\n                           HiveProject(ss_sold_date_sk=[$0], ss_customer_sk=[$3], ss_net_paid=[$20])\n                             HiveTableScan(table=[[default, store_sales]], table:alias=[store_sales])\n                       HiveProject(d_date_sk=[$0])\n-                        HiveFilter(condition=[AND(=($1, 1999), IN($1, 1998, 1999))])\n+                        HiveFilter(condition=[=($1, 1999)])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMTE2OQ=="}, "originalCommit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTg5MDIxOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxMDoyNzowMlrOHQ7UwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNjowMzo0OVrOHQ9fXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMTIzMw==", "bodyText": "note: we have RexNode-s are comparable; this string2expr stuff is not neccessarily needed anymore", "url": "https://github.com/apache/hive/pull/1492#discussion_r487511233", "createdAt": "2020-09-13T10:27:02Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -734,6 +721,30 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n               }\n               operands.remove(i);\n               --i;\n+            } else if (operand.getKind() == SqlKind.EQUALS) {\n+              Constraint c = Constraint.of(operand);\n+              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+                continue;\n+              }\n+              String ref = c.exprNode.toString();\n+              stringToExpr.put(ref, c.exprNode);\n+              if (inLHSExprToRHSExprs.containsKey(ref)) {\n+                String expr = c.constNode.toString();\n+                stringToExpr.put(expr, c.constNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU0NjcxNg==", "bodyText": "Makes sense, I will simplify this code.", "url": "https://github.com/apache/hive/pull/1492#discussion_r487546716", "createdAt": "2020-09-13T16:03:49Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -734,6 +721,30 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n               }\n               operands.remove(i);\n               --i;\n+            } else if (operand.getKind() == SqlKind.EQUALS) {\n+              Constraint c = Constraint.of(operand);\n+              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+                continue;\n+              }\n+              String ref = c.exprNode.toString();\n+              stringToExpr.put(ref, c.exprNode);\n+              if (inLHSExprToRHSExprs.containsKey(ref)) {\n+                String expr = c.constNode.toString();\n+                stringToExpr.put(expr, c.constNode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMTIzMw=="}, "originalCommit": {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d"}, "originalPosition": 333}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1ODE5MTg2OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTozNjo1NFrOHSH6cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTo0ODowMVrOHSIaHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2NjA2Ng==", "bodyText": "I think this may not neccessarily false; consider:\nx=1 and x=2\n\nwhich is not true; but in case x is null - the result of the AND will be null\ninstead of false this could be only rewritten to x is null and null; but even in that case there could be other stuff which might affect null/false;\nso I think we may not do a return here.", "url": "https://github.com/apache/hive/pull/1492#discussion_r488766066", "createdAt": "2020-09-15T15:36:54Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -727,44 +708,58 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n                 }\n               } else {\n                 for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  String expr = inCall.getOperands().get(j).toString();\n-                  inLHSExprToRHSExprs.put(ref, expr);\n-                  stringToExpr.put(expr, inCall.getOperands().get(j));\n+                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+                }\n+              }\n+              operands.remove(i);\n+              --i;\n+            } else if (operand.getKind() == SqlKind.EQUALS) {\n+              Constraint c = Constraint.of(operand);\n+              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+                continue;\n+              }\n+              RexNode ref = c.exprNode;\n+              if (inLHSExprToRHSExprs.containsKey(ref)) {\n+                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n+                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+                  // Note that Multimap does not keep a key if all its values are removed.\n+                  // Hence, since there are no common expressions and it is within an AND,\n+                  // we should return false\n+                  return rexBuilder.makeLiteral(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0e9aca03d96186a54cbd2edaa15df37f8701b7"}, "originalPosition": 385}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NDE3Mg==", "bodyText": "Good catch. It seems the problem was already there though. I am revisiting this logic.", "url": "https://github.com/apache/hive/pull/1492#discussion_r488774172", "createdAt": "2020-09-15T15:48:01Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -727,44 +708,58 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n                 }\n               } else {\n                 for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  String expr = inCall.getOperands().get(j).toString();\n-                  inLHSExprToRHSExprs.put(ref, expr);\n-                  stringToExpr.put(expr, inCall.getOperands().get(j));\n+                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+                }\n+              }\n+              operands.remove(i);\n+              --i;\n+            } else if (operand.getKind() == SqlKind.EQUALS) {\n+              Constraint c = Constraint.of(operand);\n+              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+                continue;\n+              }\n+              RexNode ref = c.exprNode;\n+              if (inLHSExprToRHSExprs.containsKey(ref)) {\n+                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n+                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+                  // Note that Multimap does not keep a key if all its values are removed.\n+                  // Hence, since there are no common expressions and it is within an AND,\n+                  // we should return false\n+                  return rexBuilder.makeLiteral(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2NjA2Ng=="}, "originalCommit": {"oid": "5a0e9aca03d96186a54cbd2edaa15df37f8701b7"}, "originalPosition": 385}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MjI2NTc3OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjo1MzowOFrOHSvXYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjo1MzowOFrOHSvXYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxMjQ0OQ==", "bodyText": "I believe this would not need to be a CASE it could be an AND as well\n(x IS NULL OR y IS NULL) AND null\n\nbut I know - it won't make much difference - the CASE might be more readbale :)", "url": "https://github.com/apache/hive/pull/1492#discussion_r489412449", "createdAt": "2020-09-16T12:53:08Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);\n+            }\n+          } else {\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              inLHSExprToRHSExprs.put(ref, constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              operands.remove(i);\n-              --i;\n             }\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n-          break;\n-        case OR:\n-          // IN clauses need to be combined by keeping all elements\n-          operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-              }\n-              operands.remove(i);\n-              --i;\n+          operands.remove(i);\n+          --i;\n+        } else if (operand.getKind() == SqlKind.EQUALS) {\n+          Constraint c = Constraint.of(operand);\n+          if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+            continue;\n+          }\n+          if (c.exprNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.exprNode);\n+          }\n+          if (c.constNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.constNode);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+            inLHSExprToRHSExprs.get(c.exprNode).retainAll(Collections.singleton(c.constNode));\n+            if (!inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, c.exprNode, inLHSExprToRHSNullableExprs);\n             }\n+          } else {\n+            inLHSExprToRHSExprs.put(c.exprNode, c.constNode);\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n-          break;\n-        default:\n-          return super.visitCall(call);\n+          operands.remove(i);\n+          --i;\n+        }\n       }\n-      return node;\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode handleOR(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping all elements\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          for (int j = 1; j < inCall.getOperands().size(); j++) {\n+            inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+          }\n+          operands.remove(i);\n+          --i;\n+        }\n+      }\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode createResultFromEmptySet(RexBuilder rexBuilder,\n+        RexNode ref, Multimap<RexNode, RexNode> inLHSExprToRHSNullableExprs) {\n+      if (inLHSExprToRHSNullableExprs.containsKey(ref)) {\n+        // We handle possible null values in the expressions.\n+        List<RexNode> nullableExprs =\n+            inLHSExprToRHSNullableExprs.get(ref)\n+                .stream()\n+                .map(n -> rexBuilder.makeCall(SqlStdOperatorTable.IS_NULL, ImmutableList.of(n)))\n+                .collect(Collectors.toList());\n+        return rexBuilder.makeCall(SqlStdOperatorTable.CASE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db45b1d73397dea3699811bb43f7083486241be7"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MjI3Mjc5OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjo1NDo1NlrOHSvbzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjo1NDo1NlrOHSvbzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxMzU4Mg==", "bodyText": "at this point - aren't we in the middle of processing all the operands of the AND?\nx IN (1,2) AND x IN (3,4) AND y IN (1,2)\n\nI suspect for the above expression we don't know anything about y (yet) - isn't that a problem?", "url": "https://github.com/apache/hive/pull/1492#discussion_r489413582", "createdAt": "2020-09-16T12:54:56Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db45b1d73397dea3699811bb43f7083486241be7"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MjMxMzIxOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMzowNDoyN1rOHSv0zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxOTo1Njo0NVrOHTCEpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxOTk4Mg==", "bodyText": "right now I don't fully agree with this logic - if we have an expression like:\nx IN (1,2) AND x in (3,4) and y IN (5,6)\n\nit's clear that we may only return false or null; but I think we may still need to choose false based on the other expressions; for the above:\n\nwhen x is null, y=5 then the result will be null\nbut when x is null, y=1 then the result will be false\n\nin light of this reasoning it seem to me that this starts looking more and more sophisticated....\nI think it might worth a try to see if these \"early-return-type\" simplifications kick-in a lot or not - and as an alternative approach consider removing them instead of saving them.\nI think at some point we should run the simplification earlier when the ORs are still open - so that it could analyze-it properly", "url": "https://github.com/apache/hive/pull/1492#discussion_r489419982", "createdAt": "2020-09-16T13:04:27Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);\n+            }\n+          } else {\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              inLHSExprToRHSExprs.put(ref, constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              operands.remove(i);\n-              --i;\n             }\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n-          break;\n-        case OR:\n-          // IN clauses need to be combined by keeping all elements\n-          operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-              }\n-              operands.remove(i);\n-              --i;\n+          operands.remove(i);\n+          --i;\n+        } else if (operand.getKind() == SqlKind.EQUALS) {\n+          Constraint c = Constraint.of(operand);\n+          if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+            continue;\n+          }\n+          if (c.exprNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.exprNode);\n+          }\n+          if (c.constNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.constNode);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+            inLHSExprToRHSExprs.get(c.exprNode).retainAll(Collections.singleton(c.constNode));\n+            if (!inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, c.exprNode, inLHSExprToRHSNullableExprs);\n             }\n+          } else {\n+            inLHSExprToRHSExprs.put(c.exprNode, c.constNode);\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n-          break;\n-        default:\n-          return super.visitCall(call);\n+          operands.remove(i);\n+          --i;\n+        }\n       }\n-      return node;\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode handleOR(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping all elements\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          for (int j = 1; j < inCall.getOperands().size(); j++) {\n+            inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+          }\n+          operands.remove(i);\n+          --i;\n+        }\n+      }\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode createResultFromEmptySet(RexBuilder rexBuilder,\n+        RexNode ref, Multimap<RexNode, RexNode> inLHSExprToRHSNullableExprs) {\n+      if (inLHSExprToRHSNullableExprs.containsKey(ref)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db45b1d73397dea3699811bb43f7083486241be7"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUwMTIwNg==", "bodyText": "I agree. Isn't enough to move the logic to deal with the empty case to the end, instead of doing early bail out? I think that would fix the issue. I need to deal with the empty case in some way.\nI prefer to avoid moving the rule at this stage and keep the change focused within the rule. Otherwise, we may have to deal with closing and re-opening, plus the fix seems more risky (including backporting).", "url": "https://github.com/apache/hive/pull/1492#discussion_r489501206", "createdAt": "2020-09-16T14:52:55Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);\n+            }\n+          } else {\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              inLHSExprToRHSExprs.put(ref, constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              operands.remove(i);\n-              --i;\n             }\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n-          break;\n-        case OR:\n-          // IN clauses need to be combined by keeping all elements\n-          operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-              }\n-              operands.remove(i);\n-              --i;\n+          operands.remove(i);\n+          --i;\n+        } else if (operand.getKind() == SqlKind.EQUALS) {\n+          Constraint c = Constraint.of(operand);\n+          if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+            continue;\n+          }\n+          if (c.exprNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.exprNode);\n+          }\n+          if (c.constNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.constNode);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+            inLHSExprToRHSExprs.get(c.exprNode).retainAll(Collections.singleton(c.constNode));\n+            if (!inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, c.exprNode, inLHSExprToRHSNullableExprs);\n             }\n+          } else {\n+            inLHSExprToRHSExprs.put(c.exprNode, c.constNode);\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n-          break;\n-        default:\n-          return super.visitCall(call);\n+          operands.remove(i);\n+          --i;\n+        }\n       }\n-      return node;\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode handleOR(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping all elements\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          for (int j = 1; j < inCall.getOperands().size(); j++) {\n+            inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+          }\n+          operands.remove(i);\n+          --i;\n+        }\n+      }\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode createResultFromEmptySet(RexBuilder rexBuilder,\n+        RexNode ref, Multimap<RexNode, RexNode> inLHSExprToRHSNullableExprs) {\n+      if (inLHSExprToRHSNullableExprs.containsKey(ref)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxOTk4Mg=="}, "originalCommit": {"oid": "db45b1d73397dea3699811bb43f7083486241be7"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU4MTY2Mg==", "bodyText": "isn't enough to move the logic to deal with the empty case to the end\n\nof course - that could work as well! I just wanted to suggest that in case there is no \"big benefit\" keeping it - we may remove it as well - it contained correctness issues before this patch :)\n\nI prefer to avoid moving the rule at this stage and keep the change focused within the rule.\n\nI only wanted to note that we should do that sometime later on", "url": "https://github.com/apache/hive/pull/1492#discussion_r489581662", "createdAt": "2020-09-16T16:50:02Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);\n+            }\n+          } else {\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              inLHSExprToRHSExprs.put(ref, constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              operands.remove(i);\n-              --i;\n             }\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n-          break;\n-        case OR:\n-          // IN clauses need to be combined by keeping all elements\n-          operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-              }\n-              operands.remove(i);\n-              --i;\n+          operands.remove(i);\n+          --i;\n+        } else if (operand.getKind() == SqlKind.EQUALS) {\n+          Constraint c = Constraint.of(operand);\n+          if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+            continue;\n+          }\n+          if (c.exprNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.exprNode);\n+          }\n+          if (c.constNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.constNode);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+            inLHSExprToRHSExprs.get(c.exprNode).retainAll(Collections.singleton(c.constNode));\n+            if (!inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, c.exprNode, inLHSExprToRHSNullableExprs);\n             }\n+          } else {\n+            inLHSExprToRHSExprs.put(c.exprNode, c.constNode);\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n-          break;\n-        default:\n-          return super.visitCall(call);\n+          operands.remove(i);\n+          --i;\n+        }\n       }\n-      return node;\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode handleOR(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping all elements\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          for (int j = 1; j < inCall.getOperands().size(); j++) {\n+            inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+          }\n+          operands.remove(i);\n+          --i;\n+        }\n+      }\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode createResultFromEmptySet(RexBuilder rexBuilder,\n+        RexNode ref, Multimap<RexNode, RexNode> inLHSExprToRHSNullableExprs) {\n+      if (inLHSExprToRHSNullableExprs.containsKey(ref)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxOTk4Mg=="}, "originalCommit": {"oid": "db45b1d73397dea3699811bb43f7083486241be7"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTcxODk1MQ==", "bodyText": "@kgyrtkirk I pushed a new commit and added a few more test cases.", "url": "https://github.com/apache/hive/pull/1492#discussion_r489718951", "createdAt": "2020-09-16T19:56:45Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);\n+            }\n+          } else {\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              inLHSExprToRHSExprs.put(ref, constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              operands.remove(i);\n-              --i;\n             }\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n-          break;\n-        case OR:\n-          // IN clauses need to be combined by keeping all elements\n-          operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-              }\n-              operands.remove(i);\n-              --i;\n+          operands.remove(i);\n+          --i;\n+        } else if (operand.getKind() == SqlKind.EQUALS) {\n+          Constraint c = Constraint.of(operand);\n+          if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+            continue;\n+          }\n+          if (c.exprNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.exprNode);\n+          }\n+          if (c.constNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.constNode);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+            inLHSExprToRHSExprs.get(c.exprNode).retainAll(Collections.singleton(c.constNode));\n+            if (!inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, c.exprNode, inLHSExprToRHSNullableExprs);\n             }\n+          } else {\n+            inLHSExprToRHSExprs.put(c.exprNode, c.constNode);\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n-          break;\n-        default:\n-          return super.visitCall(call);\n+          operands.remove(i);\n+          --i;\n+        }\n       }\n-      return node;\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode handleOR(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping all elements\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          for (int j = 1; j < inCall.getOperands().size(); j++) {\n+            inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+          }\n+          operands.remove(i);\n+          --i;\n+        }\n+      }\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode createResultFromEmptySet(RexBuilder rexBuilder,\n+        RexNode ref, Multimap<RexNode, RexNode> inLHSExprToRHSNullableExprs) {\n+      if (inLHSExprToRHSNullableExprs.containsKey(ref)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxOTk4Mg=="}, "originalCommit": {"oid": "db45b1d73397dea3699811bb43f7083486241be7"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzk5MjkyOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMDozNDowNlrOHY33QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxOTozNFrOHZISGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg0MzEzNw==", "bodyText": "Is there any particular reason why do we need this? (I think it was not needed before)\nI believe this will at most only add a cast to wieden nullability", "url": "https://github.com/apache/hive/pull/1492#discussion_r495843137", "createdAt": "2020-09-28T10:34:06Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -757,10 +752,15 @@ private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n         }\n       }\n       // Create IN clauses\n-      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      final List<RexNode> newOperands = createInClauses(rexBuilder,\n+          visitedRefs, inLHSExprToRHSExprs, inLHSExprToRHSNullableExprs);\n       newOperands.addAll(operands);\n       // Return node\n-      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+      RexNode result = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+      if (!result.getType().equals(call.getType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "193fb77a8d425c68e5e4c8848fcaf68f9bb863f6"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMjE1Mg==", "bodyText": "Once again, good catch. This compensation was coming from a previous version of the patch :( I have pushed a new commit.", "url": "https://github.com/apache/hive/pull/1492#discussion_r496112152", "createdAt": "2020-09-28T17:19:34Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -757,10 +752,15 @@ private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n         }\n       }\n       // Create IN clauses\n-      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      final List<RexNode> newOperands = createInClauses(rexBuilder,\n+          visitedRefs, inLHSExprToRHSExprs, inLHSExprToRHSNullableExprs);\n       newOperands.addAll(operands);\n       // Return node\n-      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+      RexNode result = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+      if (!result.getType().equals(call.getType())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg0MzEzNw=="}, "originalCommit": {"oid": "193fb77a8d425c68e5e4c8848fcaf68f9bb863f6"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 430, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}