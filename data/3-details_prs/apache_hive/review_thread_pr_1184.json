{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMTM4NTQ5", "number": 1184, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMTo1ODowMFrOERrGaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjowMzo1NlrOERrJ3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTY3NDAzOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveCardinalityPreservingJoinOptimization.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMTo1ODowMFrOG2hGSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNzoyMzo0NFrOG23rBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxODU3MQ==", "bodyText": "LOG.debug(\"Lineage of expression can not be determined: {}\", expr);", "url": "https://github.com/apache/hive/pull/1184#discussion_r459818571", "createdAt": "2020-07-24T01:58:00Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveCardinalityPreservingJoinOptimization.java", "diffHunk": "@@ -161,127 +174,118 @@ public RelNode trim(RelBuilder relBuilder, RelNode root) {\n         return root;\n       }\n \n-      // 4. Collect fields for new Project on the top of Join backs\n+      // 3. Join back tables to the top of original plan\n       Mapping newInputMapping = trimResult.right;\n-      RexNode[] newProjects = new RexNode[rootFieldList.size()];\n-      String[] newColumnNames = new String[rootFieldList.size()];\n-      projectsFromOriginalPlan(rexBuilder, newInput.getRowType().getFieldCount(), newInput, newInputMapping,\n-          newProjects, newColumnNames);\n+      Map<RexTableInputRef, Integer> tableInputRefMapping = new HashMap<>();\n \n-      // 5. Join back tables to the top of original plan\n       for (TableToJoinBack tableToJoinBack : tableToJoinBackList) {\n-        LOG.debug(\"Joining back table \" + tableToJoinBack.projectedFields.relOptHiveTable.getName());\n+        LOG.debug(\"Joining back table \" + tableToJoinBack.joinedBackFields.relOptHiveTable.getName());\n \n-        // 5.1 Create new TableScan of tables to join back\n-        RelOptHiveTable relOptTable = tableToJoinBack.projectedFields.relOptHiveTable;\n+        // 3.1. Create new TableScan of tables to join back\n+        RelOptHiveTable relOptTable = tableToJoinBack.joinedBackFields.relOptHiveTable;\n         RelOptCluster cluster = relBuilder.getCluster();\n         HiveTableScan tableScan = new HiveTableScan(cluster, cluster.traitSetOf(HiveRelNode.CONVENTION),\n             relOptTable, relOptTable.getHiveTableMD().getTableName(), null, false, false);\n-        // 5.2 Project only required fields from this table\n+        // 3.2. Create Project with the required fields from this table\n         RelNode projectTableAccessRel = tableScan.project(\n-            tableToJoinBack.projectedFields.fieldsInSourceTable, new HashSet<>(0), REL_BUILDER.get());\n+            tableToJoinBack.joinedBackFields.fieldsInSourceTable, new HashSet<>(0), REL_BUILDER.get());\n \n-        Mapping keyMapping = Mappings.create(MappingType.INVERSE_SURJECTION,\n-            tableScan.getRowType().getFieldCount(), tableToJoinBack.keys.cardinality());\n+        // 3.3. Create mapping between the Project and TableScan\n+        Mapping projectMapping = Mappings.create(MappingType.INVERSE_SURJECTION,\n+            tableScan.getRowType().getFieldCount(),\n+            tableToJoinBack.joinedBackFields.fieldsInSourceTable.cardinality());\n         int projectIndex = 0;\n+        for (int i : tableToJoinBack.joinedBackFields.fieldsInSourceTable) {\n+          projectMapping.set(i, projectIndex);\n+          ++projectIndex;\n+        }\n+\n         int offset = newInput.getRowType().getFieldCount();\n \n-        for (int source : tableToJoinBack.projectedFields.fieldsInSourceTable) {\n-          if (tableToJoinBack.keys.get(source)) {\n-            // 5.3 Map key field to it's index in the Project on the TableScan\n-            keyMapping.set(source, projectIndex);\n-          } else {\n-            // 5.4 if this is not a key field then we need it in the new Project on the top of Join backs\n-            ProjectMapping currentProjectMapping =\n-                tableToJoinBack.projectedFields.mapping.stream()\n-                    .filter(projectMapping -> projectMapping.indexInSourceTable == source)\n-                    .findFirst().get();\n-            addToProject(projectTableAccessRel, projectIndex, rexBuilder,\n-                offset + projectIndex,\n-                currentProjectMapping.indexInRootProject,\n-                newProjects, newColumnNames);\n+        // 3.4. Map rexTableInputRef to the index where it can be found in the new Input row type\n+        for (TableInputRefHolder mapping : tableToJoinBack.joinedBackFields.mapping) {\n+          int indexInSourceTable = mapping.tableInputRef.getIndex();\n+          if (!tableToJoinBack.keys.get(indexInSourceTable)) {\n+            // 3.5. if this is not a key field it is shifted by the left input field count\n+            tableInputRefMapping.put(mapping.tableInputRef, offset + projectMapping.getTarget(indexInSourceTable));\n           }\n-          ++projectIndex;\n         }\n \n-        // 5.5 Create Join\n+        // 3.7. Create Join\n         relBuilder.push(newInput);\n         relBuilder.push(projectTableAccessRel);\n \n         RexNode joinCondition = joinCondition(\n-            newInput, newInputMapping, tableToJoinBack, projectTableAccessRel, keyMapping, rexBuilder);\n+            newInput, newInputMapping, tableToJoinBack, projectTableAccessRel, projectMapping, rexBuilder);\n \n         newInput = relBuilder.join(JoinRelType.INNER, joinCondition).build();\n       }\n \n-      // 6 Create Project on top of all Join backs\n+      // 4. Collect rexNodes for Project\n+      TableInputRefMapper mapper = new TableInputRefMapper(tableInputRefMapping, rexBuilder, newInput);\n+      List<RexNode> rexNodeList = new ArrayList<>(rootInput.getRowType().getFieldCount());\n+      for (int i = 0; i < rootInput.getRowType().getFieldCount(); i++) {\n+        RexNode rexNode = rexNodesToShuttle.get(i);\n+        if (rexNode != null) {\n+          rexNodeList.add(mapper.apply(rexNode));\n+        } else {\n+          int target = newInputMapping.getTarget(i);\n+          rexNodeList.add(\n+              rexBuilder.makeInputRef(newInput.getRowType().getFieldList().get(target).getType(), target));\n+        }\n+      }\n+\n+      // 5. Create Project on top of all Join backs\n       relBuilder.push(newInput);\n-      relBuilder.project(asList(newProjects), asList(newColumnNames));\n+      relBuilder.project(rexNodeList, newColumnNames);\n \n       return root.copy(root.getTraitSet(), singletonList(relBuilder.build()));\n     } finally {\n       REL_BUILDER.remove();\n     }\n   }\n \n-  private List<ProjectedFields> getExpressionLineageOf(\n+  private List<JoinedBackFields> getExpressionLineageOf(\n       List<RexInputRef> projectExpressions, RelNode projectInput) {\n     RelMetadataQuery relMetadataQuery = RelMetadataQuery.instance();\n-    Map<RexTableInputRef.RelTableRef, ProjectedFieldsBuilder> fieldMappingBuilders = new HashMap<>();\n+    Map<RexTableInputRef.RelTableRef, JoinedBackFieldsBuilder> fieldMappingBuilders = new HashMap<>();\n     List<RexTableInputRef.RelTableRef> tablesOrdered = new ArrayList<>(); // use this list to keep the order of tables\n     for (RexInputRef expr : projectExpressions) {\n       Set<RexNode> expressionLineage = relMetadataQuery.getExpressionLineage(projectInput, expr);\n       if (expressionLineage == null || expressionLineage.size() != 1) {\n-        LOG.debug(\"Lineage can not be determined of expression: \" + expr);\n+        LOG.debug(\"Lineage of expression can not be determined: \" + expr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c504d19d72e153235a9e5c1a74b6185fb2376b87"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4ODQyMg==", "bodyText": "fixed", "url": "https://github.com/apache/hive/pull/1184#discussion_r460188422", "createdAt": "2020-07-24T17:23:44Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveCardinalityPreservingJoinOptimization.java", "diffHunk": "@@ -161,127 +174,118 @@ public RelNode trim(RelBuilder relBuilder, RelNode root) {\n         return root;\n       }\n \n-      // 4. Collect fields for new Project on the top of Join backs\n+      // 3. Join back tables to the top of original plan\n       Mapping newInputMapping = trimResult.right;\n-      RexNode[] newProjects = new RexNode[rootFieldList.size()];\n-      String[] newColumnNames = new String[rootFieldList.size()];\n-      projectsFromOriginalPlan(rexBuilder, newInput.getRowType().getFieldCount(), newInput, newInputMapping,\n-          newProjects, newColumnNames);\n+      Map<RexTableInputRef, Integer> tableInputRefMapping = new HashMap<>();\n \n-      // 5. Join back tables to the top of original plan\n       for (TableToJoinBack tableToJoinBack : tableToJoinBackList) {\n-        LOG.debug(\"Joining back table \" + tableToJoinBack.projectedFields.relOptHiveTable.getName());\n+        LOG.debug(\"Joining back table \" + tableToJoinBack.joinedBackFields.relOptHiveTable.getName());\n \n-        // 5.1 Create new TableScan of tables to join back\n-        RelOptHiveTable relOptTable = tableToJoinBack.projectedFields.relOptHiveTable;\n+        // 3.1. Create new TableScan of tables to join back\n+        RelOptHiveTable relOptTable = tableToJoinBack.joinedBackFields.relOptHiveTable;\n         RelOptCluster cluster = relBuilder.getCluster();\n         HiveTableScan tableScan = new HiveTableScan(cluster, cluster.traitSetOf(HiveRelNode.CONVENTION),\n             relOptTable, relOptTable.getHiveTableMD().getTableName(), null, false, false);\n-        // 5.2 Project only required fields from this table\n+        // 3.2. Create Project with the required fields from this table\n         RelNode projectTableAccessRel = tableScan.project(\n-            tableToJoinBack.projectedFields.fieldsInSourceTable, new HashSet<>(0), REL_BUILDER.get());\n+            tableToJoinBack.joinedBackFields.fieldsInSourceTable, new HashSet<>(0), REL_BUILDER.get());\n \n-        Mapping keyMapping = Mappings.create(MappingType.INVERSE_SURJECTION,\n-            tableScan.getRowType().getFieldCount(), tableToJoinBack.keys.cardinality());\n+        // 3.3. Create mapping between the Project and TableScan\n+        Mapping projectMapping = Mappings.create(MappingType.INVERSE_SURJECTION,\n+            tableScan.getRowType().getFieldCount(),\n+            tableToJoinBack.joinedBackFields.fieldsInSourceTable.cardinality());\n         int projectIndex = 0;\n+        for (int i : tableToJoinBack.joinedBackFields.fieldsInSourceTable) {\n+          projectMapping.set(i, projectIndex);\n+          ++projectIndex;\n+        }\n+\n         int offset = newInput.getRowType().getFieldCount();\n \n-        for (int source : tableToJoinBack.projectedFields.fieldsInSourceTable) {\n-          if (tableToJoinBack.keys.get(source)) {\n-            // 5.3 Map key field to it's index in the Project on the TableScan\n-            keyMapping.set(source, projectIndex);\n-          } else {\n-            // 5.4 if this is not a key field then we need it in the new Project on the top of Join backs\n-            ProjectMapping currentProjectMapping =\n-                tableToJoinBack.projectedFields.mapping.stream()\n-                    .filter(projectMapping -> projectMapping.indexInSourceTable == source)\n-                    .findFirst().get();\n-            addToProject(projectTableAccessRel, projectIndex, rexBuilder,\n-                offset + projectIndex,\n-                currentProjectMapping.indexInRootProject,\n-                newProjects, newColumnNames);\n+        // 3.4. Map rexTableInputRef to the index where it can be found in the new Input row type\n+        for (TableInputRefHolder mapping : tableToJoinBack.joinedBackFields.mapping) {\n+          int indexInSourceTable = mapping.tableInputRef.getIndex();\n+          if (!tableToJoinBack.keys.get(indexInSourceTable)) {\n+            // 3.5. if this is not a key field it is shifted by the left input field count\n+            tableInputRefMapping.put(mapping.tableInputRef, offset + projectMapping.getTarget(indexInSourceTable));\n           }\n-          ++projectIndex;\n         }\n \n-        // 5.5 Create Join\n+        // 3.7. Create Join\n         relBuilder.push(newInput);\n         relBuilder.push(projectTableAccessRel);\n \n         RexNode joinCondition = joinCondition(\n-            newInput, newInputMapping, tableToJoinBack, projectTableAccessRel, keyMapping, rexBuilder);\n+            newInput, newInputMapping, tableToJoinBack, projectTableAccessRel, projectMapping, rexBuilder);\n \n         newInput = relBuilder.join(JoinRelType.INNER, joinCondition).build();\n       }\n \n-      // 6 Create Project on top of all Join backs\n+      // 4. Collect rexNodes for Project\n+      TableInputRefMapper mapper = new TableInputRefMapper(tableInputRefMapping, rexBuilder, newInput);\n+      List<RexNode> rexNodeList = new ArrayList<>(rootInput.getRowType().getFieldCount());\n+      for (int i = 0; i < rootInput.getRowType().getFieldCount(); i++) {\n+        RexNode rexNode = rexNodesToShuttle.get(i);\n+        if (rexNode != null) {\n+          rexNodeList.add(mapper.apply(rexNode));\n+        } else {\n+          int target = newInputMapping.getTarget(i);\n+          rexNodeList.add(\n+              rexBuilder.makeInputRef(newInput.getRowType().getFieldList().get(target).getType(), target));\n+        }\n+      }\n+\n+      // 5. Create Project on top of all Join backs\n       relBuilder.push(newInput);\n-      relBuilder.project(asList(newProjects), asList(newColumnNames));\n+      relBuilder.project(rexNodeList, newColumnNames);\n \n       return root.copy(root.getTraitSet(), singletonList(relBuilder.build()));\n     } finally {\n       REL_BUILDER.remove();\n     }\n   }\n \n-  private List<ProjectedFields> getExpressionLineageOf(\n+  private List<JoinedBackFields> getExpressionLineageOf(\n       List<RexInputRef> projectExpressions, RelNode projectInput) {\n     RelMetadataQuery relMetadataQuery = RelMetadataQuery.instance();\n-    Map<RexTableInputRef.RelTableRef, ProjectedFieldsBuilder> fieldMappingBuilders = new HashMap<>();\n+    Map<RexTableInputRef.RelTableRef, JoinedBackFieldsBuilder> fieldMappingBuilders = new HashMap<>();\n     List<RexTableInputRef.RelTableRef> tablesOrdered = new ArrayList<>(); // use this list to keep the order of tables\n     for (RexInputRef expr : projectExpressions) {\n       Set<RexNode> expressionLineage = relMetadataQuery.getExpressionLineage(projectInput, expr);\n       if (expressionLineage == null || expressionLineage.size() != 1) {\n-        LOG.debug(\"Lineage can not be determined of expression: \" + expr);\n+        LOG.debug(\"Lineage of expression can not be determined: \" + expr);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxODU3MQ=="}, "originalCommit": {"oid": "c504d19d72e153235a9e5c1a74b6185fb2376b87"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTY3NTExOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveCardinalityPreservingJoinOptimization.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMTo1OTowNlrOG2hG-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNzoyMzo1MVrOG23rQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxODc0Nw==", "bodyText": "LOG.debug(\"Joining back table {}\", tableToJoinBack.joinedBackFields.relOptHiveTable.getName());", "url": "https://github.com/apache/hive/pull/1184#discussion_r459818747", "createdAt": "2020-07-24T01:59:06Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveCardinalityPreservingJoinOptimization.java", "diffHunk": "@@ -161,127 +174,118 @@ public RelNode trim(RelBuilder relBuilder, RelNode root) {\n         return root;\n       }\n \n-      // 4. Collect fields for new Project on the top of Join backs\n+      // 3. Join back tables to the top of original plan\n       Mapping newInputMapping = trimResult.right;\n-      RexNode[] newProjects = new RexNode[rootFieldList.size()];\n-      String[] newColumnNames = new String[rootFieldList.size()];\n-      projectsFromOriginalPlan(rexBuilder, newInput.getRowType().getFieldCount(), newInput, newInputMapping,\n-          newProjects, newColumnNames);\n+      Map<RexTableInputRef, Integer> tableInputRefMapping = new HashMap<>();\n \n-      // 5. Join back tables to the top of original plan\n       for (TableToJoinBack tableToJoinBack : tableToJoinBackList) {\n-        LOG.debug(\"Joining back table \" + tableToJoinBack.projectedFields.relOptHiveTable.getName());\n+        LOG.debug(\"Joining back table \" + tableToJoinBack.joinedBackFields.relOptHiveTable.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c504d19d72e153235a9e5c1a74b6185fb2376b87"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4ODQ4Mw==", "bodyText": "fixed", "url": "https://github.com/apache/hive/pull/1184#discussion_r460188483", "createdAt": "2020-07-24T17:23:51Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveCardinalityPreservingJoinOptimization.java", "diffHunk": "@@ -161,127 +174,118 @@ public RelNode trim(RelBuilder relBuilder, RelNode root) {\n         return root;\n       }\n \n-      // 4. Collect fields for new Project on the top of Join backs\n+      // 3. Join back tables to the top of original plan\n       Mapping newInputMapping = trimResult.right;\n-      RexNode[] newProjects = new RexNode[rootFieldList.size()];\n-      String[] newColumnNames = new String[rootFieldList.size()];\n-      projectsFromOriginalPlan(rexBuilder, newInput.getRowType().getFieldCount(), newInput, newInputMapping,\n-          newProjects, newColumnNames);\n+      Map<RexTableInputRef, Integer> tableInputRefMapping = new HashMap<>();\n \n-      // 5. Join back tables to the top of original plan\n       for (TableToJoinBack tableToJoinBack : tableToJoinBackList) {\n-        LOG.debug(\"Joining back table \" + tableToJoinBack.projectedFields.relOptHiveTable.getName());\n+        LOG.debug(\"Joining back table \" + tableToJoinBack.joinedBackFields.relOptHiveTable.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxODc0Nw=="}, "originalCommit": {"oid": "c504d19d72e153235a9e5c1a74b6185fb2376b87"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTY4Mjg2OnYy", "diffSide": "RIGHT", "path": "ql/src/test/results/clientpositive/perf/tez/constraints/cbo_query84.q.out", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjowMzo1NlrOG2hLHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNzoyNToxOVrOG23uCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxOTgwNw==", "bodyText": "This is not nice, it seem a side effect of using the new cost model. I am wondering why we did not hit it before? Are we changing the metadata provider correctly?", "url": "https://github.com/apache/hive/pull/1184#discussion_r459819807", "createdAt": "2020-07-24T02:03:56Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/results/clientpositive/perf/tez/constraints/cbo_query84.q.out", "diffHunk": "@@ -56,24 +56,24 @@ CBO PLAN:\n HiveProject(customer_id=[$0], customername=[$1])\n   HiveSortLimit(sort0=[$2], dir0=[ASC], fetch=[100])\n     HiveProject(customer_id=[$2], customername=[$6], c_customer_id=[$2])\n-      HiveJoin(condition=[=($8, $4)], joinType=[inner], algorithm=[none], cost=[not available])\n-        HiveJoin(condition=[=($1, $3)], joinType=[inner], algorithm=[none], cost=[not available])\n-          HiveJoin(condition=[=($0, $1)], joinType=[inner], algorithm=[none], cost=[not available])\n+      HiveJoin(condition=[=($8, $4)], joinType=[inner], algorithm=[CommonJoin], cost=[not available])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c504d19d72e153235a9e5c1a74b6185fb2376b87"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4OTE5Mw==", "bodyText": "Added logic to reset the joinAlgorithm back to none in all HiveJoin nodes after calculating the cost and switching back the MetadataProvider", "url": "https://github.com/apache/hive/pull/1184#discussion_r460189193", "createdAt": "2020-07-24T17:25:19Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/results/clientpositive/perf/tez/constraints/cbo_query84.q.out", "diffHunk": "@@ -56,24 +56,24 @@ CBO PLAN:\n HiveProject(customer_id=[$0], customername=[$1])\n   HiveSortLimit(sort0=[$2], dir0=[ASC], fetch=[100])\n     HiveProject(customer_id=[$2], customername=[$6], c_customer_id=[$2])\n-      HiveJoin(condition=[=($8, $4)], joinType=[inner], algorithm=[none], cost=[not available])\n-        HiveJoin(condition=[=($1, $3)], joinType=[inner], algorithm=[none], cost=[not available])\n-          HiveJoin(condition=[=($0, $1)], joinType=[inner], algorithm=[none], cost=[not available])\n+      HiveJoin(condition=[=($8, $4)], joinType=[inner], algorithm=[CommonJoin], cost=[not available])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxOTgwNw=="}, "originalCommit": {"oid": "c504d19d72e153235a9e5c1a74b6185fb2376b87"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 687, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}