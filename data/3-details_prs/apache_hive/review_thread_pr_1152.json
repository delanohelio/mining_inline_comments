{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3MTAxMTQ1", "number": 1152, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwMDoxNjo1OFrOEHZg1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwMDoyNzo1NVrOEHZj0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MTkzNDk1OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwMDoxNjo1OFrOGmvI4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo1OTo1MlrOGm71pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MTM5NQ==", "bodyText": "Can you check if this can already be done by any of the utility methods in OperatorUtils? If it is not, can we move it to that class with rest of utility methods in case it is useful in the future?", "url": "https://github.com/apache/hive/pull/1152#discussion_r443271395", "createdAt": "2020-06-22T00:16:58Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java", "diffHunk": "@@ -1566,13 +1569,38 @@ private void removeSemijoinsParallelToMapJoin(OptimizeTezProcContext procCtx)\n \n       List<ExprNodeDesc> keyDesc = selectedMJOp.getConf().getKeys().get(posBigTable);\n       ExprNodeColumnDesc keyCol = (ExprNodeColumnDesc) keyDesc.get(0);\n-\n-      tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n-          keyCol.getColumn(), selectedMJOpRatio);\n+      String realTSColName = getOriginalTSColName(selectedMJOp, keyCol.getColumn());\n+      if (realTSColName != null) {\n+        tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n+                realTSColName, selectedMJOpRatio);\n+      } else {\n+        LOG.warn(\"ProbeDecode could not find TSColName for ColKey {} with MJ Schema {} \", keyCol, selectedMJOp.getSchema());\n+      }\n     }\n     return tsProbeDecodeCtx;\n   }\n \n+  private static String getOriginalTSColName(MapJoinOperator mjOp, String internalCoName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd7e3a0dbad207cda42580e29e52565f4e3b537c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3OTQ2MA==", "bodyText": "Utility method is now moved to operatorUtils", "url": "https://github.com/apache/hive/pull/1152#discussion_r443479460", "createdAt": "2020-06-22T10:59:52Z", "author": {"login": "pgaref"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java", "diffHunk": "@@ -1566,13 +1569,38 @@ private void removeSemijoinsParallelToMapJoin(OptimizeTezProcContext procCtx)\n \n       List<ExprNodeDesc> keyDesc = selectedMJOp.getConf().getKeys().get(posBigTable);\n       ExprNodeColumnDesc keyCol = (ExprNodeColumnDesc) keyDesc.get(0);\n-\n-      tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n-          keyCol.getColumn(), selectedMJOpRatio);\n+      String realTSColName = getOriginalTSColName(selectedMJOp, keyCol.getColumn());\n+      if (realTSColName != null) {\n+        tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n+                realTSColName, selectedMJOpRatio);\n+      } else {\n+        LOG.warn(\"ProbeDecode could not find TSColName for ColKey {} with MJ Schema {} \", keyCol, selectedMJOp.getSchema());\n+      }\n     }\n     return tsProbeDecodeCtx;\n   }\n \n+  private static String getOriginalTSColName(MapJoinOperator mjOp, String internalCoName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MTM5NQ=="}, "originalCommit": {"oid": "bd7e3a0dbad207cda42580e29e52565f4e3b537c"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MTk0MjU5OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwMDoyNzo1NVrOGmvM8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNToyNzo1NVrOGnZyxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MjQzMw==", "bodyText": "You could throw an error only if you are running in test mode:\nif (conf.getBoolVar(ConfVars.HIVE_IN_TEST)) {\n...\n\nWhile I am not a huge fan of interleaving a check like this within the production code, it may help you identify any issues, gaps, or regressions in the future.\nIf you do not want to do that, an alternative is uploading a patch throwing an error instead of printing the warning to get a complete test run, then create follow-up issues if there are any. It will not help you with regressions in the future, but you will be able to identify any existing issue.", "url": "https://github.com/apache/hive/pull/1152#discussion_r443272433", "createdAt": "2020-06-22T00:27:55Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java", "diffHunk": "@@ -1566,13 +1569,38 @@ private void removeSemijoinsParallelToMapJoin(OptimizeTezProcContext procCtx)\n \n       List<ExprNodeDesc> keyDesc = selectedMJOp.getConf().getKeys().get(posBigTable);\n       ExprNodeColumnDesc keyCol = (ExprNodeColumnDesc) keyDesc.get(0);\n-\n-      tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n-          keyCol.getColumn(), selectedMJOpRatio);\n+      String realTSColName = getOriginalTSColName(selectedMJOp, keyCol.getColumn());\n+      if (realTSColName != null) {\n+        tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n+                realTSColName, selectedMJOpRatio);\n+      } else {\n+        LOG.warn(\"ProbeDecode could not find TSColName for ColKey {} with MJ Schema {} \", keyCol, selectedMJOp.getSchema());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd7e3a0dbad207cda42580e29e52565f4e3b537c"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4MjAzNg==", "bodyText": "Hey @jcamachor , thanks for the comments!\nThe HIVE_IN_TEST trick could work as long we enable probedecode optimisation by default right? (currently if off)\nJust enabled the optimisation for this PR (throwing an exception instead of warn) to identify any existing issues.", "url": "https://github.com/apache/hive/pull/1152#discussion_r443482036", "createdAt": "2020-06-22T11:05:15Z", "author": {"login": "pgaref"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java", "diffHunk": "@@ -1566,13 +1569,38 @@ private void removeSemijoinsParallelToMapJoin(OptimizeTezProcContext procCtx)\n \n       List<ExprNodeDesc> keyDesc = selectedMJOp.getConf().getKeys().get(posBigTable);\n       ExprNodeColumnDesc keyCol = (ExprNodeColumnDesc) keyDesc.get(0);\n-\n-      tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n-          keyCol.getColumn(), selectedMJOpRatio);\n+      String realTSColName = getOriginalTSColName(selectedMJOp, keyCol.getColumn());\n+      if (realTSColName != null) {\n+        tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n+                realTSColName, selectedMJOpRatio);\n+      } else {\n+        LOG.warn(\"ProbeDecode could not find TSColName for ColKey {} with MJ Schema {} \", keyCol, selectedMJOp.getSchema());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MjQzMw=="}, "originalCommit": {"oid": "bd7e3a0dbad207cda42580e29e52565f4e3b537c"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxNzI1MQ==", "bodyText": "Qtest results here:\nhttp://ci.hive.apache.org/blue/organizations/jenkins/hive-precommit/detail/PR-1152/4/tests/\nSeems that for for existing MJ ops the probedecode optimisation works fine (properly finds original TS col alias as well). Not sure if we want to enable probe by default however. Thoughts? cc @ashutoshc", "url": "https://github.com/apache/hive/pull/1152#discussion_r443617251", "createdAt": "2020-06-22T14:51:13Z", "author": {"login": "pgaref"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java", "diffHunk": "@@ -1566,13 +1569,38 @@ private void removeSemijoinsParallelToMapJoin(OptimizeTezProcContext procCtx)\n \n       List<ExprNodeDesc> keyDesc = selectedMJOp.getConf().getKeys().get(posBigTable);\n       ExprNodeColumnDesc keyCol = (ExprNodeColumnDesc) keyDesc.get(0);\n-\n-      tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n-          keyCol.getColumn(), selectedMJOpRatio);\n+      String realTSColName = getOriginalTSColName(selectedMJOp, keyCol.getColumn());\n+      if (realTSColName != null) {\n+        tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n+                realTSColName, selectedMJOpRatio);\n+      } else {\n+        LOG.warn(\"ProbeDecode could not find TSColName for ColKey {} with MJ Schema {} \", keyCol, selectedMJOp.getSchema());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MjQzMw=="}, "originalCommit": {"oid": "bd7e3a0dbad207cda42580e29e52565f4e3b537c"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk3MDI0Nw==", "bodyText": "Cool! I think we should enable it by default indeed.", "url": "https://github.com/apache/hive/pull/1152#discussion_r443970247", "createdAt": "2020-06-23T05:27:55Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java", "diffHunk": "@@ -1566,13 +1569,38 @@ private void removeSemijoinsParallelToMapJoin(OptimizeTezProcContext procCtx)\n \n       List<ExprNodeDesc> keyDesc = selectedMJOp.getConf().getKeys().get(posBigTable);\n       ExprNodeColumnDesc keyCol = (ExprNodeColumnDesc) keyDesc.get(0);\n-\n-      tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n-          keyCol.getColumn(), selectedMJOpRatio);\n+      String realTSColName = getOriginalTSColName(selectedMJOp, keyCol.getColumn());\n+      if (realTSColName != null) {\n+        tsProbeDecodeCtx = new TableScanOperator.ProbeDecodeContext(mjCacheKey, mjSmallTablePos,\n+                realTSColName, selectedMJOpRatio);\n+      } else {\n+        LOG.warn(\"ProbeDecode could not find TSColName for ColKey {} with MJ Schema {} \", keyCol, selectedMJOp.getSchema());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MjQzMw=="}, "originalCommit": {"oid": "bd7e3a0dbad207cda42580e29e52565f4e3b537c"}, "originalPosition": 39}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 666, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}