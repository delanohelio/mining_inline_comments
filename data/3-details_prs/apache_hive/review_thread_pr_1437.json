{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0NTkzMjk3", "number": 1437, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxOTozNToyOFrOEd3b2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNToxNDoxOVrOEe9D6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzUyNDEwOnYy", "diffSide": "RIGHT", "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxOTozNToyOFrOHJSQOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwODo1ODoxMlrOHJwZHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ5ODI5Ng==", "bodyText": "Should we set the default to 2 now that it is only triggered in very specific cases?", "url": "https://github.com/apache/hive/pull/1437#discussion_r479498296", "createdAt": "2020-08-28T19:35:28Z", "author": {"login": "jcamachor"}, "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "diffHunk": "@@ -2591,6 +2591,10 @@ private static void populateLlapDaemonVarsSet(Set<String> llapDaemonVarsSetLocal\n     HIVE_CTE_MATERIALIZE_THRESHOLD(\"hive.optimize.cte.materialize.threshold\", -1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2174573c38121047c90fe414faebe88e22cbf8c"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk5MjA5NA==", "bodyText": "done", "url": "https://github.com/apache/hive/pull/1437#discussion_r479992094", "createdAt": "2020-08-31T08:58:12Z", "author": {"login": "kasakrisz"}, "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "diffHunk": "@@ -2591,6 +2591,10 @@ private static void populateLlapDaemonVarsSet(Set<String> llapDaemonVarsSetLocal\n     HIVE_CTE_MATERIALIZE_THRESHOLD(\"hive.optimize.cte.materialize.threshold\", -1,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ5ODI5Ng=="}, "originalCommit": {"oid": "e2174573c38121047c90fe414faebe88e22cbf8c"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzU0MTAzOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/QB.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxOTo0MTo1MlrOHJSacA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwODo1OTozMFrOHJwb4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwMDkxMg==", "bodyText": "Trying to understand this step. Does this lead to parsing the same subquery multiple times?", "url": "https://github.com/apache/hive/pull/1437#discussion_r479500912", "createdAt": "2020-08-28T19:41:52Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/QB.java", "diffHunk": "@@ -457,4 +469,17 @@ public boolean hasTableDefined() {\n     return !(aliases.size() == 1 && aliases.get(0).equals(SemanticAnalyzer.DUMMY_TABLE));\n   }\n \n+  public void addSubqExprAlias(ASTNode expressionTree, SemanticAnalyzer semanticAnalyzer) throws SemanticException {\n+    String alias = \"__subexpr\" + subQueryExpressionAliasCounter++;\n+\n+    // Recursively do the first phase of semantic analysis for the subquery\n+    QBExpr qbexpr = new QBExpr(alias);\n+\n+    ASTNode subqref = (ASTNode) expressionTree.getChild(1);\n+    semanticAnalyzer.doPhase1QBExpr(subqref, qbexpr, getId(), alias, isInsideView());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2174573c38121047c90fe414faebe88e22cbf8c"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk5MjgwMg==", "bodyText": "This step parses the subquery only. It is necessary to collect references to the CTEs in subquery expressions.", "url": "https://github.com/apache/hive/pull/1437#discussion_r479992802", "createdAt": "2020-08-31T08:59:30Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/QB.java", "diffHunk": "@@ -457,4 +469,17 @@ public boolean hasTableDefined() {\n     return !(aliases.size() == 1 && aliases.get(0).equals(SemanticAnalyzer.DUMMY_TABLE));\n   }\n \n+  public void addSubqExprAlias(ASTNode expressionTree, SemanticAnalyzer semanticAnalyzer) throws SemanticException {\n+    String alias = \"__subexpr\" + subQueryExpressionAliasCounter++;\n+\n+    // Recursively do the first phase of semantic analysis for the subquery\n+    QBExpr qbexpr = new QBExpr(alias);\n+\n+    ASTNode subqref = (ASTNode) expressionTree.getChild(1);\n+    semanticAnalyzer.doPhase1QBExpr(subqref, qbexpr, getId(), alias, isInsideView());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwMDkxMg=="}, "originalCommit": {"oid": "e2174573c38121047c90fe414faebe88e22cbf8c"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzU0NDM4OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/QBParseInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxOTo0MzoxMlrOHJScgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwOTowMjoxN1rOHJwhqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwMTQ0MQ==", "bodyText": "Although the method is evident, could we add a comment?\nShould this be static since it is a utility method that can be used beyond this scope?", "url": "https://github.com/apache/hive/pull/1437#discussion_r479501441", "createdAt": "2020-08-28T19:43:12Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/QBParseInfo.java", "diffHunk": "@@ -677,6 +685,33 @@ public void setNoScanAnalyzeCommand(boolean isNoScanAnalyzeCommand) {\n   public boolean hasInsertTables() {\n     return this.insertIntoTables.size() > 0 || this.insertOverwriteTables.size() > 0;\n   }\n+\n+  public boolean isFullyAggregate() throws SemanticException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2174573c38121047c90fe414faebe88e22cbf8c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk5NDI4MA==", "bodyText": "Added javadocs. I think it can be non-static until it is used from another location. It uses the destToSelExpr field located in QBParseInfo.", "url": "https://github.com/apache/hive/pull/1437#discussion_r479994280", "createdAt": "2020-08-31T09:02:17Z", "author": {"login": "kasakrisz"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/QBParseInfo.java", "diffHunk": "@@ -677,6 +685,33 @@ public void setNoScanAnalyzeCommand(boolean isNoScanAnalyzeCommand) {\n   public boolean hasInsertTables() {\n     return this.insertIntoTables.size() > 0 || this.insertOverwriteTables.size() > 0;\n   }\n+\n+  public boolean isFullyAggregate() throws SemanticException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwMTQ0MQ=="}, "originalCommit": {"oid": "e2174573c38121047c90fe414faebe88e22cbf8c"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzU1MjA5OnYy", "diffSide": "RIGHT", "path": "ql/src/test/queries/clientpositive/cte_mat_6.q", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxOTo0NTo1OVrOHJShHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNToxMzo0M1rOHK7Yhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwMjYyMw==", "bodyText": "Could we add tests to make sure the optimization is only triggered for SELECT queries? For instance, I am thinking about CTAS and CMV statements, the optimization should not triggered in those cases (I guess it could lead some kind of side effect, at least for CMV).", "url": "https://github.com/apache/hive/pull/1437#discussion_r479502623", "createdAt": "2020-08-28T19:45:59Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/cte_mat_6.q", "diffHunk": "@@ -0,0 +1,81 @@\n+set hive.optimize.cte.materialize.threshold=1;\n+\n+create table t0(col0 int);\n+\n+insert into t0(col0) values\n+(1),(2),\n+(100),(100),(100),\n+(200),(200);\n+\n+-- CTE is referenced from scalar subquery in the select clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+-- disable cte materialization\n+set hive.optimize.cte.materialize.threshold=-1;\n+\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+\n+-- enable cte materialization\n+set hive.optimize.cte.materialize.threshold=1;\n+\n+-- CTE is referenced from scalar subquery in the where clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0\n+from t0\n+where t0.col0 > (select small_count from cte)\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0\n+from t0\n+where t0.col0 > (select small_count from cte)\n+order by t0.col0;\n+\n+-- CTE is referenced from scalar subquery in the having clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, count(*)\n+from t0\n+group by col0\n+having count(*) > (select small_count from cte)\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, count(*)\n+from t0\n+group by col0\n+having count(*) > (select small_count from cte)\n+order by t0.col0;\n+\n+-- mix full aggregate and non-full aggregate ctes\n+explain\n+with cte1 as (select col0 as k1 from t0 where col0 = '5'),\n+     cte2 as (select count(*) as all_count from t0),\n+     cte3 as (select col0 as k3, col0 + col0 as k3_2x, count(*) as key_count from t0 group by col0)\n+select t0.col0, count(*)\n+from t0\n+join cte1 on t0.col0 = cte1.k1\n+join cte3 on t0.col0 = cte3.k3\n+group by col0\n+having count(*) > (select all_count from cte2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2174573c38121047c90fe414faebe88e22cbf8c"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk3MDU3MA==", "bodyText": "I added a check for CTAS.\nFor create materialize view CTE materialization is disabled here\nSemanticAnalyzer.genResolvedParseTree\n    // 5. Resolve Parse Tree\n    // Materialization is allowed if it is not a view definition\n    getMetaData(qb, createVwDesc == null && !forViewCreation);\n\n\n  \n    \n      hive/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java\n    \n    \n         Line 12355\n      in\n      54aff33\n    \n    \n    \n    \n\n        \n          \n           getMetaData(qb, createVwDesc == null && !forViewCreation);", "url": "https://github.com/apache/hive/pull/1437#discussion_r479970570", "createdAt": "2020-08-31T08:16:19Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/queries/clientpositive/cte_mat_6.q", "diffHunk": "@@ -0,0 +1,81 @@\n+set hive.optimize.cte.materialize.threshold=1;\n+\n+create table t0(col0 int);\n+\n+insert into t0(col0) values\n+(1),(2),\n+(100),(100),(100),\n+(200),(200);\n+\n+-- CTE is referenced from scalar subquery in the select clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+-- disable cte materialization\n+set hive.optimize.cte.materialize.threshold=-1;\n+\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+\n+-- enable cte materialization\n+set hive.optimize.cte.materialize.threshold=1;\n+\n+-- CTE is referenced from scalar subquery in the where clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0\n+from t0\n+where t0.col0 > (select small_count from cte)\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0\n+from t0\n+where t0.col0 > (select small_count from cte)\n+order by t0.col0;\n+\n+-- CTE is referenced from scalar subquery in the having clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, count(*)\n+from t0\n+group by col0\n+having count(*) > (select small_count from cte)\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, count(*)\n+from t0\n+group by col0\n+having count(*) > (select small_count from cte)\n+order by t0.col0;\n+\n+-- mix full aggregate and non-full aggregate ctes\n+explain\n+with cte1 as (select col0 as k1 from t0 where col0 = '5'),\n+     cte2 as (select count(*) as all_count from t0),\n+     cte3 as (select col0 as k3, col0 + col0 as k3_2x, count(*) as key_count from t0 group by col0)\n+select t0.col0, count(*)\n+from t0\n+join cte1 on t0.col0 = cte1.k1\n+join cte3 on t0.col0 = cte3.k3\n+group by col0\n+having count(*) > (select all_count from cte2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwMjYyMw=="}, "originalCommit": {"oid": "e2174573c38121047c90fe414faebe88e22cbf8c"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA3ODk1Nw==", "bodyText": "@jcamachor\nI just found that CTE materialization was enabled for CTAS in the past or at least it was tested. Please see\nhttps://github.com/apache/hive/blob/master/ql/src/test/queries/clientpositive/cte_4.q\nShould we disable it anyway?", "url": "https://github.com/apache/hive/pull/1437#discussion_r480078957", "createdAt": "2020-08-31T11:52:24Z", "author": {"login": "kasakrisz"}, "path": "ql/src/test/queries/clientpositive/cte_mat_6.q", "diffHunk": "@@ -0,0 +1,81 @@\n+set hive.optimize.cte.materialize.threshold=1;\n+\n+create table t0(col0 int);\n+\n+insert into t0(col0) values\n+(1),(2),\n+(100),(100),(100),\n+(200),(200);\n+\n+-- CTE is referenced from scalar subquery in the select clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+-- disable cte materialization\n+set hive.optimize.cte.materialize.threshold=-1;\n+\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+\n+-- enable cte materialization\n+set hive.optimize.cte.materialize.threshold=1;\n+\n+-- CTE is referenced from scalar subquery in the where clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0\n+from t0\n+where t0.col0 > (select small_count from cte)\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0\n+from t0\n+where t0.col0 > (select small_count from cte)\n+order by t0.col0;\n+\n+-- CTE is referenced from scalar subquery in the having clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, count(*)\n+from t0\n+group by col0\n+having count(*) > (select small_count from cte)\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, count(*)\n+from t0\n+group by col0\n+having count(*) > (select small_count from cte)\n+order by t0.col0;\n+\n+-- mix full aggregate and non-full aggregate ctes\n+explain\n+with cte1 as (select col0 as k1 from t0 where col0 = '5'),\n+     cte2 as (select count(*) as all_count from t0),\n+     cte3 as (select col0 as k3, col0 + col0 as k3_2x, count(*) as key_count from t0 group by col0)\n+select t0.col0, count(*)\n+from t0\n+join cte1 on t0.col0 = cte1.k1\n+join cte3 on t0.col0 = cte3.k3\n+group by col0\n+having count(*) > (select all_count from cte2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwMjYyMw=="}, "originalCommit": {"oid": "e2174573c38121047c90fe414faebe88e22cbf8c"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIyMDc0Mg==", "bodyText": "OK, I think it is fine to leave it then.", "url": "https://github.com/apache/hive/pull/1437#discussion_r481220742", "createdAt": "2020-09-01T15:13:43Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/cte_mat_6.q", "diffHunk": "@@ -0,0 +1,81 @@\n+set hive.optimize.cte.materialize.threshold=1;\n+\n+create table t0(col0 int);\n+\n+insert into t0(col0) values\n+(1),(2),\n+(100),(100),(100),\n+(200),(200);\n+\n+-- CTE is referenced from scalar subquery in the select clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+-- disable cte materialization\n+set hive.optimize.cte.materialize.threshold=-1;\n+\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, (select small_count from cte)\n+from t0\n+order by t0.col0;\n+\n+\n+-- enable cte materialization\n+set hive.optimize.cte.materialize.threshold=1;\n+\n+-- CTE is referenced from scalar subquery in the where clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0\n+from t0\n+where t0.col0 > (select small_count from cte)\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0\n+from t0\n+where t0.col0 > (select small_count from cte)\n+order by t0.col0;\n+\n+-- CTE is referenced from scalar subquery in the having clause\n+explain\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, count(*)\n+from t0\n+group by col0\n+having count(*) > (select small_count from cte)\n+order by t0.col0;\n+\n+with cte as (select count(*) as small_count from t0 where col0 < 10)\n+select t0.col0, count(*)\n+from t0\n+group by col0\n+having count(*) > (select small_count from cte)\n+order by t0.col0;\n+\n+-- mix full aggregate and non-full aggregate ctes\n+explain\n+with cte1 as (select col0 as k1 from t0 where col0 = '5'),\n+     cte2 as (select count(*) as all_count from t0),\n+     cte3 as (select col0 as k3, col0 + col0 as k3_2x, count(*) as key_count from t0 group by col0)\n+select t0.col0, count(*)\n+from t0\n+join cte1 on t0.col0 = cte1.k1\n+join cte3 on t0.col0 = cte3.k3\n+group by col0\n+having count(*) > (select all_count from cte2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwMjYyMw=="}, "originalCommit": {"oid": "e2174573c38121047c90fe414faebe88e22cbf8c"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODkzMTYyOnYy", "diffSide": "LEFT", "path": "ql/src/test/results/clientpositive/llap/cte_4.q.out", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNToxNDoxOVrOHK7aWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNToxNDoxOVrOHK7aWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIyMTIxMA==", "bodyText": "Expected?", "url": "https://github.com/apache/hive/pull/1437#discussion_r481221210", "createdAt": "2020-09-01T15:14:19Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/results/clientpositive/llap/cte_4.q.out", "diffHunk": "@@ -106,23 +106,17 @@ PREHOOK: query: create table s2 as\n with q1 as ( select key from src where key = '4')\n select * from q1\n PREHOOK: type: CREATETABLE_AS_SELECT\n-PREHOOK: Input: default@q1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bf9fc5932a142b251fac4e17c9cb70090ca6f6"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 390, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}