{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NDI5MTI0", "number": 1238, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMDoyNzozMlrOENwgZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMDozMzo0OVrOENwpEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODYxNjY5OnYy", "diffSide": "RIGHT", "path": "llap-client/src/java/org/apache/hadoop/hive/llap/io/api/LlapIo.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMDoyNzozM1rOGwin9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMDoyNzozM1rOGwin9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MjExOA==", "bodyText": "Missing javadoc for cachetag", "url": "https://github.com/apache/hive/pull/1238#discussion_r453552118", "createdAt": "2020-07-13T10:27:33Z", "author": {"login": "pvary"}, "path": "llap-client/src/java/org/apache/hadoop/hive/llap/io/api/LlapIo.java", "diffHunk": "@@ -35,6 +41,15 @@\n    */\n   long purge();\n \n+  /**\n+   * Returns a deserialized OrcTail instance associated with the ORC file on the given path.\n+   *  Raw content is either obtained from cache, or from disk if there is a cache miss.\n+   * @param path Orc file path\n+   * @param conf jobConf", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c156a2d684a744727f4cade0f73ab999e34073e"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODYzODkwOnYy", "diffSide": "RIGHT", "path": "llap-server/src/java/org/apache/hadoop/hive/llap/io/encoded/OrcEncodedDataReader.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMDozMzo0OVrOGwi1Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTozOTowNFrOGwk2GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1NTQ2Mw==", "bodyText": "What happens if the tail is evicted from the cache in the meantime (after the check, but before this line). Or it is locked during this code?", "url": "https://github.com/apache/hive/pull/1238#discussion_r453555463", "createdAt": "2020-07-13T10:33:49Z", "author": {"login": "pvary"}, "path": "llap-server/src/java/org/apache/hadoop/hive/llap/io/encoded/OrcEncodedDataReader.java", "diffHunk": "@@ -575,31 +626,8 @@ private OrcFileMetadata getFileFooterFromCacheOrDisk() throws IOException {\n       tailBuffers = metadataCache.getFileMetadata(fileKey);\n       if (tailBuffers != null) {\n         try {\n-          MemoryBuffer tailBuffer = tailBuffers.getSingleBuffer();\n-          ByteBuffer bb = null;\n-          if (tailBuffer != null) {\n-            bb = tailBuffer.getByteBufferDup();\n-            // TODO: remove the copy after ORC-158 and ORC-197\n-            // if (bb.isDirect()) {\n-              ByteBuffer dupBb = tailBuffer.getByteBufferDup(); // Don't mess with the cached object.\n-              bb = ByteBuffer.allocate(dupBb.remaining());\n-              bb.put(dupBb);\n-              bb.flip();\n-            // }\n-          } else {\n-            // TODO: add the ability to extractFileTail to read from multiple buffers?\n-            MemoryBuffer[] tailBufferArray = tailBuffers.getMultipleBuffers();\n-            int totalSize = 0;\n-            for (MemoryBuffer buf : tailBufferArray) {\n-              totalSize += buf.getByteBufferRaw().remaining();\n-            }\n-            bb = ByteBuffer.allocate(totalSize);\n-            for (MemoryBuffer buf : tailBufferArray) {\n-              bb.put(buf.getByteBufferDup());\n-            }\n-            bb.flip();\n-          }\n-          OrcTail orcTail = ReaderImpl.extractFileTail(bb);\n+          OrcTail orcTail = getOrcTailFromLlapBuffers(tailBuffers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c156a2d684a744727f4cade0f73ab999e34073e"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1NjA1NQ==", "bodyText": "Oh, I see now... it is decRefBuffer...", "url": "https://github.com/apache/hive/pull/1238#discussion_r453556055", "createdAt": "2020-07-13T10:34:47Z", "author": {"login": "pvary"}, "path": "llap-server/src/java/org/apache/hadoop/hive/llap/io/encoded/OrcEncodedDataReader.java", "diffHunk": "@@ -575,31 +626,8 @@ private OrcFileMetadata getFileFooterFromCacheOrDisk() throws IOException {\n       tailBuffers = metadataCache.getFileMetadata(fileKey);\n       if (tailBuffers != null) {\n         try {\n-          MemoryBuffer tailBuffer = tailBuffers.getSingleBuffer();\n-          ByteBuffer bb = null;\n-          if (tailBuffer != null) {\n-            bb = tailBuffer.getByteBufferDup();\n-            // TODO: remove the copy after ORC-158 and ORC-197\n-            // if (bb.isDirect()) {\n-              ByteBuffer dupBb = tailBuffer.getByteBufferDup(); // Don't mess with the cached object.\n-              bb = ByteBuffer.allocate(dupBb.remaining());\n-              bb.put(dupBb);\n-              bb.flip();\n-            // }\n-          } else {\n-            // TODO: add the ability to extractFileTail to read from multiple buffers?\n-            MemoryBuffer[] tailBufferArray = tailBuffers.getMultipleBuffers();\n-            int totalSize = 0;\n-            for (MemoryBuffer buf : tailBufferArray) {\n-              totalSize += buf.getByteBufferRaw().remaining();\n-            }\n-            bb = ByteBuffer.allocate(totalSize);\n-            for (MemoryBuffer buf : tailBufferArray) {\n-              bb.put(buf.getByteBufferDup());\n-            }\n-            bb.flip();\n-          }\n-          OrcTail orcTail = ReaderImpl.extractFileTail(bb);\n+          OrcTail orcTail = getOrcTailFromLlapBuffers(tailBuffers);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1NTQ2Mw=="}, "originalCommit": {"oid": "5c156a2d684a744727f4cade0f73ab999e34073e"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODUwNQ==", "bodyText": "Yes, it won't be evicted as it is locked. The getFileMetadata invocation will incRef it (if it is found of course)", "url": "https://github.com/apache/hive/pull/1238#discussion_r453588505", "createdAt": "2020-07-13T11:39:04Z", "author": {"login": "szlta"}, "path": "llap-server/src/java/org/apache/hadoop/hive/llap/io/encoded/OrcEncodedDataReader.java", "diffHunk": "@@ -575,31 +626,8 @@ private OrcFileMetadata getFileFooterFromCacheOrDisk() throws IOException {\n       tailBuffers = metadataCache.getFileMetadata(fileKey);\n       if (tailBuffers != null) {\n         try {\n-          MemoryBuffer tailBuffer = tailBuffers.getSingleBuffer();\n-          ByteBuffer bb = null;\n-          if (tailBuffer != null) {\n-            bb = tailBuffer.getByteBufferDup();\n-            // TODO: remove the copy after ORC-158 and ORC-197\n-            // if (bb.isDirect()) {\n-              ByteBuffer dupBb = tailBuffer.getByteBufferDup(); // Don't mess with the cached object.\n-              bb = ByteBuffer.allocate(dupBb.remaining());\n-              bb.put(dupBb);\n-              bb.flip();\n-            // }\n-          } else {\n-            // TODO: add the ability to extractFileTail to read from multiple buffers?\n-            MemoryBuffer[] tailBufferArray = tailBuffers.getMultipleBuffers();\n-            int totalSize = 0;\n-            for (MemoryBuffer buf : tailBufferArray) {\n-              totalSize += buf.getByteBufferRaw().remaining();\n-            }\n-            bb = ByteBuffer.allocate(totalSize);\n-            for (MemoryBuffer buf : tailBufferArray) {\n-              bb.put(buf.getByteBufferDup());\n-            }\n-            bb.flip();\n-          }\n-          OrcTail orcTail = ReaderImpl.extractFileTail(bb);\n+          OrcTail orcTail = getOrcTailFromLlapBuffers(tailBuffers);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1NTQ2Mw=="}, "originalCommit": {"oid": "5c156a2d684a744727f4cade0f73ab999e34073e"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 562, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}