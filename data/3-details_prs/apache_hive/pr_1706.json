{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NDA3MjI0", "number": 1706, "title": "HIVE-24274: Implement Query Text based MaterializedView rewrite", "bodyText": "What changes were proposed in this pull request?\n\nAdd feature: Enable materialized view rewrite of a query if the query text is the same as the query defined in the materialized view.\nEnable unparsing for all queries in order to generate the expanded query text for comparison.\nRefactor and extend the HiveMaterializedViewsRegistry with the lookup by query text functionality.\n\nWhy are the changes needed?\nThis patch provides an alternative way to rewrite queries using materialized views. Materialized view query definitions has some limitations like can't have UNION, SORT BY operator. These are enabled when using the text based rewrite.\nDoes this PR introduce any user-facing change?\nIn some cases when rewrite was not possible because of the limitations mentioned above. With this patch the rewriting will be executed and it will have an effect of the output of EXPLAIN, EXPLAIN CBO commands: instead of the original query plan a scan on the materialized view will appear.\nHow was this patch tested?\nmvn test -DskipSparkTests -Dtest=TestMiniLlapLocalCliDriver -Dqfile=materialized_view_rewrite_by_text.q,masking_14.q,masking_mv.q,schq_materialized.q,sketches_materialized_view_safety.q -pl itests/qtest -Pitests\nmvn test -Dtest=TestMaterializedViewsCache -pl ql", "createdAt": "2020-11-25T12:22:26Z", "url": "https://github.com/apache/hive/pull/1706", "merged": true, "mergeCommit": {"oid": "9c6f8b76123c88b0c8a98645874722ba80b3c2b0"}, "closed": true, "closedAt": "2020-12-15T05:34:13Z", "author": {"login": "kasakrisz"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdhiP9-gBqjQwNTEwMzMzMjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmRPIKAFqTU1MjA2NTg2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f309e00897cc618d5f0f464d19c622be52cb4f1b", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/f309e00897cc618d5f0f464d19c622be52cb4f1b", "committedDate": "2020-11-25T12:07:16Z", "message": "HIVE-24274: Implement Query Text based MaterializedView rewrite"}, "afterCommit": {"oid": "88c0fd6a967a84278c13ac5e0c915d9ada238688", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/88c0fd6a967a84278c13ac5e0c915d9ada238688", "committedDate": "2020-11-30T09:50:22Z", "message": "HIVE-24274: Implement Query Text based MaterializedView rewrite"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "88c0fd6a967a84278c13ac5e0c915d9ada238688", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/88c0fd6a967a84278c13ac5e0c915d9ada238688", "committedDate": "2020-11-30T09:50:22Z", "message": "HIVE-24274: Implement Query Text based MaterializedView rewrite"}, "afterCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/f2bd4979366380a4f7fd799a8933860eb0426ccc", "committedDate": "2020-12-08T07:14:16Z", "message": "HIVE-24274: Implement Query Text based MaterializedView rewrite"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4Njk1NzM2", "url": "https://github.com/apache/hive/pull/1706#pullrequestreview-548695736", "createdAt": "2020-12-09T23:20:54Z", "commit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMzoyMDo1NFrOICuAtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxNDo1OVrOICw4Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMTkxMA==", "bodyText": "Let's make it shorter: hive.materializedview.rewriting.query.text -> hive.materializedview.rewriting.text or hive.materializedview.rewriting.sql ?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539721910", "createdAt": "2020-12-09T23:20:54Z", "author": {"login": "jcamachor"}, "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "diffHunk": "@@ -1844,6 +1844,9 @@ private static void populateLlapDaemonVarsSet(Set<String> llapDaemonVarsSetLocal\n     // materialized views\n     HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING(\"hive.materializedview.rewriting\", true,\n         \"Whether to try to rewrite queries using the materialized views enabled for rewriting\"),\n+    HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING_QUERY_TEXT(\"hive.materializedview.rewriting.query.text\", true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyOTc2OQ==", "bodyText": "Can we add a comment why we are only enabling this when this config value is true? enableUnparse documentation has a description on why it is not enabled in general. However, it is worth having a comment here, since it is difficult to establish the connection between the config property and the variable.", "url": "https://github.com/apache/hive/pull/1706#discussion_r539729769", "createdAt": "2020-12-09T23:38:21Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/Context.java", "diffHunk": "@@ -336,6 +344,9 @@ private Context(Configuration conf, String executionId)  {\n     opContext = new CompilationOpContext();\n \n     viewsTokenRewriteStreams = new HashMap<>();\n+    enableUnparse =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMDMwOQ==", "bodyText": "Can we add a comment (I know that the code was not added in this patch but it is useful to have some clarification on why this is being done)?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539730309", "createdAt": "2020-12-09T23:39:39Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/view/materialized/alter/rebuild/AlterMaterializedViewRebuildAnalyzer.java", "diffHunk": "@@ -57,7 +57,7 @@ public void analyzeInternal(ASTNode root) throws SemanticException {\n \n     ASTNode tableTree = (ASTNode) root.getChild(0);\n     TableName tableName = getQualifiedTableName(tableTree);\n-    if (ctx.enableUnparse()) {\n+    if (ctx.isScheduledQuery()) {\n       unparseTranslator.addTableNameTranslation(tableTree, SessionState.get().getCurrentDatabase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMTg2MQ==", "bodyText": "add javadoc?\nAlso, should this method be renamed to getSQLMatchingMaterializedView or anything more descriptive?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539731861", "createdAt": "2020-12-09T23:42:44Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java", "diffHunk": "@@ -1945,6 +1945,18 @@ public RelOptMaterialization getMaterializedViewForRebuild(String dbName, String\n     }\n   }\n \n+  public List<RelOptMaterialization> getMaterialization(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNDUzNw==", "bodyText": "filterAugmentMaterializedViews contains logic that is relevant to incremental computation of MVs, as well as other logic that works specifically for certain plan patterns. For instance, I am not sure we should be calling deriveGroupingSetsMaterializedViews for textual queries, e.g., whether it could lead to incorrect results.\nInstead, should we call getValidMaterializedViews(materializedViews, tablesUsed, false, false, txnMgr)? The caveat is that you will also need to create a method\n  private List<RelOptMaterialization> getValidMaterializedViews(List<Table> materializedViewTables,\n      List<String> tablesUsed, boolean forceMVContentsUpToDate, *boolean tryIncrementalRewriting*,\n      boolean expandGroupingSets, HiveTxnManager txnMgr) throws HiveException {\n\nFor the former calls, you can pass the value of the property HiveConf.getBoolVar(conf, HiveConf.ConfVars.HIVE_MATERIALIZED_VIEW_REWRITING_INCREMENTAL) for tryIncrementalRewriting. For the new call from this method, you should pass false. This will effectively lead to ignoring the MVs if they are outdated.", "url": "https://github.com/apache/hive/pull/1706#discussion_r539734537", "createdAt": "2020-12-09T23:47:41Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java", "diffHunk": "@@ -1945,6 +1945,18 @@ public RelOptMaterialization getMaterializedViewForRebuild(String dbName, String\n     }\n   }\n \n+  public List<RelOptMaterialization> getMaterialization(\n+          String queryString, List<String> tablesUsed, HiveTxnManager txnMgr) throws HiveException {\n+\n+    List<RelOptMaterialization> materializedViews =\n+            HiveMaterializedViewsRegistry.get().getRewritingMaterializedViews(queryString);\n+    if (materializedViews.isEmpty()) {\n+      return Collections.emptyList();\n+    }\n+\n+    return filterAugmentMaterializedViews(materializedViews, tablesUsed, txnMgr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MjI2NQ==", "bodyText": "We should not call toLowerCase. For instance, it would transform literal values that should be different and then consider them equal, e.g., col1='AaAa' vs col1='Aaaa'.\nIn addition to applying the change, can you add a test for this case to see that rewriting is triggered vs not-triggered?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539752265", "createdAt": "2020-12-10T00:31:20Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/MaterializedViewsCache.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.metadata;\n+\n+import org.apache.calcite.plan.RelOptMaterialization;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiFunction;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Collection for storing {@link RelOptMaterialization}s.\n+ * RelOptMaterialization can be lookup by\n+ * - the Materialized View fully qualified name\n+ * - query text.\n+ * This implementation contains two {@link ConcurrentHashMap} one for name based and one for query text based lookup.\n+ * The map contents are synchronized during each dml operation: Dml operations are performed initially on the map\n+ * which provides name based lookup. The map which provides query text based lookup is updated by lambda expressions\n+ * passed to {@link ConcurrentHashMap#compute(Object, BiFunction)}.\n+ */\n+public class MaterializedViewsCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(MaterializedViewsCache.class);\n+\n+  // Key is the database name. Value a map from the qualified name to the view object.\n+  private final ConcurrentMap<String, ConcurrentMap<String, RelOptMaterialization>> materializedViews =\n+          new ConcurrentHashMap<>();\n+  // Map for looking up materialization by view query text\n+  private final Map<String, List<RelOptMaterialization>> sqlToMaterializedView = new ConcurrentHashMap<>();\n+\n+\n+  public void putIfAbsent(Table materializedViewTable, RelOptMaterialization materialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    // You store the materialized view\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, relOptMaterialization) -> {\n+      List<RelOptMaterialization> materializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+      materializationList.add(materialization);\n+      return materialization;\n+    });\n+\n+    LOG.debug(\"Materialized view {}.{} added to registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  private ConcurrentMap<String, RelOptMaterialization> ensureDbMap(Table materializedViewTable) {\n+    // We are going to create the map for each view in the given database\n+    ConcurrentMap<String, RelOptMaterialization> dbMap =\n+            new ConcurrentHashMap<String, RelOptMaterialization>();\n+    // If we are caching the MV, we include it in the cache\n+    final ConcurrentMap<String, RelOptMaterialization> prevDbMap = materializedViews.putIfAbsent(\n+            materializedViewTable.getDbName(), dbMap);\n+    if (prevDbMap != null) {\n+      dbMap = prevDbMap;\n+    }\n+    return dbMap;\n+  }\n+\n+  public void refresh(\n+          Table oldMaterializedViewTable, Table materializedViewTable, RelOptMaterialization newMaterialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, existingMaterialization) -> {\n+      List<RelOptMaterialization> optMaterializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+\n+      if (existingMaterialization == null) {\n+        // If it was not existing, we just create it\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      Table existingMaterializedViewTable = HiveMaterializedViewUtils.extractTable(existingMaterialization);\n+      if (existingMaterializedViewTable.equals(oldMaterializedViewTable)) {\n+        // If the old version is the same, we replace it\n+        optMaterializationList.remove(existingMaterialization);\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      // Otherwise, we return existing materialization\n+      return existingMaterialization;\n+    });\n+\n+    LOG.debug(\"Refreshed materialized view {}.{} -> {}.{}\",\n+            oldMaterializedViewTable.getDbName(), oldMaterializedViewTable.getTableName(),\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(Table materializedViewTable) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(materializedViewTable.getDbName());\n+    if (dbMap != null) {\n+      // Delete only if the create time for the input materialized view table and the table\n+      // in the map match. Otherwise, keep the one in the map.\n+      dbMap.computeIfPresent(materializedViewTable.getTableName(), (mvTableName, oldMaterialization) -> {\n+        if (HiveMaterializedViewUtils.extractTable(oldMaterialization).equals(materializedViewTable)) {\n+          List<RelOptMaterialization> materializationList =\n+                  sqlToMaterializedView.get(materializedViewTable.getViewExpandedText().toLowerCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MzEwOQ==", "bodyText": "This will print the full query which will be very verbose. Maybe move printing the query text to TRACE level and simply print No materialized view with similar query text found in registry in DEBUG mode.", "url": "https://github.com/apache/hive/pull/1706#discussion_r539753109", "createdAt": "2020-12-10T00:33:27Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/MaterializedViewsCache.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.metadata;\n+\n+import org.apache.calcite.plan.RelOptMaterialization;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiFunction;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Collection for storing {@link RelOptMaterialization}s.\n+ * RelOptMaterialization can be lookup by\n+ * - the Materialized View fully qualified name\n+ * - query text.\n+ * This implementation contains two {@link ConcurrentHashMap} one for name based and one for query text based lookup.\n+ * The map contents are synchronized during each dml operation: Dml operations are performed initially on the map\n+ * which provides name based lookup. The map which provides query text based lookup is updated by lambda expressions\n+ * passed to {@link ConcurrentHashMap#compute(Object, BiFunction)}.\n+ */\n+public class MaterializedViewsCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(MaterializedViewsCache.class);\n+\n+  // Key is the database name. Value a map from the qualified name to the view object.\n+  private final ConcurrentMap<String, ConcurrentMap<String, RelOptMaterialization>> materializedViews =\n+          new ConcurrentHashMap<>();\n+  // Map for looking up materialization by view query text\n+  private final Map<String, List<RelOptMaterialization>> sqlToMaterializedView = new ConcurrentHashMap<>();\n+\n+\n+  public void putIfAbsent(Table materializedViewTable, RelOptMaterialization materialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    // You store the materialized view\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, relOptMaterialization) -> {\n+      List<RelOptMaterialization> materializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+      materializationList.add(materialization);\n+      return materialization;\n+    });\n+\n+    LOG.debug(\"Materialized view {}.{} added to registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  private ConcurrentMap<String, RelOptMaterialization> ensureDbMap(Table materializedViewTable) {\n+    // We are going to create the map for each view in the given database\n+    ConcurrentMap<String, RelOptMaterialization> dbMap =\n+            new ConcurrentHashMap<String, RelOptMaterialization>();\n+    // If we are caching the MV, we include it in the cache\n+    final ConcurrentMap<String, RelOptMaterialization> prevDbMap = materializedViews.putIfAbsent(\n+            materializedViewTable.getDbName(), dbMap);\n+    if (prevDbMap != null) {\n+      dbMap = prevDbMap;\n+    }\n+    return dbMap;\n+  }\n+\n+  public void refresh(\n+          Table oldMaterializedViewTable, Table materializedViewTable, RelOptMaterialization newMaterialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, existingMaterialization) -> {\n+      List<RelOptMaterialization> optMaterializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+\n+      if (existingMaterialization == null) {\n+        // If it was not existing, we just create it\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      Table existingMaterializedViewTable = HiveMaterializedViewUtils.extractTable(existingMaterialization);\n+      if (existingMaterializedViewTable.equals(oldMaterializedViewTable)) {\n+        // If the old version is the same, we replace it\n+        optMaterializationList.remove(existingMaterialization);\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      // Otherwise, we return existing materialization\n+      return existingMaterialization;\n+    });\n+\n+    LOG.debug(\"Refreshed materialized view {}.{} -> {}.{}\",\n+            oldMaterializedViewTable.getDbName(), oldMaterializedViewTable.getTableName(),\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(Table materializedViewTable) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(materializedViewTable.getDbName());\n+    if (dbMap != null) {\n+      // Delete only if the create time for the input materialized view table and the table\n+      // in the map match. Otherwise, keep the one in the map.\n+      dbMap.computeIfPresent(materializedViewTable.getTableName(), (mvTableName, oldMaterialization) -> {\n+        if (HiveMaterializedViewUtils.extractTable(oldMaterialization).equals(materializedViewTable)) {\n+          List<RelOptMaterialization> materializationList =\n+                  sqlToMaterializedView.get(materializedViewTable.getViewExpandedText().toLowerCase());\n+          materializationList.remove(oldMaterialization);\n+          return null;\n+        }\n+        return oldMaterialization;\n+      });\n+    }\n+\n+    LOG.debug(\"Materialized view {}.{} removed from registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(String dbName, String tableName) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(dbName);\n+    if (dbMap != null) {\n+      dbMap.computeIfPresent(tableName, (mvTableName, relOptMaterialization) -> {\n+        String queryText = HiveMaterializedViewUtils.extractTable(relOptMaterialization).getViewExpandedText();\n+        List<RelOptMaterialization> materializationList = sqlToMaterializedView.get(queryText.toLowerCase());\n+        materializationList.remove(relOptMaterialization);\n+        return null;\n+      });\n+\n+      LOG.debug(\"Materialized view {}.{} removed from registry\", dbName, tableName);\n+    }\n+  }\n+\n+  public List<RelOptMaterialization> values() {\n+    List<RelOptMaterialization> result = new ArrayList<>();\n+    materializedViews.forEach((dbName, mvs) -> result.addAll(mvs.values()));\n+    return unmodifiableList(result);\n+  }\n+\n+  RelOptMaterialization get(String dbName, String viewName) {\n+    if (materializedViews.get(dbName) != null) {\n+      LOG.debug(\"Found materialized view {}.{} in registry\", dbName, viewName);\n+      return materializedViews.get(dbName).get(viewName);\n+    }\n+    LOG.debug(\"Materialized view {}.{} not found in registry\", dbName, viewName);\n+    return null;\n+  }\n+\n+  public List<RelOptMaterialization> get(String queryText) {\n+    List<RelOptMaterialization> relOptMaterializationList = sqlToMaterializedView.get(queryText.toLowerCase());\n+    if (relOptMaterializationList == null) {\n+      LOG.debug(\"No materialized view with query text '{}' found in registry\", queryText);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1NzUxMw==", "bodyText": "could this be private?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539757513", "createdAt": "2020-12-10T00:44:26Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -345,9 +345,19 @@\n \n import javax.sql.DataSource;\n \n+import static java.util.Collections.singletonList;\n+import static org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils.extractTable;\n+\n \n public class CalcitePlanner extends SemanticAnalyzer {\n \n+  /**\n+   * {@link org.antlr.runtime.TokenRewriteStream} offers the opportunity of multiple rewrites of the same\n+   * input text (in our case the sql query text). These rewrites are called programs and identified by a string.\n+   * EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM is for identifying the program which replaces all identifiers in the\n+   * query with fully qualified identifiers.\n+   */\n+  public static final String EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM = \"EXPANDED_QUERY_PROGRAM\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1OTI5MA==", "bodyText": "Can we move this to HiveMaterializedViewsUtils.java? I think there is a single other place where we call _ copyNodeNewCluster_ and it's to create a new materialization too. Maybe you can make _ copyNodeNewCluster_ private, make _ copyMaterializationToNewCluster_ in HiveMaterializedViewsUtils.java, and only call the latter.", "url": "https://github.com/apache/hive/pull/1706#discussion_r539759290", "createdAt": "2020-12-10T00:49:00Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -2349,6 +2362,50 @@ private RelNode applyMaterializedViewRewriting(RelOptPlanner planner, RelNode ba\n       return basePlan;\n     }\n \n+    private RelOptMaterialization copyMaterializationToNewCluster(RelOptCluster optCluster, RelOptMaterialization materialization) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2MjYzMQ==", "bodyText": "Why do we disable it here?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539762631", "createdAt": "2020-12-10T00:57:49Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite.q", "diffHunk": "@@ -5,6 +5,7 @@ set hive.support.concurrency=true;\n set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2MzI3OQ==", "bodyText": "Is this the new test that you had added to verify that the casting is matching correctly now?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539763279", "createdAt": "2020-12-10T00:59:35Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/results/clientpositive/llap/materialized_view_rewrite_window.q.out", "diffHunk": "@@ -1047,6 +1047,7 @@ PREHOOK: query: select\n   program\n from tv_view_data\n PREHOOK: type: QUERY\n+PREHOOK: Input: arc_view@mv_tv_view_data_av2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NDMxOA==", "bodyText": "Can you add a few masking tests that match / do not match based on exact SQL text?\nThere are positive and negative tests for current rewriting (masking_mv in both cases):\n873d31f#diff-3ae6a10ec619425775eeff0c135ace87cfe2c8dfbaea22f99278d7cd5d9bc330", "url": "https://github.com/apache/hive/pull/1706#discussion_r539764318", "createdAt": "2020-12-10T01:02:23Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java", "diffHunk": "@@ -12565,15 +12566,17 @@ void analyzeInternal(ASTNode ast, Supplier<PlannerContext> pcf) throws SemanticE\n     sinkOp = genOPTree(ast, plannerCtx);\n \n     boolean usesMasking = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NDgzMw==", "bodyText": "Can we also add some tests with inserts on the based tables (i.e., the MVs become outdated and are not used), then rebuild, then verify the MV is used again? You can see different such scenarios in current materialized_view* tests.", "url": "https://github.com/apache/hive/pull/1706#discussion_r539764833", "createdAt": "2020-12-10T01:03:58Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/results/clientpositive/llap/materialized_view_rewrite_by_text_2.q.out", "diffHunk": "@@ -0,0 +1,334 @@\n+PREHOOK: query: create table cmv_basetable_n0 (a int, b varchar(256), c decimal(10,2), d int) stored as orc TBLPROPERTIES ('transactional'='true')\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@cmv_basetable_n0\n+POSTHOOK: query: create table cmv_basetable_n0 (a int, b varchar(256), c decimal(10,2), d int) stored as orc TBLPROPERTIES ('transactional'='true')\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@cmv_basetable_n0\n+PREHOOK: query: insert into cmv_basetable_n0 values\n+ (1, 'alfred', 10.30, 2),\n+ (2, 'bob', 3.14, 3),\n+ (2, 'bonnie', 172342.2, 3),\n+ (3, 'calvin', 978.76, 3),\n+ (3, 'charlie', 9.8, 1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@cmv_basetable_n0\n+POSTHOOK: query: insert into cmv_basetable_n0 values\n+ (1, 'alfred', 10.30, 2),\n+ (2, 'bob', 3.14, 3),\n+ (2, 'bonnie', 172342.2, 3),\n+ (3, 'calvin', 978.76, 3),\n+ (3, 'charlie', 9.8, 1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@cmv_basetable_n0\n+POSTHOOK: Lineage: cmv_basetable_n0.a SCRIPT []\n+POSTHOOK: Lineage: cmv_basetable_n0.b SCRIPT []\n+POSTHOOK: Lineage: cmv_basetable_n0.c SCRIPT []\n+POSTHOOK: Lineage: cmv_basetable_n0.d SCRIPT []\n+PREHOOK: query: create materialized view cmv_mat_view_n0\n+as select a, b, c from cmv_basetable_n0 where a = 2\n+PREHOOK: type: CREATE_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@cmv_mat_view_n0\n+POSTHOOK: query: create materialized view cmv_mat_view_n0\n+as select a, b, c from cmv_basetable_n0 where a = 2\n+POSTHOOK: type: CREATE_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@cmv_mat_view_n0\n+PREHOOK: query: select * from cmv_mat_view_n0\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_mat_view_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: select * from cmv_mat_view_n0\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_mat_view_n0\n+#### A masked pattern was here ####\n+2\tbob\t3.14\n+2\tbonnie\t172342.20\n+PREHOOK: query: show tblproperties cmv_mat_view_n0\n+PREHOOK: type: SHOW_TBLPROPERTIES\n+POSTHOOK: query: show tblproperties cmv_mat_view_n0\n+POSTHOOK: type: SHOW_TBLPROPERTIES\n+COLUMN_STATS_ACCURATE\t{\"BASIC_STATS\":\"true\",\"COLUMN_STATS\":{\"a\":\"true\",\"b\":\"true\",\"c\":\"true\"}}\n+bucketing_version\t2\n+numFiles\t1\n+numFilesErasureCoded\t0\n+numRows\t2\n+rawDataSize\t408\n+totalSize\t468\n+#### A masked pattern was here ####\n+PREHOOK: query: create materialized view if not exists cmv_mat_view2\n+as select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: CREATE_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: create materialized view if not exists cmv_mat_view2\n+as select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: CREATE_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: select * from cmv_mat_view2\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: select * from cmv_mat_view2\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: show tblproperties cmv_mat_view2\n+PREHOOK: type: SHOW_TBLPROPERTIES\n+POSTHOOK: query: show tblproperties cmv_mat_view2\n+POSTHOOK: type: SHOW_TBLPROPERTIES\n+COLUMN_STATS_ACCURATE\t{\"BASIC_STATS\":\"true\",\"COLUMN_STATS\":{\"a\":\"true\",\"c\":\"true\"}}\n+bucketing_version\t2\n+numFiles\t1\n+numFilesErasureCoded\t0\n+numRows\t2\n+rawDataSize\t232\n+totalSize\t334\n+#### A masked pattern was here ####\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: default.cmv_mat_view2\n+          Select Operator\n+            expressions: a (type: int), c (type: decimal(10,2))\n+            outputColumnNames: _col0, _col1\n+            ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: explain\n+alter materialized view cmv_mat_view2 disable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: explain\n+alter materialized view cmv_mat_view2 disable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+  Stage-1 depends on stages: Stage-0\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Alter Materialized View Rewrite\n+      name: default.cmv_mat_view2\n+      disable: true\n+\n+  Stage: Stage-1\n+    Materialized View Update\n+      name: default.cmv_mat_view2\n+      disable rewrite: true\n+\n+PREHOOK: query: alter materialized view cmv_mat_view2 disable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: alter materialized view cmv_mat_view2 disable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: cmv_basetable_n0\n+          filterExpr: (a = 3) (type: boolean)\n+          Filter Operator\n+            predicate: (a = 3) (type: boolean)\n+            Select Operator\n+              expressions: 3 (type: int), c (type: decimal(10,2))\n+              outputColumnNames: _col0, _col1\n+              ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: explain\n+alter materialized view cmv_mat_view2 enable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: explain\n+alter materialized view cmv_mat_view2 enable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+  Stage-1 depends on stages: Stage-0\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Alter Materialized View Rewrite\n+      name: default.cmv_mat_view2\n+      enable: true\n+\n+  Stage: Stage-1\n+    Materialized View Update\n+      name: default.cmv_mat_view2\n+      retrieve and include: true\n+\n+PREHOOK: query: alter materialized view cmv_mat_view2 enable rewrite\n+PREHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: alter materialized view cmv_mat_view2 enable rewrite\n+POSTHOOK: type: ALTER_MATERIALIZED_VIEW_REWRITE\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: default.cmv_mat_view2\n+          Select Operator\n+            expressions: a (type: int), c (type: decimal(10,2))\n+            outputColumnNames: _col0, _col1\n+            ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+PREHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+POSTHOOK: Input: default@cmv_mat_view2\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: drop materialized view cmv_mat_view2\n+PREHOOK: type: DROP_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_mat_view2\n+PREHOOK: Output: default@cmv_mat_view2\n+POSTHOOK: query: drop materialized view cmv_mat_view2\n+POSTHOOK: type: DROP_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_mat_view2\n+POSTHOOK: Output: default@cmv_mat_view2\n+PREHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        TableScan\n+          alias: cmv_basetable_n0\n+          filterExpr: (a = 3) (type: boolean)\n+          Filter Operator\n+            predicate: (a = 3) (type: boolean)\n+            Select Operator\n+              expressions: 3 (type: int), c (type: decimal(10,2))\n+              outputColumnNames: _col0, _col1\n+              ListSink\n+\n+PREHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+POSTHOOK: query: select a, c from cmv_basetable_n0 where a = 3\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@cmv_basetable_n0\n+#### A masked pattern was here ####\n+3\t9.80\n+3\t978.76\n+PREHOOK: query: drop materialized view cmv_mat_view_n0\n+PREHOOK: type: DROP_MATERIALIZED_VIEW\n+PREHOOK: Input: default@cmv_mat_view_n0\n+PREHOOK: Output: default@cmv_mat_view_n0\n+POSTHOOK: query: drop materialized view cmv_mat_view_n0\n+POSTHOOK: type: DROP_MATERIALIZED_VIEW\n+POSTHOOK: Input: default@cmv_mat_view_n0\n+POSTHOOK: Output: default@cmv_mat_view_n0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NjU1Mg==", "bodyText": "Another validation is needed here to confirm whether current user has access to such MV. See HiveMaterializedViewUtils.checkPrivilegeForMaterializedViews (cf4463e)\nPlease, add a test such as the one included in the cf4463e .", "url": "https://github.com/apache/hive/pull/1706#discussion_r539766552", "createdAt": "2020-12-10T01:08:44Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -2349,6 +2362,50 @@ private RelNode applyMaterializedViewRewriting(RelOptPlanner planner, RelNode ba\n       return basePlan;\n     }\n \n+    private RelOptMaterialization copyMaterializationToNewCluster(RelOptCluster optCluster, RelOptMaterialization materialization) {\n+      final RelNode viewScan = materialization.tableRel;\n+      final RelNode newViewScan = HiveMaterializedViewUtils.copyNodeNewCluster(\n+              optCluster, viewScan);\n+      return new RelOptMaterialization(newViewScan, materialization.queryRel, null,\n+              materialization.qualifiedTableName);\n+    }\n+\n+    private boolean isMaterializedViewRewritingByTextEnabled() {\n+      return conf.getBoolVar(ConfVars.HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING_QUERY_TEXT) &&\n+              mvRebuildMode == MaterializationRebuildMode.NONE &&\n+              !getQB().isMaterializedView() && !ctx.isLoadingMaterializedView() && !getQB().isCTAS() &&\n+              getQB().getIsQuery() &&\n+              getQB().hasTableDefined();\n+    }\n+\n+    private RelNode applyMaterializedViewRewritingByText(RelNode calciteGenPlan, RelOptCluster optCluster) {\n+      unparseTranslator.applyTranslations(ctx.getTokenRewriteStream(), EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM);\n+      String expandedQueryText = ctx.getTokenRewriteStream()\n+              .toString(EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM, ast.getTokenStartIndex(), ast.getTokenStopIndex());\n+      try {\n+        List<RelOptMaterialization> relOptMaterializationList = db.getMaterialization(\n+                expandedQueryText, getTablesUsed(calciteGenPlan), getTxnMgr());\n+        for (RelOptMaterialization relOptMaterialization : relOptMaterializationList) {\n+          try {\n+            Table hiveTableMD = extractTable(relOptMaterialization);\n+            if (db.validateMaterializedViewsFromRegistry(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NzE0Nw==", "bodyText": "Neat, thanks for adding these tests!!", "url": "https://github.com/apache/hive/pull/1706#discussion_r539767147", "createdAt": "2020-12-10T01:10:16Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/org/apache/hadoop/hive/ql/metadata/TestMaterializedViewsCache.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.metadata;\n+\n+import org.apache.calcite.plan.Convention;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptMaterialization;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptQuery;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelShuttle;\n+import org.apache.calcite.rel.RelVisitor;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.CorrelationId;\n+import org.apache.calcite.rel.metadata.Metadata;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.util.ImmutableBitSet;\n+import org.apache.calcite.util.Litmus;\n+import org.apache.calcite.util.Pair;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.RelOptHiveTable;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/**\n+ * Functional and parallel execution tests for {@link MaterializedViewsCache}.\n+ * Parallel execution test is disabled by default.\n+ */\n+class TestMaterializedViewsCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2Nzk0Nw==", "bodyText": "Would this still fail for queries that do not go through CBO due to missing support for some features/constructs? We do not have many of those queries left but maybe we should add the negative test (if it is not already there)", "url": "https://github.com/apache/hive/pull/1706#discussion_r539767947", "createdAt": "2020-12-10T01:12:31Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientnegative/materialized_view_no_cbo_rewrite.q", "diffHunk": "@@ -1,11 +0,0 @@\n-set hive.support.concurrency=true;\n-set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n-set hive.strict.checks.cartesian.product=false;\n-set hive.materializedview.rewriting=true;\n-\n-create table cmv_basetable (a int, b varchar(256), c decimal(10,2))\n-stored as orc TBLPROPERTIES ('transactional'='true');\n-\n-insert into cmv_basetable values (1, 'alfred', 10.30),(2, 'bob', 3.14),(2, 'bonnie', 172342.2),(3, 'calvin', 978.76),(3, 'charlie', 9.8);\n-\n-create materialized view cmv_mat_view as select a, b, c from cmv_basetable sort by a;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODIzNA==", "bodyText": "Why is this disabled now? Does the test change?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539768234", "createdAt": "2020-12-10T01:13:16Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite_dummy.q", "diffHunk": "@@ -6,6 +6,7 @@ set hive.support.concurrency=true;\n set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODI3MA==", "bodyText": "Why is this disabled now? Does the test change?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539768270", "createdAt": "2020-12-10T01:13:23Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/materialized_view_create_rewrite_multi_db.q", "diffHunk": "@@ -3,6 +3,7 @@ set hive.support.concurrency=true;\n set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODI4Nw==", "bodyText": "Why is this disabled now? Does the test change?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539768287", "createdAt": "2020-12-10T01:13:28Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/materialized_view_rewrite_1.q", "diffHunk": "@@ -5,6 +5,7 @@ set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n set hive.strict.checks.cartesian.product=false;\n set hive.stats.fetch.column.stats=true;\n set hive.materializedview.rewriting=true;\n+set hive.materializedview.rewriting.query.text=false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODY2Nw==", "bodyText": "No need, this is true by default?", "url": "https://github.com/apache/hive/pull/1706#discussion_r539768667", "createdAt": "2020-12-10T01:14:31Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/queries/clientpositive/materialized_view_rewrite_by_text_2.q", "diffHunk": "@@ -0,0 +1,65 @@\n+-- SORT_QUERY_RESULTS\n+\n+SET hive.vectorized.execution.enabled=false;\n+set hive.server2.materializedviews.registry.impl=DUMMY;\n+set hive.support.concurrency=true;\n+set hive.txn.manager=org.apache.hadoop.hive.ql.lockmgr.DbTxnManager;\n+set hive.strict.checks.cartesian.product=false;\n+set hive.materializedview.rewriting.query.text=true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2ODg3NA==", "bodyText": "Is this expected? Same question for the same WARNING messages in q files below (I assume root cause is the same).", "url": "https://github.com/apache/hive/pull/1706#discussion_r539768874", "createdAt": "2020-12-10T01:14:59Z", "author": {"login": "jcamachor"}, "path": "ql/src/test/results/clientpositive/llap/avrotblsjoin.q.out", "diffHunk": "@@ -73,6 +73,7 @@ POSTHOOK: Lineage: table1_1.col1 SCRIPT []\n POSTHOOK: Lineage: table1_1.col2 SCRIPT []\n WARNING: Comparing a bigint and a string may result in a loss of precision.\n WARNING: Comparing a bigint and a string may result in a loss of precision.\n+WARNING: Comparing a bigint and a string may result in a loss of precision.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/f2bd4979366380a4f7fd799a8933860eb0426ccc", "committedDate": "2020-12-08T07:14:16Z", "message": "HIVE-24274: Implement Query Text based MaterializedView rewrite"}, "afterCommit": {"oid": "75ccc402d8592281320675369b3477ac50a8ccc1", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/75ccc402d8592281320675369b3477ac50a8ccc1", "committedDate": "2020-12-10T07:10:44Z", "message": "rename config to hive.materializedview.rewriting.sql"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c35b599ce2652edcbeb8fca70863aad5b81a725", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/8c35b599ce2652edcbeb8fca70863aad5b81a725", "committedDate": "2020-12-10T10:22:03Z", "message": "refactor outdated validation logic"}, "afterCommit": {"oid": "742dc5b8d0d84712e466d3046dae5bf634f853ec", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/742dc5b8d0d84712e466d3046dae5bf634f853ec", "committedDate": "2020-12-10T13:02:36Z", "message": "log query sql text at trace level"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "742dc5b8d0d84712e466d3046dae5bf634f853ec", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/742dc5b8d0d84712e466d3046dae5bf634f853ec", "committedDate": "2020-12-10T13:02:36Z", "message": "log query sql text at trace level"}, "afterCommit": {"oid": "1c3b6e39cc7ea80ea05404c8992b1dfe5c7deb82", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/1c3b6e39cc7ea80ea05404c8992b1dfe5c7deb82", "committedDate": "2020-12-10T13:06:12Z", "message": "log query sql text at trace level"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3c872ebb9b9007dcaa75825570a9f92c3490009", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/d3c872ebb9b9007dcaa75825570a9f92c3490009", "committedDate": "2020-12-11T05:05:40Z", "message": "HIVE-24274: Implement Query Text based MaterializedView rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43cb8d9aa70fb161bc84c92c6731dc72aa603bd1", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/43cb8d9aa70fb161bc84c92c6731dc72aa603bd1", "committedDate": "2020-12-11T05:05:40Z", "message": "rename config to hive.materializedview.rewriting.sql"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b70bbb33565851dbfc195143789e78b071048d6", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/7b70bbb33565851dbfc195143789e78b071048d6", "committedDate": "2020-12-11T05:05:40Z", "message": "add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7f8bf07aa8710b8d84980d6a9da09be88bf3521", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/d7f8bf07aa8710b8d84980d6a9da09be88bf3521", "committedDate": "2020-12-11T05:05:40Z", "message": "rename getMaterialization to getMaterializedViewsBySql"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec82f81afc9ec10edbcf461a996b16cbf898221a", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/ec82f81afc9ec10edbcf461a996b16cbf898221a", "committedDate": "2020-12-11T05:05:40Z", "message": "disable parallelism test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e42a5070ca08042738ed1685ce478a0f7e17bd46", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/e42a5070ca08042738ed1685ce478a0f7e17bd46", "committedDate": "2020-12-11T05:05:40Z", "message": "refactor outdated validation logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27a369cfb6ab2b0e7abf01e7fea560ca4d88de40", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/27a369cfb6ab2b0e7abf01e7fea560ca4d88de40", "committedDate": "2020-12-11T05:05:40Z", "message": "log query sql text at trace level"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dcafba1318ea80d0a1f6ddc88064b111e9c47b0", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/8dcafba1318ea80d0a1f6ddc88064b111e9c47b0", "committedDate": "2020-12-11T05:05:40Z", "message": "make EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4852d431ca0399b676e04c17e5fe422da46cc401", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/4852d431ca0399b676e04c17e5fe422da46cc401", "committedDate": "2020-12-11T05:05:40Z", "message": "move copyMaterializationToNewCluster to HiveMaterializedViewUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfee0120cc7a20010d67da80cf360de298b16760", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/dfee0120cc7a20010d67da80cf360de298b16760", "committedDate": "2020-12-11T05:17:17Z", "message": "turn off text based rewrite"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "943484da359209abb32077fff807606c06a534f1", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/943484da359209abb32077fff807606c06a534f1", "committedDate": "2020-12-10T14:44:11Z", "message": "move copyMaterializationToNewCluster to HiveMaterializedViewUtils"}, "afterCommit": {"oid": "dfee0120cc7a20010d67da80cf360de298b16760", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/dfee0120cc7a20010d67da80cf360de298b16760", "committedDate": "2020-12-11T05:17:17Z", "message": "turn off text based rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "920cdb8ac2ee463f46785bf73d8c985dce9054b7", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/920cdb8ac2ee463f46785bf73d8c985dce9054b7", "committedDate": "2020-12-11T07:17:04Z", "message": "remove toLowerCase when lookup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a37670c849df2ed1be418ff2d42cfa1480def9d", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/5a37670c849df2ed1be418ff2d42cfa1480def9d", "committedDate": "2020-12-11T08:51:17Z", "message": "add test for masking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c097ddcf766777e8a13d17d5b0626fce294f3179", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/c097ddcf766777e8a13d17d5b0626fce294f3179", "committedDate": "2020-12-11T09:04:15Z", "message": "test filtering out outdated MVs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a316853915848c716a69eb6ee803816e0928d5f8", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/a316853915848c716a69eb6ee803816e0928d5f8", "committedDate": "2020-12-11T10:48:58Z", "message": "check privilege to use MV"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "863ea8e2769964133607680ae8cfdc7e82a2d126", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/863ea8e2769964133607680ae8cfdc7e82a2d126", "committedDate": "2020-12-11T13:02:55Z", "message": "remove \"set hive.materializedview.rewriting.sql=true\" since it is enabled by default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1781dc6a8288554d5f84e4926d0ac1a830beb647", "author": {"user": {"login": "kasakrisz", "name": "Krisztian Kasa"}}, "url": "https://github.com/apache/hive/commit/1781dc6a8288554d5f84e4926d0ac1a830beb647", "committedDate": "2020-12-14T17:50:56Z", "message": "add negative test: cbo turned off"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMDY1ODYw", "url": "https://github.com/apache/hive/pull/1706#pullrequestreview-552065860", "createdAt": "2020-12-15T02:51:16Z", "commit": {"oid": "1781dc6a8288554d5f84e4926d0ac1a830beb647"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3081, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}