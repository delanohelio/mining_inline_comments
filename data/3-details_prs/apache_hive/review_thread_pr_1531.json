{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0MTU0MzY2", "number": 1531, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNjoxNToyNVrOEoYmvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNjowNTo1NlrOEtVBUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNzgxNjI4OnYy", "diffSide": "RIGHT", "path": "ql/src/test/queries/clientpositive/annotate_stats_lateral_view_join.q", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNjoxNToyNVrOHZcXAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNjoxNToyNVrOHZcXAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ0MTA5MA==", "bodyText": "To make EXPLAIN show Statistics. I'm thinking to create another ticket and add this line to other annotate_stats_*.q.\ne.g. https://github.com/apache/hive/blob/master/ql/src/test/results/clientpositive/llap/annotate_stats_select.q.out", "url": "https://github.com/apache/hive/pull/1531#discussion_r496441090", "createdAt": "2020-09-29T06:15:25Z", "author": {"login": "okumin"}, "path": "ql/src/test/queries/clientpositive/annotate_stats_lateral_view_join.q", "diffHunk": "@@ -0,0 +1,38 @@\n+set hive.fetch.task.conversion=none;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88200f458e85f0982dc37641764e451e44d2548"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTcyMjY0OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMTowNTo1N1rOHaCGfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMzo1MTo0NlrOHaenIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1OTQ1NQ==", "bodyText": "Could you provide a bit more details about what the rule does? Most of the other rules in this class give a general overview of the cost model they implement.", "url": "https://github.com/apache/hive/pull/1531#discussion_r497059455", "createdAt": "2020-09-29T21:05:57Z", "author": {"login": "zabetak"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,77 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator joins the output of select with the output of UDTF.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88200f458e85f0982dc37641764e451e44d2548"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyNjU2MQ==", "bodyText": "@zabetak Thanks for taking a look!\nI added a description. Please feel free to ask me if something doesn't make sense.", "url": "https://github.com/apache/hive/pull/1531#discussion_r497526561", "createdAt": "2020-09-30T13:51:46Z", "author": {"login": "okumin"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,77 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator joins the output of select with the output of UDTF.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1OTQ1NQ=="}, "originalCommit": {"oid": "c88200f458e85f0982dc37641764e451e44d2548"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNjgzOTEzOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwMDowMToyMVrOHazRWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwMDowMToyMVrOHazRWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2NTA1MA==", "bodyText": "Just leaving a note. I took a quick look at the UDTF logic and it seems the selectivity is hardcoded via config. It seems the outer flag is not taken into account either, which could be a straightforward improvement for the estimates, i.e., UDFT will produce at least as many rows as it receives.", "url": "https://github.com/apache/hive/pull/1531#discussion_r497865050", "createdAt": "2020-10-01T00:01:21Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc942b665ea15e38b14c9c70d813c3bd348bc112"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNjg1MTU2OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwMDowODo0N1rOHazYww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNjoxMDo1NVrOHdPb1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2Njk0Nw==", "bodyText": "Do you need to clone them? Are you modifying them? (Same for next line)", "url": "https://github.com/apache/hive/pull/1531#discussion_r497866947", "createdAt": "2020-10-01T00:08:47Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics().clone();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc942b665ea15e38b14c9c70d813c3bd348bc112"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwNjM5Ng==", "bodyText": "As for udtfStats, we can totally avoid clone.\nAs for udtfStats, its column stats will be updated. However, looks like StatsUtils.getColStatisticsFromExprMap clones them?\nAnyway I think we can remove them if CI passes. I will try it.", "url": "https://github.com/apache/hive/pull/1531#discussion_r500006396", "createdAt": "2020-10-06T04:59:48Z", "author": {"login": "okumin"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics().clone();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2Njk0Nw=="}, "originalCommit": {"oid": "cc942b665ea15e38b14c9c70d813c3bd348bc112"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMzYzNw==", "bodyText": "Nothing was not unexpectedly broken. CI failed but it would not be related to this PR...\n\n91e492d", "url": "https://github.com/apache/hive/pull/1531#discussion_r500423637", "createdAt": "2020-10-06T16:10:55Z", "author": {"login": "okumin"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics().clone();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2Njk0Nw=="}, "originalCommit": {"oid": "cc942b665ea15e38b14c9c70d813c3bd348bc112"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzMxNDg3OnYy", "diffSide": "RIGHT", "path": "ql/src/test/results/clientpositive/llap/annotate_stats_lateral_view_join.q.out", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNjowNjozN1rOHdPQzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNDo1Mjo0N1rOHd3YhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMDgxMw==", "bodyText": "With clone, the following condition is not satisfied since the basic stats of parent operators are PARTIAL.\n\n  \n    \n      hive/ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java\n    \n    \n         Line 2969\n      in\n      91e492d\n    \n    \n    \n    \n\n        \n          \n           if (satisfyPrecondition(selectStats) && satisfyPrecondition(udtfStats)) {", "url": "https://github.com/apache/hive/pull/1531#discussion_r500420813", "createdAt": "2020-10-06T16:06:37Z", "author": {"login": "okumin"}, "path": "ql/src/test/results/clientpositive/llap/annotate_stats_lateral_view_join.q.out", "diffHunk": "@@ -503,14 +503,14 @@ STAGE PLANS:\n                             Statistics: Num rows: 1 Data size: 376 Basic stats: COMPLETE Column stats: COMPLETE\n                             Lateral View Join Operator\n                               outputColumnNames: _col0, _col1, _col5, _col6\n-                              Statistics: Num rows: 0 Data size: 24 Basic stats: PARTIAL Column stats: NONE\n+                              Statistics: Num rows: 0 Data size: 24 Basic stats: PARTIAL Column stats: COMPLETE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e492de239427fc1e38e5e4350cfdce409ebb70"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMjQ1Ng==", "bodyText": "BTW, it would be better that the UDTF rule puts one in num rows in case that it becomes zero.", "url": "https://github.com/apache/hive/pull/1531#discussion_r500422456", "createdAt": "2020-10-06T16:09:06Z", "author": {"login": "okumin"}, "path": "ql/src/test/results/clientpositive/llap/annotate_stats_lateral_view_join.q.out", "diffHunk": "@@ -503,14 +503,14 @@ STAGE PLANS:\n                             Statistics: Num rows: 1 Data size: 376 Basic stats: COMPLETE Column stats: COMPLETE\n                             Lateral View Join Operator\n                               outputColumnNames: _col0, _col1, _col5, _col6\n-                              Statistics: Num rows: 0 Data size: 24 Basic stats: PARTIAL Column stats: NONE\n+                              Statistics: Num rows: 0 Data size: 24 Basic stats: PARTIAL Column stats: COMPLETE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMDgxMw=="}, "originalCommit": {"oid": "91e492de239427fc1e38e5e4350cfdce409ebb70"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyMzgxMw==", "bodyText": "definetly - I don't think it will be 0 in reality!", "url": "https://github.com/apache/hive/pull/1531#discussion_r501023813", "createdAt": "2020-10-07T13:44:29Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/test/results/clientpositive/llap/annotate_stats_lateral_view_join.q.out", "diffHunk": "@@ -503,14 +503,14 @@ STAGE PLANS:\n                             Statistics: Num rows: 1 Data size: 376 Basic stats: COMPLETE Column stats: COMPLETE\n                             Lateral View Join Operator\n                               outputColumnNames: _col0, _col1, _col5, _col6\n-                              Statistics: Num rows: 0 Data size: 24 Basic stats: PARTIAL Column stats: NONE\n+                              Statistics: Num rows: 0 Data size: 24 Basic stats: PARTIAL Column stats: COMPLETE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMDgxMw=="}, "originalCommit": {"oid": "91e492de239427fc1e38e5e4350cfdce409ebb70"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA3ODE0OA==", "bodyText": "This is an edge case since HIVE_STATS_UDTF_FACTOR is greater than or equal to 1. Anyway, I created a ticket.\nhttps://issues.apache.org/jira/browse/HIVE-24240", "url": "https://github.com/apache/hive/pull/1531#discussion_r501078148", "createdAt": "2020-10-07T14:52:47Z", "author": {"login": "okumin"}, "path": "ql/src/test/results/clientpositive/llap/annotate_stats_lateral_view_join.q.out", "diffHunk": "@@ -503,14 +503,14 @@ STAGE PLANS:\n                             Statistics: Num rows: 1 Data size: 376 Basic stats: COMPLETE Column stats: COMPLETE\n                             Lateral View Join Operator\n                               outputColumnNames: _col0, _col1, _col5, _col6\n-                              Statistics: Num rows: 0 Data size: 24 Basic stats: PARTIAL Column stats: NONE\n+                              Statistics: Num rows: 0 Data size: 24 Basic stats: PARTIAL Column stats: COMPLETE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMDgxMw=="}, "originalCommit": {"oid": "91e492de239427fc1e38e5e4350cfdce409ebb70"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNjg5NjE4OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMjozNjo0MFrOHdxKSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMjo0NzowOFrOHec1-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk3NjIwMg==", "bodyText": "I know selectStats.getNumRows() should not be zero - but just in case... could you also add the resulting logic as StatsUtils or something like that?", "url": "https://github.com/apache/hive/pull/1531#discussion_r500976202", "createdAt": "2020-10-07T12:36:40Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY5MTg5Nw==", "bodyText": "Added steps to check both numbers and ensure at least one record on stats.\n5039634", "url": "https://github.com/apache/hive/pull/1531#discussion_r501691897", "createdAt": "2020-10-08T12:47:08Z", "author": {"login": "okumin"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk3NjIwMg=="}, "originalCommit": {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNjkyODUxOnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMjo0NDoyNlrOHdxdwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMjo0MzoyMFrOHecsaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4MTE4NQ==", "bodyText": "this seems to be a common expression in both branches of the if - could you move it outside?", "url": "https://github.com/apache/hive/pull/1531#discussion_r500981185", "createdAt": "2020-10-07T12:44:26Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long selectDataSize = StatsUtils.safeMult(selectStats.getDataSize(), factor);\n+      final long dataSize = StatsUtils.safeAdd(selectDataSize, udtfStats.getDataSize());\n+      Statistics joinedStats = new Statistics(udtfStats.getNumRows(), dataSize, 0, 0);\n+\n+      if (satisfyPrecondition(selectStats) && satisfyPrecondition(udtfStats)) {\n+        final Map<String, ExprNodeDesc> columnExprMap = lop.getColumnExprMap();\n+        final RowSchema schema = lop.getSchema();\n+\n+        joinedStats.updateColumnStatsState(selectStats.getColumnStatsState());\n+        final List<ColStatistics> selectColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, selectStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(multiplyColStats(selectColStats, factor));\n+\n+        joinedStats.updateColumnStatsState(udtfStats.getColumnStatsState());\n+        final List<ColStatistics> udtfColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, udtfStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(udtfColStats);\n+\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[0] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwMTc5NA==", "bodyText": "I wonder if we should switch [0] or [1] based on a condition. I can see some rules use a different marker based on maybe the existence of column stats.", "url": "https://github.com/apache/hive/pull/1531#discussion_r501101794", "createdAt": "2020-10-07T15:23:09Z", "author": {"login": "okumin"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long selectDataSize = StatsUtils.safeMult(selectStats.getDataSize(), factor);\n+      final long dataSize = StatsUtils.safeAdd(selectDataSize, udtfStats.getDataSize());\n+      Statistics joinedStats = new Statistics(udtfStats.getNumRows(), dataSize, 0, 0);\n+\n+      if (satisfyPrecondition(selectStats) && satisfyPrecondition(udtfStats)) {\n+        final Map<String, ExprNodeDesc> columnExprMap = lop.getColumnExprMap();\n+        final RowSchema schema = lop.getSchema();\n+\n+        joinedStats.updateColumnStatsState(selectStats.getColumnStatsState());\n+        final List<ColStatistics> selectColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, selectStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(multiplyColStats(selectColStats, factor));\n+\n+        joinedStats.updateColumnStatsState(udtfStats.getColumnStatsState());\n+        final List<ColStatistics> udtfColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, udtfStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(udtfColStats);\n+\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[0] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4MTE4NQ=="}, "originalCommit": {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwMzM0MQ==", "bodyText": "I don't know what's the point of these [0]/[1] markers; from one of the historical commits it seems to me like these are some kind of \"log message indexes\" inside the method ....\nI think we could stop doing that...", "url": "https://github.com/apache/hive/pull/1531#discussion_r501203341", "createdAt": "2020-10-07T17:55:26Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long selectDataSize = StatsUtils.safeMult(selectStats.getDataSize(), factor);\n+      final long dataSize = StatsUtils.safeAdd(selectDataSize, udtfStats.getDataSize());\n+      Statistics joinedStats = new Statistics(udtfStats.getNumRows(), dataSize, 0, 0);\n+\n+      if (satisfyPrecondition(selectStats) && satisfyPrecondition(udtfStats)) {\n+        final Map<String, ExprNodeDesc> columnExprMap = lop.getColumnExprMap();\n+        final RowSchema schema = lop.getSchema();\n+\n+        joinedStats.updateColumnStatsState(selectStats.getColumnStatsState());\n+        final List<ColStatistics> selectColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, selectStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(multiplyColStats(selectColStats, factor));\n+\n+        joinedStats.updateColumnStatsState(udtfStats.getColumnStatsState());\n+        final List<ColStatistics> udtfColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, udtfStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(udtfColStats);\n+\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[0] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4MTE4NQ=="}, "originalCommit": {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY4OTQ1MQ==", "bodyText": "I also agree and I did that.\nd333d5d", "url": "https://github.com/apache/hive/pull/1531#discussion_r501689451", "createdAt": "2020-10-08T12:43:20Z", "author": {"login": "okumin"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long selectDataSize = StatsUtils.safeMult(selectStats.getDataSize(), factor);\n+      final long dataSize = StatsUtils.safeAdd(selectDataSize, udtfStats.getDataSize());\n+      Statistics joinedStats = new Statistics(udtfStats.getNumRows(), dataSize, 0, 0);\n+\n+      if (satisfyPrecondition(selectStats) && satisfyPrecondition(udtfStats)) {\n+        final Map<String, ExprNodeDesc> columnExprMap = lop.getColumnExprMap();\n+        final RowSchema schema = lop.getSchema();\n+\n+        joinedStats.updateColumnStatsState(selectStats.getColumnStatsState());\n+        final List<ColStatistics> selectColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, selectStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(multiplyColStats(selectColStats, factor));\n+\n+        joinedStats.updateColumnStatsState(udtfStats.getColumnStatsState());\n+        final List<ColStatistics> udtfColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, udtfStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(udtfColStats);\n+\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[0] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4MTE4NQ=="}, "originalCommit": {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzE4Mjc1OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzo0MToyN1rOHdz7Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMjo1NjoxMFrOHedMKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyMTQ2Ng==", "bodyText": "I think we should make sure that NDV is at least 1 in case numrows is >0", "url": "https://github.com/apache/hive/pull/1531#discussion_r501021466", "createdAt": "2020-10-07T13:41:27Z", "author": {"login": "kgyrtkirk"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long selectDataSize = StatsUtils.safeMult(selectStats.getDataSize(), factor);\n+      final long dataSize = StatsUtils.safeAdd(selectDataSize, udtfStats.getDataSize());\n+      Statistics joinedStats = new Statistics(udtfStats.getNumRows(), dataSize, 0, 0);\n+\n+      if (satisfyPrecondition(selectStats) && satisfyPrecondition(udtfStats)) {\n+        final Map<String, ExprNodeDesc> columnExprMap = lop.getColumnExprMap();\n+        final RowSchema schema = lop.getSchema();\n+\n+        joinedStats.updateColumnStatsState(selectStats.getColumnStatsState());\n+        final List<ColStatistics> selectColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, selectStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(multiplyColStats(selectColStats, factor));\n+\n+        joinedStats.updateColumnStatsState(udtfStats.getColumnStatsState());\n+        final List<ColStatistics> udtfColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, udtfStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(udtfColStats);\n+\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[0] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }\n+      } else {\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[1] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }\n+      }\n+      return null;\n+    }\n+\n+    private List<ColStatistics> multiplyColStats(List<ColStatistics> colStatistics, double factor) {\n+      for (ColStatistics colStats : colStatistics) {\n+        colStats.setNumFalses(StatsUtils.safeMult(colStats.getNumFalses(), factor));\n+        colStats.setNumTrues(StatsUtils.safeMult(colStats.getNumTrues(), factor));\n+        colStats.setNumNulls(StatsUtils.safeMult(colStats.getNumNulls(), factor));\n+        // When factor > 1, the same records are duplicated and countDistinct never changes.\n+        if (factor < 1.0) {\n+          colStats.setCountDistint(StatsUtils.safeMult(colStats.getCountDistint(), factor));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5Njk5OQ==", "bodyText": "Now I think this is available for this purpose if we add updating num trues and num falses?\n\n  \n    \n      hive/ql/src/java/org/apache/hadoop/hive/ql/stats/StatsUtils.java\n    \n    \n        Lines 2050 to 2100\n      in\n      c082a72\n    \n    \n    \n    \n\n        \n          \n           public static void updateStats(Statistics stats, long newNumRows, \n        \n\n        \n          \n               boolean useColStats, Operator<? extends OperatorDesc> op, \n        \n\n        \n          \n               Set<String> affectedColumns) { \n        \n\n        \n          \n            \n        \n\n        \n          \n             if (newNumRows < 0) { \n        \n\n        \n          \n               LOG.debug(\"STATS-\" + op.toString() + \": Overflow in number of rows. \" \n        \n\n        \n          \n                   + newNumRows + \" rows will be set to Long.MAX_VALUE\"); \n        \n\n        \n          \n               newNumRows = StatsUtils.getMaxIfOverflow(newNumRows); \n        \n\n        \n          \n             } \n        \n\n        \n          \n             if (newNumRows == 0) { \n        \n\n        \n          \n               LOG.debug(\"STATS-\" + op.toString() + \": Equals 0 in number of rows. \" \n        \n\n        \n          \n                   + newNumRows + \" rows will be set to 1\"); \n        \n\n        \n          \n               newNumRows = 1; \n        \n\n        \n          \n             } \n        \n\n        \n          \n            \n        \n\n        \n          \n             long oldRowCount = stats.getNumRows(); \n        \n\n        \n          \n             double ratio = (double) newNumRows / (double) oldRowCount; \n        \n\n        \n          \n             stats.setNumRows(newNumRows); \n        \n\n        \n          \n            \n        \n\n        \n          \n             if (useColStats) { \n        \n\n        \n          \n               List<ColStatistics> colStats = stats.getColumnStats(); \n        \n\n        \n          \n               for (ColStatistics cs : colStats) { \n        \n\n        \n          \n                 long oldDV = cs.getCountDistint(); \n        \n\n        \n          \n                 if (affectedColumns.contains(cs.getColumnName())) { \n        \n\n        \n          \n                   long newDV = oldDV; \n        \n\n        \n          \n            \n        \n\n        \n          \n                   // if ratio is greater than 1, then number of rows increases. This can happen \n        \n\n        \n          \n                   // when some operators like GROUPBY duplicates the input rows in which case \n        \n\n        \n          \n                   // number of distincts should not change. Update the distinct count only when \n        \n\n        \n          \n                   // the output number of rows is less than input number of rows. \n        \n\n        \n          \n                   if (ratio <= 1.0) { \n        \n\n        \n          \n                     newDV = (long) Math.ceil(ratio * oldDV); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n                   cs.setCountDistint(newDV); \n        \n\n        \n          \n                   cs.setFilterColumn(); \n        \n\n        \n          \n                   oldDV = newDV; \n        \n\n        \n          \n                 } \n        \n\n        \n          \n                 if (oldDV > newNumRows) { \n        \n\n        \n          \n                   cs.setCountDistint(newNumRows); \n        \n\n        \n          \n                 } \n        \n\n        \n          \n                 long newNumNulls = Math.round(ratio * cs.getNumNulls()); \n        \n\n        \n          \n                 cs.setNumNulls(newNumNulls > newNumRows ? newNumRows: newNumNulls); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               stats.setColumnStats(colStats); \n        \n\n        \n          \n               long newDataSize = StatsUtils.getDataSizeFromColumnStats(newNumRows, colStats); \n        \n\n        \n          \n               stats.setDataSize(StatsUtils.getMaxIfOverflow(newDataSize)); \n        \n\n        \n          \n             } else { \n        \n\n        \n          \n               long newDataSize = (long) (ratio * stats.getDataSize()); \n        \n\n        \n          \n               stats.setDataSize(StatsUtils.getMaxIfOverflow(newDataSize)); \n        \n\n        \n          \n             } \n        \n\n        \n          \n           }", "url": "https://github.com/apache/hive/pull/1531#discussion_r501096999", "createdAt": "2020-10-07T15:17:04Z", "author": {"login": "okumin"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long selectDataSize = StatsUtils.safeMult(selectStats.getDataSize(), factor);\n+      final long dataSize = StatsUtils.safeAdd(selectDataSize, udtfStats.getDataSize());\n+      Statistics joinedStats = new Statistics(udtfStats.getNumRows(), dataSize, 0, 0);\n+\n+      if (satisfyPrecondition(selectStats) && satisfyPrecondition(udtfStats)) {\n+        final Map<String, ExprNodeDesc> columnExprMap = lop.getColumnExprMap();\n+        final RowSchema schema = lop.getSchema();\n+\n+        joinedStats.updateColumnStatsState(selectStats.getColumnStatsState());\n+        final List<ColStatistics> selectColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, selectStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(multiplyColStats(selectColStats, factor));\n+\n+        joinedStats.updateColumnStatsState(udtfStats.getColumnStatsState());\n+        final List<ColStatistics> udtfColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, udtfStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(udtfColStats);\n+\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[0] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }\n+      } else {\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[1] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }\n+      }\n+      return null;\n+    }\n+\n+    private List<ColStatistics> multiplyColStats(List<ColStatistics> colStatistics, double factor) {\n+      for (ColStatistics colStats : colStatistics) {\n+        colStats.setNumFalses(StatsUtils.safeMult(colStats.getNumFalses(), factor));\n+        colStats.setNumTrues(StatsUtils.safeMult(colStats.getNumTrues(), factor));\n+        colStats.setNumNulls(StatsUtils.safeMult(colStats.getNumNulls(), factor));\n+        // When factor > 1, the same records are duplicated and countDistinct never changes.\n+        if (factor < 1.0) {\n+          colStats.setCountDistint(StatsUtils.safeMult(colStats.getCountDistint(), factor));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyMTQ2Ng=="}, "originalCommit": {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExMDkyMg==", "bodyText": "This method may include additional logging and logics to optimize JOIN such as cs.setFilterColumn. It would be better to implement a simple and separate utility.", "url": "https://github.com/apache/hive/pull/1531#discussion_r501110922", "createdAt": "2020-10-07T15:35:11Z", "author": {"login": "okumin"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long selectDataSize = StatsUtils.safeMult(selectStats.getDataSize(), factor);\n+      final long dataSize = StatsUtils.safeAdd(selectDataSize, udtfStats.getDataSize());\n+      Statistics joinedStats = new Statistics(udtfStats.getNumRows(), dataSize, 0, 0);\n+\n+      if (satisfyPrecondition(selectStats) && satisfyPrecondition(udtfStats)) {\n+        final Map<String, ExprNodeDesc> columnExprMap = lop.getColumnExprMap();\n+        final RowSchema schema = lop.getSchema();\n+\n+        joinedStats.updateColumnStatsState(selectStats.getColumnStatsState());\n+        final List<ColStatistics> selectColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, selectStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(multiplyColStats(selectColStats, factor));\n+\n+        joinedStats.updateColumnStatsState(udtfStats.getColumnStatsState());\n+        final List<ColStatistics> udtfColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, udtfStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(udtfColStats);\n+\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[0] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }\n+      } else {\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[1] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }\n+      }\n+      return null;\n+    }\n+\n+    private List<ColStatistics> multiplyColStats(List<ColStatistics> colStatistics, double factor) {\n+      for (ColStatistics colStats : colStatistics) {\n+        colStats.setNumFalses(StatsUtils.safeMult(colStats.getNumFalses(), factor));\n+        colStats.setNumTrues(StatsUtils.safeMult(colStats.getNumTrues(), factor));\n+        colStats.setNumNulls(StatsUtils.safeMult(colStats.getNumNulls(), factor));\n+        // When factor > 1, the same records are duplicated and countDistinct never changes.\n+        if (factor < 1.0) {\n+          colStats.setCountDistint(StatsUtils.safeMult(colStats.getCountDistint(), factor));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyMTQ2Ng=="}, "originalCommit": {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY5NzU3OQ==", "bodyText": "Ceiled. I moved this method since I'd like to reuse it for HIVE-24240.\n5039634", "url": "https://github.com/apache/hive/pull/1531#discussion_r501697579", "createdAt": "2020-10-08T12:56:10Z", "author": {"login": "okumin"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long selectDataSize = StatsUtils.safeMult(selectStats.getDataSize(), factor);\n+      final long dataSize = StatsUtils.safeAdd(selectDataSize, udtfStats.getDataSize());\n+      Statistics joinedStats = new Statistics(udtfStats.getNumRows(), dataSize, 0, 0);\n+\n+      if (satisfyPrecondition(selectStats) && satisfyPrecondition(udtfStats)) {\n+        final Map<String, ExprNodeDesc> columnExprMap = lop.getColumnExprMap();\n+        final RowSchema schema = lop.getSchema();\n+\n+        joinedStats.updateColumnStatsState(selectStats.getColumnStatsState());\n+        final List<ColStatistics> selectColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, selectStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(multiplyColStats(selectColStats, factor));\n+\n+        joinedStats.updateColumnStatsState(udtfStats.getColumnStatsState());\n+        final List<ColStatistics> udtfColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, udtfStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(udtfColStats);\n+\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[0] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }\n+      } else {\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[1] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }\n+      }\n+      return null;\n+    }\n+\n+    private List<ColStatistics> multiplyColStats(List<ColStatistics> colStatistics, double factor) {\n+      for (ColStatistics colStats : colStatistics) {\n+        colStats.setNumFalses(StatsUtils.safeMult(colStats.getNumFalses(), factor));\n+        colStats.setNumTrues(StatsUtils.safeMult(colStats.getNumTrues(), factor));\n+        colStats.setNumNulls(StatsUtils.safeMult(colStats.getNumNulls(), factor));\n+        // When factor > 1, the same records are duplicated and countDistinct never changes.\n+        if (factor < 1.0) {\n+          colStats.setCountDistint(StatsUtils.safeMult(colStats.getCountDistint(), factor));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyMTQ2Ng=="}, "originalCommit": {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTY1Nzc5OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNjowNTo1NlrOHhDgmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNjowNTo1NlrOHhDgmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQyMjU1NA==", "bodyText": "factor will be greater than 0.0 and must not 0 or infinity.", "url": "https://github.com/apache/hive/pull/1531#discussion_r504422554", "createdAt": "2020-10-14T06:05:56Z", "author": {"login": "okumin"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2961,10 +2961,11 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n       final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n       final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n \n-      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long udtfNumRows = Math.max(udtfStats.getNumRows(), 1);\n+      final double factor = (double) udtfNumRows / (double) Math.max(selectStats.getNumRows(), 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50396346eaed5d6bab4ff87dd079918a769a7ebd"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 299, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}