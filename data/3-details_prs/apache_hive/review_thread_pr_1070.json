{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI5OTA1MzIw", "number": 1070, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMTo1MDo0MFrOEDo66w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMTo1MTowNVrOEDo7Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjUxNjI3OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/ppd/OpProcFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMTo1MDo0MFrOGgxq7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzo1MTo0MFrOGg0J9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMTQyMg==", "bodyText": "Please use a while.", "url": "https://github.com/apache/hive/pull/1070#discussion_r437021422", "createdAt": "2020-06-08T21:50:40Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/ppd/OpProcFactory.java", "diffHunk": "@@ -733,6 +736,97 @@ private void applyFilterTransitivity(JoinOperator join, int targetPos, OpWalkerI\n     }\n   }\n \n+  public static class GroupByPPD extends DefaultPPD implements SemanticNodeProcessor {\n+\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+        Object... nodeOutputs) throws SemanticException {\n+      super.process(nd, stack, procCtx, nodeOutputs);\n+      OpWalkerInfo owi = (OpWalkerInfo) procCtx;\n+      GroupByDesc groupByDesc = ((GroupByOperator)nd).getConf();\n+      ExprWalkerInfo prunedPred = owi.getPrunedPreds((Operator<? extends OperatorDesc>) nd);\n+      if (prunedPred == null || !prunedPred.hasAnyCandidates() ||\n+          !groupByDesc.isGroupingSetsPresent()) {\n+        return null;\n+      }\n+\n+      List<Long> groupingSets = groupByDesc.getListGroupingSets();\n+      Map<String, List<ExprNodeDesc>> candidates = prunedPred.getFinalCandidates();\n+      FastBitSet[] fastBitSets = new FastBitSet[groupingSets.size()];\n+      int groupingSetPosition = groupByDesc.getGroupingSetPosition();\n+      for (int pos = 0; pos < fastBitSets.length; pos ++) {\n+        fastBitSets[pos] = GroupByOperator.groupingSet2BitSet(groupingSets.get(pos),\n+            groupingSetPosition);\n+      }\n+      List<ExprNodeDesc> groupByKeys = ((GroupByOperator)nd).getConf().getKeys();\n+      Map<ExprNodeDesc, ExprNodeDesc> newToOldExprMap = prunedPred.getNewToOldExprMap();\n+      Map<String, List<ExprNodeDesc>> nonFinalCandidates = new HashMap<String, List<ExprNodeDesc>>();\n+      for (Iterator<Map.Entry<String, List<ExprNodeDesc>>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49221e186ebf0503b1a01e52920a802d05983711"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MjEzNQ==", "bodyText": "Done, Thanks @jcamachor for the review!", "url": "https://github.com/apache/hive/pull/1070#discussion_r437062135", "createdAt": "2020-06-08T23:51:40Z", "author": {"login": "dengzhhu653"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/ppd/OpProcFactory.java", "diffHunk": "@@ -733,6 +736,97 @@ private void applyFilterTransitivity(JoinOperator join, int targetPos, OpWalkerI\n     }\n   }\n \n+  public static class GroupByPPD extends DefaultPPD implements SemanticNodeProcessor {\n+\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+        Object... nodeOutputs) throws SemanticException {\n+      super.process(nd, stack, procCtx, nodeOutputs);\n+      OpWalkerInfo owi = (OpWalkerInfo) procCtx;\n+      GroupByDesc groupByDesc = ((GroupByOperator)nd).getConf();\n+      ExprWalkerInfo prunedPred = owi.getPrunedPreds((Operator<? extends OperatorDesc>) nd);\n+      if (prunedPred == null || !prunedPred.hasAnyCandidates() ||\n+          !groupByDesc.isGroupingSetsPresent()) {\n+        return null;\n+      }\n+\n+      List<Long> groupingSets = groupByDesc.getListGroupingSets();\n+      Map<String, List<ExprNodeDesc>> candidates = prunedPred.getFinalCandidates();\n+      FastBitSet[] fastBitSets = new FastBitSet[groupingSets.size()];\n+      int groupingSetPosition = groupByDesc.getGroupingSetPosition();\n+      for (int pos = 0; pos < fastBitSets.length; pos ++) {\n+        fastBitSets[pos] = GroupByOperator.groupingSet2BitSet(groupingSets.get(pos),\n+            groupingSetPosition);\n+      }\n+      List<ExprNodeDesc> groupByKeys = ((GroupByOperator)nd).getConf().getKeys();\n+      Map<ExprNodeDesc, ExprNodeDesc> newToOldExprMap = prunedPred.getNewToOldExprMap();\n+      Map<String, List<ExprNodeDesc>> nonFinalCandidates = new HashMap<String, List<ExprNodeDesc>>();\n+      for (Iterator<Map.Entry<String, List<ExprNodeDesc>>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMTQyMg=="}, "originalCommit": {"oid": "49221e186ebf0503b1a01e52920a802d05983711"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjUxNzM5OnYy", "diffSide": "RIGHT", "path": "ql/src/java/org/apache/hadoop/hive/ql/ppd/OpProcFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMTo1MTowNVrOGgxrmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzowNzoxOFrOGg3O1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMTU5NA==", "bodyText": "Please use a while.", "url": "https://github.com/apache/hive/pull/1070#discussion_r437021594", "createdAt": "2020-06-08T21:51:05Z", "author": {"login": "jcamachor"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/ppd/OpProcFactory.java", "diffHunk": "@@ -733,6 +736,97 @@ private void applyFilterTransitivity(JoinOperator join, int targetPos, OpWalkerI\n     }\n   }\n \n+  public static class GroupByPPD extends DefaultPPD implements SemanticNodeProcessor {\n+\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+        Object... nodeOutputs) throws SemanticException {\n+      super.process(nd, stack, procCtx, nodeOutputs);\n+      OpWalkerInfo owi = (OpWalkerInfo) procCtx;\n+      GroupByDesc groupByDesc = ((GroupByOperator)nd).getConf();\n+      ExprWalkerInfo prunedPred = owi.getPrunedPreds((Operator<? extends OperatorDesc>) nd);\n+      if (prunedPred == null || !prunedPred.hasAnyCandidates() ||\n+          !groupByDesc.isGroupingSetsPresent()) {\n+        return null;\n+      }\n+\n+      List<Long> groupingSets = groupByDesc.getListGroupingSets();\n+      Map<String, List<ExprNodeDesc>> candidates = prunedPred.getFinalCandidates();\n+      FastBitSet[] fastBitSets = new FastBitSet[groupingSets.size()];\n+      int groupingSetPosition = groupByDesc.getGroupingSetPosition();\n+      for (int pos = 0; pos < fastBitSets.length; pos ++) {\n+        fastBitSets[pos] = GroupByOperator.groupingSet2BitSet(groupingSets.get(pos),\n+            groupingSetPosition);\n+      }\n+      List<ExprNodeDesc> groupByKeys = ((GroupByOperator)nd).getConf().getKeys();\n+      Map<ExprNodeDesc, ExprNodeDesc> newToOldExprMap = prunedPred.getNewToOldExprMap();\n+      Map<String, List<ExprNodeDesc>> nonFinalCandidates = new HashMap<String, List<ExprNodeDesc>>();\n+      for (Iterator<Map.Entry<String, List<ExprNodeDesc>>>\n+           iter = candidates.entrySet().iterator(); iter.hasNext(); ) {\n+        Map.Entry<String, List<ExprNodeDesc>> entry = iter.next();\n+        List<ExprNodeDesc> residualExprs = new ArrayList<ExprNodeDesc>();\n+        List<ExprNodeDesc> finalCandidates = new ArrayList<ExprNodeDesc>();\n+        List<ExprNodeDesc> exprs = entry.getValue();\n+        for (ExprNodeDesc expr : exprs) {\n+          if (canPredPushdown(expr, groupByKeys, fastBitSets, groupingSetPosition)) {\n+            finalCandidates.add(expr);\n+          } else {\n+            residualExprs.add(newToOldExprMap.get(expr));\n+          }\n+        }\n+        if (!residualExprs.isEmpty()) {\n+          nonFinalCandidates.put(entry.getKey(), residualExprs);\n+        }\n+\n+        if (finalCandidates.isEmpty()) {\n+          iter.remove();\n+        } else {\n+          exprs.clear();\n+          exprs.addAll(finalCandidates);\n+        }\n+      }\n+      \n+      if (!nonFinalCandidates.isEmpty()) {\n+        createFilter((Operator) nd, nonFinalCandidates, owi);\n+      }\n+      return null;\n+    }\n+\n+    private boolean canPredPushdown(ExprNodeDesc expr, List<ExprNodeDesc> groupByKeys,\n+        FastBitSet[] bitSets, int groupingSetPosition) {\n+      List<ExprNodeDesc> columns = new ArrayList<ExprNodeDesc>();\n+      extractCols(expr, columns);\n+      for (ExprNodeDesc col : columns) {\n+        int index = groupByKeys.indexOf(col);\n+        assert index >= 0;\n+        for (FastBitSet bitset : bitSets) {\n+          int keyPos = bitset.nextClearBit(0);\n+          for (; keyPos < groupingSetPosition && keyPos != index;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49221e186ebf0503b1a01e52920a802d05983711"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExMjUzNA==", "bodyText": "Done", "url": "https://github.com/apache/hive/pull/1070#discussion_r437112534", "createdAt": "2020-06-09T03:07:18Z", "author": {"login": "dengzhhu653"}, "path": "ql/src/java/org/apache/hadoop/hive/ql/ppd/OpProcFactory.java", "diffHunk": "@@ -733,6 +736,97 @@ private void applyFilterTransitivity(JoinOperator join, int targetPos, OpWalkerI\n     }\n   }\n \n+  public static class GroupByPPD extends DefaultPPD implements SemanticNodeProcessor {\n+\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+        Object... nodeOutputs) throws SemanticException {\n+      super.process(nd, stack, procCtx, nodeOutputs);\n+      OpWalkerInfo owi = (OpWalkerInfo) procCtx;\n+      GroupByDesc groupByDesc = ((GroupByOperator)nd).getConf();\n+      ExprWalkerInfo prunedPred = owi.getPrunedPreds((Operator<? extends OperatorDesc>) nd);\n+      if (prunedPred == null || !prunedPred.hasAnyCandidates() ||\n+          !groupByDesc.isGroupingSetsPresent()) {\n+        return null;\n+      }\n+\n+      List<Long> groupingSets = groupByDesc.getListGroupingSets();\n+      Map<String, List<ExprNodeDesc>> candidates = prunedPred.getFinalCandidates();\n+      FastBitSet[] fastBitSets = new FastBitSet[groupingSets.size()];\n+      int groupingSetPosition = groupByDesc.getGroupingSetPosition();\n+      for (int pos = 0; pos < fastBitSets.length; pos ++) {\n+        fastBitSets[pos] = GroupByOperator.groupingSet2BitSet(groupingSets.get(pos),\n+            groupingSetPosition);\n+      }\n+      List<ExprNodeDesc> groupByKeys = ((GroupByOperator)nd).getConf().getKeys();\n+      Map<ExprNodeDesc, ExprNodeDesc> newToOldExprMap = prunedPred.getNewToOldExprMap();\n+      Map<String, List<ExprNodeDesc>> nonFinalCandidates = new HashMap<String, List<ExprNodeDesc>>();\n+      for (Iterator<Map.Entry<String, List<ExprNodeDesc>>>\n+           iter = candidates.entrySet().iterator(); iter.hasNext(); ) {\n+        Map.Entry<String, List<ExprNodeDesc>> entry = iter.next();\n+        List<ExprNodeDesc> residualExprs = new ArrayList<ExprNodeDesc>();\n+        List<ExprNodeDesc> finalCandidates = new ArrayList<ExprNodeDesc>();\n+        List<ExprNodeDesc> exprs = entry.getValue();\n+        for (ExprNodeDesc expr : exprs) {\n+          if (canPredPushdown(expr, groupByKeys, fastBitSets, groupingSetPosition)) {\n+            finalCandidates.add(expr);\n+          } else {\n+            residualExprs.add(newToOldExprMap.get(expr));\n+          }\n+        }\n+        if (!residualExprs.isEmpty()) {\n+          nonFinalCandidates.put(entry.getKey(), residualExprs);\n+        }\n+\n+        if (finalCandidates.isEmpty()) {\n+          iter.remove();\n+        } else {\n+          exprs.clear();\n+          exprs.addAll(finalCandidates);\n+        }\n+      }\n+      \n+      if (!nonFinalCandidates.isEmpty()) {\n+        createFilter((Operator) nd, nonFinalCandidates, owi);\n+      }\n+      return null;\n+    }\n+\n+    private boolean canPredPushdown(ExprNodeDesc expr, List<ExprNodeDesc> groupByKeys,\n+        FastBitSet[] bitSets, int groupingSetPosition) {\n+      List<ExprNodeDesc> columns = new ArrayList<ExprNodeDesc>();\n+      extractCols(expr, columns);\n+      for (ExprNodeDesc col : columns) {\n+        int index = groupByKeys.indexOf(col);\n+        assert index >= 0;\n+        for (FastBitSet bitset : bitSets) {\n+          int keyPos = bitset.nextClearBit(0);\n+          for (; keyPos < groupingSetPosition && keyPos != index;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMTU5NA=="}, "originalCommit": {"oid": "49221e186ebf0503b1a01e52920a802d05983711"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 740, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}