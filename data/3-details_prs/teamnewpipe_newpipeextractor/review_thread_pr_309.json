{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNjMyODMx", "number": 309, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwOTowMDowMVrODwsP1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMDoxMDo1NFrOExlx6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzgzMTg4OnYy", "diffSide": "RIGHT", "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/media_ccc/linkHandler/MediaCCCStreamLinkHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwOTowMDowMVrOGD1O4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDoyMjoxOFrOGD27YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3MTA3NQ==", "bodyText": "Why are you using a regex for conferences while using substring() for API URLs here and using URL#getPath() + substring() for non-API URLs here?", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r406671075", "createdAt": "2020-04-10T09:00:01Z", "author": {"login": "wb9688"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/media_ccc/linkHandler/MediaCCCStreamLinkHandlerFactory.java", "diffHunk": "@@ -9,10 +8,12 @@\n import java.net.URL;\n \n public class MediaCCCStreamLinkHandlerFactory extends LinkHandlerFactory {\n+    public static final String VIDEO_API_ENDPOINT = \"https://api.media.ccc.de/public/events/\";\n+    private static final String VIDEO_PATH = \"https://media.ccc.de/v/\";\n \n     @Override\n     public String getId(String urlString) throws ParsingException {\n-        if (urlString.startsWith(\"https://api.media.ccc.de/public/events/\") &&\n+        if (urlString.startsWith(VIDEO_API_ENDPOINT) &&\n                 !urlString.contains(\"?q=\")) {\n             return urlString.substring(39); //remove api\u2026/public/events part\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5ODg0OQ==", "bodyText": "I left everything as it was before, I only replaced the hardcoded url. Will fix this", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r406698849", "createdAt": "2020-04-10T10:22:18Z", "author": {"login": "Stypox"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/media_ccc/linkHandler/MediaCCCStreamLinkHandlerFactory.java", "diffHunk": "@@ -9,10 +8,12 @@\n import java.net.URL;\n \n public class MediaCCCStreamLinkHandlerFactory extends LinkHandlerFactory {\n+    public static final String VIDEO_API_ENDPOINT = \"https://api.media.ccc.de/public/events/\";\n+    private static final String VIDEO_PATH = \"https://media.ccc.de/v/\";\n \n     @Override\n     public String getId(String urlString) throws ParsingException {\n-        if (urlString.startsWith(\"https://api.media.ccc.de/public/events/\") &&\n+        if (urlString.startsWith(VIDEO_API_ENDPOINT) &&\n                 !urlString.contains(\"?q=\")) {\n             return urlString.substring(39); //remove api\u2026/public/events part\n         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3MTA3NQ=="}, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzgzNzA4OnYy", "diffSide": "RIGHT", "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/peertube/linkHandler/PeertubeChannelLinkHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwOTowMjowMVrOGD1R1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMzozMjozNlrOGENPwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3MTgzMA==", "bodyText": "Please also handle the API URLs in getId() here", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r406671830", "createdAt": "2020-04-10T09:02:01Z", "author": {"login": "wb9688"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/peertube/linkHandler/PeertubeChannelLinkHandlerFactory.java", "diffHunk": "@@ -31,7 +32,7 @@ public String getUrl(String id, List<String> contentFilters, String searchFilter\n     @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NDUxMg==", "bodyText": "Fixed while rebasing with the latest changes about accounts and channels", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r407064512", "createdAt": "2020-04-11T13:32:36Z", "author": {"login": "Stypox"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/peertube/linkHandler/PeertubeChannelLinkHandlerFactory.java", "diffHunk": "@@ -31,7 +32,7 @@ public String getUrl(String id, List<String> contentFilters, String searchFilter\n     @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3MTgzMA=="}, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzg0MDM2OnYy", "diffSide": "RIGHT", "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/peertube/linkHandler/PeertubeStreamLinkHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwOTowMzowMFrOGD1Tjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMzozMTozOVrOGENPOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3MjI3MA==", "bodyText": "Please also handle the API URLs in getId() here", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r406672270", "createdAt": "2020-04-10T09:03:00Z", "author": {"login": "wb9688"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/peertube/linkHandler/PeertubeStreamLinkHandlerFactory.java", "diffHunk": "@@ -27,7 +28,7 @@ public String getUrl(String id) {\n \n     @Override\n     public String getUrl(String id, String baseUrl) {\n-        return baseUrl + VIDEO_ENDPOINT + id;\n+        return baseUrl + VIDEO_PATH + id;\n     }\n \n     @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTI1OA==", "bodyText": "Oh right, for some reason I thought they were already being handled in some strange way", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r406699258", "createdAt": "2020-04-10T10:23:34Z", "author": {"login": "Stypox"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/peertube/linkHandler/PeertubeStreamLinkHandlerFactory.java", "diffHunk": "@@ -27,7 +28,7 @@ public String getUrl(String id) {\n \n     @Override\n     public String getUrl(String id, String baseUrl) {\n-        return baseUrl + VIDEO_ENDPOINT + id;\n+        return baseUrl + VIDEO_PATH + id;\n     }\n \n     @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3MjI3MA=="}, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NDM3OA==", "bodyText": "Those are already handled by the regex: /videos/(watch/)?([^/?&#]*)\nBoth \"framatube.org/api/v1/videos/id\" and \"framatube.org/videos/id\" match it and the second group is obtained correctly", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r407064378", "createdAt": "2020-04-11T13:31:39Z", "author": {"login": "Stypox"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/peertube/linkHandler/PeertubeStreamLinkHandlerFactory.java", "diffHunk": "@@ -27,7 +28,7 @@ public String getUrl(String id) {\n \n     @Override\n     public String getUrl(String id, String baseUrl) {\n-        return baseUrl + VIDEO_ENDPOINT + id;\n+        return baseUrl + VIDEO_PATH + id;\n     }\n \n     @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3MjI3MA=="}, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzg0MjU2OnYy", "diffSide": "RIGHT", "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/youtube/extractors/YoutubeStreamExtractor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwOTowMzo1NFrOGD1U9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwOTowMzo1NFrOGD1U9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3MjYyOQ==", "bodyText": "Could be final", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r406672629", "createdAt": "2020-04-10T09:03:54Z", "author": {"login": "wb9688"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/youtube/extractors/YoutubeStreamExtractor.java", "diffHunk": "@@ -258,7 +258,14 @@ public long getLength() throws ParsingException {\n      */\n     @Override\n     public long getTimeStamp() throws ParsingException {\n-        return getTimestampSeconds(\"((#|&|\\\\?)t=\\\\d{0,3}h?\\\\d{0,3}m?\\\\d{1,3}s?)\");\n+        long timestamp = getTimestampSeconds(\"((#|&|\\\\?)t=\\\\d{0,3}h?\\\\d{0,3}m?\\\\d{1,3}s?)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzg0MzQ4OnYy", "diffSide": "RIGHT", "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/youtube/extractors/YoutubeStreamExtractor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwOTowNDoxNFrOGD1Vfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMzozNzoyMVrOGENRtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3Mjc2Ng==", "bodyText": "Why was this changed?", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r406672766", "createdAt": "2020-04-10T09:04:14Z", "author": {"login": "wb9688"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/youtube/extractors/YoutubeStreamExtractor.java", "diffHunk": "@@ -579,7 +586,7 @@ public String getErrorMessage() {\n         try {\n             return getTextFromObject(initialAjaxJson.getObject(2).getObject(\"playerResponse\").getObject(\"playabilityStatus\")\n                     .getObject(\"errorScreen\").getObject(\"playerErrorMessageRenderer\").getObject(\"reason\"));\n-        } catch (ParsingException e) {\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5ODAzOQ==", "bodyText": "So that it also catches NullPointerExceptions, which are generated when there is no error message. In that case null should be returned", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r406698039", "createdAt": "2020-04-10T10:19:26Z", "author": {"login": "Stypox"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/youtube/extractors/YoutubeStreamExtractor.java", "diffHunk": "@@ -579,7 +586,7 @@ public String getErrorMessage() {\n         try {\n             return getTextFromObject(initialAjaxJson.getObject(2).getObject(\"playerResponse\").getObject(\"playabilityStatus\")\n                     .getObject(\"errorScreen\").getObject(\"playerErrorMessageRenderer\").getObject(\"reason\"));\n-        } catch (ParsingException e) {\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3Mjc2Ng=="}, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NTAxNA==", "bodyText": "Then why aren't you catching (ParsingException | NullPointerException e)?", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r407065014", "createdAt": "2020-04-11T13:37:21Z", "author": {"login": "B0pol"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/youtube/extractors/YoutubeStreamExtractor.java", "diffHunk": "@@ -579,7 +586,7 @@ public String getErrorMessage() {\n         try {\n             return getTextFromObject(initialAjaxJson.getObject(2).getObject(\"playerResponse\").getObject(\"playabilityStatus\")\n                     .getObject(\"errorScreen\").getObject(\"playerErrorMessageRenderer\").getObject(\"reason\"));\n-        } catch (ParsingException e) {\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3Mjc2Ng=="}, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzg0OTAwOnYy", "diffSide": "RIGHT", "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwOTowNjoyNFrOGD1Yow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDoxOTozN1rOGD24Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3MzU3MQ==", "bodyText": "Could be final, just like a lot of variables in this class", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r406673571", "createdAt": "2020-04-10T09:06:24Z", "author": {"login": "wb9688"}, "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package org.schabi.newpipe.extractor.services;\n+\n+import org.junit.Test;\n+import org.schabi.newpipe.extractor.MediaFormat;\n+import org.schabi.newpipe.extractor.localization.DateWrapper;\n+import org.schabi.newpipe.extractor.stream.AudioStream;\n+import org.schabi.newpipe.extractor.stream.Description;\n+import org.schabi.newpipe.extractor.stream.Frameset;\n+import org.schabi.newpipe.extractor.stream.StreamExtractor;\n+import org.schabi.newpipe.extractor.stream.StreamInfoItemsCollector;\n+import org.schabi.newpipe.extractor.stream.StreamType;\n+import org.schabi.newpipe.extractor.stream.SubtitlesStream;\n+import org.schabi.newpipe.extractor.stream.VideoStream;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.List;\n+\n+import javax.annotation.Nullable;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertAtLeast;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsSecureUrl;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsValidUrl;\n+import static org.schabi.newpipe.extractor.services.DefaultTests.defaultTestListOfItems;\n+\n+/**\n+ * Test for {@link StreamExtractor}\n+ */\n+public abstract class DefaultStreamExtractorTest extends DefaultExtractorTest<StreamExtractor>\n+        implements BaseStreamExtractorTest {\n+\n+    public abstract StreamType expectedStreamType();\n+    public abstract String expectedUploaderName();\n+    public abstract String expectedUploaderUrl();\n+    public abstract List<String> expectedDescriptionContains(); // e.g. for full links\n+    public abstract long expectedLength();\n+    public long expectedTimestamp() { return 0; }; // default: there is no timestamp\n+    public abstract long expectedViewCountAtLeast();\n+    @Nullable public abstract String expectedUploadDate(); // format: \"yyyy-MM-dd HH:mm:ss.SSS\"\n+    @Nullable public abstract String expectedTextualUploadDate();\n+    public abstract long expectedLikeCountAtLeast(); // return -1 if ratings are disabled\n+    public abstract long expectedDislikeCountAtLeast(); // return -1 if ratings are disabled\n+    public boolean expectedHasRelatedStreams() { return true; } // default: there are related videos\n+    public int expectedAgeLimit() { return StreamExtractor.NO_AGE_LIMIT; } // default: no limit\n+    @Nullable public String expectedErrorMessage() { return null; } // default: no error message\n+    public boolean expectedHasVideoStreams() { return true; } // default: there are video streams\n+    public boolean expectedHasAudioStreams() { return true; } // default: there are audio streams\n+    public boolean expectedHasSubtitles() { return true; } // default: there are subtitles streams\n+    public boolean expectedHasFrames() { return true; } // default: there are frames\n+    public boolean expectedHasNextStream() { return true; } // default: there is a next video\n+\n+    @Test\n+    @Override\n+    public void testStreamType() throws Exception {\n+        assertEquals(expectedStreamType(), extractor().getStreamType());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderName() throws Exception {\n+        assertEquals(expectedUploaderName(), extractor().getUploaderName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderUrl() throws Exception {\n+        final String uploaderUrl = extractor().getUploaderUrl();\n+        assertIsSecureUrl(uploaderUrl);\n+        assertEquals(expectedUploaderUrl(), uploaderUrl);\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderAvatarUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getUploaderAvatarUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testThumbnailUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getThumbnailUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDescription() throws Exception {\n+        Description description = extractor().getDescription();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5ODA4Mg==", "bodyText": "Ok, will fix this in all modified files", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r406698082", "createdAt": "2020-04-10T10:19:37Z", "author": {"login": "Stypox"}, "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package org.schabi.newpipe.extractor.services;\n+\n+import org.junit.Test;\n+import org.schabi.newpipe.extractor.MediaFormat;\n+import org.schabi.newpipe.extractor.localization.DateWrapper;\n+import org.schabi.newpipe.extractor.stream.AudioStream;\n+import org.schabi.newpipe.extractor.stream.Description;\n+import org.schabi.newpipe.extractor.stream.Frameset;\n+import org.schabi.newpipe.extractor.stream.StreamExtractor;\n+import org.schabi.newpipe.extractor.stream.StreamInfoItemsCollector;\n+import org.schabi.newpipe.extractor.stream.StreamType;\n+import org.schabi.newpipe.extractor.stream.SubtitlesStream;\n+import org.schabi.newpipe.extractor.stream.VideoStream;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.List;\n+\n+import javax.annotation.Nullable;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertAtLeast;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsSecureUrl;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsValidUrl;\n+import static org.schabi.newpipe.extractor.services.DefaultTests.defaultTestListOfItems;\n+\n+/**\n+ * Test for {@link StreamExtractor}\n+ */\n+public abstract class DefaultStreamExtractorTest extends DefaultExtractorTest<StreamExtractor>\n+        implements BaseStreamExtractorTest {\n+\n+    public abstract StreamType expectedStreamType();\n+    public abstract String expectedUploaderName();\n+    public abstract String expectedUploaderUrl();\n+    public abstract List<String> expectedDescriptionContains(); // e.g. for full links\n+    public abstract long expectedLength();\n+    public long expectedTimestamp() { return 0; }; // default: there is no timestamp\n+    public abstract long expectedViewCountAtLeast();\n+    @Nullable public abstract String expectedUploadDate(); // format: \"yyyy-MM-dd HH:mm:ss.SSS\"\n+    @Nullable public abstract String expectedTextualUploadDate();\n+    public abstract long expectedLikeCountAtLeast(); // return -1 if ratings are disabled\n+    public abstract long expectedDislikeCountAtLeast(); // return -1 if ratings are disabled\n+    public boolean expectedHasRelatedStreams() { return true; } // default: there are related videos\n+    public int expectedAgeLimit() { return StreamExtractor.NO_AGE_LIMIT; } // default: no limit\n+    @Nullable public String expectedErrorMessage() { return null; } // default: no error message\n+    public boolean expectedHasVideoStreams() { return true; } // default: there are video streams\n+    public boolean expectedHasAudioStreams() { return true; } // default: there are audio streams\n+    public boolean expectedHasSubtitles() { return true; } // default: there are subtitles streams\n+    public boolean expectedHasFrames() { return true; } // default: there are frames\n+    public boolean expectedHasNextStream() { return true; } // default: there is a next video\n+\n+    @Test\n+    @Override\n+    public void testStreamType() throws Exception {\n+        assertEquals(expectedStreamType(), extractor().getStreamType());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderName() throws Exception {\n+        assertEquals(expectedUploaderName(), extractor().getUploaderName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderUrl() throws Exception {\n+        final String uploaderUrl = extractor().getUploaderUrl();\n+        assertIsSecureUrl(uploaderUrl);\n+        assertEquals(expectedUploaderUrl(), uploaderUrl);\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderAvatarUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getUploaderAvatarUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testThumbnailUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getThumbnailUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDescription() throws Exception {\n+        Description description = extractor().getDescription();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3MzU3MQ=="}, "originalCommit": {"oid": "051e3fa5aa43417ac221ac030aa33ae2e3359cc0"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzAzNDM4OnYy", "diffSide": "RIGHT", "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0MjowM1rOGVYXEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0MjowM1rOGVYXEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MjQwMw==", "bodyText": "final", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r425072403", "createdAt": "2020-05-14T11:42:03Z", "author": {"login": "wb9688"}, "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+package org.schabi.newpipe.extractor.services;\n+\n+import org.junit.Test;\n+import org.schabi.newpipe.extractor.MediaFormat;\n+import org.schabi.newpipe.extractor.localization.DateWrapper;\n+import org.schabi.newpipe.extractor.stream.AudioStream;\n+import org.schabi.newpipe.extractor.stream.Description;\n+import org.schabi.newpipe.extractor.stream.Frameset;\n+import org.schabi.newpipe.extractor.stream.StreamExtractor;\n+import org.schabi.newpipe.extractor.stream.StreamInfoItemsCollector;\n+import org.schabi.newpipe.extractor.stream.StreamType;\n+import org.schabi.newpipe.extractor.stream.SubtitlesStream;\n+import org.schabi.newpipe.extractor.stream.VideoStream;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import javax.annotation.Nullable;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertAtLeast;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsSecureUrl;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsValidUrl;\n+import static org.schabi.newpipe.extractor.services.DefaultTests.defaultTestListOfItems;\n+\n+/**\n+ * Test for {@link StreamExtractor}\n+ */\n+public abstract class DefaultStreamExtractorTest extends DefaultExtractorTest<StreamExtractor>\n+        implements BaseStreamExtractorTest {\n+\n+    public abstract StreamType expectedStreamType();\n+    public abstract String expectedUploaderName();\n+    public abstract String expectedUploaderUrl();\n+    public abstract List<String> expectedDescriptionContains(); // e.g. for full links\n+    public abstract long expectedLength();\n+    public long expectedTimestamp() { return 0; }; // default: there is no timestamp\n+    public abstract long expectedViewCountAtLeast();\n+    @Nullable public abstract String expectedUploadDate(); // format: \"yyyy-MM-dd HH:mm:ss.SSS\"\n+    @Nullable public abstract String expectedTextualUploadDate();\n+    public abstract long expectedLikeCountAtLeast(); // return -1 if ratings are disabled\n+    public abstract long expectedDislikeCountAtLeast(); // return -1 if ratings are disabled\n+    public boolean expectedHasRelatedStreams() { return true; } // default: there are related videos\n+    public int expectedAgeLimit() { return StreamExtractor.NO_AGE_LIMIT; } // default: no limit\n+    @Nullable public String expectedErrorMessage() { return null; } // default: no error message\n+    public boolean expectedHasVideoStreams() { return true; } // default: there are video streams\n+    public boolean expectedHasAudioStreams() { return true; } // default: there are audio streams\n+    public boolean expectedHasSubtitles() { return true; } // default: there are subtitles streams\n+    public boolean expectedHasFrames() { return true; } // default: there are frames\n+    public boolean expectedHasNextStream() { return true; } // default: there is a next video\n+\n+    @Test\n+    @Override\n+    public void testStreamType() throws Exception {\n+        assertEquals(expectedStreamType(), extractor().getStreamType());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderName() throws Exception {\n+        assertEquals(expectedUploaderName(), extractor().getUploaderName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderUrl() throws Exception {\n+        final String uploaderUrl = extractor().getUploaderUrl();\n+        assertIsSecureUrl(uploaderUrl);\n+        assertEquals(expectedUploaderUrl(), uploaderUrl);\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderAvatarUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getUploaderAvatarUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testThumbnailUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getThumbnailUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDescription() throws Exception {\n+        final Description description = extractor().getDescription();\n+        assertNotNull(description);\n+        assertFalse(\"description is empty\", description.getContent().isEmpty());\n+\n+        for (String s : expectedDescriptionContains()) {\n+            assertThat(description.getContent(), containsString(s));\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLength() throws Exception {\n+        assertEquals(expectedLength(), extractor().getLength());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTimestamp() throws Exception {\n+        assertEquals(expectedTimestamp(), extractor().getTimeStamp());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testViewCount() throws Exception {\n+        assertAtLeast(expectedViewCountAtLeast(), extractor().getViewCount());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploadDate() throws Exception {\n+        final DateWrapper dateWrapper = extractor().getUploadDate();\n+\n+        if (expectedUploadDate() == null) {\n+            assertNull(dateWrapper);\n+        } else {\n+            assertNotNull(dateWrapper);\n+\n+            final Calendar expectedDate = Calendar.getInstance();\n+            final Calendar actualDate = dateWrapper.date();\n+            expectedDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            actualDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+\n+            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n+            expectedDate.setTime(sdf.parse(expectedUploadDate()));\n+            assertEquals(expectedDate, actualDate);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTextualUploadDate() throws Exception {\n+        assertEquals(expectedTextualUploadDate(), extractor().getTextualUploadDate());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLikeCount() throws Exception {\n+        if (expectedLikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getLikeCount());\n+        } else {\n+            assertAtLeast(expectedLikeCountAtLeast(), extractor().getLikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDislikeCount() throws Exception {\n+        if (expectedDislikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getDislikeCount());\n+        } else {\n+            assertAtLeast(expectedDislikeCountAtLeast(), extractor().getDislikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testRelatedStreams() throws Exception {\n+        final StreamInfoItemsCollector relatedStreams = extractor().getRelatedStreams();\n+\n+        if (expectedHasRelatedStreams()) {\n+            defaultTestListOfItems(extractor().getService(), relatedStreams.getItems(),\n+                    relatedStreams.getErrors());\n+        } else {\n+            assertNull(relatedStreams);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAgeLimit() throws Exception {\n+        assertEquals(expectedAgeLimit(), extractor().getAgeLimit());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testErrorMessage() throws Exception {\n+        assertEquals(expectedErrorMessage(), extractor().getErrorMessage());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testVideoStreams() throws Exception {\n+        List<VideoStream> videoStreams = extractor().getVideoStreams();\n+        final List<VideoStream> videoOnlyStreams = extractor().getVideoOnlyStreams();\n+        assertNotNull(videoStreams);\n+        assertNotNull(videoOnlyStreams);\n+        videoStreams.addAll(videoOnlyStreams);\n+\n+        if (expectedHasVideoStreams()) {\n+            assertFalse(videoStreams.isEmpty());\n+\n+            for (VideoStream stream : videoStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+                assertFalse(stream.getResolution().isEmpty());\n+\n+                int formatId = stream.getFormatId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ace2b0dc97db6df467f41a74219776304dac6f"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzAzNDY2OnYy", "diffSide": "RIGHT", "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0MjowOVrOGVYXRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0MjowOVrOGVYXRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MjQ1NA==", "bodyText": "final", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r425072454", "createdAt": "2020-05-14T11:42:09Z", "author": {"login": "wb9688"}, "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+package org.schabi.newpipe.extractor.services;\n+\n+import org.junit.Test;\n+import org.schabi.newpipe.extractor.MediaFormat;\n+import org.schabi.newpipe.extractor.localization.DateWrapper;\n+import org.schabi.newpipe.extractor.stream.AudioStream;\n+import org.schabi.newpipe.extractor.stream.Description;\n+import org.schabi.newpipe.extractor.stream.Frameset;\n+import org.schabi.newpipe.extractor.stream.StreamExtractor;\n+import org.schabi.newpipe.extractor.stream.StreamInfoItemsCollector;\n+import org.schabi.newpipe.extractor.stream.StreamType;\n+import org.schabi.newpipe.extractor.stream.SubtitlesStream;\n+import org.schabi.newpipe.extractor.stream.VideoStream;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import javax.annotation.Nullable;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertAtLeast;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsSecureUrl;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsValidUrl;\n+import static org.schabi.newpipe.extractor.services.DefaultTests.defaultTestListOfItems;\n+\n+/**\n+ * Test for {@link StreamExtractor}\n+ */\n+public abstract class DefaultStreamExtractorTest extends DefaultExtractorTest<StreamExtractor>\n+        implements BaseStreamExtractorTest {\n+\n+    public abstract StreamType expectedStreamType();\n+    public abstract String expectedUploaderName();\n+    public abstract String expectedUploaderUrl();\n+    public abstract List<String> expectedDescriptionContains(); // e.g. for full links\n+    public abstract long expectedLength();\n+    public long expectedTimestamp() { return 0; }; // default: there is no timestamp\n+    public abstract long expectedViewCountAtLeast();\n+    @Nullable public abstract String expectedUploadDate(); // format: \"yyyy-MM-dd HH:mm:ss.SSS\"\n+    @Nullable public abstract String expectedTextualUploadDate();\n+    public abstract long expectedLikeCountAtLeast(); // return -1 if ratings are disabled\n+    public abstract long expectedDislikeCountAtLeast(); // return -1 if ratings are disabled\n+    public boolean expectedHasRelatedStreams() { return true; } // default: there are related videos\n+    public int expectedAgeLimit() { return StreamExtractor.NO_AGE_LIMIT; } // default: no limit\n+    @Nullable public String expectedErrorMessage() { return null; } // default: no error message\n+    public boolean expectedHasVideoStreams() { return true; } // default: there are video streams\n+    public boolean expectedHasAudioStreams() { return true; } // default: there are audio streams\n+    public boolean expectedHasSubtitles() { return true; } // default: there are subtitles streams\n+    public boolean expectedHasFrames() { return true; } // default: there are frames\n+    public boolean expectedHasNextStream() { return true; } // default: there is a next video\n+\n+    @Test\n+    @Override\n+    public void testStreamType() throws Exception {\n+        assertEquals(expectedStreamType(), extractor().getStreamType());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderName() throws Exception {\n+        assertEquals(expectedUploaderName(), extractor().getUploaderName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderUrl() throws Exception {\n+        final String uploaderUrl = extractor().getUploaderUrl();\n+        assertIsSecureUrl(uploaderUrl);\n+        assertEquals(expectedUploaderUrl(), uploaderUrl);\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderAvatarUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getUploaderAvatarUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testThumbnailUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getThumbnailUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDescription() throws Exception {\n+        final Description description = extractor().getDescription();\n+        assertNotNull(description);\n+        assertFalse(\"description is empty\", description.getContent().isEmpty());\n+\n+        for (String s : expectedDescriptionContains()) {\n+            assertThat(description.getContent(), containsString(s));\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLength() throws Exception {\n+        assertEquals(expectedLength(), extractor().getLength());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTimestamp() throws Exception {\n+        assertEquals(expectedTimestamp(), extractor().getTimeStamp());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testViewCount() throws Exception {\n+        assertAtLeast(expectedViewCountAtLeast(), extractor().getViewCount());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploadDate() throws Exception {\n+        final DateWrapper dateWrapper = extractor().getUploadDate();\n+\n+        if (expectedUploadDate() == null) {\n+            assertNull(dateWrapper);\n+        } else {\n+            assertNotNull(dateWrapper);\n+\n+            final Calendar expectedDate = Calendar.getInstance();\n+            final Calendar actualDate = dateWrapper.date();\n+            expectedDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            actualDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+\n+            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n+            expectedDate.setTime(sdf.parse(expectedUploadDate()));\n+            assertEquals(expectedDate, actualDate);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTextualUploadDate() throws Exception {\n+        assertEquals(expectedTextualUploadDate(), extractor().getTextualUploadDate());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLikeCount() throws Exception {\n+        if (expectedLikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getLikeCount());\n+        } else {\n+            assertAtLeast(expectedLikeCountAtLeast(), extractor().getLikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDislikeCount() throws Exception {\n+        if (expectedDislikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getDislikeCount());\n+        } else {\n+            assertAtLeast(expectedDislikeCountAtLeast(), extractor().getDislikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testRelatedStreams() throws Exception {\n+        final StreamInfoItemsCollector relatedStreams = extractor().getRelatedStreams();\n+\n+        if (expectedHasRelatedStreams()) {\n+            defaultTestListOfItems(extractor().getService(), relatedStreams.getItems(),\n+                    relatedStreams.getErrors());\n+        } else {\n+            assertNull(relatedStreams);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAgeLimit() throws Exception {\n+        assertEquals(expectedAgeLimit(), extractor().getAgeLimit());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testErrorMessage() throws Exception {\n+        assertEquals(expectedErrorMessage(), extractor().getErrorMessage());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testVideoStreams() throws Exception {\n+        List<VideoStream> videoStreams = extractor().getVideoStreams();\n+        final List<VideoStream> videoOnlyStreams = extractor().getVideoOnlyStreams();\n+        assertNotNull(videoStreams);\n+        assertNotNull(videoOnlyStreams);\n+        videoStreams.addAll(videoOnlyStreams);\n+\n+        if (expectedHasVideoStreams()) {\n+            assertFalse(videoStreams.isEmpty());\n+\n+            for (VideoStream stream : videoStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+                assertFalse(stream.getResolution().isEmpty());\n+\n+                int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit a video stream: \" + formatId,\n+                        0 <= formatId && formatId < 0x100);\n+            }\n+        } else {\n+            assertTrue(videoStreams.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAudioStreams() throws Exception {\n+        final List<AudioStream> audioStreams = extractor().getAudioStreams();\n+        assertNotNull(audioStreams);\n+\n+        if (expectedHasAudioStreams()) {\n+            assertFalse(audioStreams.isEmpty());\n+\n+            for (AudioStream stream : audioStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+\n+                int formatId = stream.getFormatId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ace2b0dc97db6df467f41a74219776304dac6f"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzAzNTEyOnYy", "diffSide": "RIGHT", "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0MjoxNlrOGVYXjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0MjoxNlrOGVYXjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MjUyNQ==", "bodyText": "final", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r425072525", "createdAt": "2020-05-14T11:42:16Z", "author": {"login": "wb9688"}, "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+package org.schabi.newpipe.extractor.services;\n+\n+import org.junit.Test;\n+import org.schabi.newpipe.extractor.MediaFormat;\n+import org.schabi.newpipe.extractor.localization.DateWrapper;\n+import org.schabi.newpipe.extractor.stream.AudioStream;\n+import org.schabi.newpipe.extractor.stream.Description;\n+import org.schabi.newpipe.extractor.stream.Frameset;\n+import org.schabi.newpipe.extractor.stream.StreamExtractor;\n+import org.schabi.newpipe.extractor.stream.StreamInfoItemsCollector;\n+import org.schabi.newpipe.extractor.stream.StreamType;\n+import org.schabi.newpipe.extractor.stream.SubtitlesStream;\n+import org.schabi.newpipe.extractor.stream.VideoStream;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import javax.annotation.Nullable;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertAtLeast;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsSecureUrl;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsValidUrl;\n+import static org.schabi.newpipe.extractor.services.DefaultTests.defaultTestListOfItems;\n+\n+/**\n+ * Test for {@link StreamExtractor}\n+ */\n+public abstract class DefaultStreamExtractorTest extends DefaultExtractorTest<StreamExtractor>\n+        implements BaseStreamExtractorTest {\n+\n+    public abstract StreamType expectedStreamType();\n+    public abstract String expectedUploaderName();\n+    public abstract String expectedUploaderUrl();\n+    public abstract List<String> expectedDescriptionContains(); // e.g. for full links\n+    public abstract long expectedLength();\n+    public long expectedTimestamp() { return 0; }; // default: there is no timestamp\n+    public abstract long expectedViewCountAtLeast();\n+    @Nullable public abstract String expectedUploadDate(); // format: \"yyyy-MM-dd HH:mm:ss.SSS\"\n+    @Nullable public abstract String expectedTextualUploadDate();\n+    public abstract long expectedLikeCountAtLeast(); // return -1 if ratings are disabled\n+    public abstract long expectedDislikeCountAtLeast(); // return -1 if ratings are disabled\n+    public boolean expectedHasRelatedStreams() { return true; } // default: there are related videos\n+    public int expectedAgeLimit() { return StreamExtractor.NO_AGE_LIMIT; } // default: no limit\n+    @Nullable public String expectedErrorMessage() { return null; } // default: no error message\n+    public boolean expectedHasVideoStreams() { return true; } // default: there are video streams\n+    public boolean expectedHasAudioStreams() { return true; } // default: there are audio streams\n+    public boolean expectedHasSubtitles() { return true; } // default: there are subtitles streams\n+    public boolean expectedHasFrames() { return true; } // default: there are frames\n+    public boolean expectedHasNextStream() { return true; } // default: there is a next video\n+\n+    @Test\n+    @Override\n+    public void testStreamType() throws Exception {\n+        assertEquals(expectedStreamType(), extractor().getStreamType());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderName() throws Exception {\n+        assertEquals(expectedUploaderName(), extractor().getUploaderName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderUrl() throws Exception {\n+        final String uploaderUrl = extractor().getUploaderUrl();\n+        assertIsSecureUrl(uploaderUrl);\n+        assertEquals(expectedUploaderUrl(), uploaderUrl);\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderAvatarUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getUploaderAvatarUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testThumbnailUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getThumbnailUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDescription() throws Exception {\n+        final Description description = extractor().getDescription();\n+        assertNotNull(description);\n+        assertFalse(\"description is empty\", description.getContent().isEmpty());\n+\n+        for (String s : expectedDescriptionContains()) {\n+            assertThat(description.getContent(), containsString(s));\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLength() throws Exception {\n+        assertEquals(expectedLength(), extractor().getLength());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTimestamp() throws Exception {\n+        assertEquals(expectedTimestamp(), extractor().getTimeStamp());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testViewCount() throws Exception {\n+        assertAtLeast(expectedViewCountAtLeast(), extractor().getViewCount());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploadDate() throws Exception {\n+        final DateWrapper dateWrapper = extractor().getUploadDate();\n+\n+        if (expectedUploadDate() == null) {\n+            assertNull(dateWrapper);\n+        } else {\n+            assertNotNull(dateWrapper);\n+\n+            final Calendar expectedDate = Calendar.getInstance();\n+            final Calendar actualDate = dateWrapper.date();\n+            expectedDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            actualDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+\n+            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n+            expectedDate.setTime(sdf.parse(expectedUploadDate()));\n+            assertEquals(expectedDate, actualDate);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTextualUploadDate() throws Exception {\n+        assertEquals(expectedTextualUploadDate(), extractor().getTextualUploadDate());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLikeCount() throws Exception {\n+        if (expectedLikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getLikeCount());\n+        } else {\n+            assertAtLeast(expectedLikeCountAtLeast(), extractor().getLikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDislikeCount() throws Exception {\n+        if (expectedDislikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getDislikeCount());\n+        } else {\n+            assertAtLeast(expectedDislikeCountAtLeast(), extractor().getDislikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testRelatedStreams() throws Exception {\n+        final StreamInfoItemsCollector relatedStreams = extractor().getRelatedStreams();\n+\n+        if (expectedHasRelatedStreams()) {\n+            defaultTestListOfItems(extractor().getService(), relatedStreams.getItems(),\n+                    relatedStreams.getErrors());\n+        } else {\n+            assertNull(relatedStreams);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAgeLimit() throws Exception {\n+        assertEquals(expectedAgeLimit(), extractor().getAgeLimit());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testErrorMessage() throws Exception {\n+        assertEquals(expectedErrorMessage(), extractor().getErrorMessage());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testVideoStreams() throws Exception {\n+        List<VideoStream> videoStreams = extractor().getVideoStreams();\n+        final List<VideoStream> videoOnlyStreams = extractor().getVideoOnlyStreams();\n+        assertNotNull(videoStreams);\n+        assertNotNull(videoOnlyStreams);\n+        videoStreams.addAll(videoOnlyStreams);\n+\n+        if (expectedHasVideoStreams()) {\n+            assertFalse(videoStreams.isEmpty());\n+\n+            for (VideoStream stream : videoStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+                assertFalse(stream.getResolution().isEmpty());\n+\n+                int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit a video stream: \" + formatId,\n+                        0 <= formatId && formatId < 0x100);\n+            }\n+        } else {\n+            assertTrue(videoStreams.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAudioStreams() throws Exception {\n+        final List<AudioStream> audioStreams = extractor().getAudioStreams();\n+        assertNotNull(audioStreams);\n+\n+        if (expectedHasAudioStreams()) {\n+            assertFalse(audioStreams.isEmpty());\n+\n+            for (AudioStream stream : audioStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+\n+                int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit an audio stream: \" + formatId,\n+                        0x100 <= formatId && formatId < 0x1000);\n+            }\n+        } else {\n+            assertTrue(audioStreams.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testSubtitles() throws Exception {\n+        List<SubtitlesStream> subtitles = extractor().getSubtitlesDefault();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ace2b0dc97db6df467f41a74219776304dac6f"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzAzNTQ3OnYy", "diffSide": "RIGHT", "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0MjoyMVrOGVYXvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0MjoyMVrOGVYXvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MjU3NQ==", "bodyText": "final", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r425072575", "createdAt": "2020-05-14T11:42:21Z", "author": {"login": "wb9688"}, "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+package org.schabi.newpipe.extractor.services;\n+\n+import org.junit.Test;\n+import org.schabi.newpipe.extractor.MediaFormat;\n+import org.schabi.newpipe.extractor.localization.DateWrapper;\n+import org.schabi.newpipe.extractor.stream.AudioStream;\n+import org.schabi.newpipe.extractor.stream.Description;\n+import org.schabi.newpipe.extractor.stream.Frameset;\n+import org.schabi.newpipe.extractor.stream.StreamExtractor;\n+import org.schabi.newpipe.extractor.stream.StreamInfoItemsCollector;\n+import org.schabi.newpipe.extractor.stream.StreamType;\n+import org.schabi.newpipe.extractor.stream.SubtitlesStream;\n+import org.schabi.newpipe.extractor.stream.VideoStream;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import javax.annotation.Nullable;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertAtLeast;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsSecureUrl;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsValidUrl;\n+import static org.schabi.newpipe.extractor.services.DefaultTests.defaultTestListOfItems;\n+\n+/**\n+ * Test for {@link StreamExtractor}\n+ */\n+public abstract class DefaultStreamExtractorTest extends DefaultExtractorTest<StreamExtractor>\n+        implements BaseStreamExtractorTest {\n+\n+    public abstract StreamType expectedStreamType();\n+    public abstract String expectedUploaderName();\n+    public abstract String expectedUploaderUrl();\n+    public abstract List<String> expectedDescriptionContains(); // e.g. for full links\n+    public abstract long expectedLength();\n+    public long expectedTimestamp() { return 0; }; // default: there is no timestamp\n+    public abstract long expectedViewCountAtLeast();\n+    @Nullable public abstract String expectedUploadDate(); // format: \"yyyy-MM-dd HH:mm:ss.SSS\"\n+    @Nullable public abstract String expectedTextualUploadDate();\n+    public abstract long expectedLikeCountAtLeast(); // return -1 if ratings are disabled\n+    public abstract long expectedDislikeCountAtLeast(); // return -1 if ratings are disabled\n+    public boolean expectedHasRelatedStreams() { return true; } // default: there are related videos\n+    public int expectedAgeLimit() { return StreamExtractor.NO_AGE_LIMIT; } // default: no limit\n+    @Nullable public String expectedErrorMessage() { return null; } // default: no error message\n+    public boolean expectedHasVideoStreams() { return true; } // default: there are video streams\n+    public boolean expectedHasAudioStreams() { return true; } // default: there are audio streams\n+    public boolean expectedHasSubtitles() { return true; } // default: there are subtitles streams\n+    public boolean expectedHasFrames() { return true; } // default: there are frames\n+    public boolean expectedHasNextStream() { return true; } // default: there is a next video\n+\n+    @Test\n+    @Override\n+    public void testStreamType() throws Exception {\n+        assertEquals(expectedStreamType(), extractor().getStreamType());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderName() throws Exception {\n+        assertEquals(expectedUploaderName(), extractor().getUploaderName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderUrl() throws Exception {\n+        final String uploaderUrl = extractor().getUploaderUrl();\n+        assertIsSecureUrl(uploaderUrl);\n+        assertEquals(expectedUploaderUrl(), uploaderUrl);\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderAvatarUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getUploaderAvatarUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testThumbnailUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getThumbnailUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDescription() throws Exception {\n+        final Description description = extractor().getDescription();\n+        assertNotNull(description);\n+        assertFalse(\"description is empty\", description.getContent().isEmpty());\n+\n+        for (String s : expectedDescriptionContains()) {\n+            assertThat(description.getContent(), containsString(s));\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLength() throws Exception {\n+        assertEquals(expectedLength(), extractor().getLength());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTimestamp() throws Exception {\n+        assertEquals(expectedTimestamp(), extractor().getTimeStamp());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testViewCount() throws Exception {\n+        assertAtLeast(expectedViewCountAtLeast(), extractor().getViewCount());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploadDate() throws Exception {\n+        final DateWrapper dateWrapper = extractor().getUploadDate();\n+\n+        if (expectedUploadDate() == null) {\n+            assertNull(dateWrapper);\n+        } else {\n+            assertNotNull(dateWrapper);\n+\n+            final Calendar expectedDate = Calendar.getInstance();\n+            final Calendar actualDate = dateWrapper.date();\n+            expectedDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            actualDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+\n+            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n+            expectedDate.setTime(sdf.parse(expectedUploadDate()));\n+            assertEquals(expectedDate, actualDate);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTextualUploadDate() throws Exception {\n+        assertEquals(expectedTextualUploadDate(), extractor().getTextualUploadDate());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLikeCount() throws Exception {\n+        if (expectedLikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getLikeCount());\n+        } else {\n+            assertAtLeast(expectedLikeCountAtLeast(), extractor().getLikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDislikeCount() throws Exception {\n+        if (expectedDislikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getDislikeCount());\n+        } else {\n+            assertAtLeast(expectedDislikeCountAtLeast(), extractor().getDislikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testRelatedStreams() throws Exception {\n+        final StreamInfoItemsCollector relatedStreams = extractor().getRelatedStreams();\n+\n+        if (expectedHasRelatedStreams()) {\n+            defaultTestListOfItems(extractor().getService(), relatedStreams.getItems(),\n+                    relatedStreams.getErrors());\n+        } else {\n+            assertNull(relatedStreams);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAgeLimit() throws Exception {\n+        assertEquals(expectedAgeLimit(), extractor().getAgeLimit());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testErrorMessage() throws Exception {\n+        assertEquals(expectedErrorMessage(), extractor().getErrorMessage());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testVideoStreams() throws Exception {\n+        List<VideoStream> videoStreams = extractor().getVideoStreams();\n+        final List<VideoStream> videoOnlyStreams = extractor().getVideoOnlyStreams();\n+        assertNotNull(videoStreams);\n+        assertNotNull(videoOnlyStreams);\n+        videoStreams.addAll(videoOnlyStreams);\n+\n+        if (expectedHasVideoStreams()) {\n+            assertFalse(videoStreams.isEmpty());\n+\n+            for (VideoStream stream : videoStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+                assertFalse(stream.getResolution().isEmpty());\n+\n+                int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit a video stream: \" + formatId,\n+                        0 <= formatId && formatId < 0x100);\n+            }\n+        } else {\n+            assertTrue(videoStreams.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAudioStreams() throws Exception {\n+        final List<AudioStream> audioStreams = extractor().getAudioStreams();\n+        assertNotNull(audioStreams);\n+\n+        if (expectedHasAudioStreams()) {\n+            assertFalse(audioStreams.isEmpty());\n+\n+            for (AudioStream stream : audioStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+\n+                int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit an audio stream: \" + formatId,\n+                        0x100 <= formatId && formatId < 0x1000);\n+            }\n+        } else {\n+            assertTrue(audioStreams.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testSubtitles() throws Exception {\n+        List<SubtitlesStream> subtitles = extractor().getSubtitlesDefault();\n+        assertNotNull(subtitles);\n+\n+        if (expectedHasSubtitles()) {\n+            assertFalse(subtitles.isEmpty());\n+\n+            for (SubtitlesStream stream : subtitles) {\n+                assertIsSecureUrl(stream.getUrl());\n+\n+                int formatId = stream.getFormatId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ace2b0dc97db6df467f41a74219776304dac6f"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzAzNTY5OnYy", "diffSide": "RIGHT", "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0MjoyNlrOGVYX5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0MjoyNlrOGVYX5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MjYxNA==", "bodyText": "final", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r425072614", "createdAt": "2020-05-14T11:42:26Z", "author": {"login": "wb9688"}, "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+package org.schabi.newpipe.extractor.services;\n+\n+import org.junit.Test;\n+import org.schabi.newpipe.extractor.MediaFormat;\n+import org.schabi.newpipe.extractor.localization.DateWrapper;\n+import org.schabi.newpipe.extractor.stream.AudioStream;\n+import org.schabi.newpipe.extractor.stream.Description;\n+import org.schabi.newpipe.extractor.stream.Frameset;\n+import org.schabi.newpipe.extractor.stream.StreamExtractor;\n+import org.schabi.newpipe.extractor.stream.StreamInfoItemsCollector;\n+import org.schabi.newpipe.extractor.stream.StreamType;\n+import org.schabi.newpipe.extractor.stream.SubtitlesStream;\n+import org.schabi.newpipe.extractor.stream.VideoStream;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import javax.annotation.Nullable;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertAtLeast;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsSecureUrl;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsValidUrl;\n+import static org.schabi.newpipe.extractor.services.DefaultTests.defaultTestListOfItems;\n+\n+/**\n+ * Test for {@link StreamExtractor}\n+ */\n+public abstract class DefaultStreamExtractorTest extends DefaultExtractorTest<StreamExtractor>\n+        implements BaseStreamExtractorTest {\n+\n+    public abstract StreamType expectedStreamType();\n+    public abstract String expectedUploaderName();\n+    public abstract String expectedUploaderUrl();\n+    public abstract List<String> expectedDescriptionContains(); // e.g. for full links\n+    public abstract long expectedLength();\n+    public long expectedTimestamp() { return 0; }; // default: there is no timestamp\n+    public abstract long expectedViewCountAtLeast();\n+    @Nullable public abstract String expectedUploadDate(); // format: \"yyyy-MM-dd HH:mm:ss.SSS\"\n+    @Nullable public abstract String expectedTextualUploadDate();\n+    public abstract long expectedLikeCountAtLeast(); // return -1 if ratings are disabled\n+    public abstract long expectedDislikeCountAtLeast(); // return -1 if ratings are disabled\n+    public boolean expectedHasRelatedStreams() { return true; } // default: there are related videos\n+    public int expectedAgeLimit() { return StreamExtractor.NO_AGE_LIMIT; } // default: no limit\n+    @Nullable public String expectedErrorMessage() { return null; } // default: no error message\n+    public boolean expectedHasVideoStreams() { return true; } // default: there are video streams\n+    public boolean expectedHasAudioStreams() { return true; } // default: there are audio streams\n+    public boolean expectedHasSubtitles() { return true; } // default: there are subtitles streams\n+    public boolean expectedHasFrames() { return true; } // default: there are frames\n+    public boolean expectedHasNextStream() { return true; } // default: there is a next video\n+\n+    @Test\n+    @Override\n+    public void testStreamType() throws Exception {\n+        assertEquals(expectedStreamType(), extractor().getStreamType());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderName() throws Exception {\n+        assertEquals(expectedUploaderName(), extractor().getUploaderName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderUrl() throws Exception {\n+        final String uploaderUrl = extractor().getUploaderUrl();\n+        assertIsSecureUrl(uploaderUrl);\n+        assertEquals(expectedUploaderUrl(), uploaderUrl);\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderAvatarUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getUploaderAvatarUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testThumbnailUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getThumbnailUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDescription() throws Exception {\n+        final Description description = extractor().getDescription();\n+        assertNotNull(description);\n+        assertFalse(\"description is empty\", description.getContent().isEmpty());\n+\n+        for (String s : expectedDescriptionContains()) {\n+            assertThat(description.getContent(), containsString(s));\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLength() throws Exception {\n+        assertEquals(expectedLength(), extractor().getLength());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTimestamp() throws Exception {\n+        assertEquals(expectedTimestamp(), extractor().getTimeStamp());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testViewCount() throws Exception {\n+        assertAtLeast(expectedViewCountAtLeast(), extractor().getViewCount());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploadDate() throws Exception {\n+        final DateWrapper dateWrapper = extractor().getUploadDate();\n+\n+        if (expectedUploadDate() == null) {\n+            assertNull(dateWrapper);\n+        } else {\n+            assertNotNull(dateWrapper);\n+\n+            final Calendar expectedDate = Calendar.getInstance();\n+            final Calendar actualDate = dateWrapper.date();\n+            expectedDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            actualDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+\n+            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n+            expectedDate.setTime(sdf.parse(expectedUploadDate()));\n+            assertEquals(expectedDate, actualDate);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTextualUploadDate() throws Exception {\n+        assertEquals(expectedTextualUploadDate(), extractor().getTextualUploadDate());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLikeCount() throws Exception {\n+        if (expectedLikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getLikeCount());\n+        } else {\n+            assertAtLeast(expectedLikeCountAtLeast(), extractor().getLikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDislikeCount() throws Exception {\n+        if (expectedDislikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getDislikeCount());\n+        } else {\n+            assertAtLeast(expectedDislikeCountAtLeast(), extractor().getDislikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testRelatedStreams() throws Exception {\n+        final StreamInfoItemsCollector relatedStreams = extractor().getRelatedStreams();\n+\n+        if (expectedHasRelatedStreams()) {\n+            defaultTestListOfItems(extractor().getService(), relatedStreams.getItems(),\n+                    relatedStreams.getErrors());\n+        } else {\n+            assertNull(relatedStreams);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAgeLimit() throws Exception {\n+        assertEquals(expectedAgeLimit(), extractor().getAgeLimit());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testErrorMessage() throws Exception {\n+        assertEquals(expectedErrorMessage(), extractor().getErrorMessage());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testVideoStreams() throws Exception {\n+        List<VideoStream> videoStreams = extractor().getVideoStreams();\n+        final List<VideoStream> videoOnlyStreams = extractor().getVideoOnlyStreams();\n+        assertNotNull(videoStreams);\n+        assertNotNull(videoOnlyStreams);\n+        videoStreams.addAll(videoOnlyStreams);\n+\n+        if (expectedHasVideoStreams()) {\n+            assertFalse(videoStreams.isEmpty());\n+\n+            for (VideoStream stream : videoStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+                assertFalse(stream.getResolution().isEmpty());\n+\n+                int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit a video stream: \" + formatId,\n+                        0 <= formatId && formatId < 0x100);\n+            }\n+        } else {\n+            assertTrue(videoStreams.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAudioStreams() throws Exception {\n+        final List<AudioStream> audioStreams = extractor().getAudioStreams();\n+        assertNotNull(audioStreams);\n+\n+        if (expectedHasAudioStreams()) {\n+            assertFalse(audioStreams.isEmpty());\n+\n+            for (AudioStream stream : audioStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+\n+                int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit an audio stream: \" + formatId,\n+                        0x100 <= formatId && formatId < 0x1000);\n+            }\n+        } else {\n+            assertTrue(audioStreams.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testSubtitles() throws Exception {\n+        List<SubtitlesStream> subtitles = extractor().getSubtitlesDefault();\n+        assertNotNull(subtitles);\n+\n+        if (expectedHasSubtitles()) {\n+            assertFalse(subtitles.isEmpty());\n+\n+            for (SubtitlesStream stream : subtitles) {\n+                assertIsSecureUrl(stream.getUrl());\n+\n+                int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit an audio stream: \" + formatId,\n+                        0x1000 <= formatId && formatId < 0x10000);\n+            }\n+        } else {\n+            assertTrue(subtitles.isEmpty());\n+\n+            MediaFormat[] formats = {MediaFormat.VTT, MediaFormat.TTML, MediaFormat.TRANSCRIPT1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ace2b0dc97db6df467f41a74219776304dac6f"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzA0MDgzOnYy", "diffSide": "RIGHT", "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0Mzo1OFrOGVYbDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo0Mzo1OFrOGVYbDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MzQyMA==", "bodyText": "Make this a variable that's declared here, because this is imho unclear", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r425073420", "createdAt": "2020-05-14T11:43:58Z", "author": {"login": "wb9688"}, "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+package org.schabi.newpipe.extractor.services;\n+\n+import org.junit.Test;\n+import org.schabi.newpipe.extractor.MediaFormat;\n+import org.schabi.newpipe.extractor.localization.DateWrapper;\n+import org.schabi.newpipe.extractor.stream.AudioStream;\n+import org.schabi.newpipe.extractor.stream.Description;\n+import org.schabi.newpipe.extractor.stream.Frameset;\n+import org.schabi.newpipe.extractor.stream.StreamExtractor;\n+import org.schabi.newpipe.extractor.stream.StreamInfoItemsCollector;\n+import org.schabi.newpipe.extractor.stream.StreamType;\n+import org.schabi.newpipe.extractor.stream.SubtitlesStream;\n+import org.schabi.newpipe.extractor.stream.VideoStream;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+\n+import javax.annotation.Nullable;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertAtLeast;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsSecureUrl;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsValidUrl;\n+import static org.schabi.newpipe.extractor.services.DefaultTests.defaultTestListOfItems;\n+\n+/**\n+ * Test for {@link StreamExtractor}\n+ */\n+public abstract class DefaultStreamExtractorTest extends DefaultExtractorTest<StreamExtractor>\n+        implements BaseStreamExtractorTest {\n+\n+    public abstract StreamType expectedStreamType();\n+    public abstract String expectedUploaderName();\n+    public abstract String expectedUploaderUrl();\n+    public abstract List<String> expectedDescriptionContains(); // e.g. for full links\n+    public abstract long expectedLength();\n+    public long expectedTimestamp() { return 0; }; // default: there is no timestamp\n+    public abstract long expectedViewCountAtLeast();\n+    @Nullable public abstract String expectedUploadDate(); // format: \"yyyy-MM-dd HH:mm:ss.SSS\"\n+    @Nullable public abstract String expectedTextualUploadDate();\n+    public abstract long expectedLikeCountAtLeast(); // return -1 if ratings are disabled\n+    public abstract long expectedDislikeCountAtLeast(); // return -1 if ratings are disabled\n+    public boolean expectedHasRelatedStreams() { return true; } // default: there are related videos\n+    public int expectedAgeLimit() { return StreamExtractor.NO_AGE_LIMIT; } // default: no limit\n+    @Nullable public String expectedErrorMessage() { return null; } // default: no error message\n+    public boolean expectedHasVideoStreams() { return true; } // default: there are video streams\n+    public boolean expectedHasAudioStreams() { return true; } // default: there are audio streams\n+    public boolean expectedHasSubtitles() { return true; } // default: there are subtitles streams\n+    public boolean expectedHasFrames() { return true; } // default: there are frames\n+    public boolean expectedHasNextStream() { return true; } // default: there is a next video\n+\n+    @Test\n+    @Override\n+    public void testStreamType() throws Exception {\n+        assertEquals(expectedStreamType(), extractor().getStreamType());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderName() throws Exception {\n+        assertEquals(expectedUploaderName(), extractor().getUploaderName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderUrl() throws Exception {\n+        final String uploaderUrl = extractor().getUploaderUrl();\n+        assertIsSecureUrl(uploaderUrl);\n+        assertEquals(expectedUploaderUrl(), uploaderUrl);\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderAvatarUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getUploaderAvatarUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testThumbnailUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getThumbnailUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDescription() throws Exception {\n+        final Description description = extractor().getDescription();\n+        assertNotNull(description);\n+        assertFalse(\"description is empty\", description.getContent().isEmpty());\n+\n+        for (String s : expectedDescriptionContains()) {\n+            assertThat(description.getContent(), containsString(s));\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLength() throws Exception {\n+        assertEquals(expectedLength(), extractor().getLength());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTimestamp() throws Exception {\n+        assertEquals(expectedTimestamp(), extractor().getTimeStamp());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testViewCount() throws Exception {\n+        assertAtLeast(expectedViewCountAtLeast(), extractor().getViewCount());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploadDate() throws Exception {\n+        final DateWrapper dateWrapper = extractor().getUploadDate();\n+\n+        if (expectedUploadDate() == null) {\n+            assertNull(dateWrapper);\n+        } else {\n+            assertNotNull(dateWrapper);\n+\n+            final Calendar expectedDate = Calendar.getInstance();\n+            final Calendar actualDate = dateWrapper.date();\n+            expectedDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            actualDate.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+\n+            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n+            expectedDate.setTime(sdf.parse(expectedUploadDate()));\n+            assertEquals(expectedDate, actualDate);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTextualUploadDate() throws Exception {\n+        assertEquals(expectedTextualUploadDate(), extractor().getTextualUploadDate());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLikeCount() throws Exception {\n+        if (expectedLikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getLikeCount());\n+        } else {\n+            assertAtLeast(expectedLikeCountAtLeast(), extractor().getLikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDislikeCount() throws Exception {\n+        if (expectedDislikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getDislikeCount());\n+        } else {\n+            assertAtLeast(expectedDislikeCountAtLeast(), extractor().getDislikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testRelatedStreams() throws Exception {\n+        final StreamInfoItemsCollector relatedStreams = extractor().getRelatedStreams();\n+\n+        if (expectedHasRelatedStreams()) {\n+            defaultTestListOfItems(extractor().getService(), relatedStreams.getItems(),\n+                    relatedStreams.getErrors());\n+        } else {\n+            assertNull(relatedStreams);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAgeLimit() throws Exception {\n+        assertEquals(expectedAgeLimit(), extractor().getAgeLimit());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testErrorMessage() throws Exception {\n+        assertEquals(expectedErrorMessage(), extractor().getErrorMessage());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testVideoStreams() throws Exception {\n+        List<VideoStream> videoStreams = extractor().getVideoStreams();\n+        final List<VideoStream> videoOnlyStreams = extractor().getVideoOnlyStreams();\n+        assertNotNull(videoStreams);\n+        assertNotNull(videoOnlyStreams);\n+        videoStreams.addAll(videoOnlyStreams);\n+\n+        if (expectedHasVideoStreams()) {\n+            assertFalse(videoStreams.isEmpty());\n+\n+            for (VideoStream stream : videoStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+                assertFalse(stream.getResolution().isEmpty());\n+\n+                int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit a video stream: \" + formatId,\n+                        0 <= formatId && formatId < 0x100);\n+            }\n+        } else {\n+            assertTrue(videoStreams.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAudioStreams() throws Exception {\n+        final List<AudioStream> audioStreams = extractor().getAudioStreams();\n+        assertNotNull(audioStreams);\n+\n+        if (expectedHasAudioStreams()) {\n+            assertFalse(audioStreams.isEmpty());\n+\n+            for (AudioStream stream : audioStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+\n+                int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit an audio stream: \" + formatId,\n+                        0x100 <= formatId && formatId < 0x1000);\n+            }\n+        } else {\n+            assertTrue(audioStreams.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testSubtitles() throws Exception {\n+        List<SubtitlesStream> subtitles = extractor().getSubtitlesDefault();\n+        assertNotNull(subtitles);\n+\n+        if (expectedHasSubtitles()) {\n+            assertFalse(subtitles.isEmpty());\n+\n+            for (SubtitlesStream stream : subtitles) {\n+                assertIsSecureUrl(stream.getUrl());\n+\n+                int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit an audio stream: \" + formatId,\n+                        0x1000 <= formatId && formatId < 0x10000);\n+            }\n+        } else {\n+            assertTrue(subtitles.isEmpty());\n+\n+            MediaFormat[] formats = {MediaFormat.VTT, MediaFormat.TTML, MediaFormat.TRANSCRIPT1,\n+                    MediaFormat.TRANSCRIPT2, MediaFormat.TRANSCRIPT3, MediaFormat.SRT};\n+            for (MediaFormat format : formats) {\n+                subtitles = extractor().getSubtitles(format);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ace2b0dc97db6df467f41a74219776304dac6f"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDE5NTgzOnYy", "diffSide": "RIGHT", "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/media_ccc/extractors/MediaCCCParsingHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNjo1MTo0MFrOHny94g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNjo1MTo0MFrOHny94g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5MTU1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n          \n          \n            \n                        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r511491554", "createdAt": "2020-10-24T16:51:40Z", "author": {"login": "TobiGr"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/media_ccc/extractors/MediaCCCParsingHelper.java", "diffHunk": "@@ -6,14 +6,17 @@\n import java.text.SimpleDateFormat;\n import java.util.Calendar;\n import java.util.Date;\n+import java.util.TimeZone;\n \n public final class MediaCCCParsingHelper {\n     private MediaCCCParsingHelper() { }\n \n     public static Calendar parseDateFrom(final String textualUploadDate) throws ParsingException {\n         Date date;\n         try {\n-            date = new SimpleDateFormat(\"yyyy-MM-dd\").parse(textualUploadDate);\n+            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11fe87688beb27a051608c4f0facb2d8214b6d1"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDIxMjg0OnYy", "diffSide": "RIGHT", "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/youtube/YoutubeParsingHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNzoxNDozMVrOHnzGKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNzoxNDozMVrOHnzGKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5MzY3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n          \n          \n            \n                        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r511493672", "createdAt": "2020-10-24T17:14:31Z", "author": {"login": "TobiGr"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/youtube/YoutubeParsingHelper.java", "diffHunk": "@@ -185,7 +185,9 @@ public static String getFeedUrlFrom(final String channelIdOrUser) {\n     public static Calendar parseDateFrom(String textualUploadDate) throws ParsingException {\n         Date date;\n         try {\n-            date = new SimpleDateFormat(\"yyyy-MM-dd\").parse(textualUploadDate);\n+            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f11fe87688beb27a051608c4f0facb2d8214b6d1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDMxNDk4OnYy", "diffSide": "RIGHT", "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/media_ccc/extractors/MediaCCCStreamExtractor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxOToyODowNlrOHnz2aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwNzowNzowM1rOHn29wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwNjAyNA==", "bodyText": "Did you test against NewPipe this part? Will it create NullPointerException or there is already a null check?", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r511506024", "createdAt": "2020-10-24T19:28:06Z", "author": {"login": "B0pol"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/media_ccc/extractors/MediaCCCStreamExtractor.java", "diffHunk": "@@ -216,7 +219,7 @@ public StreamType getStreamType() {\n \n     @Override\n     public StreamInfoItemsCollector getRelatedStreams() {\n-        return new StreamInfoItemsCollector(getServiceId());\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d007fb31dead50952899a87ed7facb590c18b829"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU1NjYyNQ==", "bodyText": "This was done as per the documentation in the base getRelatedStreams(), and also to prevent creating new objects at random. I tested in NewPipe and it works as expected (there are null checks), but the code which takes care of it being null actually lies in the extractor, where the collector is turned into a list. I now added @nullable to all of the functions, as it was missing.", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r511556625", "createdAt": "2020-10-25T07:02:12Z", "author": {"login": "Stypox"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/media_ccc/extractors/MediaCCCStreamExtractor.java", "diffHunk": "@@ -216,7 +219,7 @@ public StreamType getStreamType() {\n \n     @Override\n     public StreamInfoItemsCollector getRelatedStreams() {\n-        return new StreamInfoItemsCollector(getServiceId());\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwNjAyNA=="}, "originalCommit": {"oid": "d007fb31dead50952899a87ed7facb590c18b829"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU1NzA1OA==", "bodyText": "Oh, and also, YouTube already returns null for age restricted videos.", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r511557058", "createdAt": "2020-10-25T07:07:03Z", "author": {"login": "Stypox"}, "path": "extractor/src/main/java/org/schabi/newpipe/extractor/services/media_ccc/extractors/MediaCCCStreamExtractor.java", "diffHunk": "@@ -216,7 +219,7 @@ public StreamType getStreamType() {\n \n     @Override\n     public StreamInfoItemsCollector getRelatedStreams() {\n-        return new StreamInfoItemsCollector(getServiceId());\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwNjAyNA=="}, "originalCommit": {"oid": "d007fb31dead50952899a87ed7facb590c18b829"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDM0NjY1OnYy", "diffSide": "RIGHT", "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMDoxMDo1NFrOHn0FGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwNzowMjoyMVrOHn28Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwOTc4NA==", "bodyText": "Could you explain why 0x100 <= formatId < 0x1000 and also above (video streams) or below (subtitles) and add comments for it?", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r511509784", "createdAt": "2020-10-24T20:10:54Z", "author": {"login": "B0pol"}, "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package org.schabi.newpipe.extractor.services;\n+\n+import org.junit.Test;\n+import org.schabi.newpipe.extractor.MediaFormat;\n+import org.schabi.newpipe.extractor.localization.DateWrapper;\n+import org.schabi.newpipe.extractor.stream.AudioStream;\n+import org.schabi.newpipe.extractor.stream.Description;\n+import org.schabi.newpipe.extractor.stream.Frameset;\n+import org.schabi.newpipe.extractor.stream.StreamExtractor;\n+import org.schabi.newpipe.extractor.stream.StreamInfoItemsCollector;\n+import org.schabi.newpipe.extractor.stream.StreamType;\n+import org.schabi.newpipe.extractor.stream.SubtitlesStream;\n+import org.schabi.newpipe.extractor.stream.VideoStream;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import javax.annotation.Nullable;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertAtLeast;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertEqualsOrderIndependent;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsSecureUrl;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsValidUrl;\n+import static org.schabi.newpipe.extractor.services.DefaultTests.defaultTestListOfItems;\n+\n+/**\n+ * Test for {@link StreamExtractor}\n+ */\n+public abstract class DefaultStreamExtractorTest extends DefaultExtractorTest<StreamExtractor>\n+        implements BaseStreamExtractorTest {\n+\n+    public abstract StreamType expectedStreamType();\n+    public abstract String expectedUploaderName();\n+    public abstract String expectedUploaderUrl();\n+    public String expectedSubChannelName() { return \"\"; } // default: there is no subchannel\n+    public String expectedSubChannelUrl() { return \"\"; } // default: there is no subchannel\n+    public abstract List<String> expectedDescriptionContains(); // e.g. for full links\n+    public abstract long expectedLength();\n+    public long expectedTimestamp() { return 0; } // default: there is no timestamp\n+    public abstract long expectedViewCountAtLeast();\n+    @Nullable public abstract String expectedUploadDate(); // format: \"yyyy-MM-dd HH:mm:ss.SSS\"\n+    @Nullable public abstract String expectedTextualUploadDate();\n+    public abstract long expectedLikeCountAtLeast(); // return -1 if ratings are disabled\n+    public abstract long expectedDislikeCountAtLeast(); // return -1 if ratings are disabled\n+    public boolean expectedHasRelatedStreams() { return true; } // default: there are related videos\n+    public int expectedAgeLimit() { return StreamExtractor.NO_AGE_LIMIT; } // default: no limit\n+    @Nullable public String expectedErrorMessage() { return null; } // default: no error message\n+    public boolean expectedHasVideoStreams() { return true; } // default: there are video streams\n+    public boolean expectedHasAudioStreams() { return true; } // default: there are audio streams\n+    public boolean expectedHasSubtitles() { return true; } // default: there are subtitles streams\n+    @Nullable public String expectedDashMpdUrlContains() { return null; } // default: no dash mpd\n+    public boolean expectedHasFrames() { return true; } // default: there are frames\n+    public String expectedHost() { return \"\"; } // default: no host for centralized platforms\n+    public String expectedPrivacy() { return \"\"; } // default: no privacy policy available\n+    public String expectedCategory() { return \"\"; } // default: no category\n+    public String expectedLicence() { return \"\"; } // default: no licence\n+    public Locale expectedLanguageInfo() { return null; } // default: no language info available\n+    public List<String> expectedTags() { return Collections.emptyList(); } // default: no tags\n+    public String expectedSupportInfo() { return \"\"; } // default: no support info available\n+\n+    @Test\n+    @Override\n+    public void testStreamType() throws Exception {\n+        assertEquals(expectedStreamType(), extractor().getStreamType());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderName() throws Exception {\n+        assertEquals(expectedUploaderName(), extractor().getUploaderName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderUrl() throws Exception {\n+        final String uploaderUrl = extractor().getUploaderUrl();\n+        assertIsSecureUrl(uploaderUrl);\n+        assertEquals(expectedUploaderUrl(), uploaderUrl);\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderAvatarUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getUploaderAvatarUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testSubChannelName() throws Exception {\n+        assertEquals(expectedSubChannelName(), extractor().getSubChannelName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testSubChannelUrl() throws Exception {\n+        final String subChannelUrl = extractor().getSubChannelUrl();\n+        assertEquals(expectedSubChannelUrl(), subChannelUrl);\n+\n+        if (!expectedSubChannelUrl().isEmpty()) {\n+            // this stream has a subchannel\n+            assertIsSecureUrl(subChannelUrl);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testSubChannelAvatarUrl() throws Exception {\n+        if (expectedSubChannelName().isEmpty() && expectedSubChannelUrl().isEmpty()) {\n+            // this stream has no subchannel\n+            assertEquals(\"\", extractor().getSubChannelAvatarUrl());\n+        } else {\n+            // this stream has a subchannel\n+            assertIsSecureUrl(extractor().getSubChannelAvatarUrl());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testThumbnailUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getThumbnailUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDescription() throws Exception {\n+        final Description description = extractor().getDescription();\n+        assertNotNull(description);\n+        assertFalse(\"description is empty\", description.getContent().isEmpty());\n+\n+        for (final String s : expectedDescriptionContains()) {\n+            assertThat(description.getContent(), containsString(s));\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLength() throws Exception {\n+        assertEquals(expectedLength(), extractor().getLength());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTimestamp() throws Exception {\n+        assertEquals(expectedTimestamp(), extractor().getTimeStamp());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testViewCount() throws Exception {\n+        assertAtLeast(expectedViewCountAtLeast(), extractor().getViewCount());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploadDate() throws Exception {\n+        final DateWrapper dateWrapper = extractor().getUploadDate();\n+\n+        if (expectedUploadDate() == null) {\n+            assertNull(dateWrapper);\n+        } else {\n+            assertNotNull(dateWrapper);\n+\n+            final Calendar expectedDate = Calendar.getInstance();\n+            final Calendar actualDate = dateWrapper.date();\n+\n+            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n+            sdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            expectedDate.setTime(sdf.parse(expectedUploadDate()));\n+            assertEquals(expectedDate, actualDate);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTextualUploadDate() throws Exception {\n+        assertEquals(expectedTextualUploadDate(), extractor().getTextualUploadDate());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLikeCount() throws Exception {\n+        if (expectedLikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getLikeCount());\n+        } else {\n+            assertAtLeast(expectedLikeCountAtLeast(), extractor().getLikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDislikeCount() throws Exception {\n+        if (expectedDislikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getDislikeCount());\n+        } else {\n+            assertAtLeast(expectedDislikeCountAtLeast(), extractor().getDislikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testRelatedStreams() throws Exception {\n+        final StreamInfoItemsCollector relatedStreams = extractor().getRelatedStreams();\n+\n+        if (expectedHasRelatedStreams()) {\n+            defaultTestListOfItems(extractor().getService(), relatedStreams.getItems(),\n+                    relatedStreams.getErrors());\n+        } else {\n+            assertNull(relatedStreams);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAgeLimit() throws Exception {\n+        assertEquals(expectedAgeLimit(), extractor().getAgeLimit());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testErrorMessage() throws Exception {\n+        assertEquals(expectedErrorMessage(), extractor().getErrorMessage());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testVideoStreams() throws Exception {\n+        final List<VideoStream> videoStreams = extractor().getVideoStreams();\n+        final List<VideoStream> videoOnlyStreams = extractor().getVideoOnlyStreams();\n+        assertNotNull(videoStreams);\n+        assertNotNull(videoOnlyStreams);\n+        videoStreams.addAll(videoOnlyStreams);\n+\n+        if (expectedHasVideoStreams()) {\n+            assertFalse(videoStreams.isEmpty());\n+\n+            for (final VideoStream stream : videoStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+                assertFalse(stream.getResolution().isEmpty());\n+\n+                final int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit a video stream: \" + formatId,\n+                        0 <= formatId && formatId < 0x100);\n+            }\n+        } else {\n+            assertTrue(videoStreams.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAudioStreams() throws Exception {\n+        final List<AudioStream> audioStreams = extractor().getAudioStreams();\n+        assertNotNull(audioStreams);\n+\n+        if (expectedHasAudioStreams()) {\n+            assertFalse(audioStreams.isEmpty());\n+\n+            for (final AudioStream stream : audioStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+\n+                final int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit an audio stream: \" + formatId,\n+                        0x100 <= formatId && formatId < 0x1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d007fb31dead50952899a87ed7facb590c18b829"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU1NjY0Mw==", "bodyText": "Ok", "url": "https://github.com/TeamNewPipe/NewPipeExtractor/pull/309#discussion_r511556643", "createdAt": "2020-10-25T07:02:21Z", "author": {"login": "Stypox"}, "path": "extractor/src/test/java/org/schabi/newpipe/extractor/services/DefaultStreamExtractorTest.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package org.schabi.newpipe.extractor.services;\n+\n+import org.junit.Test;\n+import org.schabi.newpipe.extractor.MediaFormat;\n+import org.schabi.newpipe.extractor.localization.DateWrapper;\n+import org.schabi.newpipe.extractor.stream.AudioStream;\n+import org.schabi.newpipe.extractor.stream.Description;\n+import org.schabi.newpipe.extractor.stream.Frameset;\n+import org.schabi.newpipe.extractor.stream.StreamExtractor;\n+import org.schabi.newpipe.extractor.stream.StreamInfoItemsCollector;\n+import org.schabi.newpipe.extractor.stream.StreamType;\n+import org.schabi.newpipe.extractor.stream.SubtitlesStream;\n+import org.schabi.newpipe.extractor.stream.VideoStream;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import javax.annotation.Nullable;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertAtLeast;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertEqualsOrderIndependent;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsSecureUrl;\n+import static org.schabi.newpipe.extractor.ExtractorAsserts.assertIsValidUrl;\n+import static org.schabi.newpipe.extractor.services.DefaultTests.defaultTestListOfItems;\n+\n+/**\n+ * Test for {@link StreamExtractor}\n+ */\n+public abstract class DefaultStreamExtractorTest extends DefaultExtractorTest<StreamExtractor>\n+        implements BaseStreamExtractorTest {\n+\n+    public abstract StreamType expectedStreamType();\n+    public abstract String expectedUploaderName();\n+    public abstract String expectedUploaderUrl();\n+    public String expectedSubChannelName() { return \"\"; } // default: there is no subchannel\n+    public String expectedSubChannelUrl() { return \"\"; } // default: there is no subchannel\n+    public abstract List<String> expectedDescriptionContains(); // e.g. for full links\n+    public abstract long expectedLength();\n+    public long expectedTimestamp() { return 0; } // default: there is no timestamp\n+    public abstract long expectedViewCountAtLeast();\n+    @Nullable public abstract String expectedUploadDate(); // format: \"yyyy-MM-dd HH:mm:ss.SSS\"\n+    @Nullable public abstract String expectedTextualUploadDate();\n+    public abstract long expectedLikeCountAtLeast(); // return -1 if ratings are disabled\n+    public abstract long expectedDislikeCountAtLeast(); // return -1 if ratings are disabled\n+    public boolean expectedHasRelatedStreams() { return true; } // default: there are related videos\n+    public int expectedAgeLimit() { return StreamExtractor.NO_AGE_LIMIT; } // default: no limit\n+    @Nullable public String expectedErrorMessage() { return null; } // default: no error message\n+    public boolean expectedHasVideoStreams() { return true; } // default: there are video streams\n+    public boolean expectedHasAudioStreams() { return true; } // default: there are audio streams\n+    public boolean expectedHasSubtitles() { return true; } // default: there are subtitles streams\n+    @Nullable public String expectedDashMpdUrlContains() { return null; } // default: no dash mpd\n+    public boolean expectedHasFrames() { return true; } // default: there are frames\n+    public String expectedHost() { return \"\"; } // default: no host for centralized platforms\n+    public String expectedPrivacy() { return \"\"; } // default: no privacy policy available\n+    public String expectedCategory() { return \"\"; } // default: no category\n+    public String expectedLicence() { return \"\"; } // default: no licence\n+    public Locale expectedLanguageInfo() { return null; } // default: no language info available\n+    public List<String> expectedTags() { return Collections.emptyList(); } // default: no tags\n+    public String expectedSupportInfo() { return \"\"; } // default: no support info available\n+\n+    @Test\n+    @Override\n+    public void testStreamType() throws Exception {\n+        assertEquals(expectedStreamType(), extractor().getStreamType());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderName() throws Exception {\n+        assertEquals(expectedUploaderName(), extractor().getUploaderName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderUrl() throws Exception {\n+        final String uploaderUrl = extractor().getUploaderUrl();\n+        assertIsSecureUrl(uploaderUrl);\n+        assertEquals(expectedUploaderUrl(), uploaderUrl);\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploaderAvatarUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getUploaderAvatarUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testSubChannelName() throws Exception {\n+        assertEquals(expectedSubChannelName(), extractor().getSubChannelName());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testSubChannelUrl() throws Exception {\n+        final String subChannelUrl = extractor().getSubChannelUrl();\n+        assertEquals(expectedSubChannelUrl(), subChannelUrl);\n+\n+        if (!expectedSubChannelUrl().isEmpty()) {\n+            // this stream has a subchannel\n+            assertIsSecureUrl(subChannelUrl);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testSubChannelAvatarUrl() throws Exception {\n+        if (expectedSubChannelName().isEmpty() && expectedSubChannelUrl().isEmpty()) {\n+            // this stream has no subchannel\n+            assertEquals(\"\", extractor().getSubChannelAvatarUrl());\n+        } else {\n+            // this stream has a subchannel\n+            assertIsSecureUrl(extractor().getSubChannelAvatarUrl());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testThumbnailUrl() throws Exception {\n+        assertIsSecureUrl(extractor().getThumbnailUrl());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDescription() throws Exception {\n+        final Description description = extractor().getDescription();\n+        assertNotNull(description);\n+        assertFalse(\"description is empty\", description.getContent().isEmpty());\n+\n+        for (final String s : expectedDescriptionContains()) {\n+            assertThat(description.getContent(), containsString(s));\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLength() throws Exception {\n+        assertEquals(expectedLength(), extractor().getLength());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTimestamp() throws Exception {\n+        assertEquals(expectedTimestamp(), extractor().getTimeStamp());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testViewCount() throws Exception {\n+        assertAtLeast(expectedViewCountAtLeast(), extractor().getViewCount());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testUploadDate() throws Exception {\n+        final DateWrapper dateWrapper = extractor().getUploadDate();\n+\n+        if (expectedUploadDate() == null) {\n+            assertNull(dateWrapper);\n+        } else {\n+            assertNotNull(dateWrapper);\n+\n+            final Calendar expectedDate = Calendar.getInstance();\n+            final Calendar actualDate = dateWrapper.date();\n+\n+            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n+            sdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            expectedDate.setTime(sdf.parse(expectedUploadDate()));\n+            assertEquals(expectedDate, actualDate);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testTextualUploadDate() throws Exception {\n+        assertEquals(expectedTextualUploadDate(), extractor().getTextualUploadDate());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testLikeCount() throws Exception {\n+        if (expectedLikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getLikeCount());\n+        } else {\n+            assertAtLeast(expectedLikeCountAtLeast(), extractor().getLikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testDislikeCount() throws Exception {\n+        if (expectedDislikeCountAtLeast() == -1) {\n+            assertEquals(-1, extractor().getDislikeCount());\n+        } else {\n+            assertAtLeast(expectedDislikeCountAtLeast(), extractor().getDislikeCount());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testRelatedStreams() throws Exception {\n+        final StreamInfoItemsCollector relatedStreams = extractor().getRelatedStreams();\n+\n+        if (expectedHasRelatedStreams()) {\n+            defaultTestListOfItems(extractor().getService(), relatedStreams.getItems(),\n+                    relatedStreams.getErrors());\n+        } else {\n+            assertNull(relatedStreams);\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAgeLimit() throws Exception {\n+        assertEquals(expectedAgeLimit(), extractor().getAgeLimit());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testErrorMessage() throws Exception {\n+        assertEquals(expectedErrorMessage(), extractor().getErrorMessage());\n+    }\n+\n+    @Test\n+    @Override\n+    public void testVideoStreams() throws Exception {\n+        final List<VideoStream> videoStreams = extractor().getVideoStreams();\n+        final List<VideoStream> videoOnlyStreams = extractor().getVideoOnlyStreams();\n+        assertNotNull(videoStreams);\n+        assertNotNull(videoOnlyStreams);\n+        videoStreams.addAll(videoOnlyStreams);\n+\n+        if (expectedHasVideoStreams()) {\n+            assertFalse(videoStreams.isEmpty());\n+\n+            for (final VideoStream stream : videoStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+                assertFalse(stream.getResolution().isEmpty());\n+\n+                final int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit a video stream: \" + formatId,\n+                        0 <= formatId && formatId < 0x100);\n+            }\n+        } else {\n+            assertTrue(videoStreams.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    @Override\n+    public void testAudioStreams() throws Exception {\n+        final List<AudioStream> audioStreams = extractor().getAudioStreams();\n+        assertNotNull(audioStreams);\n+\n+        if (expectedHasAudioStreams()) {\n+            assertFalse(audioStreams.isEmpty());\n+\n+            for (final AudioStream stream : audioStreams) {\n+                assertIsSecureUrl(stream.getUrl());\n+\n+                final int formatId = stream.getFormatId();\n+                assertTrue(\"format id does not fit an audio stream: \" + formatId,\n+                        0x100 <= formatId && formatId < 0x1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwOTc4NA=="}, "originalCommit": {"oid": "d007fb31dead50952899a87ed7facb590c18b829"}, "originalPosition": 274}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2897, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}