{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxMTU4ODY5", "number": 713, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo1MToyM1rOD-sSGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjozODo0M1rOEA9gvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDYzODMyOnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo1MToyM1rOGY8w1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjowODo0MFrOGZrmhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNDU1MA==", "bodyText": "nothing wrong with what you have done. But can you consider the alternative ,as well, used in other classes?\nString prefix = CLASS_NAME + MetricsAware.KEY_REGEX; instead of module ? This is how other classes have handled this scenario.", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r428814550", "createdAt": "2020-05-21T17:51:23Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -1769,7 +1769,7 @@ private void registerMeter(Meter metric) {\n     private void registerKeyedMeter(KeyedMeter metric) {\n       String metricName = metric.getName();\n       _dynamicMetricsManager.registerMetric(MODULE, metric.getKey(), metricName, com.codahale.metrics.Meter.class);\n-      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metric.getKey(), metricName)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9d858871beed74f2583c20269b99f61a57e816b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MTk1OA==", "bodyText": "Thank you so much for bringing this to my attention.\nThis question led me to have a conversation with Celia (the feature author) about how metrics work and when regex-based BrooklinMetricInfo objects should be used. It turns out there are quite a few interesting details that got me to revisit the way some of the Coordinator metrics are registered/created. I'll put together a short writeup to summarize the key aspects and best practices.\nAs far as this code change is concerned, here are the adjustments I made:\n\nAll KeyedMeter objects have been changed to be lazily created. This involves:\n\nCreating them lazily using DynamicMetricsManager.createOrUpdate*()  as opposed to DynamicMetricsManager.register*())\nAdding regex-based BrooklinMetricInfo objects for them as you suggested\n\n\nMoving the metric below to be a Meter instead of a KeyedMeter since it doesn't follow the same naming pattern\nPERFORM_CLEANUP_ORPHAN_CONNECTOR_TASKS(\"performCleanupOrphanConnectorTasks\", \"numOrphanConnectorTasks\"),", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r429581958", "createdAt": "2020-05-23T22:08:40Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -1769,7 +1769,7 @@ private void registerMeter(Meter metric) {\n     private void registerKeyedMeter(KeyedMeter metric) {\n       String metricName = metric.getName();\n       _dynamicMetricsManager.registerMetric(MODULE, metric.getKey(), metricName, com.codahale.metrics.Meter.class);\n-      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metric.getKey(), metricName)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNDU1MA=="}, "originalCommit": {"oid": "b9d858871beed74f2583c20269b99f61a57e816b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDY0Mjk2OnYy", "diffSide": "RIGHT", "path": "datastream-server-restli/src/test/java/com/linkedin/datastream/server/TestCoordinator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo1Mjo0OVrOGY8z2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMTo1NTo0NFrOGZrjrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNTMyMg==", "bodyText": "any particular reason to name variable actualMetricClazz and not actualMetricClass", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r428815322", "createdAt": "2020-05-21T17:52:49Z", "author": {"login": "vmaheshw"}, "path": "datastream-server-restli/src/test/java/com/linkedin/datastream/server/TestCoordinator.java", "diffHunk": "@@ -174,6 +183,54 @@ public void teardown() throws IOException {\n     _embeddedZookeeper.shutdown();\n   }\n \n+  @Test\n+  public void testRegistersMetricsCorrectly() throws Exception {\n+    String testCluster = \"testCoordinatorMetrics\";\n+    Coordinator coordinator = createCoordinator(_zkConnectionString, testCluster);\n+    coordinator.start();\n+\n+    // Make sure the set of metrics the Coordinator registers with the DynamicMetricsManager\n+    // matches the metricInfos the Coordinator returns from getMetricInfos().\n+    List<BrooklinMetricInfo> metricInfos = coordinator.getMetricInfos();\n+    DynamicMetricsManager metricsManager = DynamicMetricsManager.getInstance();\n+\n+    String coordinatorSimpleClassName = Coordinator.class.getSimpleName();\n+    // Keep Coordinator metricInfos\n+    Map<String, BrooklinMetricInfo> metricInfoByName = metricInfos.stream()\n+        .filter(info -> info.getNameOrRegex().startsWith(coordinatorSimpleClassName))\n+        .collect(Collectors.toMap(BrooklinMetricInfo::getNameOrRegex, Function.identity()));\n+\n+    // Keep Coordinator metrics\n+    Map<String, Metric> metrics = metricsManager.getMetricRegistry().getMetrics().entrySet().stream()\n+        .filter(entry -> entry.getKey().startsWith(coordinatorSimpleClassName))\n+        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+    Assert.assertEquals(metricInfoByName.size(), metrics.size());\n+\n+    // Mapping of BrooklinMetricInfo sub-type -> com.codahale.metrics type\n+    Map<Class<? extends BrooklinMetricInfo>, Class<? extends Metric>> metricInfoTypeToMetricType = new HashMap<>();\n+    metricInfoTypeToMetricType.put(BrooklinCounterInfo.class, Counter.class);\n+    metricInfoTypeToMetricType.put(BrooklinGaugeInfo.class, Gauge.class);\n+    metricInfoTypeToMetricType.put(BrooklinHistogramInfo.class, Histogram.class);\n+    metricInfoTypeToMetricType.put(BrooklinMeterInfo.class, Meter.class);\n+\n+    for (Map.Entry<String, BrooklinMetricInfo> entry : metricInfoByName.entrySet()) {\n+      String metricInfoKey = entry.getKey();\n+      BrooklinMetricInfo metricInfo = entry.getValue();\n+\n+      // For every BrooklinMetricInfo, there must be a registered codahale metric\n+      Metric metric = metrics.get(metricInfoKey);\n+      Assert.assertNotNull(metric);\n+\n+      // The registered codahale metric type must correspond to the BrooklinMetricInfo sub-type\n+      Class<? extends Metric> actualMetricClazz = metric.getClass();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9d858871beed74f2583c20269b99f61a57e816b"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNzgzNA==", "bodyText": "Java tradition (sigh): https://stackoverflow.com/questions/2529974/why-do-java-programmers-like-to-name-a-variable-clazz", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r428817834", "createdAt": "2020-05-21T17:57:15Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server-restli/src/test/java/com/linkedin/datastream/server/TestCoordinator.java", "diffHunk": "@@ -174,6 +183,54 @@ public void teardown() throws IOException {\n     _embeddedZookeeper.shutdown();\n   }\n \n+  @Test\n+  public void testRegistersMetricsCorrectly() throws Exception {\n+    String testCluster = \"testCoordinatorMetrics\";\n+    Coordinator coordinator = createCoordinator(_zkConnectionString, testCluster);\n+    coordinator.start();\n+\n+    // Make sure the set of metrics the Coordinator registers with the DynamicMetricsManager\n+    // matches the metricInfos the Coordinator returns from getMetricInfos().\n+    List<BrooklinMetricInfo> metricInfos = coordinator.getMetricInfos();\n+    DynamicMetricsManager metricsManager = DynamicMetricsManager.getInstance();\n+\n+    String coordinatorSimpleClassName = Coordinator.class.getSimpleName();\n+    // Keep Coordinator metricInfos\n+    Map<String, BrooklinMetricInfo> metricInfoByName = metricInfos.stream()\n+        .filter(info -> info.getNameOrRegex().startsWith(coordinatorSimpleClassName))\n+        .collect(Collectors.toMap(BrooklinMetricInfo::getNameOrRegex, Function.identity()));\n+\n+    // Keep Coordinator metrics\n+    Map<String, Metric> metrics = metricsManager.getMetricRegistry().getMetrics().entrySet().stream()\n+        .filter(entry -> entry.getKey().startsWith(coordinatorSimpleClassName))\n+        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+    Assert.assertEquals(metricInfoByName.size(), metrics.size());\n+\n+    // Mapping of BrooklinMetricInfo sub-type -> com.codahale.metrics type\n+    Map<Class<? extends BrooklinMetricInfo>, Class<? extends Metric>> metricInfoTypeToMetricType = new HashMap<>();\n+    metricInfoTypeToMetricType.put(BrooklinCounterInfo.class, Counter.class);\n+    metricInfoTypeToMetricType.put(BrooklinGaugeInfo.class, Gauge.class);\n+    metricInfoTypeToMetricType.put(BrooklinHistogramInfo.class, Histogram.class);\n+    metricInfoTypeToMetricType.put(BrooklinMeterInfo.class, Meter.class);\n+\n+    for (Map.Entry<String, BrooklinMetricInfo> entry : metricInfoByName.entrySet()) {\n+      String metricInfoKey = entry.getKey();\n+      BrooklinMetricInfo metricInfo = entry.getValue();\n+\n+      // For every BrooklinMetricInfo, there must be a registered codahale metric\n+      Metric metric = metrics.get(metricInfoKey);\n+      Assert.assertNotNull(metric);\n+\n+      // The registered codahale metric type must correspond to the BrooklinMetricInfo sub-type\n+      Class<? extends Metric> actualMetricClazz = metric.getClass();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNTMyMg=="}, "originalCommit": {"oid": "b9d858871beed74f2583c20269b99f61a57e816b"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MTIyOQ==", "bodyText": "That code was moved into a dedicated utility for validating metrics. I also changed the code to use Class instead of Clazz since it's not used on its own but as part of a longer identifier.", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r429581229", "createdAt": "2020-05-23T21:55:44Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server-restli/src/test/java/com/linkedin/datastream/server/TestCoordinator.java", "diffHunk": "@@ -174,6 +183,54 @@ public void teardown() throws IOException {\n     _embeddedZookeeper.shutdown();\n   }\n \n+  @Test\n+  public void testRegistersMetricsCorrectly() throws Exception {\n+    String testCluster = \"testCoordinatorMetrics\";\n+    Coordinator coordinator = createCoordinator(_zkConnectionString, testCluster);\n+    coordinator.start();\n+\n+    // Make sure the set of metrics the Coordinator registers with the DynamicMetricsManager\n+    // matches the metricInfos the Coordinator returns from getMetricInfos().\n+    List<BrooklinMetricInfo> metricInfos = coordinator.getMetricInfos();\n+    DynamicMetricsManager metricsManager = DynamicMetricsManager.getInstance();\n+\n+    String coordinatorSimpleClassName = Coordinator.class.getSimpleName();\n+    // Keep Coordinator metricInfos\n+    Map<String, BrooklinMetricInfo> metricInfoByName = metricInfos.stream()\n+        .filter(info -> info.getNameOrRegex().startsWith(coordinatorSimpleClassName))\n+        .collect(Collectors.toMap(BrooklinMetricInfo::getNameOrRegex, Function.identity()));\n+\n+    // Keep Coordinator metrics\n+    Map<String, Metric> metrics = metricsManager.getMetricRegistry().getMetrics().entrySet().stream()\n+        .filter(entry -> entry.getKey().startsWith(coordinatorSimpleClassName))\n+        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+    Assert.assertEquals(metricInfoByName.size(), metrics.size());\n+\n+    // Mapping of BrooklinMetricInfo sub-type -> com.codahale.metrics type\n+    Map<Class<? extends BrooklinMetricInfo>, Class<? extends Metric>> metricInfoTypeToMetricType = new HashMap<>();\n+    metricInfoTypeToMetricType.put(BrooklinCounterInfo.class, Counter.class);\n+    metricInfoTypeToMetricType.put(BrooklinGaugeInfo.class, Gauge.class);\n+    metricInfoTypeToMetricType.put(BrooklinHistogramInfo.class, Histogram.class);\n+    metricInfoTypeToMetricType.put(BrooklinMeterInfo.class, Meter.class);\n+\n+    for (Map.Entry<String, BrooklinMetricInfo> entry : metricInfoByName.entrySet()) {\n+      String metricInfoKey = entry.getKey();\n+      BrooklinMetricInfo metricInfo = entry.getValue();\n+\n+      // For every BrooklinMetricInfo, there must be a registered codahale metric\n+      Metric metric = metrics.get(metricInfoKey);\n+      Assert.assertNotNull(metric);\n+\n+      // The registered codahale metric type must correspond to the BrooklinMetricInfo sub-type\n+      Class<? extends Metric> actualMetricClazz = metric.getClass();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNTMyMg=="}, "originalCommit": {"oid": "b9d858871beed74f2583c20269b99f61a57e816b"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDM3NDUyOnYy", "diffSide": "RIGHT", "path": "datastream-testcommon/src/main/java/com/linkedin/datastream/testutil/MetricsTestUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjoyMDoxMFrOGcjfmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo0NzowOFrOGcma1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU5NDg0MA==", "bodyText": "nit whitespace missing before ':'", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r432594840", "createdAt": "2020-05-29T16:20:10Z", "author": {"login": "vmaheshw"}, "path": "datastream-testcommon/src/main/java/com/linkedin/datastream/testutil/MetricsTestUtils.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ *  Copyright 2020 LinkedIn Corporation. All rights reserved.\n+ *  Licensed under the BSD 2-Clause License. See the LICENSE file in the project root for license information.\n+ *  See the NOTICE file in the project root for additional information regarding copyright ownership.\n+ */\n+package com.linkedin.datastream.testutil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.testng.Assert;\n+\n+import com.codahale.metrics.Counter;\n+import com.codahale.metrics.Gauge;\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Metric;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linkedin.datastream.metrics.BrooklinCounterInfo;\n+import com.linkedin.datastream.metrics.BrooklinGaugeInfo;\n+import com.linkedin.datastream.metrics.BrooklinHistogramInfo;\n+import com.linkedin.datastream.metrics.BrooklinMeterInfo;\n+import com.linkedin.datastream.metrics.BrooklinMetricInfo;\n+import com.linkedin.datastream.metrics.DynamicMetricsManager;\n+import com.linkedin.datastream.metrics.MetricsAware;\n+\n+\n+/**\n+ * Test utilities for verifying metrics\n+ * @see MetricsAware\n+ */\n+public class MetricsTestUtils {\n+  // Mapping of BrooklinMetricInfo sub-types -> com.codahale.metrics types\n+  private static final Map<Class<? extends BrooklinMetricInfo>, Class<? extends Metric>> METRICS_TYPE_MAPPING = ImmutableMap.of(\n+      BrooklinCounterInfo.class, Counter.class,\n+      BrooklinGaugeInfo.class, Gauge.class,\n+      BrooklinHistogramInfo.class, Histogram.class,\n+      BrooklinMeterInfo.class, Meter.class);\n+\n+  private MetricsTestUtils() {\n+  }\n+\n+  /**\n+   * @see #verifyMetrics(MetricsAware, DynamicMetricsManager, Predicate)\n+   *\n+   * This verification only covers {@link Metric} and {@link BrooklinMetricInfo} objects whose\n+   * names start with the provided {@code metricsAware}'s simple class name.\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager) {\n+    verifyMetrics(metricsAware, metricsManager, s -> s.startsWith(metricsAware.getClass().getSimpleName()));\n+  }\n+\n+  /**\n+   * Verifies consistency between:\n+   * <ol>\n+   *   <li>{@link BrooklinMetricInfo} objects returned by the specified {@code metricsAware}\n+   *   (specifically {@link MetricsAware#getMetricInfos()}) after filtering them using {@code metricFilter}</li>\n+   *   <li>{@link Metric} objects registered with the specified {@code metricsManager} after filtering them\n+   *   using {@code metricFilter}</li>\n+   * </ol>\n+   *\n+   * In particular, it verifies that:\n+   * <ul>\n+   *   <li>All {@link BrooklinMetricInfo} are distinct</li>\n+   *   <li>Every {@link Metric} object has exactly one {@link BrooklinMetricInfo} object whose\n+   *   {@link BrooklinMetricInfo#getNameOrRegex()} matches the metric's name</li>\n+   *   <li>Every {@link Metric} is matched with a {@link BrooklinMetricInfo} object whose concrete\n+   *   type matches the metric's type according to {@link MetricsTestUtils#METRICS_TYPE_MAPPING}</li>\n+   * </ul>\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager,\n+      Predicate<String> metricFilter) {\n+\n+    List<BrooklinMetricInfo> metricInfos = metricsAware.getMetricInfos().stream()\n+        .filter(metricInfo -> metricFilter.test(metricInfo.getNameOrRegex()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that all metricInfos are distinct\n+    Assert.assertEquals(metricInfos.size(), metricInfos.stream().distinct().count(),\n+        \"The supplied metricsAware returned duplicate BrooklinMetricInfo objects\");\n+\n+    Map<String, BrooklinMetricInfo> metricInfoByName = new HashMap<>();\n+    List<BrooklinMetricInfo> regexMetricInfos = new ArrayList<>();\n+    classifyMetricInfos(metricInfos, metricInfoByName, regexMetricInfos);\n+\n+    Collection<Map.Entry<String, Metric>> metricEntries = metricsManager.getMetricRegistry().getMetrics().entrySet().stream()\n+        .filter(metricEntry -> metricFilter.test(metricEntry.getKey()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that every metric has exactly one metricInfo whose nameOrRegex matches the metric's name\n+    for (Map.Entry<String, Metric> metricEntry: metricEntries) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43527b61fefdbfa6c82d9a407073e276a520f860"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0Mjc3Mw==", "bodyText": "Fixed. Thanks for the catch.", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r432642773", "createdAt": "2020-05-29T17:47:08Z", "author": {"login": "ahmedahamid"}, "path": "datastream-testcommon/src/main/java/com/linkedin/datastream/testutil/MetricsTestUtils.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ *  Copyright 2020 LinkedIn Corporation. All rights reserved.\n+ *  Licensed under the BSD 2-Clause License. See the LICENSE file in the project root for license information.\n+ *  See the NOTICE file in the project root for additional information regarding copyright ownership.\n+ */\n+package com.linkedin.datastream.testutil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.testng.Assert;\n+\n+import com.codahale.metrics.Counter;\n+import com.codahale.metrics.Gauge;\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Metric;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linkedin.datastream.metrics.BrooklinCounterInfo;\n+import com.linkedin.datastream.metrics.BrooklinGaugeInfo;\n+import com.linkedin.datastream.metrics.BrooklinHistogramInfo;\n+import com.linkedin.datastream.metrics.BrooklinMeterInfo;\n+import com.linkedin.datastream.metrics.BrooklinMetricInfo;\n+import com.linkedin.datastream.metrics.DynamicMetricsManager;\n+import com.linkedin.datastream.metrics.MetricsAware;\n+\n+\n+/**\n+ * Test utilities for verifying metrics\n+ * @see MetricsAware\n+ */\n+public class MetricsTestUtils {\n+  // Mapping of BrooklinMetricInfo sub-types -> com.codahale.metrics types\n+  private static final Map<Class<? extends BrooklinMetricInfo>, Class<? extends Metric>> METRICS_TYPE_MAPPING = ImmutableMap.of(\n+      BrooklinCounterInfo.class, Counter.class,\n+      BrooklinGaugeInfo.class, Gauge.class,\n+      BrooklinHistogramInfo.class, Histogram.class,\n+      BrooklinMeterInfo.class, Meter.class);\n+\n+  private MetricsTestUtils() {\n+  }\n+\n+  /**\n+   * @see #verifyMetrics(MetricsAware, DynamicMetricsManager, Predicate)\n+   *\n+   * This verification only covers {@link Metric} and {@link BrooklinMetricInfo} objects whose\n+   * names start with the provided {@code metricsAware}'s simple class name.\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager) {\n+    verifyMetrics(metricsAware, metricsManager, s -> s.startsWith(metricsAware.getClass().getSimpleName()));\n+  }\n+\n+  /**\n+   * Verifies consistency between:\n+   * <ol>\n+   *   <li>{@link BrooklinMetricInfo} objects returned by the specified {@code metricsAware}\n+   *   (specifically {@link MetricsAware#getMetricInfos()}) after filtering them using {@code metricFilter}</li>\n+   *   <li>{@link Metric} objects registered with the specified {@code metricsManager} after filtering them\n+   *   using {@code metricFilter}</li>\n+   * </ol>\n+   *\n+   * In particular, it verifies that:\n+   * <ul>\n+   *   <li>All {@link BrooklinMetricInfo} are distinct</li>\n+   *   <li>Every {@link Metric} object has exactly one {@link BrooklinMetricInfo} object whose\n+   *   {@link BrooklinMetricInfo#getNameOrRegex()} matches the metric's name</li>\n+   *   <li>Every {@link Metric} is matched with a {@link BrooklinMetricInfo} object whose concrete\n+   *   type matches the metric's type according to {@link MetricsTestUtils#METRICS_TYPE_MAPPING}</li>\n+   * </ul>\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager,\n+      Predicate<String> metricFilter) {\n+\n+    List<BrooklinMetricInfo> metricInfos = metricsAware.getMetricInfos().stream()\n+        .filter(metricInfo -> metricFilter.test(metricInfo.getNameOrRegex()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that all metricInfos are distinct\n+    Assert.assertEquals(metricInfos.size(), metricInfos.stream().distinct().count(),\n+        \"The supplied metricsAware returned duplicate BrooklinMetricInfo objects\");\n+\n+    Map<String, BrooklinMetricInfo> metricInfoByName = new HashMap<>();\n+    List<BrooklinMetricInfo> regexMetricInfos = new ArrayList<>();\n+    classifyMetricInfos(metricInfos, metricInfoByName, regexMetricInfos);\n+\n+    Collection<Map.Entry<String, Metric>> metricEntries = metricsManager.getMetricRegistry().getMetrics().entrySet().stream()\n+        .filter(metricEntry -> metricFilter.test(metricEntry.getKey()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that every metric has exactly one metricInfo whose nameOrRegex matches the metric's name\n+    for (Map.Entry<String, Metric> metricEntry: metricEntries) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU5NDg0MA=="}, "originalCommit": {"oid": "43527b61fefdbfa6c82d9a407073e276a520f860"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDQzMjYxOnYy", "diffSide": "RIGHT", "path": "datastream-testcommon/src/main/java/com/linkedin/datastream/testutil/MetricsTestUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjozODo0M1rOGckFeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo0Mzo0NlrOGcmUGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwNDUzNw==", "bodyText": "I see that you changed clazz to class. My last comment around it was to understand the reasoning and not object the naming convention. After you mentioned, I noticed in other places where clazz is getting used instead of class.", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r432604537", "createdAt": "2020-05-29T16:38:43Z", "author": {"login": "vmaheshw"}, "path": "datastream-testcommon/src/main/java/com/linkedin/datastream/testutil/MetricsTestUtils.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ *  Copyright 2020 LinkedIn Corporation. All rights reserved.\n+ *  Licensed under the BSD 2-Clause License. See the LICENSE file in the project root for license information.\n+ *  See the NOTICE file in the project root for additional information regarding copyright ownership.\n+ */\n+package com.linkedin.datastream.testutil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.testng.Assert;\n+\n+import com.codahale.metrics.Counter;\n+import com.codahale.metrics.Gauge;\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Metric;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linkedin.datastream.metrics.BrooklinCounterInfo;\n+import com.linkedin.datastream.metrics.BrooklinGaugeInfo;\n+import com.linkedin.datastream.metrics.BrooklinHistogramInfo;\n+import com.linkedin.datastream.metrics.BrooklinMeterInfo;\n+import com.linkedin.datastream.metrics.BrooklinMetricInfo;\n+import com.linkedin.datastream.metrics.DynamicMetricsManager;\n+import com.linkedin.datastream.metrics.MetricsAware;\n+\n+\n+/**\n+ * Test utilities for verifying metrics\n+ * @see MetricsAware\n+ */\n+public class MetricsTestUtils {\n+  // Mapping of BrooklinMetricInfo sub-types -> com.codahale.metrics types\n+  private static final Map<Class<? extends BrooklinMetricInfo>, Class<? extends Metric>> METRICS_TYPE_MAPPING = ImmutableMap.of(\n+      BrooklinCounterInfo.class, Counter.class,\n+      BrooklinGaugeInfo.class, Gauge.class,\n+      BrooklinHistogramInfo.class, Histogram.class,\n+      BrooklinMeterInfo.class, Meter.class);\n+\n+  private MetricsTestUtils() {\n+  }\n+\n+  /**\n+   * @see #verifyMetrics(MetricsAware, DynamicMetricsManager, Predicate)\n+   *\n+   * This verification only covers {@link Metric} and {@link BrooklinMetricInfo} objects whose\n+   * names start with the provided {@code metricsAware}'s simple class name.\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager) {\n+    verifyMetrics(metricsAware, metricsManager, s -> s.startsWith(metricsAware.getClass().getSimpleName()));\n+  }\n+\n+  /**\n+   * Verifies consistency between:\n+   * <ol>\n+   *   <li>{@link BrooklinMetricInfo} objects returned by the specified {@code metricsAware}\n+   *   (specifically {@link MetricsAware#getMetricInfos()}) after filtering them using {@code metricFilter}</li>\n+   *   <li>{@link Metric} objects registered with the specified {@code metricsManager} after filtering them\n+   *   using {@code metricFilter}</li>\n+   * </ol>\n+   *\n+   * In particular, it verifies that:\n+   * <ul>\n+   *   <li>All {@link BrooklinMetricInfo} are distinct</li>\n+   *   <li>Every {@link Metric} object has exactly one {@link BrooklinMetricInfo} object whose\n+   *   {@link BrooklinMetricInfo#getNameOrRegex()} matches the metric's name</li>\n+   *   <li>Every {@link Metric} is matched with a {@link BrooklinMetricInfo} object whose concrete\n+   *   type matches the metric's type according to {@link MetricsTestUtils#METRICS_TYPE_MAPPING}</li>\n+   * </ul>\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager,\n+      Predicate<String> metricFilter) {\n+\n+    List<BrooklinMetricInfo> metricInfos = metricsAware.getMetricInfos().stream()\n+        .filter(metricInfo -> metricFilter.test(metricInfo.getNameOrRegex()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that all metricInfos are distinct\n+    Assert.assertEquals(metricInfos.size(), metricInfos.stream().distinct().count(),\n+        \"The supplied metricsAware returned duplicate BrooklinMetricInfo objects\");\n+\n+    Map<String, BrooklinMetricInfo> metricInfoByName = new HashMap<>();\n+    List<BrooklinMetricInfo> regexMetricInfos = new ArrayList<>();\n+    classifyMetricInfos(metricInfos, metricInfoByName, regexMetricInfos);\n+\n+    Collection<Map.Entry<String, Metric>> metricEntries = metricsManager.getMetricRegistry().getMetrics().entrySet().stream()\n+        .filter(metricEntry -> metricFilter.test(metricEntry.getKey()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that every metric has exactly one metricInfo whose nameOrRegex matches the metric's name\n+    for (Map.Entry<String, Metric> metricEntry: metricEntries) {\n+      int count = getMatchingMetricInfoCount(metricEntry, metricInfoByName, regexMetricInfos);\n+      Assert.assertEquals(count, 1,\n+          String.format(\"Metric %s must match exactly one BrooklinMetricInfo but it matched %d\",\n+              metricEntry.getKey(), count));\n+    }\n+  }\n+\n+  private static void classifyMetricInfos(Collection<BrooklinMetricInfo> metricInfos,\n+      Map<String, BrooklinMetricInfo> metricInfoByName, List<BrooklinMetricInfo> regexMetricInfos) {\n+    for (BrooklinMetricInfo metricInfo : metricInfos) {\n+      String nameOrRegex = metricInfo.getNameOrRegex();\n+      if (nameOrRegex.contains(MetricsAware.KEY_REGEX)) {\n+        regexMetricInfos.add(metricInfo);\n+      } else {\n+        metricInfoByName.put(nameOrRegex, metricInfo);\n+      }\n+    }\n+  }\n+\n+  private static int getMatchingMetricInfoCount(Map.Entry<String, Metric> metricEntry,\n+      Map<String, BrooklinMetricInfo> metricInfoByName, List<BrooklinMetricInfo> regexMetricInfos) {\n+    int count = 0;\n+\n+    String metricName = metricEntry.getKey();\n+    if (metricInfoByName.containsKey(metricName)) {\n+      BrooklinMetricInfo metricInfo = metricInfoByName.get(metricName);\n+      assertTypeCompatibility(metricInfo, metricEntry);\n+      ++count;\n+    }\n+\n+    for (BrooklinMetricInfo metricInfo : regexMetricInfos) {\n+      if (metricName.matches(metricInfo.getNameOrRegex())) {\n+        assertTypeCompatibility(metricInfo, metricEntry);\n+        ++count;\n+      }\n+    }\n+\n+    return count;\n+  }\n+\n+  private static void assertTypeCompatibility(BrooklinMetricInfo metricInfo, Map.Entry<String, Metric> metricEntry) {\n+    String metricName = metricEntry.getKey();\n+    Metric metric = metricEntry.getValue();\n+\n+    Class<? extends BrooklinMetricInfo> metricInfoClass = metricInfo.getClass();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43527b61fefdbfa6c82d9a407073e276a520f860"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MTA1MQ==", "bodyText": "No worries at all. I did explain why I preferred doing that eventually in my response to your earlier comment.", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r432641051", "createdAt": "2020-05-29T17:43:46Z", "author": {"login": "ahmedahamid"}, "path": "datastream-testcommon/src/main/java/com/linkedin/datastream/testutil/MetricsTestUtils.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ *  Copyright 2020 LinkedIn Corporation. All rights reserved.\n+ *  Licensed under the BSD 2-Clause License. See the LICENSE file in the project root for license information.\n+ *  See the NOTICE file in the project root for additional information regarding copyright ownership.\n+ */\n+package com.linkedin.datastream.testutil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.testng.Assert;\n+\n+import com.codahale.metrics.Counter;\n+import com.codahale.metrics.Gauge;\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Metric;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linkedin.datastream.metrics.BrooklinCounterInfo;\n+import com.linkedin.datastream.metrics.BrooklinGaugeInfo;\n+import com.linkedin.datastream.metrics.BrooklinHistogramInfo;\n+import com.linkedin.datastream.metrics.BrooklinMeterInfo;\n+import com.linkedin.datastream.metrics.BrooklinMetricInfo;\n+import com.linkedin.datastream.metrics.DynamicMetricsManager;\n+import com.linkedin.datastream.metrics.MetricsAware;\n+\n+\n+/**\n+ * Test utilities for verifying metrics\n+ * @see MetricsAware\n+ */\n+public class MetricsTestUtils {\n+  // Mapping of BrooklinMetricInfo sub-types -> com.codahale.metrics types\n+  private static final Map<Class<? extends BrooklinMetricInfo>, Class<? extends Metric>> METRICS_TYPE_MAPPING = ImmutableMap.of(\n+      BrooklinCounterInfo.class, Counter.class,\n+      BrooklinGaugeInfo.class, Gauge.class,\n+      BrooklinHistogramInfo.class, Histogram.class,\n+      BrooklinMeterInfo.class, Meter.class);\n+\n+  private MetricsTestUtils() {\n+  }\n+\n+  /**\n+   * @see #verifyMetrics(MetricsAware, DynamicMetricsManager, Predicate)\n+   *\n+   * This verification only covers {@link Metric} and {@link BrooklinMetricInfo} objects whose\n+   * names start with the provided {@code metricsAware}'s simple class name.\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager) {\n+    verifyMetrics(metricsAware, metricsManager, s -> s.startsWith(metricsAware.getClass().getSimpleName()));\n+  }\n+\n+  /**\n+   * Verifies consistency between:\n+   * <ol>\n+   *   <li>{@link BrooklinMetricInfo} objects returned by the specified {@code metricsAware}\n+   *   (specifically {@link MetricsAware#getMetricInfos()}) after filtering them using {@code metricFilter}</li>\n+   *   <li>{@link Metric} objects registered with the specified {@code metricsManager} after filtering them\n+   *   using {@code metricFilter}</li>\n+   * </ol>\n+   *\n+   * In particular, it verifies that:\n+   * <ul>\n+   *   <li>All {@link BrooklinMetricInfo} are distinct</li>\n+   *   <li>Every {@link Metric} object has exactly one {@link BrooklinMetricInfo} object whose\n+   *   {@link BrooklinMetricInfo#getNameOrRegex()} matches the metric's name</li>\n+   *   <li>Every {@link Metric} is matched with a {@link BrooklinMetricInfo} object whose concrete\n+   *   type matches the metric's type according to {@link MetricsTestUtils#METRICS_TYPE_MAPPING}</li>\n+   * </ul>\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager,\n+      Predicate<String> metricFilter) {\n+\n+    List<BrooklinMetricInfo> metricInfos = metricsAware.getMetricInfos().stream()\n+        .filter(metricInfo -> metricFilter.test(metricInfo.getNameOrRegex()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that all metricInfos are distinct\n+    Assert.assertEquals(metricInfos.size(), metricInfos.stream().distinct().count(),\n+        \"The supplied metricsAware returned duplicate BrooklinMetricInfo objects\");\n+\n+    Map<String, BrooklinMetricInfo> metricInfoByName = new HashMap<>();\n+    List<BrooklinMetricInfo> regexMetricInfos = new ArrayList<>();\n+    classifyMetricInfos(metricInfos, metricInfoByName, regexMetricInfos);\n+\n+    Collection<Map.Entry<String, Metric>> metricEntries = metricsManager.getMetricRegistry().getMetrics().entrySet().stream()\n+        .filter(metricEntry -> metricFilter.test(metricEntry.getKey()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that every metric has exactly one metricInfo whose nameOrRegex matches the metric's name\n+    for (Map.Entry<String, Metric> metricEntry: metricEntries) {\n+      int count = getMatchingMetricInfoCount(metricEntry, metricInfoByName, regexMetricInfos);\n+      Assert.assertEquals(count, 1,\n+          String.format(\"Metric %s must match exactly one BrooklinMetricInfo but it matched %d\",\n+              metricEntry.getKey(), count));\n+    }\n+  }\n+\n+  private static void classifyMetricInfos(Collection<BrooklinMetricInfo> metricInfos,\n+      Map<String, BrooklinMetricInfo> metricInfoByName, List<BrooklinMetricInfo> regexMetricInfos) {\n+    for (BrooklinMetricInfo metricInfo : metricInfos) {\n+      String nameOrRegex = metricInfo.getNameOrRegex();\n+      if (nameOrRegex.contains(MetricsAware.KEY_REGEX)) {\n+        regexMetricInfos.add(metricInfo);\n+      } else {\n+        metricInfoByName.put(nameOrRegex, metricInfo);\n+      }\n+    }\n+  }\n+\n+  private static int getMatchingMetricInfoCount(Map.Entry<String, Metric> metricEntry,\n+      Map<String, BrooklinMetricInfo> metricInfoByName, List<BrooklinMetricInfo> regexMetricInfos) {\n+    int count = 0;\n+\n+    String metricName = metricEntry.getKey();\n+    if (metricInfoByName.containsKey(metricName)) {\n+      BrooklinMetricInfo metricInfo = metricInfoByName.get(metricName);\n+      assertTypeCompatibility(metricInfo, metricEntry);\n+      ++count;\n+    }\n+\n+    for (BrooklinMetricInfo metricInfo : regexMetricInfos) {\n+      if (metricName.matches(metricInfo.getNameOrRegex())) {\n+        assertTypeCompatibility(metricInfo, metricEntry);\n+        ++count;\n+      }\n+    }\n+\n+    return count;\n+  }\n+\n+  private static void assertTypeCompatibility(BrooklinMetricInfo metricInfo, Map.Entry<String, Metric> metricEntry) {\n+    String metricName = metricEntry.getKey();\n+    Metric metric = metricEntry.getValue();\n+\n+    Class<? extends BrooklinMetricInfo> metricInfoClass = metricInfo.getClass();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwNDUzNw=="}, "originalCommit": {"oid": "43527b61fefdbfa6c82d9a407073e276a520f860"}, "originalPosition": 142}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1001, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}