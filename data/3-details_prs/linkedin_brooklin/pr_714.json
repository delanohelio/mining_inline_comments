{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMDQ5NjY5", "number": 714, "title": "Fix producer.close() deadlock by moving actual producer.close() call to separate thread in KafkaProducerWrapper", "bodyText": "We have a deadlock scenario which looks like:\n\nThe instance is shutdown, and all the KafkaProducerWrappers have their close() API called. This in turn results in calling the KafkaProducer's close() call. The close() API is synchronized\nWe try to close the KafkaProducer (shutdownProducer()) on any send failures, and this callback is called from the KafkaProducer's Sender (I/O) thread.\nThe KafkaProducerWrapper's shutdownProducer() is synchronized\nKafkaProducer's close() waits for a  Timeout duration for the close() to complete, otherwise it proceeds to force close. The force close path tries to do an ioThread.join() without a timeout.\nDue to the SendCallback firing with an Exception, and since SendCallbacks are processed as part of the ioThread, the callback is  stuck waiting for the lock on the shutdownProducer() method.\nThe ioThread.join() is unable to complete because the ioThread is deadlocked waiting for the synchronized lock on shutdownProducer(), but the lock is held by the close() call.\n\nThis PR addresses the above by spawning the \"producer.close()\" part in a separate thread. It also removes the synchronized methods in favor of a synchronized lock object to avoid dealing with issues where the callers of the KafkaProducerWrapper APIs themselves try to lock the object. Synchronization with other methods may still be a problem, but some fixes have been added to force kill stuck tasks, etc which should reduce such deadlock scenarios.", "createdAt": "2020-05-22T17:05:52Z", "url": "https://github.com/linkedin/brooklin/pull/714", "merged": true, "mergeCommit": {"oid": "5f9856e1471b3f4f496d64264c8adeb52d00cda0"}, "closed": true, "closedAt": "2020-05-30T01:58:15Z", "author": {"login": "somandal"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcj1MJWAH2gAyNDIyMDQ5NjY5OjhkZGZmZTkxZWIwYzNkMDU0ZTFlNzI4YzM1ZDg1MGIxNGI3ZGIzOWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcmM4DAgFqTQyMTM2NjUzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8ddffe91eb0c3d054e1e728c35d850b14b7db39c", "author": {"user": {"login": "somandal", "name": "Sonam Mandal"}}, "url": "https://github.com/linkedin/brooklin/commit/8ddffe91eb0c3d054e1e728c35d850b14b7db39c", "committedDate": "2020-05-22T16:51:40Z", "message": "Fix producer.close() deadlock by moving actual producer.close() call to separate thread in KafkaProducerWrapper"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NjcyNzI4", "url": "https://github.com/linkedin/brooklin/pull/714#pullrequestreview-418672728", "createdAt": "2020-05-26T20:56:14Z", "commit": {"oid": "8ddffe91eb0c3d054e1e728c35d850b14b7db39c"}, "state": "DISMISSED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDo1NjoxNFrOGawBRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzozMDoyOVrOGazp8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcwMjkxNg==", "bodyText": "Why 10 as opposed to a single thread?", "url": "https://github.com/linkedin/brooklin/pull/714#discussion_r430702916", "createdAt": "2020-05-26T20:56:14Z", "author": {"login": "ahmedahamid"}, "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -98,6 +105,13 @@\n   private final DynamicMetricsManager _dynamicMetricsManager;\n   private final String _metricsNamesPrefix;\n \n+  // A lock used to synchronized access to operations performed on the _kafkaProducer object\n+  private final ReentrantLock _producerLock = new ReentrantLock();\n+\n+  // An executor to spawn threads to close the producer.\n+  private final ExecutorService _producerCloseExecutorService = Executors.newFixedThreadPool(10,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ddffe91eb0c3d054e1e728c35d850b14b7db39c"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcwNDI1MA==", "bodyText": "Since we're not using any of ReentrantLock's advanced capabilities, I'd recommend just defining an Object and locking it using synchronized blocks; they're easier to read, do not require try/finally blocks, do not require separate lock/unlock statements, the lock/unlock are lexically defined with a block scope, are also reentrant, and are generally simpler.", "url": "https://github.com/linkedin/brooklin/pull/714#discussion_r430704250", "createdAt": "2020-05-26T20:58:50Z", "author": {"login": "ahmedahamid"}, "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -98,6 +105,13 @@\n   private final DynamicMetricsManager _dynamicMetricsManager;\n   private final String _metricsNamesPrefix;\n \n+  // A lock used to synchronized access to operations performed on the _kafkaProducer object\n+  private final ReentrantLock _producerLock = new ReentrantLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ddffe91eb0c3d054e1e728c35d850b14b7db39c"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcwNTg4NQ==", "bodyText": "Do you think it would be better to move this javadoc inside the method? It's slightly confusing now since it could be misinterpreted to mean a lock has to be acquired before this method is called.", "url": "https://github.com/linkedin/brooklin/pull/714#discussion_r430705885", "createdAt": "2020-05-26T21:02:09Z", "author": {"login": "ahmedahamid"}, "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -163,22 +177,27 @@ int getTasksSize() {\n   }\n \n   /**\n-   * Must be synchronized to avoid creating duplicate producers when multiple concurrent\n+   * Must be protected by a lock to avoid creating duplicate producers when multiple concurrent\n    * sends are in-flight and _kafkaProducer has been set to null as a result of previous\n    * producer exception.\n    */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ddffe91eb0c3d054e1e728c35d850b14b7db39c"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcwOTA4Nw==", "bodyText": "If it may be come in handy during debugging and isn't produced too frequently, it may not be such a bad idea to turn the two debug logs within this block to info instead. I don't have as much experience as you do with these logs though.", "url": "https://github.com/linkedin/brooklin/pull/714#discussion_r430709087", "createdAt": "2020-05-26T21:09:04Z", "author": {"login": "ahmedahamid"}, "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -221,61 +240,87 @@ void send(DatastreamTask task, ProducerRecord<K, V> producerRecord, Callback onC\n         }\n         // Set a max_send_attempts for KafkaException as it may be non-recoverable\n         if (numberOfAttempt > MAX_SEND_ATTEMPTS || ((cause instanceof Error || cause instanceof RuntimeException))) {\n-          _log.error(\"Send failed for partition {} with a non retriable exception\", producerRecord.partition(), e);\n+          _log.error(String.format(\"Send failed for partition %d with a non-retriable exception\",\n+              producerRecord.partition()), e);\n           throw generateSendFailure(e);\n         } else {\n-          _log.warn(\"Send failed for partition {} with retriable exception, retry {} out of {} in {} ms.\",\n-              producerRecord.partition(), numberOfAttempt, MAX_SEND_ATTEMPTS, _sendFailureRetryWaitTimeMs, e);\n+          _log.warn(String.format(\n+              \"Send failed for partition %d with a retriable exception, retry %d out of %d in %d ms.\",\n+              producerRecord.partition(), numberOfAttempt, MAX_SEND_ATTEMPTS, _sendFailureRetryWaitTimeMs), e);\n           Thread.sleep(_sendFailureRetryWaitTimeMs);\n         }\n       } catch (Exception e) {\n-        _log.error(\"Send failed for partition {} with an exception\", producerRecord.partition(), e);\n+        _log.error(String.format(\"Send failed for partition %d with an exception\", producerRecord.partition()), e);\n         throw generateSendFailure(e);\n       }\n     }\n   }\n \n-  private synchronized void shutdownProducer() {\n-    Producer<K, V> producer = _kafkaProducer;\n-    // Nullify first to prevent subsequent send() to use\n-    // the current producer which is being shutdown.\n-    _kafkaProducer = null;\n+  @VisibleForTesting\n+  void shutdownProducer() {\n+    Producer<K, V> producer;\n+    _producerLock.lock();\n+    try {\n+      producer = _kafkaProducer;\n+      // Nullify first to prevent subsequent send() to use\n+      // the current producer which is being shutdown.\n+      _kafkaProducer = null;\n+    } finally {\n+      _producerLock.unlock();\n+    }\n+\n+    // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n+    // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n+    // thread\n     if (producer != null) {\n-      producer.close(TIME_OUT, TimeUnit.MILLISECONDS);\n-      NUM_PRODUCERS.decrementAndGet();\n+      _producerCloseExecutorService.submit(() -> {\n+        _log.debug(\"KafkaProducerWrapper: Closing the Kafka Producer\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ddffe91eb0c3d054e1e728c35d850b14b7db39c"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc2MTE4Mg==", "bodyText": "Please, feel free to ignore this comment.\nI generally dislike polling in tests for several reasons. I'll just mention the most relevant ones here:\n\nIt's a source of flakiness (I know you used a timeout of 10s for that reason)\nWhen we do verifyClose(0), count == numExpected will return true immediately, a racey behavior that does not affect this test because it has a subsequent assertion that verifies shutdownProducer() itself hasn't been called.\nAssert.assertEquals(_numShutdownProducerCalls, numExpected)\nbut this begs the question: do we have to assert on _mockProducer.produce() in the first place?", "url": "https://github.com/linkedin/brooklin/pull/714#discussion_r430761182", "createdAt": "2020-05-26T23:26:08Z", "author": {"login": "ahmedahamid"}, "path": "datastream-kafka/src/test/java/com/linkedin/datastream/kafka/TestKafkaProducerWrapper.java", "diffHunk": "@@ -141,8 +153,17 @@ void verifyFlush(int numExpected) {\n       verify(_mockProducer, times(numExpected)).flush();\n     }\n \n-    void verifyClose(int numExpected) {\n+    void verifyClose(int numExpected) throws NoSuchMethodException {\n+      // Producer close is invoked in a separate thread. Must wait for the thread to get scheduled and call close\n+      Method method = Producer.class.getMethod(\"close\", long.class, TimeUnit.class);\n+      PollUtils.poll(() -> {\n+        Collection<Invocation> invocations = mockingDetails(_mockProducer).getInvocations();\n+        long count = invocations.stream().filter(invocation -> invocation.getMethod().equals(method)).count();\n+        return count == numExpected;\n+      }, 1000, 10000);\n       verify(_mockProducer, times(numExpected)).close(anyLong(), any(TimeUnit.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ddffe91eb0c3d054e1e728c35d850b14b7db39c"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc2MjQ4MA==", "bodyText": "Unlike the other two verify*() methods, this one resets its call count (_numShutdownProducerCalls). This is a little confusing because the call counts passed to the other methods in testFlushInterrupt() are all cumulative.", "url": "https://github.com/linkedin/brooklin/pull/714#discussion_r430762480", "createdAt": "2020-05-26T23:30:29Z", "author": {"login": "ahmedahamid"}, "path": "datastream-kafka/src/test/java/com/linkedin/datastream/kafka/TestKafkaProducerWrapper.java", "diffHunk": "@@ -141,8 +153,17 @@ void verifyFlush(int numExpected) {\n       verify(_mockProducer, times(numExpected)).flush();\n     }\n \n-    void verifyClose(int numExpected) {\n+    void verifyClose(int numExpected) throws NoSuchMethodException {\n+      // Producer close is invoked in a separate thread. Must wait for the thread to get scheduled and call close\n+      Method method = Producer.class.getMethod(\"close\", long.class, TimeUnit.class);\n+      PollUtils.poll(() -> {\n+        Collection<Invocation> invocations = mockingDetails(_mockProducer).getInvocations();\n+        long count = invocations.stream().filter(invocation -> invocation.getMethod().equals(method)).count();\n+        return count == numExpected;\n+      }, 1000, 10000);\n       verify(_mockProducer, times(numExpected)).close(anyLong(), any(TimeUnit.class));\n+      Assert.assertEquals(_numShutdownProducerCalls, numExpected);\n+      _numShutdownProducerCalls = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ddffe91eb0c3d054e1e728c35d850b14b7db39c"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97871962ca674d17fb8dfe3a103148d494c00c70", "author": {"user": {"login": "somandal", "name": "Sonam Mandal"}}, "url": "https://github.com/linkedin/brooklin/commit/97871962ca674d17fb8dfe3a103148d494c00c70", "committedDate": "2020-05-27T02:05:17Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4ODgwNzc1", "url": "https://github.com/linkedin/brooklin/pull/714#pullrequestreview-418880775", "createdAt": "2020-05-27T06:07:25Z", "commit": {"oid": "97871962ca674d17fb8dfe3a103148d494c00c70"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485", "author": {"user": {"login": "somandal", "name": "Sonam Mandal"}}, "url": "https://github.com/linkedin/brooklin/commit/9903637456ba0d3dd4ccdcbaa2063dd63c944485", "committedDate": "2020-05-27T16:13:53Z", "message": "Use single thread executor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NDQzNjEy", "url": "https://github.com/linkedin/brooklin/pull/714#pullrequestreview-419443612", "createdAt": "2020-05-27T17:16:42Z", "commit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDU1NTMw", "url": "https://github.com/linkedin/brooklin/pull/714#pullrequestreview-421055530", "createdAt": "2020-05-29T15:24:05Z", "commit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToyNDowNVrOGchZzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToyNDowNVrOGchZzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2MDU5MQ==", "bodyText": "nit: not sure why this method called generateSendFailure. Should this be renamed to handleSendFailure?", "url": "https://github.com/linkedin/brooklin/pull/714#discussion_r432560591", "createdAt": "2020-05-29T15:24:05Z", "author": {"login": "DEEPTHIKORAT"}, "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -221,47 +234,63 @@ void send(DatastreamTask task, ProducerRecord<K, V> producerRecord, Callback onC\n         }\n         // Set a max_send_attempts for KafkaException as it may be non-recoverable\n         if (numberOfAttempt > MAX_SEND_ATTEMPTS || ((cause instanceof Error || cause instanceof RuntimeException))) {\n-          _log.error(\"Send failed for partition {} with a non retriable exception\", producerRecord.partition(), e);\n+          _log.error(String.format(\"Send failed for partition %d with a non-retriable exception\",\n+              producerRecord.partition()), e);\n           throw generateSendFailure(e);\n         } else {\n-          _log.warn(\"Send failed for partition {} with retriable exception, retry {} out of {} in {} ms.\",\n-              producerRecord.partition(), numberOfAttempt, MAX_SEND_ATTEMPTS, _sendFailureRetryWaitTimeMs, e);\n+          _log.warn(String.format(\n+              \"Send failed for partition %d with a retriable exception, retry %d out of %d in %d ms.\",\n+              producerRecord.partition(), numberOfAttempt, MAX_SEND_ATTEMPTS, _sendFailureRetryWaitTimeMs), e);\n           Thread.sleep(_sendFailureRetryWaitTimeMs);\n         }\n       } catch (Exception e) {\n-        _log.error(\"Send failed for partition {} with an exception\", producerRecord.partition(), e);\n+        _log.error(String.format(\"Send failed for partition %d with an exception\", producerRecord.partition()), e);\n         throw generateSendFailure(e);\n       }\n     }\n   }\n \n-  private synchronized void shutdownProducer() {\n-    Producer<K, V> producer = _kafkaProducer;\n-    // Nullify first to prevent subsequent send() to use\n-    // the current producer which is being shutdown.\n-    _kafkaProducer = null;\n+  @VisibleForTesting\n+  void shutdownProducer() {\n+    Producer<K, V> producer;\n+    synchronized (_producerLock) {\n+      producer = _kafkaProducer;\n+      // Nullify first to prevent subsequent send() to use\n+      // the current producer which is being shutdown.\n+      _kafkaProducer = null;\n+    }\n+\n+    // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n+    // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n+    // thread\n     if (producer != null) {\n-      producer.close(TIME_OUT, TimeUnit.MILLISECONDS);\n-      NUM_PRODUCERS.decrementAndGet();\n+      _producerCloseExecutorService.submit(() -> {\n+        _log.info(\"KafkaProducerWrapper: Closing the Kafka Producer\");\n+        producer.close(TIME_OUT, TimeUnit.MILLISECONDS);\n+        NUM_PRODUCERS.decrementAndGet();\n+        _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+      });\n     }\n   }\n \n   private DatastreamRuntimeException generateSendFailure(Exception exception) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTU2MTA1", "url": "https://github.com/linkedin/brooklin/pull/714#pullrequestreview-421156105", "createdAt": "2020-05-29T17:37:30Z", "commit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozNzozMFrOGcmHBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozNzozMFrOGcmHBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNzcwMQ==", "bodyText": "nit: A lock used to \"synchronize\" access to", "url": "https://github.com/linkedin/brooklin/pull/714#discussion_r432637701", "createdAt": "2020-05-29T17:37:30Z", "author": {"login": "DEEPTHIKORAT"}, "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -98,6 +104,13 @@\n   private final DynamicMetricsManager _dynamicMetricsManager;\n   private final String _metricsNamesPrefix;\n \n+  // A lock used to synchronized access to operations performed on the _kafkaProducer object", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTU3NTcy", "url": "https://github.com/linkedin/brooklin/pull/714#pullrequestreview-421157572", "createdAt": "2020-05-29T17:39:43Z", "commit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozOTo0NFrOGcmLTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzozOTo0NFrOGcmLTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzODc5Ng==", "bodyText": "I am guessing we can now use setName API instead without the %d format since you changed to singleThreadExecutor?", "url": "https://github.com/linkedin/brooklin/pull/714#discussion_r432638796", "createdAt": "2020-05-29T17:39:44Z", "author": {"login": "DEEPTHIKORAT"}, "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -98,6 +104,13 @@\n   private final DynamicMetricsManager _dynamicMetricsManager;\n   private final String _metricsNamesPrefix;\n \n+  // A lock used to synchronized access to operations performed on the _kafkaProducer object\n+  private final Object _producerLock = new Object();\n+\n+  // An executor to spawn threads to close the producer.\n+  private final ExecutorService _producerCloseExecutorService = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder().setNameFormat(\"KafkaProducerWrapperClose-%d\").build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTU4NDIy", "url": "https://github.com/linkedin/brooklin/pull/714#pullrequestreview-421158422", "createdAt": "2020-05-29T17:40:58Z", "commit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo0MDo1OVrOGcmOIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo0MDo1OVrOGcmOIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzOTUyMA==", "bodyText": "nit: Should we use StringUtils ?", "url": "https://github.com/linkedin/brooklin/pull/714#discussion_r432639520", "createdAt": "2020-05-29T17:40:59Z", "author": {"login": "DEEPTHIKORAT"}, "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -117,7 +130,7 @@\n \n     _clientId = transportProviderProperties.getProperty(ProducerConfig.CLIENT_ID_CONFIG);\n     if (_clientId == null || _clientId.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTY1ODEw", "url": "https://github.com/linkedin/brooklin/pull/714#pullrequestreview-421165810", "createdAt": "2020-05-29T17:52:05Z", "commit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo1MjowNVrOGcmkiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo1MjowNVrOGcmkiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0NTI1Ng==", "bodyText": "nit: should this read: \"send failed with a non-transient exception. Shutting down producer\" to match what is being done in the method.", "url": "https://github.com/linkedin/brooklin/pull/714#discussion_r432645256", "createdAt": "2020-05-29T17:52:05Z", "author": {"login": "DEEPTHIKORAT"}, "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -221,47 +234,63 @@ void send(DatastreamTask task, ProducerRecord<K, V> producerRecord, Callback onC\n         }\n         // Set a max_send_attempts for KafkaException as it may be non-recoverable\n         if (numberOfAttempt > MAX_SEND_ATTEMPTS || ((cause instanceof Error || cause instanceof RuntimeException))) {\n-          _log.error(\"Send failed for partition {} with a non retriable exception\", producerRecord.partition(), e);\n+          _log.error(String.format(\"Send failed for partition %d with a non-retriable exception\",\n+              producerRecord.partition()), e);\n           throw generateSendFailure(e);\n         } else {\n-          _log.warn(\"Send failed for partition {} with retriable exception, retry {} out of {} in {} ms.\",\n-              producerRecord.partition(), numberOfAttempt, MAX_SEND_ATTEMPTS, _sendFailureRetryWaitTimeMs, e);\n+          _log.warn(String.format(\n+              \"Send failed for partition %d with a retriable exception, retry %d out of %d in %d ms.\",\n+              producerRecord.partition(), numberOfAttempt, MAX_SEND_ATTEMPTS, _sendFailureRetryWaitTimeMs), e);\n           Thread.sleep(_sendFailureRetryWaitTimeMs);\n         }\n       } catch (Exception e) {\n-        _log.error(\"Send failed for partition {} with an exception\", producerRecord.partition(), e);\n+        _log.error(String.format(\"Send failed for partition %d with an exception\", producerRecord.partition()), e);\n         throw generateSendFailure(e);\n       }\n     }\n   }\n \n-  private synchronized void shutdownProducer() {\n-    Producer<K, V> producer = _kafkaProducer;\n-    // Nullify first to prevent subsequent send() to use\n-    // the current producer which is being shutdown.\n-    _kafkaProducer = null;\n+  @VisibleForTesting\n+  void shutdownProducer() {\n+    Producer<K, V> producer;\n+    synchronized (_producerLock) {\n+      producer = _kafkaProducer;\n+      // Nullify first to prevent subsequent send() to use\n+      // the current producer which is being shutdown.\n+      _kafkaProducer = null;\n+    }\n+\n+    // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n+    // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n+    // thread\n     if (producer != null) {\n-      producer.close(TIME_OUT, TimeUnit.MILLISECONDS);\n-      NUM_PRODUCERS.decrementAndGet();\n+      _producerCloseExecutorService.submit(() -> {\n+        _log.info(\"KafkaProducerWrapper: Closing the Kafka Producer\");\n+        producer.close(TIME_OUT, TimeUnit.MILLISECONDS);\n+        NUM_PRODUCERS.decrementAndGet();\n+        _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+      });\n     }\n   }\n \n   private DatastreamRuntimeException generateSendFailure(Exception exception) {\n     _dynamicMetricsManager.createOrUpdateMeter(_metricsNamesPrefix, AGGREGATE, PRODUCER_ERROR, 1);\n     if (exception instanceof IllegalStateException) {\n-      _log.warn(\"sent failure transiently, exception: \", exception);\n+      _log.warn(\"send failed transiently with exception: \", exception);\n       return new DatastreamTransientException(exception);\n     } else {\n-      _log.warn(\"sent failure, restart producer, exception: \", exception);\n+      _log.warn(\"send failed, restart producer, exception: \", exception);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "originalPosition": 170}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTY1OTcz", "url": "https://github.com/linkedin/brooklin/pull/714#pullrequestreview-421165973", "createdAt": "2020-05-29T17:52:19Z", "commit": {"oid": "9903637456ba0d3dd4ccdcbaa2063dd63c944485"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7798009d8744c782dbce1997c308b4103d07d29", "author": {"user": {"login": "somandal", "name": "Sonam Mandal"}}, "url": "https://github.com/linkedin/brooklin/commit/b7798009d8744c782dbce1997c308b4103d07d29", "committedDate": "2020-05-29T18:08:05Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTgwODE5", "url": "https://github.com/linkedin/brooklin/pull/714#pullrequestreview-421180819", "createdAt": "2020-05-29T18:15:18Z", "commit": {"oid": "b7798009d8744c782dbce1997c308b4103d07d29"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzY2NTM2", "url": "https://github.com/linkedin/brooklin/pull/714#pullrequestreview-421366536", "createdAt": "2020-05-30T01:35:17Z", "commit": {"oid": "b7798009d8744c782dbce1997c308b4103d07d29"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 862, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}