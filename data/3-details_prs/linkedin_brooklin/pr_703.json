{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0MTU5MTg2", "number": 703, "title": "Fix Connector task cleanup, when leader coordinator thread gets interrupted.", "bodyText": "We are seeing lot of orphan nodes getting created when the cluster is bounced.\nDuring leader assignment, dead instances are also cleaned up.\nClean up order for dead instances:\n\nRemove all nodes under /cluster/instances/assignment\nRemove node /cluster/instances\nRemove connector node from /cluster/connector/espresso/.\nOrphan node cleanup.\n\nIf Thread gets interrupted between 2 and 3 (node is restarted), there will be orphan connector nodes, but nodes under instances/assignments will be cleaned up. Next leader will only check the dead instances and will not find anything about these connector nodes. During cleanup of orphan connector tasks (step 4), it will clean up these nodes. But, if the leader gets interrupted again before performing step4, the cleanup will not be complete.\nBouncing the cluster with some nodes at a time, will make multiple leader change within short duration. We perform ls during OrphanConnectorCleanupTask. But, if the children size of znode becomes greater than juteMaxBuffer, zkClient will start throwing exception and will not let the orphanConnectorCleanUpTask go through.\nTo solve this problem:\nWe will merge cleanup from step 2 and step3 by pre-calculating the unusedTask Set and for every node deleted from /instance//assignments and present in unusedTask Set, right after that we will delete the connector task node from /connector//. This will ensure that node present under instance and connector task will get cleanup right one after another, rather than first all nodes deleted under instance and then deleted under connector.\nSample code:\n\nfor each dead instance node:\nwalk its children nodes:\ndelete the node\nif node in UnusedTaskSet:\ndelete the task node under connector.\n\nSo, when the leader Coordinator thread gets interrupted and it is currently at step 2, all the  nodes deleted from /instance/assignments will also be cleaned up from /connector except may be the last one (which the next leader can take care of during CleanupOrphanConnectorTasks.)", "createdAt": "2020-04-16T07:06:20Z", "url": "https://github.com/linkedin/brooklin/pull/703", "merged": true, "mergeCommit": {"oid": "c70b4ef12ebc43b5a3dbaa6474f6723520e8a765"}, "closed": true, "closedAt": "2020-04-28T22:06:21Z", "author": {"login": "vmaheshw"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABboAf5CAH2gAyNDA0MTU5MTg2OmMzMWNkNGExNWNjOGRkNjliMGE2NTNkYmU0MjAxZGU5MzRlYTZkNjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccLTPaAFqTQwMjI0NjIyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "author": {"user": {"login": "vmaheshw", "name": "Vaibhav Maheshwari"}}, "url": "https://github.com/linkedin/brooklin/commit/c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "committedDate": "2019-11-18T20:06:44Z", "message": "Merge pull request #1 from linkedin/master\n\nPull latest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a4c33f184c68f793fbfdbde825a0868e79277cb", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/6a4c33f184c68f793fbfdbde825a0868e79277cb", "committedDate": "2020-04-16T03:27:48Z", "message": "Merge branch 'master' of github.com:linkedin/brooklin into HEAD"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/f3aa084698c8c83239079da26f1c52da67b134b2", "committedDate": "2020-04-16T06:47:54Z", "message": "Fix Connector task cleanup, when leader coordinator thread gets interrupted"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NTA3NTkz", "url": "https://github.com/linkedin/brooklin/pull/703#pullrequestreview-394507593", "createdAt": "2020-04-16T10:36:38Z", "commit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0ODEzNDE2", "url": "https://github.com/linkedin/brooklin/pull/703#pullrequestreview-394813416", "createdAt": "2020-04-16T16:41:49Z", "commit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNjo0MTo0OVrOGGuBkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNjo1NDo0N1rOGGuh4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5ODcwNQ==", "bodyText": "I see here that this walks the remaining unusedTasks and deletes them from under the /connectorconnector name/ path. The previous step also removes tasks from the same /connector/connector name/ path. Can you add a comment explaining why we need this second step so that the problem this solves is clear to someone reading this code?", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409698705", "createdAt": "2020-04-16T16:41:49Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -998,8 +998,10 @@ private void handleLeaderDoAssignment(boolean cleanUpOrphanConnectorTasks) {\n     if (succeeded) {\n       List<String> instances = new ArrayList<>(liveInstances);\n       instances.add(PAUSED_INSTANCE);\n-      _adapter.cleanupDeadInstanceAssignments(instances);\n-      _adapter.cleanupOldUnusedTasks(previousAssignmentByInstance, newAssignmentsByInstance);\n+      Set<DatastreamTask> unusedTasks = _adapter.findOldUnusedTasks(previousAssignmentByInstance,\n+          newAssignmentsByInstance);\n+      _adapter.cleanupDeadInstanceAssignments(instances, unusedTasks);\n+      _adapter.cleanupOldUnusedTasks(unusedTasks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwMjQzNQ==", "bodyText": "Can you update the java docs to explain that it removes both the task under the instance and the connector. Explain why it needs to do this.\nAlso, do we want to rename this function to indicate it cleans up under /instances and /connector/connectorName?", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409702435", "createdAt": "2020-04-16T16:47:31Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -850,13 +846,36 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignments(List<String> instances, Set<DatastreamTask> unusedTasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwMjYzNA==", "bodyText": "Add the second @param unusedTasks", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409702634", "createdAt": "2020-04-16T16:47:52Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -850,13 +846,36 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwMzkwNQ==", "bodyText": "Not part of your change, but I noticed this removeTaskNodes() method has a comment saying it deletes both from /instance and from /connector, but it doesn't do that. Can you fix that comment? May even want to rename it to indicate it only removes task nodes under /instance, e.g. removeTaskNodeFromInstance", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409703905", "createdAt": "2020-04-16T16:49:41Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -850,13 +846,36 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignments(List<String> instances, Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName);\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));\n+\n+        oldAssignments.forEach(oldAssignment -> {\n+          DatastreamTask unusedTask = unusedTasksByName.remove(oldAssignment);\n+          removeTaskNodes(instance, oldAssignment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNDUyMQ==", "bodyText": "update this to be /connector/<connectorName>/", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409704521", "createdAt": "2020-04-16T16:50:41Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -850,13 +846,36 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignments(List<String> instances, Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName);\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));\n+\n+        oldAssignments.forEach(oldAssignment -> {\n+          DatastreamTask unusedTask = unusedTasksByName.remove(oldAssignment);\n+          removeTaskNodes(instance, oldAssignment);\n+          // /connector/<Task> node should always be deleted after /instance/<Task>/.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNTI2Mg==", "bodyText": "Update the java docs to say this finds unused tasks.\nUpdate the java doc to add an @returns as well, indicating that it returns a list of unused DatastreamTasks", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409705262", "createdAt": "2020-04-16T16:51:58Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -875,21 +895,39 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNTY2Mg==", "bodyText": "nit: don't need the space after {}", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409705662", "createdAt": "2020-04-16T16:52:38Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -875,21 +895,39 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {} \", unusedTasks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNTk0Ng==", "bodyText": "Can you rename this to be findAndCleanupOldUnusedTasks()?\nAnd if you decide to rename the previous function to indicate that the tasks are getting cleaned up under /connector, please do the same here as well.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409705946", "createdAt": "2020-04-16T16:53:06Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -875,21 +895,39 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {} \", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  public void cleanupOldUnusedTasks(Set<DatastreamTask> unusedTasks) {\n     // Delete the connector tasks.\n     unusedTasks.forEach(t -> deleteConnectorTask(t.getConnectorType(), t.getDatastreamTaskName()));\n   }\n \n+  /**\n+   * Find the ununsed tasks and delete the unused connector tasks from zookeeper.\n+   * @param previousAssignmentByInstance Previous task assignment\n+   * @param newAssignmentsByInstance New task assignment.\n+   */\n+  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNjIxMQ==", "bodyText": "nit: ununsed -> unused", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409706211", "createdAt": "2020-04-16T16:53:34Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -875,21 +895,39 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {} \", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  public void cleanupOldUnusedTasks(Set<DatastreamTask> unusedTasks) {\n     // Delete the connector tasks.\n     unusedTasks.forEach(t -> deleteConnectorTask(t.getConnectorType(), t.getDatastreamTaskName()));\n   }\n \n+  /**\n+   * Find the ununsed tasks and delete the unused connector tasks from zookeeper.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNjk3OQ==", "bodyText": "I'm wondering if we should rename this to indicate that it clears unused tasks from /connector, e.g. cleanupOldUnusedTasksFromConnector() or something like that? Same for the next function named this way.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409706979", "createdAt": "2020-04-16T16:54:47Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -875,21 +895,39 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {} \", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  public void cleanupOldUnusedTasks(Set<DatastreamTask> unusedTasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/3687be18d3187eb733ba0312b8f178875ad6e15f", "committedDate": "2020-04-23T01:16:15Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NDA3MTY1", "url": "https://github.com/linkedin/brooklin/pull/703#pullrequestreview-399407165", "createdAt": "2020-04-23T19:24:23Z", "commit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxOToyNDoyM1rOGK4YwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNDoxNDoxOVrOGLFmuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA2Mjc4NQ==", "bodyText": "findOldUnusedTasks() looks like an implementation detail of cleanupDeadInstanceAssignmentsAndUnusedTasks(); it's not useful on its own as an independent public API of _adapter.\nI suggest we invoke findOldUnusedTasks() from within cleanupDeadInstanceAssignmentsAndUnusedTasks(). In this case, we should be able to mark the former private.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414062785", "createdAt": "2020-04-23T19:24:23Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -998,8 +998,9 @@ private void handleLeaderDoAssignment(boolean cleanUpOrphanConnectorTasks) {\n     if (succeeded) {\n       List<String> instances = new ArrayList<>(liveInstances);\n       instances.add(PAUSED_INSTANCE);\n-      _adapter.cleanupDeadInstanceAssignments(instances);\n-      _adapter.cleanupOldUnusedTasks(previousAssignmentByInstance, newAssignmentsByInstance);\n+      Set<DatastreamTask> unusedTasks = _adapter.findOldUnusedTasks(previousAssignmentByInstance,\n+          newAssignmentsByInstance);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA2ODk3NQ==", "bodyText": "cleanUp (capital U)\nNot all your fault nit: please make sure all other cleanup methods on this class use a capital U\nnit: please free to ignore this one but let me know what you think \u2014 Is this name a little too verbose? Should it be something like cleanUpDeadInstanceData? Rationale is: the javadoc can capture the details; we know cleaning up dead instances involves deleting a number of different things but should they all be reflected in the name?\nSince this is the main cleanup function called from the Coordinator, I suggest we add informational log statements on entry and exit. This can be very useful during debugging, let alone it helps us observe how long cleanup takes.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414068975", "createdAt": "2020-04-23T19:34:30Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3MDIyOA==", "bodyText": "nit: findAnd; finding is implied", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414070228", "createdAt": "2020-04-23T19:36:36Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -867,29 +892,53 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n         _liveTaskMap.remove(instance);\n       }\n     }\n+    LOG.debug(\"unusedTasks remaining after dead instances cleanup: {}\", unusedTasksByName.keySet());\n+    // Clean the remaining unusedTasks.\n+    findAndCleanupOldUnusedTasksFromConnector(unusedTasks);\n   }\n \n   /**\n+   * It finds old unused tasks.\n+   *\n    * New assignment may not contain all the tasks from the previous assignment. This means that the diff of the\n    * tasks between the new and old assignment are not used any more which can be deleted.\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n+   * @return Tasks absent in newAssignment but present in oldAssignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {}\", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  private void findAndCleanupOldUnusedTasksFromConnector(Set<DatastreamTask> unusedTasks) {\n     // Delete the connector tasks.\n     unusedTasks.forEach(t -> deleteConnectorTask(t.getConnectorType(), t.getDatastreamTaskName()));\n   }\n \n+  /**\n+   * Find the unused tasks and delete the unused connector tasks from zookeeper.\n+   * @param previousAssignmentByInstance Previous task assignment\n+   * @param newAssignmentsByInstance New task assignment.\n+   */\n+  public void findAndCleanupOldUnusedTasksFromConnector(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3MzA4Ng==", "bodyText": "This sentence doesn't read well now. I find the original version okay/useful though; the clarification you're adding below is sufficient.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414073086", "createdAt": "2020-04-23T19:41:12Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -613,19 +613,20 @@ private void addTaskNodes(String instance, DatastreamTaskImpl task) {\n   }\n \n   /**\n-   * Two nodes need to be removed for a removed task:\n+   * Nodes need to be removed for a removed task:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3MzI2Mg==", "bodyText": "add {@link}s for both functions", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414073262", "createdAt": "2020-04-23T19:41:28Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -613,19 +613,20 @@ private void addTaskNodes(String instance, DatastreamTaskImpl task) {\n   }\n \n   /**\n-   * Two nodes need to be removed for a removed task:\n+   * Nodes need to be removed for a removed task:\n    * <ol>\n    *  <li>{@code /<cluster>/instances/<instance>/<task>[JSON]}</li>\n-   *  <li>{@code /<cluster>/connectors/<connectorType>/<task>}</li>\n    * </ol>\n-   *  If either failed, a RuntimeException will be thrown.\n+   *\n+   * {@code /<cluster>/connectors/<connectorType>/<task>} gets cleaned up\n+   * in cleanupDeadInstanceAssignmentsAndUnusedTasks() after updateAssignments is successful.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3NjAxOA==", "bodyText": "new HashSet<> is not needed; oldAssignmentNames is only used for exclusion from a set, let alone the returned assignments are always unique anyways (read straight from ZooKeeper). oldAssignmentNames  can be a List<String or even Collection<String>.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414076018", "createdAt": "2020-04-23T19:45:55Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -703,11 +704,7 @@ private void diffAssignmentNodes(Map<String, List<DatastreamTask>> assignmentsBy\n           .collect(Collectors.toSet());\n \n       // get the old assignment from ZooKeeper\n-      Set<String> oldAssignmentNames = new HashSet<>();\n-      String instancePath = KeyBuilder.instanceAssignments(_cluster, instance);\n-      if (_zkclient.exists(instancePath)) {\n-        oldAssignmentNames.addAll(_zkclient.getChildren(instancePath));\n-      }\n+      Set<String> oldAssignmentNames = new HashSet<>(getInstanceAssignment(instance));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NTI5MQ==", "bodyText": "Move to line 856 since it's closely related to 855.\nNot your fault: since we're doing removeAll(), let's turn deadInstances into a Set<String> so the complexity of that operation becomes linear.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414095291", "createdAt": "2020-04-23T20:17:48Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3NjcwNw==", "bodyText": "Please feel free to ignore this comment if you prefer it the way it is \u2014 this can be written as:\nMap<String, DatastreamTask> unusedTasksByName = unusedTasks.stream()\n       .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity()));", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414176707", "createdAt": "2020-04-23T22:53:50Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI0MjUwOQ==", "bodyText": "Do we need to update unusedTasks? Can't we pass unusedTasksByName.values() to findAndCleanupOldUnusedTasksFromConnector() after changing the latter to expect a Collection?", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414242509", "createdAt": "2020-04-24T02:14:50Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName.keySet());\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));\n+\n+        oldAssignments.forEach(oldAssignment -> {\n+          removeTaskNodes(instance, oldAssignment);\n+          // /<cluster>/connectors/<connectorType>/<task> node should always be deleted after\n+          // /<cluster>/instances/<task>/.\n+          // If a node is present under /instance, the code assumes that the node will be present under\n+          // /<cluster>/connectors/<connectorType>/ as well. So, the cleanup order is very important.\n+\n+          // If the thread gets interrupted after removing node under /instance, but before deleting node\n+          // under /<cluster>/connectors/<connectorType>/, next leader will take care of cleaning this orphan node in\n+          // cleanUpOrphanConnectorTask call.\n+          DatastreamTask unusedTask = unusedTasksByName.remove(oldAssignment);\n+          if (unusedTask != null) {\n+            deleteConnectorTask(unusedTask.getConnectorType(), unusedTask.getDatastreamTaskName());\n+            unusedTasks.remove(unusedTask);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI0NTM4Nw==", "bodyText": "This is a purely stylistic comment that is heavily subjective: I personally find it slightly better to have this be an ordinary for loop because that makes it easier to grasp the logic with a quick glance at the two nested loops:\nfor (String instance: deadInstances) {\n    ...\n    for (String assignment : oldAssignments) {\n        ...   \n    }\n}", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414245387", "createdAt": "2020-04-24T02:25:06Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName.keySet());\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));\n+\n+        oldAssignments.forEach(oldAssignment -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2NDM4OQ==", "bodyText": "new HashSet<> is extraneous; we just need iteration + the elements are unique since they're read from ZooKeeper\nThe name oldAssignments doesn't convey that these are actually datastream task names. I suggest renaming it to oldDatastreamTaskNames.\nI have a suggestion in handleLeaderDoAssignment() to inline the computation of unusedTasks in this method (cleanupDeadInstanceAssignmentsAndUnusedTasks()). If we do so, we'll have access to previousAssignmentByInstance and newAssignmentsByInstance over here. In this case, wouldn't it be better to compute oldAssignments from the in-memory previousAssignmentByInstance instead of a round trip to ZooKeeper using getInstanceAssignment()?", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414264389", "createdAt": "2020-04-24T03:25:58Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName.keySet());\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3MzI0OQ==", "bodyText": "findAnd", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414273249", "createdAt": "2020-04-24T03:55:00Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -867,29 +892,53 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n         _liveTaskMap.remove(instance);\n       }\n     }\n+    LOG.debug(\"unusedTasks remaining after dead instances cleanup: {}\", unusedTasksByName.keySet());\n+    // Clean the remaining unusedTasks.\n+    findAndCleanupOldUnusedTasksFromConnector(unusedTasks);\n   }\n \n   /**\n+   * It finds old unused tasks.\n+   *\n    * New assignment may not contain all the tasks from the previous assignment. This means that the diff of the\n    * tasks between the new and old assignment are not used any more which can be deleted.\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n+   * @return Tasks absent in newAssignment but present in oldAssignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {}\", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  private void findAndCleanupOldUnusedTasksFromConnector(Set<DatastreamTask> unusedTasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3NjI4MQ==", "bodyText": "I like this comment a lot but:\n\nIt doesn't say that removeTaskNodes() removes /<cluster>/instances/<task>/\nThe path isn't exactly /<cluster>/instances/<task>/\nIt assumes a bit of background\n\nHow about we write this as:\n        oldAssignments.forEach(oldAssignment -> {\n          // We have two znodes to clean up for every datastream task\n          //  1. /<cluster>/instances/{instanceId}/assignments/<task>\n          //  2. /<cluster>/connectors/<connectorType>/<task>\n          // \n          // (1) should always be deleted first. If we were to delete (2) first,\n          // and the code got interrupted (e.g. due to shutdown), we would run\n          // the risk of having the next leader assign a task with no presence\n          // in (2) to a live host, which may cause errors in other pieces of\n          // code because datastream task entries in (2) are needed for host-\n          // independent operations like locking tasks and check-pointing progress.\n          //\n          // On the other hand, when we delete (1) before (2), if the code is \n          // interrupted in between the two operations, the next leader will not\n          // assign that task to any host; only (2) will become an orphan node \n          // and the next leader will take care of deleting it in cleanUpOrphanConnectorTask().\n          \n          // Delete (1)\n          removeTaskNodes(instance, oldAssignment);\n          \n          DatastreamTask unusedTask = unusedTasksByName.remove(oldAssignment);\n          if (unusedTask != null) {\n            // Delete (2)\n            deleteConnectorTask(unusedTask.getConnectorType(), unusedTask.getDatastreamTaskName());\n            unusedTasks.remove(unusedTask);\n          }\n        });", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414276281", "createdAt": "2020-04-24T04:04:59Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName.keySet());\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));\n+\n+        oldAssignments.forEach(oldAssignment -> {\n+          removeTaskNodes(instance, oldAssignment);\n+          // /<cluster>/connectors/<connectorType>/<task> node should always be deleted after\n+          // /<cluster>/instances/<task>/.\n+          // If a node is present under /instance, the code assumes that the node will be present under\n+          // /<cluster>/connectors/<connectorType>/ as well. So, the cleanup order is very important.\n+\n+          // If the thread gets interrupted after removing node under /instance, but before deleting node\n+          // under /<cluster>/connectors/<connectorType>/, next leader will take care of cleaning this orphan node in\n+          // cleanUpOrphanConnectorTask call.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3ODc3NQ==", "bodyText": "Collections.emptyList()", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414278775", "createdAt": "2020-04-24T04:12:28Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -787,6 +788,49 @@ public void testDeleteTasksWithPrefix() {\n     adapter.disconnect();\n   }\n \n+  @Test\n+  public void testUpdateAssignmentDeleteUnusedTasks() {\n+    String testCluster = \"testUpdateAssignmentDeleteUnusedTasks\";\n+    String connectorType = \"connectorType\";\n+    int totalTasks = 10;\n+\n+    ZkClientInterceptingAdapter adapter = createInterceptingZkAdapter(testCluster);\n+    adapter.connect();\n+\n+    List<DatastreamTask> tasks1 = new ArrayList<>();\n+    Set<DatastreamTask> unusedTaskSet = new HashSet<>();\n+\n+    // Create some nodes\n+    for (int i = 0; i < totalTasks; i++) {\n+      DatastreamTaskImpl dsTask = new DatastreamTaskImpl();\n+      dsTask.setId(\"task1\" + i);\n+      String taskPrefix = \"taskPrefix1\" + i;\n+      dsTask.setTaskPrefix(taskPrefix);\n+      dsTask.setConnectorType(connectorType);\n+      dsTask.setZkAdapter(adapter);\n+      tasks1.add(dsTask);\n+      if (i % 2 == 0) {\n+        unusedTaskSet.add(dsTask);\n+      }\n+    }\n+    updateInstanceAssignment(adapter, adapter.getInstanceName(), tasks1);\n+\n+    // Send some of the connector tasks as unused tasks to check there are still left over tasks under /connector,\n+    // but everything cleaned up under /instance.\n+    Assert.assertEquals(unusedTaskSet.size(), totalTasks / 2);\n+    adapter.cleanupDeadInstanceAssignmentsAndUnusedTasks(new ArrayList<>(), unusedTaskSet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3OTM1NQ==", "bodyText": "Collections.emptyList()", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414279355", "createdAt": "2020-04-24T04:14:19Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -769,7 +770,7 @@ public void testDeleteTasksWithPrefix() {\n     leftOverTasks = zkClient.getChildren(KeyBuilder.connector(testCluster, connectorType));\n     Assert.assertEquals(leftOverTasks.size(), 2);\n \n-    updateInstanceAssignment(adapter, adapter.getInstanceName(), new ArrayList<DatastreamTask>());\n+    updateInstanceAssignment(adapter, adapter.getInstanceName(), new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acb48aadbaaece1c721a875b4a7504081138b311", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/acb48aadbaaece1c721a875b4a7504081138b311", "committedDate": "2020-04-24T19:07:05Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMjI4NDU4", "url": "https://github.com/linkedin/brooklin/pull/703#pullrequestreview-400228458", "createdAt": "2020-04-24T19:51:22Z", "commit": {"oid": "acb48aadbaaece1c721a875b4a7504081138b311"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxOTo1MToyMlrOGLm28w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDozNDo1MlrOGLoQMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNDE3OQ==", "bodyText": "nit: it should be Cleanup (lowercase u) in this context. Rationale is: cleanup (noun) is one word, clean up (verb) is two words. We capitalize word boundaries.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414824179", "createdAt": "2020-04-24T19:51:22Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -998,10 +998,10 @@ private void handleLeaderDoAssignment(boolean cleanUpOrphanConnectorTasks) {\n     if (succeeded) {\n       List<String> instances = new ArrayList<>(liveInstances);\n       instances.add(PAUSED_INSTANCE);\n-      _adapter.cleanupDeadInstanceAssignments(instances);\n-      _adapter.cleanupOldUnusedTasks(previousAssignmentByInstance, newAssignmentsByInstance);\n+      _adapter.cleanUpDeadInstanceDataAndOtherUnusedTasks(previousAssignmentByInstance,\n+          newAssignmentsByInstance, instances);\n       if (cleanUpOrphanConnectorTasks) {\n-        performCleanupOrphanConnectorTasks();\n+        performCleanUpOrphanConnectorTasks();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acb48aadbaaece1c721a875b4a7504081138b311"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzMTk2MQ==", "bodyText": "If you're only interested in keySet() then maybe we don't need a map. A list will do.\n    LOG.debug(\"unusedTasks before cleanUp: {}\", unusedTasks.stream()\n        .map(DatastreamTask::getDatastreamTaskName).collect(Collectors.toList()));\nThe same applies to lines 910-911.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414831961", "createdAt": "2020-04-24T20:05:51Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,65 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n+   * @param previousAssignmentByInstance Previous task assignment\n+   * @param newAssignmentsByInstance New task assignment.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n-    List<String> deadInstances = getAllInstances();\n+  public void cleanUpDeadInstanceDataAndOtherUnusedTasks(\n+      Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+      Map<String, List<DatastreamTask>> newAssignmentsByInstance,\n+      List<String> instances) {\n+\n+    LOG.info(\"cleanUpDeadInstanceData is called\");\n+    Set<DatastreamTask> unusedTasks = findOldUnusedTasks(previousAssignmentByInstance, newAssignmentsByInstance);\n+\n+    Set<String> deadInstances = previousAssignmentByInstance.keySet();\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanUp: {}\", unusedTasks.stream()\n+        .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity())).keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acb48aadbaaece1c721a875b4a7504081138b311"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzMzE4Ng==", "bodyText": "Stale function name. The same applies to line 914.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414833186", "createdAt": "2020-04-24T20:08:05Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,65 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n+   * @param previousAssignmentByInstance Previous task assignment\n+   * @param newAssignmentsByInstance New task assignment.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n-    List<String> deadInstances = getAllInstances();\n+  public void cleanUpDeadInstanceDataAndOtherUnusedTasks(\n+      Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+      Map<String, List<DatastreamTask>> newAssignmentsByInstance,\n+      List<String> instances) {\n+\n+    LOG.info(\"cleanUpDeadInstanceData is called\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acb48aadbaaece1c721a875b4a7504081138b311"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0NzAyNA==", "bodyText": "Both names are equally descriptive. Thank you.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414847024", "createdAt": "2020-04-24T20:34:52Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA2ODk3NQ=="}, "originalCommit": {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMjU2ODMz", "url": "https://github.com/linkedin/brooklin/pull/703#pullrequestreview-400256833", "createdAt": "2020-04-24T20:40:57Z", "commit": {"oid": "acb48aadbaaece1c721a875b4a7504081138b311"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDo0MDo1OFrOGLocmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDo0MDo1OFrOGLocmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1MDIwMw==", "bodyText": "Rename to liveInstances", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414850203", "createdAt": "2020-04-24T20:40:58Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,65 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n+   * @param previousAssignmentByInstance Previous task assignment\n+   * @param newAssignmentsByInstance New task assignment.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n-    List<String> deadInstances = getAllInstances();\n+  public void cleanUpDeadInstanceDataAndOtherUnusedTasks(\n+      Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+      Map<String, List<DatastreamTask>> newAssignmentsByInstance,\n+      List<String> instances) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acb48aadbaaece1c721a875b4a7504081138b311"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMjU3MTQz", "url": "https://github.com/linkedin/brooklin/pull/703#pullrequestreview-400257143", "createdAt": "2020-04-24T20:41:29Z", "commit": {"oid": "acb48aadbaaece1c721a875b4a7504081138b311"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1defe95d43235e133117095e644770a193a311b", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/b1defe95d43235e133117095e644770a193a311b", "committedDate": "2020-04-24T22:29:24Z", "message": "Address PR Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9989fd1f007427d4bf2253343e33e5d883aa13a", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/e9989fd1f007427d4bf2253343e33e5d883aa13a", "committedDate": "2020-04-24T22:54:49Z", "message": "Address PR Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMzEzOTk4", "url": "https://github.com/linkedin/brooklin/pull/703#pullrequestreview-400313998", "createdAt": "2020-04-24T22:55:43Z", "commit": {"oid": "e9989fd1f007427d4bf2253343e33e5d883aa13a"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjE5OTI1", "url": "https://github.com/linkedin/brooklin/pull/703#pullrequestreview-402219925", "createdAt": "2020-04-28T21:19:26Z", "commit": {"oid": "e9989fd1f007427d4bf2253343e33e5d883aa13a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToxOToyNlrOGNnXGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToxOTo1NlrOGNnX_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTU2MQ==", "bodyText": "Can you add logs for when this starts and when this completes? Want to be able to figure out how long this process takes", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416929561", "createdAt": "2020-04-28T21:19:26Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -867,29 +908,56 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n         _liveTaskMap.remove(instance);\n       }\n     }\n+    LOG.debug(\"unusedTasks remaining after dead instances cleanup: {}\", unusedTasks.stream()\n+        .map(DatastreamTask::getDatastreamTaskName)\n+        .collect(Collectors.toList()));\n+    // Clean the remaining unusedTasks.\n+    cleanUpOldUnusedTasksFromConnector(unusedTasks);\n+    LOG.info(\"cleanUpDeadInstanceDataAndOtherUnusedTasks completed successfully.\");\n   }\n \n   /**\n+   * It finds old unused tasks.\n+   *\n    * New assignment may not contain all the tasks from the previous assignment. This means that the diff of the\n    * tasks between the new and old assignment are not used any more which can be deleted.\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n+   * @return Tasks absent in newAssignment but present in oldAssignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  private Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {}\", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  private void cleanUpOldUnusedTasksFromConnector(Collection<DatastreamTask> unusedTasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9989fd1f007427d4bf2253343e33e5d883aa13a"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTc4OQ==", "bodyText": "Can you add a log before this so that we can find out how long the previous phase of cleanup took? I am concerned that we are increasing the time it will take to cleanup the dead instances, which can lead to handleDoLeaderAssignmentChange failures that can wedge the cluster into a bad state requiring a cluster restart. We should have sufficient logging to understand how long each phase takes in case we need to make a call later on about preventing such stages from getting interrupted in the first place.", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416929789", "createdAt": "2020-04-28T21:19:56Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -867,29 +908,56 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n         _liveTaskMap.remove(instance);\n       }\n     }\n+    LOG.debug(\"unusedTasks remaining after dead instances cleanup: {}\", unusedTasks.stream()\n+        .map(DatastreamTask::getDatastreamTaskName)\n+        .collect(Collectors.toList()));\n+    // Clean the remaining unusedTasks.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9989fd1f007427d4bf2253343e33e5d883aa13a"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0054b5dc29f90efa06a4e5350a85dcf0c73b5989", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/0054b5dc29f90efa06a4e5350a85dcf0c73b5989", "committedDate": "2020-04-28T21:47:53Z", "message": "Address PR Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjQ0NjMy", "url": "https://github.com/linkedin/brooklin/pull/703#pullrequestreview-402244632", "createdAt": "2020-04-28T22:02:51Z", "commit": {"oid": "0054b5dc29f90efa06a4e5350a85dcf0c73b5989"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjQ2MjI5", "url": "https://github.com/linkedin/brooklin/pull/703#pullrequestreview-402246229", "createdAt": "2020-04-28T22:05:56Z", "commit": {"oid": "0054b5dc29f90efa06a4e5350a85dcf0c73b5989"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 422, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}