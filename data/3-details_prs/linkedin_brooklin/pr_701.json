{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMDcxOTUw", "number": 701, "title": "Fix broken Coordinator metrics", "bodyText": "This change fixes a number of broken connector metrics that were\nnot being emitted to ingraphs because they were not included among\nthe metrics the Coordinator returned in Coordinator.getMetricInfos().\nThe fix changes the way metrics are registered and updated in the\nCoordinator to reduce the chances of developer oversight.\nIn particular, before this change, adding a new metric required:\n\nUsing _dynamicMetricsManager to create/update the metric\nAdding the metric to the list returned by Coordinator.getMetricInfos()\n(or making sure it's already covered by an existing wildcard/regex metric)\n\nIt's a two-step process because step 1 creates/updates JMX metrics\nfor Brooklin, whereas step 2 makes sure those JMX metric are exposed\nto ingraphs at LinkedIn.\nWhile that setup is understandable, it is fairly error-prone because\nevery developer adding a new metric has to understand how metrics\nwork and remember to add that metric to getMetricInfos().\nThis change is an attempt to move all metric registration and updates\nto one source-of-truth class, CoordinatorMetrics, that:\n\nPopulates all metrics exposed by CheckpointProvider, EventProducer,\nTransportProviders, and Authorizer\nRegisters all gauge metrics emitted by the Coordinator\nDefines three enum types that represent all the metric types emitted by\nthe Coordinator: Meter, KeyedMeter, and Counter.\nExposes methods for updating the values of all three types of metrics:\nupdateMeter(), updateKeyedMeter(), and updateCounter().\n\nWith this change, adding a new metric only requires adding a new enum\nvalue to the enum type that corresponds to the desired metric type. This\ntakes care of registering it with the _dynamicMetricsManager and adding\nit to the list of metrics returned by getMetricInfos().", "createdAt": "2020-04-14T09:28:51Z", "url": "https://github.com/linkedin/brooklin/pull/701", "merged": true, "mergeCommit": {"oid": "ecdb28508d8bc7b126bb67fe6c0d1e6b3bd481b7"}, "closed": true, "closedAt": "2020-05-04T18:37:42Z", "author": {"login": "ahmedahamid"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXhDIvAH2gAyNDAzMDcxOTUwOjU3NTk1MTI0MDNiODc5MWFlNmNjZDZkNzM1MDJhZjczMzQ0YWQzYjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABceBhDUgFqTQwNTExNjM0NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5759512403b8791ae6ccd6d73502af73344ad3b0", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/5759512403b8791ae6ccd6d73502af73344ad3b0", "committedDate": "2020-04-14T10:36:38Z", "message": "Fix broken Coordinator metrics\n\nThis change fixes a number of broken connector metrics that were\nnot being emitted to ingraphs because they were not included among\nthe metrics the Coordinator returned in Coordinator.getMetricInfos().\nThe fix changes the way metrics are registered and updated in the\nCoordinator to reduce the chances of developer oversight."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "665b8471568185db18877dda00adf2258ba5828e", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/665b8471568185db18877dda00adf2258ba5828e", "committedDate": "2020-04-14T08:48:37Z", "message": "Fix broken Coordinator metrics\n\nThis change fixes a number of broken connector metrics that were\nnot being emitted to ingraphs because they were not included among\nthe metrics the Coordinator returned in Coordinator.getMetricInfos().\nThe fix changes the way metrics are registered and updated in the\nCoordinator to reduce the chances of developer oversight."}, "afterCommit": {"oid": "5759512403b8791ae6ccd6d73502af73344ad3b0", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/5759512403b8791ae6ccd6d73502af73344ad3b0", "committedDate": "2020-04-14T10:36:38Z", "message": "Fix broken Coordinator metrics\n\nThis change fixes a number of broken connector metrics that were\nnot being emitted to ingraphs because they were not included among\nthe metrics the Coordinator returned in Coordinator.getMetricInfos().\nThe fix changes the way metrics are registered and updated in the\nCoordinator to reduce the chances of developer oversight."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjU5NTAx", "url": "https://github.com/linkedin/brooklin/pull/701#pullrequestreview-402259501", "createdAt": "2020-04-28T22:33:40Z", "commit": {"oid": "5759512403b8791ae6ccd6d73502af73344ad3b0"}, "state": "DISMISSED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjozMzo0MFrOGNpdmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowMDo0NlrOGNqFhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2Mzk5Mg==", "bodyText": "typo: NUM_REBLANCES to NUM_REBALANCES", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r416963992", "createdAt": "2020-04-28T22:33:40Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -1685,4 +1632,234 @@ ZkAdapter getZkAdapter() {\n   CoordinatorConfig getConfig() {\n     return _config;\n   }\n+\n+  /**\n+   * Encapsulates metric registration and update for the {@link Coordinator}\n+   */\n+  private static class CoordinatorMetrics {\n+    private static final String MODULE = Coordinator.class.getSimpleName();\n+\n+    private static final String NUM_RETRIES = \"numRetries\";\n+    private static final String NUM_ERRORS = \"numErrors\";\n+    private static final String HANDLE_EVENT_PREFIX = \"handleEvent\";\n+\n+    // Gauge metrics\n+    private static final String MAX_PARTITION_COUNT_IN_TASK = \"maxPartitionCountInTask\";\n+    private static final String NUM_PAUSED_DATASTREAMS_GROUPS = \"numPausedDatastreamsGroups\";\n+    private static final String IS_LEADER = \"isLeader\";\n+\n+    // Connector common metrics\n+    private static final String NUM_DATASTREAMS = \"numDatastreams\";\n+    private static final String NUM_DATASTREAM_TASKS = \"numDatastreamTasks\";\n+\n+    private final Coordinator _coordinator;\n+    private final List<BrooklinMetricInfo> _metricInfos;\n+    private final DynamicMetricsManager _dynamicMetricsManager;\n+\n+    public CoordinatorMetrics(Coordinator coordinator) {\n+      _coordinator = coordinator;\n+      _metricInfos = new ArrayList<>();\n+      _dynamicMetricsManager = DynamicMetricsManager.getInstance();\n+\n+      addComponentMetricInfos();\n+\n+      registerMeterMetrics();\n+      registerKeyedMeterMetrics();\n+      registerGaugeMetrics();\n+      registerCounterMetrics();\n+    }\n+\n+    public void addMetricInfos(MetricsAware metricsAware) {\n+      Optional.ofNullable(metricsAware.getMetricInfos()).ifPresent(_metricInfos::addAll);\n+    }\n+\n+    public void addConnectorMetrics(ConnectorInfo connectorInfo) {\n+      addMetricInfos(connectorInfo.getConnector().getConnectorInstance());\n+\n+      // Register common connector metrics\n+      // Use connector name for the metrics, as there can be multiple connectors specified in the config that use\n+      // same connector class.\n+      String connectorName = connectorInfo.getConnectorType();\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAMS,\n+          () -> connectorInfo.getConnector().getNumDatastreams());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAMS)));\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAM_TASKS,\n+          () -> connectorInfo.getConnector().getNumDatastreamTasks());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAM_TASKS)));\n+    }\n+\n+    public List<BrooklinMetricInfo> getMetricInfos() {\n+      return Collections.unmodifiableList(_metricInfos);\n+    }\n+\n+    public void updateMeter(Meter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getName(), value);\n+    }\n+\n+    public void updateKeyedMeter(KeyedMeter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getKey(), metric.getName(), value);\n+    }\n+\n+    public void updateCounter(Counter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateCounter(MODULE, metric.getName(), value);\n+    }\n+\n+    public static KeyedMeter getKeyedMeter(EventType eventType) {\n+      switch (eventType) {\n+        case LEADER_DO_ASSIGNMENT:\n+          return KeyedMeter.LEADER_DO_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_ASSIGNMENT:\n+          return KeyedMeter.LEADER_PARTITION_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_MOVEMENT:\n+          return KeyedMeter.LEADER_PARTITION_MOVEMENT_NUM_ERRORS;\n+        case HANDLE_ASSIGNMENT_CHANGE:\n+          return KeyedMeter.HANDLE_ASSIGNMENT_CHANGE_NUM_ERRORS;\n+        case HANDLE_DATASTREAM_CHANGE_WITH_UPDATE:\n+          return KeyedMeter.HANDLE_DATASTREAM_CHANGE_WITH_UPDATE_NUM_ERRORS;\n+        case HANDLE_ADD_OR_DELETE_DATASTREAM:\n+          return KeyedMeter.HANDLE_ADD_OR_DELETE_DATASTREAM_NUM_ERRORS;\n+        case HANDLE_INSTANCE_ERROR:\n+          return KeyedMeter.HANDLE_INSTANCE_ERROR_NUM_ERRORS;\n+        case HEARTBEAT:\n+          return KeyedMeter.HEARTBEAT_NUM_ERRORS;\n+        case NO_OP:\n+          return KeyedMeter.NO_OP_NUM_ERRORS;\n+        default:\n+          throw new IllegalArgumentException(\"Unexpected Coordinator event type: \" + eventType);\n+      }\n+    }\n+\n+    private void addComponentMetricInfos() {\n+      // CheckpointProvider metrics\n+      addMetricInfos(_coordinator._cpProvider);\n+\n+      // EventProducer metrics\n+      _metricInfos.addAll(EventProducer.getMetricInfos());\n+    }\n+\n+    private void registerMeterMetrics() {\n+      Arrays.stream(Meter.values()).forEach(this::registerMeter);\n+    }\n+\n+    private void registerKeyedMeterMetrics() {\n+      Arrays.stream(KeyedMeter.values()).forEach(this::registerKeyedMeter);\n+    }\n+\n+    private void registerGaugeMetrics() {\n+      ImmutableMap<String, Supplier<?>> gaugeMetrics = ImmutableMap.<String, Supplier<?>>builder()\n+          .put(MAX_PARTITION_COUNT_IN_TASK, MAX_PARTITION_COUNT::get)\n+          .put(NUM_PAUSED_DATASTREAMS_GROUPS, PAUSED_DATASTREAMS_GROUPS::get)\n+          .put(IS_LEADER, () -> _coordinator.getIsLeader().getAsBoolean() ? 1 : 0)\n+          .build();\n+      gaugeMetrics.forEach(this::registerGauge);\n+    }\n+\n+    private void registerCounterMetrics() {\n+      Arrays.stream(Counter.values()).forEach(this::registerCounter);\n+    }\n+\n+    private void registerMeter(Meter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerKeyedMeter(KeyedMeter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metric.getKey(), metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerGauge(String metricName, Supplier<?> valueSupplier) {\n+      _dynamicMetricsManager.registerGauge(MODULE, metricName, valueSupplier);\n+      _metricInfos.add(new BrooklinGaugeInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerCounter(Counter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Counter.class);\n+      _metricInfos.add(new BrooklinCounterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    /**\n+     * Coordinator metrics of type {@link com.codahale.metrics.Meter}\n+     */\n+    public enum Meter {\n+      NUM_REBLANCES(\"numRebalances\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5759512403b8791ae6ccd6d73502af73344ad3b0"}, "originalPosition": 496}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2NjIxOA==", "bodyText": "this should be \"handleEvent-\" to avoid regression. If this metrics is present in any dashboard, it will fail.", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r416966218", "createdAt": "2020-04-28T22:39:31Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -1685,4 +1632,234 @@ ZkAdapter getZkAdapter() {\n   CoordinatorConfig getConfig() {\n     return _config;\n   }\n+\n+  /**\n+   * Encapsulates metric registration and update for the {@link Coordinator}\n+   */\n+  private static class CoordinatorMetrics {\n+    private static final String MODULE = Coordinator.class.getSimpleName();\n+\n+    private static final String NUM_RETRIES = \"numRetries\";\n+    private static final String NUM_ERRORS = \"numErrors\";\n+    private static final String HANDLE_EVENT_PREFIX = \"handleEvent\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5759512403b8791ae6ccd6d73502af73344ad3b0"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTE2Ng==", "bodyText": "do you need it to be public or can you change to package-private?", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r416971166", "createdAt": "2020-04-28T22:52:11Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -1685,4 +1632,234 @@ ZkAdapter getZkAdapter() {\n   CoordinatorConfig getConfig() {\n     return _config;\n   }\n+\n+  /**\n+   * Encapsulates metric registration and update for the {@link Coordinator}\n+   */\n+  private static class CoordinatorMetrics {\n+    private static final String MODULE = Coordinator.class.getSimpleName();\n+\n+    private static final String NUM_RETRIES = \"numRetries\";\n+    private static final String NUM_ERRORS = \"numErrors\";\n+    private static final String HANDLE_EVENT_PREFIX = \"handleEvent\";\n+\n+    // Gauge metrics\n+    private static final String MAX_PARTITION_COUNT_IN_TASK = \"maxPartitionCountInTask\";\n+    private static final String NUM_PAUSED_DATASTREAMS_GROUPS = \"numPausedDatastreamsGroups\";\n+    private static final String IS_LEADER = \"isLeader\";\n+\n+    // Connector common metrics\n+    private static final String NUM_DATASTREAMS = \"numDatastreams\";\n+    private static final String NUM_DATASTREAM_TASKS = \"numDatastreamTasks\";\n+\n+    private final Coordinator _coordinator;\n+    private final List<BrooklinMetricInfo> _metricInfos;\n+    private final DynamicMetricsManager _dynamicMetricsManager;\n+\n+    public CoordinatorMetrics(Coordinator coordinator) {\n+      _coordinator = coordinator;\n+      _metricInfos = new ArrayList<>();\n+      _dynamicMetricsManager = DynamicMetricsManager.getInstance();\n+\n+      addComponentMetricInfos();\n+\n+      registerMeterMetrics();\n+      registerKeyedMeterMetrics();\n+      registerGaugeMetrics();\n+      registerCounterMetrics();\n+    }\n+\n+    public void addMetricInfos(MetricsAware metricsAware) {\n+      Optional.ofNullable(metricsAware.getMetricInfos()).ifPresent(_metricInfos::addAll);\n+    }\n+\n+    public void addConnectorMetrics(ConnectorInfo connectorInfo) {\n+      addMetricInfos(connectorInfo.getConnector().getConnectorInstance());\n+\n+      // Register common connector metrics\n+      // Use connector name for the metrics, as there can be multiple connectors specified in the config that use\n+      // same connector class.\n+      String connectorName = connectorInfo.getConnectorType();\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAMS,\n+          () -> connectorInfo.getConnector().getNumDatastreams());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAMS)));\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAM_TASKS,\n+          () -> connectorInfo.getConnector().getNumDatastreamTasks());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAM_TASKS)));\n+    }\n+\n+    public List<BrooklinMetricInfo> getMetricInfos() {\n+      return Collections.unmodifiableList(_metricInfos);\n+    }\n+\n+    public void updateMeter(Meter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getName(), value);\n+    }\n+\n+    public void updateKeyedMeter(KeyedMeter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getKey(), metric.getName(), value);\n+    }\n+\n+    public void updateCounter(Counter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateCounter(MODULE, metric.getName(), value);\n+    }\n+\n+    public static KeyedMeter getKeyedMeter(EventType eventType) {\n+      switch (eventType) {\n+        case LEADER_DO_ASSIGNMENT:\n+          return KeyedMeter.LEADER_DO_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_ASSIGNMENT:\n+          return KeyedMeter.LEADER_PARTITION_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_MOVEMENT:\n+          return KeyedMeter.LEADER_PARTITION_MOVEMENT_NUM_ERRORS;\n+        case HANDLE_ASSIGNMENT_CHANGE:\n+          return KeyedMeter.HANDLE_ASSIGNMENT_CHANGE_NUM_ERRORS;\n+        case HANDLE_DATASTREAM_CHANGE_WITH_UPDATE:\n+          return KeyedMeter.HANDLE_DATASTREAM_CHANGE_WITH_UPDATE_NUM_ERRORS;\n+        case HANDLE_ADD_OR_DELETE_DATASTREAM:\n+          return KeyedMeter.HANDLE_ADD_OR_DELETE_DATASTREAM_NUM_ERRORS;\n+        case HANDLE_INSTANCE_ERROR:\n+          return KeyedMeter.HANDLE_INSTANCE_ERROR_NUM_ERRORS;\n+        case HEARTBEAT:\n+          return KeyedMeter.HEARTBEAT_NUM_ERRORS;\n+        case NO_OP:\n+          return KeyedMeter.NO_OP_NUM_ERRORS;\n+        default:\n+          throw new IllegalArgumentException(\"Unexpected Coordinator event type: \" + eventType);\n+      }\n+    }\n+\n+    private void addComponentMetricInfos() {\n+      // CheckpointProvider metrics\n+      addMetricInfos(_coordinator._cpProvider);\n+\n+      // EventProducer metrics\n+      _metricInfos.addAll(EventProducer.getMetricInfos());\n+    }\n+\n+    private void registerMeterMetrics() {\n+      Arrays.stream(Meter.values()).forEach(this::registerMeter);\n+    }\n+\n+    private void registerKeyedMeterMetrics() {\n+      Arrays.stream(KeyedMeter.values()).forEach(this::registerKeyedMeter);\n+    }\n+\n+    private void registerGaugeMetrics() {\n+      ImmutableMap<String, Supplier<?>> gaugeMetrics = ImmutableMap.<String, Supplier<?>>builder()\n+          .put(MAX_PARTITION_COUNT_IN_TASK, MAX_PARTITION_COUNT::get)\n+          .put(NUM_PAUSED_DATASTREAMS_GROUPS, PAUSED_DATASTREAMS_GROUPS::get)\n+          .put(IS_LEADER, () -> _coordinator.getIsLeader().getAsBoolean() ? 1 : 0)\n+          .build();\n+      gaugeMetrics.forEach(this::registerGauge);\n+    }\n+\n+    private void registerCounterMetrics() {\n+      Arrays.stream(Counter.values()).forEach(this::registerCounter);\n+    }\n+\n+    private void registerMeter(Meter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerKeyedMeter(KeyedMeter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metric.getKey(), metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerGauge(String metricName, Supplier<?> valueSupplier) {\n+      _dynamicMetricsManager.registerGauge(MODULE, metricName, valueSupplier);\n+      _metricInfos.add(new BrooklinGaugeInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerCounter(Counter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Counter.class);\n+      _metricInfos.add(new BrooklinCounterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    /**\n+     * Coordinator metrics of type {@link com.codahale.metrics.Meter}\n+     */\n+    public enum Meter {\n+      NUM_REBLANCES(\"numRebalances\"),\n+      NUM_ASSIGNMENT_CHANGES(\"numAssignmentChanges\"),\n+      NUM_PARTITION_ASSIGNMENTS(\"numPartitionAssignments\"),\n+      NUM_PARTITION_MOVEMENTS(\"numPartitionMovements\");\n+\n+      private final String _name;\n+\n+      Meter(String name) {\n+        _name = name;\n+      }\n+\n+      public String getName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5759512403b8791ae6ccd6d73502af73344ad3b0"}, "originalPosition": 507}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDIxNQ==", "bodyText": "Do you need these enums to be public or can you change it to private?", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r416974215", "createdAt": "2020-04-28T23:00:46Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -1685,4 +1632,234 @@ ZkAdapter getZkAdapter() {\n   CoordinatorConfig getConfig() {\n     return _config;\n   }\n+\n+  /**\n+   * Encapsulates metric registration and update for the {@link Coordinator}\n+   */\n+  private static class CoordinatorMetrics {\n+    private static final String MODULE = Coordinator.class.getSimpleName();\n+\n+    private static final String NUM_RETRIES = \"numRetries\";\n+    private static final String NUM_ERRORS = \"numErrors\";\n+    private static final String HANDLE_EVENT_PREFIX = \"handleEvent\";\n+\n+    // Gauge metrics\n+    private static final String MAX_PARTITION_COUNT_IN_TASK = \"maxPartitionCountInTask\";\n+    private static final String NUM_PAUSED_DATASTREAMS_GROUPS = \"numPausedDatastreamsGroups\";\n+    private static final String IS_LEADER = \"isLeader\";\n+\n+    // Connector common metrics\n+    private static final String NUM_DATASTREAMS = \"numDatastreams\";\n+    private static final String NUM_DATASTREAM_TASKS = \"numDatastreamTasks\";\n+\n+    private final Coordinator _coordinator;\n+    private final List<BrooklinMetricInfo> _metricInfos;\n+    private final DynamicMetricsManager _dynamicMetricsManager;\n+\n+    public CoordinatorMetrics(Coordinator coordinator) {\n+      _coordinator = coordinator;\n+      _metricInfos = new ArrayList<>();\n+      _dynamicMetricsManager = DynamicMetricsManager.getInstance();\n+\n+      addComponentMetricInfos();\n+\n+      registerMeterMetrics();\n+      registerKeyedMeterMetrics();\n+      registerGaugeMetrics();\n+      registerCounterMetrics();\n+    }\n+\n+    public void addMetricInfos(MetricsAware metricsAware) {\n+      Optional.ofNullable(metricsAware.getMetricInfos()).ifPresent(_metricInfos::addAll);\n+    }\n+\n+    public void addConnectorMetrics(ConnectorInfo connectorInfo) {\n+      addMetricInfos(connectorInfo.getConnector().getConnectorInstance());\n+\n+      // Register common connector metrics\n+      // Use connector name for the metrics, as there can be multiple connectors specified in the config that use\n+      // same connector class.\n+      String connectorName = connectorInfo.getConnectorType();\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAMS,\n+          () -> connectorInfo.getConnector().getNumDatastreams());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAMS)));\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAM_TASKS,\n+          () -> connectorInfo.getConnector().getNumDatastreamTasks());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAM_TASKS)));\n+    }\n+\n+    public List<BrooklinMetricInfo> getMetricInfos() {\n+      return Collections.unmodifiableList(_metricInfos);\n+    }\n+\n+    public void updateMeter(Meter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getName(), value);\n+    }\n+\n+    public void updateKeyedMeter(KeyedMeter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getKey(), metric.getName(), value);\n+    }\n+\n+    public void updateCounter(Counter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateCounter(MODULE, metric.getName(), value);\n+    }\n+\n+    public static KeyedMeter getKeyedMeter(EventType eventType) {\n+      switch (eventType) {\n+        case LEADER_DO_ASSIGNMENT:\n+          return KeyedMeter.LEADER_DO_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_ASSIGNMENT:\n+          return KeyedMeter.LEADER_PARTITION_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_MOVEMENT:\n+          return KeyedMeter.LEADER_PARTITION_MOVEMENT_NUM_ERRORS;\n+        case HANDLE_ASSIGNMENT_CHANGE:\n+          return KeyedMeter.HANDLE_ASSIGNMENT_CHANGE_NUM_ERRORS;\n+        case HANDLE_DATASTREAM_CHANGE_WITH_UPDATE:\n+          return KeyedMeter.HANDLE_DATASTREAM_CHANGE_WITH_UPDATE_NUM_ERRORS;\n+        case HANDLE_ADD_OR_DELETE_DATASTREAM:\n+          return KeyedMeter.HANDLE_ADD_OR_DELETE_DATASTREAM_NUM_ERRORS;\n+        case HANDLE_INSTANCE_ERROR:\n+          return KeyedMeter.HANDLE_INSTANCE_ERROR_NUM_ERRORS;\n+        case HEARTBEAT:\n+          return KeyedMeter.HEARTBEAT_NUM_ERRORS;\n+        case NO_OP:\n+          return KeyedMeter.NO_OP_NUM_ERRORS;\n+        default:\n+          throw new IllegalArgumentException(\"Unexpected Coordinator event type: \" + eventType);\n+      }\n+    }\n+\n+    private void addComponentMetricInfos() {\n+      // CheckpointProvider metrics\n+      addMetricInfos(_coordinator._cpProvider);\n+\n+      // EventProducer metrics\n+      _metricInfos.addAll(EventProducer.getMetricInfos());\n+    }\n+\n+    private void registerMeterMetrics() {\n+      Arrays.stream(Meter.values()).forEach(this::registerMeter);\n+    }\n+\n+    private void registerKeyedMeterMetrics() {\n+      Arrays.stream(KeyedMeter.values()).forEach(this::registerKeyedMeter);\n+    }\n+\n+    private void registerGaugeMetrics() {\n+      ImmutableMap<String, Supplier<?>> gaugeMetrics = ImmutableMap.<String, Supplier<?>>builder()\n+          .put(MAX_PARTITION_COUNT_IN_TASK, MAX_PARTITION_COUNT::get)\n+          .put(NUM_PAUSED_DATASTREAMS_GROUPS, PAUSED_DATASTREAMS_GROUPS::get)\n+          .put(IS_LEADER, () -> _coordinator.getIsLeader().getAsBoolean() ? 1 : 0)\n+          .build();\n+      gaugeMetrics.forEach(this::registerGauge);\n+    }\n+\n+    private void registerCounterMetrics() {\n+      Arrays.stream(Counter.values()).forEach(this::registerCounter);\n+    }\n+\n+    private void registerMeter(Meter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerKeyedMeter(KeyedMeter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metric.getKey(), metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerGauge(String metricName, Supplier<?> valueSupplier) {\n+      _dynamicMetricsManager.registerGauge(MODULE, metricName, valueSupplier);\n+      _metricInfos.add(new BrooklinGaugeInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerCounter(Counter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Counter.class);\n+      _metricInfos.add(new BrooklinCounterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    /**\n+     * Coordinator metrics of type {@link com.codahale.metrics.Meter}\n+     */\n+    public enum Meter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5759512403b8791ae6ccd6d73502af73344ad3b0"}, "originalPosition": 495}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODgyNjU3", "url": "https://github.com/linkedin/brooklin/pull/701#pullrequestreview-402882657", "createdAt": "2020-04-29T17:26:13Z", "commit": {"oid": "5759512403b8791ae6ccd6d73502af73344ad3b0"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "675891c12fec3aa50aa21d082c29584e2fbfe17c", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/675891c12fec3aa50aa21d082c29584e2fbfe17c", "committedDate": "2020-04-30T19:49:07Z", "message": "Address PR review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NzEwMzg5", "url": "https://github.com/linkedin/brooklin/pull/701#pullrequestreview-404710389", "createdAt": "2020-05-04T05:02:41Z", "commit": {"oid": "675891c12fec3aa50aa21d082c29584e2fbfe17c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MTE2MzQ1", "url": "https://github.com/linkedin/brooklin/pull/701#pullrequestreview-405116345", "createdAt": "2020-05-04T15:49:49Z", "commit": {"oid": "675891c12fec3aa50aa21d082c29584e2fbfe17c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 417, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}