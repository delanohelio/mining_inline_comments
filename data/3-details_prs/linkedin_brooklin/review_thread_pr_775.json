{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1NDc1NzMz", "number": 775, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwMDowNDo1MVrOE2RrpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNDo1ODowMFrOE3jfPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MzQ4MjYxOnYy", "diffSide": "LEFT", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestStickyPartitionAssignment.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwMDowNDo1MVrOHvBEdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwMDowNDo1MVrOHvBEdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MjY0Nw==", "bodyText": "Nit: Avoid unnecessary changes to make reviews shorter.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r519062647", "createdAt": "2020-11-07T00:04:51Z", "author": {"login": "jzakaryan"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestStickyPartitionAssignment.java", "diffHunk": "@@ -182,14 +177,13 @@ public void testMovePartitionToInstanceWithoutTask() {\n         new DatastreamGroupPartitionsMetadata(datastreams.get(0), partitions);\n     // Generate partition assignment\n     assignment = strategy.assignPartitions(assignment, partitionsMetadata);\n-    assignment.put(\"empty\", new HashSet<DatastreamTask>());\n+    assignment.put(\"empty\", new HashSet<>());\n \n     Map<String, Set<String>> targetAssignment = new HashMap<>();\n     targetAssignment.put(\"empty\", ImmutableSet.of(\"t-3\", \"t-2\", \"t-1\", \"t-5\"));\n-    assignment = strategy.movePartitions(assignment, targetAssignment, partitionsMetadata);\n+    strategy.movePartitions(assignment, targetAssignment, partitionsMetadata);\n   }\n \n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTc5MjAyOnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzoxNDozMVrOHwzTTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjowNDoxNlrOHw4gvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDIyMg==", "bodyText": "nits: tasks to task", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520934222", "createdAt": "2020-11-10T23:14:31Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -151,11 +152,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Preprocess the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source task\n+   * Step 3) If the instance is the one we want to move, we choose a task to which we should assign the partition\n    *         from that instance\n-   * Step 3) Scan the current assignment, compute new task if the old task belongs to these source tasks or if it\n-   *         is the target task we want to move to\n+   * Step 4) Scan the current assignment, compute the new task if the old task belongs to this source tasks or if it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxOTU4Mw==", "bodyText": "done", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521019583", "createdAt": "2020-11-11T02:04:16Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -151,11 +152,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Preprocess the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source task\n+   * Step 3) If the instance is the one we want to move, we choose a task to which we should assign the partition\n    *         from that instance\n-   * Step 3) Scan the current assignment, compute new task if the old task belongs to these source tasks or if it\n-   *         is the target task we want to move to\n+   * Step 4) Scan the current assignment, compute the new task if the old task belongs to this source tasks or if it", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDIyMg=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTc5MzI1OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzoxNTowMVrOHwzUEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjowNDoxMFrOHw4gZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDQxOQ==", "bodyText": "nit: task to tasks, preprocess to pre-process", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520934419", "createdAt": "2020-11-10T23:15:01Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -151,11 +152,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Preprocess the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source task", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxOTQ5NA==", "bodyText": "done", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521019494", "createdAt": "2020-11-11T02:04:10Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -151,11 +152,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Preprocess the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source task", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDQxOQ=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTgwNzUzOnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzoyMDozM1rOHwzctg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMTo0NDozNlrOHw3rBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjYzMA==", "bodyText": "addAll with throw NullPointerException for the value set to null. The value is set to null for the instance where there is no movement.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520936630", "createdAt": "2020-11-10T23:20:33Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -170,17 +173,35 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n \n     DatastreamGroup dg = partitionsMetadata.getDatastreamGroup();\n \n+    // Pre-process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n+    // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on instance1\n+    // and is supposed to move to instance1, remove it from the targetAssignment as this should be a no-op.\n+    Map<String, Set<String>> preprocessedTargetAssignment = new HashMap<>();\n+    targetAssignment.forEach((instance, partitions) -> {\n+      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n+      Set<String> partitionsAcrossAllDatastreamTasks = tasks.stream().filter(dg::belongsTo)\n+          .map(DatastreamTask::getPartitionsV2).flatMap(Collection::stream).collect(Collectors.toSet());\n+\n+      Set<String> updatedTargetPartitionList = new HashSet<>(partitions);\n+      updatedTargetPartitionList.removeAll(partitionsAcrossAllDatastreamTasks);\n+\n+      preprocessedTargetAssignment.computeIfAbsent(instance,\n+          val -> updatedTargetPartitionList.isEmpty() ? null : updatedTargetPartitionList);\n+    });\n+\n+    LOG.info(\"The preprocessed targetAssignment: {}\", preprocessedTargetAssignment);\n+\n     Set<String> allToReassignPartitions = new HashSet<>();\n-    targetAssignment.values().forEach(allToReassignPartitions::addAll);\n+    preprocessedTargetAssignment.values().forEach(allToReassignPartitions::addAll);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1ODAwNQ==", "bodyText": "In the previous step, where we create preprocessedTargetAssignment, the computeIfAbsent does not add the key to the map if the computed value is null. I've modified this to filter out null values anyways just to be safe, but using addAll here without null checks should be safe.\nCode that updates preProcessedTargetAssignment:\n      preProcessedTargetAssignment.computeIfAbsent(instance,\n          val -> updatedTargetPartitionList.isEmpty() ? null : updatedTargetPartitionList);\n\nComments on computeIfAbsent:\n\n* If the specified key is not already associated with a value (or is mapped\n* to {@code null}), attempts to compute its value using the given mapping\n* function and enters it into this map unless {@code null}.\n\n\nI had also validated that conputeIfAbsent works as expected for null values using some test cases when writing the code.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520958005", "createdAt": "2020-11-11T00:21:09Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -170,17 +173,35 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n \n     DatastreamGroup dg = partitionsMetadata.getDatastreamGroup();\n \n+    // Pre-process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n+    // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on instance1\n+    // and is supposed to move to instance1, remove it from the targetAssignment as this should be a no-op.\n+    Map<String, Set<String>> preprocessedTargetAssignment = new HashMap<>();\n+    targetAssignment.forEach((instance, partitions) -> {\n+      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n+      Set<String> partitionsAcrossAllDatastreamTasks = tasks.stream().filter(dg::belongsTo)\n+          .map(DatastreamTask::getPartitionsV2).flatMap(Collection::stream).collect(Collectors.toSet());\n+\n+      Set<String> updatedTargetPartitionList = new HashSet<>(partitions);\n+      updatedTargetPartitionList.removeAll(partitionsAcrossAllDatastreamTasks);\n+\n+      preprocessedTargetAssignment.computeIfAbsent(instance,\n+          val -> updatedTargetPartitionList.isEmpty() ? null : updatedTargetPartitionList);\n+    });\n+\n+    LOG.info(\"The preprocessed targetAssignment: {}\", preprocessedTargetAssignment);\n+\n     Set<String> allToReassignPartitions = new HashSet<>();\n-    targetAssignment.values().forEach(allToReassignPartitions::addAll);\n+    preprocessedTargetAssignment.values().forEach(allToReassignPartitions::addAll);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjYzMA=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MTUwNg==", "bodyText": "Make sense. You can ignore this comment.\nFeel free to ignore this suggestion. Just wondering should we make this piece more simple and readable.\nif (!updatedTargetPartitionList.isEmpty()) {\npreProcessedTargetAssignment.put(instance, updatedTargetPartitionList);\n}", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520961506", "createdAt": "2020-11-11T00:31:47Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -170,17 +173,35 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n \n     DatastreamGroup dg = partitionsMetadata.getDatastreamGroup();\n \n+    // Pre-process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n+    // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on instance1\n+    // and is supposed to move to instance1, remove it from the targetAssignment as this should be a no-op.\n+    Map<String, Set<String>> preprocessedTargetAssignment = new HashMap<>();\n+    targetAssignment.forEach((instance, partitions) -> {\n+      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n+      Set<String> partitionsAcrossAllDatastreamTasks = tasks.stream().filter(dg::belongsTo)\n+          .map(DatastreamTask::getPartitionsV2).flatMap(Collection::stream).collect(Collectors.toSet());\n+\n+      Set<String> updatedTargetPartitionList = new HashSet<>(partitions);\n+      updatedTargetPartitionList.removeAll(partitionsAcrossAllDatastreamTasks);\n+\n+      preprocessedTargetAssignment.computeIfAbsent(instance,\n+          val -> updatedTargetPartitionList.isEmpty() ? null : updatedTargetPartitionList);\n+    });\n+\n+    LOG.info(\"The preprocessed targetAssignment: {}\", preprocessedTargetAssignment);\n+\n     Set<String> allToReassignPartitions = new HashSet<>();\n-    targetAssignment.values().forEach(allToReassignPartitions::addAll);\n+    preprocessedTargetAssignment.values().forEach(allToReassignPartitions::addAll);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjYzMA=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAwNTgzMQ==", "bodyText": "I sort of prefer computeIfAbsent here, so will leave this as is.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521005831", "createdAt": "2020-11-11T01:44:36Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -170,17 +173,35 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n \n     DatastreamGroup dg = partitionsMetadata.getDatastreamGroup();\n \n+    // Pre-process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n+    // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on instance1\n+    // and is supposed to move to instance1, remove it from the targetAssignment as this should be a no-op.\n+    Map<String, Set<String>> preprocessedTargetAssignment = new HashMap<>();\n+    targetAssignment.forEach((instance, partitions) -> {\n+      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n+      Set<String> partitionsAcrossAllDatastreamTasks = tasks.stream().filter(dg::belongsTo)\n+          .map(DatastreamTask::getPartitionsV2).flatMap(Collection::stream).collect(Collectors.toSet());\n+\n+      Set<String> updatedTargetPartitionList = new HashSet<>(partitions);\n+      updatedTargetPartitionList.removeAll(partitionsAcrossAllDatastreamTasks);\n+\n+      preprocessedTargetAssignment.computeIfAbsent(instance,\n+          val -> updatedTargetPartitionList.isEmpty() ? null : updatedTargetPartitionList);\n+    });\n+\n+    LOG.info(\"The preprocessed targetAssignment: {}\", preprocessedTargetAssignment);\n+\n     Set<String> allToReassignPartitions = new HashSet<>();\n-    targetAssignment.values().forEach(allToReassignPartitions::addAll);\n+    preprocessedTargetAssignment.values().forEach(allToReassignPartitions::addAll);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjYzMA=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTgxMzM0OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzoyMjo0N1rOHwzf9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjowNDoyMVrOHw4hAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNzQ2Mg==", "bodyText": "Can you merge these two lines?", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520937462", "createdAt": "2020-11-10T23:22:47Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -170,17 +173,35 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n \n     DatastreamGroup dg = partitionsMetadata.getDatastreamGroup();\n \n+    // Pre-process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n+    // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on instance1\n+    // and is supposed to move to instance1, remove it from the targetAssignment as this should be a no-op.\n+    Map<String, Set<String>> preprocessedTargetAssignment = new HashMap<>();\n+    targetAssignment.forEach((instance, partitions) -> {\n+      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n+      Set<String> partitionsAcrossAllDatastreamTasks = tasks.stream().filter(dg::belongsTo)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxOTY0OQ==", "bodyText": "done", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521019649", "createdAt": "2020-11-11T02:04:21Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -170,17 +173,35 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n \n     DatastreamGroup dg = partitionsMetadata.getDatastreamGroup();\n \n+    // Pre-process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n+    // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on instance1\n+    // and is supposed to move to instance1, remove it from the targetAssignment as this should be a no-op.\n+    Map<String, Set<String>> preprocessedTargetAssignment = new HashMap<>();\n+    targetAssignment.forEach((instance, partitions) -> {\n+      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n+      Set<String> partitionsAcrossAllDatastreamTasks = tasks.stream().filter(dg::belongsTo)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNzQ2Mg=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTg3MjM2OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzo0NzoxNlrOHw0DJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNTozMToyMFrOHw-xwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjQ2OA==", "bodyText": "I feel we can avoid splitting this in two steps. Please check and let me know your opinion.\n    // If the partitions cannot be found from any task, we ignore these partitions\n    currentAssignment.keySet().forEach(instance -> {\n      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n      Set<String> partitionsAcrossAllDatastreamTasks = currentAssignment.get(instance).stream().filter(dg::belongsTo)\n          .map(DatastreamTask::getPartitionsV2).flatMap(Collection::stream).collect(Collectors.toSet());\n      //Remove the partitions that do not need migration.\n      allToReassignPartitions.removeAll(partitionsAcrossAllDatastreamTasks);\n      tasks.forEach(task -> {\n        if (dg.belongsTo(task)) {\n          Set<String> toMovePartitions = new HashSet<>(task.getPartitionsV2());\n          toMovePartitions.retainAll(allToReassignPartitions);\n          if (!toMovePartitions.isEmpty()) {\n            // Only update the confirmedPartitionsTaskMap if a partition is indeed being deleted from it\n            confirmedPartitionsTaskMap.put(task.getDatastreamTaskName(), toMovePartitions);\n            toMovePartitions.forEach(p -> partitionToSourceTaskMap.put(p, (DatastreamTaskImpl) task));\n          }\n        }\n      });\n    });`", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520946468", "createdAt": "2020-11-10T23:47:16Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -190,15 +211,18 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n         if (dg.belongsTo(task)) {\n           Set<String> toMovePartitions = new HashSet<>(task.getPartitionsV2());\n           toMovePartitions.retainAll(allToReassignPartitions);\n-          confirmedPartitionsTaskMap.put(task.getDatastreamTaskName(), toMovePartitions);\n-          toMovePartitions.forEach(p -> partitionToSourceTaskMap.put(p, task.getDatastreamTaskName()));\n+          if (!toMovePartitions.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAwNTA2Mg==", "bodyText": "I tried this as is, but it doesn't work (preprocessedTargetAssignment is used in a later step, so I also added code here to create this too - but that isn't what kept breaking) and it's also getting very tricky to get it to work. Just removing the partitionsAcrossAllDatastreamTasks from allToReassignPartitions results in allToReassignPartitions becoming empty by the end of the lambda. I tried creating a copy of allToReassignPartitions too, and removed from that, but  the logic wasn't correct. Tried to retain all of partitionsAcrossAllDatastreamTasks, then there are issues with creating the confirmedPartitionsTaskMap, and when I try to fix that then I see that some partitions are completely removed from the final assignment, etc.\nAt least for me, this code is quite tricky to reason with, so the two step assignment just feels cleaner and easier to understand. It may be okay to perform a two step process here, since it's just recalculating the assignments. What do you think?", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521005062", "createdAt": "2020-11-11T01:43:30Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -190,15 +211,18 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n         if (dg.belongsTo(task)) {\n           Set<String> toMovePartitions = new HashSet<>(task.getPartitionsV2());\n           toMovePartitions.retainAll(allToReassignPartitions);\n-          confirmedPartitionsTaskMap.put(task.getDatastreamTaskName(), toMovePartitions);\n-          toMovePartitions.forEach(p -> partitionToSourceTaskMap.put(p, task.getDatastreamTaskName()));\n+          if (!toMovePartitions.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjQ2OA=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA0OTU4NQ==", "bodyText": "Found a way to make this work. Silly me should have tried moving the update of allToReassignPartitions to within the targetAssignment.containsKey() block.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521049585", "createdAt": "2020-11-11T02:48:56Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -190,15 +211,18 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n         if (dg.belongsTo(task)) {\n           Set<String> toMovePartitions = new HashSet<>(task.getPartitionsV2());\n           toMovePartitions.retainAll(allToReassignPartitions);\n-          confirmedPartitionsTaskMap.put(task.getDatastreamTaskName(), toMovePartitions);\n-          toMovePartitions.forEach(p -> partitionToSourceTaskMap.put(p, task.getDatastreamTaskName()));\n+          if (!toMovePartitions.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjQ2OA=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMzU0OQ==", "bodyText": "Can you please check this code block? This logic is correct (with one minor addition required) but not so easy to get it.\n if (targetAssignment.containsKey(instance)) {\n        // Process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n        // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on\n        // instance1 and is supposed to move to instance1, remove it from the targetAssignment as this should be a\n        // no-op. Accordingly the allToReassignPartitions should also be updated to remove such partitions.\n        //Partitions not suppose to move\n        Set<String> partitionsRemovedFromTargetAssignment = new HashSet<>(targetAssignment.get(instance));\n        partitionsRemovedFromTargetAssignment.retainAll(partitionsAcrossAllDatastreamTasks);\n\n        Set<String> updatedTargetPartitionList = new HashSet<>(targetAssignment.get(instance));\n        updatedTargetPartitionList.removeAll(partitionsRemovedFromTargetAssignment);\n        // filter invalid partitions\n        updatedTargetPartitionList.retainAll(allToReassignPartitions);\n\n        processedTargetAssignment.computeIfAbsent(instance,\n            val -> updatedTargetPartitionList.isEmpty() ? null : updatedTargetPartitionList);\n\n        allToReassignPartitions.removeAll(partitionsRemovedFromTargetAssignment);\n      }`\n\nIn this, I have reordered your calls,\na. first find the partitions  from the target, which are not moving. \nb. Remove these partitions from the targetAssignment and retain  only the valid partitions in allToReassignPartitions (missing in your code) and save it in updatedTargetPartitionList\nc. Remove these partitions from allToReassignPartitions", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521113549", "createdAt": "2020-11-11T04:57:19Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -190,15 +211,18 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n         if (dg.belongsTo(task)) {\n           Set<String> toMovePartitions = new HashSet<>(task.getPartitionsV2());\n           toMovePartitions.retainAll(allToReassignPartitions);\n-          confirmedPartitionsTaskMap.put(task.getDatastreamTaskName(), toMovePartitions);\n-          toMovePartitions.forEach(p -> partitionToSourceTaskMap.put(p, task.getDatastreamTaskName()));\n+          if (!toMovePartitions.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjQ2OA=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyMjI0MA==", "bodyText": "done.\n\nb. Remove these partitions from the targetAssignment and retain  only the valid partitions in allToReassignPartitions (missing in your code) and save it in updatedTargetPartitionList\n\nThat step isn't really necessary (though I added it) since allToReassignPartitions has already filtered out invalid partitions, and all the other data-structures are created based on this.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521122240", "createdAt": "2020-11-11T05:31:20Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -190,15 +211,18 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n         if (dg.belongsTo(task)) {\n           Set<String> toMovePartitions = new HashSet<>(task.getPartitionsV2());\n           toMovePartitions.retainAll(allToReassignPartitions);\n-          confirmedPartitionsTaskMap.put(task.getDatastreamTaskName(), toMovePartitions);\n-          toMovePartitions.forEach(p -> partitionToSourceTaskMap.put(p, task.getDatastreamTaskName()));\n+          if (!toMovePartitions.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjQ2OA=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTg4MDQ4OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzo1MDo0MlrOHw0Hvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMTo0Nzo1MVrOHw3z2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NzY0Nw==", "bodyText": "Sorry for my ignorance. I'm not able to find anything changing in the next few code diff blocks, except empty lines. Just want to be sure that I'm not missing anything.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520947647", "createdAt": "2020-11-10T23:50:42Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -228,37 +251,39 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n           .reduce((task1, task2) -> task1.getPartitionsV2().size() < task2.getPartitionsV2().size() ? task1 : task2)\n           .get() : null;\n \n-        // compute new assignment for that instance\n-        Set<DatastreamTask> newAssignedTask = tasks.stream().map(task -> {\n-          if (!dg.belongsTo(task)) {\n-            return task;\n-          }\n-          boolean partitionChanged = false;\n-          List<String> newPartitions = new ArrayList<>(task.getPartitionsV2());\n-          Set<String> extraDependencies = new HashSet<>();\n+      // compute new assignment for that instance\n+      Set<DatastreamTask> newAssignedTask = tasks.stream().map(task -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAwODA4OA==", "bodyText": "yeah sorry, there was an indentation issue in this part of the code, so just fixed that. next time i'll do this as part of a separate change.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521008088", "createdAt": "2020-11-11T01:47:51Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -228,37 +251,39 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n           .reduce((task1, task2) -> task1.getPartitionsV2().size() < task2.getPartitionsV2().size() ? task1 : task2)\n           .get() : null;\n \n-        // compute new assignment for that instance\n-        Set<DatastreamTask> newAssignedTask = tasks.stream().map(task -> {\n-          if (!dg.belongsTo(task)) {\n-            return task;\n-          }\n-          boolean partitionChanged = false;\n-          List<String> newPartitions = new ArrayList<>(task.getPartitionsV2());\n-          Set<String> extraDependencies = new HashSet<>();\n+      // compute new assignment for that instance\n+      Set<DatastreamTask> newAssignedTask = tasks.stream().map(task -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NzY0Nw=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTg4Mjc4OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzo1MTo0N1rOHw0JJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjowNTozMVrOHw4kOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODAwNw==", "bodyText": "nit: mockZkAdapter2 to mockZkAdapter0", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520948007", "createdAt": "2020-11-10T23:51:47Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMDQ3NA==", "bodyText": "moved to a separate function", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521020474", "createdAt": "2020-11-11T02:05:31Z", "author": {"login": "somandal"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODAwNw=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTg4NzYxOnYy", "diffSide": "RIGHT", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzo1NDowMVrOHw0MDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjowNTozOFrOHw4kjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODc1MA==", "bodyText": "Nit: Not your fault, Do you think this test can be changed to validate the exception using AssertThrows to ensure that all the blocks including the new code is getting executed.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520948750", "createdAt": "2020-11-10T23:54:01Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMDU1Nw==", "bodyText": "done", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521020557", "createdAt": "2020-11-11T02:05:38Z", "author": {"login": "somandal"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODc1MA=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTg4OTE3OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzo1NDozNFrOHw0M3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjowNTo0NFrOHw4kyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODk1OA==", "bodyText": "same nit: mockZkAdapter2 to 0, here and other places.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520948958", "createdAt": "2020-11-10T23:54:34Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMDYxNg==", "bodyText": "moved to a separate function", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521020616", "createdAt": "2020-11-11T02:05:44Z", "author": {"login": "somandal"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODk1OA=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTg5MTAzOnYy", "diffSide": "RIGHT", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzo1NToxN1rOHw0N7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjowNTo0OVrOHw4lEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0OTIzMQ==", "bodyText": "Also, do you see a value of extracting the method for this new duplicate code block?", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520949231", "createdAt": "2020-11-10T23:55:17Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMDY5MA==", "bodyText": "done", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521020690", "createdAt": "2020-11-11T02:05:49Z", "author": {"login": "somandal"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0OTIzMQ=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTg5MjA0OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzo1NTo0NVrOHw0OlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjowNTo1NlrOHw4lTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0OTM5Nw==", "bodyText": "Please transform this test to AssertThrows as well.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520949397", "createdAt": "2020-11-10T23:55:45Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n+\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n     Assert.assertEquals(new HashSet<>(task2.getDependencies()), ImmutableSet.of(task.getDatastreamTaskName()));\n   }\n \n+  @Test(expectedExceptions = DatastreamTransientException.class)\n+  public void testTaskAddUnlockedDependency() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMDc0OQ==", "bodyText": "done", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521020749", "createdAt": "2020-11-11T02:05:56Z", "author": {"login": "somandal"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n+\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n     Assert.assertEquals(new HashSet<>(task2.getDependencies()), ImmutableSet.of(task.getDatastreamTaskName()));\n   }\n \n+  @Test(expectedExceptions = DatastreamTransientException.class)\n+  public void testTaskAddUnlockedDependency() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0OTM5Nw=="}, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Njg4NTczOnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNDo1ODowMFrOHw-QWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNToyOTo1OVrOHw-wag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMzY5MQ==", "bodyText": "Also, can you please add the steps in the comments in the code, so it is clear which code block is which step?", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521113691", "createdAt": "2020-11-11T04:58:00Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -154,11 +154,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Process the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source tasks\n+   * Step 3) If the instance is the one we want to move, we choose a task to which we should assign the partition", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe8b5645adef83ee7507bf75ef79220b4f00fb4"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyMTg5OA==", "bodyText": "done", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521121898", "createdAt": "2020-11-11T05:29:59Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -154,11 +154,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Process the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source tasks\n+   * Step 3) If the instance is the one we want to move, we choose a task to which we should assign the partition", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMzY5MQ=="}, "originalCommit": {"oid": "dbe8b5645adef83ee7507bf75ef79220b4f00fb4"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 915, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}