{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0OTQzNTMw", "number": 774, "title": "Add preAssignmentCleanup in Coordinator and extend assignment strategy", "bodyText": "In StickyMulticastPartitionAssignmentStrategy, during assignment, if the partition count changes for a task A, the new task A' is created and the existing task A is added to the dependency list. The existing task A is removed from the assignment list. The coordinator then updates the assignment to the zookeeper, by first adding the new node A' followed by deleting the old node A, to avoid assignment loss. If the coordinator either gets interrupted, or hits OOM, or session expiry, before completing the assignment update, there is a possibility that the deletion of the existing task A did not succeed. This results in both the new task A' and old task A exist in the assignment list. The next leader has no clue that the old task A needs to be cleaned up and ends up reusing the old task A (which should never happen). This results in the old task A continue to hold the task lock and the new task A' wait for the old task A to release the lock, to acquire and start processing. So, the new task A' will never run. Now, suppose another assignment is performed, where the new task A' is going to get added to the dependency list of task A'', the task  A'' object creation will fail, as it checks that the dependency should already have the lock in the constructor of DatastreamTaskImpl. This check is important to avoid A' and A'' fight for the task lock at the same time.\nPartition-Managed Kafka connector assignment is in two steps: a, assign the task b, assign the partition(which modifies the task as well).  Because of these 2 step process, it is not possible for the new leader to identify the tasks that need to be cleaned up. Also, the clean up of the old task should complete before the new assignment for 2 reasons:\na. to prevent the old task to continue running and fail the partition assignment repeatedly. (The only way to recover the setup in this case is to restart the datastreams)\nb. Because old task has no dependency, if the old task moved to another instance, there is a possibility that task A' is able to acquire the lock and task A moving to another instance will also be able to acquire the task lock because it has no dependency. This will result in both task A and task A' running simultaneously, which will result in overlapping partition record processing.\nTo solve this problem, This PR is introducing preassignment cleanup which will allow the strategy to identify the stale tasks and allow the coordinator to clean them. This will be done only once when the node becomes leader for the first time.", "createdAt": "2020-11-03T19:20:47Z", "url": "https://github.com/linkedin/brooklin/pull/774", "merged": true, "mergeCommit": {"oid": "3c53279f193f4eb70fd054a74db295aa1438bec9"}, "closed": true, "closedAt": "2020-11-10T18:13:08Z", "author": {"login": "vmaheshw"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABboAf5CAH2gAyNTE0OTQzNTMwOmMzMWNkNGExNWNjOGRkNjliMGE2NTNkYmU0MjAxZGU5MzRlYTZkNjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbNH_WgFqTUyNzQ1ODIzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "author": {"user": {"login": "vmaheshw", "name": "Vaibhav Maheshwari"}}, "url": "https://github.com/linkedin/brooklin/commit/c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "committedDate": "2019-11-18T20:06:44Z", "message": "Merge pull request #1 from linkedin/master\n\nPull latest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79ffa91188aa16ebcb2e9c1e55d4b9a8911b9c36", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/79ffa91188aa16ebcb2e9c1e55d4b9a8911b9c36", "committedDate": "2020-11-02T20:44:50Z", "message": "Merge branch 'master' of github.com:linkedin/brooklin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/0f33e4e600ce5ef837f603269fba4118e581b6b7", "committedDate": "2020-11-03T19:05:29Z", "message": "Add pre assignment cleanup to let the new leader perform cleanup before assignment if required"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODE4MDU2", "url": "https://github.com/linkedin/brooklin/pull/774#pullrequestreview-522818056", "createdAt": "2020-11-03T19:37:19Z", "commit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNzoxOVrOHs9tAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo0NzowOVrOHs-Blg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMDMzNw==", "bodyText": "Maybe \"need to be validated\"?", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r516910337", "createdAt": "2020-11-03T19:37:19Z", "author": {"login": "jzakaryan"}, "path": "datastream-server-api/src/main/java/com/linkedin/datastream/server/api/strategy/AssignmentStrategy.java", "diffHunk": "@@ -89,4 +90,16 @@\n       Map<String, Set<String>> targetAssignment, DatastreamGroupPartitionsMetadata partitionsMetadata) {\n     throw new NotImplementedException(\"movePartitions are not implemented\");\n   }\n+\n+  /**\n+   * Validate the current assignment and return the list of DatastreamTask per instance to be cleaned up.\n+   *\n+   * @param datastreams all the datastreams for which the associated tasks to be validated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzg3OA==", "bodyText": "Do you think we should turn on this feature by default without testing it in production?", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r516913878", "createdAt": "2020-11-03T19:43:52Z", "author": {"login": "jzakaryan"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/CoordinatorConfig.java", "diffHunk": "@@ -59,6 +61,7 @@ public CoordinatorConfig(Properties config) {\n     _defaultTransportProviderName = _properties.getString(CONFIG_DEFAULT_TRANSPORT_PROVIDER, \"\");\n     _zkCleanUpOrphanConnectorTask = _properties.getBoolean(CONFIG_ZK_CLEANUP_ORPHAN_CONNECTOR_TASK, false);\n     _zkCleanUpOrphanConnectorTaskLock = _properties.getBoolean(CONFIG_ZK_CLEANUP_ORPHAN_CONNECTOR_TASK_LOCK, false);\n+    _performPreAssignmentCleanup = _properties.getBoolean(CONFIG_PERFORM_PRE_ASSIGNMENT_CLEANUP, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNTYwNg==", "bodyText": "Nit: list of tasks\nAlso could be reworded to:\nIf a task is both in the dependency list as well as the current assignment list, it's possible that the previous leader went down before getting a chance to clean it up and update the zookeeper. This method identifies such tasks.", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r516915606", "createdAt": "2020-11-03T19:47:09Z", "author": {"login": "jzakaryan"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzODM2ODU0", "url": "https://github.com/linkedin/brooklin/pull/774#pullrequestreview-523836854", "createdAt": "2020-11-05T00:40:27Z", "commit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwMDo0MDoyN1rOHtuxrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwMTowMTo0MlrOHtvKhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNDM1MQ==", "bodyText": "+1 we should definitely test this first", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517714351", "createdAt": "2020-11-05T00:40:27Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/CoordinatorConfig.java", "diffHunk": "@@ -59,6 +61,7 @@ public CoordinatorConfig(Properties config) {\n     _defaultTransportProviderName = _properties.getString(CONFIG_DEFAULT_TRANSPORT_PROVIDER, \"\");\n     _zkCleanUpOrphanConnectorTask = _properties.getBoolean(CONFIG_ZK_CLEANUP_ORPHAN_CONNECTOR_TASK, false);\n     _zkCleanUpOrphanConnectorTaskLock = _properties.getBoolean(CONFIG_ZK_CLEANUP_ORPHAN_CONNECTOR_TASK_LOCK, false);\n+    _performPreAssignmentCleanup = _properties.getBoolean(CONFIG_PERFORM_PRE_ASSIGNMENT_CLEANUP, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzg3OA=="}, "originalCommit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNjE4MA==", "bodyText": "nit: Reword: list of datastream tasks mapped by instance that need to be cleaned up.", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517716180", "createdAt": "2020-11-05T00:46:52Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNzcyMA==", "bodyText": "nit: rename tasksPerInstance to dependencyTasksPerInstance (since this is doing the actual filtering logic, and the final list consists of dependency tasks left behind in the assignment)", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517717720", "createdAt": "2020-11-05T00:51:56Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   */\n+  public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n+      Map<String, Set<DatastreamTask>> currentAssignment) {\n+\n+    Set<String> datastreamGroupsSet = datastreamGroups.stream().map(DatastreamGroup::getTaskPrefix).collect(Collectors.toSet());\n+    Map<String, List<DatastreamTask>> tasksToCleanUp = new HashMap<>();\n+    // map of task name to DatastreamTask for future reference\n+    Map<String, DatastreamTask> assignmentsMap = currentAssignment.values()\n+        .stream()\n+        .flatMap(Collection::stream)\n+        .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity()));\n+\n+    for (String instance : currentAssignment.keySet()) {\n+      // find the dependency task which exists in the assignmentsMap as well.\n+      List<DatastreamTask> tasksPerInstance = currentAssignment.get(instance)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNzkzNw==", "bodyText": "nit: Reword: find the dependency tasks which also exist in the current assignment list.", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517717937", "createdAt": "2020-11-05T00:52:42Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   */\n+  public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n+      Map<String, Set<DatastreamTask>> currentAssignment) {\n+\n+    Set<String> datastreamGroupsSet = datastreamGroups.stream().map(DatastreamGroup::getTaskPrefix).collect(Collectors.toSet());\n+    Map<String, List<DatastreamTask>> tasksToCleanUp = new HashMap<>();\n+    // map of task name to DatastreamTask for future reference\n+    Map<String, DatastreamTask> assignmentsMap = currentAssignment.values()\n+        .stream()\n+        .flatMap(Collection::stream)\n+        .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity()));\n+\n+    for (String instance : currentAssignment.keySet()) {\n+      // find the dependency task which exists in the assignmentsMap as well.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTc2Nw==", "bodyText": "Can we add a log to print the tasksToCleanUp and also the count? To keep the log readable, let's print only task names?\nFor debugging purposes it may be helpful to print the task names on which these tasks exist as dependencies. I'll leave it to you to assess if this can be useful though.", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517719767", "createdAt": "2020-11-05T00:58:33Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   */\n+  public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n+      Map<String, Set<DatastreamTask>> currentAssignment) {\n+\n+    Set<String> datastreamGroupsSet = datastreamGroups.stream().map(DatastreamGroup::getTaskPrefix).collect(Collectors.toSet());\n+    Map<String, List<DatastreamTask>> tasksToCleanUp = new HashMap<>();\n+    // map of task name to DatastreamTask for future reference\n+    Map<String, DatastreamTask> assignmentsMap = currentAssignment.values()\n+        .stream()\n+        .flatMap(Collection::stream)\n+        .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity()));\n+\n+    for (String instance : currentAssignment.keySet()) {\n+      // find the dependency task which exists in the assignmentsMap as well.\n+      List<DatastreamTask> tasksPerInstance = currentAssignment.get(instance)\n+          .stream()\n+          .filter(t -> datastreamGroupsSet.contains(t.getTaskPrefix()))\n+          .map(task -> ((DatastreamTaskImpl) task).getDependencies())\n+          .flatMap(Collection::stream)\n+          .map(assignmentsMap::get)\n+          .filter(Objects::nonNull)\n+          .collect(Collectors.toList());\n+\n+      if (!tasksPerInstance.isEmpty()) {\n+        tasksToCleanUp.put(instance, tasksPerInstance);\n+      }\n+    }\n+    return tasksToCleanUp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMDcwOA==", "bodyText": "Should we also validate that the tasksToCleanup only contains the tasks we expect it to by matching task names?", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517720708", "createdAt": "2020-11-05T01:01:42Z", "author": {"login": "somandal"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestStickyPartitionAssignment.java", "diffHunk": "@@ -87,11 +86,24 @@ public void testAddPartitions() {\n     DatastreamGroupPartitionsMetadata newPartitionsMetadata =\n         new DatastreamGroupPartitionsMetadata(datastreams.get(0), newPartitions);\n \n-    assignment = strategy.assignPartitions(assignment, newPartitionsMetadata);\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assignPartitions(assignment, newPartitionsMetadata);\n \n-    for (DatastreamTask task : assignment.get(\"instance1\")) {\n+    for (DatastreamTask task : newAssignment.get(\"instance0\")) {\n       Assert.assertEquals(task.getPartitionsV2().size(), 2);\n     }\n+\n+    Map<String, List<DatastreamTask>> taskToCleanup = strategy.getTasksToCleanUp(datastreams, newAssignment);\n+    Assert.assertEquals(taskToCleanup.size(), 0);\n+\n+    // Adding the dependency task as well in the assignment list to simulate the scenario where\n+    // the dependency task nodes are not deleted and the leader gets interrupted, OOM or hit session expiry.\n+    // The next leader should be able to identify and cleanup.\n+    Map<String, Set<DatastreamTask>> finalAssignment = assignment;\n+    newAssignment.forEach((instance, taskSet1) -> taskSet1.addAll(finalAssignment.get(instance)));\n+\n+    taskToCleanup = strategy.getTasksToCleanUp(datastreams, newAssignment);\n+    Assert.assertEquals(taskToCleanup.size(), 1);\n+    taskToCleanup.forEach((instance, taskList1) -> Assert.assertEquals(taskList1.size(), 3));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e308d8f5556cb4e8deae13a18d79ac6932a2187", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/2e308d8f5556cb4e8deae13a18d79ac6932a2187", "committedDate": "2020-11-06T05:33:17Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MjM2OTEy", "url": "https://github.com/linkedin/brooklin/pull/774#pullrequestreview-525236912", "createdAt": "2020-11-06T15:06:29Z", "commit": {"oid": "2e308d8f5556cb4e8deae13a18d79ac6932a2187"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTQ1OTM0", "url": "https://github.com/linkedin/brooklin/pull/774#pullrequestreview-525545934", "createdAt": "2020-11-06T23:01:12Z", "commit": {"oid": "2e308d8f5556cb4e8deae13a18d79ac6932a2187"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bd8c4f213fee2a4da1857f2d3fdd6a29d37af1e", "author": {"user": {"login": "vmaheshw", "name": "Vaibhav Maheshwari"}}, "url": "https://github.com/linkedin/brooklin/commit/4bd8c4f213fee2a4da1857f2d3fdd6a29d37af1e", "committedDate": "2020-11-06T23:39:55Z", "message": "Merge branch 'master' into fixStickPartitionAssignment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NDQ3MTE1", "url": "https://github.com/linkedin/brooklin/pull/774#pullrequestreview-527447115", "createdAt": "2020-11-10T17:37:11Z", "commit": {"oid": "4bd8c4f213fee2a4da1857f2d3fdd6a29d37af1e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NDU4MjMy", "url": "https://github.com/linkedin/brooklin/pull/774#pullrequestreview-527458232", "createdAt": "2020-11-10T17:50:41Z", "commit": {"oid": "4bd8c4f213fee2a4da1857f2d3fdd6a29d37af1e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 324, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}