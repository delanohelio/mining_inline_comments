{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczNDM1NzA3", "number": 684, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoyMjoyMFrODe5GkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODo1MjozMlrODe67eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzE5NDQxOnYy", "diffSide": "RIGHT", "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/AbstractKafkaConnector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoyMjoyMFrOFoR-iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODozNjozMVrOFoUZaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4MTg5OQ==", "bodyText": "This will throw ConcurrentModificationException while iterating the loop.", "url": "https://github.com/linkedin/brooklin/pull/684#discussion_r377781899", "createdAt": "2020-02-11T17:22:20Z", "author": {"login": "vmaheshw"}, "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/AbstractKafkaConnector.java", "diffHunk": "@@ -142,6 +151,7 @@ public synchronized void onAssignmentChange(List<DatastreamTask> tasks) {\n           // Make sure to replace the DatastreamTask with most up to date info\n           // This is necessary because DatastreamTaskImpl.hashCode() does not take into account all the\n           // fields/properties of the DatastreamTask (e.g. dependencies).\n+          _runningTasks.remove(task);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae7119042059bb6b146d36ae0dbce4693fa3a9e"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgyMTU0NQ==", "bodyText": "This is not a problem. We are not iterating through the map that we are removing things from. We are iterating over the tasks list, which we don't modify at all.\n  **for (DatastreamTask task : tasks) {**\n    ConnectorTaskEntry connectorTaskEntry = _runningTasks.get(task);\n    if (connectorTaskEntry != null) {\n      AbstractKafkaBasedConnectorTask kafkaBasedConnectorTask = connectorTaskEntry.getConnectorTask();\n      kafkaBasedConnectorTask.checkForUpdateTask(task);\n      // Make sure to replace the DatastreamTask with most up to date info\n      // This is necessary because DatastreamTaskImpl.hashCode() does not take into account all the\n      // fields/properties of the DatastreamTask (e.g. dependencies).\n      **_runningTasks.remove(task);**\n      _runningTasks.put(task, connectorTaskEntry);\n      continue; // already running\n    }\n\n    _runningTasks.put(task, createKafkaConnectorTask(task));\n  }", "url": "https://github.com/linkedin/brooklin/pull/684#discussion_r377821545", "createdAt": "2020-02-11T18:36:31Z", "author": {"login": "somandal"}, "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/AbstractKafkaConnector.java", "diffHunk": "@@ -142,6 +151,7 @@ public synchronized void onAssignmentChange(List<DatastreamTask> tasks) {\n           // Make sure to replace the DatastreamTask with most up to date info\n           // This is necessary because DatastreamTaskImpl.hashCode() does not take into account all the\n           // fields/properties of the DatastreamTask (e.g. dependencies).\n+          _runningTasks.remove(task);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4MTg5OQ=="}, "originalCommit": {"oid": "6ae7119042059bb6b146d36ae0dbce4693fa3a9e"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzQ5MzY4OnYy", "diffSide": "RIGHT", "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/AbstractKafkaConnector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODo1MjozMlrOFoU70g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTowMjowNFrOFoVQlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzMDM1NA==", "bodyText": "typo: This will force cleanup", "url": "https://github.com/linkedin/brooklin/pull/684#discussion_r377830354", "createdAt": "2020-02-11T18:52:32Z", "author": {"login": "DEEPTHIKORAT"}, "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/AbstractKafkaConnector.java", "diffHunk": "@@ -128,10 +133,14 @@ public synchronized void onAssignmentChange(List<DatastreamTask> tasks) {\n \n       for (DatastreamTask task : toCancel) {\n         ConnectorTaskEntry connectorTaskEntry = _runningTasks.remove(task);\n-        // Stopping the connectorTask. This only marks the connector task as shutdown and does not actually wait for\n-        // the connector task to stop. onAssignmentChange() must be completed quickly, otherwise the Coordinator\n-        // kills the assignment threads.\n-        connectorTaskEntry.getConnectorTask().stop();\n+        // Spawn a separate thread to attempt stopping the connectorTask. The connectorTask will be canceled if it\n+        // does not stop within a certain amount of time. This is force cleanup of connectorTasks which take too long", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae7119042059bb6b146d36ae0dbce4693fa3a9e"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNTY3MA==", "bodyText": "done", "url": "https://github.com/linkedin/brooklin/pull/684#discussion_r377835670", "createdAt": "2020-02-11T19:02:04Z", "author": {"login": "somandal"}, "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/AbstractKafkaConnector.java", "diffHunk": "@@ -128,10 +133,14 @@ public synchronized void onAssignmentChange(List<DatastreamTask> tasks) {\n \n       for (DatastreamTask task : toCancel) {\n         ConnectorTaskEntry connectorTaskEntry = _runningTasks.remove(task);\n-        // Stopping the connectorTask. This only marks the connector task as shutdown and does not actually wait for\n-        // the connector task to stop. onAssignmentChange() must be completed quickly, otherwise the Coordinator\n-        // kills the assignment threads.\n-        connectorTaskEntry.getConnectorTask().stop();\n+        // Spawn a separate thread to attempt stopping the connectorTask. The connectorTask will be canceled if it\n+        // does not stop within a certain amount of time. This is force cleanup of connectorTasks which take too long", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzMDM1NA=="}, "originalCommit": {"oid": "6ae7119042059bb6b146d36ae0dbce4693fa3a9e"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 954, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}