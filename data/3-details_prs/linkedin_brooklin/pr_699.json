{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNzA3NDk3", "number": 699, "title": "ZK Session Expiry management (phase 1): Mark the node as follower", "bodyText": "ZK Session expiry is not handled correctly. Calling a disconnect on zk session expiry and trying to connect again, does not really work as it both the call happens on zkClientEventThread which is already interrupted. This result in silent exit of zkClientEventThread.\nRe-initializing the zkclient correctly is not the only problem. We don't have leader-> follower transition sequence in the code. As soon as session gets expired, the live instance node gets deleted and the leader is no longer participating in the election. We need to fix the transition of leader -> follower to gracefully handle zk session expiry.\nWe will solve this problem in multiple commits:\n\nMark the leader as follower so that it does not do any more assignment and affect the zk state.\nCleanup the tasks assigned.\nRe-initialize the same zk session.", "createdAt": "2020-04-10T00:40:30Z", "url": "https://github.com/linkedin/brooklin/pull/699", "merged": true, "mergeCommit": {"oid": "8a2ae4573ff3d867ed2f1393183f47cb29b2273f"}, "closed": true, "closedAt": "2020-07-22T19:44:35Z", "author": {"login": "vmaheshw"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABboAf5CAH2gAyNDAxNzA3NDk3OmMzMWNkNGExNWNjOGRkNjliMGE2NTNkYmU0MjAxZGU5MzRlYTZkNjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3ftxRAFqTQ1MzYwNjcyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "author": {"user": {"login": "vmaheshw", "name": "Vaibhav Maheshwari"}}, "url": "https://github.com/linkedin/brooklin/commit/c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "committedDate": "2019-11-18T20:06:44Z", "message": "Merge pull request #1 from linkedin/master\n\nPull latest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "699a6326b1c6cf4525a5f9c12f8b36eeb490da01", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/699a6326b1c6cf4525a5f9c12f8b36eeb490da01", "committedDate": "2020-04-06T22:34:40Z", "message": "Merge branch 'master' of github.com:linkedin/brooklin into HEAD"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ec357e954d1e0bb436583ebb9ef6efa66cacef7", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/0ec357e954d1e0bb436583ebb9ef6efa66cacef7", "committedDate": "2020-04-06T23:59:55Z", "message": "Fix arithmetic exception in StickyPartitionAssignmentStrategy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "840fa183363a81a9b1b15c71228eb2ac3ece434f", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/840fa183363a81a9b1b15c71228eb2ac3ece434f", "committedDate": "2020-04-08T20:40:37Z", "message": "Address Review Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae2f7e3360234322d16f8362c39212e0e74da3fd", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/ae2f7e3360234322d16f8362c39212e0e74da3fd", "committedDate": "2020-04-10T00:32:43Z", "message": "ZK Session Expiry management (phase 1): Bring down the node"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55913ad68ec40a5f25aafd5508180042a9cba033", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/55913ad68ec40a5f25aafd5508180042a9cba033", "committedDate": "2020-04-10T07:10:48Z", "message": "Revert \"Address Review Comments\"\n\nThis reverts commit 840fa183363a81a9b1b15c71228eb2ac3ece434f."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cba5bd0c0bb209b9192c976be3f90c50a3632f7", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/7cba5bd0c0bb209b9192c976be3f90c50a3632f7", "committedDate": "2020-04-10T07:13:31Z", "message": "Revert \"Fix arithmetic exception in StickyPartitionAssignmentStrategy\"\n\nThis reverts commit 0ec357e954d1e0bb436583ebb9ef6efa66cacef7."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/34ad17da1851dc612824533af0b64cd8e1a20595", "committedDate": "2020-04-23T07:24:59Z", "message": "Few more fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODA1MDQw", "url": "https://github.com/linkedin/brooklin/pull/699#pullrequestreview-402805040", "createdAt": "2020-04-29T15:52:00Z", "commit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1MjowMFrOGOFg6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNzoxNTowOFrOGOI5sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMzU5NQ==", "bodyText": "Do we need to add a new constructor? Can't we use the existing constructor and add the exitOnSessionExpiry field there, and have the tests set it to false?\nnit: If you do decide to keep this, you're missing an empty line between this constructor and the comments of the next one", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417423595", "createdAt": "2020-04-29T15:52:00Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -148,18 +157,35 @@\n    * @param operationRetryTimeoutMs Timeout to use for retrying failed retriable operations. A value lesser than 0 is\n    *                         considered as retry forever until a connection has been reestablished.\n    * @param listener ZKAdapterListener implementation to receive callbacks based on various znode changes\n+   * @param exitOnSessionExpiry boolean to decide whether to exit on session expiry or not.\n    */\n   public ZkAdapter(String zkServers, String cluster, String defaultTransportProviderName, int sessionTimeoutMs,\n-      int connectionTimeoutMs, int operationRetryTimeoutMs, ZkAdapterListener listener) {\n+      int connectionTimeoutMs, int operationRetryTimeoutMs, ZkAdapterListener listener, boolean exitOnSessionExpiry) {\n     _zkServers = zkServers;\n     _cluster = cluster;\n     _sessionTimeoutMs = sessionTimeoutMs;\n     _connectionTimeoutMs = connectionTimeoutMs;\n     _operationRetryTimeoutMs = operationRetryTimeoutMs;\n     _listener = listener;\n+    _exitOnSessionExpiry = exitOnSessionExpiry;\n     _defaultTransportProviderName = defaultTransportProviderName;\n   }\n \n+  /**\n+   * Constructor\n+   * @param zkServers ZooKeeper server address to connect to\n+   * @param cluster Brooklin cluster this instance belongs to\n+   * @param defaultTransportProviderName Default transport provider to use for a newly created task\n+   * @param sessionTimeoutMs Session timeout to use for the connection with the ZooKeeper server\n+   * @param connectionTimeoutMs Connection timeout to use for the connection with the ZooKeeper server\n+   * @param listener ZKAdapterListener implementation to receive callbacks based on various znode changes\n+   * @param exitOnSessionExpiry boolean to decide whether to exit on session expiry or not.\n+   */\n+  public ZkAdapter(String zkServers, String cluster, String defaultTransportProviderName, int sessionTimeoutMs,\n+      int connectionTimeoutMs, ZkAdapterListener listener, boolean exitOnSessionExpiry) {\n+    this(zkServers, cluster, defaultTransportProviderName, sessionTimeoutMs, connectionTimeoutMs, -1,\n+        listener, exitOnSessionExpiry);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNDUzOA==", "bodyText": "Not part of your changes as such, but I see this constructor used in a bunch of tests. Can you add the @VisibleForTesting annotation?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417424538", "createdAt": "2020-04-29T15:53:24Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -172,7 +198,7 @@ public ZkAdapter(String zkServers, String cluster, String defaultTransportProvid\n   public ZkAdapter(String zkServers, String cluster, String defaultTransportProviderName, int sessionTimeoutMs,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNzY2Nw==", "bodyText": "Are we doing to remove this? Since this leads to a bunch of hosts looking like leaders due to metrics, it becomes extremely difficult to debug for people not familiar with these issues and the symptoms of this change. The last oncall who had to debug this kept thinking we have multiple leaders, when we actually don't.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417427667", "createdAt": "2020-04-29T15:57:38Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -222,14 +248,22 @@ ZkClient createZkClient() {\n     return new ZkClient(_zkServers, _sessionTimeoutMs, _connectionTimeoutMs, _operationRetryTimeoutMs);\n   }\n \n+  @VisibleForTesting\n+  ZkStateChangeListener getOrCreateStateChangeListener() {\n+    if (_stateChangeListener == null) {\n+      _stateChangeListener = new ZkStateChangeListener();\n+    }\n+    return _stateChangeListener;\n+  }\n+\n   /**\n    * Connect the adapter so that it can connect and bridge events between ZooKeeper changes and\n    * the actions that need to be taken with them, which are implemented in the Coordinator class\n    */\n   public void connect() {\n     disconnect(); // Guard against leaking an existing zookeeper session", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMjgxOQ==", "bodyText": "nit: remove the extra line?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417432819", "createdAt": "2020-04-29T16:04:57Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/CoordinatorConfig.java", "diffHunk": "@@ -90,4 +97,8 @@ public boolean getZkCleanUpOrphanConnectorTask() {\n     return _zkCleanUpOrphanConnectorTask;\n   }\n \n+  public boolean getExitOnZkSessionExpiry() {\n+    return _exitOnZkSessionExpiry;\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzNzQ2MQ==", "bodyText": "Not part of your change, but I don't really see this being used in tests. Can you remove the @VisibleForTesting annotation if it is indeed not used anywhere?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417437461", "createdAt": "2020-04-29T16:11:39Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -259,7 +258,8 @@ public Coordinator(CachedDatastreamReader datastreamCache, CoordinatorConfig con\n   @VisibleForTesting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MjY1OQ==", "bodyText": "Add a comment explaining that the node at index 0 is the leader and doesn't need to listen on a previous node anymore.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417452659", "createdAt": "2020-04-29T16:34:33Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -334,6 +368,10 @@ private void joinLeaderElection() {\n \n     // if this instance is first in line to become leader. Check if it is already a leader.\n     if (index == 0) {\n+      if (_currentSubscription != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MjkxNw==", "bodyText": "Set _currentSubscription to null after unsubscribing", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417452917", "createdAt": "2020-04-29T16:34:57Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -334,6 +368,10 @@ private void joinLeaderElection() {\n \n     // if this instance is first in line to become leader. Check if it is already a leader.\n     if (index == 0) {\n+      if (_currentSubscription != null) {\n+        _zkclient.unsubscribeDataChanges(_currentSubscription, _leaderElectionListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1OTE1Mw==", "bodyText": "I see you added an unsubscribeDataChanges() here. Should this be added for other listeners that subscribe to both child and data changes on close()?  e.g. ZkBackedDMSDatastreamList?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417459153", "createdAt": "2020-04-29T16:44:37Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1353,13 +1391,14 @@ public ZkBackedTaskListProvider(String cluster, String instanceName) {\n     /**\n      * Unsubscribe to all changes to the task assignment for this instance.\n      */\n-    public void close() {\n+    private void close() {\n       LOG.info(\"ZkBackedTaskListProvider::Unsubscribing to the changes under the path \" + _path);\n-      _zkclient.unsubscribeChildChanges(KeyBuilder.instanceAssignments(_cluster, _instanceName), this);\n+      _zkclient.unsubscribeChildChanges(_path, this);\n+      _zkclient.unsubscribeDataChanges(_path, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MjAzMA==", "bodyText": "is this necessary? we're calling exit() next anyways, and this just clears up some internal state.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417462030", "createdAt": "2020-04-29T16:49:00Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1435,8 +1474,70 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener:: handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:\n+          _timer.cancel();\n+          onBecomeFollower();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MjQyMQ==", "bodyText": "Just for consistency, can you prepend the comment with \"ZkStateChangeListener::\"?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417462421", "createdAt": "2020-04-29T16:49:36Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1435,8 +1474,70 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener:: handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:\n+          _timer.cancel();\n+          onBecomeFollower();\n+          exitOnSessionExpiryOrEstablishmentError();\n+          return;\n+        case Disconnected:\n+          // if the session has expired it means that all the registration's ephemeral nodes are gone.\n+          LOG.warn(\"Got {} event. Scheduling a system stop.\", state.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MzM5NA==", "bodyText": "This comment feels a bit out of place without more explanation. In general there are a multitude of problems we deal with on session expiry. It may be a good idea to call them all out (or just the major classes of issues such as leader to follower transition, ephemeral nodes, tasks still running as if nothing happened, etc). Maybe above the class or above the function?  Since it explains the actions we take for both disconnect + expiry.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417463394", "createdAt": "2020-04-29T16:50:57Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1435,8 +1474,70 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener:: handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:\n+          _timer.cancel();\n+          onBecomeFollower();\n+          exitOnSessionExpiryOrEstablishmentError();\n+          return;\n+        case Disconnected:\n+          // if the session has expired it means that all the registration's ephemeral nodes are gone.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDgxOA==", "bodyText": "nit: session established -> session has been established", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417464818", "createdAt": "2020-04-29T16:53:00Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1435,8 +1474,70 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener:: handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:\n+          _timer.cancel();\n+          onBecomeFollower();\n+          exitOnSessionExpiryOrEstablishmentError();\n+          return;\n+        case Disconnected:\n+          // if the session has expired it means that all the registration's ephemeral nodes are gone.\n+          LOG.warn(\"Got {} event. Scheduling a system stop.\", state.toString());\n+          scheduleExpiryTimerAfterSessionTimeout();\n+          return;\n+        case SyncConnected:\n+          LOG.info(\"ZkStateChangeListener::Connected. Canceling timer.\");\n+          _timer.cancel();\n+          return;\n+        default:\n+          // Ignoring AuthFailed for now.\n+      }\n+    }\n+\n+    @Override\n+    public void handleNewSession() {\n+      LOG.info(\"ZkStateChangeListener:: A new session established.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NTQ3NQ==", "bodyText": "nit: can we rename this to scheduleExpiryTimerOnSessionDisconnected?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417465475", "createdAt": "2020-04-29T16:53:56Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1435,8 +1474,70 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener:: handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:\n+          _timer.cancel();\n+          onBecomeFollower();\n+          exitOnSessionExpiryOrEstablishmentError();\n+          return;\n+        case Disconnected:\n+          // if the session has expired it means that all the registration's ephemeral nodes are gone.\n+          LOG.warn(\"Got {} event. Scheduling a system stop.\", state.toString());\n+          scheduleExpiryTimerAfterSessionTimeout();\n+          return;\n+        case SyncConnected:\n+          LOG.info(\"ZkStateChangeListener::Connected. Canceling timer.\");\n+          _timer.cancel();\n+          return;\n+        default:\n+          // Ignoring AuthFailed for now.\n+      }\n+    }\n+\n+    @Override\n+    public void handleNewSession() {\n+      LOG.info(\"ZkStateChangeListener:: A new session established.\");\n+    }\n+\n+    @Override\n+    public void handleSessionEstablishmentError(final Throwable error) {\n+      LOG.error(\"ZkStateChangeListener:: Failed to establish session.\", error);\n+      exitOnSessionExpiryOrEstablishmentError();\n+    }\n+  }\n+\n+  private void scheduleExpiryTimerAfterSessionTimeout() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2ODMxMQ==", "bodyText": "lose the election? This sentence is a bit confusing, not sure what you mean here. Can you rephrase?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417468311", "createdAt": "2020-04-29T16:58:01Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1435,8 +1474,70 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener:: handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:\n+          _timer.cancel();\n+          onBecomeFollower();\n+          exitOnSessionExpiryOrEstablishmentError();\n+          return;\n+        case Disconnected:\n+          // if the session has expired it means that all the registration's ephemeral nodes are gone.\n+          LOG.warn(\"Got {} event. Scheduling a system stop.\", state.toString());\n+          scheduleExpiryTimerAfterSessionTimeout();\n+          return;\n+        case SyncConnected:\n+          LOG.info(\"ZkStateChangeListener::Connected. Canceling timer.\");\n+          _timer.cancel();\n+          return;\n+        default:\n+          // Ignoring AuthFailed for now.\n+      }\n+    }\n+\n+    @Override\n+    public void handleNewSession() {\n+      LOG.info(\"ZkStateChangeListener:: A new session established.\");\n+    }\n+\n+    @Override\n+    public void handleSessionEstablishmentError(final Throwable error) {\n+      LOG.error(\"ZkStateChangeListener:: Failed to establish session.\", error);\n+      exitOnSessionExpiryOrEstablishmentError();\n+    }\n+  }\n+\n+  private void scheduleExpiryTimerAfterSessionTimeout() {\n+    TimerTask timerTask = new TimerTask() {\n+      public void run() {\n+        exitOnSessionExpiryOrEstablishmentError();\n+      }\n+    };\n+    _timer.schedule(timerTask, _sessionTimeoutMs);\n+  }\n+\n+  // This is a temporary change to bring down the node on session expiry. We expect this to happen rarely.\n+  // We are working on the transition of leader to follower on session expiry. On session expiry,\n+  // the live instance (ephemeral nodes) gets deleted by the server and node automatically lose the election.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3MDU2Ng==", "bodyText": "Again, a bit confusing here. Not sure we need to add details about nurse bringing the node back up.  Also, not sure you really need to discuss the knob (which I assume is the config?) here.\nnit: shutdownhook -> shutdown hook\nMaybe rephrase it to: Calling exit() will invoke the shutdown hook and bring down the system via a clean shutdown.\nIf you do want to mention the config, you can add a sentence: This behavior to bring down the system on session expiry is controlled via a config option.\nIf you do want to discuss the nurse job, you can add: A health monitoring service is expected to be in place to restart  the Brooklin service.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417470566", "createdAt": "2020-04-29T17:01:33Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1435,8 +1474,70 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener:: handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:\n+          _timer.cancel();\n+          onBecomeFollower();\n+          exitOnSessionExpiryOrEstablishmentError();\n+          return;\n+        case Disconnected:\n+          // if the session has expired it means that all the registration's ephemeral nodes are gone.\n+          LOG.warn(\"Got {} event. Scheduling a system stop.\", state.toString());\n+          scheduleExpiryTimerAfterSessionTimeout();\n+          return;\n+        case SyncConnected:\n+          LOG.info(\"ZkStateChangeListener::Connected. Canceling timer.\");\n+          _timer.cancel();\n+          return;\n+        default:\n+          // Ignoring AuthFailed for now.\n+      }\n+    }\n+\n+    @Override\n+    public void handleNewSession() {\n+      LOG.info(\"ZkStateChangeListener:: A new session established.\");\n+    }\n+\n+    @Override\n+    public void handleSessionEstablishmentError(final Throwable error) {\n+      LOG.error(\"ZkStateChangeListener:: Failed to establish session.\", error);\n+      exitOnSessionExpiryOrEstablishmentError();\n+    }\n+  }\n+\n+  private void scheduleExpiryTimerAfterSessionTimeout() {\n+    TimerTask timerTask = new TimerTask() {\n+      public void run() {\n+        exitOnSessionExpiryOrEstablishmentError();\n+      }\n+    };\n+    _timer.schedule(timerTask, _sessionTimeoutMs);\n+  }\n+\n+  // This is a temporary change to bring down the node on session expiry. We expect this to happen rarely.\n+  // We are working on the transition of leader to follower on session expiry. On session expiry,\n+  // the live instance (ephemeral nodes) gets deleted by the server and node automatically lose the election.\n+  // By bringing down the node, the health monitoring services to restart the service is expected.\n+  // This exit call will invoke the shutdownhook and will bring down the system. This is currently\n+  // supported using a knob and adding shutdownhook will ensure the clean shutdown.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3MTIzNQ==", "bodyText": "nit: for consistency prepend the comment with \"ZkStateChangeListener::\"?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417471235", "createdAt": "2020-04-29T17:02:41Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1435,8 +1474,70 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener:: handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:\n+          _timer.cancel();\n+          onBecomeFollower();\n+          exitOnSessionExpiryOrEstablishmentError();\n+          return;\n+        case Disconnected:\n+          // if the session has expired it means that all the registration's ephemeral nodes are gone.\n+          LOG.warn(\"Got {} event. Scheduling a system stop.\", state.toString());\n+          scheduleExpiryTimerAfterSessionTimeout();\n+          return;\n+        case SyncConnected:\n+          LOG.info(\"ZkStateChangeListener::Connected. Canceling timer.\");\n+          _timer.cancel();\n+          return;\n+        default:\n+          // Ignoring AuthFailed for now.\n+      }\n+    }\n+\n+    @Override\n+    public void handleNewSession() {\n+      LOG.info(\"ZkStateChangeListener:: A new session established.\");\n+    }\n+\n+    @Override\n+    public void handleSessionEstablishmentError(final Throwable error) {\n+      LOG.error(\"ZkStateChangeListener:: Failed to establish session.\", error);\n+      exitOnSessionExpiryOrEstablishmentError();\n+    }\n+  }\n+\n+  private void scheduleExpiryTimerAfterSessionTimeout() {\n+    TimerTask timerTask = new TimerTask() {\n+      public void run() {\n+        exitOnSessionExpiryOrEstablishmentError();\n+      }\n+    };\n+    _timer.schedule(timerTask, _sessionTimeoutMs);\n+  }\n+\n+  // This is a temporary change to bring down the node on session expiry. We expect this to happen rarely.\n+  // We are working on the transition of leader to follower on session expiry. On session expiry,\n+  // the live instance (ephemeral nodes) gets deleted by the server and node automatically lose the election.\n+  // By bringing down the node, the health monitoring services to restart the service is expected.\n+  // This exit call will invoke the shutdownhook and will bring down the system. This is currently\n+  // supported using a knob and adding shutdownhook will ensure the clean shutdown.\n+  private void exitOnSessionExpiryOrEstablishmentError() {\n+    if (_exitOnSessionExpiry) {\n+      LOG.warn(\"Calling Exit 1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3ODA3MQ==", "bodyText": "It will be helpful to validate that exitOnSessionExpiryOrEstablishmentError() is indeed called on session expiry", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417478071", "createdAt": "2020-04-29T17:13:34Z", "author": {"login": "somandal"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -715,9 +725,76 @@ ZkClient createZkClient() {\n       return _zkClient;\n     }\n \n+    public class ZkClientMockStateChangeListener extends ZkStateChangeListener {\n+      boolean sessionExpired = false;\n+      @Override\n+      public void handleStateChanged(Watcher.Event.KeeperState state) {\n+        super.handleStateChanged(state);\n+        if (state == Watcher.Event.KeeperState.Expired) {\n+          LOG.info(\"ZkStateChangeListener::Session expired.\");\n+          sessionExpired = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    ZkStateChangeListener getOrCreateStateChangeListener() {\n+      _zkClientMockStateChangeListener = new ZkClientMockStateChangeListener();\n+      return _zkClientMockStateChangeListener;\n+    }\n+\n     public ZkClient getZkClient() {\n       return _zkClient;\n     }\n+\n+    public ZkClientMockStateChangeListener getZkStateChangeListener() {\n+      return _zkClientMockStateChangeListener;\n+    }\n+  }\n+\n+  @Test\n+  public void testZookeeperSessionExpiry() throws InterruptedException {\n+    String testCluster = \"testDeleteTaskWithPrefix\";\n+    String connectorType = \"connectorType\";\n+    Duration timeout = Duration.ofMinutes(1);\n+\n+    ZkClientInterceptingAdapter adapter = createInterceptingZkAdapter(testCluster, 5000);\n+    adapter.connect();\n+\n+    DatastreamTaskImpl task = new DatastreamTaskImpl();\n+    task.setId(\"3\");\n+    task.setConnectorType(connectorType);\n+    task.setZkAdapter(adapter);\n+\n+    List<DatastreamTask> tasks = new ArrayList<>();\n+    tasks.add(task);\n+    updateInstanceAssignment(adapter, adapter.getInstanceName(), tasks);\n+\n+    LOG.info(\"Acquire from instance1 should succeed\");\n+    Assert.assertTrue(expectException(() -> task.acquire(timeout), false));\n+\n+    simulateSessionExpiration(adapter);\n+\n+    Thread.sleep(5000);\n+    Assert.assertTrue(adapter.getZkStateChangeListener().sessionExpired);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3OTA4OQ==", "bodyText": "Is is possible to simulate the \"Disconnected\" state? If so, can we add a test for that, and validate that scheduleExpiryTimerAfterSessionTimeout() is indeed called too? Then validate two cases, a) Let it expire and validate that exitOnSessionExpiryOrEstablishmentError() is called, b) Don't let it expire, and validate that exitOnSessionExpiryOrEstablishmentError()  is not called.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r417479089", "createdAt": "2020-04-29T17:15:08Z", "author": {"login": "somandal"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -715,9 +725,76 @@ ZkClient createZkClient() {\n       return _zkClient;\n     }\n \n+    public class ZkClientMockStateChangeListener extends ZkStateChangeListener {\n+      boolean sessionExpired = false;\n+      @Override\n+      public void handleStateChanged(Watcher.Event.KeeperState state) {\n+        super.handleStateChanged(state);\n+        if (state == Watcher.Event.KeeperState.Expired) {\n+          LOG.info(\"ZkStateChangeListener::Session expired.\");\n+          sessionExpired = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    ZkStateChangeListener getOrCreateStateChangeListener() {\n+      _zkClientMockStateChangeListener = new ZkClientMockStateChangeListener();\n+      return _zkClientMockStateChangeListener;\n+    }\n+\n     public ZkClient getZkClient() {\n       return _zkClient;\n     }\n+\n+    public ZkClientMockStateChangeListener getZkStateChangeListener() {\n+      return _zkClientMockStateChangeListener;\n+    }\n+  }\n+\n+  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 69}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63b60c7f4f4e03efb7914066fa4918809692a4bd", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/63b60c7f4f4e03efb7914066fa4918809692a4bd", "committedDate": "2020-05-04T08:05:17Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b1673da7f51b26c8542fdcf81937b861532dcf7", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/4b1673da7f51b26c8542fdcf81937b861532dcf7", "committedDate": "2020-07-13T23:38:22Z", "message": "Remove exit code path"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "792fd213294d155645a0e623f604b74ade19654f", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/792fd213294d155645a0e623f604b74ade19654f", "committedDate": "2020-07-13T23:43:48Z", "message": "Merge branch 'master' of github.com:linkedin/brooklin into zkCleanup1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/018e58466611f51f145b03a4a3cdf78a9690b0f2", "committedDate": "2020-07-14T00:04:17Z", "message": "Code cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNjQ4NTg5", "url": "https://github.com/linkedin/brooklin/pull/699#pullrequestreview-451648589", "createdAt": "2020-07-20T14:16:40Z", "commit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNDoxNjo0MFrOG0PHPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDoyNzo1MVrOG0eF7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQyNjc0OQ==", "bodyText": "toString() is redundant here and on line 1554", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457426749", "createdAt": "2020-07-20T14:16:40Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1508,8 +1531,61 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener::handleStateChanged {}\", state.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMzY2OA==", "bodyText": "can be marked final\nI think we should use new Timer(true) so the timer uses a daemon thread\n_timer feels like an implementation detail of ZkStateChangeListener. It may be nicer to move it over there instead.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457433668", "createdAt": "2020-07-20T14:24:06Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -137,6 +142,7 @@\n \n   // Cache all live DatastreamTasks per instance for assignment strategy\n   private Map<String, Set<DatastreamTask>> _liveTaskMap = new HashMap<>();\n+  private Timer _timer = new Timer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3MTUwNA==", "bodyText": "Removing it will make the situation worse, if this PR has any bugs.\n\nCould you please explain why? Your previous analysis shows that, in the case of session expiry, calling disconnect() here causes the subsequent createZkClient() to throw since the current thread's interrupted flag is set during disconnect().", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457471504", "createdAt": "2020-07-20T15:04:08Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -222,14 +248,22 @@ ZkClient createZkClient() {\n     return new ZkClient(_zkServers, _sessionTimeoutMs, _connectionTimeoutMs, _operationRetryTimeoutMs);\n   }\n \n+  @VisibleForTesting\n+  ZkStateChangeListener getOrCreateStateChangeListener() {\n+    if (_stateChangeListener == null) {\n+      _stateChangeListener = new ZkStateChangeListener();\n+    }\n+    return _stateChangeListener;\n+  }\n+\n   /**\n    * Connect the adapter so that it can connect and bridge events between ZooKeeper changes and\n    * the actions that need to be taken with them, which are implemented in the Coordinator class\n    */\n   public void connect() {\n     disconnect(); // Guard against leaking an existing zookeeper session", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNzY2Nw=="}, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ5NTg3Nw==", "bodyText": "Not your fault but it's a thought I'd like to share with you: we have quite a few _zkclient subscriptions (subscribeChildChanges(), subscribeDataChanges(), and this new subscribeStateChanges()) that are not undone on the old ZK client when we instantiate a new one. I understand that unsubscribing isn't strictly required if we always close the old _zkclient first. However, this assumes that all the relevant pieces of code don't have issues that could cause the old ZK client instance to invoke listeners after _zkclient is reinitialized.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457495877", "createdAt": "2020-07-20T15:30:00Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -222,14 +229,22 @@ ZkClient createZkClient() {\n     return new ZkClient(_zkServers, _sessionTimeoutMs, _connectionTimeoutMs, _operationRetryTimeoutMs);\n   }\n \n+  @VisibleForTesting\n+  ZkStateChangeListener getOrCreateStateChangeListener() {\n+    if (_stateChangeListener == null) {\n+      _stateChangeListener = new ZkStateChangeListener();\n+    }\n+    return _stateChangeListener;\n+  }\n+\n   /**\n    * Connect the adapter so that it can connect and bridge events between ZooKeeper changes and\n    * the actions that need to be taken with them, which are implemented in the Coordinator class\n    */\n   public void connect() {\n     disconnect(); // Guard against leaking an existing zookeeper session\n     _zkclient = createZkClient();\n-\n+    _zkclient.subscribeStateChanges(getOrCreateStateChangeListener());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyMzcyMA==", "bodyText": "Not your fault. This comment pertains to the two unsubscribeDataChanges() calls made in this method (lines 354 and 372).\n\n_currentSubscription is only ever set to null and prevCandidate\nprevCandidate is chosen from liveInstances, a string list of the form [\"0000000052\", \"0000000053\", .... ]\nWhen subscribing to data changes for leaderElectionListener, we use KeyBuilder.liveInstance(_cluster, _currentSubscription) as path (e.g. clusterName/liveinstances/0000000052)\nWhen unsubscribing, we use _currentSubscription as path (e.g. \"0000000052\")\n\nI think this means that un-subscriptions are broken.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457523720", "createdAt": "2020-07-20T16:03:39Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -334,6 +349,12 @@ private void joinLeaderElection() {\n \n     // if this instance is first in line to become leader. Check if it is already a leader.\n     if (index == 0) {\n+      // The node at index 0 is a leader and does not have to listen on a previous node anymore.\n+      if (_currentSubscription != null) {\n+        _zkclient.unsubscribeDataChanges(_currentSubscription, _leaderElectionListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzNDc1OA==", "bodyText": "I like marking the class private but not the ctor or close(). I'd rather leave those two public.\nMy rationale is: marking them private has no practical effect on accessibility for the enclosing class; it can access everything. However, marking them public is documentation to the reader that these methods are the ones intended for use by the enclosing class, whereas the ones marked private are meant to be considered implementation details of the inner class.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457534758", "createdAt": "2020-07-20T16:21:02Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1265,13 +1286,13 @@ public static String parseHostnameFromZkInstance(String instance) {\n    * Data provider class to provide an updated list of datastreams for the cluster by watching\n    * ZooKeeper znodes under <i>/{cluster}/dms/</i>.\n    */\n-  public class ZkBackedDMSDatastreamList implements IZkChildListener, IZkDataListener {\n+  private class ZkBackedDMSDatastreamList implements IZkChildListener, IZkDataListener {\n     private final String _path;\n \n     /**\n      * Sets up a watch on the {@code /{cluster}/dms} tree, so it can be notified of future changes.\n      */\n-    public ZkBackedDMSDatastreamList() {\n+    private ZkBackedDMSDatastreamList() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU3MTc3Mw==", "bodyText": "Same comment as the one on ZkBackedDMSDatastreamList's ctor", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457571773", "createdAt": "2020-07-20T17:23:15Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1371,12 +1393,12 @@ public void close() {\n       _zkclient.unsubscribeChildChanges(_path, this);\n     }\n \n-    public List<String> getLiveInstances() {\n+    private List<String> getLiveInstances() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU3Mzk3MQ==", "bodyText": "Not your fault but since you're touching this class: I think it would be better to reverse the order of these two lines to avoid race conditions since subscribing to child changes may cause the event handler to be fired, which also writes to _liveInstances.\n      _zkclient.subscribeChildChanges(_path, this);\n      _liveInstances = getLiveInstanceNames(_zkclient.getChildren(_path));", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457573971", "createdAt": "2020-07-20T17:27:00Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1331,8 +1353,8 @@ public void handleDataDeleted(String dataPath) throws Exception {\n    * the new leader is responsible for cleaning up the instance node for the previous leader. This is\n    * done in the constructor ZkBackedLiveInstanceListProvider().\n    */\n-  public class ZkBackedLiveInstanceListProvider implements IZkChildListener {\n-    private List<String> _liveInstances = new ArrayList<>();\n+  private class ZkBackedLiveInstanceListProvider implements IZkChildListener {\n+    private List<String> _liveInstances;\n     private final String _path;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU3NzAyNg==", "bodyText": "Not your fault: can be marked private final", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457577026", "createdAt": "2020-07-20T17:32:18Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1453,15 +1476,15 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n \n   /**\n    * ZkTargetAssignmentProvider detect if there is a partition movement being intiated from restful endpoint\n    */\n-  public class ZkTargetAssignmentProvider implements IZkDataListener {\n+  private class ZkTargetAssignmentProvider implements IZkDataListener {\n     Set<String> _listenedConnectors = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU4MTQ3Ng==", "bodyText": "Do we need to instantiate a different one every time?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457581476", "createdAt": "2020-07-20T17:39:55Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1508,8 +1531,61 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener::handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:\n+          _timer.cancel();\n+          onSessionExpired();\n+          return;\n+        case Disconnected:\n+          // Wait for session timeout after disconnect to consider that the session has expired.\n+          LOG.warn(\"ZkStateChangeListener::Got {} event. Scheduling a system stop.\", state.toString());\n+          scheduleExpiryTimerAfterSessionTimeout();\n+          return;\n+        case SyncConnected:\n+          LOG.info(\"ZkStateChangeListener::Connected. Canceling timer.\");\n+          _timer.cancel();\n+          return;\n+        default:\n+          // Ignoring AuthFailed for now.\n+      }\n+    }\n+\n+    @Override\n+    public void handleNewSession() {\n+      LOG.info(\"ZkStateChangeListener::A new session has been established.\");\n+    }\n+\n+    @Override\n+    public void handleSessionEstablishmentError(final Throwable error) {\n+      LOG.error(\"ZkStateChangeListener::Failed to establish session.\", error);\n+    }\n+  }\n+\n+  private void scheduleExpiryTimerAfterSessionTimeout() {\n+    TimerTask timerTask = new TimerTask() {\n+      public void run() {\n+        onSessionExpired();\n+      }\n+    };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU4NTk4Nw==", "bodyText": "Once cancelled, _timer will no longer be usable; any subsequent calls to schedule() will throw.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457585987", "createdAt": "2020-07-20T17:47:46Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1508,8 +1531,61 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener::handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:\n+          _timer.cancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5NTIzMg==", "bodyText": "Does this mean onSessionExpired() will be called twice in case of session expiry, once when Disconnected's timer elapses and another when state becomes Expired?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457595232", "createdAt": "2020-07-20T18:03:51Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1508,8 +1531,61 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener::handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5NzYzOA==", "bodyText": "Should we log the rest anyways so we get to see the different states and build some familiarity with the transitions in different scenarios?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457597638", "createdAt": "2020-07-20T18:08:14Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1508,8 +1531,61 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  @VisibleForTesting\n+  class ZkStateChangeListener implements IZkStateListener {\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener::handleStateChanged {}\", state.toString());\n+      switch (state) {\n+        case Expired:\n+          _timer.cancel();\n+          onSessionExpired();\n+          return;\n+        case Disconnected:\n+          // Wait for session timeout after disconnect to consider that the session has expired.\n+          LOG.warn(\"ZkStateChangeListener::Got {} event. Scheduling a system stop.\", state.toString());\n+          scheduleExpiryTimerAfterSessionTimeout();\n+          return;\n+        case SyncConnected:\n+          LOG.info(\"ZkStateChangeListener::Connected. Canceling timer.\");\n+          _timer.cancel();\n+          return;\n+        default:\n+          // Ignoring AuthFailed for now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0MjAxNA==", "bodyText": "For consistency's sake, shouldn't we have ZkStateChangeListener's ctor do _zkclient.subscribeStateChanges(...) instead? This is what all the current listeners do (e.g. ZkLeaderElectionListener, ZkBackedTaskListProvider ... etc).", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457642014", "createdAt": "2020-07-20T19:29:40Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -222,14 +229,22 @@ ZkClient createZkClient() {\n     return new ZkClient(_zkServers, _sessionTimeoutMs, _connectionTimeoutMs, _operationRetryTimeoutMs);\n   }\n \n+  @VisibleForTesting\n+  ZkStateChangeListener getOrCreateStateChangeListener() {\n+    if (_stateChangeListener == null) {\n+      _stateChangeListener = new ZkStateChangeListener();\n+    }\n+    return _stateChangeListener;\n+  }\n+\n   /**\n    * Connect the adapter so that it can connect and bridge events between ZooKeeper changes and\n    * the actions that need to be taken with them, which are implemented in the Coordinator class\n    */\n   public void connect() {\n     disconnect(); // Guard against leaking an existing zookeeper session\n     _zkclient = createZkClient();\n-\n+    _zkclient.subscribeStateChanges(getOrCreateStateChangeListener());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0NDY3OQ==", "bodyText": "I feel a little concerned that this method gets-or-creates as opposed to create-only because it implies that extenders/overriders won't be able to set _stateChangeListener.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457644679", "createdAt": "2020-07-20T19:34:51Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -222,14 +229,22 @@ ZkClient createZkClient() {\n     return new ZkClient(_zkServers, _sessionTimeoutMs, _connectionTimeoutMs, _operationRetryTimeoutMs);\n   }\n \n+  @VisibleForTesting\n+  ZkStateChangeListener getOrCreateStateChangeListener() {\n+    if (_stateChangeListener == null) {\n+      _stateChangeListener = new ZkStateChangeListener();\n+    }\n+    return _stateChangeListener;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0NjUyNA==", "bodyText": "private?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457646524", "createdAt": "2020-07-20T19:38:25Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -716,9 +726,77 @@ ZkClient createZkClient() {\n       return _zkClient;\n     }\n \n+    public class ZkClientMockStateChangeListener extends ZkStateChangeListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0NjYzMg==", "bodyText": "private", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457646632", "createdAt": "2020-07-20T19:38:37Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -716,9 +726,77 @@ ZkClient createZkClient() {\n       return _zkClient;\n     }\n \n+    public class ZkClientMockStateChangeListener extends ZkStateChangeListener {\n+      boolean sessionExpired = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1NzU4NQ==", "bodyText": "_connection is actually protected. I find it better to introduce a package private method on com.linkedin.datastream.common.zk.ZkClient to retrieve the session ID.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457657585", "createdAt": "2020-07-20T19:59:16Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -716,9 +726,77 @@ ZkClient createZkClient() {\n       return _zkClient;\n     }\n \n+    public class ZkClientMockStateChangeListener extends ZkStateChangeListener {\n+      boolean sessionExpired = false;\n+      @Override\n+      public void handleStateChanged(Watcher.Event.KeeperState state) {\n+        super.handleStateChanged(state);\n+        if (state == Watcher.Event.KeeperState.Expired) {\n+          LOG.info(\"ZkStateChangeListener::Session expired.\");\n+          sessionExpired = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    ZkStateChangeListener getOrCreateStateChangeListener() {\n+      _zkClientMockStateChangeListener = spy(new ZkClientMockStateChangeListener());\n+      return _zkClientMockStateChangeListener;\n+    }\n+\n     public ZkClient getZkClient() {\n       return _zkClient;\n     }\n+\n+    public ZkClientMockStateChangeListener getZkStateChangeListener() {\n+      return _zkClientMockStateChangeListener;\n+    }\n+  }\n+\n+  @Test\n+  public void testZookeeperSessionExpiry() throws InterruptedException {\n+    String testCluster = \"testDeleteTaskWithPrefix\";\n+    String connectorType = \"connectorType\";\n+    Duration timeout = Duration.ofMinutes(1);\n+\n+    ZkClientInterceptingAdapter adapter = createInterceptingZkAdapter(testCluster, 5000);\n+    adapter.connect();\n+\n+    DatastreamTaskImpl task = new DatastreamTaskImpl();\n+    task.setId(\"3\");\n+    task.setConnectorType(connectorType);\n+    task.setZkAdapter(adapter);\n+\n+    List<DatastreamTask> tasks = new ArrayList<>();\n+    tasks.add(task);\n+    updateInstanceAssignment(adapter, adapter.getInstanceName(), tasks);\n+\n+    LOG.info(\"Acquire from instance1 should succeed\");\n+    Assert.assertTrue(expectException(() -> task.acquire(timeout), false));\n+\n+    simulateSessionExpiration(adapter);\n+\n+    Thread.sleep(5000);\n+    Assert.assertTrue(adapter.getZkStateChangeListener().sessionExpired);\n+    Mockito.verify(adapter, Mockito.times(1)).onSessionExpired();\n+  }\n+\n+  private void simulateSessionExpiration(ZkClientInterceptingAdapter adapter) {\n+    ZkConnection zkConnection = null;\n+    try {\n+      Field privateField = ZkClient.class.getSuperclass().getDeclaredField(\"_connection\");\n+      privateField.setAccessible(true);\n+      zkConnection = (ZkConnection) privateField.get(adapter.getZkClient());\n+    } catch (NoSuchFieldException | IllegalAccessException e) {\n+      Assert.fail(e.toString());\n+    }\n+\n+    ZooKeeper zookeeper = zkConnection.getZookeeper();\n+    long sessionId = zookeeper.getSessionId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2MDI0Ng==", "bodyText": "Collections.singletonList()?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457660246", "createdAt": "2020-07-20T20:04:28Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -716,9 +726,77 @@ ZkClient createZkClient() {\n       return _zkClient;\n     }\n \n+    public class ZkClientMockStateChangeListener extends ZkStateChangeListener {\n+      boolean sessionExpired = false;\n+      @Override\n+      public void handleStateChanged(Watcher.Event.KeeperState state) {\n+        super.handleStateChanged(state);\n+        if (state == Watcher.Event.KeeperState.Expired) {\n+          LOG.info(\"ZkStateChangeListener::Session expired.\");\n+          sessionExpired = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    ZkStateChangeListener getOrCreateStateChangeListener() {\n+      _zkClientMockStateChangeListener = spy(new ZkClientMockStateChangeListener());\n+      return _zkClientMockStateChangeListener;\n+    }\n+\n     public ZkClient getZkClient() {\n       return _zkClient;\n     }\n+\n+    public ZkClientMockStateChangeListener getZkStateChangeListener() {\n+      return _zkClientMockStateChangeListener;\n+    }\n+  }\n+\n+  @Test\n+  public void testZookeeperSessionExpiry() throws InterruptedException {\n+    String testCluster = \"testDeleteTaskWithPrefix\";\n+    String connectorType = \"connectorType\";\n+    Duration timeout = Duration.ofMinutes(1);\n+\n+    ZkClientInterceptingAdapter adapter = createInterceptingZkAdapter(testCluster, 5000);\n+    adapter.connect();\n+\n+    DatastreamTaskImpl task = new DatastreamTaskImpl();\n+    task.setId(\"3\");\n+    task.setConnectorType(connectorType);\n+    task.setZkAdapter(adapter);\n+\n+    List<DatastreamTask> tasks = new ArrayList<>();\n+    tasks.add(task);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY2MjY5Mg==", "bodyText": "Please excuse my ignorance: why do we have to sleep for that long? Is it because this is the value we specified for sessionTimeoutMs? If that's the reason, should we decrease that value?", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457662692", "createdAt": "2020-07-20T20:09:28Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -716,9 +726,77 @@ ZkClient createZkClient() {\n       return _zkClient;\n     }\n \n+    public class ZkClientMockStateChangeListener extends ZkStateChangeListener {\n+      boolean sessionExpired = false;\n+      @Override\n+      public void handleStateChanged(Watcher.Event.KeeperState state) {\n+        super.handleStateChanged(state);\n+        if (state == Watcher.Event.KeeperState.Expired) {\n+          LOG.info(\"ZkStateChangeListener::Session expired.\");\n+          sessionExpired = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    ZkStateChangeListener getOrCreateStateChangeListener() {\n+      _zkClientMockStateChangeListener = spy(new ZkClientMockStateChangeListener());\n+      return _zkClientMockStateChangeListener;\n+    }\n+\n     public ZkClient getZkClient() {\n       return _zkClient;\n     }\n+\n+    public ZkClientMockStateChangeListener getZkStateChangeListener() {\n+      return _zkClientMockStateChangeListener;\n+    }\n+  }\n+\n+  @Test\n+  public void testZookeeperSessionExpiry() throws InterruptedException {\n+    String testCluster = \"testDeleteTaskWithPrefix\";\n+    String connectorType = \"connectorType\";\n+    Duration timeout = Duration.ofMinutes(1);\n+\n+    ZkClientInterceptingAdapter adapter = createInterceptingZkAdapter(testCluster, 5000);\n+    adapter.connect();\n+\n+    DatastreamTaskImpl task = new DatastreamTaskImpl();\n+    task.setId(\"3\");\n+    task.setConnectorType(connectorType);\n+    task.setZkAdapter(adapter);\n+\n+    List<DatastreamTask> tasks = new ArrayList<>();\n+    tasks.add(task);\n+    updateInstanceAssignment(adapter, adapter.getInstanceName(), tasks);\n+\n+    LOG.info(\"Acquire from instance1 should succeed\");\n+    Assert.assertTrue(expectException(() -> task.acquire(timeout), false));\n+\n+    simulateSessionExpiration(adapter);\n+\n+    Thread.sleep(5000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY3MjE3NA==", "bodyText": "Unless you foresee a good reason to keep it the way it is, I'd suggest introducing a closeSession() on EmbeddedZookeeper to limit the exposed internals.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r457672174", "createdAt": "2020-07-20T20:27:51Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -716,9 +726,77 @@ ZkClient createZkClient() {\n       return _zkClient;\n     }\n \n+    public class ZkClientMockStateChangeListener extends ZkStateChangeListener {\n+      boolean sessionExpired = false;\n+      @Override\n+      public void handleStateChanged(Watcher.Event.KeeperState state) {\n+        super.handleStateChanged(state);\n+        if (state == Watcher.Event.KeeperState.Expired) {\n+          LOG.info(\"ZkStateChangeListener::Session expired.\");\n+          sessionExpired = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    ZkStateChangeListener getOrCreateStateChangeListener() {\n+      _zkClientMockStateChangeListener = spy(new ZkClientMockStateChangeListener());\n+      return _zkClientMockStateChangeListener;\n+    }\n+\n     public ZkClient getZkClient() {\n       return _zkClient;\n     }\n+\n+    public ZkClientMockStateChangeListener getZkStateChangeListener() {\n+      return _zkClientMockStateChangeListener;\n+    }\n+  }\n+\n+  @Test\n+  public void testZookeeperSessionExpiry() throws InterruptedException {\n+    String testCluster = \"testDeleteTaskWithPrefix\";\n+    String connectorType = \"connectorType\";\n+    Duration timeout = Duration.ofMinutes(1);\n+\n+    ZkClientInterceptingAdapter adapter = createInterceptingZkAdapter(testCluster, 5000);\n+    adapter.connect();\n+\n+    DatastreamTaskImpl task = new DatastreamTaskImpl();\n+    task.setId(\"3\");\n+    task.setConnectorType(connectorType);\n+    task.setZkAdapter(adapter);\n+\n+    List<DatastreamTask> tasks = new ArrayList<>();\n+    tasks.add(task);\n+    updateInstanceAssignment(adapter, adapter.getInstanceName(), tasks);\n+\n+    LOG.info(\"Acquire from instance1 should succeed\");\n+    Assert.assertTrue(expectException(() -> task.acquire(timeout), false));\n+\n+    simulateSessionExpiration(adapter);\n+\n+    Thread.sleep(5000);\n+    Assert.assertTrue(adapter.getZkStateChangeListener().sessionExpired);\n+    Mockito.verify(adapter, Mockito.times(1)).onSessionExpired();\n+  }\n+\n+  private void simulateSessionExpiration(ZkClientInterceptingAdapter adapter) {\n+    ZkConnection zkConnection = null;\n+    try {\n+      Field privateField = ZkClient.class.getSuperclass().getDeclaredField(\"_connection\");\n+      privateField.setAccessible(true);\n+      zkConnection = (ZkConnection) privateField.get(adapter.getZkClient());\n+    } catch (NoSuchFieldException | IllegalAccessException e) {\n+      Assert.fail(e.toString());\n+    }\n+\n+    ZooKeeper zookeeper = zkConnection.getZookeeper();\n+    long sessionId = zookeeper.getSessionId();\n+\n+    LOG.info(\"Closing/expiring session:\" + sessionId);\n+    ZooKeeperServer zkServer = _embeddedZookeeper.getZooKeeperServer();\n+    zkServer.closeSession(sessionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018e58466611f51f145b03a4a3cdf78a9690b0f2"}, "originalPosition": 113}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb3ac236a2f7b944b32f05301fe70f2bb831af22", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/eb3ac236a2f7b944b32f05301fe70f2bb831af22", "committedDate": "2020-07-21T16:37:07Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6087d8b7ea3b918e5d70320a44ccdd6df7da07aa", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/6087d8b7ea3b918e5d70320a44ccdd6df7da07aa", "committedDate": "2020-07-21T17:31:17Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ed0181aa2f533369203610bb7b1fbd68699c531", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/2ed0181aa2f533369203610bb7b1fbd68699c531", "committedDate": "2020-07-21T23:12:30Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7fad426f932942ef6921d70ad6182df15eac3e1", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/b7fad426f932942ef6921d70ad6182df15eac3e1", "committedDate": "2020-07-21T23:17:17Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyOTY3MDc1", "url": "https://github.com/linkedin/brooklin/pull/699#pullrequestreview-452967075", "createdAt": "2020-07-22T03:19:19Z", "commit": {"oid": "b7fad426f932942ef6921d70ad6182df15eac3e1"}, "state": "DISMISSED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMzoxOToxOVrOG1ROHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNjowMjo1MVrOG1T56A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwOTg1NA==", "bodyText": "If you decide to keep _timer, we can stash this variable in a private field since we don't need to create a new one every time this method is called.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r458509854", "createdAt": "2020-07-22T03:19:19Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1508,8 +1547,89 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  private class ZkStateChangeListener implements IZkStateListener {\n+    private Timer _timer;\n+\n+    public ZkStateChangeListener() {\n+      _zkclient.subscribeStateChanges(this);\n+    }\n+\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener::handleStateChanged {}\", state);\n+      switch (state) {\n+        case Expired:\n+          cancelTimer();\n+          onSessionExpired();\n+          return;\n+        case Disconnected:\n+          // Wait for session timeout after disconnect to consider that the session has expired.\n+          LOG.warn(\"ZkStateChangeListener::Got {} event. Scheduling a system stop.\", state);\n+          scheduleExpiryTimerAfterSessionTimeout();\n+          resetSession.set(true);\n+          return;\n+        case SyncConnected:\n+          LOG.info(\"ZkStateChangeListener::Connected. Canceling timer.\");\n+          cancelTimer();\n+          return;\n+        default:\n+          // Ignoring AuthFailed for now.\n+      }\n+    }\n+\n+    @Override\n+    public void handleNewSession() {\n+      LOG.info(\"ZkStateChangeListener::A new session has been established.\");\n+    }\n+\n+    @Override\n+    public void handleSessionEstablishmentError(final Throwable error) {\n+      LOG.error(\"ZkStateChangeListener::Failed to establish session.\", error);\n+    }\n+\n+    public void close() {\n+      _zkclient.unsubscribeStateChanges(this);\n+    }\n+\n+    private void scheduleExpiryTimerAfterSessionTimeout() {\n+      if (_timer == null) {\n+        _timer = new Timer(true);\n+      }\n+      TimerTask timerTask = new TimerTask() {\n+        public void run() {\n+          if (resetSession.get()) {\n+            onSessionExpired();\n+          }\n+        }\n+      };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7fad426f932942ef6921d70ad6182df15eac3e1"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUxNjEwNg==", "bodyText": "Do we really need this variable (resetSession)?\nAs far as I can tell (and please correct me if I'm wrong) it's intended to protect against double invocations of onSessionExpired(). Would it be simpler to do that by checking isLeader at the beginning of onBecomeFollower() instead?\n  private void onBecomeFollower() {\n    if (!_isLeader) {\n        return;\n    }\n    ...\n  }", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r458516106", "createdAt": "2020-07-22T03:44:19Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1508,8 +1547,89 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  private class ZkStateChangeListener implements IZkStateListener {\n+    private Timer _timer;\n+\n+    public ZkStateChangeListener() {\n+      _zkclient.subscribeStateChanges(this);\n+    }\n+\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener::handleStateChanged {}\", state);\n+      switch (state) {\n+        case Expired:\n+          cancelTimer();\n+          onSessionExpired();\n+          return;\n+        case Disconnected:\n+          // Wait for session timeout after disconnect to consider that the session has expired.\n+          LOG.warn(\"ZkStateChangeListener::Got {} event. Scheduling a system stop.\", state);\n+          scheduleExpiryTimerAfterSessionTimeout();\n+          resetSession.set(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7fad426f932942ef6921d70ad6182df15eac3e1"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MzgzMg==", "bodyText": "I think the code would be a lot simpler if we used a ScheduledExecutorService instead of this Timer.\nHere's what I'm thinking:\n\nWe declare two fields:\n    private final ScheduledExecutorService _scheduledExecutorService;\n    private Future<?> _zkSessionExpiryFuture = CompletableFuture.completedFuture(null);\n\nWe change cancelTimer() to do:\n_zkSessionExpiryFuture.cancel(false);\n\nWe change scheduleExpiryTimerAfterSessionTimeout() to do:\n _zkSessionExpiryFuture =\n      _scheduledExecutorService.schedule(ZkAdapter.this::onSessionExpired, _sessionTimeoutMs,\n          TimeUnit.MILLISECONDS);", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r458553832", "createdAt": "2020-07-22T06:02:51Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1508,8 +1547,89 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  private class ZkStateChangeListener implements IZkStateListener {\n+    private Timer _timer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7fad426f932942ef6921d70ad6182df15eac3e1"}, "originalPosition": 309}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNDk0Njgw", "url": "https://github.com/linkedin/brooklin/pull/699#pullrequestreview-453494680", "createdAt": "2020-07-22T16:37:25Z", "commit": {"oid": "b7fad426f932942ef6921d70ad6182df15eac3e1"}, "state": "DISMISSED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNjozNzoyNVrOG1q5-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNjozOToyNlrOG1q-5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkzMDY4Mw==", "bodyText": "@vmaheshw Personally, it'll be much easier to review any changes related to ZK session expiry once I've seen your design and implementation plan. It can avoid unnecessary confusion like this. It'd be nice if you can prioritize working on that before sending out further PRs. It will also help with prioritizing the next steps.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r458930683", "createdAt": "2020-07-22T16:37:25Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -222,14 +248,22 @@ ZkClient createZkClient() {\n     return new ZkClient(_zkServers, _sessionTimeoutMs, _connectionTimeoutMs, _operationRetryTimeoutMs);\n   }\n \n+  @VisibleForTesting\n+  ZkStateChangeListener getOrCreateStateChangeListener() {\n+    if (_stateChangeListener == null) {\n+      _stateChangeListener = new ZkStateChangeListener();\n+    }\n+    return _stateChangeListener;\n+  }\n+\n   /**\n    * Connect the adapter so that it can connect and bridge events between ZooKeeper changes and\n    * the actions that need to be taken with them, which are implemented in the Coordinator class\n    */\n   public void connect() {\n     disconnect(); // Guard against leaking an existing zookeeper session", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNzY2Nw=="}, "originalCommit": {"oid": "34ad17da1851dc612824533af0b64cd8e1a20595"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkzMTY1NA==", "bodyText": "+1, I like this suggestion more than using the _timer", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r458931654", "createdAt": "2020-07-22T16:38:59Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1508,8 +1547,89 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  private class ZkStateChangeListener implements IZkStateListener {\n+    private Timer _timer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MzgzMg=="}, "originalCommit": {"oid": "b7fad426f932942ef6921d70ad6182df15eac3e1"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkzMTk0MA==", "bodyText": "+1 I had the same question when going through the code. I like Ahmed's suggestion here.", "url": "https://github.com/linkedin/brooklin/pull/699#discussion_r458931940", "createdAt": "2020-07-22T16:39:26Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -1508,8 +1547,89 @@ public void handleDataChange(String dataPath, Object data) throws Exception {\n     }\n \n     @Override\n-    public void handleDataDeleted(String dataPath) throws Exception {\n+    public void handleDataDeleted(String dataPath) {\n       // do nothing\n     }\n   }\n+\n+  /**\n+   * Listener for ZooKeeper state changes.\n+   */\n+  private class ZkStateChangeListener implements IZkStateListener {\n+    private Timer _timer;\n+\n+    public ZkStateChangeListener() {\n+      _zkclient.subscribeStateChanges(this);\n+    }\n+\n+    @Override\n+    public void handleStateChanged(Watcher.Event.KeeperState state) {\n+      LOG.info(\"ZkStateChangeListener::handleStateChanged {}\", state);\n+      switch (state) {\n+        case Expired:\n+          cancelTimer();\n+          onSessionExpired();\n+          return;\n+        case Disconnected:\n+          // Wait for session timeout after disconnect to consider that the session has expired.\n+          LOG.warn(\"ZkStateChangeListener::Got {} event. Scheduling a system stop.\", state);\n+          scheduleExpiryTimerAfterSessionTimeout();\n+          resetSession.set(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUxNjEwNg=="}, "originalCommit": {"oid": "b7fad426f932942ef6921d70ad6182df15eac3e1"}, "originalPosition": 327}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb24a91ed6a20b8f95ec16f7d95c7e31fc079207", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/fb24a91ed6a20b8f95ec16f7d95c7e31fc079207", "committedDate": "2020-07-22T17:27:37Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNjAzNzE1", "url": "https://github.com/linkedin/brooklin/pull/699#pullrequestreview-453603715", "createdAt": "2020-07-22T19:04:38Z", "commit": {"oid": "fb24a91ed6a20b8f95ec16f7d95c7e31fc079207"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNjA2NzIw", "url": "https://github.com/linkedin/brooklin/pull/699#pullrequestreview-453606720", "createdAt": "2020-07-22T19:08:58Z", "commit": {"oid": "fb24a91ed6a20b8f95ec16f7d95c7e31fc079207"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 411, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}