{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwOTY1NzUz", "number": 706, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzoyNzowOVrOD5gUmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTo0Nzo1MlrOD5-EVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjI0OTg3OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzoyNzowOVrOGQz-Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1NzozM1rOGSTH_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4MTg5MQ==", "bodyText": "\"removing the reused tasks\"? Did you mean removing the tasks assigned to current live instances?\n\nto avoid assignment of same task from dead instance to two live instances in case of interrupt exception.\n\nSo that part of the comment is a bit confusing here. What got interrupted? This will only make sense to people who already know the details about the problem you are solving. Instead can you modify this to talk about interrupted cleanup of ZK nodes due to shutdown during leader assignment?", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r420281891", "createdAt": "2020-05-05T17:27:09Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -59,17 +60,27 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n \n     Map<String, Set<DatastreamTask>> newAssignment = new HashMap<>();\n \n+    Set<DatastreamTask> tasksAvailableToReuse = new HashSet<>();\n     // Make a copy of the current assignment, since the strategy modifies it during calculation\n     Map<String, Set<DatastreamTask>> currentAssignmentCopy = new HashMap<>(currentAssignment.size());\n-    currentAssignment.forEach((k, v) -> currentAssignmentCopy.put(k, new HashSet<>(v)));\n+    currentAssignment.forEach((k, v) -> {\n+      currentAssignmentCopy.put(k, new HashSet<>(v));\n+      // building the full list and then removing the reused tasks rather than building the list from dead tasks\n+      // to avoid assignment of same task from dead instance to two live instances in case of interrupt exception.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAyODkyMA==", "bodyText": "Strongly agree.\nThere's a whole story behind reusing tasks assigned to dead instances. I'd suggest expanding the comment even further to explain:\n\nwhy we reuse tasks assigned to dead instances to begin with\ncaveats we consider during this reuse, like the possibility of having the same task assigned to more than one instance (and why that might happen in the first place)", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421028920", "createdAt": "2020-05-06T19:11:23Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -59,17 +60,27 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n \n     Map<String, Set<DatastreamTask>> newAssignment = new HashMap<>();\n \n+    Set<DatastreamTask> tasksAvailableToReuse = new HashSet<>();\n     // Make a copy of the current assignment, since the strategy modifies it during calculation\n     Map<String, Set<DatastreamTask>> currentAssignmentCopy = new HashMap<>(currentAssignment.size());\n-    currentAssignment.forEach((k, v) -> currentAssignmentCopy.put(k, new HashSet<>(v)));\n+    currentAssignment.forEach((k, v) -> {\n+      currentAssignmentCopy.put(k, new HashSet<>(v));\n+      // building the full list and then removing the reused tasks rather than building the list from dead tasks\n+      // to avoid assignment of same task from dead instance to two live instances in case of interrupt exception.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4MTg5MQ=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDg5NQ==", "bodyText": "Done.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421840895", "createdAt": "2020-05-07T22:57:33Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -59,17 +60,27 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n \n     Map<String, Set<DatastreamTask>> newAssignment = new HashMap<>();\n \n+    Set<DatastreamTask> tasksAvailableToReuse = new HashSet<>();\n     // Make a copy of the current assignment, since the strategy modifies it during calculation\n     Map<String, Set<DatastreamTask>> currentAssignmentCopy = new HashMap<>(currentAssignment.size());\n-    currentAssignment.forEach((k, v) -> currentAssignmentCopy.put(k, new HashSet<>(v)));\n+    currentAssignment.forEach((k, v) -> {\n+      currentAssignmentCopy.put(k, new HashSet<>(v));\n+      // building the full list and then removing the reused tasks rather than building the list from dead tasks\n+      // to avoid assignment of same task from dead instance to two live instances in case of interrupt exception.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4MTg5MQ=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjI2NDU1OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzozMDo0MlrOGQ0HfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1NzoyOVrOGSTH5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4NDI4NQ==", "bodyText": "You can modify this to be:\nreturn ((reuseTasksPerDg.size() > 0) ? reuseTasksPerDg.remove(0) : new DatastreamTaskImpl(dg.getDatastreams()));\nYou can also inline this where it is called if you'd like.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r420284285", "createdAt": "2020-05-05T17:30:42Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -93,6 +107,13 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n     return newAssignment;\n   }\n \n+  private DatastreamTask getOrCreateDatastreamTask(List<DatastreamTask> reuseTasksPerDg, DatastreamGroup dg) {\n+    if (reuseTasksPerDg.size() > 0) {\n+      return reuseTasksPerDg.remove(0);\n+    }\n+    return new DatastreamTaskImpl(dg.getDatastreams());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDg2OQ==", "bodyText": "Done.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421840869", "createdAt": "2020-05-07T22:57:29Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -93,6 +107,13 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n     return newAssignment;\n   }\n \n+  private DatastreamTask getOrCreateDatastreamTask(List<DatastreamTask> reuseTasksPerDg, DatastreamGroup dg) {\n+    if (reuseTasksPerDg.size() > 0) {\n+      return reuseTasksPerDg.remove(0);\n+    }\n+    return new DatastreamTaskImpl(dg.getDatastreams());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4NDI4NQ=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjI4MzQzOnYy", "diffSide": "RIGHT", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzozNTo0NVrOGQ0Tew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1NzoyMFrOGSTHrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4NzM1NQ==", "bodyText": "Do you need these logs in the test?", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r420287355", "createdAt": "2020-05-05T17:35:45Z", "author": {"login": "somandal"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    LOG.info(\"{}\", oldAssignmentTasks);\n+    LOG.info(\"{}\", newAssignmentTasks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NzQ5Mw==", "bodyText": "+1", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421047493", "createdAt": "2020-05-06T19:44:43Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    LOG.info(\"{}\", oldAssignmentTasks);\n+    LOG.info(\"{}\", newAssignmentTasks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4NzM1NQ=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDgxMw==", "bodyText": "Done.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421840813", "createdAt": "2020-05-07T22:57:20Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    LOG.info(\"{}\", oldAssignmentTasks);\n+    LOG.info(\"{}\", newAssignmentTasks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4NzM1NQ=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTAwNzA2OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToxNDozMVrOGRhrIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1NzoxMlrOGSTHdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMDY5MA==", "bodyText": "Not your fault: this isn't very efficient; new HashSet isn't needed if instance is not absent. This could be improved to:\n currentAssignmentCopy.computeIfAbsent(instance, i -> new HashSet<>());\nIf we do that, we could also improve line 76 by avoiding the extra get():\nSet<DatastreamTask> instanceTasks = currentAssignmentCopy.computeIfAbsent(instance, i -> new HashSet<>());\ntasksAvailableToReuse.removeAll(instanceTasks);", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421030690", "createdAt": "2020-05-06T19:14:31Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -59,17 +60,27 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n \n     Map<String, Set<DatastreamTask>> newAssignment = new HashMap<>();\n \n+    Set<DatastreamTask> tasksAvailableToReuse = new HashSet<>();\n     // Make a copy of the current assignment, since the strategy modifies it during calculation\n     Map<String, Set<DatastreamTask>> currentAssignmentCopy = new HashMap<>(currentAssignment.size());\n-    currentAssignment.forEach((k, v) -> currentAssignmentCopy.put(k, new HashSet<>(v)));\n+    currentAssignment.forEach((k, v) -> {\n+      currentAssignmentCopy.put(k, new HashSet<>(v));\n+      // building the full list and then removing the reused tasks rather than building the list from dead tasks\n+      // to avoid assignment of same task from dead instance to two live instances in case of interrupt exception.\n+      tasksAvailableToReuse.addAll(v);\n+    });\n \n     for (String instance : instances) {\n       newAssignment.put(instance, new HashSet<>());\n       currentAssignmentCopy.putIfAbsent(instance, new HashSet<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDc1OQ==", "bodyText": "Done.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421840759", "createdAt": "2020-05-07T22:57:12Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -59,17 +60,27 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n \n     Map<String, Set<DatastreamTask>> newAssignment = new HashMap<>();\n \n+    Set<DatastreamTask> tasksAvailableToReuse = new HashSet<>();\n     // Make a copy of the current assignment, since the strategy modifies it during calculation\n     Map<String, Set<DatastreamTask>> currentAssignmentCopy = new HashMap<>(currentAssignment.size());\n-    currentAssignment.forEach((k, v) -> currentAssignmentCopy.put(k, new HashSet<>(v)));\n+    currentAssignment.forEach((k, v) -> {\n+      currentAssignmentCopy.put(k, new HashSet<>(v));\n+      // building the full list and then removing the reused tasks rather than building the list from dead tasks\n+      // to avoid assignment of same task from dead instance to two live instances in case of interrupt exception.\n+      tasksAvailableToReuse.addAll(v);\n+    });\n \n     for (String instance : instances) {\n       newAssignment.put(instance, new HashSet<>());\n       currentAssignmentCopy.putIfAbsent(instance, new HashSet<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMDY5MA=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTA3MjY1OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTozMzowOVrOGRiULg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1NzowN1rOGSTHXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MTE5OA==", "bodyText": "Would it be better if we built a map of taskPrefix -> List<DatastreamTask> out of tasksAvailableToReuse before the loop on 80 instead of doing this?\nI think that'll be simpler, let alone it'll spare us having to filter tasksAvailableToReuse over and over for every dg.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421041198", "createdAt": "2020-05-06T19:33:09Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -59,17 +60,27 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n \n     Map<String, Set<DatastreamTask>> newAssignment = new HashMap<>();\n \n+    Set<DatastreamTask> tasksAvailableToReuse = new HashSet<>();\n     // Make a copy of the current assignment, since the strategy modifies it during calculation\n     Map<String, Set<DatastreamTask>> currentAssignmentCopy = new HashMap<>(currentAssignment.size());\n-    currentAssignment.forEach((k, v) -> currentAssignmentCopy.put(k, new HashSet<>(v)));\n+    currentAssignment.forEach((k, v) -> {\n+      currentAssignmentCopy.put(k, new HashSet<>(v));\n+      // building the full list and then removing the reused tasks rather than building the list from dead tasks\n+      // to avoid assignment of same task from dead instance to two live instances in case of interrupt exception.\n+      tasksAvailableToReuse.addAll(v);\n+    });\n \n     for (String instance : instances) {\n       newAssignment.put(instance, new HashSet<>());\n       currentAssignmentCopy.putIfAbsent(instance, new HashSet<>());\n+      tasksAvailableToReuse.removeAll(currentAssignmentCopy.get(instance));\n     }\n \n     int instancePos = 0;\n     for (DatastreamGroup dg : datastreams) {\n+      List<DatastreamTask> reuseTasksPerDg = tasksAvailableToReuse.stream().filter(x ->\n+          x.getTaskPrefix().equals(dg.getTaskPrefix())).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDczMg==", "bodyText": "Done.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421840732", "createdAt": "2020-05-07T22:57:07Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -59,17 +60,27 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n \n     Map<String, Set<DatastreamTask>> newAssignment = new HashMap<>();\n \n+    Set<DatastreamTask> tasksAvailableToReuse = new HashSet<>();\n     // Make a copy of the current assignment, since the strategy modifies it during calculation\n     Map<String, Set<DatastreamTask>> currentAssignmentCopy = new HashMap<>(currentAssignment.size());\n-    currentAssignment.forEach((k, v) -> currentAssignmentCopy.put(k, new HashSet<>(v)));\n+    currentAssignment.forEach((k, v) -> {\n+      currentAssignmentCopy.put(k, new HashSet<>(v));\n+      // building the full list and then removing the reused tasks rather than building the list from dead tasks\n+      // to avoid assignment of same task from dead instance to two live instances in case of interrupt exception.\n+      tasksAvailableToReuse.addAll(v);\n+    });\n \n     for (String instance : instances) {\n       newAssignment.put(instance, new HashSet<>());\n       currentAssignmentCopy.putIfAbsent(instance, new HashSet<>());\n+      tasksAvailableToReuse.removeAll(currentAssignmentCopy.get(instance));\n     }\n \n     int instancePos = 0;\n     for (DatastreamGroup dg : datastreams) {\n+      List<DatastreamTask> reuseTasksPerDg = tasksAvailableToReuse.stream().filter(x ->\n+          x.getTaskPrefix().equals(dg.getTaskPrefix())).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MTE5OA=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTA4MjM1OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTozNTo0MVrOGRiZ5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1NzowMlrOGSTHMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjY2MA==", "bodyText": "You can make this part of the previous expression by replacing orElse(null) with:\n.orElseGet(() -> getOrCreateDatastreamTask(reuseTasksPerDg, dg));", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421042660", "createdAt": "2020-05-06T19:35:41Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -78,7 +89,10 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n             .stream()\n             .filter(x -> x.getTaskPrefix().equals(dg.getTaskPrefix()))\n             .findFirst()\n-            .orElse(new DatastreamTaskImpl(dg.getDatastreams()));\n+            .orElse(null);\n+        if (foundDatastreamTask == null) {\n+          foundDatastreamTask = getOrCreateDatastreamTask(reuseTasksPerDg, dg);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDY5MQ==", "bodyText": "Done.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421840691", "createdAt": "2020-05-07T22:57:02Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -78,7 +89,10 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n             .stream()\n             .filter(x -> x.getTaskPrefix().equals(dg.getTaskPrefix()))\n             .findFirst()\n-            .orElse(new DatastreamTaskImpl(dg.getDatastreams()));\n+            .orElse(null);\n+        if (foundDatastreamTask == null) {\n+          foundDatastreamTask = getOrCreateDatastreamTask(reuseTasksPerDg, dg);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjY2MA=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTA4NTg3OnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTozNjo0NlrOGRicFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1Njo1NVrOGSTHHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MzIyMA==", "bodyText": "Removing the last one is cheaper.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421043220", "createdAt": "2020-05-06T19:36:46Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -93,6 +107,13 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n     return newAssignment;\n   }\n \n+  private DatastreamTask getOrCreateDatastreamTask(List<DatastreamTask> reuseTasksPerDg, DatastreamGroup dg) {\n+    if (reuseTasksPerDg.size() > 0) {\n+      return reuseTasksPerDg.remove(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDY2OQ==", "bodyText": "Done.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421840669", "createdAt": "2020-05-07T22:56:55Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -93,6 +107,13 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n     return newAssignment;\n   }\n \n+  private DatastreamTask getOrCreateDatastreamTask(List<DatastreamTask> reuseTasksPerDg, DatastreamGroup dg) {\n+    if (reuseTasksPerDg.size() > 0) {\n+      return reuseTasksPerDg.remove(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MzIyMA=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTA4OTMwOnYy", "diffSide": "RIGHT", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTozNzo1NVrOGRieWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1Njo1MFrOGSTHAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MzgwMw==", "bodyText": "Can be more succinctly expressed as if (!reuseTasksPerDg.isEmpty())", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421043803", "createdAt": "2020-05-06T19:37:55Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -93,6 +107,13 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n     return newAssignment;\n   }\n \n+  private DatastreamTask getOrCreateDatastreamTask(List<DatastreamTask> reuseTasksPerDg, DatastreamGroup dg) {\n+    if (reuseTasksPerDg.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDY0Mg==", "bodyText": "Done.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421840642", "createdAt": "2020-05-07T22:56:50Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -93,6 +107,13 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n     return newAssignment;\n   }\n \n+  private DatastreamTask getOrCreateDatastreamTask(List<DatastreamTask> reuseTasksPerDg, DatastreamGroup dg) {\n+    if (reuseTasksPerDg.size() > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MzgwMw=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTEwNzAyOnYy", "diffSide": "RIGHT", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTo0MzoyMlrOGRipzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNzoxNzo1MFrOGSIbWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NjczMg==", "bodyText": "nit: Names are slightly inconsistent; we get oldAssignmentTasks from assignment but newAssignmentTasks from newAssignment.\nHow about firstAssignment -> firstAssignmentTasks and secondAssignment -> secondAssignmentTasks?", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421046732", "createdAt": "2020-05-06T19:43:22Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI5MjgxMA==", "bodyText": "I kept the names inline with rest of the tests in the class for uniformity. Please let me know if you feel otherwise.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421292810", "createdAt": "2020-05-07T07:24:22Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NjczMg=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NTYyNw==", "bodyText": "Understood. No problem. Feel free to keep them as is.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421665627", "createdAt": "2020-05-07T17:17:50Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NjczMg=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTEwOTkxOnYy", "diffSide": "RIGHT", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTo0NDowOVrOGRirjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzo0NzoyMFrOGSUG0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NzE4MQ==", "bodyText": "Rename to something along the lines of: testReuseDeadInstanceTasks?", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421047181", "createdAt": "2020-05-06T19:44:09Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDQ5OA==", "bodyText": "kept the test name same as StickyMulticastStrategy.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421840498", "createdAt": "2020-05-07T22:56:26Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NzE4MQ=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1Njk3OQ==", "bodyText": "No problem", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421856979", "createdAt": "2020-05-07T23:47:20Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NzE4MQ=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTEyMzQxOnYy", "diffSide": "RIGHT", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTo0Nzo1MlrOGRizuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1Njo0MVrOGSTGww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0OTI3Mg==", "bodyText": "Should we make this assert stricter: assert they're actually the exact same set of tasks?\n\nAssert.assertEquals(oldAssignmentTasks, newAssignmentTasks);\n\nShould we also assert that no task was assigned to more than one instance?", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421049272", "createdAt": "2020-05-06T19:47:52Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    LOG.info(\"{}\", oldAssignmentTasks);\n+    LOG.info(\"{}\", newAssignmentTasks);\n+    Assert.assertTrue(oldAssignmentTasks.containsAll(newAssignmentTasks));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDU3OQ==", "bodyText": "Done.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421840579", "createdAt": "2020-05-07T22:56:41Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    LOG.info(\"{}\", oldAssignmentTasks);\n+    LOG.info(\"{}\", newAssignmentTasks);\n+    Assert.assertTrue(oldAssignmentTasks.containsAll(newAssignmentTasks));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0OTI3Mg=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 997, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}