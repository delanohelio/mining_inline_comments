{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1NDc1NzMz", "number": 775, "title": "Fix multiple issues found in the partition movement code", "bodyText": "This PR fixes multiple issues in the partition movement code:\n\nIf a task has no change in partitions, do not create a new task. Earlier all tasks were getting added to the tasks to mutate list,  even if it did not contain any partitions going away or getting added\nIf the target instance receives a partition which it already owns, this should be a no-op, and the partition should remain in it's original task.\nOnly add task dependencies for partitions getting added to that task rather than all partition being moved. E.g. earlier if p1 and p2 were to be moved, and p1 got added to task1, then p1's task and p2's task were both added as dependencies. Only p1's task should be added as a dependency to task1.\nWhen adding extra dependencies, ensure that these are locked too (like we do with the predecessor task)\n\nThis PR does not change the overall logic of this piece.\nImportant: DO NOT REPORT SECURITY ISSUES DIRECTLY ON GITHUB.\nFor reporting security issues and contributing security fixes,\nplease, email security@linkedin.com instead, as described in\nthe contribution guidelines.\nPlease, take a minute to review the contribution guidelines at:\nhttps://github.com/linkedin/Brooklin/blob/master/CONTRIBUTING.md", "createdAt": "2020-11-04T15:52:38Z", "url": "https://github.com/linkedin/brooklin/pull/775", "merged": true, "mergeCommit": {"oid": "4e9c6d739e8b98200e9e33c8373d299410036570"}, "closed": true, "closedAt": "2020-11-11T18:06:44Z", "author": {"login": "somandal"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZPrQfAH2gAyNTE1NDc1NzMzOmRmODIyNDBjOTc3ZWM2NjhhY2NjYjYyZWJiYmZjOGZjY2MyZDNjZmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbh6sZAFqTUyODQxMzc2NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "author": {"user": {"login": "somandal", "name": "Sonam Mandal"}}, "url": "https://github.com/linkedin/brooklin/commit/df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "committedDate": "2020-11-04T15:41:10Z", "message": "Fix multiple issues found in the partition movement code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTYzNjI1", "url": "https://github.com/linkedin/brooklin/pull/775#pullrequestreview-525563625", "createdAt": "2020-11-07T00:04:51Z", "commit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwMDowNDo1MVrOHvBEdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwMDowNDo1MVrOHvBEdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MjY0Nw==", "bodyText": "Nit: Avoid unnecessary changes to make reviews shorter.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r519062647", "createdAt": "2020-11-07T00:04:51Z", "author": {"login": "jzakaryan"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestStickyPartitionAssignment.java", "diffHunk": "@@ -182,14 +177,13 @@ public void testMovePartitionToInstanceWithoutTask() {\n         new DatastreamGroupPartitionsMetadata(datastreams.get(0), partitions);\n     // Generate partition assignment\n     assignment = strategy.assignPartitions(assignment, partitionsMetadata);\n-    assignment.put(\"empty\", new HashSet<DatastreamTask>());\n+    assignment.put(\"empty\", new HashSet<>());\n \n     Map<String, Set<String>> targetAssignment = new HashMap<>();\n     targetAssignment.put(\"empty\", ImmutableSet.of(\"t-3\", \"t-2\", \"t-1\", \"t-5\"));\n-    assignment = strategy.movePartitions(assignment, targetAssignment, partitionsMetadata);\n+    strategy.movePartitions(assignment, targetAssignment, partitionsMetadata);\n   }\n \n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTYzNzU0", "url": "https://github.com/linkedin/brooklin/pull/775#pullrequestreview-525563754", "createdAt": "2020-11-07T00:05:26Z", "commit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjgzNTQ3", "url": "https://github.com/linkedin/brooklin/pull/775#pullrequestreview-527683547", "createdAt": "2020-11-10T23:14:31Z", "commit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzoxNDozMVrOHwzTTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzo1NTo0NVrOHw0OlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDIyMg==", "bodyText": "nits: tasks to task", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520934222", "createdAt": "2020-11-10T23:14:31Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -151,11 +152,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Preprocess the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source task\n+   * Step 3) If the instance is the one we want to move, we choose a task to which we should assign the partition\n    *         from that instance\n-   * Step 3) Scan the current assignment, compute new task if the old task belongs to these source tasks or if it\n-   *         is the target task we want to move to\n+   * Step 4) Scan the current assignment, compute the new task if the old task belongs to this source tasks or if it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDQxOQ==", "bodyText": "nit: task to tasks, preprocess to pre-process", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520934419", "createdAt": "2020-11-10T23:15:01Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -151,11 +152,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Preprocess the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source task", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjYzMA==", "bodyText": "addAll with throw NullPointerException for the value set to null. The value is set to null for the instance where there is no movement.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520936630", "createdAt": "2020-11-10T23:20:33Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -170,17 +173,35 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n \n     DatastreamGroup dg = partitionsMetadata.getDatastreamGroup();\n \n+    // Pre-process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n+    // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on instance1\n+    // and is supposed to move to instance1, remove it from the targetAssignment as this should be a no-op.\n+    Map<String, Set<String>> preprocessedTargetAssignment = new HashMap<>();\n+    targetAssignment.forEach((instance, partitions) -> {\n+      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n+      Set<String> partitionsAcrossAllDatastreamTasks = tasks.stream().filter(dg::belongsTo)\n+          .map(DatastreamTask::getPartitionsV2).flatMap(Collection::stream).collect(Collectors.toSet());\n+\n+      Set<String> updatedTargetPartitionList = new HashSet<>(partitions);\n+      updatedTargetPartitionList.removeAll(partitionsAcrossAllDatastreamTasks);\n+\n+      preprocessedTargetAssignment.computeIfAbsent(instance,\n+          val -> updatedTargetPartitionList.isEmpty() ? null : updatedTargetPartitionList);\n+    });\n+\n+    LOG.info(\"The preprocessed targetAssignment: {}\", preprocessedTargetAssignment);\n+\n     Set<String> allToReassignPartitions = new HashSet<>();\n-    targetAssignment.values().forEach(allToReassignPartitions::addAll);\n+    preprocessedTargetAssignment.values().forEach(allToReassignPartitions::addAll);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNzQ2Mg==", "bodyText": "Can you merge these two lines?", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520937462", "createdAt": "2020-11-10T23:22:47Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -170,17 +173,35 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n \n     DatastreamGroup dg = partitionsMetadata.getDatastreamGroup();\n \n+    // Pre-process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n+    // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on instance1\n+    // and is supposed to move to instance1, remove it from the targetAssignment as this should be a no-op.\n+    Map<String, Set<String>> preprocessedTargetAssignment = new HashMap<>();\n+    targetAssignment.forEach((instance, partitions) -> {\n+      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n+      Set<String> partitionsAcrossAllDatastreamTasks = tasks.stream().filter(dg::belongsTo)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjQ2OA==", "bodyText": "I feel we can avoid splitting this in two steps. Please check and let me know your opinion.\n    // If the partitions cannot be found from any task, we ignore these partitions\n    currentAssignment.keySet().forEach(instance -> {\n      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n      Set<String> partitionsAcrossAllDatastreamTasks = currentAssignment.get(instance).stream().filter(dg::belongsTo)\n          .map(DatastreamTask::getPartitionsV2).flatMap(Collection::stream).collect(Collectors.toSet());\n      //Remove the partitions that do not need migration.\n      allToReassignPartitions.removeAll(partitionsAcrossAllDatastreamTasks);\n      tasks.forEach(task -> {\n        if (dg.belongsTo(task)) {\n          Set<String> toMovePartitions = new HashSet<>(task.getPartitionsV2());\n          toMovePartitions.retainAll(allToReassignPartitions);\n          if (!toMovePartitions.isEmpty()) {\n            // Only update the confirmedPartitionsTaskMap if a partition is indeed being deleted from it\n            confirmedPartitionsTaskMap.put(task.getDatastreamTaskName(), toMovePartitions);\n            toMovePartitions.forEach(p -> partitionToSourceTaskMap.put(p, (DatastreamTaskImpl) task));\n          }\n        }\n      });\n    });`", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520946468", "createdAt": "2020-11-10T23:47:16Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -190,15 +211,18 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n         if (dg.belongsTo(task)) {\n           Set<String> toMovePartitions = new HashSet<>(task.getPartitionsV2());\n           toMovePartitions.retainAll(allToReassignPartitions);\n-          confirmedPartitionsTaskMap.put(task.getDatastreamTaskName(), toMovePartitions);\n-          toMovePartitions.forEach(p -> partitionToSourceTaskMap.put(p, task.getDatastreamTaskName()));\n+          if (!toMovePartitions.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NzY0Nw==", "bodyText": "Sorry for my ignorance. I'm not able to find anything changing in the next few code diff blocks, except empty lines. Just want to be sure that I'm not missing anything.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520947647", "createdAt": "2020-11-10T23:50:42Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -228,37 +251,39 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n           .reduce((task1, task2) -> task1.getPartitionsV2().size() < task2.getPartitionsV2().size() ? task1 : task2)\n           .get() : null;\n \n-        // compute new assignment for that instance\n-        Set<DatastreamTask> newAssignedTask = tasks.stream().map(task -> {\n-          if (!dg.belongsTo(task)) {\n-            return task;\n-          }\n-          boolean partitionChanged = false;\n-          List<String> newPartitions = new ArrayList<>(task.getPartitionsV2());\n-          Set<String> extraDependencies = new HashSet<>();\n+      // compute new assignment for that instance\n+      Set<DatastreamTask> newAssignedTask = tasks.stream().map(task -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODAwNw==", "bodyText": "nit: mockZkAdapter2 to mockZkAdapter0", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520948007", "createdAt": "2020-11-10T23:51:47Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODc1MA==", "bodyText": "Nit: Not your fault, Do you think this test can be changed to validate the exception using AssertThrows to ensure that all the blocks including the new code is getting executed.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520948750", "createdAt": "2020-11-10T23:54:01Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODk1OA==", "bodyText": "same nit: mockZkAdapter2 to 0, here and other places.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520948958", "createdAt": "2020-11-10T23:54:34Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0OTIzMQ==", "bodyText": "Also, do you see a value of extracting the method for this new duplicate code block?", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520949231", "createdAt": "2020-11-10T23:55:17Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0OTM5Nw==", "bodyText": "Please transform this test to AssertThrows as well.", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520949397", "createdAt": "2020-11-10T23:55:45Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n+\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n     Assert.assertEquals(new HashSet<>(task2.getDependencies()), ImmutableSet.of(task.getDatastreamTaskName()));\n   }\n \n+  @Test(expectedExceptions = DatastreamTransientException.class)\n+  public void testTaskAddUnlockedDependency() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc"}, "originalPosition": 72}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9068c87e7d089bb222b291f9bbbbfd10498c256d", "author": {"user": {"login": "somandal", "name": "Sonam Mandal"}}, "url": "https://github.com/linkedin/brooklin/commit/9068c87e7d089bb222b291f9bbbbfd10498c256d", "committedDate": "2020-11-11T02:07:36Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68f164664325c943dc4272621354a9a7efd8eb1a", "author": {"user": {"login": "somandal", "name": "Sonam Mandal"}}, "url": "https://github.com/linkedin/brooklin/commit/68f164664325c943dc4272621354a9a7efd8eb1a", "committedDate": "2020-11-11T02:13:43Z", "message": "Merge branch 'master' into partition-movement-fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbe8b5645adef83ee7507bf75ef79220b4f00fb4", "author": {"user": {"login": "somandal", "name": "Sonam Mandal"}}, "url": "https://github.com/linkedin/brooklin/commit/dbe8b5645adef83ee7507bf75ef79220b4f00fb4", "committedDate": "2020-11-11T02:47:33Z", "message": "Merge targetAssignment processing step into the existing step where we compute tasks with partitions going away"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3ODYyNzI3", "url": "https://github.com/linkedin/brooklin/pull/775#pullrequestreview-527862727", "createdAt": "2020-11-11T04:58:00Z", "commit": {"oid": "dbe8b5645adef83ee7507bf75ef79220b4f00fb4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNDo1ODowMFrOHw-QWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNDo1ODowMFrOHw-QWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMzY5MQ==", "bodyText": "Also, can you please add the steps in the comments in the code, so it is clear which code block is which step?", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521113691", "createdAt": "2020-11-11T04:58:00Z", "author": {"login": "vmaheshw"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -154,11 +154,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Process the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source tasks\n+   * Step 3) If the instance is the one we want to move, we choose a task to which we should assign the partition", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbe8b5645adef83ee7507bf75ef79220b4f00fb4"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28caf6eed1e3df59e50f352bc8306ea86814e6fa", "author": {"user": {"login": "somandal", "name": "Sonam Mandal"}}, "url": "https://github.com/linkedin/brooklin/commit/28caf6eed1e3df59e50f352bc8306ea86814e6fa", "committedDate": "2020-11-11T05:29:11Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MzgyNDA1", "url": "https://github.com/linkedin/brooklin/pull/775#pullrequestreview-528382405", "createdAt": "2020-11-11T17:24:14Z", "commit": {"oid": "28caf6eed1e3df59e50f352bc8306ea86814e6fa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NDEzNzY1", "url": "https://github.com/linkedin/brooklin/pull/775#pullrequestreview-528413765", "createdAt": "2020-11-11T18:04:10Z", "commit": {"oid": "28caf6eed1e3df59e50f352bc8306ea86814e6fa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 327, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}