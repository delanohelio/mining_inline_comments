{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwOTY1NzUz", "number": 706, "title": "Reuse task from dead instances instead of creating new task in Broadcast strategy.", "bodyText": "The current code creates a new task instance if the task for the datastream group is not already existing in the previous assignment for the same instance. This results in creation of new tasks whenever the cluster is bounced, resulting in extra zk operation.\nWith this change, we will reuse the task from other dead instances.\nThe following equation is not sufficient:\nTotal Task instance that can be reused = sum of all tasks in dead instances.\nIf the leader was doing an assignment and reused the task from dead instance and updated the new assignment but got interrupted before deleted the dead instances, the next leader will try to reuse the tasks from the dead instance which is already assigned to another live instance by previous leader. This will result in duplicate error during update Assignment.\nTo avoid this:\nTotal Task instance that can be reused  = sum of all tasks in dead instances - tasks in live instances.\nThis will ensure that a task is not reused.\nNote: This does not mean that during rebouncing the cluster, there will be no new task created. Because if the cluster has N nodes, the next leader may only see M live instances where M<N and it may clean-up the dead instances before the rest of the nodes come back online. But, this is still an improvement from no task re-use.", "createdAt": "2020-04-29T21:34:29Z", "url": "https://github.com/linkedin/brooklin/pull/706", "merged": true, "mergeCommit": {"oid": "5a417bb02d48028f5b527fa2f891eba478c03487"}, "closed": true, "closedAt": "2020-05-08T00:02:49Z", "author": {"login": "vmaheshw"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABboAf5CAH2gAyNDEwOTY1NzUzOmMzMWNkNGExNWNjOGRkNjliMGE2NTNkYmU0MjAxZGU5MzRlYTZkNjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcfGLJ-gFqTQwNzkxMDU0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "author": {"user": {"login": "vmaheshw", "name": "Vaibhav Maheshwari"}}, "url": "https://github.com/linkedin/brooklin/commit/c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "committedDate": "2019-11-18T20:06:44Z", "message": "Merge pull request #1 from linkedin/master\n\nPull latest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5900c04825b275064c70964236604a5e28f395bd", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/5900c04825b275064c70964236604a5e28f395bd", "committedDate": "2020-04-29T17:00:30Z", "message": "Merge branch 'master' of github.com:linkedin/brooklin into HEAD"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/4f9089651ff0d2c8a567f383381c2f6b08b643b7", "committedDate": "2020-04-29T21:25:07Z", "message": "Reuse task from dead instances in BroadcastStrategy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDAzMDkw", "url": "https://github.com/linkedin/brooklin/pull/706#pullrequestreview-406003090", "createdAt": "2020-05-05T17:27:09Z", "commit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "state": "DISMISSED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzoyNzowOVrOGQz-Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzozNTo0NVrOGQ0Tew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4MTg5MQ==", "bodyText": "\"removing the reused tasks\"? Did you mean removing the tasks assigned to current live instances?\n\nto avoid assignment of same task from dead instance to two live instances in case of interrupt exception.\n\nSo that part of the comment is a bit confusing here. What got interrupted? This will only make sense to people who already know the details about the problem you are solving. Instead can you modify this to talk about interrupted cleanup of ZK nodes due to shutdown during leader assignment?", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r420281891", "createdAt": "2020-05-05T17:27:09Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -59,17 +60,27 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n \n     Map<String, Set<DatastreamTask>> newAssignment = new HashMap<>();\n \n+    Set<DatastreamTask> tasksAvailableToReuse = new HashSet<>();\n     // Make a copy of the current assignment, since the strategy modifies it during calculation\n     Map<String, Set<DatastreamTask>> currentAssignmentCopy = new HashMap<>(currentAssignment.size());\n-    currentAssignment.forEach((k, v) -> currentAssignmentCopy.put(k, new HashSet<>(v)));\n+    currentAssignment.forEach((k, v) -> {\n+      currentAssignmentCopy.put(k, new HashSet<>(v));\n+      // building the full list and then removing the reused tasks rather than building the list from dead tasks\n+      // to avoid assignment of same task from dead instance to two live instances in case of interrupt exception.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4NDI4NQ==", "bodyText": "You can modify this to be:\nreturn ((reuseTasksPerDg.size() > 0) ? reuseTasksPerDg.remove(0) : new DatastreamTaskImpl(dg.getDatastreams()));\nYou can also inline this where it is called if you'd like.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r420284285", "createdAt": "2020-05-05T17:30:42Z", "author": {"login": "somandal"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -93,6 +107,13 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n     return newAssignment;\n   }\n \n+  private DatastreamTask getOrCreateDatastreamTask(List<DatastreamTask> reuseTasksPerDg, DatastreamGroup dg) {\n+    if (reuseTasksPerDg.size() > 0) {\n+      return reuseTasksPerDg.remove(0);\n+    }\n+    return new DatastreamTaskImpl(dg.getDatastreams());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4NzM1NQ==", "bodyText": "Do you need these logs in the test?", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r420287355", "createdAt": "2020-05-05T17:35:45Z", "author": {"login": "somandal"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    LOG.info(\"{}\", oldAssignmentTasks);\n+    LOG.info(\"{}\", newAssignmentTasks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2OTEyMTk0", "url": "https://github.com/linkedin/brooklin/pull/706#pullrequestreview-406912194", "createdAt": "2020-05-06T19:14:30Z", "commit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "state": "DISMISSED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOToxNDozMVrOGRhrIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTo0Nzo1MlrOGRizuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMDY5MA==", "bodyText": "Not your fault: this isn't very efficient; new HashSet isn't needed if instance is not absent. This could be improved to:\n currentAssignmentCopy.computeIfAbsent(instance, i -> new HashSet<>());\nIf we do that, we could also improve line 76 by avoiding the extra get():\nSet<DatastreamTask> instanceTasks = currentAssignmentCopy.computeIfAbsent(instance, i -> new HashSet<>());\ntasksAvailableToReuse.removeAll(instanceTasks);", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421030690", "createdAt": "2020-05-06T19:14:31Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -59,17 +60,27 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n \n     Map<String, Set<DatastreamTask>> newAssignment = new HashMap<>();\n \n+    Set<DatastreamTask> tasksAvailableToReuse = new HashSet<>();\n     // Make a copy of the current assignment, since the strategy modifies it during calculation\n     Map<String, Set<DatastreamTask>> currentAssignmentCopy = new HashMap<>(currentAssignment.size());\n-    currentAssignment.forEach((k, v) -> currentAssignmentCopy.put(k, new HashSet<>(v)));\n+    currentAssignment.forEach((k, v) -> {\n+      currentAssignmentCopy.put(k, new HashSet<>(v));\n+      // building the full list and then removing the reused tasks rather than building the list from dead tasks\n+      // to avoid assignment of same task from dead instance to two live instances in case of interrupt exception.\n+      tasksAvailableToReuse.addAll(v);\n+    });\n \n     for (String instance : instances) {\n       newAssignment.put(instance, new HashSet<>());\n       currentAssignmentCopy.putIfAbsent(instance, new HashSet<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MTE5OA==", "bodyText": "Would it be better if we built a map of taskPrefix -> List<DatastreamTask> out of tasksAvailableToReuse before the loop on 80 instead of doing this?\nI think that'll be simpler, let alone it'll spare us having to filter tasksAvailableToReuse over and over for every dg.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421041198", "createdAt": "2020-05-06T19:33:09Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -59,17 +60,27 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n \n     Map<String, Set<DatastreamTask>> newAssignment = new HashMap<>();\n \n+    Set<DatastreamTask> tasksAvailableToReuse = new HashSet<>();\n     // Make a copy of the current assignment, since the strategy modifies it during calculation\n     Map<String, Set<DatastreamTask>> currentAssignmentCopy = new HashMap<>(currentAssignment.size());\n-    currentAssignment.forEach((k, v) -> currentAssignmentCopy.put(k, new HashSet<>(v)));\n+    currentAssignment.forEach((k, v) -> {\n+      currentAssignmentCopy.put(k, new HashSet<>(v));\n+      // building the full list and then removing the reused tasks rather than building the list from dead tasks\n+      // to avoid assignment of same task from dead instance to two live instances in case of interrupt exception.\n+      tasksAvailableToReuse.addAll(v);\n+    });\n \n     for (String instance : instances) {\n       newAssignment.put(instance, new HashSet<>());\n       currentAssignmentCopy.putIfAbsent(instance, new HashSet<>());\n+      tasksAvailableToReuse.removeAll(currentAssignmentCopy.get(instance));\n     }\n \n     int instancePos = 0;\n     for (DatastreamGroup dg : datastreams) {\n+      List<DatastreamTask> reuseTasksPerDg = tasksAvailableToReuse.stream().filter(x ->\n+          x.getTaskPrefix().equals(dg.getTaskPrefix())).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MjY2MA==", "bodyText": "You can make this part of the previous expression by replacing orElse(null) with:\n.orElseGet(() -> getOrCreateDatastreamTask(reuseTasksPerDg, dg));", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421042660", "createdAt": "2020-05-06T19:35:41Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -78,7 +89,10 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n             .stream()\n             .filter(x -> x.getTaskPrefix().equals(dg.getTaskPrefix()))\n             .findFirst()\n-            .orElse(new DatastreamTaskImpl(dg.getDatastreams()));\n+            .orElse(null);\n+        if (foundDatastreamTask == null) {\n+          foundDatastreamTask = getOrCreateDatastreamTask(reuseTasksPerDg, dg);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MzIyMA==", "bodyText": "Removing the last one is cheaper.", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421043220", "createdAt": "2020-05-06T19:36:46Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -93,6 +107,13 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n     return newAssignment;\n   }\n \n+  private DatastreamTask getOrCreateDatastreamTask(List<DatastreamTask> reuseTasksPerDg, DatastreamGroup dg) {\n+    if (reuseTasksPerDg.size() > 0) {\n+      return reuseTasksPerDg.remove(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0MzgwMw==", "bodyText": "Can be more succinctly expressed as if (!reuseTasksPerDg.isEmpty())", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421043803", "createdAt": "2020-05-06T19:37:55Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/BroadcastStrategy.java", "diffHunk": "@@ -93,6 +107,13 @@ public BroadcastStrategy(Optional<Integer> maxTasks) {\n     return newAssignment;\n   }\n \n+  private DatastreamTask getOrCreateDatastreamTask(List<DatastreamTask> reuseTasksPerDg, DatastreamGroup dg) {\n+    if (reuseTasksPerDg.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NjczMg==", "bodyText": "nit: Names are slightly inconsistent; we get oldAssignmentTasks from assignment but newAssignmentTasks from newAssignment.\nHow about firstAssignment -> firstAssignmentTasks and secondAssignment -> secondAssignmentTasks?", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421046732", "createdAt": "2020-05-06T19:43:22Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NzE4MQ==", "bodyText": "Rename to something along the lines of: testReuseDeadInstanceTasks?", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421047181", "createdAt": "2020-05-06T19:44:09Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NzQ5Mw==", "bodyText": "+1", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421047493", "createdAt": "2020-05-06T19:44:43Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    LOG.info(\"{}\", oldAssignmentTasks);\n+    LOG.info(\"{}\", newAssignmentTasks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4NzM1NQ=="}, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0OTI3Mg==", "bodyText": "Should we make this assert stricter: assert they're actually the exact same set of tasks?\n\nAssert.assertEquals(oldAssignmentTasks, newAssignmentTasks);\n\nShould we also assert that no task was assigned to more than one instance?", "url": "https://github.com/linkedin/brooklin/pull/706#discussion_r421049272", "createdAt": "2020-05-06T19:47:52Z", "author": {"login": "ahmedahamid"}, "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestBroadcastStrategy.java", "diffHunk": "@@ -279,4 +280,21 @@ public void testRebalanceTasksWhenNewInstanceIsAdded() {\n \n     Assert.assertEquals(newAssignment.get(instance4).size(), expectedNumTasksPerInstance);\n   }\n+\n+  @Test\n+  public void testDontCreateNewTasksWhenInstanceChanged() {\n+    String[] instances = new String[]{\"instance1\", \"instance2\", \"instance3\"};\n+    List<DatastreamGroup> datastreams = generateDatastreams(\"ds\", 5);\n+    BroadcastStrategy strategy = new BroadcastStrategy(Optional.empty());\n+    Map<String, Set<DatastreamTask>> assignment =\n+        strategy.assign(datastreams, Arrays.asList(instances), new HashMap<>());\n+    instances = new String[]{\"instance1\", \"instance2\", \"instance4\"};\n+\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assign(datastreams, Arrays.asList(instances), assignment);\n+    Set<DatastreamTask> oldAssignmentTasks = assignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    Set<DatastreamTask> newAssignmentTasks = newAssignment.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n+    LOG.info(\"{}\", oldAssignmentTasks);\n+    LOG.info(\"{}\", newAssignmentTasks);\n+    Assert.assertTrue(oldAssignmentTasks.containsAll(newAssignmentTasks));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f9089651ff0d2c8a567f383381c2f6b08b643b7"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07fd332db34ee601bea810e224c876f86e45b893", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/07fd332db34ee601bea810e224c876f86e45b893", "committedDate": "2020-05-07T18:01:16Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3ODkzNTU5", "url": "https://github.com/linkedin/brooklin/pull/706#pullrequestreview-407893559", "createdAt": "2020-05-07T23:01:18Z", "commit": {"oid": "07fd332db34ee601bea810e224c876f86e45b893"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2198c2dc2991cc6936a5c4cd992a3c334348e684", "author": {"user": null}, "url": "https://github.com/linkedin/brooklin/commit/2198c2dc2991cc6936a5c4cd992a3c334348e684", "committedDate": "2020-05-07T23:43:18Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTA5NjAy", "url": "https://github.com/linkedin/brooklin/pull/706#pullrequestreview-407909602", "createdAt": "2020-05-07T23:46:25Z", "commit": {"oid": "2198c2dc2991cc6936a5c4cd992a3c334348e684"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTEwNTQ2", "url": "https://github.com/linkedin/brooklin/pull/706#pullrequestreview-407910546", "createdAt": "2020-05-07T23:49:21Z", "commit": {"oid": "2198c2dc2991cc6936a5c4cd992a3c334348e684"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4998, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}