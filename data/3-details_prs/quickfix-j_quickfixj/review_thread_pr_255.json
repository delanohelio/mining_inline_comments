{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMDE5MTQz", "number": 255, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToxMjozMVrOD25kMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNTo0Njo1MFrOD8IIhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODkyODUwOnYy", "diffSide": "RIGHT", "path": "quickfixj-core/src/main/java/quickfix/mina/initiator/AbstractSocketInitiator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToxMjozMVrOGM37cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToxMjozMVrOGM37cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1MjQzNQ==", "bodyText": "Setting maximumPoolSize to initialPoolSize ensures that numReconnectThreads threads are available to service tasks. Otherwise new threads only get created when the task queue is full.", "url": "https://github.com/quickfix-j/quickfixj/pull/255#discussion_r416152435", "createdAt": "2020-04-27T21:12:31Z", "author": {"login": "chrjohn"}, "path": "quickfixj-core/src/main/java/quickfix/mina/initiator/AbstractSocketInitiator.java", "diffHunk": "@@ -69,9 +76,27 @@ protected AbstractSocketInitiator(Application application,\n \n     protected AbstractSocketInitiator(SessionSettings settings, SessionFactory sessionFactory)\n             throws ConfigError {\n+        this(settings, sessionFactory, 0);\n+    }\n+\n+    protected AbstractSocketInitiator(Application application,\n+            MessageStoreFactory messageStoreFactory, SessionSettings settings,\n+            LogFactory logFactory, MessageFactory messageFactory, int numReconnectThreads) throws ConfigError {\n+        this(settings, new DefaultSessionFactory(application, messageStoreFactory, logFactory,\n+                messageFactory), numReconnectThreads);\n+    }\n+\n+    protected AbstractSocketInitiator(SessionSettings settings, SessionFactory sessionFactory, int numReconnectThreads)\n+            throws ConfigError {\n         super(settings, sessionFactory);\n         IoBuffer.setAllocator(new SimpleBufferAllocator());\n         IoBuffer.setUseDirectBuffer(false);\n+        if (numReconnectThreads > 0) {\n+            scheduledReconnectExecutor = Executors.newScheduledThreadPool(numReconnectThreads, new QFScheduledReconnectThreadFactory());\n+            ((ThreadPoolExecutor) scheduledReconnectExecutor).setMaximumPoolSize(numReconnectThreads);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e1e5348607661464fd7b2a33ae5723a115b4e1d"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Mzc0NDA1OnYy", "diffSide": "RIGHT", "path": "quickfixj-core/src/main/java/quickfix/mina/SessionConnector.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNTo0Njo1MFrOGU4ClA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMzo0Mzo1NFrOGgex4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0Mjg2OA==", "bodyText": "Not directly related to this change, but we probably don't want to queue up timer tasks if they take too long for some reason.\n\n  \n    \n      quickfixj/quickfixj-core/src/main/java/quickfix/mina/initiator/IoSessionInitiator.java\n    \n    \n         Line 364\n      in\n      e53d41b\n    \n    \n    \n    \n\n        \n          \n           .scheduleWithFixedDelay(reconnectTask, 0, 1, TimeUnit.SECONDS);", "url": "https://github.com/quickfix-j/quickfixj/pull/255#discussion_r424542868", "createdAt": "2020-05-13T15:46:50Z", "author": {"login": "the-thing"}, "path": "quickfixj-core/src/main/java/quickfix/mina/SessionConnector.java", "diffHunk": "@@ -318,7 +318,7 @@ protected void startSessionTimer() {\n         if (shortLivedExecutor != null) {\n             timerTask = new DelegatingTask(timerTask, shortLivedExecutor);\n         }\n-        sessionTimerFuture = scheduledExecutorService.scheduleAtFixedRate(timerTask, 0, 1000L,\n+        sessionTimerFuture = SCHEDULED_EXECUTOR.scheduleAtFixedRate(timerTask, 0, 1000L,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e1e5348607661464fd7b2a33ae5723a115b4e1d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY1MzY0MQ==", "bodyText": "The reconnectTasks timed out after a maximum of 2000ms. That was the reason to have a bigger pool to service these requests, see #254 .\nWhat do you suggest to prevent piling up these tasks?", "url": "https://github.com/quickfix-j/quickfixj/pull/255#discussion_r436653641", "createdAt": "2020-06-08T12:24:58Z", "author": {"login": "chrjohn"}, "path": "quickfixj-core/src/main/java/quickfix/mina/SessionConnector.java", "diffHunk": "@@ -318,7 +318,7 @@ protected void startSessionTimer() {\n         if (shortLivedExecutor != null) {\n             timerTask = new DelegatingTask(timerTask, shortLivedExecutor);\n         }\n-        sessionTimerFuture = scheduledExecutorService.scheduleAtFixedRate(timerTask, 0, 1000L,\n+        sessionTimerFuture = SCHEDULED_EXECUTOR.scheduleAtFixedRate(timerTask, 0, 1000L,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0Mjg2OA=="}, "originalCommit": {"oid": "7e1e5348607661464fd7b2a33ae5723a115b4e1d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcxMTkwNA==", "bodyText": "Similar to IoSessionInitiator. As a rule of thumb scheduleWithFixedDelay is better in majority of cases than scheduleAtFixedRate. It respects the delay, but it only reschedules when the tasks finishes - this does not allow bursts if for some reason task is slow.", "url": "https://github.com/quickfix-j/quickfixj/pull/255#discussion_r436711904", "createdAt": "2020-06-08T13:43:54Z", "author": {"login": "the-thing"}, "path": "quickfixj-core/src/main/java/quickfix/mina/SessionConnector.java", "diffHunk": "@@ -318,7 +318,7 @@ protected void startSessionTimer() {\n         if (shortLivedExecutor != null) {\n             timerTask = new DelegatingTask(timerTask, shortLivedExecutor);\n         }\n-        sessionTimerFuture = scheduledExecutorService.scheduleAtFixedRate(timerTask, 0, 1000L,\n+        sessionTimerFuture = SCHEDULED_EXECUTOR.scheduleAtFixedRate(timerTask, 0, 1000L,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0Mjg2OA=="}, "originalCommit": {"oid": "7e1e5348607661464fd7b2a33ae5723a115b4e1d"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2096, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}