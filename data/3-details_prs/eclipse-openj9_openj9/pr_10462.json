{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0MDU0Mjcz", "number": 10462, "title": "Implement initial JIT support for Valhalla flattened value type fields", "bodyText": "These commits introduce JIT support for flattened value type fields by generating calls to the appropriate runtime helpers (see  #9627). The approach used to implement this support can be logically separated into a few general tasks as follows:\n\nEnabling Valhalla tests to run with both the JIT and flattened fields enabled\nFixing pre-existing issues in the JIT exposed by enabling flattened field support (I have run extra regression tests that don't exercise value types specifically to ensure these fixes are adequately tested)\nAdding some infrastructural components needed to properly support flattened fields\nImplementing flattened field support by calling the runtime helpers for the getfield, withfield, and putfield operations", "createdAt": "2020-08-26T17:35:16Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10462", "merged": true, "mergeCommit": {"oid": "dd8db7c20222095fa9b274b1e583667aa6c962bd"}, "closed": true, "closedAt": "2020-09-16T14:14:15Z", "author": {"login": "Leonardo2718"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCutn6gH2gAyNDc0MDU0MjczOjdkYTE3MGZjNzg1NjZjN2NiNmUyNDJjMmVlOWI0MDI0NzJiZDlhNmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJdDsTAFqTQ4OTY3MDI0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7da170fc78566c7cb6e242c2ee9b402472bd9a6d", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7da170fc78566c7cb6e242c2ee9b402472bd9a6d", "committedDate": "2020-08-26T16:50:33Z", "message": "Add JIT flattened field testing\n\nAdd test config command to run Valhalla tests with field flattening and\nthe JIT enabled.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fff8f6a590307d803c1c2d3f5e40affd119ea649", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/fff8f6a590307d803c1c2d3f5e40affd119ea649", "committedDate": "2020-08-26T16:50:33Z", "message": "Correctly query if symref is resolved method in StringPeepholes\n\nPreviously, StringPeepholes assumed that if the symref on an acall is\n*not* unresolved, then the symbol must be a resolved method. This is\nincorrect since the symbol could be a helper, or non-helper, etc.\n\nThis commit corrects the check by querying isResolvedMethod() instead of\n!isUnresolved().\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3f5cf8030076952c96080b73a6d43b950d5950f", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c3f5cf8030076952c96080b73a6d43b950d5950f", "committedDate": "2020-08-26T17:01:20Z", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "1f8470e6f85d170f6181381d5b19834a382a1511", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/1f8470e6f85d170f6181381d5b19834a382a1511", "committedDate": "2020-08-26T17:38:39Z", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2OTUyOTM5", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#pullrequestreview-476952939", "createdAt": "2020-08-27T17:53:04Z", "commit": {"oid": "7da170fc78566c7cb6e242c2ee9b402472bd9a6d"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNzo1MzowNFrOHIbIng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxODozMTo0OFrOHIcasQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU5NTIzMA==", "bodyText": "-Xgcpolicy:optthruput -Xnocompactgc is used in -Xint when both  -XX:ValueTypeFlatteningThreshold=99999 and -XX:+EnableArrayFlattening are enabled.  To be consistent as -Xint test variations, is this variation added here for future when we add -XX:+EnableArrayFlattening to -Xjit test?", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478595230", "createdAt": "2020-08-27T17:53:04Z", "author": {"login": "a7ehuo"}, "path": "test/functional/Valhalla/playlist.xml", "diffHunk": "@@ -62,6 +62,8 @@\n \t\t\t  -\t<variation>-Xjit:count=0</variation>\n \t\t\t  -->\n \t\t\t<variation>-Xjit:count=1,disableAsyncCompilation</variation>\n+\t\t\t<variation>-Xjit:count=1,disableAsyncCompilation -Xgcpolicy:nogc -XX:ValueTypeFlatteningThreshold=99999</variation>\n+\t\t\t<variation>-Xjit:count=1,disableAsyncCompilation -Xgcpolicy:optthruput -Xnocompactgc -XX:ValueTypeFlatteningThreshold=99999</variation>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7da170fc78566c7cb6e242c2ee9b402472bd9a6d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYwMjI4MQ==", "bodyText": "Would it make the API cleaner by combining these helpers into one API such as findOrCreateFlattenableSymbolRef(owningMethodSymbol, opCode, isStatic, isArrayElment) and have an enum to switch on the different optCode and type?", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478602281", "createdAt": "2020-08-27T18:05:47Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/compile/J9SymbolReferenceTable.hpp", "diffHunk": "@@ -110,7 +110,17 @@ class SymbolReferenceTable : public OMR::SymbolReferenceTableConnector\n    TR::SymbolReference * findOrCreateWriteBarrierClassStoreRealTimeGCSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = 0);\n    TR::SymbolReference * findOrCreateWriteBarrierBatchStoreSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = 0);\n \n-   TR::SymbolReference * findOrCreateAcmpHelperSymbolRef(TR::ResolvedMethodSymbol * owningMEthodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateAcmpHelperSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+\n+   // these helpers are guarenteed to never throw if the receiving object is not null,\n+   // so we explicit generate NULLCHKs and assume the helpers will never throw\n+   TR::SymbolReference * findOrCreateGetFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateWithFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreatePutFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateGetFlattenableStaticFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreatePutFlattenableStaticFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateLoadFlattenableArrayElementSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateStoreFlattenableArrayElementSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a5f95c1fcffff186871f77a133cce7ddfdf1609"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxMTA1NA==", "bodyText": "Should isStore is passed in as true for isFieldResolved here?", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478611054", "createdAt": "2020-08-27T18:22:02Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6735,6 +6735,20 @@ TR_J9ByteCodeIlGenerator::storeInstance(int32_t cpIndex)\n    if (_generateWriteBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n \n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+   if (TR::Compiler->om.areValueTypesEnabled() && owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (!isFieldResolved(comp(), owningMethod, cpIndex, false))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f8470e6f85d170f6181381d5b19834a382a1511"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxNDE2NA==", "bodyText": "I wonder if genFlattenableWithFieldWithHelper should be moved before the stack manipulation at line 6222. genFlattenableWithFieldWithHelper will take care of pop and push and genNullCheck instead of piggy back on genWithField here. It'd be easier down the road to debug the code when the stack manipulation inside one function. Actually loadFlattenableInstanceWithHelper and storeFlattenableInstanceWithHelper already do so.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478614164", "createdAt": "2020-08-27T18:27:56Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6231,6 +6231,13 @@ TR_J9ByteCodeIlGenerator::genWithField(uint16_t fieldCpIndex)\n    TR::Node *passThruNode = TR::Node::create(TR::PassThrough, 1, originalObject);\n    genTreeTop(genNullCheck(passThruNode));\n \n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+   if (owningMethod->isFieldQType(fieldCpIndex) && owningMethod->isFieldFlattened(comp(), fieldCpIndex, _methodSymbol->isStatic()))\n+      {\n+      genFlattenableWithFieldWithHelper(fieldCpIndex, newFieldValue, originalObject);\n+      return;\n+      }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c05be6691f9b107a095ac7791d695a8ffb1536"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxNjI0MQ==", "bodyText": "Why isn't  push(helperCallNode) needed here?", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478616241", "createdAt": "2020-08-27T18:31:48Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6868,6 +6882,25 @@ TR_J9ByteCodeIlGenerator::storeInstance(int32_t cpIndex)\n       }\n    }\n \n+void\n+TR_J9ByteCodeIlGenerator::storeFlattenableInstanceWithHelper(int32_t cpIndex)\n+   {\n+   TR::Node * value = pop();\n+   TR::Node * address = pop();\n+   if (!address->isNonNull())\n+      {\n+      auto* nullchk = TR::Node::create(TR::PassThrough, 1, address);\n+      nullchk = genNullCheck(nullchk);\n+      genTreeTop(nullchk);\n+      }\n+   auto* j9ResolvedMethod = static_cast<TR_ResolvedJ9Method *>(_methodSymbol->getResolvedMethod());\n+   auto* ramFieldRef = reinterpret_cast<J9RAMFieldRef*>(j9ResolvedMethod->cp()) + cpIndex;\n+   auto* ramFieldRefNode = TR::Node::aconst(reinterpret_cast<uintptr_t>(ramFieldRef));\n+   auto* helperCallNode = TR::Node::createWithSymRef(TR::acall, 3, 3, value, address, ramFieldRefNode, comp()->getSymRefTab()->findOrCreatePutFlattenableFieldSymbolRef());\n+   handleSideEffect(helperCallNode);\n+   genTreeTop(helperCallNode);\n+   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f8470e6f85d170f6181381d5b19834a382a1511"}, "originalPosition": 42}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f8470e6f85d170f6181381d5b19834a382a1511", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/1f8470e6f85d170f6181381d5b19834a382a1511", "committedDate": "2020-08-26T17:38:39Z", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd", "committedDate": "2020-08-31T14:10:34Z", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTI3MTgx", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#pullrequestreview-480127181", "createdAt": "2020-09-01T21:24:52Z", "commit": {"oid": "121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMToyNDo1MlrOHLIzAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMToyNDo1MlrOHLIzAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MDUxNA==", "bodyText": "Is there a macro or other helper to do this test and the shifting? Just wanting to avoid magic values if possible...", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r481440514", "createdAt": "2020-09-01T21:24:52Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -166,127 +128,81 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n          TR_ASSERT_FATAL(supClass, \"Found NULL supClass in inheritance chain\");\n          }\n \n-      romCl = supClass->romClass;\n-\n-      // iterate through the fields creating TR_VMField and inserting them into a List\n-\n-      currentField = romFieldsStartDo(romCl, &state);\n-      while (currentField)\n-         {\n-         if ((currentField->modifiers & J9AccStatic) == 0)\n-            {\n-            totalNumFields++;\n-            _numRefSlotsInObject += buildField(supClass, currentField);\n-            }\n-         else\n-            {\n-            buildField(supClass, currentField);\n-            }\n-         currentField = romFieldsNextDo(&state);\n-         }\n+      collectFieldInfo(supClass);\n       }\n \n    // copy the GCData\n-   numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n-   numRefs = 0;\n-   descriptorPtr = aClazz->instanceDescription;\n-\n-   // null terminated\n-   _gcDescriptor = (int32_t *) _comp->trMemory()->allocateMemory((_numRefSlotsInObject+1)*sizeof(int32_t), allocKind);\n-   _gcDescriptor[_numRefSlotsInObject] = 0;\n+   UDATA *descriptorPtr = aClazz->instanceDescription;\n+   UDATA descriptorWord=0;\n \n-   slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n-   countSlots = slotsInHeader;\n-   bitIndex = 0;\n+   int32_t bitIndex = 0;\n    if ( ((UDATA) descriptorPtr) & BCT_J9DescriptionImmediate )\n       {\n       bitIndex++;\n       descriptorWord = ((UDATA) descriptorPtr) >> 1;\n       }\n    else\n-     {\n-     descriptorWord = descriptorPtr[0];\n-     }\n+      {\n+      descriptorWord = descriptorPtr[0];\n+      }\n \n+   const int32_t numBytesInSlot = TR::Compiler->om.sizeofReferenceField();\n+   const int32_t numBitsInWord = 8*sizeof(decltype(*(aClazz->instanceDescription)));\n+   const int32_t numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n+   const uintptr_t slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n+   uintptr_t countSlots = slotsInHeader;\n    while (1)\n       {\n-       if ( descriptorWord & 0x1 )\n-          {\n-           _gcDescriptor[numRefs++] = countSlots;\n-          }\n-       countSlots++;\n-       if (countSlots >= (slotsInHeader + numSlotsInObject))\n-          {\n-             break;\n-          }\n-       if (bitIndex == (numBitsInWord - 1))\n-          {\n-          descriptorPtr++;\n-          bitIndex = 0;\n-          descriptorWord = *descriptorPtr;\n-          }\n-       else\n-          {\n-          descriptorWord = descriptorWord >> 1;\n-          bitIndex++;\n-          }\n+      if ( descriptorWord & 0x1 )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd"}, "originalPosition": 177}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMDkxNTk3", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#pullrequestreview-480091597", "createdAt": "2020-09-01T20:29:12Z", "commit": {"oid": "fae2c6b4d97fe082ef5994a6f31741e5a51db001"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyOToxMlrOHLHENg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDozMzo1NVrOHLHNYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMjE1MA==", "bodyText": "This is a real nit, and I know the loop was already coded this way, but if the value of the index variable i is never used in this loop, is there any reason for having this loop count down to zero rather than writing?\nfor (int32_t i = 0; i < numSupClasses; i++)", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r481412150", "createdAt": "2020-09-01T20:29:12Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -121,38 +103,18 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n             _statics = new (_comp->trMemory(), allocKind) TR_ScratchList<TR_VMField> (_comp->trMemory());\n             break;\n          default:\n-         \tbreak;\n+            TR_ASSERT_FATAL(false, \"Unknown allocation kind %d\", allocKind);\n          }\n-\t  }\n-   else\n-\t  {\n-      _fields = NULL;\n-      _statics = NULL;\n-\t  }\n-   _numRefSlotsInObject = 0;\n+      }\n \n    // self\n-   romCl = aClazz->romClass;\n-   TR_ASSERT(!(romCl->modifiers & J9AccClassArray), \"Cannot construct TR_VMFieldsInfo for array class %p\", aClazz);\n-   currentField = romFieldsStartDo(romCl, &state);\n-   while (currentField)\n-      {\n-      if ((currentField->modifiers & J9AccStatic) == 0)\n-         {\n-         totalNumFields++;\n-         _numRefSlotsInObject += buildField(aClazz, currentField);\n-         }\n-\t  else\n-\t\t {\n-         buildField(aClazz, currentField);\n-\t\t }\n-      currentField = romFieldsNextDo(&state);\n-      }\n+   TR_ASSERT(!(aClazz->romClass->modifiers & J9AccClassArray), \"Cannot construct TR_VMFieldsInfo for array class %p\", aClazz);\n+   collectFieldInfo(aClazz);\n \n    //supers\n-   int numSupClasses = J9CLASS_DEPTH(aClazz);\n+   const int32_t numSupClasses = J9CLASS_DEPTH(aClazz);\n    J9Class *supClass = aClazz;\n-   for (i=numSupClasses-1; i>=0; i--)\n+   for (int32_t i = numSupClasses-1; i>=0; i--)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae2c6b4d97fe082ef5994a6f31741e5a51db001"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDQ5Nw==", "bodyText": "Another nit - as long as you're correcting the indentation, I think this break is still indented too far.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r481414497", "createdAt": "2020-09-01T20:33:55Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -166,127 +128,81 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n          TR_ASSERT_FATAL(supClass, \"Found NULL supClass in inheritance chain\");\n          }\n \n-      romCl = supClass->romClass;\n-\n-      // iterate through the fields creating TR_VMField and inserting them into a List\n-\n-      currentField = romFieldsStartDo(romCl, &state);\n-      while (currentField)\n-         {\n-         if ((currentField->modifiers & J9AccStatic) == 0)\n-            {\n-            totalNumFields++;\n-            _numRefSlotsInObject += buildField(supClass, currentField);\n-            }\n-         else\n-            {\n-            buildField(supClass, currentField);\n-            }\n-         currentField = romFieldsNextDo(&state);\n-         }\n+      collectFieldInfo(supClass);\n       }\n \n    // copy the GCData\n-   numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n-   numRefs = 0;\n-   descriptorPtr = aClazz->instanceDescription;\n-\n-   // null terminated\n-   _gcDescriptor = (int32_t *) _comp->trMemory()->allocateMemory((_numRefSlotsInObject+1)*sizeof(int32_t), allocKind);\n-   _gcDescriptor[_numRefSlotsInObject] = 0;\n+   UDATA *descriptorPtr = aClazz->instanceDescription;\n+   UDATA descriptorWord=0;\n \n-   slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n-   countSlots = slotsInHeader;\n-   bitIndex = 0;\n+   int32_t bitIndex = 0;\n    if ( ((UDATA) descriptorPtr) & BCT_J9DescriptionImmediate )\n       {\n       bitIndex++;\n       descriptorWord = ((UDATA) descriptorPtr) >> 1;\n       }\n    else\n-     {\n-     descriptorWord = descriptorPtr[0];\n-     }\n+      {\n+      descriptorWord = descriptorPtr[0];\n+      }\n \n+   const int32_t numBytesInSlot = TR::Compiler->om.sizeofReferenceField();\n+   const int32_t numBitsInWord = 8*sizeof(decltype(*(aClazz->instanceDescription)));\n+   const int32_t numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n+   const uintptr_t slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n+   uintptr_t countSlots = slotsInHeader;\n    while (1)\n       {\n-       if ( descriptorWord & 0x1 )\n-          {\n-           _gcDescriptor[numRefs++] = countSlots;\n-          }\n-       countSlots++;\n-       if (countSlots >= (slotsInHeader + numSlotsInObject))\n-          {\n-             break;\n-          }\n-       if (bitIndex == (numBitsInWord - 1))\n-          {\n-          descriptorPtr++;\n-          bitIndex = 0;\n-          descriptorWord = *descriptorPtr;\n-          }\n-       else\n-          {\n-          descriptorWord = descriptorWord >> 1;\n-          bitIndex++;\n-          }\n+      if ( descriptorWord & 0x1 )\n+         {\n+         _gcDescriptor.push_back(countSlots);\n+         }\n+      countSlots++;\n+      if (countSlots >= (slotsInHeader + numSlotsInObject))\n+         {\n+            break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae2c6b4d97fe082ef5994a6f31741e5a51db001"}, "originalPosition": 184}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9694a83d94c0d8c04aa192ce6a191c09af02c73", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a9694a83d94c0d8c04aa192ce6a191c09af02c73", "committedDate": "2020-09-02T15:00:54Z", "message": "Fix TR_VMFieldsInfo constructor\n\nPreviously, the TR_VMFieldInfo constructors assumed that the number of\nfields in an object instance must equal the number of slots in the\ninstance. Value type flattening breaks that assumption, so this\ncommit refactors the code to correctly handle flattened fields.\n\nThe original code traversed all the fields in an object instance and\nrecorded the number of object references visited. This number was then\nused to calculate the size of the dynamically allocated `_gcDescriptor`\narray, which was then populated with the offset of each ref slot.\nUnfortunately, when enabling value type flattening, the number of ref\nslots can end up being larger than the number of ref fields in the object,\nresulting writes past the end of the array (which happens to corrupt the\nstack because it just happens to get allocated in a stack region).\n\nAs a fix, this commit changes `_gcDescriptor` to be a std::vector that\nis populated by calling `push_back()` for every ref slot in an instance.\nAs a result, pre-calculating the number of ref-slots is no longer needed\nand the allocated space is guaranteed to be large enough. As a bonus,\nthe code can be significantly simplified by removing some of the\nbookkeeping previously used to calculate the number of ref slots.\n\nIn order to make the code easier to understand for myself while fixing\nthe above issue and for future developers, I have also done the\nfollowing refactors:\n\n- Added member initialization list to ensure all members always get\n  initialized with some default value (previously, there was a path were\n  `_statics` and `_fields` could be uninitialized)\n- Moved variable declarations to where the variables are actually used\n  (there's no reason to pretend a constructor has to compile with C89)\n- Removed unused/unneeded variables and fields:\n  - _ramClass\n  - _numRefSlotsInObject\n  - totalNumFields\n  - numSlotsInObject\n- Changed return type of `buildField()` to void\n  - we no longer need to know if the field that was added is a ref\n- Moved field collection to it's own function\n  - simplified collection of fields by removing need to care about\n    static vs non-static fields\n  - we no longer need to know which fields occupy slots in an instance\n- Made some variables `const` to make sure they are never assigned\n- Removed unused methods:\n  - `print()` (only used in commented out code)\n  - `getNumRefSlotsInObject()`\n- Fixed incorrect indenting\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "348866a842a6467e4f0d8cc60e9d0372072218e9", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/348866a842a6467e4f0d8cc60e9d0372072218e9", "committedDate": "2020-09-02T15:00:59Z", "message": "Add findOrCreate methods for flattened value type helper symbols\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd", "committedDate": "2020-08-31T14:10:34Z", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f6f521ed788389d01ba6f7836c0569ea970844f2", "committedDate": "2020-09-02T15:00:59Z", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwOTUyMjgz", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#pullrequestreview-480952283", "createdAt": "2020-09-02T15:39:35Z", "commit": {"oid": "121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTo0MDo0NFrOHL1bAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTo0MDo0NFrOHL1bAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA==", "bodyText": "Why do we do runtime resolve when we can safely compile-time resolve it? Other fields only need resolve check when we can't compile-time resolve them. Are ValueType fields different?", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482171648", "createdAt": "2020-09-02T15:40:44Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,11 +5061,48 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+/**\n+ * @brief Returns whether a field ref in the constant pool resolved\n+ *\n+ * Importantly, when this function returns false, a ResolveCHK is guarenteed to be needed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "867966b76548849a32c35a1e3d275630e5e2d51b", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/867966b76548849a32c35a1e3d275630e5e2d51b", "committedDate": "2020-09-09T14:18:01Z", "message": "Add helper to check if field cpRef is resolved\n\nThis helper will be used during IL generation to handle flattened value\ntype fields.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f18bbddadb68ae27a6e69e6fd7b32b204588b51c", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f18bbddadb68ae27a6e69e6fd7b32b204588b51c", "committedDate": "2020-09-09T14:18:06Z", "message": "Implement flattened loadInstance support\n\nSupport is implemented by generating a call to the getFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87d281cfb617e5fca58f4dbe1035f54ad888e6fd", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/87d281cfb617e5fca58f4dbe1035f54ad888e6fd", "committedDate": "2020-09-09T14:18:06Z", "message": "Implement flattened withfield support\n\nSupport is implemented by generating a call to the withFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4f609fe37f91189aba08575b4a1fcd4d07e6ac9", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f4f609fe37f91189aba08575b4a1fcd4d07e6ac9", "committedDate": "2020-09-09T14:18:06Z", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f6f521ed788389d01ba6f7836c0569ea970844f2", "committedDate": "2020-09-02T15:00:59Z", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "f4f609fe37f91189aba08575b4a1fcd4d07e6ac9", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f4f609fe37f91189aba08575b4a1fcd4d07e6ac9", "committedDate": "2020-09-09T14:18:06Z", "message": "Implement flattened storeInstance support\n\nSupport is implemented by generating a call to the putFlattenableField\nruntime helper.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NjcwMjQ2", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#pullrequestreview-489670246", "createdAt": "2020-09-16T14:13:50Z", "commit": {"oid": "f4f609fe37f91189aba08575b4a1fcd4d07e6ac9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 229, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}