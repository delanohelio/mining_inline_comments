{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwMTM2NDQ5", "number": 10850, "title": "Improve performance of persistent memory allocator", "bodyText": "The persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\nSigned-off-by: Marius Pirvu mpirvu@ca.ibm.com", "createdAt": "2020-10-08T19:24:26Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10850", "merged": true, "mergeCommit": {"oid": "e9d73ae0f63d036ab839dfdd204b45320bf24ee0"}, "closed": true, "closedAt": "2020-10-19T14:57:30Z", "author": {"login": "mpirvu"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSlzEAABqjM4Nzg5MTQwNzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdTKzhDgFqTUxMDcxNDgzMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d4b96445eeb497882797e0c20bc31ca47d62185", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3d4b96445eeb497882797e0c20bc31ca47d62185", "committedDate": "2020-10-08T19:22:33Z", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}, "afterCommit": {"oid": "9587c68a2c87549a732acdb0097d112070a177cc", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9587c68a2c87549a732acdb0097d112070a177cc", "committedDate": "2020-10-14T23:14:45Z", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9587c68a2c87549a732acdb0097d112070a177cc", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9587c68a2c87549a732acdb0097d112070a177cc", "committedDate": "2020-10-14T23:14:45Z", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}, "afterCommit": {"oid": "12f44e4f256ddd2371aea4cde37145b47a660403", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/12f44e4f256ddd2371aea4cde37145b47a660403", "committedDate": "2020-10-15T00:45:42Z", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "12f44e4f256ddd2371aea4cde37145b47a660403", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/12f44e4f256ddd2371aea4cde37145b47a660403", "committedDate": "2020-10-15T00:45:42Z", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}, "afterCommit": {"oid": "599c742bc1c529cd9bc4fd21ab89553e35d079b4", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/599c742bc1c529cd9bc4fd21ab89553e35d079b4", "committedDate": "2020-10-15T18:01:25Z", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzkxMzk4", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#pullrequestreview-509791398", "createdAt": "2020-10-15T20:40:19Z", "commit": {"oid": "599c742bc1c529cd9bc4fd21ab89553e35d079b4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0MDoxOVrOHiZWFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMjoxMDoyN1rOHidQrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODg4Nw==", "bodyText": "Why do we need shift one more than BITS_TO_SHIFT_FIRST_INTERVAL? Right now, since a \"large block\" is any allocation greater than 2^7 bytes, doesn't this means that the interval 0 will contain blocks ranging from [2^7, 2^9), whereas for any other interval m, the range would be [2^m, 2^m+1)? It looks like from the code above:\nif (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n\nthe last interval is given to anything >= than 2^14. However, if the bits were only shifted BITS_TO_SHIFT_FIRST_INTERVAL, then:\nblock size 2^7 == b'1000 0000; 2^7 >> 8 == b'1000\nblock size 2^16 - 1 == b'1111 1111 1111 1111; 2^16 - 1 >> 8 == b'1111 1111\nThis ranges would yield valid indices into the __logTable. As it stands, it doesn't look like all the intervals will be used since 2^14 - 1 == b'11 1111 1111 1111; 2^14 - 1 >> 8 == b'11 1111, which  means it'll result with an interval of 4 + _logTable[3] == 5.", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505828887", "createdAt": "2020-10-15T20:40:19Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599c742bc1c529cd9bc4fd21ab89553e35d079b4"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyOTY0OA==", "bodyText": "Isn't this doing the same thing as the floorLog2 function? Couldn't we just have one implementation?", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505829648", "createdAt": "2020-10-15T20:41:14Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599c742bc1c529cd9bc4fd21ab89553e35d079b4"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyOTk4Nw==", "bodyText": "Do these comments need to be in the code?", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505829987", "createdAt": "2020-10-15T20:41:41Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];\n+   //size_t index = 0;\n+   //for (; blockSize; ++index, blockSize >>=1) {}\n+   //return index;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599c742bc1c529cd9bc4fd21ab89553e35d079b4"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2NTA5Mg==", "bodyText": "Would be better to have a more descriptive name than block1.", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505865092", "createdAt": "2020-10-15T21:23:46Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];\n+   //size_t index = 0;\n+   //for (; blockSize; ++index, blockSize >>=1) {}\n+   //return index;\n+   }\n+\n+void\n+PersistentAllocator::freeBlockToIndexedList(Block * block1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599c742bc1c529cd9bc4fd21ab89553e35d079b4"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg4NTAxMQ==", "bodyText": "I think you have to potentially update _startInterval here, since the blocks are added before the existing block, and hence when searching for a new block we won't realize a chain exists.", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505885011", "createdAt": "2020-10-15T21:50:58Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];\n+   //size_t index = 0;\n+   //for (; blockSize; ++index, blockSize >>=1) {}\n+   //return index;\n+   }\n+\n+void\n+PersistentAllocator::freeBlockToIndexedList(Block * block1)\n+   {\n+   checkIntegrity(\"freeVariableSizeBlock start\");\n+   TR_ASSERT_FATAL(block1->next() == NULL, \"Double free detected %p\", block1);\n+   TR_ASSERT(block1->size() > 0, \"Block size is non-positive\");\n+   TR_ASSERT(freeBlocksIndex(block1->size()) == LARGE_BLOCK_LIST_INDEX, \"We must be working on the variable size block list\");\n+\n+   ExtendedBlock *block = reinterpret_cast<ExtendedBlock *>(block1);\n+   block->init(); // reset links to other nodes\n+\n+   size_t index = getInterval(block->size());\n+\n+   ExtendedBlock * blockIterator = reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n+   if (!blockIterator || blockIterator->size() > block->size())\n+      {\n+      // Add at the beginning of the list\n+      block->setNext(reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]));\n+      _freeBlocks[LARGE_BLOCK_LIST_INDEX] = reinterpret_cast<Block*>(block);\n+      if (block->next())\n+         block->next()->setPrevious(block);\n+      // Adjust the interval bounderies\n+      _startInterval[index] = block;\n+      if (!_endInterval[index])\n+         _endInterval[index] = block;\n+      }\n+   else // This will not be the very first block in the variable size block list\n+      {\n+      // Find position in the list\n+      if (_startInterval[index])\n+         {\n+         // Other blocks are present in this interval\n+         ExtendedBlock *startBlock = _startInterval[index];\n+         ExtendedBlock *blockIterator = startBlock;\n+\n+         ExtendedBlock *prev = NULL;\n+         while (blockIterator && blockIterator->size() < block->size())\n+            {\n+            prev = blockIterator;\n+            blockIterator = blockIterator->next();\n+            }\n+         if (blockIterator)\n+            {\n+            // Insert at or before blockIterator\n+            if (blockIterator->size() == block->size())\n+               {\n+               // Add the block to the list of blocks of same size\n+               block->setNextBlockSameSize(blockIterator->nextBlockSameSize());\n+               blockIterator->setNextBlockSameSize(block);\n+               }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599c742bc1c529cd9bc4fd21ab89553e35d079b4"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5MjcyNA==", "bodyText": "I don't think this is necessary, since prevBlock is set to block, and block is set to block->next(), so prevBlock->next() is always going to be block, except for I guess maybe some race condition.", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505892724", "createdAt": "2020-10-15T22:09:48Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];\n+   //size_t index = 0;\n+   //for (; blockSize; ++index, blockSize >>=1) {}\n+   //return index;\n+   }\n+\n+void\n+PersistentAllocator::freeBlockToIndexedList(Block * block1)\n+   {\n+   checkIntegrity(\"freeVariableSizeBlock start\");\n+   TR_ASSERT_FATAL(block1->next() == NULL, \"Double free detected %p\", block1);\n+   TR_ASSERT(block1->size() > 0, \"Block size is non-positive\");\n+   TR_ASSERT(freeBlocksIndex(block1->size()) == LARGE_BLOCK_LIST_INDEX, \"We must be working on the variable size block list\");\n+\n+   ExtendedBlock *block = reinterpret_cast<ExtendedBlock *>(block1);\n+   block->init(); // reset links to other nodes\n+\n+   size_t index = getInterval(block->size());\n+\n+   ExtendedBlock * blockIterator = reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n+   if (!blockIterator || blockIterator->size() > block->size())\n+      {\n+      // Add at the beginning of the list\n+      block->setNext(reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]));\n+      _freeBlocks[LARGE_BLOCK_LIST_INDEX] = reinterpret_cast<Block*>(block);\n+      if (block->next())\n+         block->next()->setPrevious(block);\n+      // Adjust the interval bounderies\n+      _startInterval[index] = block;\n+      if (!_endInterval[index])\n+         _endInterval[index] = block;\n+      }\n+   else // This will not be the very first block in the variable size block list\n+      {\n+      // Find position in the list\n+      if (_startInterval[index])\n+         {\n+         // Other blocks are present in this interval\n+         ExtendedBlock *startBlock = _startInterval[index];\n+         ExtendedBlock *blockIterator = startBlock;\n+\n+         ExtendedBlock *prev = NULL;\n+         while (blockIterator && blockIterator->size() < block->size())\n+            {\n+            prev = blockIterator;\n+            blockIterator = blockIterator->next();\n+            }\n+         if (blockIterator)\n+            {\n+            // Insert at or before blockIterator\n+            if (blockIterator->size() == block->size())\n+               {\n+               // Add the block to the list of blocks of same size\n+               block->setNextBlockSameSize(blockIterator->nextBlockSameSize());\n+               blockIterator->setNextBlockSameSize(block);\n+               }\n+            else // Insert before blockIterator\n+               {\n+               block->setNext(blockIterator);\n+               block->setPrevious(blockIterator->previous());\n+               TR_ASSERT(blockIterator->previous(), \"blockIterator->previous() must exist because we already treated the case where we insert at the beginning of the list\");\n+               blockIterator->previous()->setNext(block);\n+               blockIterator->setPrevious(block);\n+               // Adjust the interval bounderies\n+               if (_startInterval[index]->size() > block->size())\n+                  {\n+                  // block becomes the first entry in this interval\n+                  TR_ASSERT(_startInterval[index] == blockIterator, \"blockInterator must be first block in this interval\"); \n+                  _startInterval[index] = block;\n+                  }\n+               else // Insert in the middle or end of interval\n+                  {\n+                  // blockIterator may belong to the next interval in\n+                  // which case _endInterval needs to be changed to block\n+                  if (_endInterval[index]->size() < block->size())\n+                     {\n+                     TR_ASSERT(getInterval(blockIterator->size()) > index, \"blockInterator must be first block in the next interval: index=%zu b->sz=%zu bi->sz=%zu\", index, block->size(), blockIterator->size());\n+                     _endInterval[index] = block;\n+                     }\n+                  }\n+               }\n+            }\n+         else // Insert after 'prev'; block will be the very last entry in the list\n+            {\n+            TR_ASSERT(prev, \"prev must exist\");\n+            TR_ASSERT(!prev->next(), \"this must be the last element in the list\");\n+            block->setPrevious(prev);\n+            block->setNext(NULL);\n+            prev->setNext(block);\n+            _endInterval[index] = block;\n+            }\n+         }\n+      else // There are no other blocks in this interval\n+         {\n+         // Find the closest interval that has a block\n+         // I verified that the block will not be attached at the beginning of the list.\n+         // Thus, there must be a previous interval with some block in it\n+         TR_ASSERT(index > 0, \"Index must be greater than 0\");\n+         for (int i = (int)index - 1; i >= 0; i--)\n+            {\n+            if (_endInterval[i])\n+               {\n+               block->setPrevious(_endInterval[i]);\n+               block->setNext(_endInterval[i]->next());\n+               TR_ASSERT(block->size() > _endInterval[i]->size(), \"wrong sizes previous\");\n+               if (block->next())\n+                  {\n+                  block->next()->setPrevious(block);\n+                  TR_ASSERT(block->size() < block->next()->size(), \"wrong sizes after block->size()=%zu next->size()=%zu\", block->size(), block->next()->size());\n+                  }\n+               _endInterval[i]->setNext(block);\n+               break;\n+               }\n+            }\n+         TR_ASSERT(block->previous(), \"I must have attached my block to the list\");\n+         _startInterval[index] = block;\n+         _endInterval[index] = block;\n+         }\n       }\n+      checkIntegrity(\"freeVariableSizeBlock end\");   \n    }\n \n+void \n+PersistentAllocator::checkIntegrity(const char msg[])\n+   {\n+#ifdef DEBUG\n+   ExtendedBlock *firstBlock = reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n+   ExtendedBlock *prevBlock = NULL;\n+   TR_ASSERT_FATAL(!firstBlock || firstBlock->previous() == NULL, \"Error for first block\");\n+   for (ExtendedBlock *block = firstBlock; block; prevBlock = block, block = block->next())\n+      {\n+      if (prevBlock)\n+         {\n+         TR_ASSERT_FATAL(prevBlock->size() < block->size(), \"Blocks are not correctly ordered\");\n+         TR_ASSERT_FATAL(block->previous() == prevBlock, \"block->previous() != prevBlock\");\n+         TR_ASSERT_FATAL(prevBlock->next() == block, \"prevBlock->next() != block\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599c742bc1c529cd9bc4fd21ab89553e35d079b4"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5MzAzNw==", "bodyText": "Since we don't really build debug builds, maybe this is better guarded with an option, or env var. Otherwise, we risk this code getting stale.", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#discussion_r505893037", "createdAt": "2020-10-15T22:10:27Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -228,58 +324,256 @@ void\n PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->size());\n    TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n-   block->_next = _freeBlocks[index];\n+   block->setNext(_freeBlocks[index]);\n    _freeBlocks[index] = block;\n    }\n \n void\n PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n    // Appropriate lock should have been obtained\n-   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   block->_next = NULL;\n+   TR_ASSERT(block->size() > 0, \"Block size is non-positive\");\n+   block->setNext(NULL);\n    // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   TR_ASSERT(freeBlocksIndex(block->_size) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n+   TR_ASSERT(freeBlocksIndex(block->size()) == LARGE_BLOCK_LIST_INDEX, \"freeVariableSizeBlock should be used for large blocks, so index should be LARGE_BLOCK_LIST_INDEX\");\n    Block * blockIterator = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n-   if (!blockIterator || !(blockIterator->_size < block->_size) )\n+   if (!blockIterator || !(blockIterator->size() < block->size()) )\n       {\n-      block->_next = _freeBlocks[LARGE_BLOCK_LIST_INDEX];\n+      block->setNext(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n       _freeBlocks[LARGE_BLOCK_LIST_INDEX] = block;\n       }\n    else\n       {\n-      while (blockIterator->next() && blockIterator->next()->_size < block->_size)\n+      while (blockIterator->next() && blockIterator->next()->size() < block->size())\n          {\n          blockIterator = blockIterator->next();\n          }\n-      block->_next = blockIterator->next();\n-      blockIterator->_next = block;\n+      block->setNext(blockIterator->next());\n+      blockIterator->setNext(block);\n+      }\n+   }\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+size_t \n+PersistentAllocator::getInterval(size_t blockSize)\n+   {  \n+   // Find the power-of-two interval that this block size belongs to\n+   TR_ASSERT(blockSize >= PERSISTANT_BLOCK_SIZE_BUCKETS * sizeof(void *), \"getInterval should be used only on big blocks. blockSize=%zu\", blockSize);\n+   // If very large block\n+   if (blockSize >= (1 << (BITS_TO_SHIFT_FIRST_INTERVAL + NUM_INTERVALS - 1)))\n+      return NUM_INTERVALS - 1; // last one\n+   blockSize >>= (BITS_TO_SHIFT_FIRST_INTERVAL + 1);\n+   // log2 implementation that uses a lookup table of 16 entries\n+   // The value to compute the log on cannot be larger than 1 byte\n+   static_assert(NUM_INTERVALS <= 9, \"For large values of NUM_INTERVALS the log2 implementation below will not work\");\n+   TR_ASSERT(blockSize < (1 << 8), \"blockSize is too large %zu to apply the log2 implementation below\", blockSize);\n+   static const uint8_t _logTable[16] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3 };\n+   size_t upper;\n+   return (upper = blockSize >> 4) ? 4 + _logTable[upper] : _logTable[blockSize];\n+   //size_t index = 0;\n+   //for (; blockSize; ++index, blockSize >>=1) {}\n+   //return index;\n+   }\n+\n+void\n+PersistentAllocator::freeBlockToIndexedList(Block * block1)\n+   {\n+   checkIntegrity(\"freeVariableSizeBlock start\");\n+   TR_ASSERT_FATAL(block1->next() == NULL, \"Double free detected %p\", block1);\n+   TR_ASSERT(block1->size() > 0, \"Block size is non-positive\");\n+   TR_ASSERT(freeBlocksIndex(block1->size()) == LARGE_BLOCK_LIST_INDEX, \"We must be working on the variable size block list\");\n+\n+   ExtendedBlock *block = reinterpret_cast<ExtendedBlock *>(block1);\n+   block->init(); // reset links to other nodes\n+\n+   size_t index = getInterval(block->size());\n+\n+   ExtendedBlock * blockIterator = reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]);\n+   if (!blockIterator || blockIterator->size() > block->size())\n+      {\n+      // Add at the beginning of the list\n+      block->setNext(reinterpret_cast<ExtendedBlock*>(_freeBlocks[LARGE_BLOCK_LIST_INDEX]));\n+      _freeBlocks[LARGE_BLOCK_LIST_INDEX] = reinterpret_cast<Block*>(block);\n+      if (block->next())\n+         block->next()->setPrevious(block);\n+      // Adjust the interval bounderies\n+      _startInterval[index] = block;\n+      if (!_endInterval[index])\n+         _endInterval[index] = block;\n+      }\n+   else // This will not be the very first block in the variable size block list\n+      {\n+      // Find position in the list\n+      if (_startInterval[index])\n+         {\n+         // Other blocks are present in this interval\n+         ExtendedBlock *startBlock = _startInterval[index];\n+         ExtendedBlock *blockIterator = startBlock;\n+\n+         ExtendedBlock *prev = NULL;\n+         while (blockIterator && blockIterator->size() < block->size())\n+            {\n+            prev = blockIterator;\n+            blockIterator = blockIterator->next();\n+            }\n+         if (blockIterator)\n+            {\n+            // Insert at or before blockIterator\n+            if (blockIterator->size() == block->size())\n+               {\n+               // Add the block to the list of blocks of same size\n+               block->setNextBlockSameSize(blockIterator->nextBlockSameSize());\n+               blockIterator->setNextBlockSameSize(block);\n+               }\n+            else // Insert before blockIterator\n+               {\n+               block->setNext(blockIterator);\n+               block->setPrevious(blockIterator->previous());\n+               TR_ASSERT(blockIterator->previous(), \"blockIterator->previous() must exist because we already treated the case where we insert at the beginning of the list\");\n+               blockIterator->previous()->setNext(block);\n+               blockIterator->setPrevious(block);\n+               // Adjust the interval bounderies\n+               if (_startInterval[index]->size() > block->size())\n+                  {\n+                  // block becomes the first entry in this interval\n+                  TR_ASSERT(_startInterval[index] == blockIterator, \"blockInterator must be first block in this interval\"); \n+                  _startInterval[index] = block;\n+                  }\n+               else // Insert in the middle or end of interval\n+                  {\n+                  // blockIterator may belong to the next interval in\n+                  // which case _endInterval needs to be changed to block\n+                  if (_endInterval[index]->size() < block->size())\n+                     {\n+                     TR_ASSERT(getInterval(blockIterator->size()) > index, \"blockInterator must be first block in the next interval: index=%zu b->sz=%zu bi->sz=%zu\", index, block->size(), blockIterator->size());\n+                     _endInterval[index] = block;\n+                     }\n+                  }\n+               }\n+            }\n+         else // Insert after 'prev'; block will be the very last entry in the list\n+            {\n+            TR_ASSERT(prev, \"prev must exist\");\n+            TR_ASSERT(!prev->next(), \"this must be the last element in the list\");\n+            block->setPrevious(prev);\n+            block->setNext(NULL);\n+            prev->setNext(block);\n+            _endInterval[index] = block;\n+            }\n+         }\n+      else // There are no other blocks in this interval\n+         {\n+         // Find the closest interval that has a block\n+         // I verified that the block will not be attached at the beginning of the list.\n+         // Thus, there must be a previous interval with some block in it\n+         TR_ASSERT(index > 0, \"Index must be greater than 0\");\n+         for (int i = (int)index - 1; i >= 0; i--)\n+            {\n+            if (_endInterval[i])\n+               {\n+               block->setPrevious(_endInterval[i]);\n+               block->setNext(_endInterval[i]->next());\n+               TR_ASSERT(block->size() > _endInterval[i]->size(), \"wrong sizes previous\");\n+               if (block->next())\n+                  {\n+                  block->next()->setPrevious(block);\n+                  TR_ASSERT(block->size() < block->next()->size(), \"wrong sizes after block->size()=%zu next->size()=%zu\", block->size(), block->next()->size());\n+                  }\n+               _endInterval[i]->setNext(block);\n+               break;\n+               }\n+            }\n+         TR_ASSERT(block->previous(), \"I must have attached my block to the list\");\n+         _startInterval[index] = block;\n+         _endInterval[index] = block;\n+         }\n       }\n+      checkIntegrity(\"freeVariableSizeBlock end\");   \n    }\n \n+void \n+PersistentAllocator::checkIntegrity(const char msg[])\n+   {\n+#ifdef DEBUG", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599c742bc1c529cd9bc4fd21ab89553e35d079b4"}, "originalPosition": 358}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9dbcb0257dfbf8681052f75475a53280ab42bb9", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e9dbcb0257dfbf8681052f75475a53280ab42bb9", "committedDate": "2020-10-16T03:38:23Z", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "599c742bc1c529cd9bc4fd21ab89553e35d079b4", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/599c742bc1c529cd9bc4fd21ab89553e35d079b4", "committedDate": "2020-10-15T18:01:25Z", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}, "afterCommit": {"oid": "e9dbcb0257dfbf8681052f75475a53280ab42bb9", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e9dbcb0257dfbf8681052f75475a53280ab42bb9", "committedDate": "2020-10-16T03:38:23Z", "message": "Improve performance of persistent memory allocator\n\nThe persistent memory allocator keeps a single linked list\nfor all freed memory blocks larger than 128 bytes. The list\nis sorted by the block size so every time we need to allocate\nfrom it or add a freed block to it we need to traverse it\nto find the appropriate spot. If this list becomes very large,\nsearching the list for the appropriate spot could consume an\nexcessive amount CPU.\nFor a regular JVM the usage pattern is not conducive to very\nlarge such lists. In contrast, JITServer makes extensive use\nof persistent memory. When one JVMClient ends, all of its\npersistent allocations (at JITServer) are put on this free\nblock list which could reach over 30K elements in size.\nThis makes allocations for a subsequent JVMClient very slow.\nThe solution implemented by this commit is to keep a set\nof indices to nodes whose sizes are power-of-two. This way,\nwhen searching for a free block, we don't have to start from\nthe beginning of the list, but start from a node in the middle\nbased on size.\nSince this change carries a bit of risk, it will be enabled\n(for the time being) only for JITServer\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzE0ODMx", "url": "https://github.com/eclipse-openj9/openj9/pull/10850#pullrequestreview-510714831", "createdAt": "2020-10-16T18:37:07Z", "commit": {"oid": "e9dbcb0257dfbf8681052f75475a53280ab42bb9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 139, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}