{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNTk0NTgw", "number": 8529, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo1MDozOVrODeJbyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo1MDozOVrODeJbyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTM4NDQwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo1MDozOVrOFnJ6rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwNDowNzoxN1rOFnPDhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwMTI2MA==", "bodyText": "Is it worth adding a small comment why the upper range check is needed? Also will we handle the non-const case correctly?", "url": "https://github.com/eclipse-openj9/openj9/pull/8529#discussion_r376601260", "createdAt": "2020-02-07T20:50:39Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -13611,7 +13611,7 @@ TR::Register *J9::Power::TreeEvaluator::arraycopyEvaluator(TR::Node *node, TR::C\n    if (node->isForwardArrayCopy() && lengthNode->getOpCode().isLoadConst())\n       {\n       len = (lengthNode->getType().isInt32() ? lengthNode->getInt() : lengthNode->getLongInt());\n-      if (len >= 0)\n+      if (len >= 0 && len < 0x100000000LL)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88b6b596185a416408f65bd82d52672cb7885a2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY4NTQ0NA==", "bodyText": "Added a comment in 6669a51.\nAs for the non-const (helper call) case, it definitely generates code that doesn't trigger any asserts, but I'm honestly not sure whether it would actually function with such a long length if it were executed as I don't know that anybody has ever bothered to test it. The issue being fixed here definitely shouldn't affect it since it's a helper and not generated by the codegen at all. Generally, AFAIK it's not possible to actually execute an arraycopy node in OpenJ9 that has such a long length as they only arise from the optimizer and are completely unreachable in practice, e.g. as a result of #8530.", "url": "https://github.com/eclipse-openj9/openj9/pull/8529#discussion_r376685444", "createdAt": "2020-02-08T04:07:17Z", "author": {"login": "aviansie-ben"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -13611,7 +13611,7 @@ TR::Register *J9::Power::TreeEvaluator::arraycopyEvaluator(TR::Node *node, TR::C\n    if (node->isForwardArrayCopy() && lengthNode->getOpCode().isLoadConst())\n       {\n       len = (lengthNode->getType().isInt32() ? lengthNode->getInt() : lengthNode->getLongInt());\n-      if (len >= 0)\n+      if (len >= 0 && len < 0x100000000LL)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwMTI2MA=="}, "originalCommit": {"oid": "c88b6b596185a416408f65bd82d52672cb7885a2"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 709, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}