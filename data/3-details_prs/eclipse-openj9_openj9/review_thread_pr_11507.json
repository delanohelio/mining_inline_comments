{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyMDMxODE4", "number": 11507, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxODowMDo0OFrOFG1anQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowMzoxNFrOFL4pVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzEwOTQxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxODowMDo0OFrOIIB9IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNDo0NDo0NFrOIIllMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5MTU1Mw==", "bodyText": "@dchopra001  This is the update you suggested me, please let me know if this change will be part of #11320 so I can remove it from here", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r545291553", "createdAt": "2020-12-17T18:00:48Z", "author": {"login": "bragaigor"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -1374,8 +1374,7 @@ TR::Register *J9::X86::TreeEvaluator::multianewArrayEvaluator(TR::Node *node, TR\n       }\n \n    // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n-   generateRegRegInstruction(MOVRegReg(),  node, temp2Reg, firstDimLenReg, cg);\n-   generateRegImmInstruction(SHLRegImm1(), node, temp2Reg, 4, cg);\n+   generateRegRegImmInstruction(IMulRegRegImms(4), node, temp2Reg, firstDimLenReg, zeroArraySize, cg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88db5cbaa77b9ce36907fc7d8ddf0a7734ec4d9b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3NTI0OA==", "bodyText": "The change will be part of the above mentioned PR (and I've ported an equivalent fix to Z as well). So you can remove it from here. Thanks!", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r545875248", "createdAt": "2020-12-18T14:44:44Z", "author": {"login": "dchopra001"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -1374,8 +1374,7 @@ TR::Register *J9::X86::TreeEvaluator::multianewArrayEvaluator(TR::Node *node, TR\n       }\n \n    // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n-   generateRegRegInstruction(MOVRegReg(),  node, temp2Reg, firstDimLenReg, cg);\n-   generateRegImmInstruction(SHLRegImm1(), node, temp2Reg, 4, cg);\n+   generateRegRegImmInstruction(IMulRegRegImms(4), node, temp2Reg, firstDimLenReg, zeroArraySize, cg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5MTU1Mw=="}, "originalCommit": {"oid": "88db5cbaa77b9ce36907fc7d8ddf0a7734ec4d9b"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzI4MjMxOnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxMTowOFrOIJZiOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxMTowOFrOIJZiOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcyNjQ1Nw==", "bodyText": "minor difference, but you can just pass dataAddr value, instead of passing headerSize and header", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r546726457", "createdAt": "2020-12-21T14:11:08Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -58,6 +58,67 @@ class MM_ObjectAllocationAPI\n \tconst J9VMGCSizeClasses *_sizeClasses;\n #endif /* J9VM_GC_SEGREGATED_HEAP */\n \n+\tVMINLINE void\n+\tinitializeIndexableSlots(bool initializeSlots, UDATA dataSize, UDATA headerSize, J9IndexableObject *header)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzI5Mzk0OnYy", "diffSide": "RIGHT", "path": "runtime/oti/j9consts.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxNDoyOFrOIJZpJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxNDoyOFrOIJZpJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcyODIyOA==", "bodyText": "i'd call it  J9_GC_INDEXABLE_DATA_FIELD_SIZE and define it as sizeof(U_64)", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r546728228", "createdAt": "2020-12-21T14:14:28Z", "author": {"login": "amicic"}, "path": "runtime/oti/j9consts.h", "diffHunk": "@@ -458,6 +458,8 @@ extern \"C\" {\n \n #define J9_GC_MINIMUM_OBJECT_SIZE 0x10\n #if defined(J9VM_ENV_DATA64)\n+#define J9_GC_EXTRA_DATA_FIELD_SIZE 0x08", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzMxMjg1OnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxOToxMlrOIJZzjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNjoxMjo1MFrOIJdsKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjczMDg5Mw==", "bodyText": "You could share the code for setter and getter.... have dataAddrSlotForContiguous() (and one for Discontiguous) that will give you address of the dataAddr Slot, and then setter and getter just de-references the address.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r546730893", "createdAt": "2020-12-21T14:19:12Z", "author": {"login": "amicic"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,143 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 address = (U_64)((UDATA)arrayPtr + contiguousHeaderSize());\n+\n+\t\tif (compressed) {\n+\t\t\t((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr = address;\n+\t\t} else {\n+\t\t\t((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr = address;\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5NDUzOA==", "bodyText": "True, were you thinking something along these lines?", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r546794538", "createdAt": "2020-12-21T16:12:50Z", "author": {"login": "bragaigor"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,143 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 address = (U_64)((UDATA)arrayPtr + contiguousHeaderSize());\n+\n+\t\tif (compressed) {\n+\t\t\t((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr = address;\n+\t\t} else {\n+\t\t\t((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr = address;\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjczMDg5Mw=="}, "originalCommit": {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDEwODY3OnYy", "diffSide": "RIGHT", "path": "runtime/oti/j9consts.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNToyNjo0MlrOIN101w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNToyNjo0MlrOIN101w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM4NDI3OQ==", "bodyText": "Remove extra space", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551384279", "createdAt": "2021-01-04T15:26:42Z", "author": {"login": "bragaigor"}, "path": "runtime/oti/j9consts.h", "diffHunk": "@@ -458,6 +458,8 @@ extern \"C\" {\n \n #define J9_GC_MINIMUM_OBJECT_SIZE 0x10\n #if defined(J9VM_ENV_DATA64)\n+#define  J9_GC_INDEXABLE_DATA_FIELD_SIZE sizeof(U_64)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686aacd36aaa6f47396d5ff1a2dd5eecc58df281"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTI1Njg4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMDo1MDo0MFrOIOAoSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMTozOTowMFrOIOCAZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTI4OA==", "bodyText": "Is the cast needed here?", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551561288", "createdAt": "2021-01-04T20:50:40Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7040,10 +7040,20 @@ static bool genZeroInitObject2(\n    auto headerSize = isArrayNew ? TR::Compiler->om.contiguousArrayHeaderSizeInBytes() : TR::Compiler->om.objectHeaderSizeInBytes();\n    // If we are using full refs both contiguous and discontiguous array header have the same size, in which case we must adjust header size\n    // slightly so that rep stosb can initialize the size field of zero sized arrays appropriately\n-   if (!cg->comp()->target().is32Bit() && !TR::Compiler->om.compressObjectReferences() && isArrayNew)\n+   //   #bits per section (compressed refs): | 32 bits |  32 bits   | 32 bits | 32 bits |   32 bits   |   32 bits    |\n+   //   zero sized arrays:                   |  class  | mustBeZero |   size  | padding |          dataAddr          |\n+   //   smallest contiguous array:           |  class  |    size    |      dataAddr     | 1 byte + padding |  other  |\n+   //   In order for us to successfully initialize the size field of a zero sized array in compressed refs\n+   //   we must subtract 8 bytes (sizeof(dataAddr)) from header size. And in case of full refs we must\n+   //   subtract 16 bytes from the header in order to properly initialize the zero sized field. We can\n+   //   accomplish that by simply subtracting the offset of dataAddr field, which is 8 for compressed refs\n+   //   and 16 for full refs.\n+#if defined(TR_TARGET_64BIT)\n+   if (!cg->comp()->target().is32Bit() && isArrayNew)\n       {\n-      headerSize -= 8;\n+      headerSize -= ((TR_J9VMBase *)(cg->fe()))->getOffsetOfContiguousDataAddrField();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686aacd36aaa6f47396d5ff1a2dd5eecc58df281"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2OTgxNw==", "bodyText": "Yes, we get a \"no member named \u2018getOffsetOfContiguousDataAddrField\u2019 in class TR_FrontEnd\" error if we don't cast it to TR_J9VMBase *", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551569817", "createdAt": "2021-01-04T21:08:53Z", "author": {"login": "bragaigor"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7040,10 +7040,20 @@ static bool genZeroInitObject2(\n    auto headerSize = isArrayNew ? TR::Compiler->om.contiguousArrayHeaderSizeInBytes() : TR::Compiler->om.objectHeaderSizeInBytes();\n    // If we are using full refs both contiguous and discontiguous array header have the same size, in which case we must adjust header size\n    // slightly so that rep stosb can initialize the size field of zero sized arrays appropriately\n-   if (!cg->comp()->target().is32Bit() && !TR::Compiler->om.compressObjectReferences() && isArrayNew)\n+   //   #bits per section (compressed refs): | 32 bits |  32 bits   | 32 bits | 32 bits |   32 bits   |   32 bits    |\n+   //   zero sized arrays:                   |  class  | mustBeZero |   size  | padding |          dataAddr          |\n+   //   smallest contiguous array:           |  class  |    size    |      dataAddr     | 1 byte + padding |  other  |\n+   //   In order for us to successfully initialize the size field of a zero sized array in compressed refs\n+   //   we must subtract 8 bytes (sizeof(dataAddr)) from header size. And in case of full refs we must\n+   //   subtract 16 bytes from the header in order to properly initialize the zero sized field. We can\n+   //   accomplish that by simply subtracting the offset of dataAddr field, which is 8 for compressed refs\n+   //   and 16 for full refs.\n+#if defined(TR_TARGET_64BIT)\n+   if (!cg->comp()->target().is32Bit() && isArrayNew)\n       {\n-      headerSize -= 8;\n+      headerSize -= ((TR_J9VMBase *)(cg->fe()))->getOffsetOfContiguousDataAddrField();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTI4OA=="}, "originalCommit": {"oid": "686aacd36aaa6f47396d5ff1a2dd5eecc58df281"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4MjIyNg==", "bodyText": "Oh I see, I saw the parenthesis in the wrong place. I thought we were casting whatever getOffsetOfContiguousDataAddrField returned to TR_J9VMBase *. A change I would like to see made is to make use of static_cast here instead of a C style cast as the C++ variant is type safe.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551582226", "createdAt": "2021-01-04T21:35:25Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7040,10 +7040,20 @@ static bool genZeroInitObject2(\n    auto headerSize = isArrayNew ? TR::Compiler->om.contiguousArrayHeaderSizeInBytes() : TR::Compiler->om.objectHeaderSizeInBytes();\n    // If we are using full refs both contiguous and discontiguous array header have the same size, in which case we must adjust header size\n    // slightly so that rep stosb can initialize the size field of zero sized arrays appropriately\n-   if (!cg->comp()->target().is32Bit() && !TR::Compiler->om.compressObjectReferences() && isArrayNew)\n+   //   #bits per section (compressed refs): | 32 bits |  32 bits   | 32 bits | 32 bits |   32 bits   |   32 bits    |\n+   //   zero sized arrays:                   |  class  | mustBeZero |   size  | padding |          dataAddr          |\n+   //   smallest contiguous array:           |  class  |    size    |      dataAddr     | 1 byte + padding |  other  |\n+   //   In order for us to successfully initialize the size field of a zero sized array in compressed refs\n+   //   we must subtract 8 bytes (sizeof(dataAddr)) from header size. And in case of full refs we must\n+   //   subtract 16 bytes from the header in order to properly initialize the zero sized field. We can\n+   //   accomplish that by simply subtracting the offset of dataAddr field, which is 8 for compressed refs\n+   //   and 16 for full refs.\n+#if defined(TR_TARGET_64BIT)\n+   if (!cg->comp()->target().is32Bit() && isArrayNew)\n       {\n-      headerSize -= 8;\n+      headerSize -= ((TR_J9VMBase *)(cg->fe()))->getOffsetOfContiguousDataAddrField();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTI4OA=="}, "originalCommit": {"oid": "686aacd36aaa6f47396d5ff1a2dd5eecc58df281"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4Mzg0Nw==", "bodyText": "Sounds good!", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551583847", "createdAt": "2021-01-04T21:39:00Z", "author": {"login": "bragaigor"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7040,10 +7040,20 @@ static bool genZeroInitObject2(\n    auto headerSize = isArrayNew ? TR::Compiler->om.contiguousArrayHeaderSizeInBytes() : TR::Compiler->om.objectHeaderSizeInBytes();\n    // If we are using full refs both contiguous and discontiguous array header have the same size, in which case we must adjust header size\n    // slightly so that rep stosb can initialize the size field of zero sized arrays appropriately\n-   if (!cg->comp()->target().is32Bit() && !TR::Compiler->om.compressObjectReferences() && isArrayNew)\n+   //   #bits per section (compressed refs): | 32 bits |  32 bits   | 32 bits | 32 bits |   32 bits   |   32 bits    |\n+   //   zero sized arrays:                   |  class  | mustBeZero |   size  | padding |          dataAddr          |\n+   //   smallest contiguous array:           |  class  |    size    |      dataAddr     | 1 byte + padding |  other  |\n+   //   In order for us to successfully initialize the size field of a zero sized array in compressed refs\n+   //   we must subtract 8 bytes (sizeof(dataAddr)) from header size. And in case of full refs we must\n+   //   subtract 16 bytes from the header in order to properly initialize the zero sized field. We can\n+   //   accomplish that by simply subtracting the offset of dataAddr field, which is 8 for compressed refs\n+   //   and 16 for full refs.\n+#if defined(TR_TARGET_64BIT)\n+   if (!cg->comp()->target().is32Bit() && isArrayNew)\n       {\n-      headerSize -= 8;\n+      headerSize -= ((TR_J9VMBase *)(cg->fe()))->getOffsetOfContiguousDataAddrField();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTI4OA=="}, "originalCommit": {"oid": "686aacd36aaa6f47396d5ff1a2dd5eecc58df281"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MjE0MDc1OnYy", "diffSide": "RIGHT", "path": "runtime/oti/j9consts.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMzoxNDowMFrOIOItNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNToyNTo1NlrOIObhoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY5MzYyMw==", "bodyText": "Brackets please.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551693623", "createdAt": "2021-01-05T03:14:00Z", "author": {"login": "gacholio"}, "path": "runtime/oti/j9consts.h", "diffHunk": "@@ -458,6 +458,8 @@ extern \"C\" {\n \n #define J9_GC_MINIMUM_OBJECT_SIZE 0x10\n #if defined(J9VM_ENV_DATA64)\n+#define J9_GC_INDEXABLE_DATA_FIELD_SIZE sizeof(U_64)\n+#define J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE J9_GC_MINIMUM_OBJECT_SIZE +  J9_GC_INDEXABLE_DATA_FIELD_SIZE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwMTk1Mg==", "bodyText": "nit: please also lose the extra space after +", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552001952", "createdAt": "2021-01-05T15:25:56Z", "author": {"login": "keithc-ca"}, "path": "runtime/oti/j9consts.h", "diffHunk": "@@ -458,6 +458,8 @@ extern \"C\" {\n \n #define J9_GC_MINIMUM_OBJECT_SIZE 0x10\n #if defined(J9VM_ENV_DATA64)\n+#define J9_GC_INDEXABLE_DATA_FIELD_SIZE sizeof(U_64)\n+#define J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE J9_GC_MINIMUM_OBJECT_SIZE +  J9_GC_INDEXABLE_DATA_FIELD_SIZE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY5MzYyMw=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDA2MDM1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNDo1NjozNVrOIOaX6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTo1ODo0NlrOIOc4Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4MzA4MA==", "bodyText": "The header file says these functions return uintptr_t. Please be consistent.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551983080", "createdAt": "2021-01-05T14:56:35Z", "author": {"login": "keithc-ca"}, "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -1024,6 +1024,10 @@ UDATA TR_J9VMBase::getOffsetOfBackfillOffsetField()                 {return offs\n \n UDATA TR_J9VMBase::getOffsetOfContiguousArraySizeField()            {return TR::Compiler->om.offsetOfContiguousArraySizeField();}\n UDATA TR_J9VMBase::getOffsetOfDiscontiguousArraySizeField()         {return TR::Compiler->om.offsetOfDiscontiguousArraySizeField();}\n+#if defined(TR_TARGET_64BIT)\n+UDATA TR_J9VMBase::getOffsetOfContiguousDataAddrField()             {return TR::Compiler->om.offsetOfContiguousDataAddrField();}\n+UDATA TR_J9VMBase::getOffsetOfDiscontiguousDataAddrField()          {return TR::Compiler->om.offsetOfDiscontiguousDataAddrField();}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxNDgyNA==", "bodyText": "You're right, I tried to be consistent with the other method usages as they have uintptr_t in the header file and UDATA here. Should I update this to use uintptr_t instead?", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552014824", "createdAt": "2021-01-05T15:45:02Z", "author": {"login": "bragaigor"}, "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -1024,6 +1024,10 @@ UDATA TR_J9VMBase::getOffsetOfBackfillOffsetField()                 {return offs\n \n UDATA TR_J9VMBase::getOffsetOfContiguousArraySizeField()            {return TR::Compiler->om.offsetOfContiguousArraySizeField();}\n UDATA TR_J9VMBase::getOffsetOfDiscontiguousArraySizeField()         {return TR::Compiler->om.offsetOfDiscontiguousArraySizeField();}\n+#if defined(TR_TARGET_64BIT)\n+UDATA TR_J9VMBase::getOffsetOfContiguousDataAddrField()             {return TR::Compiler->om.offsetOfContiguousDataAddrField();}\n+UDATA TR_J9VMBase::getOffsetOfDiscontiguousDataAddrField()          {return TR::Compiler->om.offsetOfDiscontiguousDataAddrField();}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4MzA4MA=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDExNA==", "bodyText": "In GC code, the preference seems to be in favour of standard types (e.g. uintptr_t).", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552024114", "createdAt": "2021-01-05T15:58:46Z", "author": {"login": "keithc-ca"}, "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -1024,6 +1024,10 @@ UDATA TR_J9VMBase::getOffsetOfBackfillOffsetField()                 {return offs\n \n UDATA TR_J9VMBase::getOffsetOfContiguousArraySizeField()            {return TR::Compiler->om.offsetOfContiguousArraySizeField();}\n UDATA TR_J9VMBase::getOffsetOfDiscontiguousArraySizeField()         {return TR::Compiler->om.offsetOfDiscontiguousArraySizeField();}\n+#if defined(TR_TARGET_64BIT)\n+UDATA TR_J9VMBase::getOffsetOfContiguousDataAddrField()             {return TR::Compiler->om.offsetOfContiguousDataAddrField();}\n+UDATA TR_J9VMBase::getOffsetOfDiscontiguousDataAddrField()          {return TR::Compiler->om.offsetOfDiscontiguousDataAddrField();}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4MzA4MA=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDA4MjUyOnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTowMjoxNFrOIOalzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjowMToxNFrOIOc-4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NjYzNw==", "bodyText": "This this use AssertDiscontiguousArrayletLayout?", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551986637", "createdAt": "2021-01-05T15:02:14Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyMDcwMA==", "bodyText": "For now we only use AssertDiscontiguousArrayletLayout in getDataAddrForDiscontiguous, because setDataAddrForDiscontiguous will also be setting dataAddr field for hybrid arraylets and AssertDiscontiguousArrayletLayout only asserts if they're strictly Discontiguous. The reason for that is that we made the assumption that getDataAddrForDiscontiguous(J9IndexableObject *arrayPtr) would only be used in case of pure disncotiguous arraylets (double mapping case or future off-heap technology)", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552020700", "createdAt": "2021-01-05T15:53:51Z", "author": {"login": "bragaigor"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NjYzNw=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNTgyNA==", "bodyText": "It just struck me as inconsistent to assert in dataAddrSlotForContiguous, but not dataAddrSlotForDiscontiguous.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552025824", "createdAt": "2021-01-05T16:01:14Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NjYzNw=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDA4NDczOnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTowMjo1MVrOIOanWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTowMjo1MVrOIOanWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NzAzNA==", "bodyText": "I think the first cast is redundant.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551987034", "createdAt": "2021-01-05T15:02:51Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tU_64 *dataAddr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tU_64 address = (U_64)((U_64)arrayPtr + contiguousHeaderSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDA4NTYwOnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTowMzowOVrOIOaoAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTowMzowOVrOIOaoAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NzIwMQ==", "bodyText": "Redundant cast.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551987201", "createdAt": "2021-01-05T15:03:09Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tU_64 *dataAddr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tU_64 address = (U_64)((U_64)arrayPtr + contiguousHeaderSize());\n+\t\t*dataAddr = address;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a discontiguous indexable object.\n+\t * Sets the data pointer of a discontiguous indexable object; in this case\n+\t * dataAddr will point to the contiguous representation of the data\n+\t * which resides outside the heap (assuming double map/sparse-heap is enabled).\n+\t * In case double map is disabled, the dataAddr will point to the first arrayoid\n+\t * of the discontiguous indexable object, which also resides right after dataAddr\n+\t * field.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @param dataAddr      Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForDiscontiguous(J9IndexableObject *arrayPtr, U_64 address)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tU_64 calculatedDataAddr = address;\n+\t\tU_64 *dataAddr = dataAddrSlotForDiscontiguous(arrayPtr);\n+\n+\t\t/* If calculatedDataAddr is NULL then we make dataAddr point to the first arrayoid */\n+\t\t/* Later on, when sparse-heap is enabled by default, we must assert dataAddr is not NULL */\n+\t\tif (0 == calculatedDataAddr) {\n+\t\t\tcalculatedDataAddr = (U_64)((U_64)arrayPtr + discontiguousHeaderSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDEzMzk0OnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNToxNToxNlrOIObGXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNToxNToxNlrOIObGXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk5NDk3NQ==", "bodyText": "This can be:\nuint8_t *afterAlloc = heapAlloc + allocateSize;\n\nwhich eliminates the cast here and the need for one on line 168.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551994975", "createdAt": "2021-01-05T15:15:16Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -80,25 +142,30 @@ class MM_ObjectAllocationAPI\n #endif /* J9VM_ENV_DATA64 */\n \t\t\t{\n \t\t\t\t/* Calculate the size of the object */\n-\t\t\t\tUDATA const headerSize = J9VMTHREAD_CONTIGUOUS_HEADER_SIZE(currentThread);\n-\t\t\t\tUDATA const dataSize = ((UDATA)size) * J9ARRAYCLASS_GET_STRIDE(arrayClass);\n-\t\t\t\tUDATA allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(UDATA)(_objectAlignmentInBytes - 1);\n+\t\t\t\tuintptr_t const headerSize = J9VMTHREAD_CONTIGUOUS_HEADER_SIZE(currentThread);\n+\t\t\t\tuintptr_t const dataSize = ((uintptr_t)size) * J9ARRAYCLASS_GET_STRIDE(arrayClass);\n+\t\t\t\tuintptr_t allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);\n+#if defined(J9VM_ENV_DATA64)\n+\t\t\t\tif (allocateSize < J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE) {\n+\t\t\t\t\tallocateSize = J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE;\n+\t\t\t\t}\n+#else /* !J9VM_ENV_DATA64 */\n \t\t\t\tif (allocateSize < J9_GC_MINIMUM_OBJECT_SIZE) {\n \t\t\t\t\tallocateSize = J9_GC_MINIMUM_OBJECT_SIZE;\n \t\t\t\t}\n-\n+#endif /* J9VM_ENV_DATA64 */\n \t\t\t\t/* Allocate the memory */\n \t\t\t\tj9object_t objectHeader = NULL;\n \n \t\t\t\tswitch(_gcAllocationType) {\n \n #if defined(J9VM_GC_THREAD_LOCAL_HEAP)\n \t\t\t\tcase OMR_GC_ALLOCATION_TYPE_TLH:\n-\t\t\t\t\tif (allocateSize <= ((UDATA) currentThread->heapTop - (UDATA) currentThread->heapAlloc)) {\n-\t\t\t\t\t\tU_8 *heapAlloc = currentThread->heapAlloc;\n-\t\t\t\t\t\tUDATA afterAlloc = (UDATA)heapAlloc + allocateSize;\n+\t\t\t\t\tif (allocateSize <= ((uintptr_t) currentThread->heapTop - (uintptr_t) currentThread->heapAlloc)) {\n+\t\t\t\t\t\tuint8_t *heapAlloc = currentThread->heapAlloc;\n+\t\t\t\t\t\tuintptr_t afterAlloc = (uintptr_t)heapAlloc + allocateSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDEzOTIxOnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNToxNjozNlrOIObJww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNToxNjozNlrOIObJww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk5NTg0Mw==", "bodyText": "nit: end of multi-line comment (*/) should be on a line by itself.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551995843", "createdAt": "2021-01-05T15:16:36Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -150,29 +217,24 @@ class MM_ObjectAllocationAPI\n \t\t\t\t}\n \n \t\t\t\t/* Initialize the object */\n-\t\t\t\tif (J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(currentThread)) {\n-\t\t\t\t\tJ9IndexableObjectContiguousCompressed *header = (J9IndexableObjectContiguousCompressed*)objectHeader;\n-\t\t\t\t\theader->clazz = (U_32)(UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tJ9IndexableObjectContiguousFull *header = (J9IndexableObjectContiguousFull*)objectHeader;\n-\t\t\t\t\theader->clazz = (UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tinitializeContiguousIndexableObject(currentThread, initializeSlots, arrayClass, size, dataSize, &objectHeader);\n+\n \t\t\t\tif (memoryBarrier) {\n \t\t\t\t\tVM_AtomicSupport::writeBarrier();\n \t\t\t\t}\n \t\t\t\tinstance = objectHeader;\n \t\t\t}\n \t\t} else {\n+#if defined(J9VM_ENV_DATA64)\n+\t\t\t/* Calculate size of indexable object */\n+\t\t\tuintptr_t const headerSize = J9VMTHREAD_DISCONTIGUOUS_HEADER_SIZE(currentThread);\n+\t\t\tuintptr_t allocateSize = (headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);\n+\t\t\t/* Discontiguous header size is always equal or greater than J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE; therefore,\n+\t\t\t * there's no need to check if allocateSize is less than J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDE0MzEwOnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNToxNzoyOFrOIObMFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNToxNzoyOFrOIObMFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk5NjQzOQ==", "bodyText": "Needless casts as above.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551996439", "createdAt": "2021-01-05T15:17:28Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -181,11 +243,11 @@ class MM_ObjectAllocationAPI\n #if defined(J9VM_GC_THREAD_LOCAL_HEAP)\n \t\t\tcase OMR_GC_ALLOCATION_TYPE_TLH:\n \n-\t\t\t\tif (allocateSize <= ((UDATA) currentThread->heapTop - (UDATA) currentThread->heapAlloc)) {\n-\t\t\t\t\tU_8 *heapAlloc = currentThread->heapAlloc;\n-\t\t\t\t\tUDATA afterAlloc = (UDATA)heapAlloc + allocateSize;\n+\t\t\t\tif (allocateSize <= ((uintptr_t) currentThread->heapTop - (uintptr_t) currentThread->heapAlloc)) {\n+\t\t\t\t\tuint8_t *heapAlloc = currentThread->heapAlloc;\n+\t\t\t\t\tuintptr_t afterAlloc = (uintptr_t)heapAlloc + allocateSize;\n \t\t\t\t\tobjectHeader = (j9object_t) heapAlloc;\n-\t\t\t\t\tcurrentThread->heapAlloc = (U_8 *)afterAlloc;\n+\t\t\t\t\tcurrentThread->heapAlloc = (uint8_t *)afterAlloc;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDE3MjkxOnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNToyNDo0OFrOIObe3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNToyNDo0OFrOIObe3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwMTI0Ng==", "bodyText": "I think this round-up pattern deserves to be refactored into a helper function (perhaps a macro already exists).", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552001246", "createdAt": "2021-01-05T15:24:48Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -274,9 +327,9 @@ class MM_ObjectAllocationAPI\n \t\tj9object_t instance = NULL;\n #if defined(J9VM_GC_THREAD_LOCAL_HEAP) || defined(J9VM_GC_SEGREGATED_HEAP)\n \t\t/* Calculate the size of the object */\n-\t\tUDATA const headerSize = J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n-\t\tUDATA dataSize = clazz->totalInstanceSize;\n-\t\tUDATA allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(UDATA)(_objectAlignmentInBytes - 1);\n+\t\tuintptr_t const headerSize = J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\tuintptr_t dataSize = clazz->totalInstanceSize;\n+\t\tuintptr_t allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDczMTA5OnYy", "diffSide": "RIGHT", "path": "runtime/oti/j9nonbuilder.h", "isResolved": true, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzo0MjoxOVrOIOg1VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMDoyNjo1M1rOIOmG7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg==", "bodyText": "These structures are no longer used (they exist only to keep DDR happy), so if you avoid changing them, then there may not be a need for any DDR work.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552088916", "createdAt": "2021-01-05T17:42:19Z", "author": {"login": "gacholio"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2967,18 +2967,25 @@ typedef struct J9IndexableObjectContiguous {\n #if defined(J9VM_ENV_DATA64) && defined(OMR_GC_FULL_POINTERS)\n \tU_32 padding;\n #endif /* J9VM_ENV_DATA64 && !OMR_GC_COMPRESSED_POINTERS */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMDUzMg==", "bodyText": "Sounds good. I used them because I was getting errors on PPC 32 bit machines and the usage of those macros fixed that issue. Which macro should I use to specify if the platform is 32 or 64 bits instead?", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552100532", "createdAt": "2021-01-05T18:02:52Z", "author": {"login": "bragaigor"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2967,18 +2967,25 @@ typedef struct J9IndexableObjectContiguous {\n #if defined(J9VM_ENV_DATA64) && defined(OMR_GC_FULL_POINTERS)\n \tU_32 padding;\n #endif /* J9VM_ENV_DATA64 && !OMR_GC_COMPRESSED_POINTERS */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNzA5OQ==", "bodyText": "J9VM_ENV_DATA64 is the right macro to use.\nThey must be updated or DDR will break: see my comment below.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552107099", "createdAt": "2021-01-05T18:14:56Z", "author": {"login": "keithc-ca"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2967,18 +2967,25 @@ typedef struct J9IndexableObjectContiguous {\n #if defined(J9VM_ENV_DATA64) && defined(OMR_GC_FULL_POINTERS)\n \tU_32 padding;\n #endif /* J9VM_ENV_DATA64 && !OMR_GC_COMPRESSED_POINTERS */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjExMjM5MQ==", "bodyText": "Ah I see what you mean. Only the structures J9IndexableObject.*Compressed and J9IndexableObject.*Full are used while J9IndexableObjectContiguous is not, correct? Can I say the same for J9IndexableObjectDiscontiguous struct?", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552112391", "createdAt": "2021-01-05T18:24:05Z", "author": {"login": "bragaigor"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2967,18 +2967,25 @@ typedef struct J9IndexableObjectContiguous {\n #if defined(J9VM_ENV_DATA64) && defined(OMR_GC_FULL_POINTERS)\n \tU_32 padding;\n #endif /* J9VM_ENV_DATA64 && !OMR_GC_COMPRESSED_POINTERS */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEyMTc0Ng==", "bodyText": "Perhaps the answer is what I thought we had already done - add a flag to indicate the presence of the compressed/full structures and use that instead of the mixed mode flag. Then we could leave the outdated structures as-is.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552121746", "createdAt": "2021-01-05T18:42:25Z", "author": {"login": "gacholio"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2967,18 +2967,25 @@ typedef struct J9IndexableObjectContiguous {\n #if defined(J9VM_ENV_DATA64) && defined(OMR_GC_FULL_POINTERS)\n \tU_32 padding;\n #endif /* J9VM_ENV_DATA64 && !OMR_GC_COMPRESSED_POINTERS */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1NzIyNg==", "bodyText": "The DDR code must continue to use J9IndexableObjectContiguous and J9IndexableObjectDiscontiguous to support core files from VMs before the introduction of the *Compressed and *Full variants. The old types should have sizes that reflect the new reality so the offset to the elements can be correctly computed.\nI'm not sure it's worth the effort to avoid using J9IndexableObjectContiguous or J9IndexableObjectDiscontiguous except for old core files.\nThe dataAddr field should be added to all six types (in 64-bit builds).", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552157226", "createdAt": "2021-01-05T19:50:17Z", "author": {"login": "keithc-ca"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2967,18 +2967,25 @@ typedef struct J9IndexableObjectContiguous {\n #if defined(J9VM_ENV_DATA64) && defined(OMR_GC_FULL_POINTERS)\n \tU_32 padding;\n #endif /* J9VM_ENV_DATA64 && !OMR_GC_COMPRESSED_POINTERS */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE2MTA3Mg==", "bodyText": "The DDR code must continue to use J9IndexableObjectContiguous and J9IndexableObjectDiscontiguous to support core files from VMs before the introduction of the *Compressed and *Full variants.\n\nCurious why we have this restriction? Shouldn't we always use the DDR/jdmpview version that came with the VM which generated the core file being investigated?", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552161072", "createdAt": "2021-01-05T19:57:39Z", "author": {"login": "fjeremic"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2967,18 +2967,25 @@ typedef struct J9IndexableObjectContiguous {\n #if defined(J9VM_ENV_DATA64) && defined(OMR_GC_FULL_POINTERS)\n \tU_32 padding;\n #endif /* J9VM_ENV_DATA64 && !OMR_GC_COMPRESSED_POINTERS */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3NDU0Nw==", "bodyText": "Yes, I suppose there is no benefit to doing as I suggested. The sizes are derived from the core file, so there's no reason not to update the obsolete structures.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552174547", "createdAt": "2021-01-05T20:25:15Z", "author": {"login": "gacholio"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2967,18 +2967,25 @@ typedef struct J9IndexableObjectContiguous {\n #if defined(J9VM_ENV_DATA64) && defined(OMR_GC_FULL_POINTERS)\n \tU_32 padding;\n #endif /* J9VM_ENV_DATA64 && !OMR_GC_COMPRESSED_POINTERS */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3NTM0Mg==", "bodyText": "The intent has always been that DDR is backward-compatible; that is, a new version of jdmpview should be able to read a core file produced by an older VM. This greatly simplifies the support story: you don't need to have every version in use by any customer to support them all. If a problem is identified in DDR in the version used by some client, you have the option to use a newer version (perhaps a new, custom version) to examine core files.\nRather than a restriction, this permits greater freedom in your choice of which version of jdmpview to use.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552175342", "createdAt": "2021-01-05T20:26:53Z", "author": {"login": "keithc-ca"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2967,18 +2967,25 @@ typedef struct J9IndexableObjectContiguous {\n #if defined(J9VM_ENV_DATA64) && defined(OMR_GC_FULL_POINTERS)\n \tU_32 padding;\n #endif /* J9VM_ENV_DATA64 && !OMR_GC_COMPRESSED_POINTERS */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDczMjU5OnYy", "diffSide": "RIGHT", "path": "runtime/oti/j9nonbuilder.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzo0Mjo0N1rOIOg2Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzo1NDoyMFrOIOhPjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTE2Mg==", "bodyText": "Same comment as above - don't change the unused structures.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552089162", "createdAt": "2021-01-05T17:42:47Z", "author": {"login": "gacholio"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2989,13 +2996,19 @@ typedef struct J9IndexableObjectDiscontiguous {\n #if defined(OMR_GC_COMPRESSED_POINTERS) || !defined(J9VM_ENV_DATA64)\n \tU_32 padding;\n #endif /* OMR_GC_COMPRESSED_POINTERS || !J9VM_ENV_DATA64 */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA5NTYzMA==", "bodyText": "Those types are used in DDR code, e.g. J9IndexableObjectHelper.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552095630", "createdAt": "2021-01-05T17:54:20Z", "author": {"login": "keithc-ca"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2989,13 +2996,19 @@ typedef struct J9IndexableObjectDiscontiguous {\n #if defined(OMR_GC_COMPRESSED_POINTERS) || !defined(J9VM_ENV_DATA64)\n \tU_32 padding;\n #endif /* OMR_GC_COMPRESSED_POINTERS || !J9VM_ENV_DATA64 */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTE2Mg=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3ODk5MjYwOnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxNjoxMzowMVrOIPJrdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxNjoxMzowMVrOIPJrdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc1ODEzNQ==", "bodyText": "nit: please remove this blank line", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552758135", "createdAt": "2021-01-06T16:13:01Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tvoid **dataAddrPtr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tvoid *dataAddr = (void *)((U_64)arrayPtr + contiguousHeaderSize());\n+\t\t*dataAddrPtr = dataAddr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a discontiguous indexable object.\n+\t * Sets the data pointer of a discontiguous indexable object; in this case\n+\t * dataAddr will point to the contiguous representation of the data\n+\t * which resides outside the heap (assuming double map/sparse-heap is enabled).\n+\t * In case double map is disabled, the dataAddr will point to the first arrayoid\n+\t * of the discontiguous indexable object, which also resides right after dataAddr\n+\t * field.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @param dataAddr      Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForDiscontiguous(J9IndexableObject *arrayPtr, void *address)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tvoid *calculatedDataAddr = address;\n+\t\tvoid **dataAddrPtr = dataAddrSlotForDiscontiguous(arrayPtr);\n+\n+\t\t/* If calculatedDataAddr is NULL then we make dataAddr point to the first arrayoid */\n+\t\t/* Later on, when sparse-heap is enabled by default, we must assert dataAddr is not NULL */\n+\t\tif (NULL == calculatedDataAddr) {\n+\t\t\tcalculatedDataAddr = (void *)((U_64)arrayPtr + discontiguousHeaderSize());\n+\t\t}\n+\n+\t\t*dataAddrPtr = calculatedDataAddr;\n+\t}\n+\n+\t/**\n+\t * Returns data pointer associated with a contiguous Indexable object.\n+\t * Data pointer will always be pointing at the arraylet data. In this\n+\t * case the data pointer will be pointing to address immediately after\n+\t * the header.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @return data address associated with the Indexable object\n+\t */\n+\tMMINLINE void *\n+\tgetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tvoid *dataAddr = *dataAddrSlotForContiguous(arrayPtr);\n+\t\treturn dataAddr;\n+\t}\n+\n+\t/**\n+\t * Returns data pointer associated with a discontiguous Indexable object.\n+\t * Data pointer will always be pointing at the arraylet data. In this\n+\t * case the data pointer will be pointing to address immediately after\n+\t * the header (the arrayoid), except when double mapping or sparse-heap\n+\t * is enabled. In these cases, the data pointer will point to the\n+\t * contiguous representation of the data; hence returning that pointer.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @return data address associated with the Indexable object\n+\t */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23a6fbc2f8e8f6efe1722772b18f011d37222f4d"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3OTkxMTI4OnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOToxMjo1OVrOIPTB6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTozMDoyMVrOIPTjcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMTMzNw==", "bodyText": "U64 is not correct in the name - the logic is correct (and used) even on 32bit, too.\nRename it to either ROUND_TO, or perhaps ROUND_UP_TO\nBTW, the same logic exists in GC_ObjectModelBase::adjustSizeInBytes() in OMR. Ideally, the macro should be on OMR side and both sides use it (but I guess this ok for now),", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552911337", "createdAt": "2021-01-06T19:12:59Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -33,6 +33,9 @@\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n \n+/* Generic rounding macro - result is a uintptr_t */\n+#define ROUND_U64_TO(granularity, number) (((uintptr_t)(number) + (granularity) - 1) & ~((uintptr_t)(granularity) - 1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMjExOA==", "bodyText": "and I'd swap the positions of the arguments", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552912118", "createdAt": "2021-01-06T19:14:30Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -33,6 +33,9 @@\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n \n+/* Generic rounding macro - result is a uintptr_t */\n+#define ROUND_U64_TO(granularity, number) (((uintptr_t)(number) + (granularity) - 1) & ~((uintptr_t)(granularity) - 1))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMTMzNw=="}, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxNDY5Ng==", "bodyText": "we actually have a macro already: ROUND_UP_TO_POWEROF2 (object heap alignment is 8, what indeed is a power of 2)", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552914696", "createdAt": "2021-01-06T19:19:46Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -33,6 +33,9 @@\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n \n+/* Generic rounding macro - result is a uintptr_t */\n+#define ROUND_U64_TO(granularity, number) (((uintptr_t)(number) + (granularity) - 1) & ~((uintptr_t)(granularity) - 1))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMTMzNw=="}, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxNjg5NA==", "bodyText": "I thought I remembered OMR having such a macro. Thanks, @amicic for pointing it out.\nThis should definitely use ROUND_UP_TO_POWEROF2.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552916894", "createdAt": "2021-01-06T19:24:23Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -33,6 +33,9 @@\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n \n+/* Generic rounding macro - result is a uintptr_t */\n+#define ROUND_U64_TO(granularity, number) (((uintptr_t)(number) + (granularity) - 1) & ~((uintptr_t)(granularity) - 1))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMTMzNw=="}, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxOTkyMg==", "bodyText": "Yes I was going with ROUND_TO but ran into some issues with redefinition and namespaces. Cool I didn't know about ROUND_UP_TO_POWEROF2, I'll update it to make use of this macro, thanks!", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552919922", "createdAt": "2021-01-06T19:30:21Z", "author": {"login": "bragaigor"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -33,6 +33,9 @@\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n \n+/* Generic rounding macro - result is a uintptr_t */\n+#define ROUND_U64_TO(granularity, number) (((uintptr_t)(number) + (granularity) - 1) & ~((uintptr_t)(granularity) - 1))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMTMzNw=="}, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDAwMjMyOnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0MTo0OVrOIPT4Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0MTo0OVrOIPT4Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNTI3MQ==", "bodyText": "it's more generic/optimal (in potential case this gets used on 32 bit) to cast to UDATA (what also discontiguousHeaderSize() returns).\nsame for contiguous", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552925271", "createdAt": "2021-01-06T19:41:49Z", "author": {"login": "amicic"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,160 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tvoid **dataAddrPtr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tvoid *dataAddr = (void *)((U_64)arrayPtr + contiguousHeaderSize());\n+\t\t*dataAddrPtr = dataAddr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a discontiguous indexable object.\n+\t * Sets the data pointer of a discontiguous indexable object; in this case\n+\t * dataAddr will point to the contiguous representation of the data\n+\t * which resides outside the heap (assuming double map/sparse-heap is enabled).\n+\t * In case double map is disabled, the dataAddr will point to the first arrayoid\n+\t * of the discontiguous indexable object, which also resides right after dataAddr\n+\t * field.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @param dataAddr      Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForDiscontiguous(J9IndexableObject *arrayPtr, void *address)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tvoid *calculatedDataAddr = address;\n+\t\tvoid **dataAddrPtr = dataAddrSlotForDiscontiguous(arrayPtr);\n+\n+\t\t/* If calculatedDataAddr is NULL then we make dataAddr point to the first arrayoid */\n+\t\t/* Later on, when sparse-heap is enabled by default, we must assert dataAddr is not NULL */\n+\t\tif (NULL == calculatedDataAddr) {\n+\t\t\tcalculatedDataAddr = (void *)((U_64)arrayPtr + discontiguousHeaderSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDAyNTgwOnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo1MDowNFrOIPUGzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo1MDowNFrOIPUGzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODk3Mw==", "bodyText": "missed to use the macro", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552928973", "createdAt": "2021-01-06T19:50:04Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -150,29 +220,25 @@ class MM_ObjectAllocationAPI\n \t\t\t\t}\n \n \t\t\t\t/* Initialize the object */\n-\t\t\t\tif (J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(currentThread)) {\n-\t\t\t\t\tJ9IndexableObjectContiguousCompressed *header = (J9IndexableObjectContiguousCompressed*)objectHeader;\n-\t\t\t\t\theader->clazz = (U_32)(UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tJ9IndexableObjectContiguousFull *header = (J9IndexableObjectContiguousFull*)objectHeader;\n-\t\t\t\t\theader->clazz = (UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tinitializeContiguousIndexableObject(currentThread, initializeSlots, arrayClass, size, dataSize, &objectHeader);\n+\n \t\t\t\tif (memoryBarrier) {\n \t\t\t\t\tVM_AtomicSupport::writeBarrier();\n \t\t\t\t}\n \t\t\t\tinstance = objectHeader;\n \t\t\t}\n \t\t} else {\n+#if defined(J9VM_ENV_DATA64)\n+\t\t\t/* Calculate size of indexable object */\n+\t\t\tuintptr_t const headerSize = J9VMTHREAD_DISCONTIGUOUS_HEADER_SIZE(currentThread);\n+\t\t\tuintptr_t allocateSize = (headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA2NzQxOnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowMzoxNFrOIPUg6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxMDoyMlrOIPUsoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNTY1Nw==", "bodyText": "(NULL != dataAddr) is just temporary till all parties do initialize/update dataAddr? Even in 0-sized arrays, this will be initialized (to the end of header)?", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552935657", "createdAt": "2021-01-06T20:03:14Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -48,16 +51,78 @@ class MM_ObjectAllocationAPI\n \t * Data members\n \t */\n private:\n-\tconst UDATA _gcAllocationType;\n+\tconst uintptr_t _gcAllocationType;\n #if defined(J9VM_GC_BATCH_CLEAR_TLH)\n-\tconst UDATA _initializeSlotsOnTLHAllocate;\n+\tconst uintptr_t _initializeSlotsOnTLHAllocate;\n #endif /* J9VM_GC_BATCH_CLEAR_TLH */\n-\tconst UDATA _objectAlignmentInBytes;\n+\tconst uintptr_t _objectAlignmentInBytes;\n \n #if defined (J9VM_GC_SEGREGATED_HEAP)\n \tconst J9VMGCSizeClasses *_sizeClasses;\n #endif /* J9VM_GC_SEGREGATED_HEAP */\n \n+\tVMINLINE void\n+\tinitializeIndexableSlots(bool initializeSlots, uintptr_t dataSize, void *dataAddr)\n+\t{\n+\t\tif ((NULL != dataAddr) && initializeSlots) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzODY1Nw==", "bodyText": "Yes, dataAddr will always be initialized to:\nvoid *dataAddr = (void *)((uintptr_t)header + headerSize);\n\n(NULL != dataAddr) is there for safety even though it's not necessary since the default is to init dataAddr to point to data right after header.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552938657", "createdAt": "2021-01-06T20:10:22Z", "author": {"login": "bragaigor"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -48,16 +51,78 @@ class MM_ObjectAllocationAPI\n \t * Data members\n \t */\n private:\n-\tconst UDATA _gcAllocationType;\n+\tconst uintptr_t _gcAllocationType;\n #if defined(J9VM_GC_BATCH_CLEAR_TLH)\n-\tconst UDATA _initializeSlotsOnTLHAllocate;\n+\tconst uintptr_t _initializeSlotsOnTLHAllocate;\n #endif /* J9VM_GC_BATCH_CLEAR_TLH */\n-\tconst UDATA _objectAlignmentInBytes;\n+\tconst uintptr_t _objectAlignmentInBytes;\n \n #if defined (J9VM_GC_SEGREGATED_HEAP)\n \tconst J9VMGCSizeClasses *_sizeClasses;\n #endif /* J9VM_GC_SEGREGATED_HEAP */\n \n+\tVMINLINE void\n+\tinitializeIndexableSlots(bool initializeSlots, uintptr_t dataSize, void *dataAddr)\n+\t{\n+\t\tif ((NULL != dataAddr) && initializeSlots) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNTY1Nw=="}, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 889, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}