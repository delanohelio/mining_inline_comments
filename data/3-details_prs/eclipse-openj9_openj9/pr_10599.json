{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3Mzg4MTUw", "number": 10599, "title": "Fix GCMap issue for read only unresolved field resolution and resolve virtual call sequence", "bodyText": "For the read only unresolved field resolution and resolution of virtual , JIT helper glue code will have set up the return address to be the start of the resolution sequence where after returning from the helper, we again load the correct index or\naddress in case of field resolution and vTable offset for virtual call from the resolution data block. If the helper we call ends up triggering GC, the stack walker will use the JIT return address we passed to walk current JIT frame and find the GC map associated with the return address. The GC map logic subtracts 1 which means that unless we create the GC Map on an instruction before the return label, we will retrieve the wrong GC map. Correct fix here would be passing the address of next instruction after the snippet call in mainline as jitEIP when we call JIT helper. This commit fixes this issue.\nSigned-off-by: Rahil Shah rahil@ca.ibm.com", "createdAt": "2020-09-15T15:42:09Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10599", "merged": true, "mergeCommit": {"oid": "0bfc9b8607a0cc52765e8295c6778b7f6d2bcb37"}, "closed": true, "closedAt": "2020-09-29T16:38:39Z", "author": {"login": "r30shah"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLFmPnABqjM3ODk0NDE2NDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNq610AFqTQ5ODY3OTkxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f54ba020dea0cc81d6e7e8aad02da0b028256288", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f54ba020dea0cc81d6e7e8aad02da0b028256288", "committedDate": "2020-09-15T13:37:38Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "3e82f0896ddf131c965ca251765635b1ea57d3da", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3e82f0896ddf131c965ca251765635b1ea57d3da", "committedDate": "2020-09-21T16:01:32Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e82f0896ddf131c965ca251765635b1ea57d3da", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3e82f0896ddf131c965ca251765635b1ea57d3da", "committedDate": "2020-09-21T16:01:32Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "27cadae793bd317f4c6fbd475dfddca423245cc8", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/27cadae793bd317f4c6fbd475dfddca423245cc8", "committedDate": "2020-09-23T19:08:30Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5f6f000c11c73729e9a8f136a21a40a7fe38416", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c5f6f000c11c73729e9a8f136a21a40a7fe38416", "committedDate": "2020-09-23T19:45:54Z", "message": "Remove the un-needed NOP added for adjusting GCMap\n\nFor Unresolved Virtual Call Dispatch sequence in read only code, we had\nto add a NOP in mainline before the start of the resolve sequence for\nsuch calls to make sure that if a GC is triggered while calling C helper\nfunction, it sees correct GCMap. This was a hack with potential bug where\nlocal register assigner can shuffles the register between NOP and start\nof virtual call resolution sequence which can alter the state of\nregisters.\nCorrect fix for this issue is implemented in this commit where while\ncalling C helper from PicBuilder, it passes the address of the next\ninstruction in mainline after snippet call.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "27cadae793bd317f4c6fbd475dfddca423245cc8", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/27cadae793bd317f4c6fbd475dfddca423245cc8", "committedDate": "2020-09-23T19:08:30Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "7b338abb5dd0f20fafbafcf06353059bd235de0a", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7b338abb5dd0f20fafbafcf06353059bd235de0a", "committedDate": "2020-09-23T19:46:02Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NTc4Njcz", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#pullrequestreview-497578673", "createdAt": "2020-09-28T14:36:57Z", "commit": {"oid": "7b338abb5dd0f20fafbafcf06353059bd235de0a"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNDozNjo1N1rOHZAvWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNDo0ODo0MlrOHZBRJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk4ODU2OQ==", "bodyText": "Tabs should be spaces here for consistency.", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495988569", "createdAt": "2020-09-28T14:36:57Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.cpp", "diffHunk": "@@ -122,12 +123,11 @@ J9::Z::UnresolvedDataReadOnlySnippet::emitSnippetBody()\n       // Branch to doneLabel (BRCL 0xF,[doneLabel])\n       *reinterpret_cast<int16_t*>(cursor) = 0xC0F4;\n \n-      addressA = reinterpret_cast<intptr_t>(doneLabel->getCodeLocation());\n-      addressB = reinterpret_cast<intptr_t>(cursor);\n+\t\tintptr_t doneLabelAddress = reinterpret_cast<intptr_t>(doneLabel->getCodeLocation());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b338abb5dd0f20fafbafcf06353059bd235de0a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5MDQ4NQ==", "bodyText": "How about calling it what is is, i.e. returnLabel?", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495990485", "createdAt": "2020-09-28T14:39:40Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.cpp", "diffHunk": "@@ -67,12 +67,14 @@ J9::Z::UnresolvedDataReadOnlySnippet::UnresolvedDataReadOnlySnippet(\n       intptr_t resolveDataAddress,\n       TR::LabelSymbol *startResolveSequenceLabel,\n       TR::LabelSymbol *volatileFenceLabel,\n+      TR::LabelSymbol *snippetCallNextInstrLabel,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b338abb5dd0f20fafbafcf06353059bd235de0a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5MjAyNQ==", "bodyText": "We should probably leave this comment in.", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495992025", "createdAt": "2020-09-28T14:41:45Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.cpp", "diffHunk": "@@ -89,26 +91,25 @@ J9::Z::UnresolvedDataReadOnlySnippet::emitSnippetBody()\n    TR::GlobalFunctionCallData dataDestination(glueSymRef, getNode(), cursor, cg(), self());\n    cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n \n-   // Relative address to the CCUnresolvedData*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b338abb5dd0f20fafbafcf06353059bd235de0a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5NTAyMg==", "bodyText": "How about naming this startResolveSequenceLabelAddr?", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495995022", "createdAt": "2020-09-28T14:45:40Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.cpp", "diffHunk": "@@ -89,26 +91,25 @@ J9::Z::UnresolvedDataReadOnlySnippet::emitSnippetBody()\n    TR::GlobalFunctionCallData dataDestination(glueSymRef, getNode(), cursor, cg(), self());\n    cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n \n-   // Relative address to the CCUnresolvedData*\n-   intptr_t addressA = reinterpret_cast<intptr_t>(resolveDataAddress);\n-   intptr_t addressB = reinterpret_cast<intptr_t>(cursor);\n+   uint8_t *helperCallRA = cursor;\n \n-   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(addressA), \"CCUnresolvedData* [%p] is outside relative immediate range\", addressA);\n+   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(resolveDataAddress), \"CCUnresolvedData* [%p] is outside relative immediate range\", resolveDataAddress);\n \n-   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(addressA - addressB);\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(resolveDataAddress - (intptr_t)helperCallRA);\n    cursor += 4;\n \n    // Constant pool index\n    *reinterpret_cast<int32_t*>(cursor) = getCPIndex();\n    cursor += 4;\n \n    // Relative address to the start of the mainline resolution\n-   addressA = reinterpret_cast<intptr_t>(startResolveSequenceLabel->getCodeLocation());\n-   addressB = reinterpret_cast<intptr_t>(cursor);\n-\n-   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(addressA), \"startResolveSequenceLabel [%p] is outside relative immediate range\", addressA);\n+   intptr_t startOfResolutionSeqLabelAddr = reinterpret_cast<intptr_t>(startResolveSequenceLabel->getCodeLocation());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b338abb5dd0f20fafbafcf06353059bd235de0a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5Njc1OA==", "bodyText": "We should add a comment above this similar to others about what it is trying to encode. For example Relative address to the return label following the snippet call.", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495996758", "createdAt": "2020-09-28T14:48:04Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.cpp", "diffHunk": "@@ -89,26 +91,25 @@ J9::Z::UnresolvedDataReadOnlySnippet::emitSnippetBody()\n    TR::GlobalFunctionCallData dataDestination(glueSymRef, getNode(), cursor, cg(), self());\n    cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n \n-   // Relative address to the CCUnresolvedData*\n-   intptr_t addressA = reinterpret_cast<intptr_t>(resolveDataAddress);\n-   intptr_t addressB = reinterpret_cast<intptr_t>(cursor);\n+   uint8_t *helperCallRA = cursor;\n \n-   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(addressA), \"CCUnresolvedData* [%p] is outside relative immediate range\", addressA);\n+   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(resolveDataAddress), \"CCUnresolvedData* [%p] is outside relative immediate range\", resolveDataAddress);\n \n-   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(addressA - addressB);\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(resolveDataAddress - (intptr_t)helperCallRA);\n    cursor += 4;\n \n    // Constant pool index\n    *reinterpret_cast<int32_t*>(cursor) = getCPIndex();\n    cursor += 4;\n \n    // Relative address to the start of the mainline resolution\n-   addressA = reinterpret_cast<intptr_t>(startResolveSequenceLabel->getCodeLocation());\n-   addressB = reinterpret_cast<intptr_t>(cursor);\n-\n-   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(addressA), \"startResolveSequenceLabel [%p] is outside relative immediate range\", addressA);\n+   intptr_t startOfResolutionSeqLabelAddr = reinterpret_cast<intptr_t>(startResolveSequenceLabel->getCodeLocation());\n+   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(startOfResolutionSeqLabelAddr), \"startResolveSequenceLabel [%p] is outside relative immediate range\", startOfResolutionSeqLabelAddr);\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(startOfResolutionSeqLabelAddr - (intptr_t)helperCallRA);\n+   cursor += 4;\n \n-   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(addressA - addressB);\n+   intptr_t snippetCallNextInstrLabelAddress = reinterpret_cast<intptr_t>(snippetCallNextInstrLabel->getCodeLocation());\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(snippetCallNextInstrLabelAddress - (intptr_t)helperCallRA);\n    cursor += 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b338abb5dd0f20fafbafcf06353059bd235de0a"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5NzIyMg==", "bodyText": "We should order these in the same way as the parameters to the constructor. I'll ignore the fact that we're missing documentation which is true for a wide scope of this effort. We will get to it though before we merge into mainline.", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#discussion_r495997222", "createdAt": "2020-09-28T14:48:42Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9UnresolvedDataReadOnlySnippet.hpp", "diffHunk": "@@ -89,6 +90,7 @@ class UnresolvedDataReadOnlySnippet : public TR::Snippet\n    TR::LabelSymbol *startResolveSequenceLabel;\n    TR::LabelSymbol *volatileFenceLabel;\n    TR::LabelSymbol *doneLabel;\n+   TR::LabelSymbol *snippetCallNextInstrLabel;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b338abb5dd0f20fafbafcf06353059bd235de0a"}, "originalPosition": 12}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7b338abb5dd0f20fafbafcf06353059bd235de0a", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7b338abb5dd0f20fafbafcf06353059bd235de0a", "committedDate": "2020-09-23T19:46:02Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "ee40f0a3614cab3847b46a4b61c6fb2795d4b775", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ee40f0a3614cab3847b46a4b61c6fb2795d4b775", "committedDate": "2020-09-28T19:54:43Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee40f0a3614cab3847b46a4b61c6fb2795d4b775", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ee40f0a3614cab3847b46a4b61c6fb2795d4b775", "committedDate": "2020-09-28T19:54:43Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "3ac390dbe99682be85f71980c4568d19c47c35dd", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3ac390dbe99682be85f71980c4568d19c47c35dd", "committedDate": "2020-09-28T20:05:26Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "602be0121b2e925ba5801a153abb585fe9008379", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/602be0121b2e925ba5801a153abb585fe9008379", "committedDate": "2020-09-28T20:08:04Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ac390dbe99682be85f71980c4568d19c47c35dd", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3ac390dbe99682be85f71980c4568d19c47c35dd", "committedDate": "2020-09-28T20:05:26Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "602be0121b2e925ba5801a153abb585fe9008379", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/602be0121b2e925ba5801a153abb585fe9008379", "committedDate": "2020-09-28T20:08:04Z", "message": "Fix GCMap issue in Unresolved field Resolution\n\nFor the unresolved field resolution, JIT helper glue code will have set\nup the return address to be the start of the resolution sequence where\nafter returning from the helper, we again load the correct index or\naddress from the resolution data block. If the helper we call ends up\ntriggering GC, the stack walker will use the JIT return address we\npassed to walk current JIT frame and find the GC map associated with the\nreturn address. The GC map logic subtracts 1 which means that unless we\ncreate the GC Map on an instruction before the return label, we will\nretrive the wrong GC map. Correct fix here would be passing the address\nof next instruction after the snippet call in mainline as jitEIP when\nwe call JIT helper. This commit fixes this issue.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4Njc5OTE5", "url": "https://github.com/eclipse-openj9/openj9/pull/10599#pullrequestreview-498679919", "createdAt": "2020-09-29T16:38:32Z", "commit": {"oid": "602be0121b2e925ba5801a153abb585fe9008379"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 10, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}