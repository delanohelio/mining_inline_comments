{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzOTkxNjMy", "number": 11393, "title": "Remove unneeded code in NULLCHKEvaluator", "bodyText": "There is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\nFixes: #11318\nSigned-off-by: Filip Jeremic fjeremic@ca.ibm.com", "createdAt": "2020-12-07T22:36:00Z", "url": "https://github.com/eclipse-openj9/openj9/pull/11393", "merged": true, "mergeCommit": {"oid": "1f0f08e949d6e4eddd4719ff3759d029d1799b8b"}, "closed": true, "closedAt": "2021-01-28T16:52:26Z", "author": {"login": "fjeremic"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmdoBRgBqjQxMTU3MzA4OTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd0noyqgFqTU3ODUzODkxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95df5ec5958e4439a865bc5c4505a6e26a8c2b3a", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/95df5ec5958e4439a865bc5c4505a6e26a8c2b3a", "committedDate": "2020-12-07T22:23:19Z", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}, "afterCommit": {"oid": "4870a0dbcafbff3fd8d2bf3451f001352677f096", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4870a0dbcafbff3fd8d2bf3451f001352677f096", "committedDate": "2020-12-15T17:16:39Z", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4870a0dbcafbff3fd8d2bf3451f001352677f096", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4870a0dbcafbff3fd8d2bf3451f001352677f096", "committedDate": "2020-12-15T17:16:39Z", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}, "afterCommit": {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/602e95240bd6a245c0e2ff0c95dd61918cd11792", "committedDate": "2020-12-15T17:18:33Z", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTc0NjM4", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#pullrequestreview-554974638", "createdAt": "2020-12-17T20:46:39Z", "commit": {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMDQzMzI3", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#pullrequestreview-563043327", "createdAt": "2021-01-06T21:19:09Z", "commit": {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToxOTowOVrOIPWX7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMTo1NDozNlrOIPXNnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjEyNA==", "bodyText": "Found the issue. It appears that the code is slightly different on x86 than on Z and Power in this area. The mistake here is the new line we added should be cg->evaluate(node->getFirstChild());. This is because on x86 we modify the value of firstChild where as on Z and Power we do not.\nHere is explicitly where we do this in the code on x86:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/x/codegen/J9TreeEvaluator.cpp#L1665-L1688\nAnd for reference here it is on Z for example (where we use a separate variable n to do this):\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/z/codegen/J9TreeEvaluator.cpp#L5571-L5590\nAnd here it is on Power:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/p/codegen/J9TreeEvaluator.cpp#L13111-L13124", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#discussion_r552966124", "createdAt": "2021-01-06T21:19:09Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2001,25 +2001,7 @@ TR::Register *J9::X86::TreeEvaluator::evaluateNULLCHKWithPossibleResolve(\n    //\n    if (needLateEvaluation)\n       {\n-      if (comp->useCompressedPointers())\n-         {\n-         // for stores under NULLCHKs, artificially bump\n-         // down the reference count before evaluation (since stores\n-         // return null as registers)\n-         //\n-         bool fixRefCount = false;\n-         if (node->getFirstChild()->getOpCode().isStoreIndirect() &&\n-               node->getFirstChild()->getReferenceCount() > 1)\n-            {\n-            node->getFirstChild()->decReferenceCount();\n-            fixRefCount = true;\n-            }\n-         cg->evaluate(node->getFirstChild());\n-         if (fixRefCount)\n-            node->getFirstChild()->incReferenceCount();\n-         }\n-      else\n-         cg->evaluate(firstChild);\n+      cg->evaluate(firstChild);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3OTA5MQ==", "bodyText": "In fact I believe x86 has a bug here, or at the very least we are missing opportunities. Because we modify the value of firstChild the computation on line 1684:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/x/codegen/J9TreeEvaluator.cpp#L1659-L1713\nthis subsequent line:\nhttps://github.com/eclipse/openj9/blob/137829daa49943b5129f54bdac8aa5754b2e3186/runtime/compiler/x/codegen/J9TreeEvaluator.cpp#L1690\nMeans that all the subsequent if and else if checks will fail! This is because opcode is an indirect load IL, and all the checks are checking for something else, for example:\n   if (opCode.isLoadVar() || (comp->target().is64Bit() && opCode.getOpCodeValue()==TR::l2i))\n...\n   else if (opCode.isStore())\n...\n   else if (opCode.isCall()     &&\n            opCode.isIndirect() &&\n            cg->getNumberBytesReadInaccessible() > TR::Compiler->om.offsetOfObjectVftField())\n...\n   else if (opCode.getOpCodeValue() == TR::monent ||\n            opCode.getOpCodeValue() == TR::monexit)\n...\n   else if (!disableBranchlessPassThroughNULLCHK && opCode.getOpCodeValue () == TR::PassThrough\n            && !needResolution && cg->getHasResumableTrapHandler())\n...\n\nAll of these checks will fail. Surely this is a bug right?", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#discussion_r552979091", "createdAt": "2021-01-06T21:52:41Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2001,25 +2001,7 @@ TR::Register *J9::X86::TreeEvaluator::evaluateNULLCHKWithPossibleResolve(\n    //\n    if (needLateEvaluation)\n       {\n-      if (comp->useCompressedPointers())\n-         {\n-         // for stores under NULLCHKs, artificially bump\n-         // down the reference count before evaluation (since stores\n-         // return null as registers)\n-         //\n-         bool fixRefCount = false;\n-         if (node->getFirstChild()->getOpCode().isStoreIndirect() &&\n-               node->getFirstChild()->getReferenceCount() > 1)\n-            {\n-            node->getFirstChild()->decReferenceCount();\n-            fixRefCount = true;\n-            }\n-         cg->evaluate(node->getFirstChild());\n-         if (fixRefCount)\n-            node->getFirstChild()->incReferenceCount();\n-         }\n-      else\n-         cg->evaluate(firstChild);\n+      cg->evaluate(firstChild);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjEyNA=="}, "originalCommit": {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3OTg3MQ==", "bodyText": "@0xdaryl I think this may be outside the scope of this PR to fix because the above code has been dead for quite a while. I'm not sure what will happen if we suddenly start running all that code. Let me know what you think on how we should proceed here. The way I see it we have a few options:\n\nLeave the code as is for now and open up an issue\nTry enabling the code and see if any tests fail\nWait until we can common up this evaluator as much of it can be shared across platforms and fix it then\n???\n\nNote to fix the failures observed in this PR is a trivial fix as noted in the first comment in this chain. I'll definitely be making that change. The question here is what to do about reusing firstChild and updating it incorrectly thus making a bunch of subsequent code effectively dead.", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#discussion_r552979871", "createdAt": "2021-01-06T21:54:36Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -2001,25 +2001,7 @@ TR::Register *J9::X86::TreeEvaluator::evaluateNULLCHKWithPossibleResolve(\n    //\n    if (needLateEvaluation)\n       {\n-      if (comp->useCompressedPointers())\n-         {\n-         // for stores under NULLCHKs, artificially bump\n-         // down the reference count before evaluation (since stores\n-         // return null as registers)\n-         //\n-         bool fixRefCount = false;\n-         if (node->getFirstChild()->getOpCode().isStoreIndirect() &&\n-               node->getFirstChild()->getReferenceCount() > 1)\n-            {\n-            node->getFirstChild()->decReferenceCount();\n-            fixRefCount = true;\n-            }\n-         cg->evaluate(node->getFirstChild());\n-         if (fixRefCount)\n-            node->getFirstChild()->incReferenceCount();\n-         }\n-      else\n-         cg->evaluate(firstChild);\n+      cg->evaluate(firstChild);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjEyNA=="}, "originalCommit": {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792"}, "originalPosition": 23}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "602e95240bd6a245c0e2ff0c95dd61918cd11792", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/602e95240bd6a245c0e2ff0c95dd61918cd11792", "committedDate": "2020-12-15T17:18:33Z", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}, "afterCommit": {"oid": "04ed11240e095e5f6ab2a67d1be2681d08a40137", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/04ed11240e095e5f6ab2a67d1be2681d08a40137", "committedDate": "2021-01-20T21:05:56Z", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6467f5b8abd7b2cee03a847d7d85e2028a97febe", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/6467f5b8abd7b2cee03a847d7d85e2028a97febe", "committedDate": "2021-01-28T15:09:19Z", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "04ed11240e095e5f6ab2a67d1be2681d08a40137", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/04ed11240e095e5f6ab2a67d1be2681d08a40137", "committedDate": "2021-01-20T21:05:56Z", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}, "afterCommit": {"oid": "6467f5b8abd7b2cee03a847d7d85e2028a97febe", "author": {"user": {"login": "fjeremic", "name": "Filip Jeremic"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/6467f5b8abd7b2cee03a847d7d85e2028a97febe", "committedDate": "2021-01-28T15:09:19Z", "message": "Remove unneeded code in NULLCHKEvaluator\n\nThere is code which decrements and increments node counts for stores and\nloads which is unnecessary. In the case of stores, the IL trees do not\nproduce a value so decrementing and then incrementing the node does\nnothing at all. The comment seemingly implies that the result may return\nNULL (presumably from the evaluators) however such a value is never\nconsumed so it should not matter.\n\nIn the case of loads we seem to be trying to avoid a evaluating a load\nwith exactly one unevaluated reference underneath a NULLCHK which will\nnever happen because such IL will have been purged from the method\nduring simplification passes at the optimizer level.\n\nWith all this, there is no need to replicate such logic across all the\nplatforms, and we simply delete the code.\n\nSigned-off-by: Filip Jeremic <fjeremic@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTM4OTE5", "url": "https://github.com/eclipse-openj9/openj9/pull/11393#pullrequestreview-578538919", "createdAt": "2021-01-28T16:52:09Z", "commit": {"oid": "6467f5b8abd7b2cee03a847d7d85e2028a97febe"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1466, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}