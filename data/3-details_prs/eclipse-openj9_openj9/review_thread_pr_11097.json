{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1MDEwNzY2", "number": 11097, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDo0NToyNFrOE1ZBJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNDoyMDowMVrOE2yZpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE5ODc2OnYy", "diffSide": "RIGHT", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDo0NToyNFrOHtpEZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwMTozMDozNlrOHuc9CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMDgzOQ==", "bodyText": "fields is not used in testUnresolvedValueTypeDefaultValue, why is it passed in?", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r517620839", "createdAt": "2020-11-04T20:45:24Z", "author": {"login": "a7ehuo"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "diffHunk": "@@ -380,6 +398,101 @@ private static void testCheckCastRefClassOnNull(ClassWriter cw, String className\n \t\tmv.visitEnd();\n \t}\n \n+\tprivate static void testUnresolvedValueTypeDefaultValue(ClassWriter cw, String className, String valueUsedInCode, String[] fields) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9520d8c1eea80c7442e0d1741e833718ee72c9ac"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY1MDU3Nw==", "bodyText": "Almost all of the test methods have a fields argument, even though most of them don't use it, so I just followed suit.  I would be happy to drop the fieldsargument in this case.", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r517650577", "createdAt": "2020-11-04T21:48:24Z", "author": {"login": "hzongaro"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "diffHunk": "@@ -380,6 +398,101 @@ private static void testCheckCastRefClassOnNull(ClassWriter cw, String className\n \t\tmv.visitEnd();\n \t}\n \n+\tprivate static void testUnresolvedValueTypeDefaultValue(ClassWriter cw, String className, String valueUsedInCode, String[] fields) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMDgzOQ=="}, "originalCommit": {"oid": "9520d8c1eea80c7442e0d1741e833718ee72c9ac"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM1MzI0NA==", "bodyText": "Agreed, no need to add field params if they are not being used. This was probably an oversight in the other tests.", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r518353244", "createdAt": "2020-11-05T20:44:47Z", "author": {"login": "tajila"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "diffHunk": "@@ -380,6 +398,101 @@ private static void testCheckCastRefClassOnNull(ClassWriter cw, String className\n \t\tmv.visitEnd();\n \t}\n \n+\tprivate static void testUnresolvedValueTypeDefaultValue(ClassWriter cw, String className, String valueUsedInCode, String[] fields) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMDgzOQ=="}, "originalCommit": {"oid": "9520d8c1eea80c7442e0d1741e833718ee72c9ac"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ3MDkyMQ==", "bodyText": "Removed the fields argument in commit 20e8e8a.", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r518470921", "createdAt": "2020-11-06T01:30:36Z", "author": {"login": "hzongaro"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "diffHunk": "@@ -380,6 +398,101 @@ private static void testCheckCastRefClassOnNull(ClassWriter cw, String className\n \t\tmv.visitEnd();\n \t}\n \n+\tprivate static void testUnresolvedValueTypeDefaultValue(ClassWriter cw, String className, String valueUsedInCode, String[] fields) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMDgzOQ=="}, "originalCommit": {"oid": "9520d8c1eea80c7442e0d1741e833718ee72c9ac"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDIyMjA0OnYy", "diffSide": "RIGHT", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDo1MjozOFrOHtpSoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjowNzoyOFrOHu0F9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNDQ4MA==", "bodyText": "Why does passing -1 avoid the execution of GETFIELD?", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r517624480", "createdAt": "2020-11-04T20:52:38Z", "author": {"login": "a7ehuo"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -2460,6 +2460,201 @@ static public void testFlattenedFieldInitSequence() throws Throwable {\n \t\tassertNotNull(getB.invoke(getD.invoke(containerC)));\n \t}\n \t\n+\t/*\n+\t * Test use of DEFAULTVALUE for a value type class that has not been resolved.\n+\t * The method is first called so that the DEFAULTVALUE will not be executed,\n+\t * and the class not resolved, and then called so that the DEFAULTVALUE\n+\t * and class resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedDefaultValueUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedA\", fields);\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateRefClass(\"UsingUnresolvedA\", fields2, \"UnresolvedA\");\n+\n+\t\tMethodHandle defaultValueUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeDefaultValue\", MethodType.methodType(Object.class, int.class));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tassertNull(defaultValueUnresolved.invoke(0));\n+\t\t}\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tObject defaultValue = defaultValueUnresolved.invoke(1);\n+\t\t\tassertNotNull(defaultValue);\n+\t\t\tassertEquals(getX.invoke(defaultValue), Integer.valueOf(0));\n+\t\t\tassertEquals(getY.invoke(defaultValue), Integer.valueOf(0));\n+\t\t}\n+\t}\n+\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedWithFieldUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedD\", fields, \"HostD\");\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateHostRefClass(\"UsingUnresolvedD\", fields2, \"UnresolvedD\", fields);\n+\n+\t\tMethodHandle withFieldUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeWithField\", MethodType.methodType(Object.class, new Class[] {int.class, Object.class}));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of WITHFIELD and resolution of value type class\n+\t\t\tassertNull(withFieldUnresolved.invoke(0, null));\n+\t\t}\n+\n+\t\tMethodHandle makeDefaultValue = lookup.findStatic(valueClass, \"makeValueTypeDefaultValue\", MethodType.methodType(Object.class));\n+\t\tObject defaultValue = makeDefaultValue.invoke();\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of WITHFIELD and resolution of value type class\n+\t\t\tObject withFieldValue = (withFieldUnresolved.invoke(1, defaultValue));\n+\t\t\tassertEquals(getX.invoke(withFieldValue), Integer.valueOf(1));\n+\t\t\tassertEquals(getY.invoke(withFieldValue), Integer.valueOf(2));\n+\t\t}\n+\t}\n+\n+\tprivate static class UnresolvedClassDesc {\n+\t\tpublic String name;\n+\t\tpublic String[] fields;\n+\t\tpublic UnresolvedClassDesc(String name, String[] fields) {\n+\t\t\tthis.name = name;\n+\t\t\tthis.fields = fields;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Test use of GETFIELD operations on the fields of a container class, where\n+\t * the fields are of value type classes that have not been resolved.\n+\t *\n+\t * The method is first called so that the GETFIELD will not be executed, and\n+\t * the class not resolved, and then called so that the GETFIELD and class\n+\t * resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedGetFieldUse() throws Throwable {\n+\t\tUnresolvedClassDesc[] uclassDescArr = new UnresolvedClassDesc[] {\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB1\", new String[] {\"a:I\", \"b:I\"}),\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB2\", new String[] {\"c:I\", \"d:I\"}),\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB3\", new String[] {\"e:I\", \"f:I\"})};\n+\n+\t\tClass[] valueClassArr = new Class[uclassDescArr.length];\n+\t\tString containerFields[] = new String[uclassDescArr.length];\n+\t\tMethodHandle[][] valueFieldGetters = new MethodHandle[uclassDescArr.length][];\n+\n+\t\tfor (int i = 0; i < uclassDescArr.length; i++) {\n+\t\t\tUnresolvedClassDesc desc = uclassDescArr[i];\n+\t\t\tvalueClassArr[i] = ValueTypeGenerator.generateValueClass(desc.name, desc.fields);\n+\t\t\tvalueFieldGetters[i] = new MethodHandle[desc.fields.length];\n+\t\t\tcontainerFields[i] = \"v\"+(i+1)+\":Q\"+desc.name+\";\";\n+\n+\t\t\tfor (int j = 0; j < desc.fields.length; j++) {\n+\t\t\t\tString[] nameAndSig = desc.fields[j].split(\":\");\n+\t\t\t\tvalueFieldGetters[i][j] = generateGenericGetter(valueClassArr[i], nameAndSig[0]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tClass containerClass = ValueTypeGenerator.generateRefClass(\"ContainerForUnresolvedB\", containerFields);\n+\n+\t\tString fieldsUsing[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateRefClass(\"UsingUnresolvedB\", fieldsUsing, \"ContainerForUnresolvedB\", containerFields);\n+\n+\t\tMethodHandle getFieldUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeGetField\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMethodType.methodType(Object.class, new Class[] {int.class, containerClass}));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass -1 to avoid execution of GETFIELD against field that has a value type class\n+\t\t\t// In turn that delays the resolution of the value type class\n+\t\t\tassertNull(getFieldUnresolved.invoke(-1, null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9520d8c1eea80c7442e0d1741e833718ee72c9ac"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY1MzM0MQ==", "bodyText": "The code in the ValueTypeGenerator.testUnresolvedValueTypeGetField method that generates this test uses a TABLESWITCH instruction with values in the range [0..fieldWatch-1] to decide which field to retrieve.  -1 goes to the default case, which returns null.\nI'll clarify this comment, and a similar comment in the test for PUTFIELD.", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r517653341", "createdAt": "2020-11-04T21:54:10Z", "author": {"login": "hzongaro"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -2460,6 +2460,201 @@ static public void testFlattenedFieldInitSequence() throws Throwable {\n \t\tassertNotNull(getB.invoke(getD.invoke(containerC)));\n \t}\n \t\n+\t/*\n+\t * Test use of DEFAULTVALUE for a value type class that has not been resolved.\n+\t * The method is first called so that the DEFAULTVALUE will not be executed,\n+\t * and the class not resolved, and then called so that the DEFAULTVALUE\n+\t * and class resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedDefaultValueUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedA\", fields);\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateRefClass(\"UsingUnresolvedA\", fields2, \"UnresolvedA\");\n+\n+\t\tMethodHandle defaultValueUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeDefaultValue\", MethodType.methodType(Object.class, int.class));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tassertNull(defaultValueUnresolved.invoke(0));\n+\t\t}\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tObject defaultValue = defaultValueUnresolved.invoke(1);\n+\t\t\tassertNotNull(defaultValue);\n+\t\t\tassertEquals(getX.invoke(defaultValue), Integer.valueOf(0));\n+\t\t\tassertEquals(getY.invoke(defaultValue), Integer.valueOf(0));\n+\t\t}\n+\t}\n+\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedWithFieldUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedD\", fields, \"HostD\");\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateHostRefClass(\"UsingUnresolvedD\", fields2, \"UnresolvedD\", fields);\n+\n+\t\tMethodHandle withFieldUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeWithField\", MethodType.methodType(Object.class, new Class[] {int.class, Object.class}));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of WITHFIELD and resolution of value type class\n+\t\t\tassertNull(withFieldUnresolved.invoke(0, null));\n+\t\t}\n+\n+\t\tMethodHandle makeDefaultValue = lookup.findStatic(valueClass, \"makeValueTypeDefaultValue\", MethodType.methodType(Object.class));\n+\t\tObject defaultValue = makeDefaultValue.invoke();\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of WITHFIELD and resolution of value type class\n+\t\t\tObject withFieldValue = (withFieldUnresolved.invoke(1, defaultValue));\n+\t\t\tassertEquals(getX.invoke(withFieldValue), Integer.valueOf(1));\n+\t\t\tassertEquals(getY.invoke(withFieldValue), Integer.valueOf(2));\n+\t\t}\n+\t}\n+\n+\tprivate static class UnresolvedClassDesc {\n+\t\tpublic String name;\n+\t\tpublic String[] fields;\n+\t\tpublic UnresolvedClassDesc(String name, String[] fields) {\n+\t\t\tthis.name = name;\n+\t\t\tthis.fields = fields;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Test use of GETFIELD operations on the fields of a container class, where\n+\t * the fields are of value type classes that have not been resolved.\n+\t *\n+\t * The method is first called so that the GETFIELD will not be executed, and\n+\t * the class not resolved, and then called so that the GETFIELD and class\n+\t * resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedGetFieldUse() throws Throwable {\n+\t\tUnresolvedClassDesc[] uclassDescArr = new UnresolvedClassDesc[] {\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB1\", new String[] {\"a:I\", \"b:I\"}),\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB2\", new String[] {\"c:I\", \"d:I\"}),\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB3\", new String[] {\"e:I\", \"f:I\"})};\n+\n+\t\tClass[] valueClassArr = new Class[uclassDescArr.length];\n+\t\tString containerFields[] = new String[uclassDescArr.length];\n+\t\tMethodHandle[][] valueFieldGetters = new MethodHandle[uclassDescArr.length][];\n+\n+\t\tfor (int i = 0; i < uclassDescArr.length; i++) {\n+\t\t\tUnresolvedClassDesc desc = uclassDescArr[i];\n+\t\t\tvalueClassArr[i] = ValueTypeGenerator.generateValueClass(desc.name, desc.fields);\n+\t\t\tvalueFieldGetters[i] = new MethodHandle[desc.fields.length];\n+\t\t\tcontainerFields[i] = \"v\"+(i+1)+\":Q\"+desc.name+\";\";\n+\n+\t\t\tfor (int j = 0; j < desc.fields.length; j++) {\n+\t\t\t\tString[] nameAndSig = desc.fields[j].split(\":\");\n+\t\t\t\tvalueFieldGetters[i][j] = generateGenericGetter(valueClassArr[i], nameAndSig[0]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tClass containerClass = ValueTypeGenerator.generateRefClass(\"ContainerForUnresolvedB\", containerFields);\n+\n+\t\tString fieldsUsing[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateRefClass(\"UsingUnresolvedB\", fieldsUsing, \"ContainerForUnresolvedB\", containerFields);\n+\n+\t\tMethodHandle getFieldUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeGetField\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMethodType.methodType(Object.class, new Class[] {int.class, containerClass}));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass -1 to avoid execution of GETFIELD against field that has a value type class\n+\t\t\t// In turn that delays the resolution of the value type class\n+\t\t\tassertNull(getFieldUnresolved.invoke(-1, null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNDQ4MA=="}, "originalCommit": {"oid": "9520d8c1eea80c7442e0d1741e833718ee72c9ac"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ3MDcwNQ==", "bodyText": "Annabelle @a7ehuo, I have addressed this in commit 20e8e8a.  May I ask you to have a look?", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r518470705", "createdAt": "2020-11-06T01:29:59Z", "author": {"login": "hzongaro"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -2460,6 +2460,201 @@ static public void testFlattenedFieldInitSequence() throws Throwable {\n \t\tassertNotNull(getB.invoke(getD.invoke(containerC)));\n \t}\n \t\n+\t/*\n+\t * Test use of DEFAULTVALUE for a value type class that has not been resolved.\n+\t * The method is first called so that the DEFAULTVALUE will not be executed,\n+\t * and the class not resolved, and then called so that the DEFAULTVALUE\n+\t * and class resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedDefaultValueUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedA\", fields);\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateRefClass(\"UsingUnresolvedA\", fields2, \"UnresolvedA\");\n+\n+\t\tMethodHandle defaultValueUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeDefaultValue\", MethodType.methodType(Object.class, int.class));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tassertNull(defaultValueUnresolved.invoke(0));\n+\t\t}\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tObject defaultValue = defaultValueUnresolved.invoke(1);\n+\t\t\tassertNotNull(defaultValue);\n+\t\t\tassertEquals(getX.invoke(defaultValue), Integer.valueOf(0));\n+\t\t\tassertEquals(getY.invoke(defaultValue), Integer.valueOf(0));\n+\t\t}\n+\t}\n+\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedWithFieldUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedD\", fields, \"HostD\");\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateHostRefClass(\"UsingUnresolvedD\", fields2, \"UnresolvedD\", fields);\n+\n+\t\tMethodHandle withFieldUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeWithField\", MethodType.methodType(Object.class, new Class[] {int.class, Object.class}));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of WITHFIELD and resolution of value type class\n+\t\t\tassertNull(withFieldUnresolved.invoke(0, null));\n+\t\t}\n+\n+\t\tMethodHandle makeDefaultValue = lookup.findStatic(valueClass, \"makeValueTypeDefaultValue\", MethodType.methodType(Object.class));\n+\t\tObject defaultValue = makeDefaultValue.invoke();\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of WITHFIELD and resolution of value type class\n+\t\t\tObject withFieldValue = (withFieldUnresolved.invoke(1, defaultValue));\n+\t\t\tassertEquals(getX.invoke(withFieldValue), Integer.valueOf(1));\n+\t\t\tassertEquals(getY.invoke(withFieldValue), Integer.valueOf(2));\n+\t\t}\n+\t}\n+\n+\tprivate static class UnresolvedClassDesc {\n+\t\tpublic String name;\n+\t\tpublic String[] fields;\n+\t\tpublic UnresolvedClassDesc(String name, String[] fields) {\n+\t\t\tthis.name = name;\n+\t\t\tthis.fields = fields;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Test use of GETFIELD operations on the fields of a container class, where\n+\t * the fields are of value type classes that have not been resolved.\n+\t *\n+\t * The method is first called so that the GETFIELD will not be executed, and\n+\t * the class not resolved, and then called so that the GETFIELD and class\n+\t * resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedGetFieldUse() throws Throwable {\n+\t\tUnresolvedClassDesc[] uclassDescArr = new UnresolvedClassDesc[] {\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB1\", new String[] {\"a:I\", \"b:I\"}),\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB2\", new String[] {\"c:I\", \"d:I\"}),\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB3\", new String[] {\"e:I\", \"f:I\"})};\n+\n+\t\tClass[] valueClassArr = new Class[uclassDescArr.length];\n+\t\tString containerFields[] = new String[uclassDescArr.length];\n+\t\tMethodHandle[][] valueFieldGetters = new MethodHandle[uclassDescArr.length][];\n+\n+\t\tfor (int i = 0; i < uclassDescArr.length; i++) {\n+\t\t\tUnresolvedClassDesc desc = uclassDescArr[i];\n+\t\t\tvalueClassArr[i] = ValueTypeGenerator.generateValueClass(desc.name, desc.fields);\n+\t\t\tvalueFieldGetters[i] = new MethodHandle[desc.fields.length];\n+\t\t\tcontainerFields[i] = \"v\"+(i+1)+\":Q\"+desc.name+\";\";\n+\n+\t\t\tfor (int j = 0; j < desc.fields.length; j++) {\n+\t\t\t\tString[] nameAndSig = desc.fields[j].split(\":\");\n+\t\t\t\tvalueFieldGetters[i][j] = generateGenericGetter(valueClassArr[i], nameAndSig[0]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tClass containerClass = ValueTypeGenerator.generateRefClass(\"ContainerForUnresolvedB\", containerFields);\n+\n+\t\tString fieldsUsing[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateRefClass(\"UsingUnresolvedB\", fieldsUsing, \"ContainerForUnresolvedB\", containerFields);\n+\n+\t\tMethodHandle getFieldUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeGetField\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMethodType.methodType(Object.class, new Class[] {int.class, containerClass}));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass -1 to avoid execution of GETFIELD against field that has a value type class\n+\t\t\t// In turn that delays the resolution of the value type class\n+\t\t\tassertNull(getFieldUnresolved.invoke(-1, null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNDQ4MA=="}, "originalCommit": {"oid": "9520d8c1eea80c7442e0d1741e833718ee72c9ac"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1MDAzOA==", "bodyText": "LGTM. Thanks for adding the sample code.", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r518850038", "createdAt": "2020-11-06T16:07:28Z", "author": {"login": "a7ehuo"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -2460,6 +2460,201 @@ static public void testFlattenedFieldInitSequence() throws Throwable {\n \t\tassertNotNull(getB.invoke(getD.invoke(containerC)));\n \t}\n \t\n+\t/*\n+\t * Test use of DEFAULTVALUE for a value type class that has not been resolved.\n+\t * The method is first called so that the DEFAULTVALUE will not be executed,\n+\t * and the class not resolved, and then called so that the DEFAULTVALUE\n+\t * and class resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedDefaultValueUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedA\", fields);\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateRefClass(\"UsingUnresolvedA\", fields2, \"UnresolvedA\");\n+\n+\t\tMethodHandle defaultValueUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeDefaultValue\", MethodType.methodType(Object.class, int.class));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tassertNull(defaultValueUnresolved.invoke(0));\n+\t\t}\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tObject defaultValue = defaultValueUnresolved.invoke(1);\n+\t\t\tassertNotNull(defaultValue);\n+\t\t\tassertEquals(getX.invoke(defaultValue), Integer.valueOf(0));\n+\t\t\tassertEquals(getY.invoke(defaultValue), Integer.valueOf(0));\n+\t\t}\n+\t}\n+\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedWithFieldUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedD\", fields, \"HostD\");\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateHostRefClass(\"UsingUnresolvedD\", fields2, \"UnresolvedD\", fields);\n+\n+\t\tMethodHandle withFieldUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeWithField\", MethodType.methodType(Object.class, new Class[] {int.class, Object.class}));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of WITHFIELD and resolution of value type class\n+\t\t\tassertNull(withFieldUnresolved.invoke(0, null));\n+\t\t}\n+\n+\t\tMethodHandle makeDefaultValue = lookup.findStatic(valueClass, \"makeValueTypeDefaultValue\", MethodType.methodType(Object.class));\n+\t\tObject defaultValue = makeDefaultValue.invoke();\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of WITHFIELD and resolution of value type class\n+\t\t\tObject withFieldValue = (withFieldUnresolved.invoke(1, defaultValue));\n+\t\t\tassertEquals(getX.invoke(withFieldValue), Integer.valueOf(1));\n+\t\t\tassertEquals(getY.invoke(withFieldValue), Integer.valueOf(2));\n+\t\t}\n+\t}\n+\n+\tprivate static class UnresolvedClassDesc {\n+\t\tpublic String name;\n+\t\tpublic String[] fields;\n+\t\tpublic UnresolvedClassDesc(String name, String[] fields) {\n+\t\t\tthis.name = name;\n+\t\t\tthis.fields = fields;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Test use of GETFIELD operations on the fields of a container class, where\n+\t * the fields are of value type classes that have not been resolved.\n+\t *\n+\t * The method is first called so that the GETFIELD will not be executed, and\n+\t * the class not resolved, and then called so that the GETFIELD and class\n+\t * resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedGetFieldUse() throws Throwable {\n+\t\tUnresolvedClassDesc[] uclassDescArr = new UnresolvedClassDesc[] {\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB1\", new String[] {\"a:I\", \"b:I\"}),\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB2\", new String[] {\"c:I\", \"d:I\"}),\n+\t\t\t\t\t\t\t\tnew UnresolvedClassDesc(\"UnresolvedB3\", new String[] {\"e:I\", \"f:I\"})};\n+\n+\t\tClass[] valueClassArr = new Class[uclassDescArr.length];\n+\t\tString containerFields[] = new String[uclassDescArr.length];\n+\t\tMethodHandle[][] valueFieldGetters = new MethodHandle[uclassDescArr.length][];\n+\n+\t\tfor (int i = 0; i < uclassDescArr.length; i++) {\n+\t\t\tUnresolvedClassDesc desc = uclassDescArr[i];\n+\t\t\tvalueClassArr[i] = ValueTypeGenerator.generateValueClass(desc.name, desc.fields);\n+\t\t\tvalueFieldGetters[i] = new MethodHandle[desc.fields.length];\n+\t\t\tcontainerFields[i] = \"v\"+(i+1)+\":Q\"+desc.name+\";\";\n+\n+\t\t\tfor (int j = 0; j < desc.fields.length; j++) {\n+\t\t\t\tString[] nameAndSig = desc.fields[j].split(\":\");\n+\t\t\t\tvalueFieldGetters[i][j] = generateGenericGetter(valueClassArr[i], nameAndSig[0]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tClass containerClass = ValueTypeGenerator.generateRefClass(\"ContainerForUnresolvedB\", containerFields);\n+\n+\t\tString fieldsUsing[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateRefClass(\"UsingUnresolvedB\", fieldsUsing, \"ContainerForUnresolvedB\", containerFields);\n+\n+\t\tMethodHandle getFieldUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeGetField\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMethodType.methodType(Object.class, new Class[] {int.class, containerClass}));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass -1 to avoid execution of GETFIELD against field that has a value type class\n+\t\t\t// In turn that delays the resolution of the value type class\n+\t\t\tassertNull(getFieldUnresolved.invoke(-1, null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyNDQ4MA=="}, "originalCommit": {"oid": "9520d8c1eea80c7442e0d1741e833718ee72c9ac"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDI0NDkwOnYy", "diffSide": "RIGHT", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDo1OTo0M1rOHtpgsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwMToyOTo0OVrOHuc79A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyODA4MQ==", "bodyText": "Would adding some java example code on how UnresolvedB* , ContainerForUnresolvedB, UsingUnresolvedB, and getters are defined and used help people follow the test better? Same question on testUnresolvedPutFieldUse.", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r517628081", "createdAt": "2020-11-04T20:59:43Z", "author": {"login": "a7ehuo"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -2460,6 +2460,201 @@ static public void testFlattenedFieldInitSequence() throws Throwable {\n \t\tassertNotNull(getB.invoke(getD.invoke(containerC)));\n \t}\n \t\n+\t/*\n+\t * Test use of DEFAULTVALUE for a value type class that has not been resolved.\n+\t * The method is first called so that the DEFAULTVALUE will not be executed,\n+\t * and the class not resolved, and then called so that the DEFAULTVALUE\n+\t * and class resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedDefaultValueUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedA\", fields);\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateRefClass(\"UsingUnresolvedA\", fields2, \"UnresolvedA\");\n+\n+\t\tMethodHandle defaultValueUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeDefaultValue\", MethodType.methodType(Object.class, int.class));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tassertNull(defaultValueUnresolved.invoke(0));\n+\t\t}\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tObject defaultValue = defaultValueUnresolved.invoke(1);\n+\t\t\tassertNotNull(defaultValue);\n+\t\t\tassertEquals(getX.invoke(defaultValue), Integer.valueOf(0));\n+\t\t\tassertEquals(getY.invoke(defaultValue), Integer.valueOf(0));\n+\t\t}\n+\t}\n+\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedWithFieldUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedD\", fields, \"HostD\");\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateHostRefClass(\"UsingUnresolvedD\", fields2, \"UnresolvedD\", fields);\n+\n+\t\tMethodHandle withFieldUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeWithField\", MethodType.methodType(Object.class, new Class[] {int.class, Object.class}));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of WITHFIELD and resolution of value type class\n+\t\t\tassertNull(withFieldUnresolved.invoke(0, null));\n+\t\t}\n+\n+\t\tMethodHandle makeDefaultValue = lookup.findStatic(valueClass, \"makeValueTypeDefaultValue\", MethodType.methodType(Object.class));\n+\t\tObject defaultValue = makeDefaultValue.invoke();\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of WITHFIELD and resolution of value type class\n+\t\t\tObject withFieldValue = (withFieldUnresolved.invoke(1, defaultValue));\n+\t\t\tassertEquals(getX.invoke(withFieldValue), Integer.valueOf(1));\n+\t\t\tassertEquals(getY.invoke(withFieldValue), Integer.valueOf(2));\n+\t\t}\n+\t}\n+\n+\tprivate static class UnresolvedClassDesc {\n+\t\tpublic String name;\n+\t\tpublic String[] fields;\n+\t\tpublic UnresolvedClassDesc(String name, String[] fields) {\n+\t\t\tthis.name = name;\n+\t\t\tthis.fields = fields;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Test use of GETFIELD operations on the fields of a container class, where\n+\t * the fields are of value type classes that have not been resolved.\n+\t *\n+\t * The method is first called so that the GETFIELD will not be executed, and\n+\t * the class not resolved, and then called so that the GETFIELD and class\n+\t * resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedGetFieldUse() throws Throwable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9520d8c1eea80c7442e0d1741e833718ee72c9ac"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY1MzMyOA==", "bodyText": "Yes, definitely.  I'll do that.", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r517653328", "createdAt": "2020-11-04T21:54:08Z", "author": {"login": "hzongaro"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -2460,6 +2460,201 @@ static public void testFlattenedFieldInitSequence() throws Throwable {\n \t\tassertNotNull(getB.invoke(getD.invoke(containerC)));\n \t}\n \t\n+\t/*\n+\t * Test use of DEFAULTVALUE for a value type class that has not been resolved.\n+\t * The method is first called so that the DEFAULTVALUE will not be executed,\n+\t * and the class not resolved, and then called so that the DEFAULTVALUE\n+\t * and class resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedDefaultValueUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedA\", fields);\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateRefClass(\"UsingUnresolvedA\", fields2, \"UnresolvedA\");\n+\n+\t\tMethodHandle defaultValueUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeDefaultValue\", MethodType.methodType(Object.class, int.class));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tassertNull(defaultValueUnresolved.invoke(0));\n+\t\t}\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tObject defaultValue = defaultValueUnresolved.invoke(1);\n+\t\t\tassertNotNull(defaultValue);\n+\t\t\tassertEquals(getX.invoke(defaultValue), Integer.valueOf(0));\n+\t\t\tassertEquals(getY.invoke(defaultValue), Integer.valueOf(0));\n+\t\t}\n+\t}\n+\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedWithFieldUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedD\", fields, \"HostD\");\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateHostRefClass(\"UsingUnresolvedD\", fields2, \"UnresolvedD\", fields);\n+\n+\t\tMethodHandle withFieldUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeWithField\", MethodType.methodType(Object.class, new Class[] {int.class, Object.class}));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of WITHFIELD and resolution of value type class\n+\t\t\tassertNull(withFieldUnresolved.invoke(0, null));\n+\t\t}\n+\n+\t\tMethodHandle makeDefaultValue = lookup.findStatic(valueClass, \"makeValueTypeDefaultValue\", MethodType.methodType(Object.class));\n+\t\tObject defaultValue = makeDefaultValue.invoke();\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of WITHFIELD and resolution of value type class\n+\t\t\tObject withFieldValue = (withFieldUnresolved.invoke(1, defaultValue));\n+\t\t\tassertEquals(getX.invoke(withFieldValue), Integer.valueOf(1));\n+\t\t\tassertEquals(getY.invoke(withFieldValue), Integer.valueOf(2));\n+\t\t}\n+\t}\n+\n+\tprivate static class UnresolvedClassDesc {\n+\t\tpublic String name;\n+\t\tpublic String[] fields;\n+\t\tpublic UnresolvedClassDesc(String name, String[] fields) {\n+\t\t\tthis.name = name;\n+\t\t\tthis.fields = fields;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Test use of GETFIELD operations on the fields of a container class, where\n+\t * the fields are of value type classes that have not been resolved.\n+\t *\n+\t * The method is first called so that the GETFIELD will not be executed, and\n+\t * the class not resolved, and then called so that the GETFIELD and class\n+\t * resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedGetFieldUse() throws Throwable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyODA4MQ=="}, "originalCommit": {"oid": "9520d8c1eea80c7442e0d1741e833718ee72c9ac"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ3MDY0NA==", "bodyText": "Annabelle @a7ehuo, I have addressed this in commit 20e8e8a.  May I ask you to have a look?", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r518470644", "createdAt": "2020-11-06T01:29:49Z", "author": {"login": "hzongaro"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -2460,6 +2460,201 @@ static public void testFlattenedFieldInitSequence() throws Throwable {\n \t\tassertNotNull(getB.invoke(getD.invoke(containerC)));\n \t}\n \t\n+\t/*\n+\t * Test use of DEFAULTVALUE for a value type class that has not been resolved.\n+\t * The method is first called so that the DEFAULTVALUE will not be executed,\n+\t * and the class not resolved, and then called so that the DEFAULTVALUE\n+\t * and class resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedDefaultValueUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedA\", fields);\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateRefClass(\"UsingUnresolvedA\", fields2, \"UnresolvedA\");\n+\n+\t\tMethodHandle defaultValueUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeDefaultValue\", MethodType.methodType(Object.class, int.class));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tassertNull(defaultValueUnresolved.invoke(0));\n+\t\t}\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of DEFAULTVALUE and resolution of value type class\n+\t\t\tObject defaultValue = defaultValueUnresolved.invoke(1);\n+\t\t\tassertNotNull(defaultValue);\n+\t\t\tassertEquals(getX.invoke(defaultValue), Integer.valueOf(0));\n+\t\t\tassertEquals(getY.invoke(defaultValue), Integer.valueOf(0));\n+\t\t}\n+\t}\n+\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedWithFieldUse() throws Throwable {\n+\t\tString fields[] = {\"x:I\", \"y:I\"};\n+\t\tClass valueClass = ValueTypeGenerator.generateValueClass(\"UnresolvedD\", fields, \"HostD\");\n+\t\tString fields2[] = {};\n+\t\tClass usingClass = ValueTypeGenerator.generateHostRefClass(\"UsingUnresolvedD\", fields2, \"UnresolvedD\", fields);\n+\n+\t\tMethodHandle withFieldUnresolved = lookup.findStatic(usingClass, \"testUnresolvedValueTypeWithField\", MethodType.methodType(Object.class, new Class[] {int.class, Object.class}));\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass zero to avoid execution of WITHFIELD and resolution of value type class\n+\t\t\tassertNull(withFieldUnresolved.invoke(0, null));\n+\t\t}\n+\n+\t\tMethodHandle makeDefaultValue = lookup.findStatic(valueClass, \"makeValueTypeDefaultValue\", MethodType.methodType(Object.class));\n+\t\tObject defaultValue = makeDefaultValue.invoke();\n+\n+\t\tMethodHandle getX = generateGenericGetter(valueClass, \"x\");\n+\t\tMethodHandle getY = generateGenericGetter(valueClass, \"y\");\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\t// Pass one to force execution of WITHFIELD and resolution of value type class\n+\t\t\tObject withFieldValue = (withFieldUnresolved.invoke(1, defaultValue));\n+\t\t\tassertEquals(getX.invoke(withFieldValue), Integer.valueOf(1));\n+\t\t\tassertEquals(getY.invoke(withFieldValue), Integer.valueOf(2));\n+\t\t}\n+\t}\n+\n+\tprivate static class UnresolvedClassDesc {\n+\t\tpublic String name;\n+\t\tpublic String[] fields;\n+\t\tpublic UnresolvedClassDesc(String name, String[] fields) {\n+\t\t\tthis.name = name;\n+\t\t\tthis.fields = fields;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Test use of GETFIELD operations on the fields of a container class, where\n+\t * the fields are of value type classes that have not been resolved.\n+\t *\n+\t * The method is first called so that the GETFIELD will not be executed, and\n+\t * the class not resolved, and then called so that the GETFIELD and class\n+\t * resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedGetFieldUse() throws Throwable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyODA4MQ=="}, "originalCommit": {"oid": "9520d8c1eea80c7442e0d1741e833718ee72c9ac"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjIxMzg0OnYy", "diffSide": "LEFT", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjozMzo1MlrOHu1Fjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNToyNzo1MFrOHv0Frw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2NjMxOQ==", "bodyText": "instead of duplicating the body, this can  call generateValueClass(String name, String[] fields, String nestHost) with a null nest host", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r518866319", "createdAt": "2020-11-06T16:33:52Z", "author": {"login": "tajila"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "diffHunk": "@@ -921,17 +1117,64 @@ public static void generateClassFile(String name, byte[] bytes) {\n \t}\n \n \tpublic static Class<?> generateValueClass(String name, String[] fields) throws Throwable {\n-\t\tbyte[] bytes = generateClass(name, fields, false, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "981320df6d1cd23fadf8f599b1ccf01978362cdc"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5ODU0Mw==", "bodyText": "Addressed in commit fbba191", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r519898543", "createdAt": "2020-11-09T15:27:50Z", "author": {"login": "hzongaro"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "diffHunk": "@@ -921,17 +1117,64 @@ public static void generateClassFile(String name, byte[] bytes) {\n \t}\n \n \tpublic static Class<?> generateValueClass(String name, String[] fields) throws Throwable {\n-\t\tbyte[] bytes = generateClass(name, fields, false, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2NjMxOQ=="}, "originalCommit": {"oid": "981320df6d1cd23fadf8f599b1ccf01978362cdc"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjIyNjM5OnYy", "diffSide": "RIGHT", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjozNzoxNFrOHu1Njw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNToyODoyNlrOHv0HXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2ODM2Nw==", "bodyText": "can you add a comment describing what accessedContainer and valueClassUsedInCode are", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r518868367", "createdAt": "2020-11-06T16:37:14Z", "author": {"login": "tajila"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "diffHunk": "@@ -46,8 +46,91 @@\n \tstatic {\n \t\tgenerator = new ValueTypeGenerator();\n \t}\n-\t\n-\tprivate static byte[] generateClass(String className, String[] fields, boolean isVerifiable, boolean isRef) {\n+\n+\tprivate static class ClassConfiguration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "981320df6d1cd23fadf8f599b1ccf01978362cdc"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5ODk3Mg==", "bodyText": "Addressed in commit fbba191", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r519898972", "createdAt": "2020-11-09T15:28:26Z", "author": {"login": "hzongaro"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "diffHunk": "@@ -46,8 +46,91 @@\n \tstatic {\n \t\tgenerator = new ValueTypeGenerator();\n \t}\n-\t\n-\tprivate static byte[] generateClass(String className, String[] fields, boolean isVerifiable, boolean isRef) {\n+\n+\tprivate static class ClassConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2ODM2Nw=="}, "originalCommit": {"oid": "981320df6d1cd23fadf8f599b1ccf01978362cdc"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjIzMTk4OnYy", "diffSide": "RIGHT", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjozODo0MlrOHu1Q5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNToyODowNlrOHv0Gag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2OTIyMw==", "bodyText": "nitpick: please use the /* style comments", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r518869223", "createdAt": "2020-11-06T16:38:42Z", "author": {"login": "tajila"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -2460,6 +2460,322 @@ static public void testFlattenedFieldInitSequence() throws Throwable {\n \t\tassertNotNull(getB.invoke(getD.invoke(containerC)));\n \t}\n \t\n+\t/*\n+\t * Test use of DEFAULTVALUE for a value type class that has not been resolved.\n+\t * The method is first called so that the DEFAULTVALUE will not be executed,\n+\t * and the class not resolved, and then called so that the DEFAULTVALUE\n+\t * and class resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedDefaultValueUse() throws Throwable {\n+\t\t// Set up classes that look roughly like this:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "981320df6d1cd23fadf8f599b1ccf01978362cdc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5ODczMA==", "bodyText": "Addressed in commit fbba191", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r519898730", "createdAt": "2020-11-09T15:28:06Z", "author": {"login": "hzongaro"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -2460,6 +2460,322 @@ static public void testFlattenedFieldInitSequence() throws Throwable {\n \t\tassertNotNull(getB.invoke(getD.invoke(containerC)));\n \t}\n \t\n+\t/*\n+\t * Test use of DEFAULTVALUE for a value type class that has not been resolved.\n+\t * The method is first called so that the DEFAULTVALUE will not be executed,\n+\t * and the class not resolved, and then called so that the DEFAULTVALUE\n+\t * and class resolution is triggered.\n+\t */\n+\t@Test(priority=1)\n+\tstatic public void testUnresolvedDefaultValueUse() throws Throwable {\n+\t\t// Set up classes that look roughly like this:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2OTIyMw=="}, "originalCommit": {"oid": "981320df6d1cd23fadf8f599b1ccf01978362cdc"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1ODg0MzI3OnYy", "diffSide": "RIGHT", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNDoyMDowMVrOHvw_mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNToyODo0OVrOHv0IaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg0NzgzNA==", "bodyText": "This should be a call to visitNestMember.  I must have messed it up in the process of refactoring code.", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r519847834", "createdAt": "2020-11-09T14:20:01Z", "author": {"login": "hzongaro"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "diffHunk": "@@ -60,6 +143,14 @@\n \t\t}\n \n \t\tcw.visitSource(className + \".java\", null);\n+\n+\t\tif (nestHost != null) {\n+\t\t\tcw.visitNestHost(nestHost);\n+\t\t}\n+\n+\t\tif (valueUsedInCode != null) {\n+\t\t\tcw.visitNestHost(valueUsedInCode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "981320df6d1cd23fadf8f599b1ccf01978362cdc"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5OTI0MQ==", "bodyText": "Fixed in commit fbba191", "url": "https://github.com/eclipse-openj9/openj9/pull/11097#discussion_r519899241", "createdAt": "2020-11-09T15:28:49Z", "author": {"login": "hzongaro"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeGenerator.java", "diffHunk": "@@ -60,6 +143,14 @@\n \t\t}\n \n \t\tcw.visitSource(className + \".java\", null);\n+\n+\t\tif (nestHost != null) {\n+\t\t\tcw.visitNestHost(nestHost);\n+\t\t}\n+\n+\t\tif (valueUsedInCode != null) {\n+\t\t\tcw.visitNestHost(valueUsedInCode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg0NzgzNA=="}, "originalCommit": {"oid": "981320df6d1cd23fadf8f599b1ccf01978362cdc"}, "originalPosition": 104}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1089, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}