{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NDQwMTQ5", "number": 10245, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoyMjoxMFrOEV8S1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoyMjoxMFrOEV8S1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDQzNDEyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/j9methodServer.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoyMjoxMFrOG8_J0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODoyMjoxMFrOG8_J0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMjQ1MQ==", "bodyText": "Let's avoid the double call to getCachedResolvedMethod() when we found it the first time", "url": "https://github.com/eclipse-openj9/openj9/pull/10245#discussion_r466602451", "createdAt": "2020-08-06T18:22:10Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/j9methodServer.cpp", "diffHunk": "@@ -1954,37 +1954,64 @@ TR_ResolvedJ9JITServerMethod::cacheFields()\n       }\n    }\n \n-void\n-TR_ResolvedJ9JITServerMethod::cacheImplementorMethods(\n-   std::vector<TR_OpaqueClassBlock *> &subClasses,\n+int32_t\n+TR_ResolvedJ9JITServerMethod::collectImplementorsCapped(\n+   TR_OpaqueClassBlock *topClass,\n+   int32_t maxCount,\n    int32_t cpIndexOrOffset,\n-   bool isInterface,\n-   int32_t ttlForUnresolved)\n+   TR_YesNoMaybe useGetResolvedInterfaceMethod,\n+   TR_ResolvedMethod **implArray)\n    {\n-   auto compInfoPT = (TR::CompilationInfoPerThreadRemote *) _fe->_compInfoPT;\n-   int32_t numMethods = subClasses.size();\n-\n-   _stream->write(JITServer::MessageType::ResolvedMethod_getResolvedImplementorMethods, (TR_ResolvedJ9Method *) _remoteMirror, subClasses, cpIndexOrOffset, isInterface);\n-   auto recv = _stream->read<std::vector<J9Method *>, std::vector<TR_ResolvedJ9JITServerMethodInfo>>();\n+   auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(_fe->_compInfoPT);\n+   JITServer::ServerStream *stream = compInfoPT->getMethodBeingCompiled()->_stream;\n+   stream->write(\n+      JITServer::MessageType::ResolvedMethod_getResolvedImplementorMethods,\n+      topClass,\n+      maxCount,\n+      cpIndexOrOffset,\n+      _remoteMirror,\n+      useGetResolvedInterfaceMethod);\n+   auto recv = stream->read<std::vector<TR_ResolvedJ9JITServerMethodInfo>, std::vector<J9Method *>, int32_t>();\n+   auto &methodInfos = std::get<0>(recv);\n+   auto &ramMethods = std::get<1>(recv);\n+\n+   bool isInterface = TR::Compiler->cls.isInterfaceClass(compInfoPT->getCompilation(), topClass);\n+\n+   // refine if requested by a caller\n+   if (useGetResolvedInterfaceMethod != TR_maybe)\n+      isInterface = useGetResolvedInterfaceMethod == TR_yes ? true : false;\n+   for (int32_t i = 0; i < methodInfos.size(); ++i)\n+      {\n+      TR_ResolvedMethodType type = isInterface ?\n+         TR_ResolvedMethodType::Interface :\n+         TR_ResolvedMethodType::VirtualFromOffset;\n \n-   // Note: the number of received methods can be smaller\n-   // than the requsted number, because client will abort after\n-   // the first unresolved method.\n-   auto &ramMethods = std::get<0>(recv);\n-   auto &methodInfos = std::get<1>(recv);\n-   for (int32_t i = 0; i < ramMethods.size(); ++i)\n-      {\n-      TR_ResolvedMethodType type = isInterface ? TR_ResolvedMethodType::Interface : TR_ResolvedMethodType::VirtualFromOffset;\n       TR_ResolvedMethod *resolvedMethod;\n-      TR_ResolvedMethodKey key = compInfoPT->getResolvedMethodKey(type, (TR_OpaqueClassBlock *) _ramClass, cpIndexOrOffset, subClasses[i]);\n-      // Assume that we already checked that none of the methods have already been cached\n-      compInfoPT->cacheResolvedMethod(\n-         key,\n-         (TR_OpaqueMethodBlock *) ramMethods[i],\n-         0,\n-         methodInfos[i],\n-         ttlForUnresolved);\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(_ramClass),\n+            cpIndexOrOffset,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(std::get<0>(methodInfos[i]).ramClass));\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             this,\n+             &resolvedMethod))\n+         {\n+         compInfoPT->cacheResolvedMethod(\n+            key,\n+            (TR_OpaqueMethodBlock *) ramMethods[i],\n+            cpIndexOrOffset,\n+            methodInfos[i],\n+            0); // all received methods should be resolved\n+         }\n+\n+      bool success = compInfoPT->getCachedResolvedMethod(key, this, &resolvedMethod);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c323b92884c1e0874d020ad681247be14ab580"}, "originalPosition": 82}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4811, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}