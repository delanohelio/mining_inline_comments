{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyMDMxODE4", "number": 11507, "title": "Add extra U_64 data field to Indexable Object Headers", "bodyText": "Preliminary work to incorporate extra 64 bit field to Indexable object headers. In case of contiguous arraylets the extra field will hold the address of where the data starts, which is right after the header. In case of discontiguous arraylets the extra field will hold the address of:\n\nThe contiguous double mapped region (assuming double map is enabled).\nThe contiguous sparse-heap region outside the heap (assuming sparse heap is enabled).\nIf double mapping an sparse heap are both disabled, dataAddr will point to the address right adter the header, in this case to the first arrayoid.\n\nThis is the first phase concerning a series of deliverable. Here, we introduce the extra U_64 data field along with helper functions such as getters and setters that will be needed in the future. Now dataAddr is only introduced and never used. Once it\u2019s stable we\u2019ll deliver the second phase of changes that makes use of dataAddr. dataAddr is only available in 64 bit platforms.\nPlease refer to #11438 for more info. This set of changes concern part of the first action item of such issue.\nDepends on: #11320\nSigned-off-by: Igor Braga higorb1@gmail.com", "createdAt": "2020-12-17T17:58:10Z", "url": "https://github.com/eclipse-openj9/openj9/pull/11507", "merged": true, "mergeCommit": {"oid": "be9d1d0e47d3f5e8c99667c30ea1f6d0d04995e8"}, "closed": true, "closedAt": "2021-01-08T14:44:03Z", "author": {"login": "bragaigor"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdnHcjIAFqTU1NDg1NDIyMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdt0i84AFqTU2MzUwMzcxMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0ODU0MjIy", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-554854222", "createdAt": "2020-12-17T18:00:48Z", "commit": {"oid": "88db5cbaa77b9ce36907fc7d8ddf0a7734ec4d9b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxODowMDo0OFrOIIB9IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxODowMDo0OFrOIIB9IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5MTU1Mw==", "bodyText": "@dchopra001  This is the update you suggested me, please let me know if this change will be part of #11320 so I can remove it from here", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r545291553", "createdAt": "2020-12-17T18:00:48Z", "author": {"login": "bragaigor"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -1374,8 +1374,7 @@ TR::Register *J9::X86::TreeEvaluator::multianewArrayEvaluator(TR::Node *node, TR\n       }\n \n    // temp2Reg = firstDimLenReg * 16 (discontiguousArrayHeaderSizeInBytes)\n-   generateRegRegInstruction(MOVRegReg(),  node, temp2Reg, firstDimLenReg, cg);\n-   generateRegImmInstruction(SHLRegImm1(), node, temp2Reg, 4, cg);\n+   generateRegRegImmInstruction(IMulRegRegImms(4), node, temp2Reg, firstDimLenReg, zeroArraySize, cg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88db5cbaa77b9ce36907fc7d8ddf0a7734ec4d9b"}, "originalPosition": 6}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c458663c079ee3bd9e6ce49d6296a72527fcb1f6", "author": {"user": {"login": "bragaigor", "name": "Igor Braga"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c458663c079ee3bd9e6ce49d6296a72527fcb1f6", "committedDate": "2020-12-18T16:46:47Z", "message": "Revert JIT fix as that's taken care at #11507\n\nSigned-off-by: Igor Braga <higorb1@gmail.com>"}, "afterCommit": {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131", "author": {"user": {"login": "bragaigor", "name": "Igor Braga"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/919fd3044121cdbaa4de02bc341d9da3a0859131", "committedDate": "2020-12-19T17:00:56Z", "message": "Add extra U_64 data field to Indexable Object Headers\n\nPreliminary work to incorporate extra 64 bit field to\nIndexable object headers. In case of contiguous arraylets\nthe extra field will hold the address of where the data\nstarts, which is right after the header. In case of\ndiscontiguous arraylets the extra field will hold the\naddress of:\n\n- The contiguous double mapped region (assuming double map\n  is enabled).\n- The contiguous sparse-heap region outside the heap (assuming\n  sparse heap is enabled).\n- If double mapping an sparse heap are both disabled, dataAddr\n  will point to the address right adter the header, in this\n  case to the first arrayoid.\n\nThis is the first phase concerning a series of deliverables.\nHere, we introduce the extra U_64 data field along with helper\nfunctions such as getters and setters that will be needed in\nthe future. Now dataAddr is only introduced and never used.\nOnce it\u2019s stable we\u2019ll deliver the second phase of changes\nthat makes use of dataAddr.\n\nPlease refer to https://github.com/eclipse/openj9/issues/11438\nfor more info. This set of changes concern part of the first\naction item of such issue.\n\nSigned-off-by: Igor Braga <higorb1@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NDA2MDY5", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-556406069", "createdAt": "2020-12-21T14:11:08Z", "commit": {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxMTowOFrOIJZiOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxMTowOFrOIJZiOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcyNjQ1Nw==", "bodyText": "minor difference, but you can just pass dataAddr value, instead of passing headerSize and header", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r546726457", "createdAt": "2020-12-21T14:11:08Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -58,6 +58,67 @@ class MM_ObjectAllocationAPI\n \tconst J9VMGCSizeClasses *_sizeClasses;\n #endif /* J9VM_GC_SEGREGATED_HEAP */\n \n+\tVMINLINE void\n+\tinitializeIndexableSlots(bool initializeSlots, UDATA dataSize, UDATA headerSize, J9IndexableObject *header)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NDA4Mzgw", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-556408380", "createdAt": "2020-12-21T14:14:27Z", "commit": {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxNDoyOFrOIJZpJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxNDoyOFrOIJZpJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcyODIyOA==", "bodyText": "i'd call it  J9_GC_INDEXABLE_DATA_FIELD_SIZE and define it as sizeof(U_64)", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r546728228", "createdAt": "2020-12-21T14:14:28Z", "author": {"login": "amicic"}, "path": "runtime/oti/j9consts.h", "diffHunk": "@@ -458,6 +458,8 @@ extern \"C\" {\n \n #define J9_GC_MINIMUM_OBJECT_SIZE 0x10\n #if defined(J9VM_ENV_DATA64)\n+#define J9_GC_EXTRA_DATA_FIELD_SIZE 0x08", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NDExNjk4", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-556411698", "createdAt": "2020-12-21T14:19:12Z", "commit": {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxOToxMlrOIJZzjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxOToxMlrOIJZzjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjczMDg5Mw==", "bodyText": "You could share the code for setter and getter.... have dataAddrSlotForContiguous() (and one for Discontiguous) that will give you address of the dataAddr Slot, and then setter and getter just de-references the address.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r546730893", "createdAt": "2020-12-21T14:19:12Z", "author": {"login": "amicic"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,143 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 address = (U_64)((UDATA)arrayPtr + contiguousHeaderSize());\n+\n+\t\tif (compressed) {\n+\t\t\t((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr = address;\n+\t\t} else {\n+\t\t\t((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr = address;\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "919fd3044121cdbaa4de02bc341d9da3a0859131"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMTE3MDg4", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-561117088", "createdAt": "2021-01-04T15:26:41Z", "commit": {"oid": "686aacd36aaa6f47396d5ff1a2dd5eecc58df281"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNToyNjo0MlrOIN101w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNToyNjo0MlrOIN101w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM4NDI3OQ==", "bodyText": "Remove extra space", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551384279", "createdAt": "2021-01-04T15:26:42Z", "author": {"login": "bragaigor"}, "path": "runtime/oti/j9consts.h", "diffHunk": "@@ -458,6 +458,8 @@ extern \"C\" {\n \n #define J9_GC_MINIMUM_OBJECT_SIZE 0x10\n #if defined(J9VM_ENV_DATA64)\n+#define  J9_GC_INDEXABLE_DATA_FIELD_SIZE sizeof(U_64)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686aacd36aaa6f47396d5ff1a2dd5eecc58df281"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMzM1MTU4", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-561335158", "createdAt": "2021-01-04T20:50:39Z", "commit": {"oid": "686aacd36aaa6f47396d5ff1a2dd5eecc58df281"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMDo1MDo0MFrOIOAoSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMDo1MDo0MFrOIOAoSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTI4OA==", "bodyText": "Is the cast needed here?", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551561288", "createdAt": "2021-01-04T20:50:40Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/x/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7040,10 +7040,20 @@ static bool genZeroInitObject2(\n    auto headerSize = isArrayNew ? TR::Compiler->om.contiguousArrayHeaderSizeInBytes() : TR::Compiler->om.objectHeaderSizeInBytes();\n    // If we are using full refs both contiguous and discontiguous array header have the same size, in which case we must adjust header size\n    // slightly so that rep stosb can initialize the size field of zero sized arrays appropriately\n-   if (!cg->comp()->target().is32Bit() && !TR::Compiler->om.compressObjectReferences() && isArrayNew)\n+   //   #bits per section (compressed refs): | 32 bits |  32 bits   | 32 bits | 32 bits |   32 bits   |   32 bits    |\n+   //   zero sized arrays:                   |  class  | mustBeZero |   size  | padding |          dataAddr          |\n+   //   smallest contiguous array:           |  class  |    size    |      dataAddr     | 1 byte + padding |  other  |\n+   //   In order for us to successfully initialize the size field of a zero sized array in compressed refs\n+   //   we must subtract 8 bytes (sizeof(dataAddr)) from header size. And in case of full refs we must\n+   //   subtract 16 bytes from the header in order to properly initialize the zero sized field. We can\n+   //   accomplish that by simply subtracting the offset of dataAddr field, which is 8 for compressed refs\n+   //   and 16 for full refs.\n+#if defined(TR_TARGET_64BIT)\n+   if (!cg->comp()->target().is32Bit() && isArrayNew)\n       {\n-      headerSize -= 8;\n+      headerSize -= ((TR_J9VMBase *)(cg->fe()))->getOffsetOfContiguousDataAddrField();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686aacd36aaa6f47396d5ff1a2dd5eecc58df281"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNDg4NzY1", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-561488765", "createdAt": "2021-01-05T03:14:00Z", "commit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMzoxNDowMFrOIOItNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMzoxNDowMFrOIOItNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY5MzYyMw==", "bodyText": "Brackets please.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551693623", "createdAt": "2021-01-05T03:14:00Z", "author": {"login": "gacholio"}, "path": "runtime/oti/j9consts.h", "diffHunk": "@@ -458,6 +458,8 @@ extern \"C\" {\n \n #define J9_GC_MINIMUM_OBJECT_SIZE 0x10\n #if defined(J9VM_ENV_DATA64)\n+#define J9_GC_INDEXABLE_DATA_FIELD_SIZE sizeof(U_64)\n+#define J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE J9_GC_MINIMUM_OBJECT_SIZE +  J9_GC_INDEXABLE_DATA_FIELD_SIZE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxODU4NjUy", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-561858652", "createdAt": "2021-01-05T14:59:07Z", "commit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxODU2MzE1", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-561856315", "createdAt": "2021-01-05T14:56:35Z", "commit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNDo1NjozNVrOIOaX6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNToyNTo1NlrOIObhoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4MzA4MA==", "bodyText": "The header file says these functions return uintptr_t. Please be consistent.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551983080", "createdAt": "2021-01-05T14:56:35Z", "author": {"login": "keithc-ca"}, "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -1024,6 +1024,10 @@ UDATA TR_J9VMBase::getOffsetOfBackfillOffsetField()                 {return offs\n \n UDATA TR_J9VMBase::getOffsetOfContiguousArraySizeField()            {return TR::Compiler->om.offsetOfContiguousArraySizeField();}\n UDATA TR_J9VMBase::getOffsetOfDiscontiguousArraySizeField()         {return TR::Compiler->om.offsetOfDiscontiguousArraySizeField();}\n+#if defined(TR_TARGET_64BIT)\n+UDATA TR_J9VMBase::getOffsetOfContiguousDataAddrField()             {return TR::Compiler->om.offsetOfContiguousDataAddrField();}\n+UDATA TR_J9VMBase::getOffsetOfDiscontiguousDataAddrField()          {return TR::Compiler->om.offsetOfDiscontiguousDataAddrField();}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NjYzNw==", "bodyText": "This this use AssertDiscontiguousArrayletLayout?", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551986637", "createdAt": "2021-01-05T15:02:14Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NzAzNA==", "bodyText": "I think the first cast is redundant.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551987034", "createdAt": "2021-01-05T15:02:51Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tU_64 *dataAddr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tU_64 address = (U_64)((U_64)arrayPtr + contiguousHeaderSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NzIwMQ==", "bodyText": "Redundant cast.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551987201", "createdAt": "2021-01-05T15:03:09Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE U_64*\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tU_64 *address = NULL;\n+\t\tif (compressed) {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\taddress = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn address;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tU_64 *dataAddr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tU_64 address = (U_64)((U_64)arrayPtr + contiguousHeaderSize());\n+\t\t*dataAddr = address;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a discontiguous indexable object.\n+\t * Sets the data pointer of a discontiguous indexable object; in this case\n+\t * dataAddr will point to the contiguous representation of the data\n+\t * which resides outside the heap (assuming double map/sparse-heap is enabled).\n+\t * In case double map is disabled, the dataAddr will point to the first arrayoid\n+\t * of the discontiguous indexable object, which also resides right after dataAddr\n+\t * field.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @param dataAddr      Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForDiscontiguous(J9IndexableObject *arrayPtr, U_64 address)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tU_64 calculatedDataAddr = address;\n+\t\tU_64 *dataAddr = dataAddrSlotForDiscontiguous(arrayPtr);\n+\n+\t\t/* If calculatedDataAddr is NULL then we make dataAddr point to the first arrayoid */\n+\t\t/* Later on, when sparse-heap is enabled by default, we must assert dataAddr is not NULL */\n+\t\tif (0 == calculatedDataAddr) {\n+\t\t\tcalculatedDataAddr = (U_64)((U_64)arrayPtr + discontiguousHeaderSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk5NDk3NQ==", "bodyText": "This can be:\nuint8_t *afterAlloc = heapAlloc + allocateSize;\n\nwhich eliminates the cast here and the need for one on line 168.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551994975", "createdAt": "2021-01-05T15:15:16Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -80,25 +142,30 @@ class MM_ObjectAllocationAPI\n #endif /* J9VM_ENV_DATA64 */\n \t\t\t{\n \t\t\t\t/* Calculate the size of the object */\n-\t\t\t\tUDATA const headerSize = J9VMTHREAD_CONTIGUOUS_HEADER_SIZE(currentThread);\n-\t\t\t\tUDATA const dataSize = ((UDATA)size) * J9ARRAYCLASS_GET_STRIDE(arrayClass);\n-\t\t\t\tUDATA allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(UDATA)(_objectAlignmentInBytes - 1);\n+\t\t\t\tuintptr_t const headerSize = J9VMTHREAD_CONTIGUOUS_HEADER_SIZE(currentThread);\n+\t\t\t\tuintptr_t const dataSize = ((uintptr_t)size) * J9ARRAYCLASS_GET_STRIDE(arrayClass);\n+\t\t\t\tuintptr_t allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);\n+#if defined(J9VM_ENV_DATA64)\n+\t\t\t\tif (allocateSize < J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE) {\n+\t\t\t\t\tallocateSize = J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE;\n+\t\t\t\t}\n+#else /* !J9VM_ENV_DATA64 */\n \t\t\t\tif (allocateSize < J9_GC_MINIMUM_OBJECT_SIZE) {\n \t\t\t\t\tallocateSize = J9_GC_MINIMUM_OBJECT_SIZE;\n \t\t\t\t}\n-\n+#endif /* J9VM_ENV_DATA64 */\n \t\t\t\t/* Allocate the memory */\n \t\t\t\tj9object_t objectHeader = NULL;\n \n \t\t\t\tswitch(_gcAllocationType) {\n \n #if defined(J9VM_GC_THREAD_LOCAL_HEAP)\n \t\t\t\tcase OMR_GC_ALLOCATION_TYPE_TLH:\n-\t\t\t\t\tif (allocateSize <= ((UDATA) currentThread->heapTop - (UDATA) currentThread->heapAlloc)) {\n-\t\t\t\t\t\tU_8 *heapAlloc = currentThread->heapAlloc;\n-\t\t\t\t\t\tUDATA afterAlloc = (UDATA)heapAlloc + allocateSize;\n+\t\t\t\t\tif (allocateSize <= ((uintptr_t) currentThread->heapTop - (uintptr_t) currentThread->heapAlloc)) {\n+\t\t\t\t\t\tuint8_t *heapAlloc = currentThread->heapAlloc;\n+\t\t\t\t\t\tuintptr_t afterAlloc = (uintptr_t)heapAlloc + allocateSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk5NTg0Mw==", "bodyText": "nit: end of multi-line comment (*/) should be on a line by itself.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551995843", "createdAt": "2021-01-05T15:16:36Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -150,29 +217,24 @@ class MM_ObjectAllocationAPI\n \t\t\t\t}\n \n \t\t\t\t/* Initialize the object */\n-\t\t\t\tif (J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(currentThread)) {\n-\t\t\t\t\tJ9IndexableObjectContiguousCompressed *header = (J9IndexableObjectContiguousCompressed*)objectHeader;\n-\t\t\t\t\theader->clazz = (U_32)(UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tJ9IndexableObjectContiguousFull *header = (J9IndexableObjectContiguousFull*)objectHeader;\n-\t\t\t\t\theader->clazz = (UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tinitializeContiguousIndexableObject(currentThread, initializeSlots, arrayClass, size, dataSize, &objectHeader);\n+\n \t\t\t\tif (memoryBarrier) {\n \t\t\t\t\tVM_AtomicSupport::writeBarrier();\n \t\t\t\t}\n \t\t\t\tinstance = objectHeader;\n \t\t\t}\n \t\t} else {\n+#if defined(J9VM_ENV_DATA64)\n+\t\t\t/* Calculate size of indexable object */\n+\t\t\tuintptr_t const headerSize = J9VMTHREAD_DISCONTIGUOUS_HEADER_SIZE(currentThread);\n+\t\t\tuintptr_t allocateSize = (headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);\n+\t\t\t/* Discontiguous header size is always equal or greater than J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE; therefore,\n+\t\t\t * there's no need to check if allocateSize is less than J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk5NjQzOQ==", "bodyText": "Needless casts as above.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r551996439", "createdAt": "2021-01-05T15:17:28Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -181,11 +243,11 @@ class MM_ObjectAllocationAPI\n #if defined(J9VM_GC_THREAD_LOCAL_HEAP)\n \t\t\tcase OMR_GC_ALLOCATION_TYPE_TLH:\n \n-\t\t\t\tif (allocateSize <= ((UDATA) currentThread->heapTop - (UDATA) currentThread->heapAlloc)) {\n-\t\t\t\t\tU_8 *heapAlloc = currentThread->heapAlloc;\n-\t\t\t\t\tUDATA afterAlloc = (UDATA)heapAlloc + allocateSize;\n+\t\t\t\tif (allocateSize <= ((uintptr_t) currentThread->heapTop - (uintptr_t) currentThread->heapAlloc)) {\n+\t\t\t\t\tuint8_t *heapAlloc = currentThread->heapAlloc;\n+\t\t\t\t\tuintptr_t afterAlloc = (uintptr_t)heapAlloc + allocateSize;\n \t\t\t\t\tobjectHeader = (j9object_t) heapAlloc;\n-\t\t\t\t\tcurrentThread->heapAlloc = (U_8 *)afterAlloc;\n+\t\t\t\t\tcurrentThread->heapAlloc = (uint8_t *)afterAlloc;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwMTI0Ng==", "bodyText": "I think this round-up pattern deserves to be refactored into a helper function (perhaps a macro already exists).", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552001246", "createdAt": "2021-01-05T15:24:48Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -274,9 +327,9 @@ class MM_ObjectAllocationAPI\n \t\tj9object_t instance = NULL;\n #if defined(J9VM_GC_THREAD_LOCAL_HEAP) || defined(J9VM_GC_SEGREGATED_HEAP)\n \t\t/* Calculate the size of the object */\n-\t\tUDATA const headerSize = J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n-\t\tUDATA dataSize = clazz->totalInstanceSize;\n-\t\tUDATA allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(UDATA)(_objectAlignmentInBytes - 1);\n+\t\tuintptr_t const headerSize = J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\tuintptr_t dataSize = clazz->totalInstanceSize;\n+\t\tuintptr_t allocateSize = (dataSize + headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwMTk1Mg==", "bodyText": "nit: please also lose the extra space after +", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552001952", "createdAt": "2021-01-05T15:25:56Z", "author": {"login": "keithc-ca"}, "path": "runtime/oti/j9consts.h", "diffHunk": "@@ -458,6 +458,8 @@ extern \"C\" {\n \n #define J9_GC_MINIMUM_OBJECT_SIZE 0x10\n #if defined(J9VM_ENV_DATA64)\n+#define J9_GC_INDEXABLE_DATA_FIELD_SIZE sizeof(U_64)\n+#define J9_GC_MINIMUM_INDEXABLE_OBJECT_SIZE J9_GC_MINIMUM_OBJECT_SIZE +  J9_GC_INDEXABLE_DATA_FIELD_SIZE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY5MzYyMw=="}, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxOTk2ODU5", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-561996859", "createdAt": "2021-01-05T17:42:19Z", "commit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzo0MjoxOVrOIOg1VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzo0MjoxOVrOIOg1VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4ODkxNg==", "bodyText": "These structures are no longer used (they exist only to keep DDR happy), so if you avoid changing them, then there may not be a need for any DDR work.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552088916", "createdAt": "2021-01-05T17:42:19Z", "author": {"login": "gacholio"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2967,18 +2967,25 @@ typedef struct J9IndexableObjectContiguous {\n #if defined(J9VM_ENV_DATA64) && defined(OMR_GC_FULL_POINTERS)\n \tU_32 padding;\n #endif /* J9VM_ENV_DATA64 && !OMR_GC_COMPRESSED_POINTERS */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxOTk3MTg4", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-561997188", "createdAt": "2021-01-05T17:42:46Z", "commit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzo0Mjo0N1rOIOg2Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzo0Mjo0N1rOIOg2Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTE2Mg==", "bodyText": "Same comment as above - don't change the unused structures.", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552089162", "createdAt": "2021-01-05T17:42:47Z", "author": {"login": "gacholio"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -2989,13 +2996,19 @@ typedef struct J9IndexableObjectDiscontiguous {\n #if defined(OMR_GC_COMPRESSED_POINTERS) || !defined(J9VM_ENV_DATA64)\n \tU_32 padding;\n #endif /* OMR_GC_COMPRESSED_POINTERS || !J9VM_ENV_DATA64 */\n+#if defined(J9VM_ENV_DATA64)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf05e0c03e97f6d93ac00e6811977596546d22ab"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyODQxMDYx", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-562841061", "createdAt": "2021-01-06T16:13:01Z", "commit": {"oid": "23a6fbc2f8e8f6efe1722772b18f011d37222f4d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxNjoxMzowMVrOIPJrdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxNjoxMzowMVrOIPJrdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc1ODEzNQ==", "bodyText": "nit: please remove this blank line", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552758135", "createdAt": "2021-01-06T16:13:01Z", "author": {"login": "keithc-ca"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,161 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tvoid **dataAddrPtr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tvoid *dataAddr = (void *)((U_64)arrayPtr + contiguousHeaderSize());\n+\t\t*dataAddrPtr = dataAddr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a discontiguous indexable object.\n+\t * Sets the data pointer of a discontiguous indexable object; in this case\n+\t * dataAddr will point to the contiguous representation of the data\n+\t * which resides outside the heap (assuming double map/sparse-heap is enabled).\n+\t * In case double map is disabled, the dataAddr will point to the first arrayoid\n+\t * of the discontiguous indexable object, which also resides right after dataAddr\n+\t * field.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @param dataAddr      Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForDiscontiguous(J9IndexableObject *arrayPtr, void *address)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tvoid *calculatedDataAddr = address;\n+\t\tvoid **dataAddrPtr = dataAddrSlotForDiscontiguous(arrayPtr);\n+\n+\t\t/* If calculatedDataAddr is NULL then we make dataAddr point to the first arrayoid */\n+\t\t/* Later on, when sparse-heap is enabled by default, we must assert dataAddr is not NULL */\n+\t\tif (NULL == calculatedDataAddr) {\n+\t\t\tcalculatedDataAddr = (void *)((U_64)arrayPtr + discontiguousHeaderSize());\n+\t\t}\n+\n+\t\t*dataAddrPtr = calculatedDataAddr;\n+\t}\n+\n+\t/**\n+\t * Returns data pointer associated with a contiguous Indexable object.\n+\t * Data pointer will always be pointing at the arraylet data. In this\n+\t * case the data pointer will be pointing to address immediately after\n+\t * the header.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @return data address associated with the Indexable object\n+\t */\n+\tMMINLINE void *\n+\tgetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tvoid *dataAddr = *dataAddrSlotForContiguous(arrayPtr);\n+\t\treturn dataAddr;\n+\t}\n+\n+\t/**\n+\t * Returns data pointer associated with a discontiguous Indexable object.\n+\t * Data pointer will always be pointing at the arraylet data. In this\n+\t * case the data pointer will be pointing to address immediately after\n+\t * the header (the arrayoid), except when double mapping or sparse-heap\n+\t * is enabled. In these cases, the data pointer will point to the\n+\t * contiguous representation of the data; hence returning that pointer.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @return data address associated with the Indexable object\n+\t */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23a6fbc2f8e8f6efe1722772b18f011d37222f4d"}, "originalPosition": 130}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d956b71734d228103ba66c8c326096dbbacf8c7a", "author": {"user": {"login": "bragaigor", "name": "Igor Braga"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/d956b71734d228103ba66c8c326096dbbacf8c7a", "committedDate": "2021-01-06T18:06:07Z", "message": "Remove space\n\nSigned-off-by: Igor Braga <higorb1@gmail.com>"}, "afterCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a", "author": {"user": {"login": "bragaigor", "name": "Igor Braga"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/eea13016da2093cef1c255ef51e09833bf83404a", "committedDate": "2021-01-06T18:07:21Z", "message": "Add extra U_64 data field to Indexable Object Headers\n\nPreliminary work to incorporate extra 64 bit field to\nIndexable object headers. In case of contiguous arraylets\nthe extra field will hold the address of where the data\nstarts, which is right after the header. In case of\ndiscontiguous arraylets the extra field will hold the\naddress of:\n\n- The contiguous double mapped region (assuming double map\n  is enabled).\n- The contiguous sparse-heap region outside the heap (assuming\n  sparse heap is enabled).\n- If double mapping an sparse heap are both disabled, dataAddr\n  will point to the address right adter the header, in this\n  case to the first arrayoid.\n\nThis is the first phase concerning a series of deliverables.\nHere, we introduce the extra U_64 data field along with helper\nfunctions such as getters and setters that will be needed in\nthe future. Now dataAddr is only introduced and never used.\nOnce it\u2019s stable we\u2019ll deliver the second phase of changes\nthat makes use of dataAddr.\n\nPlease refer to https://github.com/eclipse/openj9/issues/11438\nfor more info. This set of changes concern part of the first\naction item of such issue.\n\nSigned-off-by: Igor Braga <higorb1@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyOTQ3ODUw", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-562947850", "createdAt": "2021-01-06T18:33:43Z", "commit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyOTUzNTQ5", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-562953549", "createdAt": "2021-01-06T18:42:42Z", "commit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyOTczNTUx", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-562973551", "createdAt": "2021-01-06T19:12:59Z", "commit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOToxMjo1OVrOIPTB6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOToxMjo1OVrOIPTB6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkxMTMzNw==", "bodyText": "U64 is not correct in the name - the logic is correct (and used) even on 32bit, too.\nRename it to either ROUND_TO, or perhaps ROUND_UP_TO\nBTW, the same logic exists in GC_ObjectModelBase::adjustSizeInBytes() in OMR. Ideally, the macro should be on OMR side and both sides use it (but I guess this ok for now),", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552911337", "createdAt": "2021-01-06T19:12:59Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -33,6 +33,9 @@\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n #endif /* OMR_OVERRIDE_COMPRESS_OBJECT_REFERENCES */\n \n+/* Generic rounding macro - result is a uintptr_t */\n+#define ROUND_U64_TO(granularity, number) (((uintptr_t)(number) + (granularity) - 1) & ~((uintptr_t)(granularity) - 1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyOTkxMzIx", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-562991321", "createdAt": "2021-01-06T19:41:48Z", "commit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0MTo0OVrOIPT4Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0MTo0OVrOIPT4Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNTI3MQ==", "bodyText": "it's more generic/optimal (in potential case this gets used on 32 bit) to cast to UDATA (what also discontiguousHeaderSize() returns).\nsame for contiguous", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552925271", "createdAt": "2021-01-06T19:41:49Z", "author": {"login": "amicic"}, "path": "runtime/gc_glue_java/ArrayletObjectModel.hpp", "diffHunk": "@@ -831,6 +831,160 @@ class GC_ArrayletObjectModel : public GC_ArrayletObjectModelBase\n \t\treturn getSpineSize(J9GC_J9OBJECT_CLAZZ(arrayPtr, this), layout, getSizeInElements(arrayPtr));\n \t}\n \n+#if defined(J9VM_ENV_DATA64)\n+\n+\t/**\n+\t * Gets data pointer of a contiguous indexable object.\n+\t * Helper to get dataAddr field of contiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tAssertContiguousArrayletLayout(arrayPtr);\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectContiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Gets data pointer of a discontiguous indexable object.\n+\t * Helper to get dataAddr field of discontiguous indexable objects.\n+\t *\n+\t * @return Pointer which points to discontiguous indexable object data\n+\t */\n+\tMMINLINE void **\n+\tdataAddrSlotForDiscontiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tbool const compressed = compressObjectReferences();\n+\t\tvoid **dataAddrPtr = NULL;\n+\t\tif (compressed) {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousCompressed *)arrayPtr)->dataAddr;\n+\t\t} else {\n+\t\t\tdataAddrPtr = &((J9IndexableObjectDiscontiguousFull *)arrayPtr)->dataAddr;\n+\t\t}\n+\t\treturn dataAddrPtr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a contiguous indexable object.\n+\t * Sets the data pointer of a contiguous indexable object; in this case\n+\t * dataAddr will point directly into the data right after dataAddr field\n+\t * (data resides in heap).\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForContiguous(J9IndexableObject *arrayPtr)\n+\t{\n+\t\tvoid **dataAddrPtr = dataAddrSlotForContiguous(arrayPtr);\n+\t\tvoid *dataAddr = (void *)((U_64)arrayPtr + contiguousHeaderSize());\n+\t\t*dataAddrPtr = dataAddr;\n+\t}\n+\n+\t/**\n+\t * Sets data pointer of a discontiguous indexable object.\n+\t * Sets the data pointer of a discontiguous indexable object; in this case\n+\t * dataAddr will point to the contiguous representation of the data\n+\t * which resides outside the heap (assuming double map/sparse-heap is enabled).\n+\t * In case double map is disabled, the dataAddr will point to the first arrayoid\n+\t * of the discontiguous indexable object, which also resides right after dataAddr\n+\t * field.\n+\t *\n+\t * @param arrayPtr      Pointer to the indexable object whose size is required\n+\t * @param dataAddr      Pointer which points to indexable object data\n+\t */\n+\tMMINLINE void\n+\tsetDataAddrForDiscontiguous(J9IndexableObject *arrayPtr, void *address)\n+\t{\n+\t\t/* If double mapping is enabled only, arraylet will have a discontiguous layout.\n+\t\t * If sparse-heap is enabled, arraylet will have a contiguous layout. For now\n+\t\t * we can't simply Assert only the discontiguous case because there could also\n+\t\t * exist hybrid arraylets (which will be dicontinued in the future) */\n+\t\tvoid *calculatedDataAddr = address;\n+\t\tvoid **dataAddrPtr = dataAddrSlotForDiscontiguous(arrayPtr);\n+\n+\t\t/* If calculatedDataAddr is NULL then we make dataAddr point to the first arrayoid */\n+\t\t/* Later on, when sparse-heap is enabled by default, we must assert dataAddr is not NULL */\n+\t\tif (NULL == calculatedDataAddr) {\n+\t\t\tcalculatedDataAddr = (void *)((U_64)arrayPtr + discontiguousHeaderSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyOTk2MDUy", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-562996052", "createdAt": "2021-01-06T19:50:04Z", "commit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo1MDowNFrOIPUGzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo1MDowNFrOIPUGzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODk3Mw==", "bodyText": "missed to use the macro", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552928973", "createdAt": "2021-01-06T19:50:04Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -150,29 +220,25 @@ class MM_ObjectAllocationAPI\n \t\t\t\t}\n \n \t\t\t\t/* Initialize the object */\n-\t\t\t\tif (J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(currentThread)) {\n-\t\t\t\t\tJ9IndexableObjectContiguousCompressed *header = (J9IndexableObjectContiguousCompressed*)objectHeader;\n-\t\t\t\t\theader->clazz = (U_32)(UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tJ9IndexableObjectContiguousFull *header = (J9IndexableObjectContiguousFull*)objectHeader;\n-\t\t\t\t\theader->clazz = (UDATA)arrayClass;\n-\t\t\t\t\theader->size = size;\n-\t\t\t\t\tif (initializeSlots) {\n-\t\t\t\t\t\tmemset(header + 1, 0, dataSize);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tinitializeContiguousIndexableObject(currentThread, initializeSlots, arrayClass, size, dataSize, &objectHeader);\n+\n \t\t\t\tif (memoryBarrier) {\n \t\t\t\t\tVM_AtomicSupport::writeBarrier();\n \t\t\t\t}\n \t\t\t\tinstance = objectHeader;\n \t\t\t}\n \t\t} else {\n+#if defined(J9VM_ENV_DATA64)\n+\t\t\t/* Calculate size of indexable object */\n+\t\t\tuintptr_t const headerSize = J9VMTHREAD_DISCONTIGUOUS_HEADER_SIZE(currentThread);\n+\t\t\tuintptr_t allocateSize = (headerSize + _objectAlignmentInBytes - 1) & ~(uintptr_t)(_objectAlignmentInBytes - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 202}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMDA0MTM5", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-563004139", "createdAt": "2021-01-06T20:03:14Z", "commit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowMzoxNFrOIPUg6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowMzoxNFrOIPUg6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNTY1Nw==", "bodyText": "(NULL != dataAddr) is just temporary till all parties do initialize/update dataAddr? Even in 0-sized arrays, this will be initialized (to the end of header)?", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#discussion_r552935657", "createdAt": "2021-01-06T20:03:14Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAllocationAPI.hpp", "diffHunk": "@@ -48,16 +51,78 @@ class MM_ObjectAllocationAPI\n \t * Data members\n \t */\n private:\n-\tconst UDATA _gcAllocationType;\n+\tconst uintptr_t _gcAllocationType;\n #if defined(J9VM_GC_BATCH_CLEAR_TLH)\n-\tconst UDATA _initializeSlotsOnTLHAllocate;\n+\tconst uintptr_t _initializeSlotsOnTLHAllocate;\n #endif /* J9VM_GC_BATCH_CLEAR_TLH */\n-\tconst UDATA _objectAlignmentInBytes;\n+\tconst uintptr_t _objectAlignmentInBytes;\n \n #if defined (J9VM_GC_SEGREGATED_HEAP)\n \tconst J9VMGCSizeClasses *_sizeClasses;\n #endif /* J9VM_GC_SEGREGATED_HEAP */\n \n+\tVMINLINE void\n+\tinitializeIndexableSlots(bool initializeSlots, uintptr_t dataSize, void *dataAddr)\n+\t{\n+\t\tif ((NULL != dataAddr) && initializeSlots) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMDQzODQ1", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-563043845", "createdAt": "2021-01-06T21:20:11Z", "commit": {"oid": "eea13016da2093cef1c255ef51e09833bf83404a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f16da64b5bcb87ca7466bf4c76c70a8c244b06e1", "author": {"user": {"login": "bragaigor", "name": "Igor Braga"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f16da64b5bcb87ca7466bf4c76c70a8c244b06e1", "committedDate": "2021-01-07T02:08:47Z", "message": "Add extra U_64 data field to Indexable Object Headers\n\nPreliminary work to incorporate extra 64 bit field to\nIndexable object headers. In case of contiguous arraylets\nthe extra field will hold the address of where the data\nstarts, which is right after the header. In case of\ndiscontiguous arraylets the extra field will hold the\naddress of:\n\n- The contiguous double mapped region (assuming double map\n  is enabled).\n- The contiguous sparse-heap region outside the heap (assuming\n  sparse heap is enabled).\n- If double mapping an sparse heap are both disabled, dataAddr\n  will point to the address right adter the header, in this\n  case to the first arrayoid.\n\nThis is the first phase concerning a series of deliverables.\nHere, we introduce the extra U_64 data field along with helper\nfunctions such as getters and setters that will be needed in\nthe future. Now dataAddr is only introduced and never used.\nOnce it\u2019s stable we\u2019ll deliver the second phase of changes\nthat makes use of dataAddr.\n\nPlease refer to https://github.com/eclipse/openj9/issues/11438\nfor more info. This set of changes concern part of the first\naction item of such issue.\n\nSigned-off-by: Igor Braga <higorb1@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0640065758336751f4a502005243bd7a5288f662", "author": {"user": {"login": "bragaigor", "name": "Igor Braga"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0640065758336751f4a502005243bd7a5288f662", "committedDate": "2021-01-07T02:06:18Z", "message": "Use ROUND_UP_TO_POWEROF2 instead of creating new macro\n\nSigned-off-by: Igor Braga <higorb1@gmail.com>"}, "afterCommit": {"oid": "f16da64b5bcb87ca7466bf4c76c70a8c244b06e1", "author": {"user": {"login": "bragaigor", "name": "Igor Braga"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f16da64b5bcb87ca7466bf4c76c70a8c244b06e1", "committedDate": "2021-01-07T02:08:47Z", "message": "Add extra U_64 data field to Indexable Object Headers\n\nPreliminary work to incorporate extra 64 bit field to\nIndexable object headers. In case of contiguous arraylets\nthe extra field will hold the address of where the data\nstarts, which is right after the header. In case of\ndiscontiguous arraylets the extra field will hold the\naddress of:\n\n- The contiguous double mapped region (assuming double map\n  is enabled).\n- The contiguous sparse-heap region outside the heap (assuming\n  sparse heap is enabled).\n- If double mapping an sparse heap are both disabled, dataAddr\n  will point to the address right adter the header, in this\n  case to the first arrayoid.\n\nThis is the first phase concerning a series of deliverables.\nHere, we introduce the extra U_64 data field along with helper\nfunctions such as getters and setters that will be needed in\nthe future. Now dataAddr is only introduced and never used.\nOnce it\u2019s stable we\u2019ll deliver the second phase of changes\nthat makes use of dataAddr.\n\nPlease refer to https://github.com/eclipse/openj9/issues/11438\nfor more info. This set of changes concern part of the first\naction item of such issue.\n\nSigned-off-by: Igor Braga <higorb1@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzNTAzNzEy", "url": "https://github.com/eclipse-openj9/openj9/pull/11507#pullrequestreview-563503712", "createdAt": "2021-01-07T13:57:04Z", "commit": {"oid": "f16da64b5bcb87ca7466bf4c76c70a8c244b06e1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1530, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}