{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NjIxNTE3", "number": 9359, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjowNjoyMlrOD12OIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjowNjozNFrOD12OmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3Nzg5NDc0OnYy", "diffSide": "RIGHT", "path": "jcl/src/openj9.dtfjview/share/classes/com/ibm/jvm/dtfjview/commands/HexdumpCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjowNjoyMlrOGLexFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjowNzoyOVrOGLez2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5MTYwNQ==", "bodyText": "Seems <bytes_to_print> should have surrounding [] characters since it's optional. The following help could also mention the default of 256.", "url": "https://github.com/eclipse-openj9/openj9/pull/9359#discussion_r414691605", "createdAt": "2020-04-24T16:06:22Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.dtfjview/share/classes/com/ibm/jvm/dtfjview/commands/HexdumpCommand.java", "diffHunk": "@@ -37,161 +39,153 @@\n public class HexdumpCommand extends BaseJdmpviewCommand {\n \n \t{\n-\t\taddCommand(\"hexdump\", \"<hex address>\", \"outputs a section of memory in hexadecimal, ascii and ebcdic\");\t\n+\t\taddCommand(\"hexdump\", \"<hex address> [<bytes_to_print>]\", \"outputs a section of memory in hexadecimal, ASCII and EBCDIC\");\t\n \t}\n-\t\n+\n+\t@Override\n \tpublic void run(String command, String[] args, IContext context, PrintStream out) throws CommandException {\n-\t\tif(initCommand(command, args, context, out)) {\n-\t\t\treturn;\t\t//processing already handled by super class\n+\t\tif (initCommand(command, args, context, out)) {\n+\t\t\treturn; // processing already handled by super class\n \t\t}\n \t\tdoCommand(args);\n \t}\n-\t\n-\tpublic void doCommand(String[] args){\n-\t\tStringBuffer stringBuffer = new StringBuffer();\n+\n+\tpublic void doCommand(String[] args) {\n \t\tImageAddressSpace imageAddressSpace = ctx.getAddressSpace();\n-\t\tif(null == imageAddressSpace) {\n+\n+\t\tif (null == imageAddressSpace) {\n \t\t\tout.println(\"Could not find an address space which contains a process in this core file\");\n \t\t\treturn;\n \t\t}\n-\t\tlong addressInDecimal = 0;\n-\t\tint numBytesToPrint = 16*16; //dump 256 bytes by default\n-\t\tint asciiIndex = 0;\n-\t\t\n-\t\tif (args.length != 0){\n-\t\t\tLong address = Utils.longFromString(args[0]);\n-\t\t\tif(null == address){\n-\t\t\t\tout.println(\"Specified address is invalid\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\taddressInDecimal = address.longValue();\n-\t\t}\n-\t\telse\n-\t\t{\n+\n+\t\tif (args.length == 0) {\n \t\t\tout.println(\"\\\"hexdump\\\" requires at least an address parameter\");\n \t\t\treturn;\n \t\t}\n-\t\t\n-\t\tif (args.length > 1){\n-\t\t\ttry{\n-\t\t\t\tnumBytesToPrint = Integer.parseInt(args[1]);\n-\t\t\t}catch(NumberFormatException nfe){\n-\t\t\t\tout.println(\"Specified length is invalid\");\n+\n+\t\tlong address;\n+\n+\t\t{\n+\t\t\tLong longAddress = Utils.longFromString(args[0]);\n+\n+\t\t\tif (null != longAddress) {\n+\t\t\t\taddress = longAddress.longValue();\n+\t\t\t} else {\n+\t\t\t\tout.println(\"Specified address is invalid: \" + args[0]);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint numBytesToPrint = 256; // dump 256 bytes by default\n+\n+\t\tif (args.length > 1) {\n+\t\t\ttry {\n+\t\t\t\tnumBytesToPrint = Integer.decode(args[1]);\n+\t\t\t} catch (NumberFormatException e) {\n+\t\t\t\tout.println(\"Specified length is invalid: \" + args[1]);\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n-\t\t\n-\t\tImagePointer imagePointerBase = imageAddressSpace.getPointer(addressInDecimal);\n+\n \t\tboolean is_zOSdump = false;\n+\n \t\ttry {\n-\t\t\tis_zOSdump = ctx.getImage().getSystemType().toLowerCase().indexOf(\"z/os\") >= 0;\n-\t\t} catch (DataUnavailable e1) {\n-\t\t\t// unable to get the dump OS type, continue without the additional zOS EBCDIC option\n-\t\t} catch (CorruptDataException e1) {\n-\t\t\t// unable to get the dump OS type, continue without the additional zOS EBCDIC option\n+\t\t\tis_zOSdump = ctx.getImage().getSystemType().toLowerCase().contains(\"z/os\");\n+\t\t} catch (CorruptDataException | DataUnavailable e) {\n+\t\t\t// unable to get the dump OS type, continue without the additional z/OS EBCDIC option\n \t\t}\n-\t\t\n-\t\tString asciiChars = \"\";\n-\t\tString ebcdicChars = \"\";\n-\t\t\n-\t\tlong i; \n-\t\tfor (i = 0; i < numBytesToPrint; i++){\n-\t\t\tImagePointer imagePointer = imagePointerBase.add(i);\n-\t\t\t//stringBuffer.append(Long.toHexString(addressInDecimal+i)+\":\\t\");\n-\t\t\t//stringBuffer.append(Long.toHexString(imagePointer.getAddress())+\":\\t\");\n+\n+\t\tImagePointer imagePointer = imageAddressSpace.getPointer(address);\n+\t\tStringBuilder lineBuffer = new StringBuilder();\n+\t\tchar[] asciiBlock = new char[16];\n+\t\tchar[] ebcdicBlock = new char[16];\n+\n+\t\tout.println();\n+\n+\t\tfor (int byteOffset = 0; byteOffset < numBytesToPrint; ++byteOffset) {\n \t\t\ttry {\n-\t\t\t\tbyte byteValue = imagePointer.getByteAt(0);\n-\t\t\t\tasciiIndex = byteValue & 0xFF;\n-\n-\t\t\t\tString rawHexString = Integer.toHexString(asciiIndex);\n-\t\t\t\tString fixedHexString = fixHexStringLength(rawHexString);\n-\t\t\t\t\n-\t\t\t\tString hexText = fixedHexString;\n-\t\t\t\tif (0 == i%4){\n-\t\t\t\t\thexText = \" \"+hexText;\n+\t\t\t\tint lineOffset = byteOffset % 16;\n+\n+\t\t\t\tif (0 == lineOffset) {\n+\t\t\t\t\tlineBuffer.append(Long.toHexString(address + byteOffset));\n+\t\t\t\t\tlineBuffer.append(':');\n \t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tif (0 == i%16){\n-\t\t\t\t\thexText  = \"\\n\"+Long.toHexString(imagePointer.getAddress())+\":\"+hexText;\n-\t\t\t\t\tasciiChars = \"  |\";\n-\t\t\t\t\tebcdicChars = \" |\";\n+\n+\t\t\t\tint byteValue = imagePointer.getByteAt(byteOffset) & 0xFF;\n+\n+\t\t\t\tif (0 == (lineOffset % 4)) {\n+\t\t\t\t\tlineBuffer.append(' ');\n \t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tstringBuffer.append(hexText);\n-\t\t\t\t\n-\t\t\t\tasciiChars += Utils.byteToAscii.substring(asciiIndex,asciiIndex+1);\n-\t\t\t\tif (15 == i%16 && i != 0){\n-\t\t\t\t\tasciiChars += \"|\";\n-\t\t\t\t\tstringBuffer.append(asciiChars);\n+\n+\t\t\t\tlineBuffer.append(String.format(\"%02x\", byteValue));\n+\t\t\t\tasciiBlock[lineOffset] = Utils.byteToAscii.charAt(byteValue);\n+\n+\t\t\t\tif (is_zOSdump) {\n+\t\t\t\t\t// for z/OS dumps, output additional EBCDIC interpretation of the memory bytes\n+\t\t\t\t\tebcdicBlock[lineOffset] = Utils.byteToEbcdic.charAt(byteValue);\n \t\t\t\t}\n-\t\t\t\tif (is_zOSdump){\n-\t\t\t\t\t// for zOS dumps, output additional EBCDIC interpretation of the memory byes\n-\t\t\t\t\tebcdicChars += Utils.byteToEbcdic.substring(asciiIndex,asciiIndex+1);\n-\t\t\t\t\tif (15 == i%16 && i != 0){\n-\t\t\t\t\t\tebcdicChars += \"|\";\n-\t\t\t\t\t\tstringBuffer.append(ebcdicChars);\n+\n+\t\t\t\tif (15 == lineOffset) {\n+\t\t\t\t\tlineBuffer.append(\"  |\");\n+\t\t\t\t\tlineBuffer.append(asciiBlock);\n+\t\t\t\t\tlineBuffer.append('|');\n+\n+\t\t\t\t\tif (is_zOSdump) {\n+\t\t\t\t\t\tlineBuffer.append(\" |\");\n+\t\t\t\t\t\tlineBuffer.append(ebcdicBlock);\n+\t\t\t\t\t\tlineBuffer.append('|');\n \t\t\t\t\t}\n+\n+\t\t\t\t\tout.println(lineBuffer.toString());\n+\t\t\t\t\tlineBuffer.setLength(0);\n \t\t\t\t}\n-\t\t\t}catch (MemoryAccessException e) {\n-\t\t\t\tout.println(\"Address not in memory - 0x\" \n-\t\t\t\t\t\t+ Long.toHexString(imagePointer.getAddress()));\n-\t\t\t\treturn;\n-\t\t\t}catch (CorruptDataException e) {\n+\t\t\t} catch (CorruptDataException e) {\n \t\t\t\tout.println(\"Dump data is corrupted\");\n \t\t\t\treturn;\n+\t\t\t} catch (MemoryAccessException e) {\n+\t\t\t\tout.println(\"Address not in memory - 0x\" + Long.toHexString(address + byteOffset));\n+\t\t\t\treturn;\n \t\t\t}\n \t\t}\n-\t\t\n-\t\tlong undisplayedBytes = 16 - i%16; \n-\t\tif (16 != undisplayedBytes){\n-\t\t\tstringBuffer.append(padSpace(undisplayedBytes, asciiChars));\n-\t\t\tif (is_zOSdump){\n-\t\t\t\t// Add padding and output the remaining EBCDIC characters\n-\t\t\t\tfor (int j = 0; j < undisplayedBytes; j++){\n-\t\t\t\t\tebcdicChars = \" \" + ebcdicChars;\n+\n+\t\tint lineOffset = numBytesToPrint % 16;\n+\n+\t\tif (0 != lineOffset) {\n+\t\t\tfor (int offset = lineOffset; offset < 16; ++offset) {\n+\t\t\t\tif (0 == (offset % 4)) {\n+\t\t\t\t\tlineBuffer.append(' ');\n \t\t\t\t}\n-\t\t\t\tstringBuffer.append(\" \" + ebcdicChars);\n+\t\t\t\tlineBuffer.append(\"  \");\n \t\t\t}\n+\n+\t\t\tArrays.fill(asciiBlock, lineOffset, 16, ' ');\n+\t\t\tlineBuffer.append(\"  |\");\n+\t\t\tlineBuffer.append(asciiBlock);\n+\t\t\tlineBuffer.append('|');\n+\n+\t\t\tif (is_zOSdump) {\n+\t\t\t\tArrays.fill(ebcdicBlock, lineOffset, 16, ' ');\n+\t\t\t\tlineBuffer.append(\" |\");\n+\t\t\t\tlineBuffer.append(ebcdicBlock);\n+\t\t\t\tlineBuffer.append('|');\n+\t\t\t}\n+\n+\t\t\tout.println(lineBuffer.toString());\n \t\t}\n-\t\tstringBuffer.append(\"\\n\");\n-\t\tout.println(new String(stringBuffer));\n-\t\t\n-\t\t/*properties.put(Utils.CURRENT_MEM_ADDRESS, \n-\t\t\t\tLong.toHexString(addressInDecimal+numBytesToPrint));*/\n-\t\tctx.getProperties().put(Utils.CURRENT_MEM_ADDRESS, Long.valueOf(addressInDecimal));\n+\n+\t\tout.println();\n+\n+\t\tctx.getProperties().put(Utils.CURRENT_MEM_ADDRESS, Long.valueOf(address));\n \t\tctx.getProperties().put(Utils.CURRENT_NUM_BYTES_TO_PRINT, Integer.valueOf(numBytesToPrint));\n \t}\n-\t\n-\tprivate String padSpace(long undisplayedBytes, String asciiChars){\n-\t\tfor (int i = 0; i < 2*undisplayedBytes + undisplayedBytes/4; i++){\n-\t\t\tasciiChars = \" \" + asciiChars;\n-\t\t}\n-\t\treturn asciiChars;\n-\t}\n-\t\n-\tprivate String fixHexStringLength(String rawHexString){\n-\t\tint length = rawHexString.length();\n-\t\tif (1 == length){\n-\t\t\treturn (\"0\" + rawHexString);\n-\t\t}\n-\t\telse if (2 == length){\n-\t\t\treturn rawHexString;\n-\t\t}\n-\t\telse if (8 == length){\n-\t\t\treturn rawHexString.substring(6, 8);\n-\t\t}\n-\t\telse{\n-\t\t\treturn \"ERROR fixHexStringLength\";\n-\t\t}\n-\t}\n-\t\n+\n \t@Override\n \tpublic void printDetailedHelp(PrintStream out) {\n-\t\tout.println(\"outputs a section of memory in hexadecimal, ascii and ebcdic\\n\\n\" + \n-\t\t\t\t\"parameters: <hex_address> <bytes_to_print>\\n\\n\" +\n-\t\t\t\t\"outputs <bytes_to_print> bytes of memory contents \" +\n-\t\t\t\t\"starting from <hex_address>, ebcdic output is provided for z/OS dumps\"\n-\t\t\t\t);\n-\t\t\n+\t\tout.format(\"outputs a section of memory in hexadecimal, ASCII and EBCDIC%n\"\n+\t\t\t\t+ \"%n\" \n+\t\t\t\t+ \"parameters: <hex_address> <bytes_to_print>%n\" ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0ccf1ed57202ff4be7d26cb4dac678238a3022"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5MjMxNQ==", "bodyText": "Agreed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9359#discussion_r414692315", "createdAt": "2020-04-24T16:07:29Z", "author": {"login": "keithc-ca"}, "path": "jcl/src/openj9.dtfjview/share/classes/com/ibm/jvm/dtfjview/commands/HexdumpCommand.java", "diffHunk": "@@ -37,161 +39,153 @@\n public class HexdumpCommand extends BaseJdmpviewCommand {\n \n \t{\n-\t\taddCommand(\"hexdump\", \"<hex address>\", \"outputs a section of memory in hexadecimal, ascii and ebcdic\");\t\n+\t\taddCommand(\"hexdump\", \"<hex address> [<bytes_to_print>]\", \"outputs a section of memory in hexadecimal, ASCII and EBCDIC\");\t\n \t}\n-\t\n+\n+\t@Override\n \tpublic void run(String command, String[] args, IContext context, PrintStream out) throws CommandException {\n-\t\tif(initCommand(command, args, context, out)) {\n-\t\t\treturn;\t\t//processing already handled by super class\n+\t\tif (initCommand(command, args, context, out)) {\n+\t\t\treturn; // processing already handled by super class\n \t\t}\n \t\tdoCommand(args);\n \t}\n-\t\n-\tpublic void doCommand(String[] args){\n-\t\tStringBuffer stringBuffer = new StringBuffer();\n+\n+\tpublic void doCommand(String[] args) {\n \t\tImageAddressSpace imageAddressSpace = ctx.getAddressSpace();\n-\t\tif(null == imageAddressSpace) {\n+\n+\t\tif (null == imageAddressSpace) {\n \t\t\tout.println(\"Could not find an address space which contains a process in this core file\");\n \t\t\treturn;\n \t\t}\n-\t\tlong addressInDecimal = 0;\n-\t\tint numBytesToPrint = 16*16; //dump 256 bytes by default\n-\t\tint asciiIndex = 0;\n-\t\t\n-\t\tif (args.length != 0){\n-\t\t\tLong address = Utils.longFromString(args[0]);\n-\t\t\tif(null == address){\n-\t\t\t\tout.println(\"Specified address is invalid\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\taddressInDecimal = address.longValue();\n-\t\t}\n-\t\telse\n-\t\t{\n+\n+\t\tif (args.length == 0) {\n \t\t\tout.println(\"\\\"hexdump\\\" requires at least an address parameter\");\n \t\t\treturn;\n \t\t}\n-\t\t\n-\t\tif (args.length > 1){\n-\t\t\ttry{\n-\t\t\t\tnumBytesToPrint = Integer.parseInt(args[1]);\n-\t\t\t}catch(NumberFormatException nfe){\n-\t\t\t\tout.println(\"Specified length is invalid\");\n+\n+\t\tlong address;\n+\n+\t\t{\n+\t\t\tLong longAddress = Utils.longFromString(args[0]);\n+\n+\t\t\tif (null != longAddress) {\n+\t\t\t\taddress = longAddress.longValue();\n+\t\t\t} else {\n+\t\t\t\tout.println(\"Specified address is invalid: \" + args[0]);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint numBytesToPrint = 256; // dump 256 bytes by default\n+\n+\t\tif (args.length > 1) {\n+\t\t\ttry {\n+\t\t\t\tnumBytesToPrint = Integer.decode(args[1]);\n+\t\t\t} catch (NumberFormatException e) {\n+\t\t\t\tout.println(\"Specified length is invalid: \" + args[1]);\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n-\t\t\n-\t\tImagePointer imagePointerBase = imageAddressSpace.getPointer(addressInDecimal);\n+\n \t\tboolean is_zOSdump = false;\n+\n \t\ttry {\n-\t\t\tis_zOSdump = ctx.getImage().getSystemType().toLowerCase().indexOf(\"z/os\") >= 0;\n-\t\t} catch (DataUnavailable e1) {\n-\t\t\t// unable to get the dump OS type, continue without the additional zOS EBCDIC option\n-\t\t} catch (CorruptDataException e1) {\n-\t\t\t// unable to get the dump OS type, continue without the additional zOS EBCDIC option\n+\t\t\tis_zOSdump = ctx.getImage().getSystemType().toLowerCase().contains(\"z/os\");\n+\t\t} catch (CorruptDataException | DataUnavailable e) {\n+\t\t\t// unable to get the dump OS type, continue without the additional z/OS EBCDIC option\n \t\t}\n-\t\t\n-\t\tString asciiChars = \"\";\n-\t\tString ebcdicChars = \"\";\n-\t\t\n-\t\tlong i; \n-\t\tfor (i = 0; i < numBytesToPrint; i++){\n-\t\t\tImagePointer imagePointer = imagePointerBase.add(i);\n-\t\t\t//stringBuffer.append(Long.toHexString(addressInDecimal+i)+\":\\t\");\n-\t\t\t//stringBuffer.append(Long.toHexString(imagePointer.getAddress())+\":\\t\");\n+\n+\t\tImagePointer imagePointer = imageAddressSpace.getPointer(address);\n+\t\tStringBuilder lineBuffer = new StringBuilder();\n+\t\tchar[] asciiBlock = new char[16];\n+\t\tchar[] ebcdicBlock = new char[16];\n+\n+\t\tout.println();\n+\n+\t\tfor (int byteOffset = 0; byteOffset < numBytesToPrint; ++byteOffset) {\n \t\t\ttry {\n-\t\t\t\tbyte byteValue = imagePointer.getByteAt(0);\n-\t\t\t\tasciiIndex = byteValue & 0xFF;\n-\n-\t\t\t\tString rawHexString = Integer.toHexString(asciiIndex);\n-\t\t\t\tString fixedHexString = fixHexStringLength(rawHexString);\n-\t\t\t\t\n-\t\t\t\tString hexText = fixedHexString;\n-\t\t\t\tif (0 == i%4){\n-\t\t\t\t\thexText = \" \"+hexText;\n+\t\t\t\tint lineOffset = byteOffset % 16;\n+\n+\t\t\t\tif (0 == lineOffset) {\n+\t\t\t\t\tlineBuffer.append(Long.toHexString(address + byteOffset));\n+\t\t\t\t\tlineBuffer.append(':');\n \t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tif (0 == i%16){\n-\t\t\t\t\thexText  = \"\\n\"+Long.toHexString(imagePointer.getAddress())+\":\"+hexText;\n-\t\t\t\t\tasciiChars = \"  |\";\n-\t\t\t\t\tebcdicChars = \" |\";\n+\n+\t\t\t\tint byteValue = imagePointer.getByteAt(byteOffset) & 0xFF;\n+\n+\t\t\t\tif (0 == (lineOffset % 4)) {\n+\t\t\t\t\tlineBuffer.append(' ');\n \t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tstringBuffer.append(hexText);\n-\t\t\t\t\n-\t\t\t\tasciiChars += Utils.byteToAscii.substring(asciiIndex,asciiIndex+1);\n-\t\t\t\tif (15 == i%16 && i != 0){\n-\t\t\t\t\tasciiChars += \"|\";\n-\t\t\t\t\tstringBuffer.append(asciiChars);\n+\n+\t\t\t\tlineBuffer.append(String.format(\"%02x\", byteValue));\n+\t\t\t\tasciiBlock[lineOffset] = Utils.byteToAscii.charAt(byteValue);\n+\n+\t\t\t\tif (is_zOSdump) {\n+\t\t\t\t\t// for z/OS dumps, output additional EBCDIC interpretation of the memory bytes\n+\t\t\t\t\tebcdicBlock[lineOffset] = Utils.byteToEbcdic.charAt(byteValue);\n \t\t\t\t}\n-\t\t\t\tif (is_zOSdump){\n-\t\t\t\t\t// for zOS dumps, output additional EBCDIC interpretation of the memory byes\n-\t\t\t\t\tebcdicChars += Utils.byteToEbcdic.substring(asciiIndex,asciiIndex+1);\n-\t\t\t\t\tif (15 == i%16 && i != 0){\n-\t\t\t\t\t\tebcdicChars += \"|\";\n-\t\t\t\t\t\tstringBuffer.append(ebcdicChars);\n+\n+\t\t\t\tif (15 == lineOffset) {\n+\t\t\t\t\tlineBuffer.append(\"  |\");\n+\t\t\t\t\tlineBuffer.append(asciiBlock);\n+\t\t\t\t\tlineBuffer.append('|');\n+\n+\t\t\t\t\tif (is_zOSdump) {\n+\t\t\t\t\t\tlineBuffer.append(\" |\");\n+\t\t\t\t\t\tlineBuffer.append(ebcdicBlock);\n+\t\t\t\t\t\tlineBuffer.append('|');\n \t\t\t\t\t}\n+\n+\t\t\t\t\tout.println(lineBuffer.toString());\n+\t\t\t\t\tlineBuffer.setLength(0);\n \t\t\t\t}\n-\t\t\t}catch (MemoryAccessException e) {\n-\t\t\t\tout.println(\"Address not in memory - 0x\" \n-\t\t\t\t\t\t+ Long.toHexString(imagePointer.getAddress()));\n-\t\t\t\treturn;\n-\t\t\t}catch (CorruptDataException e) {\n+\t\t\t} catch (CorruptDataException e) {\n \t\t\t\tout.println(\"Dump data is corrupted\");\n \t\t\t\treturn;\n+\t\t\t} catch (MemoryAccessException e) {\n+\t\t\t\tout.println(\"Address not in memory - 0x\" + Long.toHexString(address + byteOffset));\n+\t\t\t\treturn;\n \t\t\t}\n \t\t}\n-\t\t\n-\t\tlong undisplayedBytes = 16 - i%16; \n-\t\tif (16 != undisplayedBytes){\n-\t\t\tstringBuffer.append(padSpace(undisplayedBytes, asciiChars));\n-\t\t\tif (is_zOSdump){\n-\t\t\t\t// Add padding and output the remaining EBCDIC characters\n-\t\t\t\tfor (int j = 0; j < undisplayedBytes; j++){\n-\t\t\t\t\tebcdicChars = \" \" + ebcdicChars;\n+\n+\t\tint lineOffset = numBytesToPrint % 16;\n+\n+\t\tif (0 != lineOffset) {\n+\t\t\tfor (int offset = lineOffset; offset < 16; ++offset) {\n+\t\t\t\tif (0 == (offset % 4)) {\n+\t\t\t\t\tlineBuffer.append(' ');\n \t\t\t\t}\n-\t\t\t\tstringBuffer.append(\" \" + ebcdicChars);\n+\t\t\t\tlineBuffer.append(\"  \");\n \t\t\t}\n+\n+\t\t\tArrays.fill(asciiBlock, lineOffset, 16, ' ');\n+\t\t\tlineBuffer.append(\"  |\");\n+\t\t\tlineBuffer.append(asciiBlock);\n+\t\t\tlineBuffer.append('|');\n+\n+\t\t\tif (is_zOSdump) {\n+\t\t\t\tArrays.fill(ebcdicBlock, lineOffset, 16, ' ');\n+\t\t\t\tlineBuffer.append(\" |\");\n+\t\t\t\tlineBuffer.append(ebcdicBlock);\n+\t\t\t\tlineBuffer.append('|');\n+\t\t\t}\n+\n+\t\t\tout.println(lineBuffer.toString());\n \t\t}\n-\t\tstringBuffer.append(\"\\n\");\n-\t\tout.println(new String(stringBuffer));\n-\t\t\n-\t\t/*properties.put(Utils.CURRENT_MEM_ADDRESS, \n-\t\t\t\tLong.toHexString(addressInDecimal+numBytesToPrint));*/\n-\t\tctx.getProperties().put(Utils.CURRENT_MEM_ADDRESS, Long.valueOf(addressInDecimal));\n+\n+\t\tout.println();\n+\n+\t\tctx.getProperties().put(Utils.CURRENT_MEM_ADDRESS, Long.valueOf(address));\n \t\tctx.getProperties().put(Utils.CURRENT_NUM_BYTES_TO_PRINT, Integer.valueOf(numBytesToPrint));\n \t}\n-\t\n-\tprivate String padSpace(long undisplayedBytes, String asciiChars){\n-\t\tfor (int i = 0; i < 2*undisplayedBytes + undisplayedBytes/4; i++){\n-\t\t\tasciiChars = \" \" + asciiChars;\n-\t\t}\n-\t\treturn asciiChars;\n-\t}\n-\t\n-\tprivate String fixHexStringLength(String rawHexString){\n-\t\tint length = rawHexString.length();\n-\t\tif (1 == length){\n-\t\t\treturn (\"0\" + rawHexString);\n-\t\t}\n-\t\telse if (2 == length){\n-\t\t\treturn rawHexString;\n-\t\t}\n-\t\telse if (8 == length){\n-\t\t\treturn rawHexString.substring(6, 8);\n-\t\t}\n-\t\telse{\n-\t\t\treturn \"ERROR fixHexStringLength\";\n-\t\t}\n-\t}\n-\t\n+\n \t@Override\n \tpublic void printDetailedHelp(PrintStream out) {\n-\t\tout.println(\"outputs a section of memory in hexadecimal, ascii and ebcdic\\n\\n\" + \n-\t\t\t\t\"parameters: <hex_address> <bytes_to_print>\\n\\n\" +\n-\t\t\t\t\"outputs <bytes_to_print> bytes of memory contents \" +\n-\t\t\t\t\"starting from <hex_address>, ebcdic output is provided for z/OS dumps\"\n-\t\t\t\t);\n-\t\t\n+\t\tout.format(\"outputs a section of memory in hexadecimal, ASCII and EBCDIC%n\"\n+\t\t\t\t+ \"%n\" \n+\t\t\t\t+ \"parameters: <hex_address> <bytes_to_print>%n\" ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5MTYwNQ=="}, "originalCommit": {"oid": "4a0ccf1ed57202ff4be7d26cb4dac678238a3022"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3Nzg5NTkzOnYy", "diffSide": "RIGHT", "path": "jcl/src/openj9.dtfjview/share/classes/com/ibm/jvm/dtfjview/commands/HexdumpCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjowNjozNFrOGLextQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjowNjozNFrOGLextQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5MTc2NQ==", "bodyText": "I don't think the brackets are needed.", "url": "https://github.com/eclipse-openj9/openj9/pull/9359#discussion_r414691765", "createdAt": "2020-04-24T16:06:34Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.dtfjview/share/classes/com/ibm/jvm/dtfjview/commands/HexdumpCommand.java", "diffHunk": "@@ -37,161 +39,153 @@\n public class HexdumpCommand extends BaseJdmpviewCommand {\n \n \t{\n-\t\taddCommand(\"hexdump\", \"<hex address>\", \"outputs a section of memory in hexadecimal, ascii and ebcdic\");\t\n+\t\taddCommand(\"hexdump\", \"<hex address> [<bytes_to_print>]\", \"outputs a section of memory in hexadecimal, ASCII and EBCDIC\");\t\n \t}\n-\t\n+\n+\t@Override\n \tpublic void run(String command, String[] args, IContext context, PrintStream out) throws CommandException {\n-\t\tif(initCommand(command, args, context, out)) {\n-\t\t\treturn;\t\t//processing already handled by super class\n+\t\tif (initCommand(command, args, context, out)) {\n+\t\t\treturn; // processing already handled by super class\n \t\t}\n \t\tdoCommand(args);\n \t}\n-\t\n-\tpublic void doCommand(String[] args){\n-\t\tStringBuffer stringBuffer = new StringBuffer();\n+\n+\tpublic void doCommand(String[] args) {\n \t\tImageAddressSpace imageAddressSpace = ctx.getAddressSpace();\n-\t\tif(null == imageAddressSpace) {\n+\n+\t\tif (null == imageAddressSpace) {\n \t\t\tout.println(\"Could not find an address space which contains a process in this core file\");\n \t\t\treturn;\n \t\t}\n-\t\tlong addressInDecimal = 0;\n-\t\tint numBytesToPrint = 16*16; //dump 256 bytes by default\n-\t\tint asciiIndex = 0;\n-\t\t\n-\t\tif (args.length != 0){\n-\t\t\tLong address = Utils.longFromString(args[0]);\n-\t\t\tif(null == address){\n-\t\t\t\tout.println(\"Specified address is invalid\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\taddressInDecimal = address.longValue();\n-\t\t}\n-\t\telse\n-\t\t{\n+\n+\t\tif (args.length == 0) {\n \t\t\tout.println(\"\\\"hexdump\\\" requires at least an address parameter\");\n \t\t\treturn;\n \t\t}\n-\t\t\n-\t\tif (args.length > 1){\n-\t\t\ttry{\n-\t\t\t\tnumBytesToPrint = Integer.parseInt(args[1]);\n-\t\t\t}catch(NumberFormatException nfe){\n-\t\t\t\tout.println(\"Specified length is invalid\");\n+\n+\t\tlong address;\n+\n+\t\t{\n+\t\t\tLong longAddress = Utils.longFromString(args[0]);\n+\n+\t\t\tif (null != longAddress) {\n+\t\t\t\taddress = longAddress.longValue();\n+\t\t\t} else {\n+\t\t\t\tout.println(\"Specified address is invalid: \" + args[0]);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint numBytesToPrint = 256; // dump 256 bytes by default\n+\n+\t\tif (args.length > 1) {\n+\t\t\ttry {\n+\t\t\t\tnumBytesToPrint = Integer.decode(args[1]);\n+\t\t\t} catch (NumberFormatException e) {\n+\t\t\t\tout.println(\"Specified length is invalid: \" + args[1]);\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n-\t\t\n-\t\tImagePointer imagePointerBase = imageAddressSpace.getPointer(addressInDecimal);\n+\n \t\tboolean is_zOSdump = false;\n+\n \t\ttry {\n-\t\t\tis_zOSdump = ctx.getImage().getSystemType().toLowerCase().indexOf(\"z/os\") >= 0;\n-\t\t} catch (DataUnavailable e1) {\n-\t\t\t// unable to get the dump OS type, continue without the additional zOS EBCDIC option\n-\t\t} catch (CorruptDataException e1) {\n-\t\t\t// unable to get the dump OS type, continue without the additional zOS EBCDIC option\n+\t\t\tis_zOSdump = ctx.getImage().getSystemType().toLowerCase().contains(\"z/os\");\n+\t\t} catch (CorruptDataException | DataUnavailable e) {\n+\t\t\t// unable to get the dump OS type, continue without the additional z/OS EBCDIC option\n \t\t}\n-\t\t\n-\t\tString asciiChars = \"\";\n-\t\tString ebcdicChars = \"\";\n-\t\t\n-\t\tlong i; \n-\t\tfor (i = 0; i < numBytesToPrint; i++){\n-\t\t\tImagePointer imagePointer = imagePointerBase.add(i);\n-\t\t\t//stringBuffer.append(Long.toHexString(addressInDecimal+i)+\":\\t\");\n-\t\t\t//stringBuffer.append(Long.toHexString(imagePointer.getAddress())+\":\\t\");\n+\n+\t\tImagePointer imagePointer = imageAddressSpace.getPointer(address);\n+\t\tStringBuilder lineBuffer = new StringBuilder();\n+\t\tchar[] asciiBlock = new char[16];\n+\t\tchar[] ebcdicBlock = new char[16];\n+\n+\t\tout.println();\n+\n+\t\tfor (int byteOffset = 0; byteOffset < numBytesToPrint; ++byteOffset) {\n \t\t\ttry {\n-\t\t\t\tbyte byteValue = imagePointer.getByteAt(0);\n-\t\t\t\tasciiIndex = byteValue & 0xFF;\n-\n-\t\t\t\tString rawHexString = Integer.toHexString(asciiIndex);\n-\t\t\t\tString fixedHexString = fixHexStringLength(rawHexString);\n-\t\t\t\t\n-\t\t\t\tString hexText = fixedHexString;\n-\t\t\t\tif (0 == i%4){\n-\t\t\t\t\thexText = \" \"+hexText;\n+\t\t\t\tint lineOffset = byteOffset % 16;\n+\n+\t\t\t\tif (0 == lineOffset) {\n+\t\t\t\t\tlineBuffer.append(Long.toHexString(address + byteOffset));\n+\t\t\t\t\tlineBuffer.append(':');\n \t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tif (0 == i%16){\n-\t\t\t\t\thexText  = \"\\n\"+Long.toHexString(imagePointer.getAddress())+\":\"+hexText;\n-\t\t\t\t\tasciiChars = \"  |\";\n-\t\t\t\t\tebcdicChars = \" |\";\n+\n+\t\t\t\tint byteValue = imagePointer.getByteAt(byteOffset) & 0xFF;\n+\n+\t\t\t\tif (0 == (lineOffset % 4)) {\n+\t\t\t\t\tlineBuffer.append(' ');\n \t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tstringBuffer.append(hexText);\n-\t\t\t\t\n-\t\t\t\tasciiChars += Utils.byteToAscii.substring(asciiIndex,asciiIndex+1);\n-\t\t\t\tif (15 == i%16 && i != 0){\n-\t\t\t\t\tasciiChars += \"|\";\n-\t\t\t\t\tstringBuffer.append(asciiChars);\n+\n+\t\t\t\tlineBuffer.append(String.format(\"%02x\", byteValue));\n+\t\t\t\tasciiBlock[lineOffset] = Utils.byteToAscii.charAt(byteValue);\n+\n+\t\t\t\tif (is_zOSdump) {\n+\t\t\t\t\t// for z/OS dumps, output additional EBCDIC interpretation of the memory bytes\n+\t\t\t\t\tebcdicBlock[lineOffset] = Utils.byteToEbcdic.charAt(byteValue);\n \t\t\t\t}\n-\t\t\t\tif (is_zOSdump){\n-\t\t\t\t\t// for zOS dumps, output additional EBCDIC interpretation of the memory byes\n-\t\t\t\t\tebcdicChars += Utils.byteToEbcdic.substring(asciiIndex,asciiIndex+1);\n-\t\t\t\t\tif (15 == i%16 && i != 0){\n-\t\t\t\t\t\tebcdicChars += \"|\";\n-\t\t\t\t\t\tstringBuffer.append(ebcdicChars);\n+\n+\t\t\t\tif (15 == lineOffset) {\n+\t\t\t\t\tlineBuffer.append(\"  |\");\n+\t\t\t\t\tlineBuffer.append(asciiBlock);\n+\t\t\t\t\tlineBuffer.append('|');\n+\n+\t\t\t\t\tif (is_zOSdump) {\n+\t\t\t\t\t\tlineBuffer.append(\" |\");\n+\t\t\t\t\t\tlineBuffer.append(ebcdicBlock);\n+\t\t\t\t\t\tlineBuffer.append('|');\n \t\t\t\t\t}\n+\n+\t\t\t\t\tout.println(lineBuffer.toString());\n+\t\t\t\t\tlineBuffer.setLength(0);\n \t\t\t\t}\n-\t\t\t}catch (MemoryAccessException e) {\n-\t\t\t\tout.println(\"Address not in memory - 0x\" \n-\t\t\t\t\t\t+ Long.toHexString(imagePointer.getAddress()));\n-\t\t\t\treturn;\n-\t\t\t}catch (CorruptDataException e) {\n+\t\t\t} catch (CorruptDataException e) {\n \t\t\t\tout.println(\"Dump data is corrupted\");\n \t\t\t\treturn;\n+\t\t\t} catch (MemoryAccessException e) {\n+\t\t\t\tout.println(\"Address not in memory - 0x\" + Long.toHexString(address + byteOffset));\n+\t\t\t\treturn;\n \t\t\t}\n \t\t}\n-\t\t\n-\t\tlong undisplayedBytes = 16 - i%16; \n-\t\tif (16 != undisplayedBytes){\n-\t\t\tstringBuffer.append(padSpace(undisplayedBytes, asciiChars));\n-\t\t\tif (is_zOSdump){\n-\t\t\t\t// Add padding and output the remaining EBCDIC characters\n-\t\t\t\tfor (int j = 0; j < undisplayedBytes; j++){\n-\t\t\t\t\tebcdicChars = \" \" + ebcdicChars;\n+\n+\t\tint lineOffset = numBytesToPrint % 16;\n+\n+\t\tif (0 != lineOffset) {\n+\t\t\tfor (int offset = lineOffset; offset < 16; ++offset) {\n+\t\t\t\tif (0 == (offset % 4)) {\n+\t\t\t\t\tlineBuffer.append(' ');\n \t\t\t\t}\n-\t\t\t\tstringBuffer.append(\" \" + ebcdicChars);\n+\t\t\t\tlineBuffer.append(\"  \");\n \t\t\t}\n+\n+\t\t\tArrays.fill(asciiBlock, lineOffset, 16, ' ');\n+\t\t\tlineBuffer.append(\"  |\");\n+\t\t\tlineBuffer.append(asciiBlock);\n+\t\t\tlineBuffer.append('|');\n+\n+\t\t\tif (is_zOSdump) {\n+\t\t\t\tArrays.fill(ebcdicBlock, lineOffset, 16, ' ');\n+\t\t\t\tlineBuffer.append(\" |\");\n+\t\t\t\tlineBuffer.append(ebcdicBlock);\n+\t\t\t\tlineBuffer.append('|');\n+\t\t\t}\n+\n+\t\t\tout.println(lineBuffer.toString());\n \t\t}\n-\t\tstringBuffer.append(\"\\n\");\n-\t\tout.println(new String(stringBuffer));\n-\t\t\n-\t\t/*properties.put(Utils.CURRENT_MEM_ADDRESS, \n-\t\t\t\tLong.toHexString(addressInDecimal+numBytesToPrint));*/\n-\t\tctx.getProperties().put(Utils.CURRENT_MEM_ADDRESS, Long.valueOf(addressInDecimal));\n+\n+\t\tout.println();\n+\n+\t\tctx.getProperties().put(Utils.CURRENT_MEM_ADDRESS, Long.valueOf(address));\n \t\tctx.getProperties().put(Utils.CURRENT_NUM_BYTES_TO_PRINT, Integer.valueOf(numBytesToPrint));\n \t}\n-\t\n-\tprivate String padSpace(long undisplayedBytes, String asciiChars){\n-\t\tfor (int i = 0; i < 2*undisplayedBytes + undisplayedBytes/4; i++){\n-\t\t\tasciiChars = \" \" + asciiChars;\n-\t\t}\n-\t\treturn asciiChars;\n-\t}\n-\t\n-\tprivate String fixHexStringLength(String rawHexString){\n-\t\tint length = rawHexString.length();\n-\t\tif (1 == length){\n-\t\t\treturn (\"0\" + rawHexString);\n-\t\t}\n-\t\telse if (2 == length){\n-\t\t\treturn rawHexString;\n-\t\t}\n-\t\telse if (8 == length){\n-\t\t\treturn rawHexString.substring(6, 8);\n-\t\t}\n-\t\telse{\n-\t\t\treturn \"ERROR fixHexStringLength\";\n-\t\t}\n-\t}\n-\t\n+\n \t@Override\n \tpublic void printDetailedHelp(PrintStream out) {\n-\t\tout.println(\"outputs a section of memory in hexadecimal, ascii and ebcdic\\n\\n\" + \n-\t\t\t\t\"parameters: <hex_address> <bytes_to_print>\\n\\n\" +\n-\t\t\t\t\"outputs <bytes_to_print> bytes of memory contents \" +\n-\t\t\t\t\"starting from <hex_address>, ebcdic output is provided for z/OS dumps\"\n-\t\t\t\t);\n-\t\t\n+\t\tout.format(\"outputs a section of memory in hexadecimal, ASCII and EBCDIC%n\"\n+\t\t\t\t+ \"%n\" \n+\t\t\t\t+ \"parameters: <hex_address> <bytes_to_print>%n\" \n+\t\t\t\t+ \"%n\"\n+\t\t\t\t+ \"outputs <bytes_to_print> bytes of memory contents starting from <hex_address>%n\"\n+\t\t\t\t+ \"(EBCDIC output is also provided for z/OS dumps)%n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0ccf1ed57202ff4be7d26cb4dac678238a3022"}, "originalPosition": 289}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 252, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}