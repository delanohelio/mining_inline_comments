{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxMjAxNTQ5", "number": 11489, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNzozNDowMFrOFGUB6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNzozNDowMFrOFGUB6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMTYzOTQ0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/optimizer/J9Inliner.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNzozNDowMFrOIHRB9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTo1OTowNlrOIIGgPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ4OTk3Mw==", "bodyText": "Should you output the new refined receiver class address that was found as part of this trace message?  Outputting which invokevirtual it was would also be useful.", "url": "https://github.com/eclipse-openj9/openj9/pull/11489#discussion_r544489973", "createdAt": "2020-12-16T17:34:00Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/optimizer/J9Inliner.cpp", "diffHunk": "@@ -552,6 +552,29 @@ bool TR_J9VirtualCallSite::findCallSiteTarget(TR_CallStack *callStack, TR_Inline\n \n    tryToRefineReceiverClassBasedOnResolvedTypeArgInfo(inliner);\n \n+   // Refine receiver class based on CP class\n+   // When we have an invokevirtual on an abstract method defined in an interface class,\n+   // the call site's class will be more concrete than class of method.\n+   // This happens when an abstract class implements an interface class without providing\n+   // implementation for the given method, and the call site is refering to the method of\n+   // the abstract class, the cp entry of the method ref will be resolved to j9method of\n+   // the interface class. However, the class ref from cp will be resolved to the abstract\n+   // class, which is more concrete\n+   //\n+   if (_cpIndex != -1 && _receiverClass && TR::Compiler->cls.isInterfaceClass(comp(), _receiverClass))\n+      {\n+      TR_ResolvedMethod* owningMethod = _initialCalleeMethod->owningMethod();\n+      int32_t classRefCPIndex = owningMethod->classCPIndexOfMethod(_cpIndex);\n+      TR_OpaqueClassBlock* callSiteClass = owningMethod->getClassFromConstantPool(comp(), classRefCPIndex);\n+      if (callSiteClass &&\n+          callSiteClass != _receiverClass &&\n+          fe()->isInstanceOf(callSiteClass, _receiverClass, true, true, false) == TR_yes)\n+         {\n+         heuristicTrace(inliner->tracer(), \"Receiver type is class of an interface method for invokevirtual, improve it to call site receiver type\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1cd10645acacd3fc59d6946382897ae7d949b66"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NjA3Ng==", "bodyText": "@0xdaryl Added change to print out the old and new class info", "url": "https://github.com/eclipse-openj9/openj9/pull/11489#discussion_r545366076", "createdAt": "2020-12-17T19:59:06Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/optimizer/J9Inliner.cpp", "diffHunk": "@@ -552,6 +552,29 @@ bool TR_J9VirtualCallSite::findCallSiteTarget(TR_CallStack *callStack, TR_Inline\n \n    tryToRefineReceiverClassBasedOnResolvedTypeArgInfo(inliner);\n \n+   // Refine receiver class based on CP class\n+   // When we have an invokevirtual on an abstract method defined in an interface class,\n+   // the call site's class will be more concrete than class of method.\n+   // This happens when an abstract class implements an interface class without providing\n+   // implementation for the given method, and the call site is refering to the method of\n+   // the abstract class, the cp entry of the method ref will be resolved to j9method of\n+   // the interface class. However, the class ref from cp will be resolved to the abstract\n+   // class, which is more concrete\n+   //\n+   if (_cpIndex != -1 && _receiverClass && TR::Compiler->cls.isInterfaceClass(comp(), _receiverClass))\n+      {\n+      TR_ResolvedMethod* owningMethod = _initialCalleeMethod->owningMethod();\n+      int32_t classRefCPIndex = owningMethod->classCPIndexOfMethod(_cpIndex);\n+      TR_OpaqueClassBlock* callSiteClass = owningMethod->getClassFromConstantPool(comp(), classRefCPIndex);\n+      if (callSiteClass &&\n+          callSiteClass != _receiverClass &&\n+          fe()->isInstanceOf(callSiteClass, _receiverClass, true, true, false) == TR_yes)\n+         {\n+         heuristicTrace(inliner->tracer(), \"Receiver type is class of an interface method for invokevirtual, improve it to call site receiver type\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ4OTk3Mw=="}, "originalCommit": {"oid": "d1cd10645acacd3fc59d6946382897ae7d949b66"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 880, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}