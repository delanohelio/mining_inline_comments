{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MjcyMzU0", "number": 9745, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzozNToxMlrOEBc7Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMToyOTo1NlrOECvdrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTU3OTEwOnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/EnvironmentDelegate.cpp", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzozNToxMlrOGdToIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMDozMjo0OVrOGdZHMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng==", "bodyText": "Looks like the question I asked about support for dual TLH mode applies here: Am I reading correctly that if we set size for both TLHs we can get 2 * size to be allocated potentially?", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433383456", "createdAt": "2020-06-01T17:35:12Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/EnvironmentDelegate.cpp", "diffHunk": "@@ -252,58 +252,134 @@ MM_EnvironmentDelegate::forceOutOfLineVMAccess()\n \n #if defined (J9VM_GC_THREAD_LOCAL_HEAP)\n /**\n- * Disable inline TLH allocates by hiding the real heap allocation address from\n- * JIT/Interpreter in realHeapAlloc and setting heapALloc == HeapTop so TLH\n+ * Disable inline TLH allocates by hiding the real heap top address from\n+ * JIT/Interpreter in realHeapTop and setting HeapTop == heapALloc so TLH\n  * looks full.\n  *\n  */\n void\n MM_EnvironmentDelegate::disableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->heapAlloc;\n-\t_vmThread->heapAlloc = _vmThread->heapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t}\n+\t_vmThread->heapTop = _vmThread->heapAlloc;\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->nonZeroHeapAlloc;\n-\t_vmThread->nonZeroHeapAlloc = _vmThread->nonZeroHeapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t}\n+\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc;\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Re-enable inline TLH allocate by restoring heapAlloc from realHeapAlloc\n+ * Re-enable inline TLH allocate by restoring heapTop from realHeapTop\n  */\n void\n MM_EnvironmentDelegate::enableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\t_vmThread->heapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\t_vmThread->nonZeroHeapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Determine if inline TLH allocate is enabled; its enabled if realheapAlloc is NULL.\n+ * Determine if inline TLH allocate is enabled; its enabled if realheapTop is NULL.\n  * @return TRUE if inline TLH allocates currently enabled for this thread; FALSE otherwise\n  */\n bool\n MM_EnvironmentDelegate::isInlineTLHAllocateEnabled()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\tbool result = (NULL == tlh->realHeapAlloc);\n+\tbool result = (NULL == tlh->realHeapTop);\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\tresult = result && (NULL == tlh->realHeapAlloc);\n+\tresult = result && (NULL == tlh->realHeapTop);\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n \n \treturn result;\n }\n+\n+\n+void\n+MM_EnvironmentDelegate::setTLHSamplingTop(uintptr_t size)\n+{\n+\tuintptr_t max = 0;\n+\tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->heapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->heapTop - _vmThread->heapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t\t}\n+\t\t_vmThread->heapTop = _vmThread->heapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}\n+\n+#if defined(J9VM_GC_NON_ZERO_TLH)\n+\t/* TODO: need to find better way set TLH sampling Top for NON ZERO case */\n+\ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->nonZeroHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t\t}\n+\t\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cdfcf384b05e280d57036a02e54c3ae361e7805"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQwOTI3MQ==", "bodyText": "yes, we might not get very accurate result on nonzero case,have not found the better way to handle the non zero case.", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433409271", "createdAt": "2020-06-01T18:24:06Z", "author": {"login": "LinHu2016"}, "path": "runtime/gc_glue_java/EnvironmentDelegate.cpp", "diffHunk": "@@ -252,58 +252,134 @@ MM_EnvironmentDelegate::forceOutOfLineVMAccess()\n \n #if defined (J9VM_GC_THREAD_LOCAL_HEAP)\n /**\n- * Disable inline TLH allocates by hiding the real heap allocation address from\n- * JIT/Interpreter in realHeapAlloc and setting heapALloc == HeapTop so TLH\n+ * Disable inline TLH allocates by hiding the real heap top address from\n+ * JIT/Interpreter in realHeapTop and setting HeapTop == heapALloc so TLH\n  * looks full.\n  *\n  */\n void\n MM_EnvironmentDelegate::disableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->heapAlloc;\n-\t_vmThread->heapAlloc = _vmThread->heapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t}\n+\t_vmThread->heapTop = _vmThread->heapAlloc;\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->nonZeroHeapAlloc;\n-\t_vmThread->nonZeroHeapAlloc = _vmThread->nonZeroHeapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t}\n+\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc;\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Re-enable inline TLH allocate by restoring heapAlloc from realHeapAlloc\n+ * Re-enable inline TLH allocate by restoring heapTop from realHeapTop\n  */\n void\n MM_EnvironmentDelegate::enableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\t_vmThread->heapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\t_vmThread->nonZeroHeapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Determine if inline TLH allocate is enabled; its enabled if realheapAlloc is NULL.\n+ * Determine if inline TLH allocate is enabled; its enabled if realheapTop is NULL.\n  * @return TRUE if inline TLH allocates currently enabled for this thread; FALSE otherwise\n  */\n bool\n MM_EnvironmentDelegate::isInlineTLHAllocateEnabled()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\tbool result = (NULL == tlh->realHeapAlloc);\n+\tbool result = (NULL == tlh->realHeapTop);\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\tresult = result && (NULL == tlh->realHeapAlloc);\n+\tresult = result && (NULL == tlh->realHeapTop);\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n \n \treturn result;\n }\n+\n+\n+void\n+MM_EnvironmentDelegate::setTLHSamplingTop(uintptr_t size)\n+{\n+\tuintptr_t max = 0;\n+\tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->heapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->heapTop - _vmThread->heapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t\t}\n+\t\t_vmThread->heapTop = _vmThread->heapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}\n+\n+#if defined(J9VM_GC_NON_ZERO_TLH)\n+\t/* TODO: need to find better way set TLH sampling Top for NON ZERO case */\n+\ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->nonZeroHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t\t}\n+\t\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng=="}, "originalCommit": {"oid": "0cdfcf384b05e280d57036a02e54c3ae361e7805"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MjMwOA==", "bodyText": "Do we have a platform that can actually have both active (btw, is X using just nonZeroHeapAlloc/Top?)?  I'm willing to ignore that issue for now, if we think it will take more than a day to do/test it and we can follow up after the upcoming release (by as you said disabling one of two TLHs).", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433462308", "createdAt": "2020-06-01T20:10:05Z", "author": {"login": "amicic"}, "path": "runtime/gc_glue_java/EnvironmentDelegate.cpp", "diffHunk": "@@ -252,58 +252,134 @@ MM_EnvironmentDelegate::forceOutOfLineVMAccess()\n \n #if defined (J9VM_GC_THREAD_LOCAL_HEAP)\n /**\n- * Disable inline TLH allocates by hiding the real heap allocation address from\n- * JIT/Interpreter in realHeapAlloc and setting heapALloc == HeapTop so TLH\n+ * Disable inline TLH allocates by hiding the real heap top address from\n+ * JIT/Interpreter in realHeapTop and setting HeapTop == heapALloc so TLH\n  * looks full.\n  *\n  */\n void\n MM_EnvironmentDelegate::disableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->heapAlloc;\n-\t_vmThread->heapAlloc = _vmThread->heapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t}\n+\t_vmThread->heapTop = _vmThread->heapAlloc;\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->nonZeroHeapAlloc;\n-\t_vmThread->nonZeroHeapAlloc = _vmThread->nonZeroHeapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t}\n+\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc;\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Re-enable inline TLH allocate by restoring heapAlloc from realHeapAlloc\n+ * Re-enable inline TLH allocate by restoring heapTop from realHeapTop\n  */\n void\n MM_EnvironmentDelegate::enableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\t_vmThread->heapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\t_vmThread->nonZeroHeapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Determine if inline TLH allocate is enabled; its enabled if realheapAlloc is NULL.\n+ * Determine if inline TLH allocate is enabled; its enabled if realheapTop is NULL.\n  * @return TRUE if inline TLH allocates currently enabled for this thread; FALSE otherwise\n  */\n bool\n MM_EnvironmentDelegate::isInlineTLHAllocateEnabled()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\tbool result = (NULL == tlh->realHeapAlloc);\n+\tbool result = (NULL == tlh->realHeapTop);\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\tresult = result && (NULL == tlh->realHeapAlloc);\n+\tresult = result && (NULL == tlh->realHeapTop);\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n \n \treturn result;\n }\n+\n+\n+void\n+MM_EnvironmentDelegate::setTLHSamplingTop(uintptr_t size)\n+{\n+\tuintptr_t max = 0;\n+\tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->heapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->heapTop - _vmThread->heapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t\t}\n+\t\t_vmThread->heapTop = _vmThread->heapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}\n+\n+#if defined(J9VM_GC_NON_ZERO_TLH)\n+\t/* TODO: need to find better way set TLH sampling Top for NON ZERO case */\n+\ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->nonZeroHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t\t}\n+\t\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng=="}, "originalCommit": {"oid": "0cdfcf384b05e280d57036a02e54c3ae361e7805"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NjgxMA==", "bodyText": "I believe non-Zeroed TLH is using on pLinux (LE and BE) and AIX. I am not sure about current status of zLinux.", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433466810", "createdAt": "2020-06-01T20:19:26Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/EnvironmentDelegate.cpp", "diffHunk": "@@ -252,58 +252,134 @@ MM_EnvironmentDelegate::forceOutOfLineVMAccess()\n \n #if defined (J9VM_GC_THREAD_LOCAL_HEAP)\n /**\n- * Disable inline TLH allocates by hiding the real heap allocation address from\n- * JIT/Interpreter in realHeapAlloc and setting heapALloc == HeapTop so TLH\n+ * Disable inline TLH allocates by hiding the real heap top address from\n+ * JIT/Interpreter in realHeapTop and setting HeapTop == heapALloc so TLH\n  * looks full.\n  *\n  */\n void\n MM_EnvironmentDelegate::disableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->heapAlloc;\n-\t_vmThread->heapAlloc = _vmThread->heapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t}\n+\t_vmThread->heapTop = _vmThread->heapAlloc;\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->nonZeroHeapAlloc;\n-\t_vmThread->nonZeroHeapAlloc = _vmThread->nonZeroHeapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t}\n+\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc;\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Re-enable inline TLH allocate by restoring heapAlloc from realHeapAlloc\n+ * Re-enable inline TLH allocate by restoring heapTop from realHeapTop\n  */\n void\n MM_EnvironmentDelegate::enableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\t_vmThread->heapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\t_vmThread->nonZeroHeapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Determine if inline TLH allocate is enabled; its enabled if realheapAlloc is NULL.\n+ * Determine if inline TLH allocate is enabled; its enabled if realheapTop is NULL.\n  * @return TRUE if inline TLH allocates currently enabled for this thread; FALSE otherwise\n  */\n bool\n MM_EnvironmentDelegate::isInlineTLHAllocateEnabled()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\tbool result = (NULL == tlh->realHeapAlloc);\n+\tbool result = (NULL == tlh->realHeapTop);\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\tresult = result && (NULL == tlh->realHeapAlloc);\n+\tresult = result && (NULL == tlh->realHeapTop);\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n \n \treturn result;\n }\n+\n+\n+void\n+MM_EnvironmentDelegate::setTLHSamplingTop(uintptr_t size)\n+{\n+\tuintptr_t max = 0;\n+\tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->heapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->heapTop - _vmThread->heapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t\t}\n+\t\t_vmThread->heapTop = _vmThread->heapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}\n+\n+#if defined(J9VM_GC_NON_ZERO_TLH)\n+\t/* TODO: need to find better way set TLH sampling Top for NON ZERO case */\n+\ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->nonZeroHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t\t}\n+\t\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng=="}, "originalCommit": {"oid": "0cdfcf384b05e280d57036a02e54c3ae361e7805"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2OTQwMw==", "bodyText": "Non-zero TLH can be used for primitive arrays only. So to see a mismatch an application should include primitive arrays to the allocation mix.", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433469403", "createdAt": "2020-06-01T20:24:45Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/EnvironmentDelegate.cpp", "diffHunk": "@@ -252,58 +252,134 @@ MM_EnvironmentDelegate::forceOutOfLineVMAccess()\n \n #if defined (J9VM_GC_THREAD_LOCAL_HEAP)\n /**\n- * Disable inline TLH allocates by hiding the real heap allocation address from\n- * JIT/Interpreter in realHeapAlloc and setting heapALloc == HeapTop so TLH\n+ * Disable inline TLH allocates by hiding the real heap top address from\n+ * JIT/Interpreter in realHeapTop and setting HeapTop == heapALloc so TLH\n  * looks full.\n  *\n  */\n void\n MM_EnvironmentDelegate::disableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->heapAlloc;\n-\t_vmThread->heapAlloc = _vmThread->heapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t}\n+\t_vmThread->heapTop = _vmThread->heapAlloc;\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->nonZeroHeapAlloc;\n-\t_vmThread->nonZeroHeapAlloc = _vmThread->nonZeroHeapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t}\n+\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc;\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Re-enable inline TLH allocate by restoring heapAlloc from realHeapAlloc\n+ * Re-enable inline TLH allocate by restoring heapTop from realHeapTop\n  */\n void\n MM_EnvironmentDelegate::enableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\t_vmThread->heapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\t_vmThread->nonZeroHeapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Determine if inline TLH allocate is enabled; its enabled if realheapAlloc is NULL.\n+ * Determine if inline TLH allocate is enabled; its enabled if realheapTop is NULL.\n  * @return TRUE if inline TLH allocates currently enabled for this thread; FALSE otherwise\n  */\n bool\n MM_EnvironmentDelegate::isInlineTLHAllocateEnabled()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\tbool result = (NULL == tlh->realHeapAlloc);\n+\tbool result = (NULL == tlh->realHeapTop);\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\tresult = result && (NULL == tlh->realHeapAlloc);\n+\tresult = result && (NULL == tlh->realHeapTop);\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n \n \treturn result;\n }\n+\n+\n+void\n+MM_EnvironmentDelegate::setTLHSamplingTop(uintptr_t size)\n+{\n+\tuintptr_t max = 0;\n+\tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->heapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->heapTop - _vmThread->heapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t\t}\n+\t\t_vmThread->heapTop = _vmThread->heapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}\n+\n+#if defined(J9VM_GC_NON_ZERO_TLH)\n+\t/* TODO: need to find better way set TLH sampling Top for NON ZERO case */\n+\ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->nonZeroHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t\t}\n+\t\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng=="}, "originalCommit": {"oid": "0cdfcf384b05e280d57036a02e54c3ae361e7805"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ3MzMzMA==", "bodyText": "I agree that proper handling for dual TLH case can be done later in separate change", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r433473330", "createdAt": "2020-06-01T20:32:49Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/EnvironmentDelegate.cpp", "diffHunk": "@@ -252,58 +252,134 @@ MM_EnvironmentDelegate::forceOutOfLineVMAccess()\n \n #if defined (J9VM_GC_THREAD_LOCAL_HEAP)\n /**\n- * Disable inline TLH allocates by hiding the real heap allocation address from\n- * JIT/Interpreter in realHeapAlloc and setting heapALloc == HeapTop so TLH\n+ * Disable inline TLH allocates by hiding the real heap top address from\n+ * JIT/Interpreter in realHeapTop and setting HeapTop == heapALloc so TLH\n  * looks full.\n  *\n  */\n void\n MM_EnvironmentDelegate::disableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->heapAlloc;\n-\t_vmThread->heapAlloc = _vmThread->heapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t}\n+\t_vmThread->heapTop = _vmThread->heapAlloc;\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\ttlh->realHeapAlloc = _vmThread->nonZeroHeapAlloc;\n-\t_vmThread->nonZeroHeapAlloc = _vmThread->nonZeroHeapTop;\n+\tif (NULL == tlh->realHeapTop) {\n+\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t}\n+\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc;\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Re-enable inline TLH allocate by restoring heapAlloc from realHeapAlloc\n+ * Re-enable inline TLH allocate by restoring heapTop from realHeapTop\n  */\n void\n MM_EnvironmentDelegate::enableInlineTLHAllocate()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\t_vmThread->heapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\t_vmThread->nonZeroHeapAlloc =  tlh->realHeapAlloc;\n-\ttlh->realHeapAlloc = NULL;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\ttlh->realHeapTop = NULL;\n+\t}\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n }\n \n /**\n- * Determine if inline TLH allocate is enabled; its enabled if realheapAlloc is NULL.\n+ * Determine if inline TLH allocate is enabled; its enabled if realheapTop is NULL.\n  * @return TRUE if inline TLH allocates currently enabled for this thread; FALSE otherwise\n  */\n bool\n MM_EnvironmentDelegate::isInlineTLHAllocateEnabled()\n {\n \tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n-\tbool result = (NULL == tlh->realHeapAlloc);\n+\tbool result = (NULL == tlh->realHeapTop);\n \n #if defined(J9VM_GC_NON_ZERO_TLH)\n \ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n-\tresult = result && (NULL == tlh->realHeapAlloc);\n+\tresult = result && (NULL == tlh->realHeapTop);\n #endif /* defined(J9VM_GC_NON_ZERO_TLH) */\n \n \treturn result;\n }\n+\n+\n+void\n+MM_EnvironmentDelegate::setTLHSamplingTop(uintptr_t size)\n+{\n+\tuintptr_t max = 0;\n+\tJ9ModronThreadLocalHeap *tlh = (J9ModronThreadLocalHeap *)&_vmThread->allocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->heapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->heapTop - _vmThread->heapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->heapTop;\n+\t\t}\n+\t\t_vmThread->heapTop = _vmThread->heapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->heapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}\n+\n+#if defined(J9VM_GC_NON_ZERO_TLH)\n+\t/* TODO: need to find better way set TLH sampling Top for NON ZERO case */\n+\ttlh = (J9ModronThreadLocalHeap *)&_vmThread->nonZeroAllocateThreadLocalHeap;\n+\tif (NULL != tlh->realHeapTop) {\n+\t\tmax = tlh->realHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t} else {\n+\t\tmax = _vmThread->nonZeroHeapTop - _vmThread->nonZeroHeapAlloc;\n+\t}\n+\n+\tif (max > size) {\n+\t\tif (NULL == tlh->realHeapTop) {\n+\t\t\ttlh->realHeapTop = _vmThread->nonZeroHeapTop;\n+\t\t}\n+\t\t_vmThread->nonZeroHeapTop = _vmThread->nonZeroHeapAlloc + size;\n+\t} else {\n+\t\tif (NULL != tlh->realHeapTop) {\n+\t\t\t_vmThread->nonZeroHeapTop =  tlh->realHeapTop;\n+\t\t\ttlh->realHeapTop = NULL;\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzQ1Ng=="}, "originalCommit": {"oid": "0cdfcf384b05e280d57036a02e54c3ae361e7805"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzEwMjU0OnYy", "diffSide": "RIGHT", "path": "debugtools/DDR_VM/src/com/ibm/j9ddr/vm29/j9/gc/GCObjectHeapIteratorAddressOrderedList_V1.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMToyOTo1NlrOGfYtrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjozNzowM1rOGfaTiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2Mzk0OQ==", "bodyText": "This will fail with NoSuchFieldError when examining core files created before the addition of realHeapTop.", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r435563949", "createdAt": "2020-06-04T21:29:56Z", "author": {"login": "keithc-ca"}, "path": "debugtools/DDR_VM/src/com/ibm/j9ddr/vm29/j9/gc/GCObjectHeapIteratorAddressOrderedList_V1.java", "diffHunk": "@@ -75,9 +75,9 @@ protected GCObjectHeapIteratorAddressOrderedList_V1(U8Pointer base, U8Pointer to\n \t\t\t\t\t\texcludedRangeList.add(new U8Pointer[] {heapAlloc, heapTop});\n \t\t\t\t\t} else {\n \t\t\t\t\t\t/* Might be an instrumented VM */\n-\t\t\t\t\t\tU8Pointer realHeapAlloc = adjustedToRange(vmThread.allocateThreadLocalHeap().realHeapAlloc(), base, top);\n-\t\t\t\t\t\tif(realHeapAlloc.notNull() && isSomethingToAdd(realHeapAlloc, heapTop)) {\n-\t\t\t\t\t\t\texcludedRangeList.add(new U8Pointer[] {realHeapAlloc, heapTop});\n+\t\t\t\t\t\tU8Pointer realHeapTop = adjustedToRange(vmThread.allocateThreadLocalHeap().realHeapTop(), base, top);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2dd5591146ad6d9c1690cd2be03d9dd7e187452"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5MDAyNQ==", "bodyText": "Good point, thank you very much.", "url": "https://github.com/eclipse-openj9/openj9/pull/9745#discussion_r435590025", "createdAt": "2020-06-04T22:37:03Z", "author": {"login": "dmitripivkine"}, "path": "debugtools/DDR_VM/src/com/ibm/j9ddr/vm29/j9/gc/GCObjectHeapIteratorAddressOrderedList_V1.java", "diffHunk": "@@ -75,9 +75,9 @@ protected GCObjectHeapIteratorAddressOrderedList_V1(U8Pointer base, U8Pointer to\n \t\t\t\t\t\texcludedRangeList.add(new U8Pointer[] {heapAlloc, heapTop});\n \t\t\t\t\t} else {\n \t\t\t\t\t\t/* Might be an instrumented VM */\n-\t\t\t\t\t\tU8Pointer realHeapAlloc = adjustedToRange(vmThread.allocateThreadLocalHeap().realHeapAlloc(), base, top);\n-\t\t\t\t\t\tif(realHeapAlloc.notNull() && isSomethingToAdd(realHeapAlloc, heapTop)) {\n-\t\t\t\t\t\t\texcludedRangeList.add(new U8Pointer[] {realHeapAlloc, heapTop});\n+\t\t\t\t\t\tU8Pointer realHeapTop = adjustedToRange(vmThread.allocateThreadLocalHeap().realHeapTop(), base, top);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2Mzk0OQ=="}, "originalCommit": {"oid": "d2dd5591146ad6d9c1690cd2be03d9dd7e187452"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 96, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}