{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMTI1NzA2", "number": 8680, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMzowMDowNFrODjroLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDowMDozN1rODmsN9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzQxNTUwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMzowMDowNFrOFvoKHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMzowMjoyN1rOFvoMBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ4NTM0Mw==", "bodyText": "vmThread is available at the beginning of this method. Use that instead.", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385485343", "createdAt": "2020-02-28T03:00:04Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -500,6 +500,19 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          vmInfo._floatInvokeExactThunkHelper = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_icallVMprJavaSendInvokeExactF, false, false, false)->getMethodAddress();\n          vmInfo._doubleInvokeExactThunkHelper = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_icallVMprJavaSendInvokeExactD, false, false, false)->getMethodAddress();\n          vmInfo._interpreterVTableOffset = TR::Compiler->vm.getInterpreterVTableOffset();\n+         vmInfo._jlrMethodInvoke = fe->_vmThread->javaVM->jlrMethodInvoke;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36f6b2b1805466b7799f6a0bc99b369bb52a403"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ4NTUwNw==", "bodyText": "Since javaVM is used in several places you could store to a local and use that instead.", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385485507", "createdAt": "2020-02-28T03:00:49Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -500,6 +500,19 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          vmInfo._floatInvokeExactThunkHelper = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_icallVMprJavaSendInvokeExactF, false, false, false)->getMethodAddress();\n          vmInfo._doubleInvokeExactThunkHelper = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_icallVMprJavaSendInvokeExactD, false, false, false)->getMethodAddress();\n          vmInfo._interpreterVTableOffset = TR::Compiler->vm.getInterpreterVTableOffset();\n+         vmInfo._jlrMethodInvoke = fe->_vmThread->javaVM->jlrMethodInvoke;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ4NTM0Mw=="}, "originalCommit": {"oid": "b36f6b2b1805466b7799f6a0bc99b369bb52a403"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ4NTgyOA==", "bodyText": "I think you need to acquire VMAccess because you are working with objects which can be changed by GC", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385485828", "createdAt": "2020-02-28T03:02:27Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -500,6 +500,19 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          vmInfo._floatInvokeExactThunkHelper = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_icallVMprJavaSendInvokeExactF, false, false, false)->getMethodAddress();\n          vmInfo._doubleInvokeExactThunkHelper = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_icallVMprJavaSendInvokeExactD, false, false, false)->getMethodAddress();\n          vmInfo._interpreterVTableOffset = TR::Compiler->vm.getInterpreterVTableOffset();\n+         vmInfo._jlrMethodInvoke = fe->_vmThread->javaVM->jlrMethodInvoke;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ4NTM0Mw=="}, "originalCommit": {"oid": "b36f6b2b1805466b7799f6a0bc99b369bb52a403"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzQyMTU3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9Server.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMzowNDo1MFrOFvoN1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMzowODoxOFrOFvoQzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ4NjI5NA==", "bodyText": "getOrCacheVMInfo is called several times. better to call it once and store the answer in a local reference.", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385486294", "createdAt": "2020-02-28T03:04:50Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,7 +692,44 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+   \n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+\n+   if (_compInfoPT->getClientData()->getOrCacheVMInfo(stream)->_jlrMethodInvoke == NULL || ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36f6b2b1805466b7799f6a0bc99b369bb52a403"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ4NzA1NA==", "bodyText": "If _jlrMethodInvoke is NULL you have to send a message because it may have became non-null since the last time we checked.", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385487054", "createdAt": "2020-02-28T03:08:18Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,7 +692,44 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+   \n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+\n+   if (_compInfoPT->getClientData()->getOrCacheVMInfo(stream)->_jlrMethodInvoke == NULL || ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ4NjI5NA=="}, "originalCommit": {"oid": "b36f6b2b1805466b7799f6a0bc99b369bb52a403"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzQyODI3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9Server.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMzoxMDowM1rOFvoSHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDozMjozOFrOFv25QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ4NzM4OA==", "bodyText": "I don't see _jlrAccessibleObjectClass set anywhere in the VM. We need to ask about this and maybe we can remove it completely", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385487388", "createdAt": "2020-02-28T03:10:03Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,7 +692,44 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+   \n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+\n+   if (_compInfoPT->getClientData()->getOrCacheVMInfo(stream)->_jlrMethodInvoke == NULL || \n+         _compInfoPT->getClientData()->getOrCacheVMInfo(stream)->_jlrMethodInvoke == ((J9Method *) method))\n+      {\n+      return true;\n+      }\n+\n+   if(!clazz)\n+      {\n+      return false;\n+      }\n+\n+   TR_OpaqueClassBlock * jlrAccessibleObjectClass = _compInfoPT->getClientData()->getOrCacheVMInfo(stream)->_jlrAccessibleObjectClass;\n+   if (jlrAccessibleObjectClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, jlrAccessibleObjectClass ,false))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36f6b2b1805466b7799f6a0bc99b369bb52a403"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyNjc4NA==", "bodyText": "I believe it's obsolete, in 2011 there was a commit \"never initialize vm->jlrAccessibleObject again, and stop checking against it in stackwalks as we will always be J2SE_SHAPE_SUN\"", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385726784", "createdAt": "2020-02-28T14:32:38Z", "author": {"login": "pshipton"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,7 +692,44 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+   \n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+\n+   if (_compInfoPT->getClientData()->getOrCacheVMInfo(stream)->_jlrMethodInvoke == NULL || \n+         _compInfoPT->getClientData()->getOrCacheVMInfo(stream)->_jlrMethodInvoke == ((J9Method *) method))\n+      {\n+      return true;\n+      }\n+\n+   if(!clazz)\n+      {\n+      return false;\n+      }\n+\n+   TR_OpaqueClassBlock * jlrAccessibleObjectClass = _compInfoPT->getClientData()->getOrCacheVMInfo(stream)->_jlrAccessibleObjectClass;\n+   if (jlrAccessibleObjectClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, jlrAccessibleObjectClass ,false))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ4NzM4OA=="}, "originalCommit": {"oid": "b36f6b2b1805466b7799f6a0bc99b369bb52a403"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTUwNTQxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjo1MTo0MFrOFv7vzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjo1MTo0MFrOFv7vzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNjI4NA==", "bodyText": "You need to create a block here with { } so that we leave the critical section as soon as possible", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385806284", "createdAt": "2020-02-28T16:51:40Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -500,6 +501,18 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          vmInfo._floatInvokeExactThunkHelper = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_icallVMprJavaSendInvokeExactF, false, false, false)->getMethodAddress();\n          vmInfo._doubleInvokeExactThunkHelper = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_icallVMprJavaSendInvokeExactD, false, false, false)->getMethodAddress();\n          vmInfo._interpreterVTableOffset = TR::Compiler->vm.getInterpreterVTableOffset();\n+         TR::VMAccessCriticalSection getVMInfo(fe);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f604cad07a52f020487fb7cbe033dbbbdd8a421c"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTUzMzgwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9Server.cpp", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzowMDoxMlrOFv8BYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwMDo1MjoyN1rOFwGkmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMDc4NQ==", "bodyText": "If vmInfo->jlrMethodInvoke is null you have to send a message to the client to get updated information. This message is actually JITServer::MessageType::VM_stackWalkerMaySkipFrames, but change it such that it returns the value of vmInfo->jlrMethodInvoke as well so that we can update at the server.", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385810785", "createdAt": "2020-02-28T17:00:12Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,7 +692,33 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+   auto *vmInfo = _compInfoPT->getClientData()->getOrCacheVMInfo(stream);\n+   \n+   if (vmInfo->_jlrMethodInvoke == ((J9Method *) method))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f604cad07a52f020487fb7cbe033dbbbdd8a421c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzODcxMg==", "bodyText": "Thanks. Lets see if I am understanding this correctly.\nThis JITServer::MessageType::VM_stackWalkerMaySkipFrames message currently returns a bool value which is the return value of stackWalkerMaySkipFrames function at client. I need to change this VM_stackWalkerMaySkipFrames message so that it returns the value of vmInfo->jlrMethodInvoke. Shall we change the name of this message then?\nIf vmInfo->jlrMethodInvoke is NULL, we send a message and once have the new vmInfo->jlrMethodInvoke  value on the server, we can cache the value inside VMInfo.", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385838712", "createdAt": "2020-02-28T17:57:16Z", "author": {"login": "chrisc66"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,7 +692,33 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+   auto *vmInfo = _compInfoPT->getClientData()->getOrCacheVMInfo(stream);\n+   \n+   if (vmInfo->_jlrMethodInvoke == ((J9Method *) method))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMDc4NQ=="}, "originalCommit": {"oid": "f604cad07a52f020487fb7cbe033dbbbdd8a421c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5Nzg1OQ==", "bodyText": "we can cache the value inside VMInfo.\n\nNote, that cache will need to be updated if the java.lang.reflect.Method class is redefined.", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385897859", "createdAt": "2020-02-28T20:04:59Z", "author": {"login": "DanHeidinga"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,7 +692,33 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+   auto *vmInfo = _compInfoPT->getClientData()->getOrCacheVMInfo(stream);\n+   \n+   if (vmInfo->_jlrMethodInvoke == ((J9Method *) method))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMDc4NQ=="}, "originalCommit": {"oid": "f604cad07a52f020487fb7cbe033dbbbdd8a421c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4MzY0Mw==", "bodyText": "cache will need to be updated if the java.lang.reflect.Method class is redefined.\n\n@DanHeidinga  I looked where vmInfo->jlrMethodInvoke is set and there is only one place: in standardInit() called from scarInit(J9JavaVM * vm) called from J9VMDllMain(J9JavaVM* vm, IDATA stage, void* reserved) with a stage of JCL_INITIALIZED. Thus, if java.lang.reflect.Method class is redefined, don't we have to update vmInfo->jlrMethodInvoke  as well?", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385983643", "createdAt": "2020-02-29T00:52:27Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,7 +692,33 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+   auto *vmInfo = _compInfoPT->getClientData()->getOrCacheVMInfo(stream);\n+   \n+   if (vmInfo->_jlrMethodInvoke == ((J9Method *) method))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMDc4NQ=="}, "originalCommit": {"oid": "f604cad07a52f020487fb7cbe033dbbbdd8a421c"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTUzNzY4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9Server.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzowMTozMVrOFv8D6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzowMTozMVrOFv8D6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMTQzNQ==", "bodyText": "Here we just return false, we don't need to send another message.", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385811435", "createdAt": "2020-02-28T17:01:31Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,7 +692,33 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n+   auto *vmInfo = _compInfoPT->getClientData()->getOrCacheVMInfo(stream);\n+   \n+   if (vmInfo->_jlrMethodInvoke == ((J9Method *) method))\n+      {\n+      return true;\n+      }\n+   if(!clazz)\n+      {\n+      return false;\n+      }\n+#if defined(J9VM_OPT_SIDECAR)\n+   if (vmInfo->_srMethodAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srMethodAccessorClass ,false))\n+      {\n+      return true;\n+      }\n+   if (vmInfo->_srConstructorAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srConstructorAccessorClass ,false))\n+      {\n+      return true;\n+      }\n+#endif // J9VM_OPT_SIDECAR\n+\n    stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, method, clazz);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f604cad07a52f020487fb7cbe033dbbbdd8a421c"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDQyMTY3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjoyMDo0NVrOFwEd3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjoyMDo0NVrOFwEd3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0OTE0OA==", "bodyText": "You still need to receive a message from the server.", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385949148", "createdAt": "2020-02-28T22:20:45Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -551,10 +566,11 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          break;\n       case MessageType::VM_stackWalkerMaySkipFrames:\n          {\n-         auto recv = client->getRecvData<TR_OpaqueMethodBlock *, TR_OpaqueClassBlock *>();\n-         TR_OpaqueMethodBlock *method = std::get<0>(recv);\n-         TR_OpaqueClassBlock *clazz = std::get<1>(recv);\n-         client->write(response, fe->stackWalkerMaySkipFrames(method, clazz));\n+         // auto recv = client->getRecvData<TR_OpaqueMethodBlock *, TR_OpaqueClassBlock *>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdb4ca7ea05e3e1259f9997f46adaae8efe44eaa"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDQ3OTkzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9Server.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjo1MDo0MlrOFwFBEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjo1MDo0MlrOFwFBEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1ODE2Mg==", "bodyText": "After asking the client about the value of vmInfo->jlrMethodInvoke you need another check against NULL. According to the original code if vmInfo->jlrMethodInvoke == NULL  you can return true", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r385958162", "createdAt": "2020-02-28T22:50:42Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,9 +692,41 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n-   stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, method, clazz);\n-   return std::get<0>(stream->read<bool>());\n+   auto *vmInfo = _compInfoPT->getClientData()->getOrCacheVMInfo(stream);\n+   \n+   if (vmInfo->_jlrMethodInvoke == NULL)\n+      {\n+      stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, JITServer::Void());\n+      vmInfo->_jlrMethodInvoke = std::get<0>(stream->read<J9Method*>());\n+      // stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, method, clazz);\n+      // return std::get<0>(stream->read<bool>());\n+      }\n+   if (vmInfo->_jlrMethodInvoke == ((J9Method *) method))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdb4ca7ea05e3e1259f9997f46adaae8efe44eaa"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDMwMjUyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9Server.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjo0MDoyMFrOFwmqfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjo0MDoyMFrOFwmqfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwOTQzOQ==", "bodyText": "Ideally the test vmInfo->_jlrMethodInvoke == NULL is performed before vmInfo->_jlrMethodInvoke == ((J9Method *) method). Lets push that vmInfo->_jlrMethodInvoke == NULL test above like this:\nif (vmInfo->_jlrMethodInvoke == NULL)\n      {\n      // Cached information could be outdated. Ask the client again.\n      stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, JITServer::Void());\n      vmInfo->_jlrMethodInvoke = std::get<0>(stream->read<J9Method*>());\n      if (vmInfo->_jlrMethodInvoke == NULL)\n         return true;\n      }\nif (vmInfo->_jlrMethodInvoke == ((J9Method *) method)\n    return true;", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r386509439", "createdAt": "2020-03-02T16:40:20Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,9 +692,40 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n-   stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, method, clazz);\n-   return std::get<0>(stream->read<bool>());\n+   auto *vmInfo = _compInfoPT->getClientData()->getOrCacheVMInfo(stream);\n+   \n+   if (vmInfo->_jlrMethodInvoke == NULL)\n+      {\n+      stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, JITServer::Void());\n+      vmInfo->_jlrMethodInvoke = std::get<0>(stream->read<J9Method*>());\n+      }\n+   // If _jlrMethodInvoke is NULL at the client, return true\n+   if (vmInfo->_jlrMethodInvoke == ((J9Method *) method) || vmInfo->_jlrMethodInvoke == NULL)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9edde168759c2a0b56b64b8f34b24f912039fb15"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODk2OTQ4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9Server.cpp", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDowMDozN1rOF0QDyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxOToxNToxNFrOF0dZsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMzMzM4NA==", "bodyText": "I see that the VM sets srConstructorAccessor and srMethodAccessor in succession, so if one can be null the other one can be too.\nI also suggest getting all 3 fields that we need from the client in one message, rather than sending separate messages.", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r390333384", "createdAt": "2020-03-10T14:00:37Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,9 +692,48 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n-   stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, method, clazz);\n-   return std::get<0>(stream->read<bool>());\n+   auto *vmInfo = _compInfoPT->getClientData()->getOrCacheVMInfo(stream);\n+   \n+   if (vmInfo->_jlrMethodInvoke == NULL)\n+      {\n+      // Cached information could be outdated. Ask the client again.\n+      stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, JITServer::Void());\n+      vmInfo->_jlrMethodInvoke = std::get<0>(stream->read<J9Method*, TR_OpaqueClassBlock*>());\n+      if (vmInfo->_jlrMethodInvoke == NULL)\n+         return true;\n+      }\n+   if (vmInfo->_jlrMethodInvoke == ((J9Method *) method))\n+      {\n+      return true;\n+      }\n+   if(!clazz)\n+      {\n+      return false;\n+      }\n+#if defined(J9VM_OPT_SIDECAR)\n+   if (vmInfo->_srMethodAccessorClass == NULL)\n+      {\n+      // Cached information could be outdated. Ask the client again.\n+      stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, JITServer::Void());\n+      vmInfo->_srMethodAccessorClass = std::get<1>(stream->read<J9Method*, TR_OpaqueClassBlock*>());\n+      }\n+   if (vmInfo->_srMethodAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srMethodAccessorClass ,false))\n+      {\n+      return true;\n+      }\n+   if (vmInfo->_srConstructorAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srConstructorAccessorClass ,false))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fe41d824311d3ad383b07d5dac7e4e919910602"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM1NTkzNA==", "bodyText": "Will do that. The question is where should we send this message?\nI could populate this if block (line 703). Add srConstructorAccessor == NULL || srMethodAccessor  == NULL in if condition, query and cache three values at the same time.\nAlso I noticed that srConstructorAccessor and srMethodAccessor are protected by #if defined(J9VM_OPT_SIDECAR) in TR_J9VM::stackWalkerMaySkipFrames implementation, however they are not protected in J9JavaVM definition. I am not sure what J9VM_OPT_SIDECAR is exactly doing, so I hope my suggestion won't break anything in the case of J9VM_OPT_SIDECAR is not defined.", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r390355934", "createdAt": "2020-03-10T14:30:37Z", "author": {"login": "chrisc66"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,9 +692,48 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n-   stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, method, clazz);\n-   return std::get<0>(stream->read<bool>());\n+   auto *vmInfo = _compInfoPT->getClientData()->getOrCacheVMInfo(stream);\n+   \n+   if (vmInfo->_jlrMethodInvoke == NULL)\n+      {\n+      // Cached information could be outdated. Ask the client again.\n+      stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, JITServer::Void());\n+      vmInfo->_jlrMethodInvoke = std::get<0>(stream->read<J9Method*, TR_OpaqueClassBlock*>());\n+      if (vmInfo->_jlrMethodInvoke == NULL)\n+         return true;\n+      }\n+   if (vmInfo->_jlrMethodInvoke == ((J9Method *) method))\n+      {\n+      return true;\n+      }\n+   if(!clazz)\n+      {\n+      return false;\n+      }\n+#if defined(J9VM_OPT_SIDECAR)\n+   if (vmInfo->_srMethodAccessorClass == NULL)\n+      {\n+      // Cached information could be outdated. Ask the client again.\n+      stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, JITServer::Void());\n+      vmInfo->_srMethodAccessorClass = std::get<1>(stream->read<J9Method*, TR_OpaqueClassBlock*>());\n+      }\n+   if (vmInfo->_srMethodAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srMethodAccessorClass ,false))\n+      {\n+      return true;\n+      }\n+   if (vmInfo->_srConstructorAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srConstructorAccessorClass ,false))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMzMzM4NA=="}, "originalCommit": {"oid": "0fe41d824311d3ad383b07d5dac7e4e919910602"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ1ODc0NA==", "bodyText": "I'd say if the methods that use srConstructorAccessor or srMethodAccessor in the VM code are not protected by J9VM_OPT_SIDECAR we should remove that protection as well.\n\nThe question is where should we send this message?\n\nYour implementation is ok, but it can be optimized because sometimes even with partial information we can answer the frontend query. So I am thinking something along these lines:\nget cached information\nbool freshInfo = false;\nif (vmInfo->_jlrMethodInvoke == NULL)\n   send message and get all 3 pieces that we want\n   store them into vmInfo\n   freshInfo = true;\n   if (vmInfo->_jlrMethodInvoke == NULL)\n        return true;\nif (vmInfo->_jlrMethodInvoke == ((J9Method *) method))\n  return true;\nif (!clazz)\n   return false;\nif (vmInfo->_srMethodAccessorClass == NULL && !freshInfo)\n     send message and get all 3 pieces that we want\n     store them into vmInfo\n     freshInfo = true;\n  if (vmInfo->_srMethodAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srMethodAccessorClass ,false))\n      return true;\nrepeat for srConstructorAccessor", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r390458744", "createdAt": "2020-03-10T16:47:20Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,9 +692,48 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n-   stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, method, clazz);\n-   return std::get<0>(stream->read<bool>());\n+   auto *vmInfo = _compInfoPT->getClientData()->getOrCacheVMInfo(stream);\n+   \n+   if (vmInfo->_jlrMethodInvoke == NULL)\n+      {\n+      // Cached information could be outdated. Ask the client again.\n+      stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, JITServer::Void());\n+      vmInfo->_jlrMethodInvoke = std::get<0>(stream->read<J9Method*, TR_OpaqueClassBlock*>());\n+      if (vmInfo->_jlrMethodInvoke == NULL)\n+         return true;\n+      }\n+   if (vmInfo->_jlrMethodInvoke == ((J9Method *) method))\n+      {\n+      return true;\n+      }\n+   if(!clazz)\n+      {\n+      return false;\n+      }\n+#if defined(J9VM_OPT_SIDECAR)\n+   if (vmInfo->_srMethodAccessorClass == NULL)\n+      {\n+      // Cached information could be outdated. Ask the client again.\n+      stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, JITServer::Void());\n+      vmInfo->_srMethodAccessorClass = std::get<1>(stream->read<J9Method*, TR_OpaqueClassBlock*>());\n+      }\n+   if (vmInfo->_srMethodAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srMethodAccessorClass ,false))\n+      {\n+      return true;\n+      }\n+   if (vmInfo->_srConstructorAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srConstructorAccessorClass ,false))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMzMzM4NA=="}, "originalCommit": {"oid": "0fe41d824311d3ad383b07d5dac7e4e919910602"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU1MTk4Nw==", "bodyText": "Looked into the pseudo code, we actually have two duplicated if checks, so I just kept the one outside.\nif (vmInfo->_srMethodAccessorClass == NULL && !freshInfo)\n     send message and get all 3 pieces that we want\n     store them into vmInfo\n     freshInfo = true;\n// HERE, this one is removed in latest commit\n  if (vmInfo->_srMethodAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srMethodAccessorClass ,false))\n      return true;\n// HERE\nif (vmInfo->_srMethodAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srMethodAccessorClass ,false))\n      return true;", "url": "https://github.com/eclipse-openj9/openj9/pull/8680#discussion_r390551987", "createdAt": "2020-03-10T19:15:14Z", "author": {"login": "chrisc66"}, "path": "runtime/compiler/env/VMJ9Server.cpp", "diffHunk": "@@ -692,9 +692,48 @@ TR_J9ServerVM::getStaticReferenceFieldAtAddress(uintptrj_t fieldAddress)\n bool\n TR_J9ServerVM::stackWalkerMaySkipFrames(TR_OpaqueMethodBlock *method, TR_OpaqueClassBlock *clazz)\n    {\n+   if(!method)\n+      {\n+      return false;\n+      }\n+\n    JITServer::ServerStream *stream = _compInfoPT->getMethodBeingCompiled()->_stream;\n-   stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, method, clazz);\n-   return std::get<0>(stream->read<bool>());\n+   auto *vmInfo = _compInfoPT->getClientData()->getOrCacheVMInfo(stream);\n+   \n+   if (vmInfo->_jlrMethodInvoke == NULL)\n+      {\n+      // Cached information could be outdated. Ask the client again.\n+      stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, JITServer::Void());\n+      vmInfo->_jlrMethodInvoke = std::get<0>(stream->read<J9Method*, TR_OpaqueClassBlock*>());\n+      if (vmInfo->_jlrMethodInvoke == NULL)\n+         return true;\n+      }\n+   if (vmInfo->_jlrMethodInvoke == ((J9Method *) method))\n+      {\n+      return true;\n+      }\n+   if(!clazz)\n+      {\n+      return false;\n+      }\n+#if defined(J9VM_OPT_SIDECAR)\n+   if (vmInfo->_srMethodAccessorClass == NULL)\n+      {\n+      // Cached information could be outdated. Ask the client again.\n+      stream->write(JITServer::MessageType::VM_stackWalkerMaySkipFrames, JITServer::Void());\n+      vmInfo->_srMethodAccessorClass = std::get<1>(stream->read<J9Method*, TR_OpaqueClassBlock*>());\n+      }\n+   if (vmInfo->_srMethodAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srMethodAccessorClass ,false))\n+      {\n+      return true;\n+      }\n+   if (vmInfo->_srConstructorAccessorClass != NULL && TR_J9ServerVM::isInstanceOf( clazz, vmInfo->_srConstructorAccessorClass ,false))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMzMzM4NA=="}, "originalCommit": {"oid": "0fe41d824311d3ad383b07d5dac7e4e919910602"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 627, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}