{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwODUzNTcw", "number": 10866, "title": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro", "bodyText": "This patch removes J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro along with related code\nFixes #6652\nSigned-off-by: Alexey Anufriev contact@alexey-anufriev.com", "createdAt": "2020-10-09T22:42:10Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10866", "merged": true, "mergeCommit": {"oid": "3caadd433c8157b403f337ecd7a057ae188d8297"}, "closed": true, "closedAt": "2020-10-16T17:57:07Z", "author": {"login": "alexey-anufriev"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQ-TOOABqjM4NjIwMzQ1MjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdTKOyeAFqTUxMDY4OTI5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "50ef98194b23ed7c15d41a33516d58bf961dae58", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/50ef98194b23ed7c15d41a33516d58bf961dae58", "committedDate": "2020-10-09T22:50:04Z", "message": "Align Copyright header\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}, "afterCommit": {"oid": "70d1589d85637102f3aca4af44101883738236a8", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/70d1589d85637102f3aca4af44101883738236a8", "committedDate": "2020-10-09T22:54:58Z", "message": "Align Copyright header\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e4286a27c648bbd701b68d39af14b2bdf1e4505b", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e4286a27c648bbd701b68d39af14b2bdf1e4505b", "committedDate": "2020-10-10T15:09:50Z", "message": "Fix CompositeCacheSizesTests\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}, "afterCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8f5d420218bc4ccec6f2887401666a572f1a5de6", "committedDate": "2020-10-10T21:11:45Z", "message": "Fix CompositeCacheSizesTests\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NDEyMjI1", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#pullrequestreview-507412225", "createdAt": "2020-10-13T13:07:10Z", "commit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMzowNzoxMFrOHglulA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMzoxNzowNlrOHgmLxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzNDYxMg==", "bodyText": "This change is unnecessary.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r503934612", "createdAt": "2020-10-13T13:07:10Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CompiledMethodManagerImpl.cpp", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2001, 2019 IBM Corp. and others\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzNjk5Ng==", "bodyText": "It's policy to keep existing tracepoint numbers the same, meaning that older tracepoint can't be deleted. They can be updated with the Obsolete keyword.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r503936996", "createdAt": "2020-10-13T13:10:42Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1804,37 +1804,6 @@ TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Templ\n TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"\n \n-TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzOTg4NA==", "bodyText": "This change is unnecessary.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r503939884", "createdAt": "2020-10-13T13:14:44Z", "author": {"login": "pshipton"}, "path": "runtime/tests/shared/SCStoreTransactionTests.hpp", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2001, 2014 IBM Corp. and others\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk0MjA4Ng==", "bodyText": "The deletion is backwards here.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r503942086", "createdAt": "2020-10-13T13:17:06Z", "author": {"login": "pshipton"}, "path": "runtime/tests/shared/CorruptCacheTest.cpp", "diffHunk": "@@ -1044,61 +1009,48 @@ testCorruptCache(J9JavaVM* vm)\n \t\tswitch (i) {\n \t\tcase 0:\n #if !defined(J9ZOS390)\n-#if !defined(J9SHR_CACHELET_SUPPORT)\n \t\t\tcacheType = J9PORT_SHR_CACHE_TYPE_PERSISTENT;\n \t\t\tcacheTypeString = \"J9PORT_SHR_CACHE_TYPE_PERSISTENT\";\n-#else\n-\t\t\tcacheType = J9PORT_SHR_CACHE_TYPE_VMEM;\n-\t\t\tcacheTypeString = \"J9PORT_SHR_CACHE_TYPE_VMEM\";\n-#endif\n \t\t\treadOnly = false;\n \t\t\textraRuntimeFlags |= J9SHR_RUNTIMEFLAG_DISABLE_CORRUPT_CACHE_DUMPS;\n #endif\n \t\t\tbreak;\n \t\tcase 1:\n-#if !defined(J9SHR_CACHELET_SUPPORT)\n \t\t\tcacheType = J9PORT_SHR_CACHE_TYPE_NONPERSISTENT;\n \t\t\tcacheTypeString = \"J9PORT_SHR_CACHE_TYPE_NONPERSISTENT\";\n \t\t\treadOnly = false;\n \t\t\textraRuntimeFlags |= J9SHR_RUNTIMEFLAG_DISABLE_CORRUPT_CACHE_DUMPS;\n-#endif\n+\n \t\t\tbreak;\n \t\tcase 2:\n #if !(defined(J9ZOS390))\n-#if !defined(J9SHR_CACHELET_SUPPORT)\n-\t\t\tcacheType = J9PORT_SHR_CACHE_TYPE_PERSISTENT;\n-\t\t\tcacheTypeString = \"J9PORT_SHR_CACHE_TYPE_PERSISTENT\";\n-#else\n \t\t\tcacheType = J9PORT_SHR_CACHE_TYPE_VMEM;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NTY1NDEw", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#pullrequestreview-507565410", "createdAt": "2020-10-13T15:29:25Z", "commit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNToyOToyNVrOHgsqeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNjoxMDo1OFrOHgujhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0ODI1MA==", "bodyText": "I believe _cacheletCntr, _cacheletTail, _cacheletHead, _runningNested, _growEnabled, _isSerialized a few lines above can be removed.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504048250", "createdAt": "2020-10-13T15:29:25Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -295,13 +295,7 @@ SH_CacheMap::initialize(J9JavaVM* vm, J9SharedClassConfig* sharedClassConfig, Bl\n \t_isSerialized = false;\n \t_isAssertEnabled = true;\n \t_metadataReleased = false;\n-\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MDIxOA==", "bodyText": "The trace point Trc_SHR_CM_readCache_initCacheletFailed can be marked as Obsolete at j9shr.tdf.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504050218", "createdAt": "2020-10-13T15:31:31Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -1276,47 +1207,6 @@ SH_CacheMap::readCache(J9VMThread* currentThread, SH_CompositeCacheImpl* cache,\n \t\t\t\t\tTrc_SHR_Assert_ShouldNeverHappen();\n \t\t\t\t\tresult = CM_READ_CACHE_FAILED;\n \t\t\t\t}\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\t\t\t\t/* Initialize cachelets, but don't start them up */\n-\t\t\t\tif ((cache == _cc) && (itemType == TYPE_CACHELET)) {\n-\t\t\t\t\tCacheletWrapper* wrapper = (CacheletWrapper*)ITEMDATA(it);\n-\t\t\t\t\tBlockPtr cacheletMemory = (BlockPtr)CLETDATA(wrapper);\n-\t\t\t\t\tSH_CompositeCacheImpl* cachelet = _cacheletHead; /* this list currently spans all supercaches */\n-\t\t\t\t\twhile (cachelet) {\n-\t\t\t\t\t\tif (cachelet->getNestedMemory() == cacheletMemory) {\n-\t\t\t\t\t\t\t/* cachelet is already initialized */\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcachelet = cachelet->getNext();\n-\t\t\t\t\t}\n-\t\t\t\t\t\n-\t\t\t\t\tif (cachelet == NULL) {\n-\t\t\t\t\t\tif (!(cachelet = initCachelet(currentThread, (BlockPtr)cacheletMemory, false))) {\n-\t\t\t\t\t\t\tTrc_SHR_CM_readCache_initCacheletFailed(currentThread, cacheletMemory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MDk0MA==", "bodyText": "This trace point can also be mark as Obsolete in j9shr.tdf.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504050940", "createdAt": "2020-10-13T15:32:19Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -1276,47 +1207,6 @@ SH_CacheMap::readCache(J9VMThread* currentThread, SH_CompositeCacheImpl* cache,\n \t\t\t\t\tTrc_SHR_Assert_ShouldNeverHappen();\n \t\t\t\t\tresult = CM_READ_CACHE_FAILED;\n \t\t\t\t}\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\t\t\t\t/* Initialize cachelets, but don't start them up */\n-\t\t\t\tif ((cache == _cc) && (itemType == TYPE_CACHELET)) {\n-\t\t\t\t\tCacheletWrapper* wrapper = (CacheletWrapper*)ITEMDATA(it);\n-\t\t\t\t\tBlockPtr cacheletMemory = (BlockPtr)CLETDATA(wrapper);\n-\t\t\t\t\tSH_CompositeCacheImpl* cachelet = _cacheletHead; /* this list currently spans all supercaches */\n-\t\t\t\t\twhile (cachelet) {\n-\t\t\t\t\t\tif (cachelet->getNestedMemory() == cacheletMemory) {\n-\t\t\t\t\t\t\t/* cachelet is already initialized */\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcachelet = cachelet->getNext();\n-\t\t\t\t\t}\n-\t\t\t\t\t\n-\t\t\t\t\tif (cachelet == NULL) {\n-\t\t\t\t\t\tif (!(cachelet = initCachelet(currentThread, (BlockPtr)cacheletMemory, false))) {\n-\t\t\t\t\t\t\tTrc_SHR_CM_readCache_initCacheletFailed(currentThread, cacheletMemory);\n-\t\t\t\t\t\t\tresult = CM_READ_CACHE_FAILED;\n-\t\t\t\t\t\t\tgoto readCache_stop;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tTrc_SHR_CM_readCache_initCachelet(currentThread, cachelet, cacheletMemory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MzY3NQ==", "bodyText": "This trace point can be mark as Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504053675", "createdAt": "2020-10-13T15:35:42Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -5836,993 +5644,6 @@ SH_CacheMap::getAttachedDataManager(J9VMThread* currentThread)\n \treturn NULL;\n }\n \n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-UDATA\n-SH_CacheMap::startAllManagers(J9VMThread* currentThread)\n-{\n-\tif (getScopeManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getClasspathManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getROMClassManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getByteDataManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getCompiledMethodManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\treturn 1;\n-}\n-\n-#endif /* J9SHR_CACHELET_SUPPORT */\n-\n-\t/************************************** STUFF EXCLUSIVE TO CACHELETS *********************************/\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-SH_CompositeCacheImpl*\n-SH_CacheMap::initCachelet(J9VMThread* currentThread, BlockPtr existingCacheletMemory, bool creatingCachelet) \n-{\n-\tvoid* ccMem = pool_newElement(_ccPool);\n-\tSH_CompositeCacheImpl* newCachelet;\n-\t\n-\tif (ccMem == NULL) {\n-\t\t/* TODO: Tracepoint */\n-\t\treturn NULL;\n-\t}\n-\tif ((_cacheletHead == NULL) && (startAllManagers(currentThread) == 0)) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tnewCachelet = SH_CompositeCacheImpl::newInstanceNested(currentThread->javaVM, _cc, (SH_CompositeCacheImpl*)ccMem, J9SHR_DEFAULT_CACHELET_SIZE, existingCacheletMemory, creatingCachelet);\n-\tif (!newCachelet) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tif (_cacheletHead != NULL) {\n-\t\t_cacheletTail->setNext((SH_CompositeCacheImpl*)newCachelet);\n-\t} else {\n-\t\t_cacheletHead = _ccCacheletHead = (SH_CompositeCacheImpl*)newCachelet;\n-\t}\n-\t_cacheletTail = (SH_CompositeCacheImpl*)newCachelet;\n-\treturn newCachelet;\n-}\n-\n-/* TODO: Check that we are checking for CC_STARTUP_CORRUPT */\n-/* THREADING: Does not require the cache write mutex */\n-IDATA\n-SH_CacheMap::startupCachelet(J9VMThread* currentThread, SH_CompositeCache* cachelet)\n-{\n-\tIDATA rc;\n-\t\n-\t/* Because starting up a cachelet might require the write mutex,\n-\t * we can't have the refresh mutex here.\n-\t */\n-\trc = ((SH_CompositeCacheImpl*)cachelet)->startupNested(currentThread);\n-\tif (rc == CC_STARTUP_OK) {\n-\t\tif (sanityWalkROMClassSegment(currentThread, (SH_CompositeCacheImpl*)cachelet) == 0) {\n-\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t}\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tbool hasClassSegmentMutex = \n-\t\t\t\t(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);\n-\t\t\t/* This is harmless if segments were already initialized. */\n-\t\t\tif (-1 ==  refreshHashtables(currentThread, hasClassSegmentMutex)) {\n-\t\t\t\tif ( _ccHead->isCacheCorrupt()) {\n-\t\t\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t\t\t} else {\n-\t\t\t\t\trc = CC_STARTUP_FAILED;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif (CC_STARTUP_CORRUPT == rc) {\n-\t\treportCorruptCache(currentThread, _ccHead);\n-\t}\n-\n-\treturn rc;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewCachelet(J9VMThread* currentThread) \n-{\n-\tJ9SharedDataDescriptor descriptor;\n-\tSH_Manager* localBDM;\n-\tBlockPtr cacheletMemory;\n-\tSH_CompositeCacheImpl* returnVal = NULL;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tbool createdNewChainedCache = false;\n-\tIDATA i;\n-\t\n-\tTrc_SHR_CM_createNewCachelet_Entry(currentThread);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\t/* Assume that the manager is started */\n-\tlocalBDM = managers()->getManagerForDataType(TYPE_BYTE_DATA);\n-\tdescriptor.address = 0;\n-\tdescriptor.type = J9SHR_DATA_TYPE_CACHELET;\n-\tdescriptor.length = J9SHR_DEFAULT_CACHELET_SIZE;\n-\tdescriptor.flags = (J9SHRDATA_ALLOCATE_ZEROD_MEMORY | J9SHRDATA_NOT_INDEXED);\n-\n-\tfor (i=0; i<2; i++) {\n-\t\tcacheletMemory = (BlockPtr)addByteDataToCache(currentThread, localBDM, NULL, &descriptor, NULL, true);\n-\n-\t\tif (cacheletMemory != NULL) {\n-\t\t\treturnVal = initCachelet(currentThread, cacheletMemory, true);\n-\t\t\tif (returnVal) {\n-\t\t\t\tif (startupCachelet(currentThread, returnVal) == CC_STARTUP_OK) {\n-\t\t\t\t\tif (createdNewChainedCache) {\n-\t\t\t\t\t\tJ9SharedInvariantInternTable *stringTable = vm->sharedInvariantInternTable;\n-\t\t\t\t\t\t_ccCacheletHead = returnVal;\n-\t\t\t\t\t\tif (!initializeROMSegmentList(currentThread)) {\n-\t\t\t\t\t\t\t/* TODO: handle this correctly */\n-\t\t\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MzY5OA==", "bodyText": "This trace point can be mark as Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504053698", "createdAt": "2020-10-13T15:35:44Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -5836,993 +5644,6 @@ SH_CacheMap::getAttachedDataManager(J9VMThread* currentThread)\n \treturn NULL;\n }\n \n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-UDATA\n-SH_CacheMap::startAllManagers(J9VMThread* currentThread)\n-{\n-\tif (getScopeManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getClasspathManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getROMClassManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getByteDataManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getCompiledMethodManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\treturn 1;\n-}\n-\n-#endif /* J9SHR_CACHELET_SUPPORT */\n-\n-\t/************************************** STUFF EXCLUSIVE TO CACHELETS *********************************/\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-SH_CompositeCacheImpl*\n-SH_CacheMap::initCachelet(J9VMThread* currentThread, BlockPtr existingCacheletMemory, bool creatingCachelet) \n-{\n-\tvoid* ccMem = pool_newElement(_ccPool);\n-\tSH_CompositeCacheImpl* newCachelet;\n-\t\n-\tif (ccMem == NULL) {\n-\t\t/* TODO: Tracepoint */\n-\t\treturn NULL;\n-\t}\n-\tif ((_cacheletHead == NULL) && (startAllManagers(currentThread) == 0)) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tnewCachelet = SH_CompositeCacheImpl::newInstanceNested(currentThread->javaVM, _cc, (SH_CompositeCacheImpl*)ccMem, J9SHR_DEFAULT_CACHELET_SIZE, existingCacheletMemory, creatingCachelet);\n-\tif (!newCachelet) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tif (_cacheletHead != NULL) {\n-\t\t_cacheletTail->setNext((SH_CompositeCacheImpl*)newCachelet);\n-\t} else {\n-\t\t_cacheletHead = _ccCacheletHead = (SH_CompositeCacheImpl*)newCachelet;\n-\t}\n-\t_cacheletTail = (SH_CompositeCacheImpl*)newCachelet;\n-\treturn newCachelet;\n-}\n-\n-/* TODO: Check that we are checking for CC_STARTUP_CORRUPT */\n-/* THREADING: Does not require the cache write mutex */\n-IDATA\n-SH_CacheMap::startupCachelet(J9VMThread* currentThread, SH_CompositeCache* cachelet)\n-{\n-\tIDATA rc;\n-\t\n-\t/* Because starting up a cachelet might require the write mutex,\n-\t * we can't have the refresh mutex here.\n-\t */\n-\trc = ((SH_CompositeCacheImpl*)cachelet)->startupNested(currentThread);\n-\tif (rc == CC_STARTUP_OK) {\n-\t\tif (sanityWalkROMClassSegment(currentThread, (SH_CompositeCacheImpl*)cachelet) == 0) {\n-\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t}\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tbool hasClassSegmentMutex = \n-\t\t\t\t(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);\n-\t\t\t/* This is harmless if segments were already initialized. */\n-\t\t\tif (-1 ==  refreshHashtables(currentThread, hasClassSegmentMutex)) {\n-\t\t\t\tif ( _ccHead->isCacheCorrupt()) {\n-\t\t\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t\t\t} else {\n-\t\t\t\t\trc = CC_STARTUP_FAILED;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif (CC_STARTUP_CORRUPT == rc) {\n-\t\treportCorruptCache(currentThread, _ccHead);\n-\t}\n-\n-\treturn rc;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewCachelet(J9VMThread* currentThread) \n-{\n-\tJ9SharedDataDescriptor descriptor;\n-\tSH_Manager* localBDM;\n-\tBlockPtr cacheletMemory;\n-\tSH_CompositeCacheImpl* returnVal = NULL;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tbool createdNewChainedCache = false;\n-\tIDATA i;\n-\t\n-\tTrc_SHR_CM_createNewCachelet_Entry(currentThread);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1NDI1MQ==", "bodyText": "This trace point can be mark as Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504054251", "createdAt": "2020-10-13T15:36:26Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -5836,993 +5644,6 @@ SH_CacheMap::getAttachedDataManager(J9VMThread* currentThread)\n \treturn NULL;\n }\n \n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-UDATA\n-SH_CacheMap::startAllManagers(J9VMThread* currentThread)\n-{\n-\tif (getScopeManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getClasspathManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getROMClassManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getByteDataManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getCompiledMethodManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\treturn 1;\n-}\n-\n-#endif /* J9SHR_CACHELET_SUPPORT */\n-\n-\t/************************************** STUFF EXCLUSIVE TO CACHELETS *********************************/\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-SH_CompositeCacheImpl*\n-SH_CacheMap::initCachelet(J9VMThread* currentThread, BlockPtr existingCacheletMemory, bool creatingCachelet) \n-{\n-\tvoid* ccMem = pool_newElement(_ccPool);\n-\tSH_CompositeCacheImpl* newCachelet;\n-\t\n-\tif (ccMem == NULL) {\n-\t\t/* TODO: Tracepoint */\n-\t\treturn NULL;\n-\t}\n-\tif ((_cacheletHead == NULL) && (startAllManagers(currentThread) == 0)) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tnewCachelet = SH_CompositeCacheImpl::newInstanceNested(currentThread->javaVM, _cc, (SH_CompositeCacheImpl*)ccMem, J9SHR_DEFAULT_CACHELET_SIZE, existingCacheletMemory, creatingCachelet);\n-\tif (!newCachelet) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tif (_cacheletHead != NULL) {\n-\t\t_cacheletTail->setNext((SH_CompositeCacheImpl*)newCachelet);\n-\t} else {\n-\t\t_cacheletHead = _ccCacheletHead = (SH_CompositeCacheImpl*)newCachelet;\n-\t}\n-\t_cacheletTail = (SH_CompositeCacheImpl*)newCachelet;\n-\treturn newCachelet;\n-}\n-\n-/* TODO: Check that we are checking for CC_STARTUP_CORRUPT */\n-/* THREADING: Does not require the cache write mutex */\n-IDATA\n-SH_CacheMap::startupCachelet(J9VMThread* currentThread, SH_CompositeCache* cachelet)\n-{\n-\tIDATA rc;\n-\t\n-\t/* Because starting up a cachelet might require the write mutex,\n-\t * we can't have the refresh mutex here.\n-\t */\n-\trc = ((SH_CompositeCacheImpl*)cachelet)->startupNested(currentThread);\n-\tif (rc == CC_STARTUP_OK) {\n-\t\tif (sanityWalkROMClassSegment(currentThread, (SH_CompositeCacheImpl*)cachelet) == 0) {\n-\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t}\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tbool hasClassSegmentMutex = \n-\t\t\t\t(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);\n-\t\t\t/* This is harmless if segments were already initialized. */\n-\t\t\tif (-1 ==  refreshHashtables(currentThread, hasClassSegmentMutex)) {\n-\t\t\t\tif ( _ccHead->isCacheCorrupt()) {\n-\t\t\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t\t\t} else {\n-\t\t\t\t\trc = CC_STARTUP_FAILED;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif (CC_STARTUP_CORRUPT == rc) {\n-\t\treportCorruptCache(currentThread, _ccHead);\n-\t}\n-\n-\treturn rc;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewCachelet(J9VMThread* currentThread) \n-{\n-\tJ9SharedDataDescriptor descriptor;\n-\tSH_Manager* localBDM;\n-\tBlockPtr cacheletMemory;\n-\tSH_CompositeCacheImpl* returnVal = NULL;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tbool createdNewChainedCache = false;\n-\tIDATA i;\n-\t\n-\tTrc_SHR_CM_createNewCachelet_Entry(currentThread);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\t/* Assume that the manager is started */\n-\tlocalBDM = managers()->getManagerForDataType(TYPE_BYTE_DATA);\n-\tdescriptor.address = 0;\n-\tdescriptor.type = J9SHR_DATA_TYPE_CACHELET;\n-\tdescriptor.length = J9SHR_DEFAULT_CACHELET_SIZE;\n-\tdescriptor.flags = (J9SHRDATA_ALLOCATE_ZEROD_MEMORY | J9SHRDATA_NOT_INDEXED);\n-\n-\tfor (i=0; i<2; i++) {\n-\t\tcacheletMemory = (BlockPtr)addByteDataToCache(currentThread, localBDM, NULL, &descriptor, NULL, true);\n-\n-\t\tif (cacheletMemory != NULL) {\n-\t\t\treturnVal = initCachelet(currentThread, cacheletMemory, true);\n-\t\t\tif (returnVal) {\n-\t\t\t\tif (startupCachelet(currentThread, returnVal) == CC_STARTUP_OK) {\n-\t\t\t\t\tif (createdNewChainedCache) {\n-\t\t\t\t\t\tJ9SharedInvariantInternTable *stringTable = vm->sharedInvariantInternTable;\n-\t\t\t\t\t\t_ccCacheletHead = returnVal;\n-\t\t\t\t\t\tif (!initializeROMSegmentList(currentThread)) {\n-\t\t\t\t\t\t\t/* TODO: handle this correctly */\n-\t\t\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\t\t\treturn NULL;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (stringTable) {\n-\t\t\t\t\t\t\tUDATA ignore;\n-\n-\t\t\t\t\t\t\tupdateAllManagersWithNewCacheArea(currentThread, returnVal);\n-\t\t\t\t\t\t\t/* TODO: VERY IMPORTANT!! Entering the readWrite area mutex while we have the writeMutex breaks our threading model for cross-process\n-\t\t\t\t\t\t\t * synchronization. If this were ever used for multi-JVM, it could/would deadlock. However, we have to get the readWrite mutex here\n-\t\t\t\t\t\t\t * so that we can reset the string table. Currently, this will cause assertion failures in CompositeCache for that reason. */\n-\t\t\t\t\t\t\t_cc->enterReadWriteAreaMutex(currentThread, FALSE, &ignore, &ignore);\n-\t\t\t\t\t\t\t_cc->setInternCacheHeaderFields(\n-\t\t\t\t\t\t    \t&(stringTable->sharedTailNodePtr),\n-\t\t\t\t\t\t    \t&(stringTable->sharedHeadNodePtr),\n-\t\t\t\t\t\t\t    &(stringTable->totalSharedNodesPtr),\n-\t\t\t\t\t\t    \t&(stringTable->totalSharedWeightPtr));\n-\n-\t\t\t\t\t\t\tj9shr_resetSharedStringTable(currentThread->javaVM);\n-\n-\t\t\t\t\t\t\t_cc->exitReadWriteAreaMutex(currentThread, J9SHR_STRING_POOL_OK);\n-\t\t\t\t\t\t\tresetAllManagers(currentThread);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t} else {\n-\t\t\t\t\t/* TODO: Need to do some backpedalling and cleanup here */\n-\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\treturn NULL;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!createdNewChainedCache && _growEnabled && createNewChainedCache(currentThread, 0)) {\n-\t\t\t\tcreatedNewChainedCache = true;\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t}\n-\t}\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, returnVal);\n-\treturn returnVal;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewChainedCache(J9VMThread* currentThread, UDATA requiredSize)\n-{\n-\tvoid* ccMem;\n-\tSH_CompositeCacheImpl* newCache;\n-\tJ9SharedClassCacheDescriptor *cacheDesc;\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\n-\tTrc_SHR_CM_createNewChainedCache_Entry(currentThread, requiredSize, requiredSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 445}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1NDM0MA==", "bodyText": "This trace point can be mark as Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504054340", "createdAt": "2020-10-13T15:36:34Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -5836,993 +5644,6 @@ SH_CacheMap::getAttachedDataManager(J9VMThread* currentThread)\n \treturn NULL;\n }\n \n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-UDATA\n-SH_CacheMap::startAllManagers(J9VMThread* currentThread)\n-{\n-\tif (getScopeManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getClasspathManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getROMClassManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getByteDataManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getCompiledMethodManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\treturn 1;\n-}\n-\n-#endif /* J9SHR_CACHELET_SUPPORT */\n-\n-\t/************************************** STUFF EXCLUSIVE TO CACHELETS *********************************/\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-SH_CompositeCacheImpl*\n-SH_CacheMap::initCachelet(J9VMThread* currentThread, BlockPtr existingCacheletMemory, bool creatingCachelet) \n-{\n-\tvoid* ccMem = pool_newElement(_ccPool);\n-\tSH_CompositeCacheImpl* newCachelet;\n-\t\n-\tif (ccMem == NULL) {\n-\t\t/* TODO: Tracepoint */\n-\t\treturn NULL;\n-\t}\n-\tif ((_cacheletHead == NULL) && (startAllManagers(currentThread) == 0)) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tnewCachelet = SH_CompositeCacheImpl::newInstanceNested(currentThread->javaVM, _cc, (SH_CompositeCacheImpl*)ccMem, J9SHR_DEFAULT_CACHELET_SIZE, existingCacheletMemory, creatingCachelet);\n-\tif (!newCachelet) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tif (_cacheletHead != NULL) {\n-\t\t_cacheletTail->setNext((SH_CompositeCacheImpl*)newCachelet);\n-\t} else {\n-\t\t_cacheletHead = _ccCacheletHead = (SH_CompositeCacheImpl*)newCachelet;\n-\t}\n-\t_cacheletTail = (SH_CompositeCacheImpl*)newCachelet;\n-\treturn newCachelet;\n-}\n-\n-/* TODO: Check that we are checking for CC_STARTUP_CORRUPT */\n-/* THREADING: Does not require the cache write mutex */\n-IDATA\n-SH_CacheMap::startupCachelet(J9VMThread* currentThread, SH_CompositeCache* cachelet)\n-{\n-\tIDATA rc;\n-\t\n-\t/* Because starting up a cachelet might require the write mutex,\n-\t * we can't have the refresh mutex here.\n-\t */\n-\trc = ((SH_CompositeCacheImpl*)cachelet)->startupNested(currentThread);\n-\tif (rc == CC_STARTUP_OK) {\n-\t\tif (sanityWalkROMClassSegment(currentThread, (SH_CompositeCacheImpl*)cachelet) == 0) {\n-\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t}\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tbool hasClassSegmentMutex = \n-\t\t\t\t(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);\n-\t\t\t/* This is harmless if segments were already initialized. */\n-\t\t\tif (-1 ==  refreshHashtables(currentThread, hasClassSegmentMutex)) {\n-\t\t\t\tif ( _ccHead->isCacheCorrupt()) {\n-\t\t\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t\t\t} else {\n-\t\t\t\t\trc = CC_STARTUP_FAILED;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif (CC_STARTUP_CORRUPT == rc) {\n-\t\treportCorruptCache(currentThread, _ccHead);\n-\t}\n-\n-\treturn rc;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewCachelet(J9VMThread* currentThread) \n-{\n-\tJ9SharedDataDescriptor descriptor;\n-\tSH_Manager* localBDM;\n-\tBlockPtr cacheletMemory;\n-\tSH_CompositeCacheImpl* returnVal = NULL;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tbool createdNewChainedCache = false;\n-\tIDATA i;\n-\t\n-\tTrc_SHR_CM_createNewCachelet_Entry(currentThread);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\t/* Assume that the manager is started */\n-\tlocalBDM = managers()->getManagerForDataType(TYPE_BYTE_DATA);\n-\tdescriptor.address = 0;\n-\tdescriptor.type = J9SHR_DATA_TYPE_CACHELET;\n-\tdescriptor.length = J9SHR_DEFAULT_CACHELET_SIZE;\n-\tdescriptor.flags = (J9SHRDATA_ALLOCATE_ZEROD_MEMORY | J9SHRDATA_NOT_INDEXED);\n-\n-\tfor (i=0; i<2; i++) {\n-\t\tcacheletMemory = (BlockPtr)addByteDataToCache(currentThread, localBDM, NULL, &descriptor, NULL, true);\n-\n-\t\tif (cacheletMemory != NULL) {\n-\t\t\treturnVal = initCachelet(currentThread, cacheletMemory, true);\n-\t\t\tif (returnVal) {\n-\t\t\t\tif (startupCachelet(currentThread, returnVal) == CC_STARTUP_OK) {\n-\t\t\t\t\tif (createdNewChainedCache) {\n-\t\t\t\t\t\tJ9SharedInvariantInternTable *stringTable = vm->sharedInvariantInternTable;\n-\t\t\t\t\t\t_ccCacheletHead = returnVal;\n-\t\t\t\t\t\tif (!initializeROMSegmentList(currentThread)) {\n-\t\t\t\t\t\t\t/* TODO: handle this correctly */\n-\t\t\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\t\t\treturn NULL;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (stringTable) {\n-\t\t\t\t\t\t\tUDATA ignore;\n-\n-\t\t\t\t\t\t\tupdateAllManagersWithNewCacheArea(currentThread, returnVal);\n-\t\t\t\t\t\t\t/* TODO: VERY IMPORTANT!! Entering the readWrite area mutex while we have the writeMutex breaks our threading model for cross-process\n-\t\t\t\t\t\t\t * synchronization. If this were ever used for multi-JVM, it could/would deadlock. However, we have to get the readWrite mutex here\n-\t\t\t\t\t\t\t * so that we can reset the string table. Currently, this will cause assertion failures in CompositeCache for that reason. */\n-\t\t\t\t\t\t\t_cc->enterReadWriteAreaMutex(currentThread, FALSE, &ignore, &ignore);\n-\t\t\t\t\t\t\t_cc->setInternCacheHeaderFields(\n-\t\t\t\t\t\t    \t&(stringTable->sharedTailNodePtr),\n-\t\t\t\t\t\t    \t&(stringTable->sharedHeadNodePtr),\n-\t\t\t\t\t\t\t    &(stringTable->totalSharedNodesPtr),\n-\t\t\t\t\t\t    \t&(stringTable->totalSharedWeightPtr));\n-\n-\t\t\t\t\t\t\tj9shr_resetSharedStringTable(currentThread->javaVM);\n-\n-\t\t\t\t\t\t\t_cc->exitReadWriteAreaMutex(currentThread, J9SHR_STRING_POOL_OK);\n-\t\t\t\t\t\t\tresetAllManagers(currentThread);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t} else {\n-\t\t\t\t\t/* TODO: Need to do some backpedalling and cleanup here */\n-\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\treturn NULL;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!createdNewChainedCache && _growEnabled && createNewChainedCache(currentThread, 0)) {\n-\t\t\t\tcreatedNewChainedCache = true;\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t}\n-\t}\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, returnVal);\n-\treturn returnVal;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewChainedCache(J9VMThread* currentThread, UDATA requiredSize)\n-{\n-\tvoid* ccMem;\n-\tSH_CompositeCacheImpl* newCache;\n-\tJ9SharedClassCacheDescriptor *cacheDesc;\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\n-\tTrc_SHR_CM_createNewChainedCache_Entry(currentThread, requiredSize, requiredSize);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_Assert_True(_sharedClassConfig != NULL);\n-\n-\tccMem = j9mem_allocate_memory(SH_CompositeCacheImpl::getRequiredConstrBytes(false, false), J9MEM_CATEGORY_CLASSES);\n-\n-\tif (ccMem == NULL) {\n-\t\tTrc_SHR_CM_createNewChainedCache_Exit(currentThread, NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 452}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1ODk0OQ==", "bodyText": "There is another #if defined(J9SHR_CACHELETS_SAVE_READWRITE_AREA) at line 3954 (or line 3796 with your change) which can be removed.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504058949", "createdAt": "2020-10-13T15:42:50Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -5836,993 +5644,6 @@ SH_CacheMap::getAttachedDataManager(J9VMThread* currentThread)\n \treturn NULL;\n }\n \n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-UDATA\n-SH_CacheMap::startAllManagers(J9VMThread* currentThread)\n-{\n-\tif (getScopeManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getClasspathManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getROMClassManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getByteDataManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\tif (getCompiledMethodManager(currentThread) == NULL) {\n-\t\treturn 0;\n-\t}\n-\treturn 1;\n-}\n-\n-#endif /* J9SHR_CACHELET_SUPPORT */\n-\n-\t/************************************** STUFF EXCLUSIVE TO CACHELETS *********************************/\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-SH_CompositeCacheImpl*\n-SH_CacheMap::initCachelet(J9VMThread* currentThread, BlockPtr existingCacheletMemory, bool creatingCachelet) \n-{\n-\tvoid* ccMem = pool_newElement(_ccPool);\n-\tSH_CompositeCacheImpl* newCachelet;\n-\t\n-\tif (ccMem == NULL) {\n-\t\t/* TODO: Tracepoint */\n-\t\treturn NULL;\n-\t}\n-\tif ((_cacheletHead == NULL) && (startAllManagers(currentThread) == 0)) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tnewCachelet = SH_CompositeCacheImpl::newInstanceNested(currentThread->javaVM, _cc, (SH_CompositeCacheImpl*)ccMem, J9SHR_DEFAULT_CACHELET_SIZE, existingCacheletMemory, creatingCachelet);\n-\tif (!newCachelet) {\n-\t\tpool_removeElement(_ccPool, ccMem);\n-\t\treturn NULL;\n-\t}\n-\tif (_cacheletHead != NULL) {\n-\t\t_cacheletTail->setNext((SH_CompositeCacheImpl*)newCachelet);\n-\t} else {\n-\t\t_cacheletHead = _ccCacheletHead = (SH_CompositeCacheImpl*)newCachelet;\n-\t}\n-\t_cacheletTail = (SH_CompositeCacheImpl*)newCachelet;\n-\treturn newCachelet;\n-}\n-\n-/* TODO: Check that we are checking for CC_STARTUP_CORRUPT */\n-/* THREADING: Does not require the cache write mutex */\n-IDATA\n-SH_CacheMap::startupCachelet(J9VMThread* currentThread, SH_CompositeCache* cachelet)\n-{\n-\tIDATA rc;\n-\t\n-\t/* Because starting up a cachelet might require the write mutex,\n-\t * we can't have the refresh mutex here.\n-\t */\n-\trc = ((SH_CompositeCacheImpl*)cachelet)->startupNested(currentThread);\n-\tif (rc == CC_STARTUP_OK) {\n-\t\tif (sanityWalkROMClassSegment(currentThread, (SH_CompositeCacheImpl*)cachelet) == 0) {\n-\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t}\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tbool hasClassSegmentMutex = \n-\t\t\t\t(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);\n-\t\t\t/* This is harmless if segments were already initialized. */\n-\t\t\tif (-1 ==  refreshHashtables(currentThread, hasClassSegmentMutex)) {\n-\t\t\t\tif ( _ccHead->isCacheCorrupt()) {\n-\t\t\t\t\trc = CC_STARTUP_CORRUPT;\n-\t\t\t\t} else {\n-\t\t\t\t\trc = CC_STARTUP_FAILED;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif (CC_STARTUP_CORRUPT == rc) {\n-\t\treportCorruptCache(currentThread, _ccHead);\n-\t}\n-\n-\treturn rc;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewCachelet(J9VMThread* currentThread) \n-{\n-\tJ9SharedDataDescriptor descriptor;\n-\tSH_Manager* localBDM;\n-\tBlockPtr cacheletMemory;\n-\tSH_CompositeCacheImpl* returnVal = NULL;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tbool createdNewChainedCache = false;\n-\tIDATA i;\n-\t\n-\tTrc_SHR_CM_createNewCachelet_Entry(currentThread);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\t/* Assume that the manager is started */\n-\tlocalBDM = managers()->getManagerForDataType(TYPE_BYTE_DATA);\n-\tdescriptor.address = 0;\n-\tdescriptor.type = J9SHR_DATA_TYPE_CACHELET;\n-\tdescriptor.length = J9SHR_DEFAULT_CACHELET_SIZE;\n-\tdescriptor.flags = (J9SHRDATA_ALLOCATE_ZEROD_MEMORY | J9SHRDATA_NOT_INDEXED);\n-\n-\tfor (i=0; i<2; i++) {\n-\t\tcacheletMemory = (BlockPtr)addByteDataToCache(currentThread, localBDM, NULL, &descriptor, NULL, true);\n-\n-\t\tif (cacheletMemory != NULL) {\n-\t\t\treturnVal = initCachelet(currentThread, cacheletMemory, true);\n-\t\t\tif (returnVal) {\n-\t\t\t\tif (startupCachelet(currentThread, returnVal) == CC_STARTUP_OK) {\n-\t\t\t\t\tif (createdNewChainedCache) {\n-\t\t\t\t\t\tJ9SharedInvariantInternTable *stringTable = vm->sharedInvariantInternTable;\n-\t\t\t\t\t\t_ccCacheletHead = returnVal;\n-\t\t\t\t\t\tif (!initializeROMSegmentList(currentThread)) {\n-\t\t\t\t\t\t\t/* TODO: handle this correctly */\n-\t\t\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\t\t\treturn NULL;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (stringTable) {\n-\t\t\t\t\t\t\tUDATA ignore;\n-\n-\t\t\t\t\t\t\tupdateAllManagersWithNewCacheArea(currentThread, returnVal);\n-\t\t\t\t\t\t\t/* TODO: VERY IMPORTANT!! Entering the readWrite area mutex while we have the writeMutex breaks our threading model for cross-process\n-\t\t\t\t\t\t\t * synchronization. If this were ever used for multi-JVM, it could/would deadlock. However, we have to get the readWrite mutex here\n-\t\t\t\t\t\t\t * so that we can reset the string table. Currently, this will cause assertion failures in CompositeCache for that reason. */\n-\t\t\t\t\t\t\t_cc->enterReadWriteAreaMutex(currentThread, FALSE, &ignore, &ignore);\n-\t\t\t\t\t\t\t_cc->setInternCacheHeaderFields(\n-\t\t\t\t\t\t    \t&(stringTable->sharedTailNodePtr),\n-\t\t\t\t\t\t    \t&(stringTable->sharedHeadNodePtr),\n-\t\t\t\t\t\t\t    &(stringTable->totalSharedNodesPtr),\n-\t\t\t\t\t\t    \t&(stringTable->totalSharedWeightPtr));\n-\n-\t\t\t\t\t\t\tj9shr_resetSharedStringTable(currentThread->javaVM);\n-\n-\t\t\t\t\t\t\t_cc->exitReadWriteAreaMutex(currentThread, J9SHR_STRING_POOL_OK);\n-\t\t\t\t\t\t\tresetAllManagers(currentThread);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t} else {\n-\t\t\t\t\t/* TODO: Need to do some backpedalling and cleanup here */\n-\t\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\t\treturn NULL;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!createdNewChainedCache && _growEnabled && createNewChainedCache(currentThread, 0)) {\n-\t\t\t\tcreatedNewChainedCache = true;\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, NULL);\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t}\n-\t}\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_CM_createNewCachelet_Exit(currentThread, returnVal);\n-\treturn returnVal;\n-}\n-\n-/* THREADING: Must have cache write mutex */\n-SH_CompositeCacheImpl*\n-SH_CacheMap::createNewChainedCache(J9VMThread* currentThread, UDATA requiredSize)\n-{\n-\tvoid* ccMem;\n-\tSH_CompositeCacheImpl* newCache;\n-\tJ9SharedClassCacheDescriptor *cacheDesc;\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\n-\tTrc_SHR_CM_createNewChainedCache_Entry(currentThread, requiredSize, requiredSize);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_Assert_True(_sharedClassConfig != NULL);\n-\n-\tccMem = j9mem_allocate_memory(SH_CompositeCacheImpl::getRequiredConstrBytes(false, false), J9MEM_CATEGORY_CLASSES);\n-\n-\tif (ccMem == NULL) {\n-\t\tTrc_SHR_CM_createNewChainedCache_Exit(currentThread, NULL);\n-\t\treturn NULL;\n-\t}\n-\n-\tcacheDesc = this->appendCacheDescriptorList(currentThread, _sharedClassConfig);\n-\tif (!cacheDesc) {\n-\t\tTrc_SHR_CM_createNewChainedCache_Exit(currentThread, NULL);\n-\t\treturn NULL;\n-\t}\n-\n-\t/* For now, chained caches can only be VMEM */\n-\tnewCache = SH_CompositeCacheImpl::newInstanceChained(currentThread->javaVM, (SH_CompositeCacheImpl*)ccMem, _sharedClassConfig, J9PORT_SHR_CACHE_TYPE_VMEM);\n-\tif (newCache) {\n-\t\tJ9JavaVM* vm = currentThread->javaVM;\n-\t\tU_32 ignored;\n-\t\tIDATA rc;\n-\t\tJ9SharedClassPreinitConfig tempConfig;\n-\t\t\n-\t\tmemcpy(&tempConfig, vm->sharedClassPreinitConfig, sizeof(J9SharedClassPreinitConfig));\n-\t\tif (requiredSize > 0) {\n-\t\t\ttempConfig.sharedClassCacheSize = requiredSize;\n-\t\t\ttempConfig.sharedClassReadWriteBytes = 0;\n-\t\t}\n-\t\t\n-\t\trc = newCache->startupChained(currentThread, _ccHead, &tempConfig, &ignored, &_localCrashCntr);\n-\t\tif (rc == CC_STARTUP_OK) {\n-\t\t\tSH_CompositeCacheImpl* walk = _cacheletHead;\n-\t\t\tSH_CompositeCacheImpl* last = NULL;\n-\t\t\t\n-\t\t\t_cc->setNext(newCache);\n-\t\t\t_cc->setCacheHeaderFullFlags(currentThread, J9SHR_ALL_CACHE_FULL_BITS, false);\n-\t\t\t/* Mark existing cachelets full */\n-\t\t\twhile (walk) {\n-\t\t\t\tif (false == walk->isCacheMarkedFull(currentThread)) {\n-\t\t\t\t\twalk->setCacheHeaderFullFlags(currentThread, J9SHR_ALL_CACHE_FULL_BITS, false);\n-\t\t\t\t}\n-\t\t\t\tlast = walk;\n-\t\t\t\twalk = walk->getNext();\n-\t\t\t}\n-\t\t\t_cc = newCache;\n-\t\t\t_prevCClastCachelet = last;\n-\t\t} else {\n-\t\t\tgoto _error;\n-\t\t}\n-\t} else {\n-\t\tgoto _error;\n-\t}\n-\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_CM_createNewChainedCache_Exit(currentThread, newCache);\n-\treturn newCache;\n-\n-_error:\n-\tpool_removeElement(_ccPool, ccMem);\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\tTrc_SHR_CM_createNewChainedCache_Exit(currentThread, NULL);\n-\treturn NULL;\n-}\n-\n-/**\n- * @retval -1 failed\n- * @retval 0 succeeded\n- */\n-IDATA\n-SH_CacheMap::buildCacheletMetadata(J9VMThread* currentThread, SH_Manager::CacheletMetadataArray** metadataArray)\n-{\n-\tUDATA metadataArraySize;\n-\tUDATA numberOfManagers = 0;\n-\tUDATA numberOfCachelets = 0;\n-\tSH_CompositeCacheImpl* walk;\n-\tSH_Manager::CacheletMetadataArray* array;\n-\tUDATA counter = 0;\n-\tUDATA cacheletMetadataSize;\n-\tSH_Manager::CacheletMetadata* currentMeta;\n-\tconst char* fnName = \"buildCacheletMetadata\";\n-\tSH_Manager* walkManager;\n-\tSH_Managers::ManagerWalkState state;\n-\tCacheletHints* firstHint;\n-\tUDATA totalSizeNeeded = sizeof(J9SharedCacheHeader);\n-\t\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\t\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\twalk = _cacheletHead;\n-\twhile (walk) {\n-\t\tif (walk->isStarted()) {\n-\t\t\t++numberOfCachelets;\n-\t\t}\n-\t\twalk = walk->getNext();\n-\t}\n-\n-\twalkManager = managers()->startDo(currentThread, MANAGER_STATE_STARTED, &state);\n-\twhile (walkManager) {\n-\t\tnumberOfManagers++;\n-\t\twalkManager = managers()->nextDo(&state);\n-\t}\n-\n-\t/*\n-\t * Hint collection data structure:\n-\t * one CacheletMetadata per cachelet\n-\t *   one CacheletHints per manager per cachelet - includes data type\n-\t *     one data record per hash item in the manager - data record size can vary by manager\n-\t *\n-\t * Serialized cachelet metadata format:\n-\t * layout CacheletWrapper + (CacheletHints + hint data) x (#cachelets x #managers) + segment list \n-\t *\n-\t * The hint is a key that indicates to the manager which cachelet to load.\n-\t */\n-\tcacheletMetadataSize = sizeof(SH_Manager::CacheletMetadata) + (numberOfManagers * sizeof(CacheletHints));\n-\tmetadataArraySize = sizeof(SH_Manager::CacheletMetadataArray) + (numberOfCachelets * cacheletMetadataSize);\n-\n-\t/* \n-\t * The temp metadata is allocated here in a contiguous block with this format:\n-\t * CacheletMetadataArray | #cachelets x CacheletMetadata | #cachelets x #managers x CacheletHints\n-\t */\n-\tarray = (SH_Manager::CacheletMetadataArray*)j9mem_allocate_memory(metadataArraySize, J9MEM_CATEGORY_CLASSES);\n-\tif (array == NULL) {\n-\t\t_ccHead->exitWriteMutex(currentThread, fnName);\n-\t\treturn -1;\n-\t}\n-\tmemset(array, 0, metadataArraySize);\n-\t\n-\t/* set up the array pointers */\n-\tarray->numMetas = numberOfCachelets;\n-\tarray->metadataArray = (SH_Manager::CacheletMetadata*)&array[1];\n-\tfirstHint = (CacheletHints*)&array->metadataArray[numberOfCachelets]; \n-\t\n-\twalk = _cacheletHead;\n-\tcurrentMeta = &array->metadataArray[0];\n-\twhile (walk) {\n-\t\tif (walk->isStarted()) {\n-\t\t\tcurrentMeta->cachelet = walk;\n-\t\t\tcurrentMeta->numHints = numberOfManagers;\n-\t\t\tcurrentMeta->hintsArray\t= firstHint;\n-\t\t\t++currentMeta;\n-\t\t\tfirstHint += numberOfManagers;\n-\t\t}\n-\t\twalk = walk->getNext();\n-\t}\n-\n-\t/* generate hints */\n-\twalkManager = managers()->startDo(currentThread, MANAGER_STATE_STARTED, &state);\n-\twhile (walkManager) {\n-\t\twalkManager->generateHints(currentThread, array);\n-\t\twalkManager = managers()->nextDo(&state);\n-\t}\n-\n-\tfor (counter=0; counter<array->numMetas; counter++) {\n-\t\tUDATA c2;\n-\t\tSH_Manager::CacheletMetadata* cacheletMetadata = &array->metadataArray[counter];\n-\t\tShcItem item;\n-\t\tShcItem* itemPtr = &item;\n-\t\tU_32 total = sizeof(CacheletWrapper);\n-\t\tfor (c2=0; c2<cacheletMetadata->numHints; c2++) {\n-\t\t\tif (cacheletMetadata->hintsArray[c2].dataType != TYPE_UNINITIALIZED) {\n-\t\t\t\ttotal += (U_32)(sizeof(CacheletHints) + cacheletMetadata->hintsArray[c2].length);\n-\t\t\t}\n-\t\t}\n-\t\ttotal += (U_32)(sizeof(UDATA) * \n-\t\t\t((SH_CompositeCacheImpl*)cacheletMetadata->cachelet)->countROMSegments(currentThread));\n-\t\t_ccHead->initBlockData(&itemPtr, total, TYPE_CACHELET);\n-\t\ttotalSizeNeeded += _ccHead->getBytesRequiredForItemWithAlign(itemPtr, SHC_WORDALIGN, 0);\n-\t}\n-\t/* discard any old metadata by creating a new supercache for the hints */\n-\t/* TODO: could optimize and use the current cache if there is enough room and no existing metadata */\n-\tif (createNewChainedCache(currentThread, totalSizeNeeded + (_ccHead->getOSPageSize() * 2)) == NULL) {  \n-\t\tCACHEMAP_PRINT1(J9NLS_ERROR, J9NLS_SHRC_CM_NO_CACHE_FOR_HINTS, _cacheName);\n-\t\treturn -1;\n-\t}\n-\n-\t/* write hints into the current supercache */\n-\tfor (counter=0; counter<array->numMetas; counter++) {\n-\t\tif (writeCacheletMetadata(currentThread, &array->metadataArray[counter]) != 0) {\n-\t\t\treturn -1;\n-\t\t}\n-\t}\n-\n-\t*metadataArray = array;\n-\n-\treturn 0;\n-}\n-\n-void\n-SH_CacheMap::freeCacheletMetadata(J9VMThread* currentThread, SH_Manager::CacheletMetadataArray* metaArray)\n-{\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\tSH_Manager* walkManager;\n-\tSH_Managers::ManagerWalkState state;\n-\n-\twalkManager = managers()->startDo(currentThread, MANAGER_STATE_STARTED, &state);\n-\twhile (walkManager) {\n-\t\twalkManager->freeHintData(currentThread, metaArray);\n-\t\twalkManager = managers()->nextDo(&state);\n-\t}\n-\tj9mem_free_memory(metaArray);\n-}\n-\n-IDATA\n-SH_CacheMap::readCacheletHints(J9VMThread* currentThread, SH_CompositeCacheImpl* cachelet, CacheletWrapper* cacheletWrapper)\n-{\n-\tUDATA counter = 0;\n-\tCacheletHints* currentHints = (CacheletHints*)CLETHINTS(cacheletWrapper);\n-\n-\tfor (counter=0; counter<cacheletWrapper->numHints; counter++) {\n-\t\tSH_Manager* managerForType;\n-\t\t\n-\t\t/* With Cachelets, all managers should already be started */\n-\t\tmanagerForType = managers()->getManagerForDataType(currentHints->dataType);\n-\t\tif (NULL == managerForType) {\n-\t\t\tTrc_SHR_CM_readCacheletHints_noManager(currentThread, currentHints->dataType);\n-\t\t\tif (0 == currentHints->length) {\n-\t\t\t\t/* Doesn't matter if the manager can't be found when there are no hints */\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tTrc_SHR_Assert_ShouldNeverHappen();\n-\t\t\tcontinue;\n-\t\t}\n-\t\t/* currentHints->data is NULL; don't use it. The hint data was copied directly after the CacheletHint structure. */\n-\t\tmanagerForType->primeFromHints(currentThread, cachelet, (U_8*)&currentHints[1], currentHints->length);\n-\t\tcurrentHints = (CacheletHints*)((UDATA)currentHints + (currentHints->length + sizeof(CacheletHints)));\n-\t}\n-\treturn 0;\n-}\n-\n-/**\n- * Create the class memory segments for a cachelet.\n- * Do this when the cachelet is initialized, rather than when startup() is called,\n- * because we may not be able to get the class segment mutex when startup() is called.\n- * @param[in] currentThread The current thread.\n- * @param[in] cachelet The cachelet.\n- * @param[in] cacheletWrapper The cachelet metadata.\n- * @retval true success\n- * @retval false failure\n- * @pre Owns the VM class segment mutex\n- * @post Owns the VM class segment mutex\n- */\n-bool\n-SH_CacheMap::readCacheletSegments(J9VMThread* currentThread, SH_CompositeCacheImpl* cachelet, CacheletWrapper* cacheletWrapper)\n-{\n-\tU_8* cursor = CLETHINTS(cacheletWrapper);\n-\tUDATA* segmentLengths = NULL;\n-\tU_8* firstBaseAddress = NULL;\n-\tU_8* baseAddress = NULL;\n-\tJ9MemorySegment* segment = NULL;\n-\tUDATA i;\n-\t\n-\tTrc_SHR_Assert_True(omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex));\n-\t\n-\tif (cacheletWrapper->numSegments == 0) {\n-\t\tTrc_SHR_CM_readCacheletSegments_noSegments(currentThread, cachelet, cacheletWrapper);\n-\t\treturn true;\n-\t}\n-\t\n-\t/* scan past the hints */\n-\tfor (i = 0; i < cacheletWrapper->numHints; ++i) {\n-\t\tCacheletHints* hint = (CacheletHints*)cursor;\n-\t\tcursor += hint->length + sizeof(CacheletHints); \n-\t}\n-\t\n-\t/* Scan the segment lengths. Note that _theca isn't initialized. */\n-\tfirstBaseAddress = baseAddress = (U_8*)(cachelet->getNestedMemory()) + cacheletWrapper->segmentStartOffset;\n-\tsegmentLengths = (UDATA*)cursor;\n-\tfor (i = 0; i < cacheletWrapper->numSegments; ++i) {\n-\t\tsegment = addNewROMImageSegment(currentThread, baseAddress, baseAddress + *segmentLengths);\n-\t\tif (!segment) {\n-\t\t\tTrc_SHR_CM_readCacheletSegments_addSegmentFailed(currentThread,\n-\t\t\t\t\tcachelet, cacheletWrapper, i, baseAddress, baseAddress + *segmentLengths);\n-\t\t\treturn false;\n-\t\t}\n-\t\tsegment->heapAlloc = segment->heapTop;\n-\n-\t\tbaseAddress += *segmentLengths;\n-\t\t++segmentLengths;\n-\t}\n-\t/* the last segment may not be fully allocated */\n-\tsegment->heapAlloc = segment->heapBase + cacheletWrapper->lastSegmentAlloc;\n-\tcachelet->setCurrentROMSegment(segment);\n-\t\n-\tTrc_SHR_CM_readCacheletSegments_addedSegments(currentThread,\n-\t\t\tcachelet, cacheletWrapper,\n-\t\t\tcacheletWrapper->numSegments,\n-\t\t\tfirstBaseAddress,\n-\t\t\tsegment->heapTop,\n-\t\t\tsegment->heapAlloc,\n-\t\t\tcachelet->getCurrentROMSegment());\n-\treturn true;\n-}\n-\n-IDATA\n-SH_CacheMap::writeCacheletMetadata(J9VMThread* currentThread, SH_Manager::CacheletMetadata* cacheletMetadata)\n-{\n-\tSH_CompositeCacheImpl* cachelet = (SH_CompositeCacheImpl*)cacheletMetadata->cachelet;\n-\tShcItem item;\n-\tShcItem* itemPtr = &item;\n-\tShcItem* itemInCache = NULL;\n-\tCacheletWrapper cw;\n-\tCacheletWrapper* cwInCache = NULL;\n-\tU_32 totalSizeNeeded = sizeof(CacheletWrapper);\n-\tUDATA counter = 0;\n-\tBlockPtr cursor;\n-\tUDATA hintsUsed = 0;\n-\tUDATA numSegments = 0;\n-\tPORT_ACCESS_FROM_VMC(currentThread);\n-\n-\tTrc_SHR_Assert_True(_ccHead->hasWriteMutex(currentThread));\n-\n-\t/* TODO If you don't write hints for a manager, then when the cache is started, the manager\n-\t * won't consider itself _isRunningNested. So we have to write something even if there\n-\t * are no hints.\n-\t */\n-\tfor (counter=0; counter<cacheletMetadata->numHints; counter++) {\n-\t\tCacheletHints* currentHints = &cacheletMetadata->hintsArray[counter];\n-\t\tif ((currentHints->dataType != TYPE_UNINITIALIZED) && (currentHints->length > 0)) {\n-\t\t\ttotalSizeNeeded += (U_32)(sizeof(CacheletHints) + currentHints->length);\n-\t\t\t++hintsUsed;\n-\t\t}\n-\t}\n-\n-\tnumSegments = cachelet->countROMSegments(currentThread);\n-\ttotalSizeNeeded += (U_32)(sizeof(UDATA) * numSegments);\n-\n-\t/* TODO the granularity of a block is 1M. Most of it may be wasted. */\n-\t_ccHead->initBlockData(&itemPtr, totalSizeNeeded, TYPE_CACHELET);\n-\titemInCache = (ShcItem*)_cc->allocateBlock(currentThread, itemPtr, SHC_WORDALIGN, 0);\n-\t\n-\tif (itemInCache == NULL) {\n-\t\t/* There are 3 failure conditions when allocate() can return NULL */\n-\t\tif (true == _cc->isCacheMarkedFull(currentThread)) {\n-\t\t\tCACHEMAP_PRINT2(J9NLS_ERROR, J9NLS_SHRC_CM_CACHE_FULL, _cacheName, totalSizeNeeded);\n-\t\t} else if (_cc->isCacheCorrupt()) {\n-\t\t\tCACHEMAP_PRINT(J9NLS_ERROR, J9NLS_SHRC_CM_CACHE_CORRUPT);\n-\t\t} else {\n-\t\t\tI_32 freeBlockBytes = _cc->getFreeBlockBytes();\n-\t\t\tJ9SharedClassJavacoreDataDescriptor descriptor;\n-\t\t\tCACHEMAP_PRINT3(J9NLS_ERROR, J9NLS_SHRC_CM_INSUFFICIENT_FREE_BLOCK, _cacheName, freeBlockBytes, totalSizeNeeded);\n-\t\t\tj9tty_printf(PORTLIB, \"Free bytes: %d\\t\", _cc->getFreeBytes());\n-\t\t\tj9tty_printf(PORTLIB, \"AOT bytes: %d\\t\", _cc->getAOTBytes());\n-\t\t\tj9tty_printf(PORTLIB, \"JIT bytes: %d\\n\", _cc->getJITBytes());\n-\t\t\tif (1 == getJavacoreData(currentThread->javaVM, &descriptor)) {\n-\t\t\t\tj9tty_printf(PORTLIB, \"minAOT: %d\\t\", descriptor.minAOT);\n-\t\t\t\tj9tty_printf(PORTLIB, \"minJIT: %d\\n\", descriptor.minJIT);\n-\t\t\t}\n-\t\t}\n-\t\tCACHEMAP_PRINT1(J9NLS_ERROR, J9NLS_SHRC_CM_NO_BLOCK_FOR_HINTS, _cacheName);\n-\t\treturn -1;\n-\t}\n-\n-\t/* construct CacheletWrapper */\n-\tcwInCache = (CacheletWrapper*)ITEMDATA(itemInCache);\n-\tcw.dataStart = (J9SRP)((UDATA)cachelet->getCacheHeaderAddress() - (UDATA)cwInCache);\n-\tcw.dataLength = cachelet->getCacheMemorySize();\n-\tcw.numHints = hintsUsed;\n-\tcw.numSegments = numSegments;\n-\tcw.segmentStartOffset = (UDATA)cachelet->getBaseAddress() - (UDATA)cachelet->getCacheHeaderAddress();\n-\tmemcpy(cwInCache, &cw, sizeof(CacheletWrapper));\n-\tcacheletMetadata->wrapperAddress = cwInCache;\n-\t\n-\t/* construct hints */\n-\tcursor = (BlockPtr)cwInCache + sizeof(CacheletWrapper);\n-\tfor (counter=0; counter<cacheletMetadata->numHints; counter++) {\n-\t\tCacheletHints* currentHints = &cacheletMetadata->hintsArray[counter];\n-\t\t\n-\t\t/* skip uninitialized and zero length hints */\n-\t\tif ((currentHints->dataType != TYPE_UNINITIALIZED) && (currentHints->length > 0)) {\n-\t\t\tmemcpy(cursor, currentHints, sizeof(CacheletHints));\n-\t\t\t/* cursor->data should be an address in the target cache.\n-\t\t\t * It can't be set to an absolute value.\n-\t\t\t */\n-\t\t\t((CacheletHints*)cursor)->data = NULL;\n-\t\t\tcursor += sizeof(CacheletHints);\n-\n-\t\t\tmemcpy(cursor, currentHints->data, currentHints->length);\n-\t\t\tcursor += currentHints->length;\n-\t\t}\n-\t}\n-\n-\t/* construct segments */\n-\tcachelet->writeROMSegmentMetadata(currentThread, numSegments, cursor, &cwInCache->lastSegmentAlloc);\n-\n-\t_cc->commitUpdate(currentThread, false);\n-\n-\treturn 0;\n-}\n-\n-#if 0\n-/** \n- * Grow cache in place.\n- */\n-IDATA\n-SH_CacheMap::growCacheInPlace(J9VMThread* currentThread, UDATA rwGrowth, UDATA freeGrowth)\n-{\n-\tBlockPtr srcSegmentStart, srcSegmentEnd;\n-\tUDATA srcSegmentLen;\n-\n-\t/* relocate the cachelets, and then move them */\n-\tBlockPtr newBase = (BlockPtr)_cc->getBaseAddress() + rwGrowth;\n-\tthis->setDeployedROMClassStarts(currentThread, newBase);\n-\tif (this->fixupCompiledMethodsForSerialization(currentThread,newBase)!= 0) {\n-\t\t/*TODO ... possibly return -1*/\n-\t}\n-\tsrcSegmentStart = (BlockPtr)_cc->getBaseAddress();\n-\tsrcSegmentEnd = (BlockPtr)_cc->getCacheEndAddress();\n-\tsrcSegmentLen = srcSegmentEnd - srcSegmentStart;\n-\tmemmove(newBase, srcSegmentStart, srcSegmentLen);\n-\tmemset(srcSegmentStart, 0, rwGrowth);\n-\t_cc->growCacheInPlace(rwGrowth, freeGrowth);\n-\tif (resetAllManagers(currentThread) != 0) {\n-\t\treturn -1;\n-\t}\n-\treturn readCache(currentThread, _cc, -1, false);\n-}\n-#endif\n-\n-\n-/**\n- * Serialize a chained growable cache to one big deployment cache.\n- * \n- * @retval true succeeded\n- * @retval false failed\n- */\n-bool\n-SH_CacheMap::serializeSharedCache(J9VMThread* currentThread)\n-{\n-\tbool ok = true;\n-\tconst char* fnName = \"serializeSharedCache\";\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\tif (_runningNested) {\n-\t\tif (!currentThread) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (_ccHead->enterWriteMutex(currentThread, true, fnName) != 0) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!_isSerialized) {\n-\t\t\tok = serializeOfflineCache(currentThread);\n-\t\t\t_isSerialized = true;\n-\t\t}\n-\t\t_ccHead->exitWriteMutex(currentThread, fnName);\n-\t}\n-#endif\n-\treturn ok;\n-}\n-\n-/**\n- * Serialize this chained cache to one big deployment cache.\n- * The chained cache contents are no longer usable after this.\n- * @param[in] this chain of supercaches\n- * @param[in] currentThread\n- * @retval true succeeded\n- * @retval false failed. We may have deleted the serialized cache because it was corrupt.\n- * \n- */\n-bool\n-SH_CacheMap::serializeOfflineCache(J9VMThread* currentThread)\n-{\n-\tSH_CompositeCacheImpl* serializedCache = NULL;\n-\tSH_CompositeCacheImpl* supercache;\n-\tSH_CompositeCacheImpl* cachelet;\n-\tJ9SharedClassConfig config;\n-\tJ9SharedClassPreinitConfig piconfig;\n-\tJ9SharedClassCacheDescriptor newCacheDesc;\n-\tU_32 actualSize;\n-\tUDATA localCrashCntr;\n-\tbool cacheHasIntegrity;\n-\tJ9JavaVM* vm = currentThread->javaVM;\n-\tvoid* objectMemory;\n-\tUDATA totalMetadataSize = 0;\n-\tUDATA totalCacheletSize = 0;\n-#if defined(J9SHR_CACHELETS_SAVE_READWRITE_AREA)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 923}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2MTUxMg==", "bodyText": "Trc_SHR_CMI_primeHashtables_addingHint and Trc_SHR_CMI_primeHashtables_failedToPrimeHint can be marked as Obsolete", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504061512", "createdAt": "2020-10-13T15:46:08Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1453,147 +1437,3 @@ SH_ClasspathManagerImpl2::getNumItemsByType(UDATA* numClasspaths, UDATA* numURLs\n \t*numURLs = _urlCount;\n \t*numTokens = _tokenCount;\n }\n-\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\n-/**\n- * Walk the managed items hashtable in this cachelet. Allocate and populate an array\n- * of hints, one for each hash entry.\n- *\n- * @param[in] self a data type manager\n- * @param[in] vmthread the current VMThread\n- * @param[out] hints a CacheletHints structure. This function fills in its\n- * contents.\n- *\n- * @retval 0 success\n- * @retval -1 failure\n- */\n-IDATA\n-SH_ClasspathManagerImpl2::createHintsForCachelet(J9VMThread* vmthread, SH_CompositeCache* cachelet, CacheletHints* hints)\n-{\n-\tTrc_SHR_Assert_True(hints != NULL);\n-\n-\t/* hints->dataType should have been set by the caller */\n-\tTrc_SHR_Assert_True(hints->dataType == _dataTypesRepresented[0]);\n-\t\n-\treturn cpeCollectHashes(vmthread, cachelet, hints);\n-}\n-\n-/**\n- * add a (_hashValue, cachelet) entry to the hash table\n- * only called with hints of the right data type \n- *\n- * each hint is a UDATA-length hash of a string\n- * \n- * This method is not threadsafe.\n- */\n-IDATA\n-SH_ClasspathManagerImpl2::primeHashtables(J9VMThread* vmthread, SH_CompositeCache* cachelet, U_8* hintsData, UDATA dataLength)\n-{\n-\tUDATA* hashSlot = (UDATA*)hintsData;\n-\tUDATA hintCount = 0;\n-\n-\tif ((dataLength == 0) || (hintsData == NULL)) {\n-\t\treturn 0;\n-\t}\n-\n-\thintCount = dataLength / sizeof(UDATA);\n-\twhile (hintCount-- > 0) {\n-\t\tTrc_SHR_CMI_primeHashtables_addingHint(vmthread, cachelet, *hashSlot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2Mzk4NQ==", "bodyText": "The above #if defined(J9SHR_CACHELETS_SAVE_READWRITE_AREA) and code inside it can also be removed.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504063985", "createdAt": "2020-10-13T15:49:36Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CompositeCache.cpp", "diffHunk": "@@ -2835,11 +2712,6 @@ SH_CompositeCacheImpl::allocate(J9VMThread* currentThread, U_8 type, ShcItem* it\n \t\t\tif (readWriteBuffer) {\n #if defined(J9SHR_CACHELETS_SAVE_READWRITE_AREA)\n \t\t\t\t*readWriteBuffer = parent->allocateReadWrite(separateBufferSize);\n-#if defined(J9SHR_CACHELET_SUPPORT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3Mzc4Nw==", "bodyText": "You can remove the flag J9SHR_RUNTIMEFLAG_ENABLE_NESTED in shcflags.h and make a comment there say bit 0x10000 is free to use. All the code checking this flag can also be removed.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504073787", "createdAt": "2020-10-13T16:02:51Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -352,9 +342,6 @@ J9SharedClassesOptions J9SHAREDCLASSESOPTIONS[] = {\n \t{ OPTION_RESTORE_FROM_SNAPSHOT, PARSE_TYPE_EXACT, RESULT_DO_RESTORE_FROM_SNAPSHOT, J9SHR_RUNTIMEFLAG_RESTORE},\n \t{ OPTION_PRINT_SNAPSHOTNAME, PARSE_TYPE_EXACT, RESULT_DO_PRINT_SNAPSHOTNAME, 0},\n #endif /* !defined(WIN32) */\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\t{ OPTION_NESTED, PARSE_TYPE_EXACT, RESULT_DO_ADD_RUNTIMEFLAG, J9SHR_RUNTIMEFLAG_ENABLE_NESTED},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3NTUwMw==", "bodyText": "OPTION_NESTED can also be removed.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504075503", "createdAt": "2020-10-13T16:05:27Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -352,9 +342,6 @@ J9SharedClassesOptions J9SHAREDCLASSESOPTIONS[] = {\n \t{ OPTION_RESTORE_FROM_SNAPSHOT, PARSE_TYPE_EXACT, RESULT_DO_RESTORE_FROM_SNAPSHOT, J9SHR_RUNTIMEFLAG_RESTORE},\n \t{ OPTION_PRINT_SNAPSHOTNAME, PARSE_TYPE_EXACT, RESULT_DO_PRINT_SNAPSHOTNAME, 0},\n #endif /* !defined(WIN32) */\n-#if defined(J9SHR_CACHELET_SUPPORT)\n-\t{ OPTION_NESTED, PARSE_TYPE_EXACT, RESULT_DO_ADD_RUNTIMEFLAG, J9SHR_RUNTIMEFLAG_ENABLE_NESTED},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3Mzc4Nw=="}, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3NzQ1Mw==", "bodyText": "Nothing is changed in this file. So no need to update the copyright date.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504077453", "createdAt": "2020-10-13T16:08:18Z", "author": {"login": "hangshao0"}, "path": "runtime/tests/shared/CompositeCacheSizesTests.hpp", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2001, 2017 IBM Corp. and others\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3OTIzNg==", "bodyText": "No need to update the copyright date.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504079236", "createdAt": "2020-10-13T16:10:58Z", "author": {"login": "hangshao0"}, "path": "runtime/tests/shared/SCStringTransactionTests.hpp", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2001, 2014 IBM Corp. and others\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 3}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8f5d420218bc4ccec6f2887401666a572f1a5de6", "committedDate": "2020-10-10T21:11:45Z", "message": "Fix CompositeCacheSizesTests\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}, "afterCommit": {"oid": "e4d9018d65bdc5a2454c41f8ce6c55accc93a035", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e4d9018d65bdc5a2454c41f8ce6c55accc93a035", "committedDate": "2020-10-14T19:17:29Z", "message": "Remove J9SHR_CACHELET_SUPPORT macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT macro and related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NjY0MjAy", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#pullrequestreview-508664202", "createdAt": "2020-10-14T19:32:15Z", "commit": {"oid": "e4d9018d65bdc5a2454c41f8ce6c55accc93a035"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxOTozMjoxNVrOHhiBRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMTowODoxOVrOHhlG8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyMjQzNw==", "bodyText": "_ccCacheletHead and _prevCClastCachelet can also be removed.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504922437", "createdAt": "2020-10-14T19:32:15Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CacheMap.hpp", "diffHunk": "@@ -299,9 +289,7 @@ class SH_CacheMap : public SH_SharedCache, public SH_CacheMapStats\n \tJ9SharedClassConfig* _sharedClassConfig;\n \t\n \tSH_CompositeCacheImpl* _ccHead;\t\t\t\t/* head of supercache list */\n-\tSH_CompositeCacheImpl* _cacheletHead;\t\t/* head of all known cachelets */\n \tSH_CompositeCacheImpl* _ccCacheletHead;\t\t/* head of cachelet list for current cache */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d9018d65bdc5a2454c41f8ce6c55accc93a035"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzNDg2OA==", "bodyText": "There is one more #if defined(J9SHR_CACHELETS_SAVE_READWRITE_AREA) above in the function at line 2799 (or line 2676 with your change)", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504934868", "createdAt": "2020-10-14T19:54:43Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CompositeCache.cpp", "diffHunk": "@@ -2835,11 +2712,6 @@ SH_CompositeCacheImpl::allocate(J9VMThread* currentThread, U_8 type, ShcItem* it\n \t\t\tif (readWriteBuffer) {\n #if defined(J9SHR_CACHELETS_SAVE_READWRITE_AREA)\n \t\t\t\t*readWriteBuffer = parent->allocateReadWrite(separateBufferSize);\n-#if defined(J9SHR_CACHELET_SUPPORT)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA2Mzk4NQ=="}, "originalCommit": {"oid": "8f5d420218bc4ccec6f2887401666a572f1a5de6"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzNzE1Ng==", "bodyText": "The indentation in this block looks incorrect to me. I guess you are using spaces instead of tabs ?", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504937156", "createdAt": "2020-10-14T19:58:52Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/CompositeCache.cpp", "diffHunk": "@@ -2872,30 +2741,22 @@ SH_CompositeCacheImpl::allocate(J9VMThread* currentThread, U_8 type, ShcItem* it\n \t\tSH_CompositeCacheImpl *ccToUse = ((_ccHead == NULL) ? ((_parent == NULL) ? this : _parent->_ccHead) : _ccHead);\n \n \t\tif (ALLOCATE_TYPE_AOT == type) {\n-\t\t\tTrc_SHR_Assert_True((0 == (*_runtimeFlags & J9SHR_RUNTIMEFLAG_ENABLE_NESTED)));\n \t\t\tflags |= J9SHR_AOT_SPACE_FULL;\n \t\t} else if (ALLOCATE_TYPE_JIT == type) {\n-\t\t\tTrc_SHR_Assert_True((0 == (*_runtimeFlags & J9SHR_RUNTIMEFLAG_ENABLE_NESTED)));\n \t\t\tflags |= J9SHR_JIT_SPACE_FULL;\n \t\t} else {\n-\t\t\tif (0 != (*_runtimeFlags & J9SHR_RUNTIMEFLAG_ENABLE_NESTED)) {\n-\t\t\t\t/* For realtime cache, allocation failure can happen only when trying to allocate new cachelet. */\n-\t\t\t\tTrc_SHR_Assert_Equals(itemToWrite->dataType, TYPE_CACHELET);\n-\t\t\t\tflags |= J9SHR_BLOCK_SPACE_FULL;\n-\t\t\t} else {\n-\t\t\t\tI_32 freeBlockBytes = getFreeBlockBytes();\n-\t\t\t\t/* Allocation request for BLOCK data can fail if\n-\t\t\t\t * \t\trequested amount > freeBlockBytes >= CC_MIN_SPACE_BEFORE_CACHE_FULL, or\n-\t\t\t\t * \t\trequested amount > freeBlockBytes < (J9SHR_MIN_GAP_BEFORE_METADATA + J9SHR_MIN_DUMMY_DATA_SIZE).\n-\t\t\t\t * In first case we don't want to set J9SHR_RUNTIMEFLAG_BLOCK_SPACE_FULL as free block bytes is above threshold.\n-\t\t\t\t * In second case we don't need to set J9SHR_RUNTIMEFLAG_BLOCK_SPACE_FULL as it would have been done in previous commit.\n-\t\t\t\t */\n-\t\t\t\tif (freeBlockBytes < (I_32) (J9SHR_MIN_GAP_BEFORE_METADATA + J9SHR_MIN_DUMMY_DATA_SIZE)) {\n-\t\t\t\t\tTrc_SHR_Assert_True(J9SHR_BLOCK_SPACE_FULL == (J9SHR_BLOCK_SPACE_FULL & _theca->cacheFullFlags));\n-\t\t\t\t} else {\n-\t\t\t\t\tTrc_SHR_Assert_True(freeBlockBytes >= (I_32) CC_MIN_SPACE_BEFORE_CACHE_FULL);\n-\t\t\t\t}\n-\t\t\t}\n+            I_32 freeBlockBytes = getFreeBlockBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d9018d65bdc5a2454c41f8ce6c55accc93a035"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk3MzA0MQ==", "bodyText": "Nothing is changed in this file, so no need to change the copyright date.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r504973041", "createdAt": "2020-10-14T21:08:19Z", "author": {"login": "hangshao0"}, "path": "runtime/shared_common/Managers.cpp", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2001, 2014 IBM Corp. and others\n+ * Copyright (c) 2001, 2020 IBM Corp. and others", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d9018d65bdc5a2454c41f8ce6c55accc93a035"}, "originalPosition": 3}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e4d9018d65bdc5a2454c41f8ce6c55accc93a035", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e4d9018d65bdc5a2454c41f8ce6c55accc93a035", "committedDate": "2020-10-14T19:17:29Z", "message": "Remove J9SHR_CACHELET_SUPPORT macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT macro and related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}, "afterCommit": {"oid": "82c7505435c7dfbaf27471eddd8ec9858a3c4857", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/82c7505435c7dfbaf27471eddd8ec9858a3c4857", "committedDate": "2020-10-14T21:19:59Z", "message": "Remove J9SHR_CACHELET_SUPPORT macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT macro and related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82c7505435c7dfbaf27471eddd8ec9858a3c4857", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/82c7505435c7dfbaf27471eddd8ec9858a3c4857", "committedDate": "2020-10-14T21:19:59Z", "message": "Remove J9SHR_CACHELET_SUPPORT macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT macro and related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}, "afterCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/bf3d5c6395d7545086d0abf175193af19ed0e3f7", "committedDate": "2020-10-14T21:35:29Z", "message": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro along with related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzkyNDU3", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#pullrequestreview-508792457", "createdAt": "2020-10-14T21:45:13Z", "commit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4ODI4Mzkx", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#pullrequestreview-508828391", "createdAt": "2020-10-14T22:58:57Z", "commit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjo1ODo1OFrOHhphHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMzoxNDo0M1rOHhqK9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA0NTI3OA==", "bodyText": "Pls fix the indenting here and the next line, to use tabs.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505045278", "createdAt": "2020-10-14T22:58:58Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CompositeCache.cpp", "diffHunk": "@@ -6053,13 +5414,8 @@ SH_CompositeCacheImpl::setRuntimeCacheFullFlags(J9VMThread* currentThread)\n \t\t\t\tCC_TRACE1(J9SHR_VERBOSEFLAG_ENABLE_VERBOSE, J9NLS_INFO, J9NLS_SHRC_CM_WARN_FULL_CACHE, _cacheName);\n \t\t\t} else {\n \t\t\t\tif (0 != (cacheFullFlags & J9SHR_RUNTIMEFLAG_BLOCK_SPACE_FULL)) {\n-\t\t\t\t\tif (0 != (cacheFullFlags & J9SHR_RUNTIMEFLAG_ENABLE_NESTED)) {\n-\t\t\t\t\t\t/* If we requested a growable cache, this is an error. */\n-\t\t\t\t\t\tCC_TRACE1(J9SHR_VERBOSEFLAG_ENABLE_VERBOSE_DEFAULT, J9NLS_INFO, J9NLS_SHRC_CM_WARN_FULL_CACHE, _cacheName);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t/* Only report Block data space full to std-err with verbose enabled */\n-\t\t\t\t\t\tCC_TRACE1(J9SHR_VERBOSEFLAG_ENABLE_VERBOSE, J9NLS_INFO, J9NLS_SHRC_CM_WARN_BLOCK_SPACE_FULL, _cacheName);\n-\t\t\t\t\t}\n+                    /* Only report Block data space full to std-err with verbose enabled */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "originalPosition": 837}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1MTA0MQ==", "bodyText": "Pls remove the isNested parameter of getFirstROMClassAddress().", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505051041", "createdAt": "2020-10-14T23:07:30Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -1049,7 +971,7 @@ SH_CacheMap::initializeROMSegmentList(J9VMThread* currentThread)\n \tTrc_SHR_CM_initializeROMSegmentList_Entry(currentThread);\n \n \tcacheBase = (U_8*)_ccHead->getBaseAddress();\n-\tfirstROMClassAddress = _ccHead->getFirstROMClassAddress(_runningNested);\n+\tfirstROMClassAddress = _ccHead->getFirstROMClassAddress(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDE3Nw==", "bodyText": "All these primeHashtables tracepoints are Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505054177", "createdAt": "2020-10-14T23:12:09Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1774,8 +1774,8 @@ TraceExit=Trc_SHR_OSC_recreateSemaphore_Exit4Obsolete NoEnv Obsolete Overhead=1\n TraceEvent=Trc_SHR_BDMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"BDMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n TraceException=Trc_SHR_BDMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"BDMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n TraceEvent=Trc_SHR_RMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"RMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDY1Mw==", "bodyText": "Obsolete", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505054653", "createdAt": "2020-10-14T23:12:51Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1788,11 +1788,11 @@ TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1\n \n TraceExit=Trc_SHR_CC_startup_Exit8 Overhead=1 Level=1 Template=\"CC startup: Exiting due to running nested on existing cache not containing cachelets\"\n \n-TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n-TraceExit=Trc_SHR_CM_createNewCachelet_Exit Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n+TraceExit=Trc_SHR_CM_createNewCachelet_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n \n-TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n-TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n+TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n \n TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDgyNA==", "bodyText": "Obsolete", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505054824", "createdAt": "2020-10-14T23:13:07Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1788,11 +1788,11 @@ TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1\n \n TraceExit=Trc_SHR_CC_startup_Exit8 Overhead=1 Level=1 Template=\"CC startup: Exiting due to running nested on existing cache not containing cachelets\"\n \n-TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n-TraceExit=Trc_SHR_CM_createNewCachelet_Exit Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n+TraceExit=Trc_SHR_CM_createNewCachelet_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n \n-TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n-TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n+TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n \n TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"\n TraceException=Trc_SHR_CM_writeROMClassToCache_failedToReStoreClasspath Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Failed to re-store classpath in new supercache. Classpath item=0x%p, size=%u. Supercache free=%u, total=%u. Cachelet free=%u, total=%u.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NDk3MA==", "bodyText": "These 2 are Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505054970", "createdAt": "2020-10-14T23:13:19Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1804,36 +1804,36 @@ TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Templ\n TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTIwNA==", "bodyText": "Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505055204", "createdAt": "2020-10-14T23:13:37Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1804,36 +1804,36 @@ TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Templ\n TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTM0NQ==", "bodyText": "These 2 are Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505055345", "createdAt": "2020-10-14T23:13:50Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1804,36 +1804,36 @@ TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Templ\n TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"\n \n-TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv  Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n+TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Returned from init method\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTc0Mg==", "bodyText": "These 4 are Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505055742", "createdAt": "2020-10-14T23:14:24Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1804,36 +1804,36 @@ TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Templ\n TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"\n \n-TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv  Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n+TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Returned from init method\"\n TraceExit=Trc_SHR_OSC_Vmem_startup_Exit NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successful exit\"\n \n-TraceEntry=Trc_SHR_OSC_Vmem_attach_Entry Obsolete NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Entered\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_corruptCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is corrupt\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_differentBuildID NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: cache has an unrecognised buildID\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_invalidCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is invalid\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_validCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is valid\"\n+TraceEntry=Trc_SHR_OSC_Vmem_attach_Entry NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Entered\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_corruptCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is corrupt\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_differentBuildID NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: cache has an unrecognised buildID\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_invalidCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is invalid\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_validCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is valid\"\n \n TraceEntry=Trc_SHR_M_startupHintCachelets_Entry Overhead=1 Level=1 Template=\"M startupHintCachelets: hint=%u\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTk4OA==", "bodyText": "These 3 are Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505055988", "createdAt": "2020-10-14T23:14:43Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1844,8 +1844,8 @@ TraceException=Trc_SHR_M_startupHintCachelets_lockStartupMonitorFailed Overhead=\n TraceException=Trc_SHR_RRM_rrmTableLookup_lockStartupMonitorFailed Overhead=1 Level=1 Template=\"RRM rrmTableLookup: Can't lock startup monitor, rc=%d, cachelet=0x%p, for hint=0x%p\"\n TraceException=Trc_SHR_CC_newInstanceNested_allocStartupMonitorFailed NoEnv Overhead=1 Level=1 Template=\"CC newInstanceNested: Failed to allocate _startupMonitor for cachelet %p\"\n \n-TraceEvent=Trc_SHR_CM_readCache_initCachelet Overhead=1 Level=1 Template=\"CM readCache: init new cachelet, cachelet=0x%p cacheletMemory=0x%p\"\n-TraceException=Trc_SHR_CM_readCache_initCacheletFailed Overhead=1 Level=1 Template=\"CM readCache: init new cachelet failed, cacheletMemory=0x%p\"\n+TraceEvent=Trc_SHR_CM_readCache_initCachelet Obsolete Overhead=1 Level=1 Template=\"CM readCache: init new cachelet, cachelet=0x%p cacheletMemory=0x%p\"\n+TraceException=Trc_SHR_CM_readCache_initCacheletFailed Obsolete Overhead=1 Level=1 Template=\"CM readCache: init new cachelet failed, cacheletMemory=0x%p\"\n TraceEvent=Trc_SHR_CM_readCacheletSegments_noSegments Overhead=1 Level=1 Template=\"CM readCacheletSegments: No class segments for cachelet 0x%p, wrapper=0x%p\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7"}, "originalPosition": 99}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bf3d5c6395d7545086d0abf175193af19ed0e3f7", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/bf3d5c6395d7545086d0abf175193af19ed0e3f7", "committedDate": "2020-10-14T21:35:29Z", "message": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro along with related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}, "afterCommit": {"oid": "1253518c01a6c38abe109969af22e325cf78855b", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/1253518c01a6c38abe109969af22e325cf78855b", "committedDate": "2020-10-15T20:58:04Z", "message": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro along with related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODYyMTQw", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#pullrequestreview-509862140", "createdAt": "2020-10-15T22:51:59Z", "commit": {"oid": "1253518c01a6c38abe109969af22e325cf78855b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMjo1MTo1OVrOHieLsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMjo1MzozMlrOHieNvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwODE0NA==", "bodyText": "These two are Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505908144", "createdAt": "2020-10-15T22:51:59Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1771,84 +1771,84 @@ TraceAssert=Trc_SHR_Assert_True_KNOWNPROBLEM NoEnv Obsolete Overhead=1 Level=3 A\n \n TraceExit=Trc_SHR_OSC_recreateSemaphore_Exit4Obsolete NoEnv Obsolete Overhead=1 Level=1 Group=OSCache Template=\"OSCache recreateSemaphore Exit, failure = semaphore id is different, semid in cache header=%d, current %d\"\n \n-TraceEvent=Trc_SHR_BDMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"BDMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_BDMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"BDMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_BDMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"BDMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_BDMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"BDMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_RMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"RMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_RMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"RMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_RMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"RMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_RMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"RMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_RRM_primeHashtables_addingHint Overhead=9 Level=9 Template=\"RRM primeHashtables: Adding hint, cachelet=0x%p hashValue=0x%p\"\n-TraceException=Trc_SHR_RRM_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"RRM primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=0x%p\"\n+TraceEvent=Trc_SHR_RRM_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"RRM primeHashtables: Adding hint, cachelet=0x%p hashValue=0x%p\"\n+TraceException=Trc_SHR_RRM_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"RRM primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=0x%p\"\n \n-TraceEvent=Trc_SHR_SMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"SMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"SMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_SMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"SMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"SMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n TraceExit=Trc_SHR_CC_startup_Exit8 Overhead=1 Level=1 Template=\"CC startup: Exiting due to running nested on existing cache not containing cachelets\"\n \n-TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n-TraceExit=Trc_SHR_CM_createNewCachelet_Exit Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n+TraceExit=Trc_SHR_CM_createNewCachelet_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n \n-TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n-TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n+TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n \n-TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"\n-TraceException=Trc_SHR_CM_writeROMClassToCache_failedToReStoreClasspath Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Failed to re-store classpath in new supercache. Classpath item=0x%p, size=%u. Supercache free=%u, total=%u. Cachelet free=%u, total=%u.\"\n+TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Obsolete Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"\n+TraceException=Trc_SHR_CM_writeROMClassToCache_failedToReStoreClasspath Obsolete Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Failed to re-store classpath in new supercache. Classpath item=0x%p, size=%u. Supercache free=%u, total=%u. Cachelet free=%u, total=%u.\"\n \n TraceExit=Trc_SHR_CM_addROMClassToCache_ExitFull Overhead=1 Level=1 Template=\"CM addROMClassToCache: Exiting due to full cache\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1253518c01a6c38abe109969af22e325cf78855b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwODY2OQ==", "bodyText": "These 3 are Obsolete.", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#discussion_r505908669", "createdAt": "2020-10-15T22:53:32Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -1771,84 +1771,84 @@ TraceAssert=Trc_SHR_Assert_True_KNOWNPROBLEM NoEnv Obsolete Overhead=1 Level=3 A\n \n TraceExit=Trc_SHR_OSC_recreateSemaphore_Exit4Obsolete NoEnv Obsolete Overhead=1 Level=1 Group=OSCache Template=\"OSCache recreateSemaphore Exit, failure = semaphore id is different, semid in cache header=%d, current %d\"\n \n-TraceEvent=Trc_SHR_BDMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"BDMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_BDMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"BDMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_BDMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"BDMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_BDMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"BDMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_CMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"CMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_CMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"CMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_RMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"RMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_RMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"RMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_RMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"RMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_RMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"RMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n-TraceEvent=Trc_SHR_RRM_primeHashtables_addingHint Overhead=9 Level=9 Template=\"RRM primeHashtables: Adding hint, cachelet=0x%p hashValue=0x%p\"\n-TraceException=Trc_SHR_RRM_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"RRM primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=0x%p\"\n+TraceEvent=Trc_SHR_RRM_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"RRM primeHashtables: Adding hint, cachelet=0x%p hashValue=0x%p\"\n+TraceException=Trc_SHR_RRM_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"RRM primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=0x%p\"\n \n-TraceEvent=Trc_SHR_SMI_primeHashtables_addingHint Overhead=9 Level=9 Template=\"SMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n-TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Overhead=1 Level=1 Template=\"SMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n+TraceEvent=Trc_SHR_SMI_primeHashtables_addingHint Obsolete Overhead=9 Level=9 Template=\"SMI primeHashtables: Adding hint, cachelet=0x%p hashValue=%u\"\n+TraceException=Trc_SHR_SMI_primeHashtables_failedToPrimeHint Obsolete Overhead=1 Level=1 Template=\"SMI primeHashtables: Failed to prime hint, manager=0x%p cachelet=0x%p hashValue=%u\"\n \n TraceExit=Trc_SHR_CC_startup_Exit8 Overhead=1 Level=1 Template=\"CC startup: Exiting due to running nested on existing cache not containing cachelets\"\n \n-TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n-TraceExit=Trc_SHR_CM_createNewCachelet_Exit Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewCachelet_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Entering\"\n+TraceExit=Trc_SHR_CM_createNewCachelet_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewCachelet: Exiting with returnVal=0x%p\"\n \n-TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n-TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n+TraceEntry=Trc_SHR_CM_createNewChainedCache_Entry Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Entering with requiredSize=%d (0x%x)\"\n+TraceExit=Trc_SHR_CM_createNewChainedCache_Exit Obsolete Overhead=1 Level=1 Template=\"CM createNewChainedCache: Exiting with newCache=0x%p\"\n \n-TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"\n-TraceException=Trc_SHR_CM_writeROMClassToCache_failedToReStoreClasspath Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Failed to re-store classpath in new supercache. Classpath item=0x%p, size=%u. Supercache free=%u, total=%u. Cachelet free=%u, total=%u.\"\n+TraceEvent=Trc_SHR_CM_writeROMClassToCache_classpathNotInNewSupercache Obsolete Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Classpath not in current supercache. Re-storing.\"\n+TraceException=Trc_SHR_CM_writeROMClassToCache_failedToReStoreClasspath Obsolete Overhead=1 Level=1 Template=\"CM writeROMClassToCache: Failed to re-store classpath in new supercache. Classpath item=0x%p, size=%u. Supercache free=%u, total=%u. Cachelet free=%u, total=%u.\"\n \n TraceExit=Trc_SHR_CM_addROMClassToCache_ExitFull Overhead=1 Level=1 Template=\"CM addROMClassToCache: Exiting due to full cache\"\n \n TraceException=Trc_SHR_RMI_compareROMClasses_NoCachelet Overhead=1 Level=1 Template=\"RMI compareROMClasses: ERROR: 0x%p not found in any cachelet\"\n \n-TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n-TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"\n-\n-TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv  Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n-TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Returned from init method\"\n-TraceExit=Trc_SHR_OSC_Vmem_startup_Exit NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successful exit\"\n-\n-TraceEntry=Trc_SHR_OSC_Vmem_attach_Entry Obsolete NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Entered\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_corruptCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is corrupt\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_differentBuildID NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: cache has an unrecognised buildID\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_invalidCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is invalid\"\n-TraceExit=Trc_SHR_OSC_Vmem_attach_validCacheHeader NoEnv Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is valid\"\n-\n-TraceEntry=Trc_SHR_M_startupHintCachelets_Entry Overhead=1 Level=1 Template=\"M startupHintCachelets: hint=%u\"\n-TraceExit=Trc_SHR_M_startupHintCachelets_Exit Overhead=1 Level=1 Template=\"M startupHintCachelets: cacheletsStarted=%d\"\n-TraceEvent=Trc_SHR_M_startupHintCachelets_startingCacheletForHint Overhead=1 Level=1 Template=\"M startupHintCachelets: starting cachelet 0x%p from hint %u (0x%p)\"\n-TraceException=Trc_SHR_M_startupHintCachelets_startupCacheletFailed Overhead=1 Level=1 Template=\"M startupHintCachelets: Cachelet startup failed, rc=%d, cachelet=0x%p, hint=%u (0x%p)\"\n+TraceEntry=Trc_SHR_INIT_hookSerializeSharedCache_entry Noenv Obsolete Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Entering hookSerializeSharedCache\"\n+TraceExit=Trc_SHR_INIT_hookSerializeSharedCache_exit Noenv Obsolete Overhead=1 Level=1 Template=\"INIT HOOK SERIALIZE CACHE: Exiting hookSerializeSharedCache\"\n+\n+TraceEntry=Trc_SHR_OSC_Vmem_startup_Entry NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Entering cache name = %s, control dir = %s, cache size = %zu, numSems = %zd, create flags = 0x%zx, verbose flags = 0x%zx, openFlags = 0x%x\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_commonStartupFailure NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_commonStartupSuccess NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Common startup succeeded\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_detectedNetworkCache NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: detected network cache - aborting\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open failed for cache path name = %s\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodfileopen NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: j9file_open successful for cache path name = %s, file handle %d\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_failed_mutex_init NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to initialize mutex %zu\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized_mutexes NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Succeeded initializing mutexes\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Acquire header write lock failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodAcquireHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully acquired header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_cacheNotInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock acquired, cache is not in use\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheInUse NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attach write lock not acquired, cache is in use\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_fileOpened NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: File length > 0, file opened\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheTooSmall Noenv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Cache is too small even for OSCache header\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release attach read lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseAttachReadLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released attach read lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_badReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Failed to release header write lock\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_goodReleaseHeaderWriteLock NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successfully released header write lock\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_closefilefailed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Exiting - closeCacheFile failed\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_cacheNotInitialized NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Attempting to open read-only but cache is not initialized\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_allocation_failed NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Memory allocation of %d bytes failed\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_callinginit NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Calling init with _mapDataAddr=%p, _mapDataLength=%zu, sharedClassMinAOTSize=%zd, sharedClassMaxAOTSize=%zd, sharedClassReadWriteBytes=%zd\"\n+TraceEvent=Trc_SHR_OSC_Vmem_startup_initialized NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Returned from init method\"\n+TraceExit=Trc_SHR_OSC_Vmem_startup_Exit NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::startup: Successful exit\"\n+\n+TraceEntry=Trc_SHR_OSC_Vmem_attach_Entry NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Entered\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_corruptCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is corrupt\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_differentBuildID NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: cache has an unrecognised buildID\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_invalidCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is invalid\"\n+TraceExit=Trc_SHR_OSC_Vmem_attach_validCacheHeader NoEnv Obsolete Overhead=1 Level=1 Template=\"SH_OSCachevmem::attach: Cache header is valid\"\n+\n+TraceEntry=Trc_SHR_M_startupHintCachelets_Entry Obsolete Overhead=1 Level=1 Template=\"M startupHintCachelets: hint=%u\"\n+TraceExit=Trc_SHR_M_startupHintCachelets_Exit Obsolete Overhead=1 Level=1 Template=\"M startupHintCachelets: cacheletsStarted=%d\"\n+TraceEvent=Trc_SHR_M_startupHintCachelets_startingCacheletForHint Obsolete Overhead=1 Level=1 Template=\"M startupHintCachelets: starting cachelet 0x%p from hint %u (0x%p)\"\n+TraceException=Trc_SHR_M_startupHintCachelets_startupCacheletFailed Obsolete Overhead=1 Level=1 Template=\"M startupHintCachelets: Cachelet startup failed, rc=%d, cachelet=0x%p, hint=%u (0x%p)\"\n TraceException=Trc_SHR_M_startupHintCachelets_lockStartupMonitorFailed Overhead=1 Level=1 Template=\"M startupHintCachelets: Can't lock startup monitor, rc=%d, cachelet=0x%p, for hint=%u (0x%p)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1253518c01a6c38abe109969af22e325cf78855b"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "153d72e8c769600d918c06e83e091208d1594748", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/153d72e8c769600d918c06e83e091208d1594748", "committedDate": "2020-10-16T07:35:28Z", "message": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro along with related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1253518c01a6c38abe109969af22e325cf78855b", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/1253518c01a6c38abe109969af22e325cf78855b", "committedDate": "2020-10-15T20:58:04Z", "message": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro along with related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}, "afterCommit": {"oid": "153d72e8c769600d918c06e83e091208d1594748", "author": {"user": {"login": "alexey-anufriev", "name": "Alexey Anufriev"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/153d72e8c769600d918c06e83e091208d1594748", "committedDate": "2020-10-16T07:35:28Z", "message": "Remove J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro\n\nThis patch removes J9SHR_CACHELET_SUPPORT and J9SHR_CACHELETS_SAVE_READWRITE_AREA macro along with related code\n\nFixes #6652\n\nSigned-off-by: Alexey Anufriev <contact@alexey-anufriev.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg5Mjk0", "url": "https://github.com/eclipse-openj9/openj9/pull/10866#pullrequestreview-510689294", "createdAt": "2020-10-16T17:57:01Z", "commit": {"oid": "153d72e8c769600d918c06e83e091208d1594748"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 153, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}