{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMjA2NTYy", "number": 8922, "title": "Refactor JIT implementation of acmp{eq,ne} to handle value types", "bodyText": "In IlGen, the ifacmpeq and ifacmpne bytecodes now get turned into a non-helper call that represents the comparison operation.  In Lower Trees, the non-helper call is then transformed into a helper call with fast-paths for cases that are easily handled. Currently, the only fast-path is for when the objects being compared have the same address, in which case the operands are equal regardless of whether they are value types or reference types.\nEventually, more fast-paths will be added and optimizations will recognize the non-helper call and convert it to a regular acmp if the JIT can prove doing so is correct.", "createdAt": "2020-03-19T19:56:15Z", "url": "https://github.com/eclipse-openj9/openj9/pull/8922", "merged": true, "mergeCommit": {"oid": "414ffb456780022181c56e9a4b2107ed27e7b898"}, "closed": true, "closedAt": "2020-06-12T17:46:06Z", "author": {"login": "Leonardo2718"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPkLwPAFqTM3ODY5MDI1Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqSbYZAFqTQyOTE3MzY4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NjkwMjUy", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#pullrequestreview-378690252", "createdAt": "2020-03-20T17:44:22Z", "commit": {"oid": "33c5a9dab9359abf96b9e83b5277aecf142eabc5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzo0NDoyMlrOF5ddug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzo0NDoyMlrOF5ddug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5NTg5OA==", "bodyText": "I'd appreciate reviews of this code from @r30shah @andrewcraik @hzongaro and @aviansie-ben. I'm not really happy with this code, but I haven't settled on a good way to clean it up yet. In particular, I don't like the way GlRegDeps are handled right now. I'm open any suggestions people might have.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r395795898", "createdAt": "2020-03-20T17:44:22Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   traceMsg(comp, \"<LEO> Detected call to substitutabilityComparisonSymbol in n%dn\\n\", node->getGlobalIndex());\n+\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   traceMsg(comp, \"<LEO> Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));\n+   traceMsg(comp, \"<LEO> Anchoring call argument n%dn and n%dn under treetops n%dn and n%dn\\n\",\n+      node->getFirstChild()->getGlobalIndex(), node->getSecondChild()->getGlobalIndex(), anchoredCallArg1TT->getNode()->getGlobalIndex(), anchoredCallArg2TT->getNode()->getGlobalIndex());\n+\n+   // put non-helper call in its own block by block splitting at the\n+   // next treetop and then at the current one\n+   TR::Block* prevBlock = tt->getEnclosingBlock();\n+   comp->dumpMethodTrees(\"Initial trees\");\n+   TR::Block* targetBlock = prevBlock->splitPostGRA(tt->getPrevTreeTop(), cfg, true, NULL);\n+   TR::Block* callBlock = prevBlock->split(tt, cfg, true, NULL);\n+   callBlock->setIsExtensionOfPreviousBlock(true);\n+   comp->dumpMethodTrees(\"Trees after splitting blocks to isolate call\");\n+\n+   // insert store of constant 1\n+   // the value must go wherever the value returned by the helper call goes\n+   // so that the code in the target block picks up the constant if we fast-path\n+   // (i.e. jump around) the call\n+   auto* anchoredNode = anchoredCallTT->getNode()->getFirstChild(); // call node is under a treetop node\n+   traceMsg(comp, \"<LEO> Anchored call has been transformed into %s node n%dn\\n\",\n+            anchoredNode->getOpCode().getName(), anchoredNode->getGlobalIndex());\n+   auto* const1Node = TR::Node::iconst(1);\n+   TR::Node* storeNode = NULL;\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      traceMsg(comp, \"<LEO> Storing constant 1 in register %s\\n\",\n+               comp->getDebug()->getGlobalRegisterName(anchoredNode->getGlobalRegisterNumber()));\n+      storeNode = TR::Node::create(TR::iRegStore, 1, const1Node);\n+      storeNode->setGlobalRegisterNumber(anchoredNode->getGlobalRegisterNumber());\n+      }\n+   else if (anchoredNode->getOpCodeValue() == TR::iload)\n+      {\n+      traceMsg(comp, \"<LEO> Storing constant 1 to symref %d (%s)\\n\",\n+               anchoredNode->getSymbolReference()->getReferenceNumber(), anchoredNode->getSymbolReference()->getName(comp->getDebug()));\n+      storeNode = TR::Node::create(TR::istore, 1, const1Node);\n+      storeNode->setSymbolReference(anchoredNode->getSymbolReference());\n+      }\n+   else\n+      TR_ASSERT_FATAL(false, \"Anchord call has been turned into unexpected opcode %s\\n\", anchoredNode->getOpCode().getName());\n+   prevBlock->append(TR::TreeTop::create(comp, storeNode));\n+   comp->dumpMethodTrees(\"Trees after inserting store of constant 1\");\n+\n+   // instert acmpeq for fastpath, taking care to set the proper register dependencies\n+   auto* ifacmpeqNode = TR::Node::createif(TR::ifacmpeq, anchoredCallArg1TT->getNode()->getFirstChild(), anchoredCallArg2TT->getNode()->getFirstChild(), targetBlock->getEntry());\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      auto* depNode = TR::Node::create(TR::PassThrough, 1, storeNode->getChild(0));\n+      depNode->setGlobalRegisterNumber(storeNode->getGlobalRegisterNumber());\n+\n+      TR::Node* glRegDeps = TR::Node::create(TR::GlRegDeps);\n+      glRegDeps->addChildren(&depNode, 1);\n+      ifacmpeqNode->addChildren(&glRegDeps, 1);\n+\n+      if (callBlock->getExit()->getNode()->getNumChildren() > 0)\n+         {\n+         auto* expectedDeps = callBlock->getExit()->getNode()->getFirstChild();\n+         for (int i = 0; i < expectedDeps->getNumChildren(); ++i)\n+            {\n+            TR::Node* temp = expectedDeps->getChild(i);\n+            if (temp->getGlobalRegisterNumber() == depNode->getGlobalRegisterNumber())\n+               continue;\n+            glRegDeps->addChildren(&temp, 1);\n+            }\n+         }\n+      }\n+   prevBlock->append(TR::TreeTop::create(comp, ifacmpeqNode));\n+\n+   comp->dumpMethodTrees(\"Trees after inserting acmpeq fast path\");\n+   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33c5a9dab9359abf96b9e83b5277aecf142eabc5"}, "originalPosition": 156}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "33c5a9dab9359abf96b9e83b5277aecf142eabc5", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/33c5a9dab9359abf96b9e83b5277aecf142eabc5", "committedDate": "2020-03-19T19:44:23Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4c8e14ce2eaff320a43ab194548e61819c5e9beb", "committedDate": "2020-03-24T20:09:01Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1OTMyNDEw", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#pullrequestreview-385932410", "createdAt": "2020-04-01T20:40:07Z", "commit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0MDowN1rOF_Rwpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0MDowN1rOF_Rwpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTU5MA==", "bodyText": "Why does this need to be set to 1 to go to an if test it for equality to 0? Why not just branch directly to the block targetted by the ificmpqeq in the block you are going to...", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r401895590", "createdAt": "2020-04-01T20:40:07Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1OTMzODkx", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#pullrequestreview-385933891", "createdAt": "2020-04-01T20:42:19Z", "commit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0MjoxOVrOF_R1Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0MjoxOVrOF_R1Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Njc1MQ==", "bodyText": "Whether this should be an extension and whether this should have the same frequency as the original block depends on how likely we think the we are to run the helper (if it is unlikely having this code down the bottom of the method might be more performant?)", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r401896751", "createdAt": "2020-04-01T20:42:19Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMTk5OTQ4", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#pullrequestreview-392199948", "createdAt": "2020-04-13T15:00:18Z", "commit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNTowMDoxOFrOGEpQTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNTowMDoxOFrOGEpQTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyMzQwNA==", "bodyText": "This looks like https://github.com/eclipse/omr/blob/87bb94e10fc847bc89d1a55b866d6952e31bcea8/compiler/optimizer/OMROptimization.cpp#L214\nPerhaps this pass would make more sense as a late MustBeDone optimization pass rather than in the CG itself since it is going to be doing some serious surgery that the optimizer might be able to help with? Just a thought...", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r407523404", "createdAt": "2020-04-13T15:00:18Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   traceMsg(comp, \"<LEO> Detected call to substitutabilityComparisonSymbol in n%dn\\n\", node->getGlobalIndex());\n+\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   traceMsg(comp, \"<LEO> Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMDExMjM5", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#pullrequestreview-393011239", "createdAt": "2020-04-14T14:56:14Z", "commit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDo1NjoxNFrOGFSwAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDo1NjoxNFrOGFSwAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIwMzI2Nw==", "bodyText": "@Leonardo2718  I have just looked into the part where you are splitting blocks. When you create a callBlock, you do not need to set fixupCommoning to true, this will cause it to walk the tree-top before the split point (Although, there might not be anything to common). Another reason for not to set up fixupCommoning to true if you are setting the callBlock as extension of previous block.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r408203267", "createdAt": "2020-04-14T14:56:14Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   traceMsg(comp, \"<LEO> Detected call to substitutabilityComparisonSymbol in n%dn\\n\", node->getGlobalIndex());\n+\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   traceMsg(comp, \"<LEO> Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));\n+   traceMsg(comp, \"<LEO> Anchoring call argument n%dn and n%dn under treetops n%dn and n%dn\\n\",\n+      node->getFirstChild()->getGlobalIndex(), node->getSecondChild()->getGlobalIndex(), anchoredCallArg1TT->getNode()->getGlobalIndex(), anchoredCallArg2TT->getNode()->getGlobalIndex());\n+\n+   // put non-helper call in its own block by block splitting at the\n+   // next treetop and then at the current one\n+   TR::Block* prevBlock = tt->getEnclosingBlock();\n+   comp->dumpMethodTrees(\"Initial trees\");\n+   TR::Block* targetBlock = prevBlock->splitPostGRA(tt->getNextTreeTop(), cfg, true, NULL);\n+   TR::Block* callBlock = prevBlock->split(tt, cfg, true, NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 98}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4c8e14ce2eaff320a43ab194548e61819c5e9beb", "committedDate": "2020-03-24T20:09:01Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "a3bd6243d5f758ca28c55e9b1f813b17a75dde9a", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a3bd6243d5f758ca28c55e9b1f813b17a75dde9a", "committedDate": "2020-04-20T17:55:05Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a3bd6243d5f758ca28c55e9b1f813b17a75dde9a", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a3bd6243d5f758ca28c55e9b1f813b17a75dde9a", "committedDate": "2020-04-20T17:55:05Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "c57b2dd616b0f58b3504681977b03b4007248885", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c57b2dd616b0f58b3504681977b03b4007248885", "committedDate": "2020-04-20T18:50:39Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c57b2dd616b0f58b3504681977b03b4007248885", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c57b2dd616b0f58b3504681977b03b4007248885", "committedDate": "2020-04-20T18:50:39Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "f20903d30436e68d6b199cfe09faf8c3bf895086", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f20903d30436e68d6b199cfe09faf8c3bf895086", "committedDate": "2020-04-20T20:32:22Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f20903d30436e68d6b199cfe09faf8c3bf895086", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f20903d30436e68d6b199cfe09faf8c3bf895086", "committedDate": "2020-04-20T20:32:22Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "7f8467387b4e308777886788ff5152268271fa81", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7f8467387b4e308777886788ff5152268271fa81", "committedDate": "2020-04-21T13:45:47Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4Mzk5NjI0", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#pullrequestreview-398399624", "createdAt": "2020-04-22T17:08:27Z", "commit": {"oid": "7f8467387b4e308777886788ff5152268271fa81"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzowODoyN1rOGKBYOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzowODoyN1rOGKBYOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2MTUyOA==", "bodyText": "According to Travis CI this seems to be missing a self()->", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r413161528", "createdAt": "2020-04-22T17:08:27Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -809,6 +973,11 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n    OMR::CodeGeneratorConnector::lowerTreeIfNeeded(node, childNumberOfNode, parent, tt);\n \n+   if (node->getOpCode().isCall())\n+      {\n+      lowerNonhelperCallIfNeeded(node, tt);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f8467387b4e308777886788ff5152268271fa81"}, "originalPosition": 188}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7f8467387b4e308777886788ff5152268271fa81", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7f8467387b4e308777886788ff5152268271fa81", "committedDate": "2020-04-21T13:45:47Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "3c0bb4689386604bf5e4abb51824d69fb4db4f99", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3c0bb4689386604bf5e4abb51824d69fb4db4f99", "committedDate": "2020-04-22T17:49:28Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02f8f49655614afdcb3dcc8b73a0478fd7e0dd7c", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/02f8f49655614afdcb3dcc8b73a0478fd7e0dd7c", "committedDate": "2020-05-29T15:48:13Z", "message": "Add support for the substituabilityComparison non-helper symbol\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2da342944e57bc32b2f35ac4c64e00624626e2c3", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2da342944e57bc32b2f35ac4c64e00624626e2c3", "committedDate": "2020-05-29T15:48:13Z", "message": "Add support for acmpHelper symbol\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afbc85d4f5b56e5b07bab625cb7100e4c302177d", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/afbc85d4f5b56e5b07bab625cb7100e4c302177d", "committedDate": "2020-05-29T15:48:13Z", "message": "Generate non-helper call for acmpeq/acmpne in IlGen\n\nWith the introduction of value types, the semantics of eq and ne\ncomparisons have become more complext. As a result, we now map these\noperations to a non-helper call. This commit updates the IL generator to\nemit the call instead of generating an IL opcode for the comparison\ndirectly.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "466f6fafbeaad9a35a592de3f91b027f9846fcc8", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/466f6fafbeaad9a35a592de3f91b027f9846fcc8", "committedDate": "2020-05-29T15:48:14Z", "message": "Add basic framework for lowering non-helper calls\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81d751d71afcb9cf4a63293a4ef7de9a8553801d", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/81d751d71afcb9cf4a63293a4ef7de9a8553801d", "committedDate": "2020-05-29T15:48:14Z", "message": "Lower objectEqualityComparison call to acmpHelper call\n\nThe objectEqualityComparison non-helper is implemented by simply\nlowering it to a call to acmpHelper. Because both are just call,\nchanging the symref held by the call node is enough. Eventually, the\nlowering will also generate fast-paths, but for now, this implementation\nshould be enough to get things working.\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3c0bb4689386604bf5e4abb51824d69fb4db4f99", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3c0bb4689386604bf5e4abb51824d69fb4db4f99", "committedDate": "2020-04-22T17:49:28Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c", "committedDate": "2020-05-29T15:48:14Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4OTc1NDMy", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#pullrequestreview-428975432", "createdAt": "2020-06-11T14:35:34Z", "commit": {"oid": "572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNTozNFrOGigQrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNTozNFrOGigQrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMzMyNg==", "bodyText": "I think this should use invalidateStructure rather than setStructure(0). That being the new API to invalidate structure.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r438833326", "createdAt": "2020-06-11T14:35:34Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ *\n+ * @details\n+ *\n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt, const bool trace)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4OTc2Njkz", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#pullrequestreview-428976693", "createdAt": "2020-06-11T14:36:54Z", "commit": {"oid": "572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNjo1NFrOGigUaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNjo1NFrOGigUaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNDI4Mw==", "bodyText": "should this trace turn on under traceCG for convenience?", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r438834283", "createdAt": "2020-06-11T14:36:54Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ *\n+ * @details\n+ *\n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt, const bool trace)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   if (trace)\n+      traceMsg(comp, \"Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));\n+   if (trace)\n+      {\n+      traceMsg(comp, \"Anchoring call arguments n%dn and n%dn under treetops n%dn and n%dn\\n\",\n+         node->getFirstChild()->getGlobalIndex(), node->getSecondChild()->getGlobalIndex(), anchoredCallArg1TT->getNode()->getGlobalIndex(), anchoredCallArg2TT->getNode()->getGlobalIndex());\n+      }\n+\n+   // put non-helper call in its own block by block splitting at the\n+   // next treetop and then at the current one\n+   TR::Block* prevBlock = tt->getEnclosingBlock();\n+   TR::Block* targetBlock = prevBlock->splitPostGRA(tt->getNextTreeTop(), cfg, true, NULL);\n+   TR::Block* callBlock = prevBlock->split(tt, cfg);\n+   callBlock->setIsExtensionOfPreviousBlock(true);\n+   if (trace)\n+      traceMsg(comp, \"Isolated call node n%dn in block_%d\\n\", node->getGlobalIndex(), callBlock->getNumber());\n+\n+   // insert store of constant 1\n+   // the value must go wherever the value returned by the helper call goes\n+   // so that the code in the target block picks up the constant if we fast-path\n+   // (i.e. jump around) the call\n+   TR::Node* anchoredNode = anchoredCallTT->getNode()->getFirstChild(); // call node is under a treetop node\n+   if (trace)\n+      traceMsg(comp, \"Anchored call has been transformed into %s node n%dn\\n\", anchoredNode->getOpCode().getName(), anchoredNode->getGlobalIndex());\n+   auto* const1Node = TR::Node::iconst(1);\n+   TR::Node* storeNode = NULL;\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      if (trace)\n+         traceMsg(comp, \"Storing constant 1 in register %s\\n\", comp->getDebug()->getGlobalRegisterName(anchoredNode->getGlobalRegisterNumber()));\n+      storeNode = TR::Node::create(TR::iRegStore, 1, const1Node);\n+      storeNode->setGlobalRegisterNumber(anchoredNode->getGlobalRegisterNumber());\n+      }\n+   else if (anchoredNode->getOpCodeValue() == TR::iload)\n+      {\n+      if (trace)\n+         traceMsg(comp, \"Storing constant 1 to symref %d (%s)\\n\", anchoredNode->getSymbolReference()->getReferenceNumber(), anchoredNode->getSymbolReference()->getName(comp->getDebug()));\n+      storeNode = TR::Node::create(TR::istore, 1, const1Node);\n+      storeNode->setSymbolReference(anchoredNode->getSymbolReference());\n+      }\n+   else\n+      TR_ASSERT_FATAL(false, \"Anchord call has been turned into unexpected opcode %s\\n\", anchoredNode->getOpCode().getName());\n+   prevBlock->append(TR::TreeTop::create(comp, storeNode));\n+\n+   // instert acmpeq for fastpath, taking care to set the proper register dependencies\n+   auto* ifacmpeqNode = TR::Node::createif(TR::ifacmpeq, anchoredCallArg1TT->getNode()->getFirstChild(), anchoredCallArg2TT->getNode()->getFirstChild(), targetBlock->getEntry());\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      auto* depNode = TR::Node::create(TR::PassThrough, 1, storeNode->getChild(0));\n+      depNode->setGlobalRegisterNumber(storeNode->getGlobalRegisterNumber());\n+\n+      TR::Node* glRegDeps = TR::Node::create(TR::GlRegDeps);\n+      glRegDeps->addChildren(&depNode, 1);\n+      ifacmpeqNode->addChildren(&glRegDeps, 1);\n+\n+      if (callBlock->getExit()->getNode()->getNumChildren() > 0)\n+         {\n+         TR::Node* expectedDeps = callBlock->getExit()->getNode()->getFirstChild();\n+         for (int i = 0; i < expectedDeps->getNumChildren(); ++i)\n+            {\n+            TR::Node* temp = expectedDeps->getChild(i);\n+            if (temp->getGlobalRegisterNumber() == depNode->getGlobalRegisterNumber())\n+               continue;\n+            glRegDeps->addChildren(&temp, 1);\n+            }\n+         }\n+      }\n+   prevBlock->append(TR::TreeTop::create(comp, ifacmpeqNode));\n+   }\n+\n+void\n+J9::CodeGenerator::lowerNonhelperCallIfNeeded(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       comp->getSymRefTab()->isNonHelper(\n+       node->getSymbolReference(),\n+       TR::SymbolReferenceTable::objectEqualityComparisonSymbol))\n+      {\n+      // turn the non-helper call into a VM helper call\n+      node->setSymbolReference(comp->getSymRefTab()->findOrCreateAcmpHelperSymbolRef());\n+      static const bool disableAcmpFastPath =  NULL != feGetEnv(\"TR_DisableAcmpFastpath\");\n+      static const bool traceFastPath = NULL != feGetEnv(\"TR_TraceAcmpFastPath\");\n+      if (!disableAcmpFastPath)\n+         {\n+         self()->fastpathAcmpHelper(node, tt, traceFastPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c"}, "originalPosition": 173}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4OTgyNDU3", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#pullrequestreview-428982457", "createdAt": "2020-06-11T14:42:56Z", "commit": {"oid": "572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fabc8125d436f22ace4c1fbe39f464f1a6bfdfd0", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/fabc8125d436f22ace4c1fbe39f464f1a6bfdfd0", "committedDate": "2020-06-11T18:03:56Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c", "committedDate": "2020-05-29T15:48:14Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}, "afterCommit": {"oid": "fabc8125d436f22ace4c1fbe39f464f1a6bfdfd0", "author": {"user": {"login": "Leonardo2718", "name": null}}, "url": "https://github.com/eclipse-openj9/openj9/commit/fabc8125d436f22ace4c1fbe39f464f1a6bfdfd0", "committedDate": "2020-06-11T18:03:56Z", "message": "Add fastpath around jitAcmpHelper call\n\nSigned-off-by: Leonardo Banderali <leonardo2718@protonmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MTczNjg3", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#pullrequestreview-429173687", "createdAt": "2020-06-11T18:19:06Z", "commit": {"oid": "fabc8125d436f22ace4c1fbe39f464f1a6bfdfd0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 535, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}