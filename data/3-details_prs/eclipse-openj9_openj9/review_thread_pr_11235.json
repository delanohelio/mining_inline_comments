{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MzQ5MTI2", "number": 11235, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMDo1MzoyN1rOFOVDjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo0MDozMVrOFOWaVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTY5MzU4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.hpp", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMDo1MzoyN1rOITBq1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxODozNDozMVrOITxnIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTIwNg==", "bodyText": "Why add a new setter that asserts \"Should not be called!\" ? Why not just...not add the setter?", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r556821206", "createdAt": "2021-01-13T20:53:27Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.hpp", "diffHunk": "@@ -61,6 +61,9 @@ class OMR_EXTENSIBLE AheadOfTimeCompile : public OMR::AheadOfTimeCompileConnecto\n \n    static void interceptAOTRelocation(TR::ExternalRelocation *relocation);\n \n+   uint32_t getSizeOfAOTRelocationHeader(TR_ExternalRelocationTargetKind k) { return TR_RelocationRecord::getSizeOfAOTRelocationHeader(k); }\n+   uint32_t *setAOTRelocationKindToHeaderSizeMap(uint32_t *p) { TR_ASSERT_FATAL(false, \"Should not be called!\\n\"); return 0; }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b526afcb81655bb7a64990a4d2a02d3a5fe2f9e3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMzcyNw==", "bodyText": "follow up: should remove the headerSizeMap constructor parameter from OMR as well unless some of other OMR consumer is somehow using it.", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r556823727", "createdAt": "2021-01-13T20:58:07Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.hpp", "diffHunk": "@@ -61,6 +61,9 @@ class OMR_EXTENSIBLE AheadOfTimeCompile : public OMR::AheadOfTimeCompileConnecto\n \n    static void interceptAOTRelocation(TR::ExternalRelocation *relocation);\n \n+   uint32_t getSizeOfAOTRelocationHeader(TR_ExternalRelocationTargetKind k) { return TR_RelocationRecord::getSizeOfAOTRelocationHeader(k); }\n+   uint32_t *setAOTRelocationKindToHeaderSizeMap(uint32_t *p) { TR_ASSERT_FATAL(false, \"Should not be called!\\n\"); return 0; }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTIwNg=="}, "originalCommit": {"oid": "b526afcb81655bb7a64990a4d2a02d3a5fe2f9e3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUzNzY3MA==", "bodyText": "Why add a new setter that asserts \"Should not be called!\" ? Why not just...not add the setter?\n\nThere is nothing to set anymore; the table of sizes is a static in RelocationRecord.cpp that's initialized at compile time. I also don't want to add the ability to change the size at runtime.\n\nfollow up: should remove the headerSizeMap constructor parameter from OMR as well unless some of other OMR consumer is somehow using it.\n\nRight now no other consumer is using it, but I recall the OMR AOT PR maybe making use of this?", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r557537670", "createdAt": "2021-01-14T16:45:07Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.hpp", "diffHunk": "@@ -61,6 +61,9 @@ class OMR_EXTENSIBLE AheadOfTimeCompile : public OMR::AheadOfTimeCompileConnecto\n \n    static void interceptAOTRelocation(TR::ExternalRelocation *relocation);\n \n+   uint32_t getSizeOfAOTRelocationHeader(TR_ExternalRelocationTargetKind k) { return TR_RelocationRecord::getSizeOfAOTRelocationHeader(k); }\n+   uint32_t *setAOTRelocationKindToHeaderSizeMap(uint32_t *p) { TR_ASSERT_FATAL(false, \"Should not be called!\\n\"); return 0; }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTIwNg=="}, "originalCommit": {"oid": "b526afcb81655bb7a64990a4d2a02d3a5fe2f9e3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzYwNTM0NQ==", "bodyText": "There is nothing to set anymore; the table of sizes is a static in RelocationRecord.cpp that's initialized at compile time. I also don't want to add the ability to change the size at runtime.\n\nHence the suggestion to not add the setter at all...", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r557605345", "createdAt": "2021-01-14T18:32:09Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.hpp", "diffHunk": "@@ -61,6 +61,9 @@ class OMR_EXTENSIBLE AheadOfTimeCompile : public OMR::AheadOfTimeCompileConnecto\n \n    static void interceptAOTRelocation(TR::ExternalRelocation *relocation);\n \n+   uint32_t getSizeOfAOTRelocationHeader(TR_ExternalRelocationTargetKind k) { return TR_RelocationRecord::getSizeOfAOTRelocationHeader(k); }\n+   uint32_t *setAOTRelocationKindToHeaderSizeMap(uint32_t *p) { TR_ASSERT_FATAL(false, \"Should not be called!\\n\"); return 0; }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTIwNg=="}, "originalCommit": {"oid": "b526afcb81655bb7a64990a4d2a02d3a5fe2f9e3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzYwNjI5OQ==", "bodyText": "Ohh, I misread. It's because the setter exists in OMR, so I wanted to ensure no one in OpenJ9 calls the setter.", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r557606299", "createdAt": "2021-01-14T18:33:51Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.hpp", "diffHunk": "@@ -61,6 +61,9 @@ class OMR_EXTENSIBLE AheadOfTimeCompile : public OMR::AheadOfTimeCompileConnecto\n \n    static void interceptAOTRelocation(TR::ExternalRelocation *relocation);\n \n+   uint32_t getSizeOfAOTRelocationHeader(TR_ExternalRelocationTargetKind k) { return TR_RelocationRecord::getSizeOfAOTRelocationHeader(k); }\n+   uint32_t *setAOTRelocationKindToHeaderSizeMap(uint32_t *p) { TR_ASSERT_FATAL(false, \"Should not be called!\\n\"); return 0; }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTIwNg=="}, "originalCommit": {"oid": "b526afcb81655bb7a64990a4d2a02d3a5fe2f9e3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzYwNjY4OQ==", "bodyText": "Never mind...another few seconds thought gave me the answer: you're actually overriding the OMR implementation of the setter.", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r557606689", "createdAt": "2021-01-14T18:34:31Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.hpp", "diffHunk": "@@ -61,6 +61,9 @@ class OMR_EXTENSIBLE AheadOfTimeCompile : public OMR::AheadOfTimeCompileConnecto\n \n    static void interceptAOTRelocation(TR::ExternalRelocation *relocation);\n \n+   uint32_t getSizeOfAOTRelocationHeader(TR_ExternalRelocationTargetKind k) { return TR_RelocationRecord::getSizeOfAOTRelocationHeader(k); }\n+   uint32_t *setAOTRelocationKindToHeaderSizeMap(uint32_t *p) { TR_ASSERT_FATAL(false, \"Should not be called!\\n\"); return 0; }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTIwNg=="}, "originalCommit": {"oid": "b526afcb81655bb7a64990a4d2a02d3a5fe2f9e3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTY5OTY0OnYy", "diffSide": "LEFT", "path": "runtime/compiler/arm/codegen/J9AheadOfTimeCompile.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMDo1NToyM1rOITBujA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNjo0MjozN1rOITtSZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMjE1Ng==", "bodyText": "not a huge deal, but for completeness, would you also mention this change in the abstract please?", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r556822156", "createdAt": "2021-01-13T20:55:23Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/arm/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -283,217 +283,3 @@ uint8_t *J9::ARM::AheadOfTimeCompile::initializeAOTRelocationHeader(TR::Iterated\n       }\n       return cursor;\n    }\n-\n-\n-uint32_t J9::ARM::AheadOfTimeCompile::_relocationTargetTypeToHeaderSizeMap[TR_NumExternalRelocationKinds] =\n-   {\n-   12,                                       // TR_ConstantPool                        = 0\n-   8,                                        // TR_HelperAddress                       = 1\n-   12,                                       // TR_RelativeMethodAddress               = 2\n-   4,                                        // TR_AbsoluteMethodAddress               = 3\n-   20,                                       // TR_DataAddress                         = 4\n-   12,                                       // TR_ClassObject                         = 5\n-   12,                                       // TR_MethodObject                        = 6\n-   12,                                       // TR_InterfaceObject                     = 7\n-   8,                                        // TR_AbsoluteHelperAddress               = 8\n-   8,                                        // TR_FixedSequenceAddress                = 9\n-   8,                                        // TR_FixedSequenceAddress2               = 10\n-   16,                                       // TR_JNIVirtualTargetAddress             = 11\n-   16,                                       // TR_JNIStaticTargetAddress              = 12\n-   4,                                        // TR_ArrayCopyHelper                     = 13\n-   4,                                        // TR_ArrayCopyToc                        = 14\n-   4,                                        // TR_BodyInfoAddress                     = 15\n-   12,                                       // TR_Thunks                              = 16\n-   16,                                       // TR_StaticRamMethodConst                = 17\n-   12,                                       // TR_Trampolines                         = 18\n-   8,                                        // TR_PicTrampolines                      = 19\n-   8,                                        // TR_CheckMethodEnter                    = 20\n-   4,                                        // TR_RamMethod                           = 21\n-   8,                                        // TR_RamMethodSequence                   = 22\n-   8,                                        // TR_RamMethodSequenceReg                = 23\n-   24,                                       // TR_VerifyClassObjectForAlloc           = 24\n-   12,                                       // TR_ConstantPoolOrderedPair             = 25\n-   4,                                        // TR_AbsoluteMethodAddressOrderedPair    = 26\n-   20,                                       // TR_VerifyRefArrayForAlloc              = 27\n-   12,                                       // TR_J2IThunks                           = 28\n-   8,                                        // TR_GlobalValue                         = 29\n-   4,                                        // TR_BodyInfoAddressLoad                 = 30\n-   20,                                       // TR_ValidateInstanceField               = 31\n-   24,                                       // TR_InlinedStaticMethodWithNopGuard     = 32\n-   24,                                       // TR_InlinedSpecialMethodWithNopGuard    = 33\n-   24,                                       // TR_InlinedVirtualMethodWithNopGuard    = 34\n-   24,                                       // TR_InlinedInterfaceMethodWithNopGuard  = 35\n-   16,                                       // TR_SpecialRamMethodConst               = 36\n-   24,                                       // TR_InlinedHCRMethod                    = 37\n-   20,                                       // TR_ValidateStaticField                 = 38\n-   20,                                       // TR_ValidateClass                       = 39\n-   16,                                       // TR_ClassAddress                        = 40\n-   8,                                        // TR_HCR                                 = 41\n-   32,                                       // TR_ProfiledMethodGuardRelocation       = 42\n-   32,                                       // TR_ProfiledClassGuardRelocation        = 43\n-   0,                                        // TR_HierarchyGuardRelocation            = 44\n-   0,                                        // TR_AbstractGuardRelocation             = 45\n-   32,                                       // TR_ProfiledInlinedMethod               = 46\n-   20,                                       // TR_MethodPointer                       = 47\n-   16,                                       // TR_ClassPointer                        = 48\n-   8,                                        // TR_CheckMethodExit                     = 49\n-   12,                                       // TR_ValidateArbitraryClass              = 50\n-   0,                                        // TR_EmitClass(not used)                 = 51\n-   16,                                       // TR_JNISpecialTargetAddress             = 52\n-   16,                                       // TR_VirtualRamMethodConst               = 53\n-   20,                                       // TR_InlinedInterfaceMethod              = 54\n-   20,                                       // TR_InlinedVirtualMethod                = 55\n-   0,                                        // TR_NativeMethodAbsolute                = 56,\n-   0,                                        // TR_NativeMethodRelative                = 57,\n-   16,                                       // TR_ArbitraryClassAddress               = 58,\n-   28,                                        // TR_DebugCounter                        = 59\n-   4,                                        // TR_ClassUnloadAssumption               = 60\n-   16,                                       // TR_J2IVirtualThunkPointer              = 61\n-   };\n-\n-\n-#if 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b526afcb81655bb7a64990a4d2a02d3a5fe2f9e3"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUzNTg0Ng==", "bodyText": "Done in 93ac7a2", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r557535846", "createdAt": "2021-01-14T16:42:37Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/arm/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -283,217 +283,3 @@ uint8_t *J9::ARM::AheadOfTimeCompile::initializeAOTRelocationHeader(TR::Iterated\n       }\n       return cursor;\n    }\n-\n-\n-uint32_t J9::ARM::AheadOfTimeCompile::_relocationTargetTypeToHeaderSizeMap[TR_NumExternalRelocationKinds] =\n-   {\n-   12,                                       // TR_ConstantPool                        = 0\n-   8,                                        // TR_HelperAddress                       = 1\n-   12,                                       // TR_RelativeMethodAddress               = 2\n-   4,                                        // TR_AbsoluteMethodAddress               = 3\n-   20,                                       // TR_DataAddress                         = 4\n-   12,                                       // TR_ClassObject                         = 5\n-   12,                                       // TR_MethodObject                        = 6\n-   12,                                       // TR_InterfaceObject                     = 7\n-   8,                                        // TR_AbsoluteHelperAddress               = 8\n-   8,                                        // TR_FixedSequenceAddress                = 9\n-   8,                                        // TR_FixedSequenceAddress2               = 10\n-   16,                                       // TR_JNIVirtualTargetAddress             = 11\n-   16,                                       // TR_JNIStaticTargetAddress              = 12\n-   4,                                        // TR_ArrayCopyHelper                     = 13\n-   4,                                        // TR_ArrayCopyToc                        = 14\n-   4,                                        // TR_BodyInfoAddress                     = 15\n-   12,                                       // TR_Thunks                              = 16\n-   16,                                       // TR_StaticRamMethodConst                = 17\n-   12,                                       // TR_Trampolines                         = 18\n-   8,                                        // TR_PicTrampolines                      = 19\n-   8,                                        // TR_CheckMethodEnter                    = 20\n-   4,                                        // TR_RamMethod                           = 21\n-   8,                                        // TR_RamMethodSequence                   = 22\n-   8,                                        // TR_RamMethodSequenceReg                = 23\n-   24,                                       // TR_VerifyClassObjectForAlloc           = 24\n-   12,                                       // TR_ConstantPoolOrderedPair             = 25\n-   4,                                        // TR_AbsoluteMethodAddressOrderedPair    = 26\n-   20,                                       // TR_VerifyRefArrayForAlloc              = 27\n-   12,                                       // TR_J2IThunks                           = 28\n-   8,                                        // TR_GlobalValue                         = 29\n-   4,                                        // TR_BodyInfoAddressLoad                 = 30\n-   20,                                       // TR_ValidateInstanceField               = 31\n-   24,                                       // TR_InlinedStaticMethodWithNopGuard     = 32\n-   24,                                       // TR_InlinedSpecialMethodWithNopGuard    = 33\n-   24,                                       // TR_InlinedVirtualMethodWithNopGuard    = 34\n-   24,                                       // TR_InlinedInterfaceMethodWithNopGuard  = 35\n-   16,                                       // TR_SpecialRamMethodConst               = 36\n-   24,                                       // TR_InlinedHCRMethod                    = 37\n-   20,                                       // TR_ValidateStaticField                 = 38\n-   20,                                       // TR_ValidateClass                       = 39\n-   16,                                       // TR_ClassAddress                        = 40\n-   8,                                        // TR_HCR                                 = 41\n-   32,                                       // TR_ProfiledMethodGuardRelocation       = 42\n-   32,                                       // TR_ProfiledClassGuardRelocation        = 43\n-   0,                                        // TR_HierarchyGuardRelocation            = 44\n-   0,                                        // TR_AbstractGuardRelocation             = 45\n-   32,                                       // TR_ProfiledInlinedMethod               = 46\n-   20,                                       // TR_MethodPointer                       = 47\n-   16,                                       // TR_ClassPointer                        = 48\n-   8,                                        // TR_CheckMethodExit                     = 49\n-   12,                                       // TR_ValidateArbitraryClass              = 50\n-   0,                                        // TR_EmitClass(not used)                 = 51\n-   16,                                       // TR_JNISpecialTargetAddress             = 52\n-   16,                                       // TR_VirtualRamMethodConst               = 53\n-   20,                                       // TR_InlinedInterfaceMethod              = 54\n-   20,                                       // TR_InlinedVirtualMethod                = 55\n-   0,                                        // TR_NativeMethodAbsolute                = 56,\n-   0,                                        // TR_NativeMethodRelative                = 57,\n-   16,                                       // TR_ArbitraryClassAddress               = 58,\n-   28,                                        // TR_DebugCounter                        = 59\n-   4,                                        // TR_ClassUnloadAssumption               = 60\n-   16,                                       // TR_J2IVirtualThunkPointer              = 61\n-   };\n-\n-\n-#if 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMjE1Ng=="}, "originalCommit": {"oid": "b526afcb81655bb7a64990a4d2a02d3a5fe2f9e3"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTg2MzExOnYy", "diffSide": "LEFT", "path": "runtime/compiler/runtime/RelocationRecord.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTozMTo1M1rOITDWpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTozMTo1M1rOITDWpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg0ODgwNg==", "bodyText": "I can live with this change. One of the reasons for the original naming was because the header was the only thing you could count on to be in every single relocation record: from the fields in the header, you could decode whether additional data was needed to perform the relocation, or whether the offsets followed immediately after the header. It is a little bit weird (to me) that you now look the header before you know how the rest of the header is laid out, but if you look in the safe part where the type field resides, then you can properly decode it :) .\nAnyway, I accept it was a source of confusion and, like I said, I can live with the update as I'm probably the only person whose brain will need to be reprogrammed :) .", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r556848806", "createdAt": "2021-01-13T21:31:53Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -503,9 +503,15 @@ TR_RelocationRecord::clean(TR_RelocationTarget *reloTarget)\n    }\n \n int32_t\n-TR_RelocationRecord::bytesInHeaderAndPayload()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fddfc0dc78a6de553f47647645d6413c58d3b9c3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTg5MDkwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/RelocationRecord.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTozNjozOFrOITDqCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNjo0MjowNFrOITtRAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1Mzc3MQ==", "bodyText": "maybe add a comment on each of the (currently) three structs listing the other two of the three BinaryTemplate structs that must all be identical in their first three (at least) fields.\nI know you're just moving code here, so those comments could be added as a follow-up.", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r556853771", "createdAt": "2021-01-13T21:36:38Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -73,6 +73,343 @@ extern \"C\" void _patchVirtualGuard(uint8_t *locationAddr, uint8_t *destinationAd\n extern \"C\" void ASM_CALL _patchVirtualGuard(uint8_t*, uint8_t*, uint32_t);\n #endif\n \n+// START OF BINARY TEMPLATES\n+\n+// These *BinaryTemplate structs describe the shape of the binary relocation records.\n+struct TR_RelocationRecordBinaryTemplate\n+   {\n+   uint8_t type(TR_RelocationTarget *reloTarget);\n+\n+   uint16_t _size;\n+   uint8_t _type;\n+   uint8_t _flags;\n+\n+#if defined(TR_HOST_64BIT)\n+   uint32_t _extra;\n+#endif\n+   };\n+\n+// Generating 32-bit code on a 64-bit machine or vice-versa won't work because the alignment won't\n+// be right.  Relying on inheritance in the structures here means padding is automatically inserted\n+// at each inheritance boundary: this inserted padding won't match across 32-bit and 64-bit platforms.\n+// Making as many fields as possible UDATA should minimize the differences and gives the most freedom\n+// in the hierarchy of binary relocation record structures, but the header definitely has an inheritance\n+// boundary at offset 4B.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21335903b890bde9a0c7c51063a9dc67e6596ee9"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUzNTQ4OQ==", "bodyText": "Done in 54e35a9. I also opened #11659 to track further clean up of the binary templates, since we no longer need to worry about padding and what not.", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r557535489", "createdAt": "2021-01-14T16:42:04Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -73,6 +73,343 @@ extern \"C\" void _patchVirtualGuard(uint8_t *locationAddr, uint8_t *destinationAd\n extern \"C\" void ASM_CALL _patchVirtualGuard(uint8_t*, uint8_t*, uint32_t);\n #endif\n \n+// START OF BINARY TEMPLATES\n+\n+// These *BinaryTemplate structs describe the shape of the binary relocation records.\n+struct TR_RelocationRecordBinaryTemplate\n+   {\n+   uint8_t type(TR_RelocationTarget *reloTarget);\n+\n+   uint16_t _size;\n+   uint8_t _type;\n+   uint8_t _flags;\n+\n+#if defined(TR_HOST_64BIT)\n+   uint32_t _extra;\n+#endif\n+   };\n+\n+// Generating 32-bit code on a 64-bit machine or vice-versa won't work because the alignment won't\n+// be right.  Relying on inheritance in the structures here means padding is automatically inserted\n+// at each inheritance boundary: this inserted padding won't match across 32-bit and 64-bit platforms.\n+// Making as many fields as possible UDATA should minimize the differences and gives the most freedom\n+// in the hierarchy of binary relocation record structures, but the header definitely has an inheritance\n+// boundary at offset 4B.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1Mzc3MQ=="}, "originalCommit": {"oid": "21335903b890bde9a0c7c51063a9dc67e6596ee9"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTkxNTc1OnYy", "diffSide": "LEFT", "path": "runtime/compiler/runtime/RelocationRecord.hpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo0MDozMVrOITD6hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo0MDozMVrOITD6hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1Nzk4OA==", "bodyText": "I am so happy to finally see these structs move out of the header file......Bravo!", "url": "https://github.com/eclipse-openj9/openj9/pull/11235#discussion_r556857988", "createdAt": "2021-01-13T21:40:31Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/runtime/RelocationRecord.hpp", "diffHunk": "@@ -39,346 +39,14 @@ class TR_RelocationTarget;\n struct TR_RelocationRecordBinaryTemplate;\n typedef TR_ExternalRelocationTargetKind TR_RelocationRecordType;\n \n-// These *BinaryTemplate structs describe the shape of the binary relocation records.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21335903b890bde9a0c7c51063a9dc67e6596ee9"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 952, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}