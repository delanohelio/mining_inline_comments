{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1NjY2MzY0", "number": 10362, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzo0Mjo0OFrOEZln4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMzo0ODo1NVrOEnDeSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjY2Mjc0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzo0Mjo0OFrOHCfS4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMjoxNTowMlrOHGs_Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ==", "bodyText": "I think this does need to be made real to facilitate debugging if test failures occur - the transform is optional. Would it make more sense to always generate the helpers and then have an ilgen opts pass to do the lowering? That way we could use a standard performTransformation guard to guard the transform to allow for easier debugging?\nIf that makes things too complicated then at least some kind of JIT option is necessary.", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r472371939", "createdAt": "2020-08-18T17:42:48Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,54 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (isFieldResovled(comp(), owningMethod, cpIndex, false))\n+         {\n+         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))\n+            {\n+            // TODO choose the runtime helper or not. Maybe based on an option?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a53071aef116ea842883790c731f0b7220d79c9"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxMjI4Mg==", "bodyText": "As per discussion with @Leonardo2718 last week, this part of code is likely moved to the runtime helper change that @Leonardo2718 is implementing. That's why I haven't updated it yet. The plan for now is to switch to the runtime flattened field helper by using an environment variable. My understanding is something like below:\n         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))\n            {\n            static char *enableRuntimeFlattenFieldGetfieldHelper = feGetEnv(\"TR_EnableRuntimeFlattenFieldGetfieldHelper\");\n            if (enableRuntimeFlattenFieldGetfieldHelper)\n               {\n               // Runtime helper\n               }\n            else\n               {\n               loadInstanceFlattenedField(cpIndex);\n               }\n            }\n         else\n            {\n            TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n            loadInstance(symRef);\n            }\n         }", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r472512282", "createdAt": "2020-08-18T21:47:44Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,54 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (isFieldResovled(comp(), owningMethod, cpIndex, false))\n+         {\n+         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))\n+            {\n+            // TODO choose the runtime helper or not. Maybe based on an option?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ=="}, "originalCommit": {"oid": "0a53071aef116ea842883790c731f0b7220d79c9"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEzMjQ2Nw==", "bodyText": "for debugging a performTransformation would be preferable to an envvar since the use of the fully flattened version is an optimization over the helper version right? eg we should degrade to the simpler one to help debug problems potentially? Thoughts? FYI @Leonardo2718 and @hzongaro", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473132467", "createdAt": "2020-08-19T15:50:23Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,54 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (isFieldResovled(comp(), owningMethod, cpIndex, false))\n+         {\n+         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))\n+            {\n+            // TODO choose the runtime helper or not. Maybe based on an option?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ=="}, "originalCommit": {"oid": "0a53071aef116ea842883790c731f0b7220d79c9"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwMTk1OQ==", "bodyText": "That is my understanding too: by default we go down the transformation path, if anything wrong happens, we use the environment variable to choose the runtime helpers for debugging. I could be wrong tho. I'll let @Leonardo2718 help confirm.", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473301959", "createdAt": "2020-08-19T20:33:34Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,54 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (isFieldResovled(comp(), owningMethod, cpIndex, false))\n+         {\n+         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))\n+            {\n+            // TODO choose the runtime helper or not. Maybe based on an option?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ=="}, "originalCommit": {"oid": "0a53071aef116ea842883790c731f0b7220d79c9"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4NTU1OQ==", "bodyText": "That is my understanding too: by default we go down the transformation path, if anything wrong happens, we use the environment variable to choose the runtime helpers for debugging\n\nI missunderstood the performTransformation macro and please ignore my comments on the above.", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r474085559", "createdAt": "2020-08-20T15:45:06Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,54 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (isFieldResovled(comp(), owningMethod, cpIndex, false))\n+         {\n+         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))\n+            {\n+            // TODO choose the runtime helper or not. Maybe based on an option?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ=="}, "originalCommit": {"oid": "0a53071aef116ea842883790c731f0b7220d79c9"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc5MDU0Nw==", "bodyText": "After some discussion with @Leonardo2718 @hzongaro, JIT option is used for now to choose between runtime helper or sym ref generation during the compilation time (eclipse/omr#5493). In the future, performTransformation could be considered. Moving the sym ref generation to Optimization phase is more complicated.", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r476790547", "createdAt": "2020-08-25T22:15:02Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,54 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (isFieldResovled(comp(), owningMethod, cpIndex, false))\n+         {\n+         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))\n+            {\n+            // TODO choose the runtime helper or not. Maybe based on an option?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTkzOQ=="}, "originalCommit": {"oid": "0a53071aef116ea842883790c731f0b7220d79c9"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjY2NDgyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzo0MzoyM1rOHCfUMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMzowNDozMVrOHCuyXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MjI3NQ==", "bodyText": "This sub-tree should have some tracing for when traceILGen is on to outline the choice made and why so we know why we generated the tree we did.", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r472372275", "createdAt": "2020-08-18T17:43:23Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,54 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (isFieldResovled(comp(), owningMethod, cpIndex, false))\n+         {\n+         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a53071aef116ea842883790c731f0b7220d79c9"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYyNTc1OA==", "bodyText": "The tracing is added to where each flattened field is being loaded.", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r472625758", "createdAt": "2020-08-19T03:04:31Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,54 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (isFieldResovled(comp(), owningMethod, cpIndex, false))\n+         {\n+         if (owningMethod->isFieldFlattened(comp(), cpIndex, _methodSymbol->isStatic()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MjI3NQ=="}, "originalCommit": {"oid": "0a53071aef116ea842883790c731f0b7220d79c9"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NzcxOTY4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNzowMDoyMVrOHDQ8Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODozMjo0MVrOHDUQEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTMzOA==", "bodyText": "Can the isFieldQType really be called before checking if it's resolved?", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473185338", "createdAt": "2020-08-19T17:00:21Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,57 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fe516eeaf27e3fea7925558c336e0882b7fac9"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzOTU2OA==", "bodyText": "isFieldQType() essentially calls VM to check J9ROMNameAndSignature as below and see if it contains Q keyword. My understanding is that it doesn't require the field to be resolved. Or does it need to?\nhttps://github.com/eclipse/openj9/blob/fef3f947a0086af748f59f5aa688b09960a43421/runtime/vm/ValueTypeHelpers.hpp#L248-L261", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473239568", "createdAt": "2020-08-19T18:32:41Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,57 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;\n+   }\n+\n void\n TR_J9ByteCodeIlGenerator::loadInstance(int32_t cpIndex)\n    {\n    if (_generateReadBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n-   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, cpIndex, false);\n-   loadInstance(symRef);\n+\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       owningMethod->isFieldQType(cpIndex))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTMzOA=="}, "originalCommit": {"oid": "99fe516eeaf27e3fea7925558c336e0882b7fac9"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1Nzc1OTU4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNzowODozMFrOHDRXTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMjoxNzowNVrOHGtEfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MjI3MQ==", "bodyText": "I think this should actually be\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               return bResolved;\n          \n          \n            \n               return !isUnresolvedInCP;\n          \n      \n    \n    \n  \n\nfieldAttributes() will return true if the CP entry gets resolved at compile-time. Under such cases, the JIT basically gets to peek at what the result will be when the entry is resolved. However, the runtime CP resolution still has to happen, so the JIT needs to treat the field as unresolved (because it is) even though it actually knows what it's supposed to be.", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473192271", "createdAt": "2020-08-19T17:08:30Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,57 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fe516eeaf27e3fea7925558c336e0882b7fac9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzOTkyMQ==", "bodyText": "Thanks for the clarification!", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473239921", "createdAt": "2020-08-19T18:33:21Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,57 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MjI3MQ=="}, "originalCommit": {"oid": "99fe516eeaf27e3fea7925558c336e0882b7fac9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI2Nzc4Nw==", "bodyText": "Actually I have a question on this code. For loadInstance, should it check if a field is resolved or if its containing class is resolved. Here on checking if the field is resolved I used how findOrCreateShadowSymbol() does it as blow:\nhttps://github.com/eclipse/openj9/blob/141cd78d2ad744ca44f04b97d0c3927ee854eaf9/runtime/compiler/compile/J9SymbolReferenceTable.cpp#L800\nLooking at genWithField(), it checks if the containing class exists or not to determine resolve or not.\nhttps://github.com/eclipse/openj9/blob/141cd78d2ad744ca44f04b97d0c3927ee854eaf9/runtime/compiler/ilgen/Walker.cpp#L6153-L6157", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r474267787", "createdAt": "2020-08-20T20:56:29Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,57 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MjI3MQ=="}, "originalCommit": {"oid": "99fe516eeaf27e3fea7925558c336e0882b7fac9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc5MTkzMg==", "bodyText": "isFieldResovled() will be removed from this PR and added to runtime helper PR.", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r476791932", "createdAt": "2020-08-25T22:17:05Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,57 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,\n+                                    &isPrivate, isStore, &isUnresolvedInCP, true /* needsAOTValidation */);\n+   return bResolved;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MjI3MQ=="}, "originalCommit": {"oid": "99fe516eeaf27e3fea7925558c336e0882b7fac9"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NzgwNjQyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNzoyMToyMlrOHDR1Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxOToyNjo0N1rOHDV-qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5OTkzMA==", "bodyText": "What happens if the cpIndex is not field entry in the CP?", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473199930", "createdAt": "2020-08-19T17:21:22Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,57 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99fe516eeaf27e3fea7925558c336e0882b7fac9"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI2Nzg4MQ==", "bodyText": "Depending on which one gets to check first (#10362 (comment)): checking isFieldQType() first or checking isFieldResovled() first.\n\nIf  isFieldQType() is called first, it returns false when cpIndex == -1. It goes down the existing path of loadInstance(symRef). It looks to me it still creates a symRef even when cpIndex == -1 regardless of value class or not.\nIf isFieldResovled() is called first, it relies on owningMethod->fieldAttributes to check cpIndex. TR_ResolvedJ9Method::fieldAttributes() only has an TR_ASSERT(cpIndex != -1, ...). It means the release build could crash when cpIndex == -1. However it applies to all cases when fieldAttributes is called regardless of value classes or not.", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r473267881", "createdAt": "2020-08-19T19:26:47Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,13 +5061,57 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+static bool isFieldResovled(TR::Compilation *comp, TR_ResolvedJ9Method * owningMethod, int32_t cpIndex, bool isStore)\n+   {\n+   uint32_t offset = 0;\n+   TR::DataType type = TR::NoType;\n+   bool isVolatile = true, isFinal = false, isPrivate = false, isUnresolvedInCP;\n+   bool bResolved = owningMethod->fieldAttributes(comp, cpIndex, &offset, &type, &isVolatile, &isFinal,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5OTkzMA=="}, "originalCommit": {"oid": "99fe516eeaf27e3fea7925558c336e0882b7fac9"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDMyNTk3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMToyOToxMFrOHLI7zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMToyOToxMFrOHLI7zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0Mjc2Ng==", "bodyText": "Can we have some documentation in the code of what the trees will look like?", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r481442766", "createdAt": "2020-09-01T21:29:10Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5160,6 +5176,81 @@ TR_J9ByteCodeIlGenerator::loadInstance(TR::SymbolReference * symRef)\n    push(dummyLoad);\n    }\n \n+static char * getTopLevelPrefixForFlattenedFields(TR_ResolvedJ9Method *owningMethod, int32_t cpIndex, int32_t &prefixLen, TR::Region &region)\n+   {\n+   int32_t len;\n+   const char * fieldNameChars = owningMethod->fieldNameChars(cpIndex, len);\n+   prefixLen = len + 1; // for '.'\n+\n+   char * newName = new (region) char[len+2];\n+   strncpy(newName, fieldNameChars, len);\n+\n+   newName[len] = '.';\n+   newName[len+1] = '\\0';\n+   return newName;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::loadFlattenableInstance(int32_t cpIndex)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e18acfff0479ca605d1869beaa773d05082e39c5"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5Mzg2ODI2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMzo0ODo1NVrOHXbxsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNTowMTowMVrOHXfPbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzNDM4NA==", "bodyText": "why do we need a nullchk here? if the receiver is 'this' it would be guarnateed non-null... or is this some kind of more general transform and in this case we happen to have this and so we leave it to the optimizer to eliminate it later?", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r494334384", "createdAt": "2020-09-24T13:48:55Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5216,6 +5217,117 @@ TR_J9ByteCodeIlGenerator::loadFlattenableInstanceWithHelper(int32_t cpIndex)\n    push(helperCallNode);\n    }\n \n+static char * getTopLevelPrefixForFlattenedFields(TR_ResolvedJ9Method *owningMethod, int32_t cpIndex, int32_t &prefixLen, TR::Region &region)\n+   {\n+   int32_t len;\n+   const char * fieldNameChars = owningMethod->fieldNameChars(cpIndex, len);\n+   prefixLen = len + 1; // for '.'\n+\n+   char * newName = new (region) char[len+2];\n+   strncpy(newName, fieldNameChars, len);\n+\n+   newName[len] = '.';\n+   newName[len+1] = '\\0';\n+   return newName;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::loadFlattenableInstance(int32_t cpIndex)\n+   {\n+   /* An example on what the tree with flattened fields looks like\n+    *\n+    * value NestedA {\n+    *    int x;\n+    *    int y;\n+    *    }\n+    * value NestedB {\n+    *    NestedA a;\n+    *    NestedA b;\n+    *    }\n+    * value ContainerC {\n+    *    NestedB c;\n+    *    NestedB d;\n+    *    }\n+    *\n+    * method=\"ContainerC.getc()QNestedB;\"\n+    *\n+    * /--- trees inserted ------------------------\n+    * n5n      (  0)  NULLCHK on n3n [#32]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "218c43a912b7cbc397bc0d3678c8b3eefc7c6c9a"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5MTE1MA==", "bodyText": "I think I should check !isNonNull() before adding the NULLCHK. I'll update it next.", "url": "https://github.com/eclipse-openj9/openj9/pull/10362#discussion_r494391150", "createdAt": "2020-09-24T15:01:01Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5216,6 +5217,117 @@ TR_J9ByteCodeIlGenerator::loadFlattenableInstanceWithHelper(int32_t cpIndex)\n    push(helperCallNode);\n    }\n \n+static char * getTopLevelPrefixForFlattenedFields(TR_ResolvedJ9Method *owningMethod, int32_t cpIndex, int32_t &prefixLen, TR::Region &region)\n+   {\n+   int32_t len;\n+   const char * fieldNameChars = owningMethod->fieldNameChars(cpIndex, len);\n+   prefixLen = len + 1; // for '.'\n+\n+   char * newName = new (region) char[len+2];\n+   strncpy(newName, fieldNameChars, len);\n+\n+   newName[len] = '.';\n+   newName[len+1] = '\\0';\n+   return newName;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::loadFlattenableInstance(int32_t cpIndex)\n+   {\n+   /* An example on what the tree with flattened fields looks like\n+    *\n+    * value NestedA {\n+    *    int x;\n+    *    int y;\n+    *    }\n+    * value NestedB {\n+    *    NestedA a;\n+    *    NestedA b;\n+    *    }\n+    * value ContainerC {\n+    *    NestedB c;\n+    *    NestedB d;\n+    *    }\n+    *\n+    * method=\"ContainerC.getc()QNestedB;\"\n+    *\n+    * /--- trees inserted ------------------------\n+    * n5n      (  0)  NULLCHK on n3n [#32]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzNDM4NA=="}, "originalCommit": {"oid": "218c43a912b7cbc397bc0d3678c8b3eefc7c6c9a"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4664, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}