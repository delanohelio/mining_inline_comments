{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MzQ4NTgy", "number": 9119, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDoyMTo0MVrODvSl3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDoyMTo0MVrODvSl3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTE0MjY4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/j9methodServer.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDoyMTo0MVrOGBoaLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNjo0ODoxNlrOGCMxYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2MzgyMg==", "bodyText": "If className is used just for traceMsg I suggest to use the same trick as above with a if (comp->getDebug()) test to avoid computing J9ROMCLASS_CLASSNAME(TR::Compiler->cls.romClassOf((TR_OpaqueClassBlock *) definingClass));", "url": "https://github.com/eclipse-openj9/openj9/pull/9119#discussion_r404363822", "createdAt": "2020-04-06T20:21:41Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/j9methodServer.cpp", "diffHunk": "@@ -2038,69 +2038,53 @@ bool\n TR_ResolvedRelocatableJ9JITServerMethod::storeValidationRecordIfNecessary(TR::Compilation * comp, J9ConstantPool *constantPool, int32_t cpIndex, TR_ExternalRelocationTargetKind reloKind, J9Method *ramMethod, J9Class *definingClass)\n    {\n    TR_J9VMBase *fej9 = (TR_J9VMBase *) comp->fe();\n+\n    bool storeClassInfo = true;\n    bool fieldInfoCanBeUsed = false;\n    TR_AOTStats *aotStats = ((TR_JitPrivateConfig *)fej9->_jitConfig->privateConfig)->aotStats;\n    bool isStatic = (reloKind == TR_ValidateStaticField);\n \n-   UDATA *classChain = NULL;\n-   auto clientData = _fe->_compInfoPT->getClientData();\n-   PersistentUnorderedMap<J9Class *, UDATA *> &classChainCache = clientData->getClassChainDataCache();\n-   if (definingClass)\n-      {\n-      // if defining class is known, check if we already have a corresponding class chain cached\n-      OMR::CriticalSection classChainDataMapMonitor(clientData->getClassChainDataMapMonitor());\n-      auto it = classChainCache.find(definingClass);\n-      if (it != classChainCache.end())\n-         classChain = it->second;\n-      }\n-\n-   if (!classChain)\n+   if (comp->getDebug())\n       {\n-      _stream->write(JITServer::MessageType::ResolvedRelocatableMethod_storeValidationRecordIfNecessary, ramMethod, constantPool, cpIndex, isStatic, definingClass);\n-      // 1. RAM class of ramMethod\n-      // 2. defining class\n-      // 3. class chain\n-      auto recv = _stream->read<J9Class *, J9Class *, UDATA *>();\n-\n-      J9Class *clazz = std::get<0>(recv);\n+      // guard this code with debug check, to avoid\n+      // sending extra messages when not tracing\n       traceMsg(comp, \"storeValidationRecordIfNecessary:\\n\");\n       traceMsg(comp, \"\\tconstantPool %p cpIndex %d\\n\", constantPool, cpIndex);\n       traceMsg(comp, \"\\treloKind %d isStatic %d\\n\", reloKind, isStatic);\n-      J9UTF8 *methodClassName = J9ROMCLASS_CLASSNAME(TR::Compiler->cls.romClassOf((TR_OpaqueClassBlock *) clazz));\n-      traceMsg(comp, \"\\tmethod %p from class %p %.*s\\n\", ramMethod, clazz, J9UTF8_LENGTH(methodClassName), J9UTF8_DATA(methodClassName));\n+      J9UTF8 *methodClassName =\n+         J9ROMCLASS_CLASSNAME(\n+            TR::Compiler->cls.romClassOf(\n+               fej9->getClassOfMethod(reinterpret_cast<TR_OpaqueMethodBlock *>(ramMethod))));\n+      traceMsg(comp,\n+               \"\\tmethod %p from class %p %.*s\\n\",\n+               ramMethod,\n+               fej9->getClassOfMethod(reinterpret_cast<TR_OpaqueMethodBlock *>(ramMethod)),\n+               J9UTF8_LENGTH(methodClassName),\n+               J9UTF8_DATA(methodClassName));\n       traceMsg(comp, \"\\tdefiningClass %p\\n\", definingClass);\n+      }\n \n-      if (!definingClass)\n-         {\n-         definingClass = std::get<1>(recv);\n-         traceMsg(comp, \"\\tdefiningClass recomputed from cp as %p\\n\", definingClass);\n-         }\n-\n-      if (!definingClass)\n-         {\n-         if (aotStats)\n-            aotStats->numDefiningClassNotFound++;\n-         return false;\n-         }\n-\n-      J9UTF8 *className = J9ROMCLASS_CLASSNAME(TR::Compiler->cls.romClassOf((TR_OpaqueClassBlock *) definingClass));\n-      traceMsg(comp, \"\\tdefiningClass name %.*s\\n\", J9UTF8_LENGTH(className), J9UTF8_DATA(className));\n+   if (!definingClass)\n+      {\n+      definingClass = (J9Class *) TR_ResolvedJ9JITServerMethod::definingClassFromCPFieldRef(comp, cpIndex, isStatic);\n+      traceMsg(comp, \"\\tdefiningClass recomputed from cp as %p\\n\", definingClass);\n+      }\n \n-      // all kinds of validations may need to rely on the entire class chain, so make sure we can build one first\n-      classChain = std::get<2>(recv);\n+   if (!definingClass)\n+      {\n+      if (aotStats)\n+         aotStats->numDefiningClassNotFound++;\n+      return false;\n       }\n \n+   J9UTF8 *className = J9ROMCLASS_CLASSNAME(TR::Compiler->cls.romClassOf((TR_OpaqueClassBlock *) definingClass));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fdcaf45998fc12bc041ce0761435009528f92d1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk1OTU4Nw==", "bodyText": "Done", "url": "https://github.com/eclipse-openj9/openj9/pull/9119#discussion_r404959587", "createdAt": "2020-04-07T16:48:16Z", "author": {"login": "dmitry-ten"}, "path": "runtime/compiler/env/j9methodServer.cpp", "diffHunk": "@@ -2038,69 +2038,53 @@ bool\n TR_ResolvedRelocatableJ9JITServerMethod::storeValidationRecordIfNecessary(TR::Compilation * comp, J9ConstantPool *constantPool, int32_t cpIndex, TR_ExternalRelocationTargetKind reloKind, J9Method *ramMethod, J9Class *definingClass)\n    {\n    TR_J9VMBase *fej9 = (TR_J9VMBase *) comp->fe();\n+\n    bool storeClassInfo = true;\n    bool fieldInfoCanBeUsed = false;\n    TR_AOTStats *aotStats = ((TR_JitPrivateConfig *)fej9->_jitConfig->privateConfig)->aotStats;\n    bool isStatic = (reloKind == TR_ValidateStaticField);\n \n-   UDATA *classChain = NULL;\n-   auto clientData = _fe->_compInfoPT->getClientData();\n-   PersistentUnorderedMap<J9Class *, UDATA *> &classChainCache = clientData->getClassChainDataCache();\n-   if (definingClass)\n-      {\n-      // if defining class is known, check if we already have a corresponding class chain cached\n-      OMR::CriticalSection classChainDataMapMonitor(clientData->getClassChainDataMapMonitor());\n-      auto it = classChainCache.find(definingClass);\n-      if (it != classChainCache.end())\n-         classChain = it->second;\n-      }\n-\n-   if (!classChain)\n+   if (comp->getDebug())\n       {\n-      _stream->write(JITServer::MessageType::ResolvedRelocatableMethod_storeValidationRecordIfNecessary, ramMethod, constantPool, cpIndex, isStatic, definingClass);\n-      // 1. RAM class of ramMethod\n-      // 2. defining class\n-      // 3. class chain\n-      auto recv = _stream->read<J9Class *, J9Class *, UDATA *>();\n-\n-      J9Class *clazz = std::get<0>(recv);\n+      // guard this code with debug check, to avoid\n+      // sending extra messages when not tracing\n       traceMsg(comp, \"storeValidationRecordIfNecessary:\\n\");\n       traceMsg(comp, \"\\tconstantPool %p cpIndex %d\\n\", constantPool, cpIndex);\n       traceMsg(comp, \"\\treloKind %d isStatic %d\\n\", reloKind, isStatic);\n-      J9UTF8 *methodClassName = J9ROMCLASS_CLASSNAME(TR::Compiler->cls.romClassOf((TR_OpaqueClassBlock *) clazz));\n-      traceMsg(comp, \"\\tmethod %p from class %p %.*s\\n\", ramMethod, clazz, J9UTF8_LENGTH(methodClassName), J9UTF8_DATA(methodClassName));\n+      J9UTF8 *methodClassName =\n+         J9ROMCLASS_CLASSNAME(\n+            TR::Compiler->cls.romClassOf(\n+               fej9->getClassOfMethod(reinterpret_cast<TR_OpaqueMethodBlock *>(ramMethod))));\n+      traceMsg(comp,\n+               \"\\tmethod %p from class %p %.*s\\n\",\n+               ramMethod,\n+               fej9->getClassOfMethod(reinterpret_cast<TR_OpaqueMethodBlock *>(ramMethod)),\n+               J9UTF8_LENGTH(methodClassName),\n+               J9UTF8_DATA(methodClassName));\n       traceMsg(comp, \"\\tdefiningClass %p\\n\", definingClass);\n+      }\n \n-      if (!definingClass)\n-         {\n-         definingClass = std::get<1>(recv);\n-         traceMsg(comp, \"\\tdefiningClass recomputed from cp as %p\\n\", definingClass);\n-         }\n-\n-      if (!definingClass)\n-         {\n-         if (aotStats)\n-            aotStats->numDefiningClassNotFound++;\n-         return false;\n-         }\n-\n-      J9UTF8 *className = J9ROMCLASS_CLASSNAME(TR::Compiler->cls.romClassOf((TR_OpaqueClassBlock *) definingClass));\n-      traceMsg(comp, \"\\tdefiningClass name %.*s\\n\", J9UTF8_LENGTH(className), J9UTF8_DATA(className));\n+   if (!definingClass)\n+      {\n+      definingClass = (J9Class *) TR_ResolvedJ9JITServerMethod::definingClassFromCPFieldRef(comp, cpIndex, isStatic);\n+      traceMsg(comp, \"\\tdefiningClass recomputed from cp as %p\\n\", definingClass);\n+      }\n \n-      // all kinds of validations may need to rely on the entire class chain, so make sure we can build one first\n-      classChain = std::get<2>(recv);\n+   if (!definingClass)\n+      {\n+      if (aotStats)\n+         aotStats->numDefiningClassNotFound++;\n+      return false;\n       }\n \n+   J9UTF8 *className = J9ROMCLASS_CLASSNAME(TR::Compiler->cls.romClassOf((TR_OpaqueClassBlock *) definingClass));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2MzgyMg=="}, "originalCommit": {"oid": "6fdcaf45998fc12bc041ce0761435009528f92d1"}, "originalPosition": 82}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 332, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}