{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MTgwMjcy", "number": 10926, "title": "ReadOnly Interface Dispatch using PIC Slots", "bodyText": "Changes for supporting no patching Interface Dispatch sequence using PIC slots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder helper for Z works as following.\n_interfaceCallHelperReadOnlyMultiSlots \n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n\nAt call site, we check the class field on each slot one after another to see if we get hit and branch to cached method address before falling to slow path and call the PIC builder helper.\nSigned-off-by: Rahil Shah rahil@ca.ibm.com", "createdAt": "2020-10-19T18:02:24Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10926", "merged": true, "mergeCommit": {"oid": "2df089f3014aaec033eee82ce842a07008bf71b0"}, "closed": true, "closedAt": "2020-10-28T18:28:24Z", "author": {"login": "r30shah"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUIG8qgBqjM4OTQ4MjAxNDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXB3ugAFqTUxODk2ODA3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5220259c95f8f267d05832eb36fd4f8b68a4bec", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c5220259c95f8f267d05832eb36fd4f8b68a4bec", "committedDate": "2020-10-19T17:43:29Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site on Z works as\nfollowing.\n\n```\ncurrentOffset = 0\ncheckNextSlot:\nCompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\nIf CompareAndSwap is successfull\n   Update the methodAddress field in the PIC Slot\n   Jump doneCacheUpdate\n\nIf CachedClassInPIC == J9Class\n   Jump doneCacheUpdate\n\ncurrentOffset += sizeof single PIC slot\nif currentOffset <= lastOffset\n   Jump checkNextSlot\n\ndoneCacheUpdate:\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "dff73375bef73906c9e3bf362dea449251ef0791", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/dff73375bef73906c9e3bf362dea449251ef0791", "committedDate": "2020-10-19T18:01:35Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dff73375bef73906c9e3bf362dea449251ef0791", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/dff73375bef73906c9e3bf362dea449251ef0791", "committedDate": "2020-10-19T18:01:35Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "f9a5c32f145161b808fa24fbd75c34a01a8d41f9", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f9a5c32f145161b808fa24fbd75c34a01a8d41f9", "committedDate": "2020-10-19T18:19:11Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f9a5c32f145161b808fa24fbd75c34a01a8d41f9", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f9a5c32f145161b808fa24fbd75c34a01a8d41f9", "committedDate": "2020-10-19T18:19:11Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "52f2861a3710bacef8c64ca5b59c0130fd68575e", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/52f2861a3710bacef8c64ca5b59c0130fd68575e", "committedDate": "2020-10-19T19:06:08Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "52f2861a3710bacef8c64ca5b59c0130fd68575e", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/52f2861a3710bacef8c64ca5b59c0130fd68575e", "committedDate": "2020-10-19T19:06:08Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ab82c5d254e0315b3c65722371fda75cc1d79a10", "committedDate": "2020-10-19T20:20:38Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MDQ1OTI0", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#pullrequestreview-515045924", "createdAt": "2020-10-22T19:20:29Z", "commit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOToyMDoyOVrOHmwYig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTo0NDoxOVrOHmxJxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMDY1MA==", "bodyText": "Why not just change the type of this variable to be intptr_t and remove the casts below?", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510400650", "createdAt": "2020-10-22T19:20:29Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1653,3 +1653,67 @@ TR::S390VirtualUnresolvedReadOnlySnippet::getLength(int32_t estimatedSnippetStar\n            + sizeof(int32_t); /*RIP offset to post snippet call in mainline*/\n    }\n \n+uint8_t *\n+TR::S390InterfaceCallReadOnlySnippet::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   TR::Node *callNode = getNode();\n+\n+   TR::SymbolReference *interfaceCallReadOnlySymRef = cg()->symRefTab()->findOrCreateRuntimeHelper(TR_S390interfaceCallHelperMultiSlotsReadOnly,\n+                                                                                                               false, false, false);\n+   \n+   TR::GlobalFunctionCallData dataDestination(interfaceCallReadOnlySymRef, callNode, cursor, cg(), self());\n+\n+   cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n+\n+   uint8_t *helperCallRA = cursor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMTg2MA==", "bodyText": "void * vs void* inconsistent. Also need spaces between arithmetic + operators.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510401860", "createdAt": "2020-10-22T19:22:45Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1653,3 +1653,67 @@ TR::S390VirtualUnresolvedReadOnlySnippet::getLength(int32_t estimatedSnippetStar\n            + sizeof(int32_t); /*RIP offset to post snippet call in mainline*/\n    }\n \n+uint8_t *\n+TR::S390InterfaceCallReadOnlySnippet::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   TR::Node *callNode = getNode();\n+\n+   TR::SymbolReference *interfaceCallReadOnlySymRef = cg()->symRefTab()->findOrCreateRuntimeHelper(TR_S390interfaceCallHelperMultiSlotsReadOnly,\n+                                                                                                               false, false, false);\n+   \n+   TR::GlobalFunctionCallData dataDestination(interfaceCallReadOnlySymRef, callNode, cursor, cg(), self());\n+\n+   cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n+\n+   uint8_t *helperCallRA = cursor;\n+   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(interfaceCallPICSlotDataAddress), \"interfaceCallPICData %p is outside relative immediate range\", interfaceCallPICSlotDataAddress);\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(interfaceCallPICSlotDataAddress - (intptr_t)helperCallRA);\n+   cursor += sizeof(int32_t);\n+\n+   intptr_t doneLabelAddress = reinterpret_cast<intptr_t>(doneLabel->getCodeLocation());\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(doneLabelAddress - (intptr_t)helperCallRA);\n+   cursor += sizeof(int32_t);\n+\n+   return cursor;\n+   }\n+\n+void\n+TR_Debug::print(TR::FILE *pOutFile, TR::S390InterfaceCallReadOnlySnippet *snippet)\n+   {\n+   uint8_t *bufferPos = snippet->getSnippetLabel()->getCodeLocation();\n+   TR::SymbolReference *resolveVirtualDispatchReadOnlySymRef = _cg->getSymRef(TR_S390interfaceCallHelperMultiSlotsReadOnly);\n+\n+   TR::SymbolReference *methodSymRef = snippet->getNode()->getSymbolReference();\n+   // TODO: Need the address of the ccGlobalFunctionCallData   \n+   printSnippetLabel(pOutFile, snippet->getSnippetLabel(), bufferPos, \"Interface Call Snippet using Multi Slots\");\n+   printPrefix(pOutFile, NULL, bufferPos, 6);\n+   trfprintf(pOutFile, \"LGRL \\tGPR14, <%p>\\t# Load address of the Helper Method, targetAddress = <%p>\",\n+                    (void *)*(int32_t*)(bufferPos+sizeof(int16_t)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNTg3OQ==", "bodyText": "static_cast needed here.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510405879", "createdAt": "2020-10-22T19:30:21Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNjc3NQ==", "bodyText": "Can we use a static const inside of ccInterfaceData to store the constant 3 and use it here instead? This seems quite error prone as the magic constant gets used several times in this function and we can replace it with a properly named and scoped constant that is defined right in the struct.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510406775", "createdAt": "2020-10-22T19:31:59Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwODg4MQ==", "bodyText": "Why is this needed?", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510408881", "createdAt": "2020-10-22T19:36:11Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));\n+   ccInterfaceDataAddress->isCacheFull = 0;\n+\n+   // Now we are checking each slot and dispatching methods. \n+   intptr_t interfaceDataAddress = reinterpret_cast<intptr_t>(ccInterfaceDataAddress);\n+\n+   TR::StaticSymbol *interfaceDataSymbol =\n+      TR::StaticSymbol::createWithAddress(trHeapMemory(), TR::Address, reinterpret_cast<void *>(interfaceDataAddress));\n+   interfaceDataSymbol->setNotDataAddress();\n+   TR::SymbolReference *interfaceDataSymRef = new (trHeapMemory()) TR::SymbolReference(cg()->comp()->getSymRefTab(), interfaceDataSymbol, 0);\n+\n+   /**\n+    * LARL  regEP, interfaceDataAddress\n+    * LARL  regRA, returnAddress\n+    * Label StartICF: (Attaching predependency conditions here.\n+    * LPQ   Class,MethodAddress, 0(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,MethodAddress\n+    * LPQ   Class,MethodAddress, 16(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * LPQ   Class,MethodAddress, 32(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * Label SnippetCal: (Cache miss, will be calling the snippet)\n+    * BRCL  interfaceCallSnippet\n+    * Label doneLabel: (Attaching Post Deps Here)\n+    */\n+   int32_t numberOfAdditionalPostDeps = 3; // For load pair instruction, we need 3 virtual registers, even reg, odd reg, even-odd pair\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Instruction *cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regEP, interfaceDataSymRef, interfaceDataSymbol->getStaticAddress());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regRA, doneLabel, cursor);\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                         dependencies->getAddCursorForPre(), 0, cg());\n+   \n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numberOfAdditionalPostDeps, cg());\n+   // Removing the pre dependencies from the postDeps\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTIxNg==", "bodyText": "Why is the NOP needed?", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510411216", "createdAt": "2020-10-22T19:40:25Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));\n+   ccInterfaceDataAddress->isCacheFull = 0;\n+\n+   // Now we are checking each slot and dispatching methods. \n+   intptr_t interfaceDataAddress = reinterpret_cast<intptr_t>(ccInterfaceDataAddress);\n+\n+   TR::StaticSymbol *interfaceDataSymbol =\n+      TR::StaticSymbol::createWithAddress(trHeapMemory(), TR::Address, reinterpret_cast<void *>(interfaceDataAddress));\n+   interfaceDataSymbol->setNotDataAddress();\n+   TR::SymbolReference *interfaceDataSymRef = new (trHeapMemory()) TR::SymbolReference(cg()->comp()->getSymRefTab(), interfaceDataSymbol, 0);\n+\n+   /**\n+    * LARL  regEP, interfaceDataAddress\n+    * LARL  regRA, returnAddress\n+    * Label StartICF: (Attaching predependency conditions here.\n+    * LPQ   Class,MethodAddress, 0(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,MethodAddress\n+    * LPQ   Class,MethodAddress, 16(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * LPQ   Class,MethodAddress, 32(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * Label SnippetCal: (Cache miss, will be calling the snippet)\n+    * BRCL  interfaceCallSnippet\n+    * Label doneLabel: (Attaching Post Deps Here)\n+    */\n+   int32_t numberOfAdditionalPostDeps = 3; // For load pair instruction, we need 3 virtual registers, even reg, odd reg, even-odd pair\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Instruction *cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regEP, interfaceDataSymRef, interfaceDataSymbol->getStaticAddress());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regRA, doneLabel, cursor);\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                         dependencies->getAddCursorForPre(), 0, cg());\n+   \n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numberOfAdditionalPostDeps, cg());\n+   // Removing the pre dependencies from the postDeps\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg());\n+   cursor = generateS390LabelInstruction(cg(), TR::InstOpCode::LABEL, callNode, cFlowRegionStart, preDeps, cursor);\n+\n+   TR::Register      *slotClassReg = cg()->allocateRegister();\n+   TR::Register      *slotMethodAddressReg = cg()->allocateRegister();\n+   TR::RegisterPair  *slotClassMethodRegPair = cg()->allocateConsecutiveRegisterPair(slotMethodAddressReg, slotClassReg);\n+   postDeps->addPostCondition(slotClassReg, TR::RealRegister::LegalEvenOfPair);\n+   postDeps->addPostCondition(slotMethodAddressReg, TR::RealRegister::LegalOddOfPair);\n+   postDeps->addPostCondition(slotClassMethodRegPair, TR::RealRegister::EvenOddPair);\n+   postDeps->addPostConditionIfNotAlreadyInserted(vftReg, TR::RealRegister::AssignAny);\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot1Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot2Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot3Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   TR::LabelSymbol *interfaceCallHelperSnippetLabel = generateLabelSymbol(cg());\n+   TR::S390InterfaceCallReadOnlySnippet *snippet = new (trHeapMemory()) TR::S390InterfaceCallReadOnlySnippet(\n+      cg(),\n+      callNode,\n+      interfaceCallHelperSnippetLabel,\n+      doneLabel,\n+      interfaceDataAddress);\n+   // Cache miss, going to slow path to lookup the interface method.\n+   cursor = new (trHeapMemory()) TR::S390RILInstruction(TR::InstOpCode::BRCL, callNode, 0xF, snippet, NULL, cg());\n+   cursor = new (trHeapMemory()) TR::S390NOPInstruction(TR::InstOpCode::NOP, 2, callNode, cg()); ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMzI1NA==", "bodyText": "We should try to keep the names of these the same as the fields for easier searchability. For example searching for \"totalSizeOfPicSlots\" will not get a hit here.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510413254", "createdAt": "2020-10-22T19:44:19Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/runtime/PicBuilder.m4", "diffHunk": "@@ -155,6 +155,24 @@ SETVAL(eq_returnAddressDirectMethod,8)\n SETVAL(eq_resolveVirtualJitEIPForHelperCall,12)\n SETVAL(eq_ResolveVirtualData_RIP,0)\n \n+ZZ Interface Call Helper Read Only Layout\n+SETVAL(eq_InterfaceCallHelperReadOnly_Data,0)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot1,0)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot1,8)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot2,16)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot2,24)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot3,32)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot3,40)\n+SETVAL(eq_InterfaceCallHelper_cpAddress,48)\n+SETVAL(eq_InterfaceCallHelper_cpIndex,56)\n+SETVAL(eq_InterfaceCallHelper_interfaceClass,64)\n+SETVAL(eq_InterfaceCallHelper_methodIndex,72)\n+SETVAL(eq_InterfaceCallHelperTotalPICSlotSize,88)\n+SETVAL(eq_InterfaceCallHelper_isCacheFullFlag,96)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 17}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ab82c5d254e0315b3c65722371fda75cc1d79a10", "committedDate": "2020-10-19T20:20:38Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "3282a01df297676d33999fca192d2613b5db1b09", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3282a01df297676d33999fca192d2613b5db1b09", "committedDate": "2020-10-23T15:58:42Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3282a01df297676d33999fca192d2613b5db1b09", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3282a01df297676d33999fca192d2613b5db1b09", "committedDate": "2020-10-23T15:58:42Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "d1f154c59f4e002f94b5e613001eb016a95a6927", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/d1f154c59f4e002f94b5e613001eb016a95a6927", "committedDate": "2020-10-23T16:15:31Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d1f154c59f4e002f94b5e613001eb016a95a6927", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/d1f154c59f4e002f94b5e613001eb016a95a6927", "committedDate": "2020-10-23T16:15:31Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "e2eb175cf4e392b9a013648129c1209bc1790bc8", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e2eb175cf4e392b9a013648129c1209bc1790bc8", "committedDate": "2020-10-26T14:38:49Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c", "committedDate": "2020-10-26T16:53:50Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e2eb175cf4e392b9a013648129c1209bc1790bc8", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/e2eb175cf4e392b9a013648129c1209bc1790bc8", "committedDate": "2020-10-26T14:38:49Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c", "committedDate": "2020-10-26T16:53:50Z", "message": "ReadOnly Interface Dispatch using PIC Slots\n\nChanges for supporting no patching Interface Dispatch sequence using PIC\nslots for read only code.\nUpdating the PIC Slots for Interface Dispatch call site in PICBuilder\nhelper for Z works as following.\n\n```\n_interfaceCallHelperReadOnlyMultiSlots\n{\n...\n   currentOffset = 0\n   checkNextSlot:\n   CompareAndSwap defaultValueInClassField,J9Class,$(currentOffset+PICSlotsData)\n   If CompareAndSwap is successfull\n      Update the methodAddress field in the PIC Slot\n      Jump doneCacheUpdate\n\n   If CachedClassInPIC == J9Class\n      Jump doneCacheUpdate\n\n   currentOffset += sizeof single PIC slot\n   if currentOffset <= lastOffset\n      Jump checkNextSlot\n\n   doneCacheUpdate:\n...\n}\n```\n\nAt call site, we check the class field on each slot one after another to\nsee if we get hit and branch to cached method address before falling to\nslow path and call the PIC builder helper.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4OTY4MDc4", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#pullrequestreview-518968078", "createdAt": "2020-10-28T18:28:16Z", "commit": {"oid": "7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 221, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}