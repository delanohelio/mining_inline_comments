{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MTc1MjA1", "number": 9074, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTozOTo0OVrODtrZyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTo0MDo1N1rODuAyWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjIzNjI2OnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxOTozOTo0OVrOF_PxLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMzo1MDozN1rOF_WnaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ==", "bodyText": "Unfortunately with compressed/full selection runtime we can not use fomrobject_t * pointer math directly any more. Please use GC_SlotObject::addToSlotAddress() (in this case) instead. See examples in ObjectScanner.hpp and other scanners source code.", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401862959", "createdAt": "2020-04-01T19:39:49Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3MDk3OQ==", "bodyText": "I'm not sure if that is correct. This is adding the total size in bytes of the object, which should be correct no matter if we're compressed or not.", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401870979", "createdAt": "2020-04-01T19:54:05Z", "author": {"login": "youngar"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}, "originalCommit": {"oid": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4MzkxNA==", "bodyText": "Right. I put this comment wrong place when re-do it after refresh, sorry. I intended to put it for line 147. However I am not sure line 147 is correct - (splitAmount * elementStride) is in bytes but added to pointer. Anyway, any (if any)fomrobject_t * pointer math in this PR should support runtime compressed/full selection", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401883914", "createdAt": "2020-04-01T20:18:02Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}, "originalCommit": {"oid": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4NzI5OQ==", "bodyText": "formatting: please add spaces around multiplication sign *", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401887299", "createdAt": "2020-04-01T20:24:09Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}, "originalCommit": {"oid": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5MjcxMA==", "bodyText": "Should I wrap it in brackets, like this?\n(fomrobject_t *)((uintptr_t)basePtr + (startIndex * elementStride));", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401892710", "createdAt": "2020-04-01T20:34:36Z", "author": {"login": "youngar"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}, "originalCommit": {"oid": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NzkyOA==", "bodyText": "Yes, please. I like it", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401897928", "createdAt": "2020-04-01T20:44:28Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}, "originalCommit": {"oid": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTE0NQ==", "bodyText": "Fixed!", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401975145", "createdAt": "2020-04-01T23:50:37Z", "author": {"login": "youngar"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2Mjk1OQ=="}, "originalCommit": {"oid": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjM4NjIwOnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDoyMzozMlrOF_RO_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMzo1MTozMFrOF_WoPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4Njk3Mg==", "bodyText": "Good catch Dmitri\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tendPtr = scanPtr + (splitAmount * elementStride);\n          \n          \n            \n            \t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401886972", "createdAt": "2020-04-01T20:23:32Z", "author": {"login": "youngar"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = scanPtr + (splitAmount * elementStride);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTM1Nw==", "bodyText": "Fixed in the PR, I didn't use the automatic github commit.", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401975357", "createdAt": "2020-04-01T23:51:30Z", "author": {"login": "youngar"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = scanPtr + (splitAmount * elementStride);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4Njk3Mg=="}, "originalCommit": {"oid": "97ef6d7b24f7c1ae8407f22cad612f70c92883b5"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjQyMjkwOnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDozNDo0M1rOF_Rlow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDozNDo0M1rOF_Rlow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Mjc3MQ==", "bodyText": "formatting: please add spaces around multiplication sign * : splitAmount * elementStride - here and a few other places", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401892771", "createdAt": "2020-04-01T20:34:43Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjQ0MDM5OnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDozOTo1NlrOF_RwXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMzo1MTo0MVrOF_Wofg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTUxNw==", "bodyText": "Is there a reason to cast to (uint8_t *)? There is cast to (uintptr_t) used everywhere. However if you want to keep (uint8_t *) - formatting: please add space between uint8_t and *", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401895517", "createdAt": "2020-04-01T20:39:56Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);\n+\t\t\tif (endPtr > limitPtr) {\n+\t\t\t\tendPtr = limitPtr;\n+\t\t\t}\n+\t\t}\n+\t\tuintptr_t *instanceDescription = elementClass->instanceDescription;\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tuintptr_t *leafDescription = elementClass->instanceLeafDescription;\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\tobjectScanner->initialize(env);\n+\t\tif (0 != startIndex) {\n+\t\t\tobjectScanner->clearHeadObjectScanner();\n+\t\t}\n+\t\treturn objectScanner;\n+\t}\n+\n+\tMMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param splitAmount The maximum number of array elements to include\n+\t * @return Pointer to split scanner in allocSpace\n+\t */\n+\tGC_IndexableObjectScanner *\n+\tsplitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)\n+\t{\n+\t\tAssert_MM_unimplemented();\n+\t}\n+\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NjI4NA==", "bodyText": "I'll cast to uintptr_t instead", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401896284", "createdAt": "2020-04-01T20:41:28Z", "author": {"login": "youngar"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);\n+\t\t\tif (endPtr > limitPtr) {\n+\t\t\t\tendPtr = limitPtr;\n+\t\t\t}\n+\t\t}\n+\t\tuintptr_t *instanceDescription = elementClass->instanceDescription;\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tuintptr_t *leafDescription = elementClass->instanceLeafDescription;\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\tobjectScanner->initialize(env);\n+\t\tif (0 != startIndex) {\n+\t\t\tobjectScanner->clearHeadObjectScanner();\n+\t\t}\n+\t\treturn objectScanner;\n+\t}\n+\n+\tMMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param splitAmount The maximum number of array elements to include\n+\t * @return Pointer to split scanner in allocSpace\n+\t */\n+\tGC_IndexableObjectScanner *\n+\tsplitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)\n+\t{\n+\t\tAssert_MM_unimplemented();\n+\t}\n+\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTUxNw=="}, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTQyMg==", "bodyText": "Fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401975422", "createdAt": "2020-04-01T23:51:41Z", "author": {"login": "youngar"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);\n+\t\t\tif (endPtr > limitPtr) {\n+\t\t\t\tendPtr = limitPtr;\n+\t\t\t}\n+\t\t}\n+\t\tuintptr_t *instanceDescription = elementClass->instanceDescription;\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tuintptr_t *leafDescription = elementClass->instanceLeafDescription;\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\tobjectScanner->initialize(env);\n+\t\tif (0 != startIndex) {\n+\t\t\tobjectScanner->clearHeadObjectScanner();\n+\t\t}\n+\t\treturn objectScanner;\n+\t}\n+\n+\tMMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param splitAmount The maximum number of array elements to include\n+\t * @return Pointer to split scanner in allocSpace\n+\t */\n+\tGC_IndexableObjectScanner *\n+\tsplitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)\n+\t{\n+\t\tAssert_MM_unimplemented();\n+\t}\n+\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTUxNw=="}, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjQ0NzQ2OnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0MjowNlrOF_R0vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMzo1MTo1MVrOF_WowA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NjYzOQ==", "bodyText": "Same as above - change cast to (uintptr_t) or add space", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401896639", "createdAt": "2020-04-01T20:42:06Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);\n+\t\t\tif (endPtr > limitPtr) {\n+\t\t\t\tendPtr = limitPtr;\n+\t\t\t}\n+\t\t}\n+\t\tuintptr_t *instanceDescription = elementClass->instanceDescription;\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tuintptr_t *leafDescription = elementClass->instanceLeafDescription;\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\tobjectScanner->initialize(env);\n+\t\tif (0 != startIndex) {\n+\t\t\tobjectScanner->clearHeadObjectScanner();\n+\t\t}\n+\t\treturn objectScanner;\n+\t}\n+\n+\tMMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param splitAmount The maximum number of array elements to include\n+\t * @return Pointer to split scanner in allocSpace\n+\t */\n+\tGC_IndexableObjectScanner *\n+\tsplitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)\n+\t{\n+\t\tAssert_MM_unimplemented();\n+\t}\n+\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);\n+\t\t\t\tGC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);\n+\t\t\t\t/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. \n+\t\t\t\t * We must also return (hasNextSlotMap = true) on top of this\n+\t\t\t\t */\n+\t\t\t\tsetMoreSlots();\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] leafMap the leaf bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, uintptr_t *leafMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, leafMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTQ4OA==", "bodyText": "Fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401975488", "createdAt": "2020-04-01T23:51:51Z", "author": {"login": "youngar"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,258 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);\n+\t\t\tif (endPtr > limitPtr) {\n+\t\t\t\tendPtr = limitPtr;\n+\t\t\t}\n+\t\t}\n+\t\tuintptr_t *instanceDescription = elementClass->instanceDescription;\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tuintptr_t *leafDescription = elementClass->instanceLeafDescription;\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\tobjectScanner->initialize(env);\n+\t\tif (0 != startIndex) {\n+\t\t\tobjectScanner->clearHeadObjectScanner();\n+\t\t}\n+\t\treturn objectScanner;\n+\t}\n+\n+\tMMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param splitAmount The maximum number of array elements to include\n+\t * @return Pointer to split scanner in allocSpace\n+\t */\n+\tGC_IndexableObjectScanner *\n+\tsplitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)\n+\t{\n+\t\tAssert_MM_unimplemented();\n+\t}\n+\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);\n+\t\t\t\tGC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);\n+\t\t\t\t/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. \n+\t\t\t\t * We must also return (hasNextSlotMap = true) on top of this\n+\t\t\t\t */\n+\t\t\t\tsetMoreSlots();\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] leafMap the leaf bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, uintptr_t *leafMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, leafMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NjYzOQ=="}, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjQ2ODE2OnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/HeadlessMixedObjectScanner.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0ODoyN1rOF_SBsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0ODoyN1rOF_SBsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5OTk1NQ==", "bodyText": "Same as above - change cast to (uintptr_t) or add space", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401899955", "createdAt": "2020-04-01T20:48:27Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/HeadlessMixedObjectScanner.hpp", "diffHunk": "@@ -51,13 +51,14 @@ class GC_HeadlessMixedObjectScanner : public GC_ObjectScanner\n \n \t/**\n \t * @param env The scanning thread environment\n-\t * @param[in] objectPtr the object to be processed\n-\t * @param[in] flags Scanning context flags\n+\t * @param scanPtr Pointer to the start of the object\n+\t * @param size The instance size\n+\t * @param flags Scanning context flags\n \t */\n-\tMMINLINE GC_HeadlessMixedObjectScanner(MM_EnvironmentBase *env, J9Class *clazzPtr, fomrobject_t *scanPtr, uintptr_t flags)\n+\tMMINLINE GC_HeadlessMixedObjectScanner(MM_EnvironmentBase *env, fomrobject_t *scanPtr, uintptr_t size, uintptr_t flags)\n \t\t: GC_ObjectScanner(env, scanPtr, 0, flags)\n-\t\t, _endPtr((fomrobject_t *)((uint8_t*)_scanPtr + env->getExtensions()->mixedObjectModel.getSizeInBytesWithoutHeader(clazzPtr)))\n-\t\t, _mapPtr(_scanPtr)\n+\t\t, _endPtr((fomrobject_t *)((uint8_t*)scanPtr + size))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjQ3NTcyOnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/MixedObjectScanner.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo1MDo0M1rOF_SGYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo1MDo0M1rOF_SGYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMTE1NA==", "bodyText": "this change is not necessary", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401901154", "createdAt": "2020-04-01T20:50:43Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/MixedObjectScanner.hpp", "diffHunk": "@@ -41,7 +41,7 @@\n class GC_MixedObjectScanner : public GC_HeadlessMixedObjectScanner\n {\n \n-\t/* Data Members */\n+\t\t/* Data Members */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjQ4OTM3OnYy", "diffSide": "RIGHT", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo1NDo1NFrOF_SO2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo1NDo1NFrOF_SO2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMzMyMg==", "bodyText": "I guess typo. Should it be /* megaObject */ ?", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401903322", "createdAt": "2020-04-01T20:54:54Z", "author": {"login": "dmitripivkine"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -107,6 +107,9 @@\n \tstatic Class largeObjectValueClass = null;\n \tstatic MethodHandle makeLargeObjectValue = null;\n \tstatic MethodHandle[] getObjects = null;\n+\t/* megeObject */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjU1NjYzOnYy", "diffSide": "RIGHT", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMToxNTozMVrOF_S41g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMzo1ODo1NlrOF_WxKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxNDA3MA==", "bodyText": "you can use checkFieldAccessMHOfAssortedType to verify that what you are getting back is the correct thing", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401914070", "createdAt": "2020-04-01T21:15:31Z", "author": {"login": "tajila"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -252,6 +255,71 @@ static public void testCreateArrayPoint2D() throws Throwable {\n \t\tassertEquals(getY.invoke(point2D_2_check), getY.invoke(point2D_2));\n \t}\n \n+\t@Test(priority=5)\n+\tstatic public void testGCFlattenedPoint2DArray() throws Throwable {\n+\t\tint x1 = 0xFFEEFFEE;\n+\t\tint y1 = 0xAABBAABB;\n+\t\tObject point2D = makePoint2D.invoke(x1, y1);\n+\t\tObject arrayObject = Array.newInstance(point2DClass, 8);\n+\n+\t\tfor (int i = 1; i < 8; i++) {\n+\t\t\tArray.set(arrayObject, i, point2D);\n+\t\t}\n+\n+\t\tSystem.gc();\n+\t\tSystem.gc();\n+\n+\t\tObject value = Array.get(arrayObject, 0);\n+\t}\n+\n+\t@Test(priority=5)\n+\tstatic public void testGCFlattenedAssortedValueArray() throws Throwable {\n+\t\tObject arrayObject = Array.newInstance(assortedValueWithLongAlignmentClass, 4);\n+\t\tObject assortedValueWithLongAlignment = createAssorted(makeAssortedValueWithLongAlignment, typeWithLongAlignmentFields);\n+\n+\t\tfor (int i = 1; i < 4; i++) {\n+\t\t\tArray.set(arrayObject, i, assortedValueWithLongAlignment);\n+\t\t}\n+\n+\t\tSystem.gc();\n+\t\tSystem.gc();\n+\n+\t\tObject value = Array.get(arrayObject, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NzY0Mw==", "bodyText": "I added tests so now we're doing all three singleAlignment, objectAlignment, and longAlignment.  The tests are now using checkFieldAccessMHOfAssortedType on each array element.", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401977643", "createdAt": "2020-04-01T23:58:56Z", "author": {"login": "youngar"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -252,6 +255,71 @@ static public void testCreateArrayPoint2D() throws Throwable {\n \t\tassertEquals(getY.invoke(point2D_2_check), getY.invoke(point2D_2));\n \t}\n \n+\t@Test(priority=5)\n+\tstatic public void testGCFlattenedPoint2DArray() throws Throwable {\n+\t\tint x1 = 0xFFEEFFEE;\n+\t\tint y1 = 0xAABBAABB;\n+\t\tObject point2D = makePoint2D.invoke(x1, y1);\n+\t\tObject arrayObject = Array.newInstance(point2DClass, 8);\n+\n+\t\tfor (int i = 1; i < 8; i++) {\n+\t\t\tArray.set(arrayObject, i, point2D);\n+\t\t}\n+\n+\t\tSystem.gc();\n+\t\tSystem.gc();\n+\n+\t\tObject value = Array.get(arrayObject, 0);\n+\t}\n+\n+\t@Test(priority=5)\n+\tstatic public void testGCFlattenedAssortedValueArray() throws Throwable {\n+\t\tObject arrayObject = Array.newInstance(assortedValueWithLongAlignmentClass, 4);\n+\t\tObject assortedValueWithLongAlignment = createAssorted(makeAssortedValueWithLongAlignment, typeWithLongAlignmentFields);\n+\n+\t\tfor (int i = 1; i < 4; i++) {\n+\t\t\tArray.set(arrayObject, i, assortedValueWithLongAlignment);\n+\t\t}\n+\n+\t\tSystem.gc();\n+\t\tSystem.gc();\n+\n+\t\tObject value = Array.get(arrayObject, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxNDA3MA=="}, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjU2OTgwOnYy", "diffSide": "RIGHT", "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMToxOTo1MlrOF_TBDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMDowMDoxOVrOF_Wy-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxNjE3Mg==", "bodyText": "For this test we want to see whether the GC will scan the default value on the J9Class (see https://github.com/eclipse/openj9/blob/master/runtime/gc_structs/ValueTypesIterator.hpp#L69), we know this is tested with a big number (200000) does it still exercise that path with 200?", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401916172", "createdAt": "2020-04-01T21:19:52Z", "author": {"login": "tajila"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -1402,7 +1471,7 @@ static public void testStaticFieldsWithObjectAlignment() throws Throwable {\n \tstatic public void testCreateLargeNumberOfPoint2D() throws Throwable {\n \t\tString fields[] = {\"x:I\", \"y:I\"};\n \t\tString className = \"Point2D\";\n-\t\tfor (int valueIndex = 0; valueIndex < 200000; valueIndex++) {\n+\t\tfor (int valueIndex = 0; valueIndex < 200; valueIndex++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkyOTk1MQ==", "bodyText": "This was accidentally added, the tests were simply taking too long.  Thanks for pointing it out.  Could we switch this test to call System.gc()?", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401929951", "createdAt": "2020-04-01T21:48:01Z", "author": {"login": "youngar"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -1402,7 +1471,7 @@ static public void testStaticFieldsWithObjectAlignment() throws Throwable {\n \tstatic public void testCreateLargeNumberOfPoint2D() throws Throwable {\n \t\tString fields[] = {\"x:I\", \"y:I\"};\n \t\tString className = \"Point2D\";\n-\t\tfor (int valueIndex = 0; valueIndex < 200000; valueIndex++) {\n+\t\tfor (int valueIndex = 0; valueIndex < 200; valueIndex++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxNjE3Mg=="}, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3ODEwNw==", "bodyText": "I just switched back the number for now.", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401978107", "createdAt": "2020-04-02T00:00:19Z", "author": {"login": "youngar"}, "path": "test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java", "diffHunk": "@@ -1402,7 +1471,7 @@ static public void testStaticFieldsWithObjectAlignment() throws Throwable {\n \tstatic public void testCreateLargeNumberOfPoint2D() throws Throwable {\n \t\tString fields[] = {\"x:I\", \"y:I\"};\n \t\tString className = \"Point2D\";\n-\t\tfor (int valueIndex = 0; valueIndex < 200000; valueIndex++) {\n+\t\tfor (int valueIndex = 0; valueIndex < 200; valueIndex++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxNjE3Mg=="}, "originalCommit": {"oid": "f4efb095aa726db6d52a481dcdb2c473cc7cb4eb"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mjk3NTIwOnYy", "diffSide": "RIGHT", "path": "test/functional/Valhalla/playlist.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMDowMzoxMVrOF_W2Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMDowNjoyN1rOF_W6Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3ODkzOQ==", "bodyText": "@tajila I think it makes sense to enable the GC as a separate variation.  It may help track down if the issue is GC specific. What do you think?", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401978939", "createdAt": "2020-04-02T00:03:11Z", "author": {"login": "youngar"}, "path": "test/functional/Valhalla/playlist.xml", "diffHunk": "@@ -27,6 +27,7 @@\n \t\t<variations>\n \t\t\t<variation>NoOptions</variation>\n \t\t\t<variation>-Xgcpolicy:nogc -XX:ValueTypeFlatteningThreshold=99999</variation>\n+\t\t\t<variation>-Xgcpolicy:optthruput -Xnocompactgc -XX:ValueTypeFlatteningThreshold=99999</variation>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f41926821736c594ddc7b61143e219a85f5e8730"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3OTkzMA==", "bodyText": "that sounds good", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r401979930", "createdAt": "2020-04-02T00:06:27Z", "author": {"login": "tajila"}, "path": "test/functional/Valhalla/playlist.xml", "diffHunk": "@@ -27,6 +27,7 @@\n \t\t<variations>\n \t\t\t<variation>NoOptions</variation>\n \t\t\t<variation>-Xgcpolicy:nogc -XX:ValueTypeFlatteningThreshold=99999</variation>\n+\t\t\t<variation>-Xgcpolicy:optthruput -Xnocompactgc -XX:ValueTypeFlatteningThreshold=99999</variation>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3ODkzOQ=="}, "originalCommit": {"oid": "f41926821736c594ddc7b61143e219a85f5e8730"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTczMjU5OnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTozOToyM1rOF_xTZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNzoyNzoxOVrOF_1t8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxMjM5MQ==", "bodyText": "I'd rather have this (and all parent) classes cache and pass through init method GCExtentions then Environment, since they don't seem  to use anything that is thread specific. This sort of makes assumption that thread that created the scanner will not be passed to another thread for usage (which might not be true - it might be passed through global scan queue).\n@dmitripivkine your opinion?\nAnyhow, that's a separate issue (would require OMR change, as well).", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r402412391", "createdAt": "2020-04-02T15:39:23Z", "author": {"login": "amicic"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,255 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07755f7fa4775348a9c8eb58f8c9e59b0bf861fb"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQzOTY4Mg==", "bodyText": "Yes, I agree. I noticed this and it might be a source of the problem potentially", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r402439682", "createdAt": "2020-04-02T16:17:46Z", "author": {"login": "dmitripivkine"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,255 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxMjM5MQ=="}, "originalCommit": {"oid": "07755f7fa4775348a9c8eb58f8c9e59b0bf861fb"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4NDcyMg==", "bodyText": "Created an issue for this: eclipse/omr#5018", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r402484722", "createdAt": "2020-04-02T17:27:19Z", "author": {"login": "youngar"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,255 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxMjM5MQ=="}, "originalCommit": {"oid": "07755f7fa4775348a9c8eb58f8c9e59b0bf861fb"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTczOTc3OnYy", "diffSide": "RIGHT", "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTo0MDo1N1rOF_xX8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjo1NzoxN1rOF_0j_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxMzU1Mw==", "bodyText": "missing EOL or something?", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r402413553", "createdAt": "2020-04-02T15:40:57Z", "author": {"login": "amicic"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,255 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + (sizeInElements * elementStride));\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + (startIndex * elementStride));\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + (splitAmount * elementStride));\n+\t\t\tif (endPtr > limitPtr) {\n+\t\t\t\tendPtr = limitPtr;\n+\t\t\t}\n+\t\t}\n+\t\tuintptr_t *instanceDescription = elementClass->instanceDescription;\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tuintptr_t *leafDescription = elementClass->instanceLeafDescription;\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\tobjectScanner->initialize(env);\n+\t\tif (0 != startIndex) {\n+\t\t\tobjectScanner->clearHeadObjectScanner();\n+\t\t}\n+\t\treturn objectScanner;\n+\t}\n+\n+\tMMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param splitAmount The maximum number of array elements to include\n+\t * @return Pointer to split scanner in allocSpace\n+\t */\n+\tGC_IndexableObjectScanner *\n+\tsplitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)\n+\t{\n+\t\tAssert_MM_unimplemented();\n+\t}\n+\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uintptr_t)_mapPtr + _elementSizeWithoutPadding);\n+\t\t\t\tGC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);\n+\t\t\t\t/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. \n+\t\t\t\t * We must also return (hasNextSlotMap = true) on top of this\n+\t\t\t\t */\n+\t\t\t\tsetMoreSlots();\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] leafMap the leaf bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, uintptr_t *leafMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, leafMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uintptr_t)_mapPtr + _elementSizeWithoutPadding);\n+\t\t\t\tGC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);\n+\t\t\t\t/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. \n+\t\t\t\t * We must also return (hasNextSlotMap = true) on top of this\n+\t\t\t\t */\n+\t\t\t\tsetMoreSlots();\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+};\n+\n+#endif /* FLATTENEDARRAYOBJECTSCANNER_HPP_ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07755f7fa4775348a9c8eb58f8c9e59b0bf861fb"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2NTc4OQ==", "bodyText": "Fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/9074#discussion_r402465789", "createdAt": "2020-04-02T16:57:17Z", "author": {"login": "youngar"}, "path": "runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp", "diffHunk": "@@ -0,0 +1,255 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)\n+#define FLATTENEDARRAYOBJECTSCANNER_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+#include \"modron.h\"\n+\n+#include \"objectdescription.h\"\n+#include \"ArrayObjectModel.hpp\"\n+#include \"GCExtensionsBase.hpp\"\n+#include \"HeadlessMixedObjectScanner.hpp\"\n+#include \"IndexableObjectScanner.hpp\"\n+\n+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner\n+{\n+\t/* Data Members */\n+private:\n+\n+\tMM_EnvironmentBase *_env;\n+\tuintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */\n+\tuintptr_t *_descriptionBasePtr; /**< Pointer to the description base */\n+#if defined(OMR_GC_LEAF_BITS)\n+\tuintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\tGC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */\n+\n+protected:\n+\n+public:\n+\n+\t/* Methods */\n+private:\n+\n+protected:\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param arrayPtr pointer to the array to be processed\n+\t * @param basePtr pointer to the first contiguous array cell\n+\t * @param limitPtr pointer to end of last contiguous array cell\n+\t * @param scanPtr pointer to the array cell where scanning will start\n+\t * @param endPtr pointer to the array cell where scanning will stop\n+\t * @param scanMap The first scan map\n+\t * @param elementSize The size of each element, without padding\n+\t * @param elementStride The stride of each element, including element padding\n+\t * @param flags Scanning context flags\n+\t */\n+\tMMINLINE GC_FlattenedArrayObjectScanner(\n+\t\tMM_EnvironmentBase *env\n+\t\t, omrobjectptr_t arrayPtr\n+\t\t, fomrobject_t *basePtr\n+\t\t, fomrobject_t *limitPtr\n+\t\t, fomrobject_t *scanPtr\n+\t\t, fomrobject_t *endPtr\n+\t\t, uintptr_t elementSize\n+\t\t, uintptr_t elementStride\n+\t\t, uintptr_t *descriptionBasePtr\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\t, uintptr_t *leafBasePtr\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t\t, uintptr_t flags)\n+\t: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)\n+\t, _env(env)\n+\t, _elementSizeWithoutPadding(elementSize)\n+\t, _descriptionBasePtr(descriptionBasePtr)\n+#if defined(OMR_GC_LEAF_BITS)\n+\t, _leafBasePtr(leafBasePtr)\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\t/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */\n+\t, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)\n+\t{\n+\t\t_typeId = __FUNCTION__;\n+\t}\n+\n+\tMMINLINE void\n+\tinitialize(MM_EnvironmentBase *env)\n+\t{\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tGC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\t_indexableScanner.initialize(env);\n+\n+\t\t/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us\n+\t\t * to miss other elements of the array\n+\t\t */\n+\t\tsetMoreSlots();\n+\t}\n+\n+public:\n+\n+\t/**\n+\t * @param[in] env The scanning thread environment\n+\t * @param[in] objectPtr pointer to the array to be processed\n+\t * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param[in] flags Scanning context flags\n+\t * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements\n+\t * @param[in] startIndex The index of the first element to scan\n+\t */\n+\tMMINLINE static GC_FlattenedArrayObjectScanner *\n+\tnewInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)\n+\t{\n+\t\tGC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;\n+\t\tGC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);\n+\t\tJ9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);\n+\t\tJ9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;\n+\n+\t\t/* TODO are these always the same? */\n+\t\tAssert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);\n+\n+\t\tJ9Class *elementClass = j9ArrayClass->componentType;\n+\t\tomrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;\n+\t\t\n+\t\tuintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);\n+\t\tuintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);\n+\t\tuintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);\n+\t\tfomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);\n+\t\tfomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + (sizeInElements * elementStride));\n+\t\tfomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + (startIndex * elementStride));\n+\t\tfomrobject_t *endPtr = limitPtr;\n+\t\tif (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {\n+\t\t\tAssert_MM_unreachable();\n+\t\t\tendPtr = (fomrobject_t *)((uintptr_t)scanPtr + (splitAmount * elementStride));\n+\t\t\tif (endPtr > limitPtr) {\n+\t\t\t\tendPtr = limitPtr;\n+\t\t\t}\n+\t\t}\n+\t\tuintptr_t *instanceDescription = elementClass->instanceDescription;\n+#if defined(OMR_GC_LEAF_BITS)\n+\t\tuintptr_t *leafDescription = elementClass->instanceLeafDescription;\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);\n+#else /* defined(OMR_GC_LEAF_BITS) */\n+\t\tnew(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+\n+\t\tobjectScanner->initialize(env);\n+\t\tif (0 != startIndex) {\n+\t\t\tobjectScanner->clearHeadObjectScanner();\n+\t\t}\n+\t\treturn objectScanner;\n+\t}\n+\n+\tMMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }\n+\n+\t/**\n+\t * @param env The scanning thread environment\n+\t * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)\n+\t * @param splitAmount The maximum number of array elements to include\n+\t * @return Pointer to split scanner in allocSpace\n+\t */\n+\tGC_IndexableObjectScanner *\n+\tsplitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)\n+\t{\n+\t\tAssert_MM_unimplemented();\n+\t}\n+\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uintptr_t)_mapPtr + _elementSizeWithoutPadding);\n+\t\t\t\tGC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);\n+\t\t\t\t/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. \n+\t\t\t\t * We must also return (hasNextSlotMap = true) on top of this\n+\t\t\t\t */\n+\t\t\t\tsetMoreSlots();\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+#if defined(OMR_GC_LEAF_BITS)\n+\t/**\n+\t * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The\n+\t * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of\n+\t * increasing significance, and the least significant bit maps to the slot at the returned\n+\t * base pointer.\n+\t *\n+\t * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] leafMap the leaf bit map for the slots contiguous with the returned base pointer\n+\t * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last\n+\t * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots\n+\t */\n+\tvirtual fomrobject_t *\n+\tgetNextSlotMap(uintptr_t *slotMap, uintptr_t *leafMap, bool *hasNextSlotMap)\n+\t{\n+\t\tfomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, leafMap, hasNextSlotMap);\n+\t\t/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */\n+\t\t*hasNextSlotMap = true;\n+\t\tif (result == NULL) {\n+\t\t\t/* No more slots in the current element, get the next element of the array */\n+\t\t\tresult = _indexableScanner.nextIndexableElement();\n+\t\t\tif (result == NULL) {\n+\t\t\t\t/* There are no elements in the array */\n+\t\t\t\t*hasNextSlotMap = false;\n+\t\t\t} else {\n+\t\t\t\t_mapPtr = result;\n+\t\t\t\t_endPtr = (fomrobject_t *)((uintptr_t)_mapPtr + _elementSizeWithoutPadding);\n+\t\t\t\tGC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);\n+\t\t\t\t/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. \n+\t\t\t\t * We must also return (hasNextSlotMap = true) on top of this\n+\t\t\t\t */\n+\t\t\t\tsetMoreSlots();\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+#endif /* defined(OMR_GC_LEAF_BITS) */\n+};\n+\n+#endif /* FLATTENEDARRAYOBJECTSCANNER_HPP_ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxMzU1Mw=="}, "originalCommit": {"oid": "07755f7fa4775348a9c8eb58f8c9e59b0bf861fb"}, "originalPosition": 255}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 476, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}