{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MTgwMjcy", "number": 10926, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOToyMDoyOVrOEw6ODQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTo0NDoxOVrOEw6tPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzIwOTczOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOToyMDoyOVrOHmwYig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1OToxNlrOHnUBNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMDY1MA==", "bodyText": "Why not just change the type of this variable to be intptr_t and remove the casts below?", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510400650", "createdAt": "2020-10-22T19:20:29Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1653,3 +1653,67 @@ TR::S390VirtualUnresolvedReadOnlySnippet::getLength(int32_t estimatedSnippetStar\n            + sizeof(int32_t); /*RIP offset to post snippet call in mainline*/\n    }\n \n+uint8_t *\n+TR::S390InterfaceCallReadOnlySnippet::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   TR::Node *callNode = getNode();\n+\n+   TR::SymbolReference *interfaceCallReadOnlySymRef = cg()->symRefTab()->findOrCreateRuntimeHelper(TR_S390interfaceCallHelperMultiSlotsReadOnly,\n+                                                                                                               false, false, false);\n+   \n+   TR::GlobalFunctionCallData dataDestination(interfaceCallReadOnlySymRef, callNode, cursor, cg(), self());\n+\n+   cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n+\n+   uint8_t *helperCallRA = cursor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDUwMQ==", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/ab82c5d254e0315b3c65722371fda75cc1d79a10..3282a01df297676d33999fca192d2613b5db1b09", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510984501", "createdAt": "2020-10-23T15:59:16Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1653,3 +1653,67 @@ TR::S390VirtualUnresolvedReadOnlySnippet::getLength(int32_t estimatedSnippetStar\n            + sizeof(int32_t); /*RIP offset to post snippet call in mainline*/\n    }\n \n+uint8_t *\n+TR::S390InterfaceCallReadOnlySnippet::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   TR::Node *callNode = getNode();\n+\n+   TR::SymbolReference *interfaceCallReadOnlySymRef = cg()->symRefTab()->findOrCreateRuntimeHelper(TR_S390interfaceCallHelperMultiSlotsReadOnly,\n+                                                                                                               false, false, false);\n+   \n+   TR::GlobalFunctionCallData dataDestination(interfaceCallReadOnlySymRef, callNode, cursor, cg(), self());\n+\n+   cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n+\n+   uint8_t *helperCallRA = cursor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMDY1MA=="}, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzIxNzE3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOToyMjo0NVrOHmwdRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1OToyNFrOHnUBgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMTg2MA==", "bodyText": "void * vs void* inconsistent. Also need spaces between arithmetic + operators.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510401860", "createdAt": "2020-10-22T19:22:45Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1653,3 +1653,67 @@ TR::S390VirtualUnresolvedReadOnlySnippet::getLength(int32_t estimatedSnippetStar\n            + sizeof(int32_t); /*RIP offset to post snippet call in mainline*/\n    }\n \n+uint8_t *\n+TR::S390InterfaceCallReadOnlySnippet::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   TR::Node *callNode = getNode();\n+\n+   TR::SymbolReference *interfaceCallReadOnlySymRef = cg()->symRefTab()->findOrCreateRuntimeHelper(TR_S390interfaceCallHelperMultiSlotsReadOnly,\n+                                                                                                               false, false, false);\n+   \n+   TR::GlobalFunctionCallData dataDestination(interfaceCallReadOnlySymRef, callNode, cursor, cg(), self());\n+\n+   cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n+\n+   uint8_t *helperCallRA = cursor;\n+   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(interfaceCallPICSlotDataAddress), \"interfaceCallPICData %p is outside relative immediate range\", interfaceCallPICSlotDataAddress);\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(interfaceCallPICSlotDataAddress - (intptr_t)helperCallRA);\n+   cursor += sizeof(int32_t);\n+\n+   intptr_t doneLabelAddress = reinterpret_cast<intptr_t>(doneLabel->getCodeLocation());\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(doneLabelAddress - (intptr_t)helperCallRA);\n+   cursor += sizeof(int32_t);\n+\n+   return cursor;\n+   }\n+\n+void\n+TR_Debug::print(TR::FILE *pOutFile, TR::S390InterfaceCallReadOnlySnippet *snippet)\n+   {\n+   uint8_t *bufferPos = snippet->getSnippetLabel()->getCodeLocation();\n+   TR::SymbolReference *resolveVirtualDispatchReadOnlySymRef = _cg->getSymRef(TR_S390interfaceCallHelperMultiSlotsReadOnly);\n+\n+   TR::SymbolReference *methodSymRef = snippet->getNode()->getSymbolReference();\n+   // TODO: Need the address of the ccGlobalFunctionCallData   \n+   printSnippetLabel(pOutFile, snippet->getSnippetLabel(), bufferPos, \"Interface Call Snippet using Multi Slots\");\n+   printPrefix(pOutFile, NULL, bufferPos, 6);\n+   trfprintf(pOutFile, \"LGRL \\tGPR14, <%p>\\t# Load address of the Helper Method, targetAddress = <%p>\",\n+                    (void *)*(int32_t*)(bufferPos+sizeof(int16_t)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDU3OA==", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/ab82c5d254e0315b3c65722371fda75cc1d79a10..3282a01df297676d33999fca192d2613b5db1b09", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510984578", "createdAt": "2020-10-23T15:59:24Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/z/codegen/S390J9CallSnippet.cpp", "diffHunk": "@@ -1653,3 +1653,67 @@ TR::S390VirtualUnresolvedReadOnlySnippet::getLength(int32_t estimatedSnippetStar\n            + sizeof(int32_t); /*RIP offset to post snippet call in mainline*/\n    }\n \n+uint8_t *\n+TR::S390InterfaceCallReadOnlySnippet::emitSnippetBody()\n+   {\n+   uint8_t *cursor = cg()->getBinaryBufferCursor();\n+   getSnippetLabel()->setCodeLocation(cursor);\n+   TR::Node *callNode = getNode();\n+\n+   TR::SymbolReference *interfaceCallReadOnlySymRef = cg()->symRefTab()->findOrCreateRuntimeHelper(TR_S390interfaceCallHelperMultiSlotsReadOnly,\n+                                                                                                               false, false, false);\n+   \n+   TR::GlobalFunctionCallData dataDestination(interfaceCallReadOnlySymRef, callNode, cursor, cg(), self());\n+\n+   cursor = cg()->getObjFmt()->encodeGlobalFunctionCall(dataDestination);\n+\n+   uint8_t *helperCallRA = cursor;\n+   TR_ASSERT_FATAL(cg()->canUseRelativeLongInstructions(interfaceCallPICSlotDataAddress), \"interfaceCallPICData %p is outside relative immediate range\", interfaceCallPICSlotDataAddress);\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(interfaceCallPICSlotDataAddress - (intptr_t)helperCallRA);\n+   cursor += sizeof(int32_t);\n+\n+   intptr_t doneLabelAddress = reinterpret_cast<intptr_t>(doneLabel->getCodeLocation());\n+   *reinterpret_cast<int32_t*>(cursor) = static_cast<int32_t>(doneLabelAddress - (intptr_t)helperCallRA);\n+   cursor += sizeof(int32_t);\n+\n+   return cursor;\n+   }\n+\n+void\n+TR_Debug::print(TR::FILE *pOutFile, TR::S390InterfaceCallReadOnlySnippet *snippet)\n+   {\n+   uint8_t *bufferPos = snippet->getSnippetLabel()->getCodeLocation();\n+   TR::SymbolReference *resolveVirtualDispatchReadOnlySymRef = _cg->getSymRef(TR_S390interfaceCallHelperMultiSlotsReadOnly);\n+\n+   TR::SymbolReference *methodSymRef = snippet->getNode()->getSymbolReference();\n+   // TODO: Need the address of the ccGlobalFunctionCallData   \n+   printSnippetLabel(pOutFile, snippet->getSnippetLabel(), bufferPos, \"Interface Call Snippet using Multi Slots\");\n+   printPrefix(pOutFile, NULL, bufferPos, 6);\n+   trfprintf(pOutFile, \"LGRL \\tGPR14, <%p>\\t# Load address of the Helper Method, targetAddress = <%p>\",\n+                    (void *)*(int32_t*)(bufferPos+sizeof(int16_t)),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMTg2MA=="}, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzI0MzQ0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTozMDoyMVrOHmws9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxNzoxOFrOHnUqiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNTg3OQ==", "bodyText": "static_cast needed here.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510405879", "createdAt": "2020-10-22T19:30:21Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NTA4MQ==", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/ab82c5d254e0315b3c65722371fda75cc1d79a10..3282a01df297676d33999fca192d2613b5db1b09", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510995081", "createdAt": "2020-10-23T16:17:18Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNTg3OQ=="}, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzI0OTAzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTozMTo1OVrOHmwwdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzowMzoxOVrOHoZmYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNjc3NQ==", "bodyText": "Can we use a static const inside of ccInterfaceData to store the constant 3 and use it here instead? This seems quite error prone as the magic constant gets used several times in this function and we can replace it with a properly named and scoped constant that is defined right in the struct.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510406775", "createdAt": "2020-10-22T19:31:59Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4Mzc3MA==", "bodyText": "static const field is allocated once for the entire DLL, not per call site. It is a static variable after all. It will not incur any difference to sizeof(ccInterfaceData).", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r512083770", "createdAt": "2020-10-26T16:11:17Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNjc3NQ=="}, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyNDUxMw==", "bodyText": "Sorry, over sighted the suggestion and forgot we can have static members inside struct in C++. Added the static const inside the ccInterfaceData struct to reflect number of PIC slots, https://github.com/eclipse/openj9/compare/e2eb175cf4e392b9a013648129c1209bc1790bc8..7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r512124513", "createdAt": "2020-10-26T17:03:19Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNjc3NQ=="}, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzI2MTg3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTozNjoxMVrOHmw4sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxODo1OFrOHnUuQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwODg4MQ==", "bodyText": "Why is this needed?", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510408881", "createdAt": "2020-10-22T19:36:11Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));\n+   ccInterfaceDataAddress->isCacheFull = 0;\n+\n+   // Now we are checking each slot and dispatching methods. \n+   intptr_t interfaceDataAddress = reinterpret_cast<intptr_t>(ccInterfaceDataAddress);\n+\n+   TR::StaticSymbol *interfaceDataSymbol =\n+      TR::StaticSymbol::createWithAddress(trHeapMemory(), TR::Address, reinterpret_cast<void *>(interfaceDataAddress));\n+   interfaceDataSymbol->setNotDataAddress();\n+   TR::SymbolReference *interfaceDataSymRef = new (trHeapMemory()) TR::SymbolReference(cg()->comp()->getSymRefTab(), interfaceDataSymbol, 0);\n+\n+   /**\n+    * LARL  regEP, interfaceDataAddress\n+    * LARL  regRA, returnAddress\n+    * Label StartICF: (Attaching predependency conditions here.\n+    * LPQ   Class,MethodAddress, 0(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,MethodAddress\n+    * LPQ   Class,MethodAddress, 16(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * LPQ   Class,MethodAddress, 32(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * Label SnippetCal: (Cache miss, will be calling the snippet)\n+    * BRCL  interfaceCallSnippet\n+    * Label doneLabel: (Attaching Post Deps Here)\n+    */\n+   int32_t numberOfAdditionalPostDeps = 3; // For load pair instruction, we need 3 virtual registers, even reg, odd reg, even-odd pair\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Instruction *cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regEP, interfaceDataSymRef, interfaceDataSymbol->getStaticAddress());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regRA, doneLabel, cursor);\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                         dependencies->getAddCursorForPre(), 0, cg());\n+   \n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numberOfAdditionalPostDeps, cg());\n+   // Removing the pre dependencies from the postDeps\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjAzNA==", "bodyText": "It is actually not needed, I wanted to just extract the post deps from the original dependencies and add room for extra deps I need in this function. There is a better way to achieve that and I have made change in https://github.com/eclipse/openj9/compare/3282a01df297676d33999fca192d2613b5db1b09..d1f154c59f4e002f94b5e613001eb016a95a6927", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510996034", "createdAt": "2020-10-23T16:18:58Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));\n+   ccInterfaceDataAddress->isCacheFull = 0;\n+\n+   // Now we are checking each slot and dispatching methods. \n+   intptr_t interfaceDataAddress = reinterpret_cast<intptr_t>(ccInterfaceDataAddress);\n+\n+   TR::StaticSymbol *interfaceDataSymbol =\n+      TR::StaticSymbol::createWithAddress(trHeapMemory(), TR::Address, reinterpret_cast<void *>(interfaceDataAddress));\n+   interfaceDataSymbol->setNotDataAddress();\n+   TR::SymbolReference *interfaceDataSymRef = new (trHeapMemory()) TR::SymbolReference(cg()->comp()->getSymRefTab(), interfaceDataSymbol, 0);\n+\n+   /**\n+    * LARL  regEP, interfaceDataAddress\n+    * LARL  regRA, returnAddress\n+    * Label StartICF: (Attaching predependency conditions here.\n+    * LPQ   Class,MethodAddress, 0(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,MethodAddress\n+    * LPQ   Class,MethodAddress, 16(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * LPQ   Class,MethodAddress, 32(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * Label SnippetCal: (Cache miss, will be calling the snippet)\n+    * BRCL  interfaceCallSnippet\n+    * Label doneLabel: (Attaching Post Deps Here)\n+    */\n+   int32_t numberOfAdditionalPostDeps = 3; // For load pair instruction, we need 3 virtual registers, even reg, odd reg, even-odd pair\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Instruction *cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regEP, interfaceDataSymRef, interfaceDataSymbol->getStaticAddress());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regRA, doneLabel, cursor);\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                         dependencies->getAddCursorForPre(), 0, cg());\n+   \n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numberOfAdditionalPostDeps, cg());\n+   // Removing the pre dependencies from the postDeps\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwODg4MQ=="}, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzI3Njg1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTo0MDoyNVrOHmxB0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjo1NTo1NFrOHoZSEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTIxNg==", "bodyText": "Why is the NOP needed?", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510411216", "createdAt": "2020-10-22T19:40:25Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));\n+   ccInterfaceDataAddress->isCacheFull = 0;\n+\n+   // Now we are checking each slot and dispatching methods. \n+   intptr_t interfaceDataAddress = reinterpret_cast<intptr_t>(ccInterfaceDataAddress);\n+\n+   TR::StaticSymbol *interfaceDataSymbol =\n+      TR::StaticSymbol::createWithAddress(trHeapMemory(), TR::Address, reinterpret_cast<void *>(interfaceDataAddress));\n+   interfaceDataSymbol->setNotDataAddress();\n+   TR::SymbolReference *interfaceDataSymRef = new (trHeapMemory()) TR::SymbolReference(cg()->comp()->getSymRefTab(), interfaceDataSymbol, 0);\n+\n+   /**\n+    * LARL  regEP, interfaceDataAddress\n+    * LARL  regRA, returnAddress\n+    * Label StartICF: (Attaching predependency conditions here.\n+    * LPQ   Class,MethodAddress, 0(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,MethodAddress\n+    * LPQ   Class,MethodAddress, 16(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * LPQ   Class,MethodAddress, 32(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * Label SnippetCal: (Cache miss, will be calling the snippet)\n+    * BRCL  interfaceCallSnippet\n+    * Label doneLabel: (Attaching Post Deps Here)\n+    */\n+   int32_t numberOfAdditionalPostDeps = 3; // For load pair instruction, we need 3 virtual registers, even reg, odd reg, even-odd pair\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Instruction *cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regEP, interfaceDataSymRef, interfaceDataSymbol->getStaticAddress());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regRA, doneLabel, cursor);\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                         dependencies->getAddCursorForPre(), 0, cg());\n+   \n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numberOfAdditionalPostDeps, cg());\n+   // Removing the pre dependencies from the postDeps\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg());\n+   cursor = generateS390LabelInstruction(cg(), TR::InstOpCode::LABEL, callNode, cFlowRegionStart, preDeps, cursor);\n+\n+   TR::Register      *slotClassReg = cg()->allocateRegister();\n+   TR::Register      *slotMethodAddressReg = cg()->allocateRegister();\n+   TR::RegisterPair  *slotClassMethodRegPair = cg()->allocateConsecutiveRegisterPair(slotMethodAddressReg, slotClassReg);\n+   postDeps->addPostCondition(slotClassReg, TR::RealRegister::LegalEvenOfPair);\n+   postDeps->addPostCondition(slotMethodAddressReg, TR::RealRegister::LegalOddOfPair);\n+   postDeps->addPostCondition(slotClassMethodRegPair, TR::RealRegister::EvenOddPair);\n+   postDeps->addPostConditionIfNotAlreadyInserted(vftReg, TR::RealRegister::AssignAny);\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot1Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot2Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot3Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   TR::LabelSymbol *interfaceCallHelperSnippetLabel = generateLabelSymbol(cg());\n+   TR::S390InterfaceCallReadOnlySnippet *snippet = new (trHeapMemory()) TR::S390InterfaceCallReadOnlySnippet(\n+      cg(),\n+      callNode,\n+      interfaceCallHelperSnippetLabel,\n+      doneLabel,\n+      interfaceDataAddress);\n+   // Cache miss, going to slow path to lookup the interface method.\n+   cursor = new (trHeapMemory()) TR::S390RILInstruction(TR::InstOpCode::BRCL, callNode, 0xF, snippet, NULL, cg());\n+   cursor = new (trHeapMemory()) TR::S390NOPInstruction(TR::InstOpCode::NOP, 2, callNode, cg()); ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5ODY2NA==", "bodyText": "According to comment in https://github.com/eclipse/openj9/blob/67d8cf0cd31d5215756678a1cd434fc04af98055/runtime/compiler/z/codegen/S390PrivateLinkage.cpp#L2189 It is needed for the patchupVirtualCall, I feel it needs more clear documentation then that. I remember, while testing when I commented out the NOP it was failing the tests, let me find-out the exact call path that that requires this NOP.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510998664", "createdAt": "2020-10-23T16:23:38Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));\n+   ccInterfaceDataAddress->isCacheFull = 0;\n+\n+   // Now we are checking each slot and dispatching methods. \n+   intptr_t interfaceDataAddress = reinterpret_cast<intptr_t>(ccInterfaceDataAddress);\n+\n+   TR::StaticSymbol *interfaceDataSymbol =\n+      TR::StaticSymbol::createWithAddress(trHeapMemory(), TR::Address, reinterpret_cast<void *>(interfaceDataAddress));\n+   interfaceDataSymbol->setNotDataAddress();\n+   TR::SymbolReference *interfaceDataSymRef = new (trHeapMemory()) TR::SymbolReference(cg()->comp()->getSymRefTab(), interfaceDataSymbol, 0);\n+\n+   /**\n+    * LARL  regEP, interfaceDataAddress\n+    * LARL  regRA, returnAddress\n+    * Label StartICF: (Attaching predependency conditions here.\n+    * LPQ   Class,MethodAddress, 0(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,MethodAddress\n+    * LPQ   Class,MethodAddress, 16(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * LPQ   Class,MethodAddress, 32(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * Label SnippetCal: (Cache miss, will be calling the snippet)\n+    * BRCL  interfaceCallSnippet\n+    * Label doneLabel: (Attaching Post Deps Here)\n+    */\n+   int32_t numberOfAdditionalPostDeps = 3; // For load pair instruction, we need 3 virtual registers, even reg, odd reg, even-odd pair\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Instruction *cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regEP, interfaceDataSymRef, interfaceDataSymbol->getStaticAddress());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regRA, doneLabel, cursor);\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                         dependencies->getAddCursorForPre(), 0, cg());\n+   \n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numberOfAdditionalPostDeps, cg());\n+   // Removing the pre dependencies from the postDeps\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg());\n+   cursor = generateS390LabelInstruction(cg(), TR::InstOpCode::LABEL, callNode, cFlowRegionStart, preDeps, cursor);\n+\n+   TR::Register      *slotClassReg = cg()->allocateRegister();\n+   TR::Register      *slotMethodAddressReg = cg()->allocateRegister();\n+   TR::RegisterPair  *slotClassMethodRegPair = cg()->allocateConsecutiveRegisterPair(slotMethodAddressReg, slotClassReg);\n+   postDeps->addPostCondition(slotClassReg, TR::RealRegister::LegalEvenOfPair);\n+   postDeps->addPostCondition(slotMethodAddressReg, TR::RealRegister::LegalOddOfPair);\n+   postDeps->addPostCondition(slotClassMethodRegPair, TR::RealRegister::EvenOddPair);\n+   postDeps->addPostConditionIfNotAlreadyInserted(vftReg, TR::RealRegister::AssignAny);\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot1Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot2Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot3Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   TR::LabelSymbol *interfaceCallHelperSnippetLabel = generateLabelSymbol(cg());\n+   TR::S390InterfaceCallReadOnlySnippet *snippet = new (trHeapMemory()) TR::S390InterfaceCallReadOnlySnippet(\n+      cg(),\n+      callNode,\n+      interfaceCallHelperSnippetLabel,\n+      doneLabel,\n+      interfaceDataAddress);\n+   // Cache miss, going to slow path to lookup the interface method.\n+   cursor = new (trHeapMemory()) TR::S390RILInstruction(TR::InstOpCode::BRCL, callNode, 0xF, snippet, NULL, cg());\n+   cursor = new (trHeapMemory()) TR::S390NOPInstruction(TR::InstOpCode::NOP, 2, callNode, cg()); ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTIxNg=="}, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NTAyMg==", "bodyText": "Ok, we should put the same comment here as exists in the JVM path linked above. I could definitely see someone not knowing anything about this coming down and removing the NOP thinking it shouldn't exist.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r512085022", "createdAt": "2020-10-26T16:13:10Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));\n+   ccInterfaceDataAddress->isCacheFull = 0;\n+\n+   // Now we are checking each slot and dispatching methods. \n+   intptr_t interfaceDataAddress = reinterpret_cast<intptr_t>(ccInterfaceDataAddress);\n+\n+   TR::StaticSymbol *interfaceDataSymbol =\n+      TR::StaticSymbol::createWithAddress(trHeapMemory(), TR::Address, reinterpret_cast<void *>(interfaceDataAddress));\n+   interfaceDataSymbol->setNotDataAddress();\n+   TR::SymbolReference *interfaceDataSymRef = new (trHeapMemory()) TR::SymbolReference(cg()->comp()->getSymRefTab(), interfaceDataSymbol, 0);\n+\n+   /**\n+    * LARL  regEP, interfaceDataAddress\n+    * LARL  regRA, returnAddress\n+    * Label StartICF: (Attaching predependency conditions here.\n+    * LPQ   Class,MethodAddress, 0(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,MethodAddress\n+    * LPQ   Class,MethodAddress, 16(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * LPQ   Class,MethodAddress, 32(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * Label SnippetCal: (Cache miss, will be calling the snippet)\n+    * BRCL  interfaceCallSnippet\n+    * Label doneLabel: (Attaching Post Deps Here)\n+    */\n+   int32_t numberOfAdditionalPostDeps = 3; // For load pair instruction, we need 3 virtual registers, even reg, odd reg, even-odd pair\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Instruction *cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regEP, interfaceDataSymRef, interfaceDataSymbol->getStaticAddress());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regRA, doneLabel, cursor);\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                         dependencies->getAddCursorForPre(), 0, cg());\n+   \n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numberOfAdditionalPostDeps, cg());\n+   // Removing the pre dependencies from the postDeps\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg());\n+   cursor = generateS390LabelInstruction(cg(), TR::InstOpCode::LABEL, callNode, cFlowRegionStart, preDeps, cursor);\n+\n+   TR::Register      *slotClassReg = cg()->allocateRegister();\n+   TR::Register      *slotMethodAddressReg = cg()->allocateRegister();\n+   TR::RegisterPair  *slotClassMethodRegPair = cg()->allocateConsecutiveRegisterPair(slotMethodAddressReg, slotClassReg);\n+   postDeps->addPostCondition(slotClassReg, TR::RealRegister::LegalEvenOfPair);\n+   postDeps->addPostCondition(slotMethodAddressReg, TR::RealRegister::LegalOddOfPair);\n+   postDeps->addPostCondition(slotClassMethodRegPair, TR::RealRegister::EvenOddPair);\n+   postDeps->addPostConditionIfNotAlreadyInserted(vftReg, TR::RealRegister::AssignAny);\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot1Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot2Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot3Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   TR::LabelSymbol *interfaceCallHelperSnippetLabel = generateLabelSymbol(cg());\n+   TR::S390InterfaceCallReadOnlySnippet *snippet = new (trHeapMemory()) TR::S390InterfaceCallReadOnlySnippet(\n+      cg(),\n+      callNode,\n+      interfaceCallHelperSnippetLabel,\n+      doneLabel,\n+      interfaceDataAddress);\n+   // Cache miss, going to slow path to lookup the interface method.\n+   cursor = new (trHeapMemory()) TR::S390RILInstruction(TR::InstOpCode::BRCL, callNode, 0xF, snippet, NULL, cg());\n+   cursor = new (trHeapMemory()) TR::S390NOPInstruction(TR::InstOpCode::NOP, 2, callNode, cg()); ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTIxNg=="}, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjExOTMxNA==", "bodyText": "I have copied the same comment in https://github.com/eclipse/openj9/compare/e2eb175cf4e392b9a013648129c1209bc1790bc8..7e34301ef20a2e2b9b78a0d987f8c0e5eb801d0c\nCurrently checking the path that needs this NOP, will modify if I find something useful.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r512119314", "createdAt": "2020-10-26T16:55:54Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/z/codegen/S390PrivateLinkage.cpp", "diffHunk": "@@ -1649,6 +1659,140 @@ J9::Z::PrivateLinkage::buildNoPatchingVirtualDispatchWithResolve(TR::Node *callN\n    return cursor;\n    }\n \n+TR::Instruction *\n+J9::Z::PrivateLinkage::buildNoPatchingIPIC(TR::Node *callNode, TR::RegisterDependencyConditions *dependencies, TR::Register *vftReg, intptr_t virtualThunk)\n+   {\n+   /**\n+    * TODO: Right now this function generates all the instruction as we are\n+    * fixing the number of PIC slots whereas we can change number of slots at compile\n+    * time for regular JIT compiled code. It is not that complicated to do that for\n+    * readOnlyCode.\n+    * We can create a different data structure to hold the J9Class and method address\n+    * size of which can be fixed at compilation time and use that.\n+    */\n+   OMR::CCData *codeCacheData = cg()->getCodeCache()->manager()->getCodeCacheData();\n+   OMR::CCData::index_t index;\n+\n+   if (!(codeCacheData->put(NULL, sizeof(ccInterfaceData), 16, NULL, index)))\n+      {\n+      cg()->comp()->failCompilation<TR::CompilationException>(\"Could not allocate interface dispatch metadata\");\n+      }\n+   ccInterfaceData *ccInterfaceDataAddress = codeCacheData->get<ccInterfaceData>(index);\n+\n+   // Intialization of CCData\n+   ccInterfaceDataAddress->slot1Class  = 0;\n+   ccInterfaceDataAddress->slot1Method = 0;\n+   ccInterfaceDataAddress->slot2Class  = 0;\n+   ccInterfaceDataAddress->slot2Method = 0;\n+   ccInterfaceDataAddress->slot3Class  = 0;\n+   ccInterfaceDataAddress->slot3Method = 0;\n+\n+   ccInterfaceDataAddress->cpAddress = reinterpret_cast<intptr_t>(callNode->getSymbolReference()->getOwningMethod(cg()->comp())->constantPool());\n+   ccInterfaceDataAddress->cpIndex = (intptr_t) callNode->getSymbolReference()->getCPIndexForVM();\n+   ccInterfaceDataAddress->interfaceClass = 0;\n+   ccInterfaceDataAddress->iTableIndex = 0;\n+   ccInterfaceDataAddress->j2iThunkAddress = virtualThunk;\n+   ccInterfaceDataAddress->totalSizeOfPicSlots = (3 /*Total Number of PICSlots*/ * sizeof(ccInterfaceDataAddress->slot1Class)) + (3 * sizeof(ccInterfaceDataAddress->slot1Method));\n+   ccInterfaceDataAddress->isCacheFull = 0;\n+\n+   // Now we are checking each slot and dispatching methods. \n+   intptr_t interfaceDataAddress = reinterpret_cast<intptr_t>(ccInterfaceDataAddress);\n+\n+   TR::StaticSymbol *interfaceDataSymbol =\n+      TR::StaticSymbol::createWithAddress(trHeapMemory(), TR::Address, reinterpret_cast<void *>(interfaceDataAddress));\n+   interfaceDataSymbol->setNotDataAddress();\n+   TR::SymbolReference *interfaceDataSymRef = new (trHeapMemory()) TR::SymbolReference(cg()->comp()->getSymRefTab(), interfaceDataSymbol, 0);\n+\n+   /**\n+    * LARL  regEP, interfaceDataAddress\n+    * LARL  regRA, returnAddress\n+    * Label StartICF: (Attaching predependency conditions here.\n+    * LPQ   Class,MethodAddress, 0(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,MethodAddress\n+    * LPQ   Class,MethodAddress, 16(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * LPQ   Class,MethodAddress, 32(interfaceDataReg)\n+    * CGR   Class,vftReg\n+    * BCR   Equal,methodAddress\n+    * Label SnippetCal: (Cache miss, will be calling the snippet)\n+    * BRCL  interfaceCallSnippet\n+    * Label doneLabel: (Attaching Post Deps Here)\n+    */\n+   int32_t numberOfAdditionalPostDeps = 3; // For load pair instruction, we need 3 virtual registers, even reg, odd reg, even-odd pair\n+   TR::Register *regRA = dependencies->searchPostConditionRegister(getReturnAddressRegister());\n+   if (regRA == NULL)\n+      {\n+      regRA = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+   TR::Register *regEP = dependencies->searchPostConditionRegister(getEntryPointRegister());\n+   if (regEP == NULL)\n+      {\n+      regEP = cg()->allocateRegister();\n+      numberOfAdditionalPostDeps+=1;\n+      }\n+\n+   TR::Instruction *cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regEP, interfaceDataSymRef, interfaceDataSymbol->getStaticAddress());\n+   TR::LabelSymbol *doneLabel = generateLabelSymbol(cg());\n+   cursor = generateRILInstruction(cg(), TR::InstOpCode::LARL, callNode, regRA, doneLabel, cursor);\n+\n+   TR::RegisterDependencyConditions *preDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies->getPreConditions(), NULL,\n+                                                                                                         dependencies->getAddCursorForPre(), 0, cg());\n+   \n+   TR::RegisterDependencyConditions *postDeps = new (trHeapMemory()) TR::RegisterDependencyConditions(dependencies, 0, numberOfAdditionalPostDeps, cg());\n+   // Removing the pre dependencies from the postDeps\n+   postDeps->setAddCursorForPre(0);\n+   postDeps->setNumPreConditions(0, trMemory());\n+   TR::LabelSymbol *cFlowRegionStart = generateLabelSymbol(cg());\n+   cursor = generateS390LabelInstruction(cg(), TR::InstOpCode::LABEL, callNode, cFlowRegionStart, preDeps, cursor);\n+\n+   TR::Register      *slotClassReg = cg()->allocateRegister();\n+   TR::Register      *slotMethodAddressReg = cg()->allocateRegister();\n+   TR::RegisterPair  *slotClassMethodRegPair = cg()->allocateConsecutiveRegisterPair(slotMethodAddressReg, slotClassReg);\n+   postDeps->addPostCondition(slotClassReg, TR::RealRegister::LegalEvenOfPair);\n+   postDeps->addPostCondition(slotMethodAddressReg, TR::RealRegister::LegalOddOfPair);\n+   postDeps->addPostCondition(slotClassMethodRegPair, TR::RealRegister::EvenOddPair);\n+   postDeps->addPostConditionIfNotAlreadyInserted(vftReg, TR::RealRegister::AssignAny);\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot1Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+\n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot2Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   cursor = generateRXInstruction(cg(), TR::InstOpCode::LPQ, callNode, slotClassMethodRegPair,\n+                                    generateS390MemoryReference(regEP, offsetof(ccInterfaceData, slot3Class), cg()), cursor);\n+   cursor = generateRRInstruction(cg(), TR::InstOpCode::CGR, callNode, slotClassReg, vftReg, cursor);\n+   cursor =generateS390BranchInstruction(cg(), TR::InstOpCode::BCR, callNode, TR::InstOpCode::COND_BE, slotMethodAddressReg, cursor);\n+   \n+   TR::LabelSymbol *interfaceCallHelperSnippetLabel = generateLabelSymbol(cg());\n+   TR::S390InterfaceCallReadOnlySnippet *snippet = new (trHeapMemory()) TR::S390InterfaceCallReadOnlySnippet(\n+      cg(),\n+      callNode,\n+      interfaceCallHelperSnippetLabel,\n+      doneLabel,\n+      interfaceDataAddress);\n+   // Cache miss, going to slow path to lookup the interface method.\n+   cursor = new (trHeapMemory()) TR::S390RILInstruction(TR::InstOpCode::BRCL, callNode, 0xF, snippet, NULL, cg());\n+   cursor = new (trHeapMemory()) TR::S390NOPInstruction(TR::InstOpCode::NOP, 2, callNode, cg()); ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTIxNg=="}, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzI4OTU5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/z/runtime/PicBuilder.m4", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTo0NDoxOVrOHmxJxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxOToyMlrOHnUvQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMzI1NA==", "bodyText": "We should try to keep the names of these the same as the fields for easier searchability. For example searching for \"totalSizeOfPicSlots\" will not get a hit here.", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510413254", "createdAt": "2020-10-22T19:44:19Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/runtime/PicBuilder.m4", "diffHunk": "@@ -155,6 +155,24 @@ SETVAL(eq_returnAddressDirectMethod,8)\n SETVAL(eq_resolveVirtualJitEIPForHelperCall,12)\n SETVAL(eq_ResolveVirtualData_RIP,0)\n \n+ZZ Interface Call Helper Read Only Layout\n+SETVAL(eq_InterfaceCallHelperReadOnly_Data,0)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot1,0)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot1,8)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot2,16)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot2,24)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot3,32)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot3,40)\n+SETVAL(eq_InterfaceCallHelper_cpAddress,48)\n+SETVAL(eq_InterfaceCallHelper_cpIndex,56)\n+SETVAL(eq_InterfaceCallHelper_interfaceClass,64)\n+SETVAL(eq_InterfaceCallHelper_methodIndex,72)\n+SETVAL(eq_InterfaceCallHelperTotalPICSlotSize,88)\n+SETVAL(eq_InterfaceCallHelper_isCacheFullFlag,96)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjI5MA==", "bodyText": "Fixed in https://github.com/eclipse/openj9/compare/ab82c5d254e0315b3c65722371fda75cc1d79a10..3282a01df297676d33999fca192d2613b5db1b09", "url": "https://github.com/eclipse-openj9/openj9/pull/10926#discussion_r510996290", "createdAt": "2020-10-23T16:19:22Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/z/runtime/PicBuilder.m4", "diffHunk": "@@ -155,6 +155,24 @@ SETVAL(eq_returnAddressDirectMethod,8)\n SETVAL(eq_resolveVirtualJitEIPForHelperCall,12)\n SETVAL(eq_ResolveVirtualData_RIP,0)\n \n+ZZ Interface Call Helper Read Only Layout\n+SETVAL(eq_InterfaceCallHelperReadOnly_Data,0)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot1,0)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot1,8)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot2,16)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot2,24)\n+SETVAL(eq_InterfaceCallHelperClassPICSlot3,32)\n+SETVAL(eq_InterfaceCallHelperMethodPICSlot3,40)\n+SETVAL(eq_InterfaceCallHelper_cpAddress,48)\n+SETVAL(eq_InterfaceCallHelper_cpIndex,56)\n+SETVAL(eq_InterfaceCallHelper_interfaceClass,64)\n+SETVAL(eq_InterfaceCallHelper_methodIndex,72)\n+SETVAL(eq_InterfaceCallHelperTotalPICSlotSize,88)\n+SETVAL(eq_InterfaceCallHelper_isCacheFullFlag,96)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMzI1NA=="}, "originalCommit": {"oid": "ab82c5d254e0315b3c65722371fda75cc1d79a10"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1179, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}