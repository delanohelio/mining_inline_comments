{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NDk5MDA4", "number": 8761, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMjozMzo1OVrODnDk5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjozNDo1NFrODoT9ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMjc5NjU0OnYy", "diffSide": "RIGHT", "path": "runtime/bcutil/cfreader.c", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMjozMzo1OVrOF00_FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNzoxNzowOVrOF1A3fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzODM4OQ==", "bodyText": "What about the case where length == 1?  The code checks for > 1 here and handles 0 == length below - what happens to length == 1?", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390938389", "createdAt": "2020-03-11T12:33:59Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -418,33 +418,51 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t}\n \n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->annotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n \n-\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n-\t\t\t{\n-\t\t\t\treturn BCT_ERR_OUT_OF_ROM;\n-\t\t\t}\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * Don't read a bogus numberOfAnnotations.\n+\t\t\t */\n+\t\t\tif (length > 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzMzA1Mw==", "bodyText": "Since a length of 1 is not long enough to have a valid numberOfAnnotations I wanted to skip the sections where numberOfAnnotations is set. Since this 1 byte is not being read the annotation will enter the error handling code since (index != end).\nI will add some additional comments to make this clear.", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r391133053", "createdAt": "2020-03-11T17:17:09Z", "author": {"login": "theresa-m"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -418,33 +418,51 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t}\n \n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->annotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n \n-\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n-\t\t\t{\n-\t\t\t\treturn BCT_ERR_OUT_OF_ROM;\n-\t\t\t}\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * Don't read a bogus numberOfAnnotations.\n+\t\t\t */\n+\t\t\tif (length > 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzODM4OQ=="}, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMjc5Nzg0OnYy", "diffSide": "RIGHT", "path": "runtime/bcutil/cfreader.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMjozNDoyNlrOF00_8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMjozNDoyNlrOF00_8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzODYwOA==", "bodyText": "nitpick\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n          \n          \n            \n            \t\t\t\t{\n          \n          \n            \n            \t\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation)) {", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390938608", "createdAt": "2020-03-11T12:34:26Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -418,33 +418,51 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t}\n \n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->annotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n \n-\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n-\t\t\t{\n-\t\t\t\treturn BCT_ERR_OUT_OF_ROM;\n-\t\t\t}\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * Don't read a bogus numberOfAnnotations.\n+\t\t\t */\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n \n-\t\t\tresult = readAnnotations(classfile, annotations->annotations, annotations->numberOfAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->annotations, annotations->numberOfAnnotations, J9CfrAnnotation))\n+\t\t\t\t{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMjg1MTY3OnYy", "diffSide": "RIGHT", "path": "runtime/bcutil/cfreader.c", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMjo1MDozNlrOF01hAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNzozNDozMlrOF1Bm2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0NzA3Mw==", "bodyText": "the lengths of 4 & 3 here aren't immediately obvious to me.  Is it the size of a the visible annotation + 1?", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390947073", "createdAt": "2020-03-11T12:50:36Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE0NTE3Nw==", "bodyText": "num_annotations (2 bytes)\ntarget_type (1 byte)\nfollowed by any additional raw data.\n\nThe 4 length is the size of the illegal annotation + 1. The minimum required to create the annotation is 3.", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r391145177", "createdAt": "2020-03-11T17:34:32Z", "author": {"login": "theresa-m"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0NzA3Mw=="}, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMjg4NDIyOnYy", "diffSide": "RIGHT", "path": "runtime/bcutil/cfreader.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzowMDoyNFrOF011Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzowMDoyNFrOF011Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MjI2Ng==", "bodyText": "It might be clearer to have a minimum number of byes required and take the max(min_required_bytes, length + 1)", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390952266", "createdAt": "2020-03-11T13:00:24Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* Extra slot for illegal target_type */\n+\t\t\t\t\tannotations->rawDataLength = length + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMjg4NjU4OnYy", "diffSide": "RIGHT", "path": "runtime/bcutil/cfreader.c", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzowMTowMlrOF012rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxODoxNDoyM1rOF1DHwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MjYyMg==", "bodyText": "Why = 1 here?", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r390952622", "createdAt": "2020-03-11T13:01:02Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* Extra slot for illegal target_type */\n+\t\t\t\t\tannotations->rawDataLength = length + 1;\n+\t\t\t\t}\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE1ODMxNg==", "bodyText": "The 1 is there to show that there is 1 type_annotation here for the illegal annotation being created.", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r391158316", "createdAt": "2020-03-11T17:54:45Z", "author": {"login": "theresa-m"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* Extra slot for illegal target_type */\n+\t\t\t\t\tannotations->rawDataLength = length + 1;\n+\t\t\t\t}\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MjYyMg=="}, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE2OTk4NQ==", "bodyText": "I will add some additional comments to all of this.", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r391169985", "createdAt": "2020-03-11T18:14:23Z", "author": {"login": "theresa-m"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -655,24 +681,55 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* calculate the length needed to insert the illegal type_annotation.\n+\t\t\t\t * The minimum number of bytes needed is three for\n+\t\t\t\t * num_annotations and target_type\n+\t\t\t\t */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\t/* Treat one byte as part of the type_annotation to reach the correct index. */\n+\t\t\t\t\tannotations->rawDataLength = 4;\n+\t\t\t\t} else if (length < 3) {\n+\t\t\t\t\tannotations->rawDataLength = 3;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* Extra slot for illegal target_type */\n+\t\t\t\t\tannotations->rawDataLength = length + 1;\n+\t\t\t\t}\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MjYyMg=="}, "originalCommit": {"oid": "36f52759cc5d2ccf9343e8eb9ea171f67fd0ee2a"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMTI2ODI2OnYy", "diffSide": "RIGHT", "path": "runtime/bcutil/cfreader.c", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNDo1ODo1MFrOF2G6rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNTowMTozNFrOF2HBIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MDc1MA==", "bodyText": "Is this special case needed?  rawDataLength will be max(3, length+1).\nIf length is 1, then rawDataLength would be 3.  Does the minimumRawDataBytes need to be 4 to cover the +1 here?", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392280750", "createdAt": "2020-03-13T14:58:50Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,102 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n \t\t\t\t * give up parsing.\n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n \t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n+\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t/* The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 3;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* use at least the minimum number of bytes, or add an extra slot for the illegal target_type */\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\t/* special case for length = 1. To ensure index is incremented correctly, \n+\t\t\t\t * add this extra byte to the end of the raw data array. */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\tannotations->rawDataLength++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6d3c25f5bc44314c577ebba23e70389f07c7c4e"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MjQwMA==", "bodyText": "Reading the code below that writes to annotations->rawAttributeData[3] = 0;, min length here needs to be 4, not 3", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392282400", "createdAt": "2020-03-13T15:01:34Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,102 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n \t\t\t\t * give up parsing.\n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n \t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n+\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t/* The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 3;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* use at least the minimum number of bytes, or add an extra slot for the illegal target_type */\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\t/* special case for length = 1. To ensure index is incremented correctly, \n+\t\t\t\t * add this extra byte to the end of the raw data array. */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\tannotations->rawDataLength++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MDc1MA=="}, "originalCommit": {"oid": "f6d3c25f5bc44314c577ebba23e70389f07c7c4e"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMTI4NDAyOnYy", "diffSide": "RIGHT", "path": "runtime/bcutil/cfreader.c", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNTowMzowMFrOF2HEyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNTowMzowMFrOF2HEyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MzMzNw==", "bodyText": "This is the case I'm most unsure of.  Maybe an example would help here? Or an assert that rawDataLength > 4, assuming that's the right condition", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392283337", "createdAt": "2020-03-13T15:03:00Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,102 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n \t\t\t\t * give up parsing.\n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n \t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n \t\t\t\t * to indicate that the attribute is malformed.\n \t\t\t\t */\n+\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t/* The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 3;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\t/* use at least the minimum number of bytes, or add an extra slot for the illegal target_type */\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\t/* special case for length = 1. To ensure index is incremented correctly, \n+\t\t\t\t * add this extra byte to the end of the raw data array. */\n+\t\t\t\tif (1 == length) {\n+\t\t\t\t\tannotations->rawDataLength++;\n+\t\t\t\t}\n+\n+\t\t\t\t/* create raw data array. */\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* set illegal target_type followed by raw data */\n+\t\t\t\tif (minimumRawDataBytes == annotations->rawDataLength) { /* final slot is reserved for illegal target_type */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t} else {\n+\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n+\n+\t\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n+\t\t\t\t\t\t/* insert an error marker */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n+\t\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t\t} else { /* the attribute is already marked bad */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = 0;\n+\t\t\t\t\t\tif (index != end) {\n+\t\t\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tannotations->rawDataLength = length - 1; /* won't be using the extra slot */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6d3c25f5bc44314c577ebba23e70389f07c7c4e"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTk1NjkzOnYy", "diffSide": "RIGHT", "path": "runtime/bcutil/cfreader.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjozMzowNlrOF2x_OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjozMzowNlrOF2x_OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk4NjQyNQ==", "bodyText": "We've tried to use -- and ++ less in the code base outside of for /  while loops\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tannotations->rawDataLength--;\n          \n          \n            \n            \t\t\t\t\tannotations->rawDataLength -= 1;", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392986425", "createdAt": "2020-03-16T12:33:06Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,106 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n-\t\t\t\t * give up parsing.\n+\t\t\t\t * Give up parsing.\n+\t\t\t\t * \n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n-\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n-\t\t\t\t * to indicate that the attribute is malformed.\n+\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field\n+\t\t\t\t * to indicate that the attribute is malformed. The remaining raw data should follow\n+\t\t\t\t * the illegal target_type.\n+\t\t\t\t * \n+\t\t\t\t * The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t * extra raw data (at least 1 byte)\n+\t\t\t\t * \n+\t\t\t\t * Length will be adjusted during rawAttributeData assignment if it is determined that \n+\t\t\t\t * an extra slot is not needed.\n \t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 4;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* Insert illegal target_type followed by remaining raw data. */\n+\t\t\t\tif (index == end) {\n+\t\t\t\t\t/* There is no remaining raw data. */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\n+\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\tannotations->rawDataLength--;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f972102e1b6b8328662691d099d9b85bf4adf3e"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTk2NTA2OnYy", "diffSide": "RIGHT", "path": "runtime/bcutil/cfreader.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjozNDozOFrOF2yESQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjozNDozOFrOF2yESQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk4NzcyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t} else { /* the attribute is already marked bad */\n          \n          \n            \n            \t\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n          \n          \n            \n            \t\t\t\t\t} else { \n          \n          \n            \n            \t\t\t\t\t\t/* The attribute is already marked bad.\n          \n          \n            \n            \t\t\t\t\t\t * Adjust rawDataLength since there was no need to insert an extra byte.\n          \n          \n            \n            \t\t\t\t\t\t */", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392987721", "createdAt": "2020-03-16T12:34:38Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,106 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n-\t\t\t\t * give up parsing.\n+\t\t\t\t * Give up parsing.\n+\t\t\t\t * \n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n-\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n-\t\t\t\t * to indicate that the attribute is malformed.\n+\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field\n+\t\t\t\t * to indicate that the attribute is malformed. The remaining raw data should follow\n+\t\t\t\t * the illegal target_type.\n+\t\t\t\t * \n+\t\t\t\t * The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t * extra raw data (at least 1 byte)\n+\t\t\t\t * \n+\t\t\t\t * Length will be adjusted during rawAttributeData assignment if it is determined that \n+\t\t\t\t * an extra slot is not needed.\n \t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 4;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* Insert illegal target_type followed by remaining raw data. */\n+\t\t\t\tif (index == end) {\n+\t\t\t\t\t/* There is no remaining raw data. */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\n+\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\tannotations->rawDataLength--;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* cursor is the starting point in raw data array to write remaining raw data. */\n+\t\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n+\n+\t\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n+\t\t\t\t\t\t/* insert an error marker */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n+\t\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t\t\tcursor = 4;\n+\t\t\t\t\t} else { /* the attribute is already marked bad */\n+\t\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f972102e1b6b8328662691d099d9b85bf4adf3e"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTk2NjQ0OnYy", "diffSide": "RIGHT", "path": "runtime/bcutil/cfreader.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjozNDo1NFrOF2yFLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjozNDo1NFrOF2yFLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk4Nzk1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\tannotations->rawDataLength--;\n          \n          \n            \n            \t\t\t\t\t\tannotations->rawDataLength -= 1;", "url": "https://github.com/eclipse-openj9/openj9/pull/8761#discussion_r392987950", "createdAt": "2020-03-16T12:34:54Z", "author": {"login": "DanHeidinga"}, "path": "runtime/bcutil/cfreader.c", "diffHunk": "@@ -623,56 +642,106 @@ readAttributes(J9CfrClassFile * classfile, J9CfrAttribute *** pAttributes, U_32\n \t\t\t\treturn -2;\n \t\t\t}\n \t\t\tannotations = (J9CfrAttributeRuntimeVisibleTypeAnnotations *)attrib;\n+\t\t\tannotations->numberOfAnnotations = 0;\n+\t\t\tannotations->typeAnnotations = NULL;\n \t\t\tannotations->rawAttributeData = NULL;\n \t\t\tannotations->rawDataLength = 0; /* 0 indicates attribute is well-formed */\n-\t\t\tCHECK_EOF(2);\n-\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n-\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation))\n-\t\t\t{\n-\t\t\t\treturn -2;\n-\t\t\t}\n-\t\t\ttypeAnnotations = annotations->typeAnnotations;\n-\t\t\t/*\n-\t\t\t * we are now at the start of the first type_annotation\n-\t\t\t * Silently ignore errors.\n+\n+\t\t\t/* In the case of a malformed attribute numberOfAnnotations may not exist even if the file did not end. \n+\t\t\t * There must be at least two bytes to have a valid numberOfAnnotations.\n+\t\t\t * Length of 0 will be treated as an error below. Length of 1 will be an error as well since the index\n+\t\t\t * will not match the end value.\n \t\t\t */\n-\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n-\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n-\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n-\t\t\t\t\tbreak;\n+\t\t\tif (length > 1) {\n+\t\t\t\tCHECK_EOF(2);\n+\t\t\t\tNEXT_U16(annotations->numberOfAnnotations, index);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->typeAnnotations, annotations->numberOfAnnotations, J9CfrTypeAnnotation)) {\n+\t\t\t\t\treturn -2;\n+\t\t\t\t}\n+\t\t\t\ttypeAnnotations = annotations->typeAnnotations;\n+\t\t\t\t/*\n+\t\t\t\t* we are now at the start of the first type_annotation\n+\t\t\t\t* Silently ignore errors.\n+\t\t\t\t*/\n+\t\t\t\tfor (j = 0; j < annotations->numberOfAnnotations; j++, typeAnnotations++) {\n+\t\t\t\t\tresult = readTypeAnnotation(classfile, typeAnnotations, data, dataEnd, segment, segmentEnd, &index, &freePointer, flags);\n+\t\t\t\t\tif (BCT_ERR_NO_ERROR != result) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (BCT_ERR_OUT_OF_ROM == result) {\n \t\t\t\t/* Return out of memory error code to allocate larger buffer for classfile */\n \t\t\t\treturn result;\n-\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (index != end)) {\n-\t\t\t\tU_32 cursor = 0;\n+\t\t\t} else if ((BCT_ERR_NO_ERROR != result) || (0 == length) || (index != end)) {\n \t\t\t\t/*\n-\t\t\t\t * give up parsing.\n+\t\t\t\t * Give up parsing.\n+\t\t\t\t * \n \t\t\t\t * Copy the raw data, insert a bogus type_annotation,\n-\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field,\n-\t\t\t\t * to indicate that the attribute is malformed.\n+\t\t\t\t * i.e. an illegal target_type byte immediately after the num_annotations field\n+\t\t\t\t * to indicate that the attribute is malformed. The remaining raw data should follow\n+\t\t\t\t * the illegal target_type.\n+\t\t\t\t * \n+\t\t\t\t * The minimum number of raw data bytes needed to create a bogus type_annotation is:\n+\t\t\t\t * num_annotations (2 bytes)\n+\t\t\t\t * target_type (1 byte)\n+\t\t\t\t * extra raw data (at least 1 byte)\n+\t\t\t\t * \n+\t\t\t\t * Length will be adjusted during rawAttributeData assignment if it is determined that \n+\t\t\t\t * an extra slot is not needed.\n \t\t\t\t */\n+\t\t\t\tconst U_32 minimumRawDataBytes = 4;\n+\n \t\t\t\tTrc_BCU_MalformedTypeAnnotation(address);\n-\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, length + 1, U_8)) {\n+\n+\t\t\t\tannotations->rawDataLength = OMR_MAX(minimumRawDataBytes, length + 1);\n+\n+\t\t\t\tif (!ALLOC_ARRAY(annotations->rawAttributeData, annotations->rawDataLength, U_8)) {\n \t\t\t\t\treturn -2;\n \t\t\t\t}\n \t\t\t\tindex = attributeStart; /* rewind to the start of the attribute */\n-\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index); /* put in the num_annotations */\n-\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n-\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n-\t\t\t\t\t/* insert an error marker */\n-\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n-\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n-\t\t\t\t\tannotations->rawDataLength = length + 1;\n-\t\t\t\t} else { /* the attribute is already marked bad */\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[3], index);\n-\t\t\t\t\tannotations->rawDataLength = length;\n+\n+\t\t\t\t/* read num_annotations or set dummy if these bytes do not exist. */\n+\t\t\t\tif (length >= 2) {\n+\t\t\t\t\tNEXT_U16(annotations->rawAttributeData[0], index);\n+\t\t\t\t} else {\n+\t\t\t\t\t/* there should be at least one type_annotation here for the illegal \n+\t\t\t\t\t * entry that is being created. */\n+\t\t\t\t\tannotations->rawAttributeData[0] = 0;\n+\t\t\t\t\tannotations->rawAttributeData[1] = 1;\n \t\t\t\t}\n-\t\t\t\tfor (cursor = 4; cursor < annotations->rawDataLength; ++cursor) {\n-\t\t\t\t\tCHECK_EOF(1);\n-\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[cursor], index);\n+\n+\t\t\t\t/* Insert illegal target_type followed by remaining raw data. */\n+\t\t\t\tif (index == end) {\n+\t\t\t\t\t/* There is no remaining raw data. */\n+\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\n+\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\tannotations->rawDataLength--;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* cursor is the starting point in raw data array to write remaining raw data. */\n+\t\t\t\t\tU_32 cursor = 0;\n+\n+\t\t\t\t\tNEXT_U8(annotations->rawAttributeData[2], index);\n+\n+\t\t\t\t\tif (CFR_TARGET_TYPE_ErrorInAttribute != annotations->rawAttributeData[2]) {\n+\t\t\t\t\t\t/* insert an error marker */\n+\t\t\t\t\t\tannotations->rawAttributeData[3] = annotations->rawAttributeData[2];\n+\t\t\t\t\t\tannotations->rawAttributeData[2] = CFR_TARGET_TYPE_ErrorInAttribute;\n+\t\t\t\t\t\tcursor = 4;\n+\t\t\t\t\t} else { /* the attribute is already marked bad */\n+\t\t\t\t\t\t/* Adjust rawDataLength since there was no need to insert an extra byte. */\n+\t\t\t\t\t\tannotations->rawDataLength--;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f972102e1b6b8328662691d099d9b85bf4adf3e"}, "originalPosition": 197}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 485, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}