{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2MzYzMTEw", "number": 10118, "title": "Prefetch resolved implementor methods for CHTable", "bodyText": "CollectImplementors is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\nThis commit adds a new helper class - CollectResolvedImplementors.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by CollectImplementors\nin one message.", "createdAt": "2020-07-08T16:44:29Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10118", "merged": true, "mergeCommit": {"oid": "04c2621751962dd32b2ff60b8d212d27d5bd953b"}, "closed": true, "closedAt": "2020-08-04T11:53:00Z", "author": {"login": "dmitry-ten"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcy9WVbABqjM1MjYxMzkyMDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5c-LEgFqTQ1NzAxMTk0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1602112630dd4ac24073f1adc120714afcb246fe", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/1602112630dd4ac24073f1adc120714afcb246fe", "committedDate": "2020-07-08T16:44:00Z", "message": "Coalesce messages in interprocedural analyzer\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "104b3f8c86e82d9336d36ddbb29c33b3492f2e8b", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/104b3f8c86e82d9336d36ddbb29c33b3492f2e8b", "committedDate": "2020-07-08T16:50:48Z", "message": "Coalesce messages in interprocedural analyzer\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "104b3f8c86e82d9336d36ddbb29c33b3492f2e8b", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/104b3f8c86e82d9336d36ddbb29c33b3492f2e8b", "committedDate": "2020-07-08T16:50:48Z", "message": "Coalesce messages in interprocedural analyzer\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "c36959f16d807e52256f825610eef35d2cb4207a", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c36959f16d807e52256f825610eef35d2cb4207a", "committedDate": "2020-07-08T17:15:56Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - 'CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c36959f16d807e52256f825610eef35d2cb4207a", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c36959f16d807e52256f825610eef35d2cb4207a", "committedDate": "2020-07-08T17:15:56Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - 'CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "112f226faf7d190eabbbec3c2a001265339e4c0e", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/112f226faf7d190eabbbec3c2a001265339e4c0e", "committedDate": "2020-07-08T17:27:28Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - 'CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "112f226faf7d190eabbbec3c2a001265339e4c0e", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/112f226faf7d190eabbbec3c2a001265339e4c0e", "committedDate": "2020-07-08T17:27:28Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - 'CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "7ef83319a2385ec4104b9250730d95893baa6699", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7ef83319a2385ec4104b9250730d95893baa6699", "committedDate": "2020-07-08T17:29:25Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7ef83319a2385ec4104b9250730d95893baa6699", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7ef83319a2385ec4104b9250730d95893baa6699", "committedDate": "2020-07-08T17:29:25Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "8b7d0138eb4e46d77fffcd952ad449e46f6e15c7", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8b7d0138eb4e46d77fffcd952ad449e46f6e15c7", "committedDate": "2020-07-09T16:51:01Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MTc5MTcx", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#pullrequestreview-448179171", "createdAt": "2020-07-14T14:47:12Z", "commit": {"oid": "8b7d0138eb4e46d77fffcd952ad449e46f6e15c7"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8b7d0138eb4e46d77fffcd952ad449e46f6e15c7", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8b7d0138eb4e46d77fffcd952ad449e46f6e15c7", "committedDate": "2020-07-09T16:51:01Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/b6d99e5dc2844531bfc63db8e540375b28cd48d6", "committedDate": "2020-07-14T19:33:21Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NTU4NTY0", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#pullrequestreview-448558564", "createdAt": "2020-07-15T00:51:17Z", "commit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMDo1MToxN1rOGxqStg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMjoyNzowMFrOGxr4Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyNjMyNg==", "bodyText": "We should use a reference for these two fields", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454726326", "createdAt": "2020-07-15T00:51:17Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/j9methodServer.cpp", "diffHunk": "@@ -1954,6 +1954,40 @@ TR_ResolvedJ9JITServerMethod::cacheFields()\n       }\n    }\n \n+void\n+TR_ResolvedJ9JITServerMethod::cacheImplementorMethods(std::vector<TR_OpaqueClassBlock *> &subClasses, int32_t cpIndexOrOffset, bool isInterface, int32_t ttlForUnresolved)\n+   {\n+   auto compInfoPT = (TR::CompilationInfoPerThreadRemote *) _fe->_compInfoPT;\n+   int32_t numMethods = subClasses.size();\n+\n+   // If there's just one field, it's faster to get it through regular means,\n+   // to avoid overhead of vectors\n+   if (numMethods < 2)\n+      return;\n+\n+   _stream->write(JITServer::MessageType::ResolvedMethod_getResolvedImplementorMethods, (TR_ResolvedJ9Method *) _remoteMirror, subClasses, cpIndexOrOffset, isInterface);\n+   auto recv = _stream->read<std::vector<J9Method *>, std::vector<TR_ResolvedJ9JITServerMethodInfo>>();\n+\n+   // Note: the number of received methods can be smaller\n+   // than the requsted number, because client will abort after\n+   // the first unresolved method.\n+   auto ramMethods = std::get<0>(recv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczMTI3MQ==", "bodyText": "This can push a NULL ramMethod as the last element. Is that intended?", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454731271", "createdAt": "2020-07-15T01:09:43Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -1841,6 +1841,52 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          client->write(response, objLocation, obj);\n          }\n          break;\n+      case MessageType::ResolvedMethod_getResolvedImplementorMethods:\n+         {\n+         auto recv = client->getRecvData<TR_ResolvedJ9Method *, std::vector<TR_OpaqueClassBlock *>, int32_t, bool>();\n+         auto owningMethod = std::get<0>(recv);\n+         auto &subClasses = std::get<1>(recv);\n+         int32_t cpIndexOrOffset = std::get<2>(recv);\n+         bool isInterface = std::get<3>(recv);\n+\n+         int32_t numMethods = subClasses.size();\n+         std::vector<J9Method *> ramMethods;\n+         std::vector<TR_ResolvedJ9JITServerMethodInfo> methodInfos;\n+         ramMethods.reserve(numMethods);\n+         methodInfos.reserve(numMethods);\n+\n+         for (int32_t i = 0; i < numMethods; ++i)\n+            {\n+            J9Method *ramMethod;\n+            TR_ResolvedJ9JITServerMethodInfo methodInfo;\n+            if (isInterface)\n+               {\n+               ramMethod = (J9Method *) fe->getResolvedInterfaceMethod(owningMethod->getPersistentIdentifier(), subClasses[i], cpIndexOrOffset);\n+               bool resolved = ramMethod && J9_BYTECODE_START_FROM_RAM_METHOD(ramMethod);\n+\n+               if (resolved)\n+                  TR_ResolvedJ9JITServerMethod::createResolvedMethodFromJ9MethodMirror(methodInfo, (TR_OpaqueMethodBlock *) ramMethod, 0, owningMethod, fe, trMemory);\n+               }\n+            else\n+               {\n+               TR_OpaqueMethodBlock *method = fe->getResolvedVirtualMethod(subClasses[i], cpIndexOrOffset);\n+               ramMethod = reinterpret_cast<J9Method *>(method);\n+               TR_ResolvedJ9JITServerMethodInfo methodInfo;\n+               if (ramMethod)\n+                  TR_ResolvedJ9JITServerMethod::createResolvedMethodMirror(methodInfo, method, 0, owningMethod, fe, trMemory);\n+               }\n+            ramMethods.push_back(ramMethod);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNTY5NQ==", "bodyText": "I don't see a constructor for TR_ResolvedJ9JITServerMethodInfo which means that at this point methodInfo is not initialized. Is methodInfo.remoteMirror going to be initialized on all possible paths later?", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454735695", "createdAt": "2020-07-15T01:25:39Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -1841,6 +1841,52 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          client->write(response, objLocation, obj);\n          }\n          break;\n+      case MessageType::ResolvedMethod_getResolvedImplementorMethods:\n+         {\n+         auto recv = client->getRecvData<TR_ResolvedJ9Method *, std::vector<TR_OpaqueClassBlock *>, int32_t, bool>();\n+         auto owningMethod = std::get<0>(recv);\n+         auto &subClasses = std::get<1>(recv);\n+         int32_t cpIndexOrOffset = std::get<2>(recv);\n+         bool isInterface = std::get<3>(recv);\n+\n+         int32_t numMethods = subClasses.size();\n+         std::vector<J9Method *> ramMethods;\n+         std::vector<TR_ResolvedJ9JITServerMethodInfo> methodInfos;\n+         ramMethods.reserve(numMethods);\n+         methodInfos.reserve(numMethods);\n+\n+         for (int32_t i = 0; i < numMethods; ++i)\n+            {\n+            J9Method *ramMethod;\n+            TR_ResolvedJ9JITServerMethodInfo methodInfo;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNjQwNQ==", "bodyText": "I see the initialization in createResolvedMethodFromJ9MethodMirror which calls:\nvoid\nTR_ResolvedJ9JITServerMethod::packMethodInfo(TR_ResolvedJ9JITServerMethodInfo &methodInfo, TR_ResolvedJ9Method *resolvedMethod, TR_FrontEnd *fe)\n   {\n   auto &methodInfoStruct = std::get<0>(methodInfo);\n   if (!resolvedMethod)\n      {\n      // resolved method not created, setting remoteMirror to NULL indicates\n      // that other fields should be ignored.\n      methodInfoStruct.remoteMirror = NULL;\n      return;\n      }\n\nbut that is not called when resolved is false.", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454736405", "createdAt": "2020-07-15T01:28:27Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -1841,6 +1841,52 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n          client->write(response, objLocation, obj);\n          }\n          break;\n+      case MessageType::ResolvedMethod_getResolvedImplementorMethods:\n+         {\n+         auto recv = client->getRecvData<TR_ResolvedJ9Method *, std::vector<TR_OpaqueClassBlock *>, int32_t, bool>();\n+         auto owningMethod = std::get<0>(recv);\n+         auto &subClasses = std::get<1>(recv);\n+         int32_t cpIndexOrOffset = std::get<2>(recv);\n+         bool isInterface = std::get<3>(recv);\n+\n+         int32_t numMethods = subClasses.size();\n+         std::vector<J9Method *> ramMethods;\n+         std::vector<TR_ResolvedJ9JITServerMethodInfo> methodInfos;\n+         ramMethods.reserve(numMethods);\n+         methodInfos.reserve(numMethods);\n+\n+         for (int32_t i = 0; i < numMethods; ++i)\n+            {\n+            J9Method *ramMethod;\n+            TR_ResolvedJ9JITServerMethodInfo methodInfo;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNTY5NQ=="}, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0NDU4Ng==", "bodyText": "Maybe an assert is a better choice here.", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454744586", "createdAt": "2020-07-15T01:58:21Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +998,115 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, NULL, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      _implArray = new (comp->trHeapMemory()) TR_ResolvedMethod *[maxCount];\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   // must only be used on JITServer server-side\n+   if (!comp()->isOutOfProcessCompilation())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0NTI2Ng==", "bodyText": "Let's move type closer to its usage, line 1055.\nSame for compInfoPT", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454745266", "createdAt": "2020-07-15T02:00:55Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +998,115 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, NULL, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      _implArray = new (comp->trHeapMemory()) TR_ResolvedMethod *[maxCount];\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   // must only be used on JITServer server-side\n+   if (!comp()->isOutOfProcessCompilation())\n+      {\n+      stopTheWalk();\n+      return false;\n+      }\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+   TR_ResolvedMethodType type = isInterface() ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0ODMyNg==", "bodyText": "Is it possible to find something in the cache, but resolvedMethod is NULL? If so, what should we do?", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454748326", "createdAt": "2020-07-15T02:12:41Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +998,115 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, NULL, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      _implArray = new (comp->trHeapMemory()) TR_ResolvedMethod *[maxCount];\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   // must only be used on JITServer server-side\n+   if (!comp()->isOutOfProcessCompilation())\n+      {\n+      stopTheWalk();\n+      return false;\n+      }\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+   TR_ResolvedMethodType type = isInterface() ?\n+      TR_ResolvedMethodType::Interface :\n+      TR_ResolvedMethodType::VirtualFromOffset;\n+   auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+\n+   // verify that our subclass meets all conditions\n+   TR_OpaqueClassBlock *classId = cl->getClassId();\n+   if (!TR::Compiler->cls.isAbstractClass(comp(), classId)\n+      && !TR::Compiler->cls.isInterfaceClass(comp(), classId))\n+      {\n+      ++_numVisitedSubClasses;\n+      if (_numVisitedSubClasses > _maxNumVisitedSubClasses)\n+         {\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+\n+      // if the implementor hasn't been cached yet,\n+      // add the corresponding subclass to the list\n+      TR_ResolvedMethod *resolvedMethod;\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            classId);\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         _subClasses.push_back(classId);\n+         }\n+      else if (resolvedMethod)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0OTgyOA==", "bodyText": "We should have an assert firing if trying to execute this not at JITServer.", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454749828", "createdAt": "2020-07-15T02:17:46Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +998,115 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, NULL, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      _implArray = new (comp->trHeapMemory()) TR_ResolvedMethod *[maxCount];\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   // must only be used on JITServer server-side\n+   if (!comp()->isOutOfProcessCompilation())\n+      {\n+      stopTheWalk();\n+      return false;\n+      }\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+   TR_ResolvedMethodType type = isInterface() ?\n+      TR_ResolvedMethodType::Interface :\n+      TR_ResolvedMethodType::VirtualFromOffset;\n+   auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+\n+   // verify that our subclass meets all conditions\n+   TR_OpaqueClassBlock *classId = cl->getClassId();\n+   if (!TR::Compiler->cls.isAbstractClass(comp(), classId)\n+      && !TR::Compiler->cls.isInterfaceClass(comp(), classId))\n+      {\n+      ++_numVisitedSubClasses;\n+      if (_numVisitedSubClasses > _maxNumVisitedSubClasses)\n+         {\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+\n+      // if the implementor hasn't been cached yet,\n+      // add the corresponding subclass to the list\n+      TR_ResolvedMethod *resolvedMethod;\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            classId);\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         _subClasses.push_back(classId);\n+         }\n+      else if (resolvedMethod)\n+         {\n+         // check to see if there are any duplicates\n+         int32_t i;\n+         for (i = 0; i < _count; i++)\n+            if (resolvedMethod->isSameMethod(_implArray[i]))\n+               break;  // we already listed this method\n+         if (i >= _count) // brand new implementer\n+            {\n+            _implArray[_count++] = resolvedMethod;\n+            if (_count >= _maxCount)\n+               {\n+               stopTheWalk();\n+               }\n+            }\n+         }\n+      }\n+\n+   return true;\n+   }\n+\n+void\n+CollectResolvedImplementors::cacheResolvedMethods()\n+   {\n+   // must only be used on JITServer server-side\n+   // _count >= _maxCount indicates that either all required implementors\n+   // are already cached or that too many subclasses were visited.\n+   // Remote call not needed.\n+   if (!comp()->isOutOfProcessCompilation() || _count >= _maxCount)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1MDA3Ng==", "bodyText": "Add /* defined(J9VM_OPT_JITSERVER)  */", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454750076", "createdAt": "2020-07-15T02:18:48Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +998,115 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, NULL, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      _implArray = new (comp->trHeapMemory()) TR_ResolvedMethod *[maxCount];\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   // must only be used on JITServer server-side\n+   if (!comp()->isOutOfProcessCompilation())\n+      {\n+      stopTheWalk();\n+      return false;\n+      }\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+   TR_ResolvedMethodType type = isInterface() ?\n+      TR_ResolvedMethodType::Interface :\n+      TR_ResolvedMethodType::VirtualFromOffset;\n+   auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+\n+   // verify that our subclass meets all conditions\n+   TR_OpaqueClassBlock *classId = cl->getClassId();\n+   if (!TR::Compiler->cls.isAbstractClass(comp(), classId)\n+      && !TR::Compiler->cls.isInterfaceClass(comp(), classId))\n+      {\n+      ++_numVisitedSubClasses;\n+      if (_numVisitedSubClasses > _maxNumVisitedSubClasses)\n+         {\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+\n+      // if the implementor hasn't been cached yet,\n+      // add the corresponding subclass to the list\n+      TR_ResolvedMethod *resolvedMethod;\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            classId);\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         _subClasses.push_back(classId);\n+         }\n+      else if (resolvedMethod)\n+         {\n+         // check to see if there are any duplicates\n+         int32_t i;\n+         for (i = 0; i < _count; i++)\n+            if (resolvedMethod->isSameMethod(_implArray[i]))\n+               break;  // we already listed this method\n+         if (i >= _count) // brand new implementer\n+            {\n+            _implArray[_count++] = resolvedMethod;\n+            if (_count >= _maxCount)\n+               {\n+               stopTheWalk();\n+               }\n+            }\n+         }\n+      }\n+\n+   return true;\n+   }\n+\n+void\n+CollectResolvedImplementors::cacheResolvedMethods()\n+   {\n+   // must only be used on JITServer server-side\n+   // _count >= _maxCount indicates that either all required implementors\n+   // are already cached or that too many subclasses were visited.\n+   // Remote call not needed.\n+   if (!comp()->isOutOfProcessCompilation() || _count >= _maxCount)\n+      {\n+      return;\n+      }\n+\n+   static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod)->cacheImplementorMethods(\n+      _subClasses,\n+      _slotOrIndex,\n+      isInterface(),\n+      2);\n+   }\n+#endif", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1MDk5Mg==", "bodyText": "Add /* defined(J9VM_OPT_JITSERVER) */", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454750992", "createdAt": "2020-07-15T02:21:59Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -1015,6 +1131,16 @@ TR_ClassQueries::collectImplementorsCapped(TR_PersistentClassInfo *clazz,\n    {\n    if (comp->getOption(TR_DisableCHOpts))\n       return maxCount+1; // fail the collection\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (comp->isOutOfProcessCompilation())\n+      {\n+      CollectResolvedImplementors classCollector(comp, clazz->getClassId(), maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod);\n+      classCollector.visit(clazz->getClassId(), locked);\n+      classCollector.cacheResolvedMethods();\n+      }\n+#endif", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1MTUzNQ==", "bodyText": "If we exceeded maxCount at this point, we don't have to execute the second pass through the hierarchy.", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454751535", "createdAt": "2020-07-15T02:24:10Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -1015,6 +1131,16 @@ TR_ClassQueries::collectImplementorsCapped(TR_PersistentClassInfo *clazz,\n    {\n    if (comp->getOption(TR_DisableCHOpts))\n       return maxCount+1; // fail the collection\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (comp->isOutOfProcessCompilation())\n+      {\n+      CollectResolvedImplementors classCollector(comp, clazz->getClassId(), maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod);\n+      classCollector.visit(clazz->getClassId(), locked);\n+      classCollector.cacheResolvedMethods();\n+      }\n+#endif\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1MjMxNA==", "bodyText": "I just saw that parameter called locked. If this is executed in a critical section we may not be able to send a message because of the delay.", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r454752314", "createdAt": "2020-07-15T02:27:00Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -1015,6 +1131,16 @@ TR_ClassQueries::collectImplementorsCapped(TR_PersistentClassInfo *clazz,\n    {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6"}, "originalPosition": 169}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b6d99e5dc2844531bfc63db8e540375b28cd48d6", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/b6d99e5dc2844531bfc63db8e540375b28cd48d6", "committedDate": "2020-07-14T19:33:21Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "10b8ae9266671db82a2d829e29bf0b0e801c9f04", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/10b8ae9266671db82a2d829e29bf0b0e801c9f04", "committedDate": "2020-07-15T19:11:24Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "10b8ae9266671db82a2d829e29bf0b0e801c9f04", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/10b8ae9266671db82a2d829e29bf0b0e801c9f04", "committedDate": "2020-07-15T19:11:24Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "3d13588a6b0d88997c1be91af0b6d14b8f882d13", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3d13588a6b0d88997c1be91af0b6d14b8f882d13", "committedDate": "2020-07-15T19:30:57Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d13588a6b0d88997c1be91af0b6d14b8f882d13", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3d13588a6b0d88997c1be91af0b6d14b8f882d13", "committedDate": "2020-07-15T19:30:57Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "855126328ecea1fb7019b5b10f3e9aec5e700438", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/855126328ecea1fb7019b5b10f3e9aec5e700438", "committedDate": "2020-07-16T17:12:06Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "855126328ecea1fb7019b5b10f3e9aec5e700438", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/855126328ecea1fb7019b5b10f3e9aec5e700438", "committedDate": "2020-07-16T17:12:06Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "c891c4b21e91f48bdeebacee18ae4cb2d59d4dae", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c891c4b21e91f48bdeebacee18ae4cb2d59d4dae", "committedDate": "2020-07-16T17:13:04Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c891c4b21e91f48bdeebacee18ae4cb2d59d4dae", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c891c4b21e91f48bdeebacee18ae4cb2d59d4dae", "committedDate": "2020-07-16T17:13:04Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "4564576c32b20b9e719a74ea795ad137253eb957", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4564576c32b20b9e719a74ea795ad137253eb957", "committedDate": "2020-07-16T19:23:50Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4564576c32b20b9e719a74ea795ad137253eb957", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/4564576c32b20b9e719a74ea795ad137253eb957", "committedDate": "2020-07-16T19:23:50Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "7fdc460fae1e5ba76fbe7791549d47d666f7d8ad", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7fdc460fae1e5ba76fbe7791549d47d666f7d8ad", "committedDate": "2020-07-16T19:51:10Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDk1OTQx", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#pullrequestreview-451095941", "createdAt": "2020-07-19T03:38:15Z", "commit": {"oid": "7fdc460fae1e5ba76fbe7791549d47d666f7d8ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwMzozODoxNVrOGzsK1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwMzozODoxNVrOGzsK1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NDIyOA==", "bodyText": "visitSubclasses is called from visit which acquires the CHTable mutex, thus we keep this mutex while sending a message. I would like to avoid that.", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r456854228", "createdAt": "2020-07-19T03:38:15Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +1007,141 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           TR_ResolvedMethod **implArray,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, implArray, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      TR_ASSERT_FATAL(comp->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+protected:\n+   virtual void visitSubclasses(TR_PersistentClassInfo *, TR_CHTable::VisitTracker& visited) override;\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   TR_ASSERT_FATAL(comp()->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+\n+   // verify that our subclass meets all conditions\n+   TR_OpaqueClassBlock *classId = cl->getClassId();\n+   if (!TR::Compiler->cls.isAbstractClass(comp(), classId)\n+      && !TR::Compiler->cls.isInterfaceClass(comp(), classId))\n+      {\n+      ++_numVisitedSubClasses;\n+      if (_numVisitedSubClasses > _maxNumVisitedSubClasses)\n+         {\n+         // too many classes visited.\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+\n+      // if the implementor hasn't been cached yet,\n+      // add the corresponding subclass to the list\n+      TR_ResolvedMethod *resolvedMethod;\n+      TR_ResolvedMethodType type = isInterface() ?\n+         TR_ResolvedMethodType::Interface :\n+         TR_ResolvedMethodType::VirtualFromOffset;\n+      auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            classId);\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         _subClasses.push_back(classId);\n+         }\n+      else if (resolvedMethod)\n+         {\n+         bool added = addImplementor(resolvedMethod);\n+         if (added && _count >= _maxCount)\n+            stopTheWalk();\n+         }\n+      else\n+         {\n+         // unresolved cached method found.\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+      }\n+\n+   return true;\n+   }\n+\n+void\n+CollectResolvedImplementors::visitSubclasses(TR_PersistentClassInfo * classInfo, TR_CHTable::VisitTracker& visited)\n+   {\n+   TR_SubclassVisitor::visitSubclasses(classInfo, visited);\n+   if (_depth == 0)\n+      {\n+      TR_ASSERT_FATAL(comp()->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+      // _count >= _maxCount indicates that either all required implementors\n+      // are already cached or that too many subclasses were visited.\n+      // Remote call not needed.\n+      if (_count >= _maxCount)\n+         {\n+         return;\n+         }\n+\n+      auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+      callerMethod->cacheImplementorMethods(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fdc460fae1e5ba76fbe7791549d47d666f7d8ad"}, "originalPosition": 221}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7fdc460fae1e5ba76fbe7791549d47d666f7d8ad", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7fdc460fae1e5ba76fbe7791549d47d666f7d8ad", "committedDate": "2020-07-16T19:51:10Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "8f44f2ef4b79f5cfa033941f3797f454d00ddc15", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8f44f2ef4b79f5cfa033941f3797f454d00ddc15", "committedDate": "2020-07-20T14:53:21Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTYwODgw", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#pullrequestreview-455160880", "createdAt": "2020-07-24T20:17:44Z", "commit": {"oid": "8f44f2ef4b79f5cfa033941f3797f454d00ddc15"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDoxNzo0NFrOG28iaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDoxNzo0NFrOG28iaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2ODEzNw==", "bodyText": "If the cached method is unresolved (resolvedMethod == NULL) shouldn't we stop the walk and set _count == _maxCount?", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r460268137", "createdAt": "2020-07-24T20:17:44Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -991,6 +1011,136 @@ bool CollectCompiledImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n    return false;\n    }\n \n+#if defined(J9VM_OPT_JITSERVER)\n+class CollectResolvedImplementors: public CollectImplementors\n+   {\n+public:\n+   CollectResolvedImplementors(TR::Compilation * comp,\n+                           TR_OpaqueClassBlock *topClassId,\n+                           TR_ResolvedMethod **implArray,\n+                           int32_t maxCount,\n+                           TR_ResolvedMethod *callerMethod,\n+                           int32_t slotOrIndex,\n+                           TR_YesNoMaybe useGetResolvedInterfaceMethod = TR_maybe) :\n+      CollectImplementors(comp, topClassId, implArray, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod)\n+      {\n+      TR_ASSERT_FATAL(comp->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+      }\n+\n+   virtual bool visitSubclass(TR_PersistentClassInfo *cl) override;\n+   void cacheResolvedMethods();\n+\n+private:\n+   std::vector<TR_OpaqueClassBlock *> _subClasses;\n+   };\n+\n+bool\n+CollectResolvedImplementors::visitSubclass(TR_PersistentClassInfo *cl)\n+   {\n+   TR_ASSERT_FATAL(comp()->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+\n+   // verify that our subclass meets all conditions\n+   TR_OpaqueClassBlock *classId = cl->getClassId();\n+   if (!TR::Compiler->cls.isAbstractClass(comp(), classId)\n+      && !TR::Compiler->cls.isInterfaceClass(comp(), classId))\n+      {\n+      ++_numVisitedSubClasses;\n+      if (_numVisitedSubClasses > _maxNumVisitedSubClasses)\n+         {\n+         // too many classes visited.\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+\n+      // if the implementor hasn't been cached yet,\n+      // add the corresponding subclass to the list\n+      TR_ResolvedMethod *resolvedMethod;\n+      TR_ResolvedMethodType type = isInterface() ?\n+         TR_ResolvedMethodType::Interface :\n+         TR_ResolvedMethodType::VirtualFromOffset;\n+      auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            classId);\n+      if (!compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         _subClasses.push_back(classId);\n+         }\n+      else if (resolvedMethod)\n+         {\n+         bool added = addImplementor(resolvedMethod);\n+         if (added && _count >= _maxCount)\n+            stopTheWalk();\n+         }\n+      else\n+         {\n+         // unresolved cached method found.\n+         // set count greater than maxCount, to indicate failure and force exit\n+         _count = _maxCount + 1;\n+         stopTheWalk();\n+         return false;\n+         }\n+      }\n+\n+   return true;\n+   }\n+\n+void\n+CollectResolvedImplementors::cacheResolvedMethods()\n+   {\n+   TR_ASSERT_FATAL(comp()->isOutOfProcessCompilation(), \"Must only be called on JITServer server-side\");\n+   // _count >= _maxCount indicates that either all required implementors\n+   // are already cached or that too many subclasses were visited.\n+   // Remote call not needed.\n+   if (_count >= _maxCount)\n+      {\n+      return;\n+      }\n+\n+   auto callerMethod = static_cast<TR_ResolvedJ9JITServerMethod *>(_callerMethod);\n+   callerMethod->cacheImplementorMethods(\n+      _subClasses,\n+      _slotOrIndex,\n+      isInterface(),\n+      2);\n+\n+   // now, add the cached methods to _implArray\n+   TR_ResolvedMethod *resolvedMethod;\n+   TR_ResolvedMethodType type = isInterface() ?\n+      TR_ResolvedMethodType::Interface :\n+      TR_ResolvedMethodType::VirtualFromOffset;\n+   auto compInfoPT = static_cast<TR::CompilationInfoPerThreadRemote *>(static_cast<TR_J9VMBase *>(fe())->_compInfoPT);\n+   for (auto it = _subClasses.begin(); it != _subClasses.end(); ++it)\n+      {\n+      TR_ResolvedMethodKey key =\n+         compInfoPT->getResolvedMethodKey(\n+            type,\n+            reinterpret_cast<TR_OpaqueClassBlock *>(callerMethod->constantPoolHdr()),\n+            _slotOrIndex,\n+            *it);\n+      if (compInfoPT->getCachedResolvedMethod(\n+             key,\n+             callerMethod,\n+             &resolvedMethod))\n+         {\n+         bool added = addImplementor(resolvedMethod);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f44f2ef4b79f5cfa033941f3797f454d00ddc15"}, "originalPosition": 246}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTYzNzk2", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#pullrequestreview-455163796", "createdAt": "2020-07-24T20:23:07Z", "commit": {"oid": "8f44f2ef4b79f5cfa033941f3797f454d00ddc15"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDoyMzowN1rOG28rvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDoyMzowN1rOG28rvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3MDUyNg==", "bodyText": "Don't we need visitSubclass(clazz) like in the original? This visits the top class.", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#discussion_r460270526", "createdAt": "2020-07-24T20:23:07Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -1015,10 +1165,23 @@ TR_ClassQueries::collectImplementorsCapped(TR_PersistentClassInfo *clazz,\n    {\n    if (comp->getOption(TR_DisableCHOpts))\n       return maxCount+1; // fail the collection\n-   CollectImplementors collector(comp, clazz->getClassId(), implArray, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod);\n-   collector.visitSubclass(clazz);\n-   collector.visit(clazz->getClassId(), locked);\n-   return collector.getCount(); // return the number of implementers in the implArray\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+   if (comp->isOutOfProcessCompilation())\n+      {\n+      CollectResolvedImplementors collector(comp, clazz->getClassId(), implArray, maxCount, callerMethod, slotOrIndex, useGetResolvedInterfaceMethod);\n+      collector.visit(clazz->getClassId(), locked);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f44f2ef4b79f5cfa033941f3797f454d00ddc15"}, "originalPosition": 270}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f44f2ef4b79f5cfa033941f3797f454d00ddc15", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8f44f2ef4b79f5cfa033941f3797f454d00ddc15", "committedDate": "2020-07-20T14:53:21Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "630d699bc6ae81591912df50264bcc7c9e10baa6", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/630d699bc6ae81591912df50264bcc7c9e10baa6", "committedDate": "2020-07-27T14:59:15Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ccc3a0786c55820a99670f5ec18421166e14e67", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3ccc3a0786c55820a99670f5ec18421166e14e67", "committedDate": "2020-07-27T15:56:37Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "630d699bc6ae81591912df50264bcc7c9e10baa6", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/630d699bc6ae81591912df50264bcc7c9e10baa6", "committedDate": "2020-07-27T14:59:15Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}, "afterCommit": {"oid": "3ccc3a0786c55820a99670f5ec18421166e14e67", "author": {"user": {"login": "dmitry-ten", "name": "Dmitry Ten"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3ccc3a0786c55820a99670f5ec18421166e14e67", "committedDate": "2020-07-27T15:56:37Z", "message": "Prefetch resolved implementor methods for CHTable\n\n`CollectImplementors` is used by CHTable to find\nthe number of implementors of a given method.\nIt works by recursively walking the class tree\nand creating a resolved method for each implementor.\nThis results in many remote queries in JITServer.\n\nThis commit adds a new helper class - `CollectResolvedImplementors`.\nIts purpose is to walk the class tree and pre-emptively cache\nall resolved methods that might be created by `CollectImplementors`\nin one message.\n\nSigned-off-by: Dmitry Ten <Dmitry.Ten@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MDExOTQy", "url": "https://github.com/eclipse-openj9/openj9/pull/10118#pullrequestreview-457011942", "createdAt": "2020-07-28T21:05:01Z", "commit": {"oid": "3ccc3a0786c55820a99670f5ec18421166e14e67"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 529, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}