{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyNTkzMTQ5", "number": 10690, "reviewThreads": {"totalCount": 67, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOTowNDoyNFrOE4TlZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxOToxMzoyMFrOFUo96w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDc2NTgwOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOTowNDoyNFrOHyJeYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwNTo0MTozNFrOH6xo8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0NjA4Mw==", "bodyText": "What are these constants based on?  Do you match corresponding values in the javacode?  If so, please point add a comment referencing that", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r522346083", "createdAt": "2020-11-12T19:04:24Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTM5Mjc1Mw==", "bodyText": "added reference to Java constant", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531392753", "createdAt": "2020-11-27T05:41:34Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0NjA4Mw=="}, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDc3MTMwOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOTowNTo0MVrOHyJhtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwNTo0MTo0OFrOH6xpNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0NjkzMw==", "bodyText": "nameObject is corrupted if a GC occurs during the second object allocation.  The object pointer needs to be pushed in a special frame or stored somewhere the GC can find it and refreshed after the second allocate", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r522346933", "createdAt": "2020-11-12T19:05:41Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTM5MjgyMQ==", "bodyText": "fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531392821", "createdAt": "2020-11-27T05:41:48Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0NjkzMw=="}, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDc5NDY5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToxMDo1MFrOHyJvTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToxMDo1MFrOHyJvTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1MDQxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tchar* signature = (char*)j9mem_allocate_memory(2 * sizeof(char*), OMRMEM_CATEGORY_VM);\n          \n          \n            \n            \t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n          \n      \n    \n    \n  \n\nThe current code is allocating two pointers worth of data (ie: 2*8 bytes on a 64bit system)", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r522350413", "createdAt": "2020-11-12T19:10:50Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass)\n+\t\tresult = 'Z';\n+\telse if (clazz == vm->byteReflectClass)\n+\t\tresult = 'B';\n+\telse if (clazz == vm->charReflectClass)\n+\t\tresult = 'C';\n+\telse if (clazz == vm->shortReflectClass)\n+\t\tresult = 'S';\n+\telse if (clazz == vm->intReflectClass)\n+\t\tresult = 'I';\n+\telse if (clazz == vm->longReflectClass)\n+\t\tresult = 'J';\n+\telse if (clazz == vm->floatReflectClass)\n+\t\tresult = 'F';\n+\telse if (clazz == vm->doubleReflectClass)\n+\t\tresult = 'D';\n+\telse if (clazz == vm->voidReflectClass)\n+\t\tresult = 'V';\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2 * sizeof(char*), OMRMEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDgwMjI5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToxMjowN1rOHyJznQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToxMjowN1rOHyJznQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1MTUxNw==", "bodyText": "There's a lot of missing { & }.  Please always use them for control flow as it prevents errors when modifying the code.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tif (* name != '[')\n          \n          \n            \n            \t\tlength += 2;\n          \n          \n            \n            \tif (* name != '[') {\n          \n          \n            \n            \t\tlength += 2;\n          \n          \n            \n            \t}", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r522351517", "createdAt": "2020-11-12T19:12:07Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass)\n+\t\tresult = 'Z';\n+\telse if (clazz == vm->byteReflectClass)\n+\t\tresult = 'B';\n+\telse if (clazz == vm->charReflectClass)\n+\t\tresult = 'C';\n+\telse if (clazz == vm->shortReflectClass)\n+\t\tresult = 'S';\n+\telse if (clazz == vm->intReflectClass)\n+\t\tresult = 'I';\n+\telse if (clazz == vm->longReflectClass)\n+\t\tresult = 'J';\n+\telse if (clazz == vm->floatReflectClass)\n+\t\tresult = 'F';\n+\telse if (clazz == vm->doubleReflectClass)\n+\t\tresult = 'D';\n+\telse if (clazz == vm->voidReflectClass)\n+\t\tresult = 'V';\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2 * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass))\n+\t{\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[')\n+\t\tlength += 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDgxNTU1OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToxNDo1OFrOHyJ7Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwNTo0NDo1NVrOH6xsAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1MzQ4Nw==", "bodyText": "This is really allocation heavy code.  Can the sizes be calculated up front and then the signatures written into a single allocation?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r522353487", "createdAt": "2020-11-12T19:14:58Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass)\n+\t\tresult = 'Z';\n+\telse if (clazz == vm->byteReflectClass)\n+\t\tresult = 'B';\n+\telse if (clazz == vm->charReflectClass)\n+\t\tresult = 'C';\n+\telse if (clazz == vm->shortReflectClass)\n+\t\tresult = 'S';\n+\telse if (clazz == vm->intReflectClass)\n+\t\tresult = 'I';\n+\telse if (clazz == vm->longReflectClass)\n+\t\tresult = 'J';\n+\telse if (clazz == vm->floatReflectClass)\n+\t\tresult = 'F';\n+\telse if (clazz == vm->doubleReflectClass)\n+\t\tresult = 'D';\n+\telse if (clazz == vm->voidReflectClass)\n+\t\tresult = 'V';\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2 * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass))\n+\t{\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[')\n+\t\tlength += 2;\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++)\n+\t\tsig[i] = '[';\n+\tif (*name != '[')\n+\t\tsig[i++] = 'L';\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\tif (*name != '[')\n+\t\tsig[i++] = ';';\n+\n+\tsig[length-1] = '\\0';\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i])\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature)\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTM5MzUzNw==", "bodyText": "Calculating the size would require two passes though the MethodType arguments list, not sure if that is better approach with all the heap object access.\nI will add this to the todo list for performance investigation", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531393537", "createdAt": "2020-11-27T05:44:55Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass)\n+\t\tresult = 'Z';\n+\telse if (clazz == vm->byteReflectClass)\n+\t\tresult = 'B';\n+\telse if (clazz == vm->charReflectClass)\n+\t\tresult = 'C';\n+\telse if (clazz == vm->shortReflectClass)\n+\t\tresult = 'S';\n+\telse if (clazz == vm->intReflectClass)\n+\t\tresult = 'I';\n+\telse if (clazz == vm->longReflectClass)\n+\t\tresult = 'J';\n+\telse if (clazz == vm->floatReflectClass)\n+\t\tresult = 'F';\n+\telse if (clazz == vm->doubleReflectClass)\n+\t\tresult = 'D';\n+\telse if (clazz == vm->voidReflectClass)\n+\t\tresult = 'V';\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2 * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass))\n+\t{\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[')\n+\t\tlength += 2;\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++)\n+\t\tsig[i] = '[';\n+\tif (*name != '[')\n+\t\tsig[i++] = 'L';\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\tif (*name != '[')\n+\t\tsig[i++] = ';';\n+\n+\tsig[length-1] = '\\0';\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i])\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature)\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1MzQ4Nw=="}, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDgyNDAwOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToxNzoyOFrOHyKAog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToxNzoyOFrOHyKAog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1NDg1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tinitStatus = jlrFieldClass->initializeStatus;\n          \n          \n            \n            \tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA) vmThread) {\n          \n          \n            \n            \tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r522354850", "createdAt": "2020-11-12T19:17:28Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass)\n+\t\tresult = 'Z';\n+\telse if (clazz == vm->byteReflectClass)\n+\t\tresult = 'B';\n+\telse if (clazz == vm->charReflectClass)\n+\t\tresult = 'C';\n+\telse if (clazz == vm->shortReflectClass)\n+\t\tresult = 'S';\n+\telse if (clazz == vm->intReflectClass)\n+\t\tresult = 'I';\n+\telse if (clazz == vm->longReflectClass)\n+\t\tresult = 'J';\n+\telse if (clazz == vm->floatReflectClass)\n+\t\tresult = 'F';\n+\telse if (clazz == vm->doubleReflectClass)\n+\t\tresult = 'D';\n+\telse if (clazz == vm->voidReflectClass)\n+\t\tresult = 'V';\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2 * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass))\n+\t{\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[')\n+\t\tlength += 2;\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++)\n+\t\tsig[i] = '[';\n+\tif (*name != '[')\n+\t\tsig[i++] = 'L';\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\tif (*name != '[')\n+\t\tsig[i++] = ';';\n+\n+\tsig[length-1] = '\\0';\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i])\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature)\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\tUDATA initStatus;\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tinitStatus = jlrFieldClass->initializeStatus;\n+\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA) vmThread) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 344}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDgyNDYzOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToxNzo0MFrOHyKBAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToxNzo0MFrOHyKBAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1NDk0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tUDATA initStatus;\n          \n          \n            \n            \tUDATA initStatus = 0;", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r522354947", "createdAt": "2020-11-12T19:17:40Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass)\n+\t\tresult = 'Z';\n+\telse if (clazz == vm->byteReflectClass)\n+\t\tresult = 'B';\n+\telse if (clazz == vm->charReflectClass)\n+\t\tresult = 'C';\n+\telse if (clazz == vm->shortReflectClass)\n+\t\tresult = 'S';\n+\telse if (clazz == vm->intReflectClass)\n+\t\tresult = 'I';\n+\telse if (clazz == vm->longReflectClass)\n+\t\tresult = 'J';\n+\telse if (clazz == vm->floatReflectClass)\n+\t\tresult = 'F';\n+\telse if (clazz == vm->doubleReflectClass)\n+\t\tresult = 'D';\n+\telse if (clazz == vm->voidReflectClass)\n+\t\tresult = 'V';\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2 * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass))\n+\t{\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[')\n+\t\tlength += 2;\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++)\n+\t\tsig[i] = '[';\n+\tif (*name != '[')\n+\t\tsig[i++] = 'L';\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\tif (*name != '[')\n+\t\tsig[i++] = ';';\n+\n+\tsig[length-1] = '\\0';\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i])\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature)\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\tUDATA initStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 337}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDgyODcxOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToxODo1NVrOHyKDpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDoxNDoyM1rOH7IaGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1NTYyMg==", "bodyText": "was this duplicated from the reflectHelpers code?  Any reason to make another copy of it?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r522355622", "createdAt": "2020-11-12T19:18:55Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass)\n+\t\tresult = 'Z';\n+\telse if (clazz == vm->byteReflectClass)\n+\t\tresult = 'B';\n+\telse if (clazz == vm->charReflectClass)\n+\t\tresult = 'C';\n+\telse if (clazz == vm->shortReflectClass)\n+\t\tresult = 'S';\n+\telse if (clazz == vm->intReflectClass)\n+\t\tresult = 'I';\n+\telse if (clazz == vm->longReflectClass)\n+\t\tresult = 'J';\n+\telse if (clazz == vm->floatReflectClass)\n+\t\tresult = 'F';\n+\telse if (clazz == vm->doubleReflectClass)\n+\t\tresult = 'D';\n+\telse if (clazz == vm->voidReflectClass)\n+\t\tresult = 'V';\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2 * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass))\n+\t{\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[')\n+\t\tlength += 2;\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++)\n+\t\tsig[i] = '[';\n+\tif (*name != '[')\n+\t\tsig[i++] = 'L';\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\tif (*name != '[')\n+\t\tsig[i++] = ';';\n+\n+\tsig[length-1] = '\\0';\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i])\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature)\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 329}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTM5NTA5NQ==", "bodyText": "I wasn't sure if I should expand the reflection function table to export this API as this will be the single place to use it outside of reflecthelp.c, so I made the copy.", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531395095", "createdAt": "2020-11-27T05:51:11Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass)\n+\t\tresult = 'Z';\n+\telse if (clazz == vm->byteReflectClass)\n+\t\tresult = 'B';\n+\telse if (clazz == vm->charReflectClass)\n+\t\tresult = 'C';\n+\telse if (clazz == vm->shortReflectClass)\n+\t\tresult = 'S';\n+\telse if (clazz == vm->intReflectClass)\n+\t\tresult = 'I';\n+\telse if (clazz == vm->longReflectClass)\n+\t\tresult = 'J';\n+\telse if (clazz == vm->floatReflectClass)\n+\t\tresult = 'F';\n+\telse if (clazz == vm->doubleReflectClass)\n+\t\tresult = 'D';\n+\telse if (clazz == vm->voidReflectClass)\n+\t\tresult = 'V';\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2 * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass))\n+\t{\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[')\n+\t\tlength += 2;\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++)\n+\t\tsig[i] = '[';\n+\tif (*name != '[')\n+\t\tsig[i++] = 'L';\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\tif (*name != '[')\n+\t\tsig[i++] = ';';\n+\n+\tsig[length-1] = '\\0';\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i])\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature)\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1NTYyMg=="}, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 329}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc2NTc4NA==", "bodyText": "Better to expand the table than to have to maintain a duplicate of the code.  Otherwise, it's easy to miss updating one of the two places if we find a bug", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531765784", "createdAt": "2020-11-27T20:14:23Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1434 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass)\n+\t\tresult = 'Z';\n+\telse if (clazz == vm->byteReflectClass)\n+\t\tresult = 'B';\n+\telse if (clazz == vm->charReflectClass)\n+\t\tresult = 'C';\n+\telse if (clazz == vm->shortReflectClass)\n+\t\tresult = 'S';\n+\telse if (clazz == vm->intReflectClass)\n+\t\tresult = 'I';\n+\telse if (clazz == vm->longReflectClass)\n+\t\tresult = 'J';\n+\telse if (clazz == vm->floatReflectClass)\n+\t\tresult = 'F';\n+\telse if (clazz == vm->doubleReflectClass)\n+\t\tresult = 'D';\n+\telse if (clazz == vm->voidReflectClass)\n+\t\tresult = 'V';\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2 * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass))\n+\t{\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[')\n+\t\tlength += 2;\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++)\n+\t\tsig[i] = '[';\n+\tif (*name != '[')\n+\t\tsig[i++] = 'L';\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\tif (*name != '[')\n+\t\tsig[i++] = ';';\n+\n+\tsig[length-1] = '\\0';\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i])\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature)\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1NTYyMg=="}, "originalCommit": {"oid": "e6878d75292ead9c0dede0eaa70f9a81127060e1"}, "originalPosition": 329}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDk3NjExOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/uma/java_lang_invoke_MethodHandleNatives_exports.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjoxOToxN1rOH7DdqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjoxOToxN1rOH7DdqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4NDc3Nw==", "bodyText": "Nitpick: overly indented inner code\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_init\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_expand\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_resolve\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_getMembers\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_staticFieldBase\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetNormal\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetVolatile\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_copyOutBootstrapArguments\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_clearCallSiteContext\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_getNamedCon\" />\n          \n          \n            \n            \t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_registerNatives\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_init\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_expand\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_resolve\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_getMembers\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_staticFieldBase\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetNormal\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetVolatile\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_copyOutBootstrapArguments\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_clearCallSiteContext\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_getNamedCon\" />\n          \n          \n            \n            \t<export name=\"Java_java_lang_invoke_MethodHandleNatives_registerNatives\" />", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531684777", "createdAt": "2020-11-27T16:19:17Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/uma/java_lang_invoke_MethodHandleNatives_exports.xml", "diffHunk": "@@ -0,0 +1,36 @@\n+<!-- \n+\tCopyright (c) 2020, 2020 IBM Corp. and others\n+\t\n+\tThis program and the accompanying materials are made available under\n+\tthe terms of the Eclipse Public License 2.0 which accompanies this\n+\tdistribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+\tor the Apache License, Version 2.0 which accompanies this distribution and\n+\tis available at https://www.apache.org/licenses/LICENSE-2.0.\n+\t\n+\tThis Source Code may also be made available under the following\n+\tSecondary Licenses when the conditions for such availability set\n+\tforth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+\tGeneral Public License, version 2 with the GNU Classpath\n+\tException [1] and GNU General Public License, version 2 with the\n+\tOpenJDK Assembly Exception [2].\n+\t\n+\t[1] https://www.gnu.org/software/classpath/license.html\n+\t[2] http://openjdk.java.net/legal/assembly-exception.html\n+\tSPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+-->\n+<exports group=\"java_lang_invoke_MethodHandleNatives\">\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_init\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_expand\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_resolve\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_getMembers\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_staticFieldBase\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetNormal\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetVolatile\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_copyOutBootstrapArguments\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_clearCallSiteContext\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_getNamedCon\" />\n+\t\t<export name=\"Java_java_lang_invoke_MethodHandleNatives_registerNatives\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDk4MTI0OnYy", "diffSide": "RIGHT", "path": "runtime/oti/jclprots.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjoyMTowOFrOH7DgtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjoyMTowOFrOH7DgtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4NTU1Ng==", "bodyText": "Shouldn't these be #if define(....OPENJDK_METHODHANDLES) ?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531685556", "createdAt": "2020-11-27T16:21:08Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/jclprots.h", "diffHunk": "@@ -943,6 +943,22 @@ extern J9_CFUNC void JNICALL\n Java_java_lang_invoke_MethodHandleNatives_checkClassBytes(JNIEnv *env, jclass jlClass, jbyteArray classRep);\n #endif /* JAVA_SPEC_VERSION >= 15 */\n \n+/* java_lang_invoke_MethodHandleNatives.cpp */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDk5ODM1OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjoyNzozNVrOH7Dq_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjoyNzozNVrOH7Dq_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODE5MQ==", "bodyText": "This needs an implementation or we'll fail to start when java assertions (-ea) are enabled.  @fengxue-IS can you create a issue to track implementing this?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531688191", "createdAt": "2020-11-27T16:27:35Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (clazzObject == NULL) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, clazzObject, callerObject, nameObject, typeObject, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\tint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\t\t\tUDATA nameLength = vmFuncs->getStringUTF8Length(currentThread, nameObject) + 1;\n+\t\t\tchar *name = (char*)j9mem_allocate_memory(nameLength, OMRMEM_CATEGORY_VM);\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignatureLength = vmFuncs->getStringUTF8Length(currentThread, sigString) + 1;\n+\t\t\t\t\tsignature = (char*)j9mem_allocate_memory(signatureLength, OMRMEM_CATEGORY_VM);\n+\t\t\t\t\tvmFuncs->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT , 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8 *)signature, signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignatureLength = vmFuncs->getStringUTF8Length(currentThread, typeObject) + 1;\n+\t\t\t\tsignature = (char*)j9mem_allocate_memory(signatureLength, OMRMEM_CATEGORY_VM);\n+\t\t\t\tUDATA stringLength = J9VMJAVALANGSTRING_LENGTH(currentThread, typeObject);\n+\t\t\t\tvmFuncs->copyStringToUTF8Helper(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT , 0, stringLength, (U_8 *)signature, signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = sigForPrimitiveOrVoid(vm, rclass);\n+\t\t\t\tif (!signature) {\n+\t\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\t}\n+\n+\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tvmFuncs->internalExitVMToJNI(currentThread);\n+\t\t\t\treturn NULL;\n+\t\t\t}\n+\t\t\tvmFuncs->copyStringToUTF8Helper(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT , 0, J9VMJAVALANGSTRING_LENGTH(currentThread, nameObject), (U_8 *)name, nameLength);\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)strlen(name);\n+\t\t\t\tnas.signatureLength = (U_32)strlen(signature);\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results)) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\tj9object_t nameObject = ((NULL == matchName) ? NULL : J9_JNI_UNWRAP_REFERENCE(matchName));\n+\t\tj9object_t sigObject = ((NULL == matchSig) ? NULL : J9_JNI_UNWRAP_REFERENCE(matchSig));\n+\t\t// j9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\t\tif (NULL == defcObject) {\n+\t\t\tresult = -1;\n+\t\t} else if (!(((NULL != matchName) && (NULL == nameObject)) || ((NULL != matchSig) && (NULL == sigObject)))) {\n+\t\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\t\t\tif (!((NULL != nameObject) && (0 == J9VMJAVALANGSTRING_LENGTH(currentThread, nameObject)))) {\n+\t\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\t\tresult = -1;\n+\t\t\t\t} else {\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\t\t\t\t\t\t\t\tif (((NULL == nameObject) || (0 != vmFuncs->compareStringToUTF8(currentThread, nameObject, FALSE, J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF))))\n+\t\t\t\t\t\t\t\t&& ((NULL != sigObject) && (0 == vmFuncs->compareStringToUTF8(currentThread, sigObject, FALSE, J9UTF8_DATA(signatureUTF), J9UTF8_LENGTH(signatureUTF))))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tvmFuncs->internalExitVMToJNI(currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\treturn -99;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (romField->modifiers & J9AccStatic) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = createFieldObject(currentThread, romField, defClass, nameUTF, signatureUTF, true);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create instance field object */\n+\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = createFieldObject(currentThread, romField, defClass, nameUTF, signatureUTF, false);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\t\t\t\t\t\t\t\t\tif (((NULL == nameObject) || (0 != vmFuncs->compareStringToUTF8(currentThread, nameObject, FALSE, J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF))))\n+\t\t\t\t\t\t\t\t\t&& ((NULL != sigObject) && (0 == vmFuncs->compareStringToUTF8(currentThread, sigObject, FALSE, J9UTF8_DATA(signatureUTF), J9UTF8_LENGTH(signatureUTF))))\n+\t\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tvmFuncs->internalExitVMToJNI(currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t\treturn -99;\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tif (romField->modifiers & J9AccStatic) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = createFieldObject(currentThread, romField, defClass, nameUTF, signatureUTF, true);\n+\t\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create instance field object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = createFieldObject(currentThread, romField, defClass, nameUTF, signatureUTF, false);\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t\tif (!J9ROMCLASS_IS_PRIMITIVE_OR_ARRAY(currentClass->romClass)) {\n+\t\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\t\tif (((NULL == nameObject) || (0 != vmFuncs->compareStringToUTF8(currentThread, nameObject, FALSE, J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF))))\n+\t\t\t\t\t\t\t\t\t&& ((NULL != sigObject) && (0 == vmFuncs->compareStringToUTF8(currentThread, sigObject, FALSE, J9UTF8_DATA(signatureUTF), J9UTF8_LENGTH(signatureUTF))))\n+\t\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tvmFuncs->internalExitVMToJNI(currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t\treturn -99;\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\t\tJ9Class *currentClass = currentITable->interfaceClass;\n+\t\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\t\tif (((NULL == nameObject) || (0 != vmFuncs->compareStringToUTF8(currentThread, nameObject, FALSE, J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF))))\n+\t\t\t\t\t\t\t\t\t&& ((NULL != sigObject) && (0 == vmFuncs->compareStringToUTF8(currentThread, sigObject, FALSE, J9UTF8_DATA(signatureUTF), J9UTF8_LENGTH(signatureUTF))))\n+\t\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tvmFuncs->internalExitVMToJNI(currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t\treturn -99;\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long objectFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the objectFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.objectFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD) && J9_ARE_NO_BITS_SET(flags, J9AccStatic)) {\n+\t\t\t\tJ9JNIFieldID *fieldID = (J9JNIFieldID*)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tresult = (jlong)fieldID->offset + J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long staticFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the staticFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object staticFieldBase(MemberName self);  // e.g., returns clazz\n+ * \n+ * Returns the staticFieldBase of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldBase with the actual field object\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldBase(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjobject result = NULL;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object getMemberVMInfo(MemberName self);  // returns {vmindex,vmtarget}\n+ * \n+ * Return a 2-element java array containing the vm offset/target data\n+ * For a field MemberName, array contains:\n+ * \t\t(field offset, declaring class)\n+ * For a method MemberName, array contains:\n+ * \t\t(vtable index, MemberName object)\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Entry(env, self);\n+\tif (NULL != self) {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tj9object_t target;\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\tvmindex = ((J9JNIFieldID*)vmindex)->offset;\n+\t\t\ttarget = clazzObject;\n+\t\t} else {\n+\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\t\tvmindex = methodID->vTableIndex & ~J9_JNI_MID_INTERFACE;\n+\t\t\t} else if (0 == methodID->vTableIndex) {\n+\t\t\t\tvmindex = -1;\n+\t\t\t} else {\n+\t\t\t\tvmindex = methodID->vTableIndex;\n+\t\t\t}\n+\t\t\ttarget = membernameObject;\n+\t\t}\n+\n+\t\tj9object_t box = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, box, vmindex);\n+\n+\t\tJ9Class *arrayClass = fetchArrayClass(currentThread, J9VMJAVALANGOBJECT(vm));\n+\t\tj9object_t arrayObject = vm->memoryManagerFunctions->J9AllocateIndexableObject(currentThread, arrayClass, 2, J9_GC_ALLOCATE_OBJECT_INSTRUMENTABLE);\n+\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, box);\n+\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, target);\n+\n+\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+\n+}\n+\n+/**\n+ * static native void setCallSiteTargetNormal(CallSite site, MethodHandle target)\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetNormal(JNIEnv *env, jclass clazz, jobject callsite, jobject target)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == callsite) || (NULL == target)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t callsiteObject = J9_JNI_UNWRAP_REFERENCE(callsite);\n+\t\tj9object_t targetObject = J9_JNI_UNWRAP_REFERENCE(target);\n+\n+\t\tUDATA offset = (UDATA)vmFuncs->instanceFieldOffset(currentThread, J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callsiteObject), (U_8*)\"target\", strlen(\"target\"),  (U_8*)\"Ljava/lang/invoke/MethodHandle;\", strlen(\"Ljava/lang/invoke/MethodHandle;\"), NULL, NULL, 0);\n+\t\tMM_ObjectAccessBarrierAPI objectAccessBarrier = MM_ObjectAccessBarrierAPI(currentThread);\n+\t\tobjectAccessBarrier.inlineMixedObjectStoreObject(currentThread, callsiteObject, offset, targetObject, false);\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void setCallSiteTargetVolatile(CallSite site, MethodHandle target);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetVolatile(JNIEnv *env, jclass clazz, jobject callsite, jobject target)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == callsite) || (NULL == target)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t callsiteObject = J9_JNI_UNWRAP_REFERENCE(callsite);\n+\t\tj9object_t targetObject = J9_JNI_UNWRAP_REFERENCE(target);\n+\n+\t\tUDATA offset = (UDATA)vmFuncs->instanceFieldOffset(currentThread, J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callsiteObject), (U_8*)\"target\", strlen(\"target\"), (U_8*)\"Ljava/lang/invoke/MethodHandle;\", strlen(\"Ljava/lang/invoke/MethodHandle;\"), NULL, NULL, 0);\n+\t\tMM_ObjectAccessBarrierAPI objectAccessBarrier = MM_ObjectAccessBarrierAPI(currentThread);\n+\t\tobjectAccessBarrier.inlineMixedObjectStoreObject(currentThread, callsiteObject, offset, targetObject, true);\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void copyOutBootstrapArguments(Class<?> caller, int[] indexInfo,\n+\t\t\t\t\t\t\t\t\t\t\t\tint start, int end,\n+\t\t\t\t\t\t\t\t\t\t\t\tObject[] buf, int pos,\n+\t\t\t\t\t\t\t\t\t\t\t\tboolean resolve,\n+\t\t\t\t\t\t\t\t\t\t\t\tObject ifNotAvailable);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_copyOutBootstrapArguments(JNIEnv *env, jclass clazz, jclass caller, jintArray indexInfo, jint start, jint end, jobjectArray buf, jint pos, jboolean resolve, jobject ifNotAvailable)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == caller) || (NULL == indexInfo) || (NULL == buf)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_JCLASS(currentThread, caller);\n+\t\tj9array_t indexInfoArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(indexInfo);\n+\t\tj9array_t bufferArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(buf);\n+\n+\t\tif ((NULL == callerClass) || (NULL == indexInfoArray) || (NULL == bufferArray) || (J9INDEXABLEOBJECT_SIZE(currentThread, indexInfoArray) < 2)) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else if (((start < -4) || (start > end) || (pos < 0)) || ((jint)J9INDEXABLEOBJECT_SIZE(currentThread, bufferArray) <= pos) || ((jint)J9INDEXABLEOBJECT_SIZE(currentThread, bufferArray) <= (pos + end - start))) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t} else {\n+\t\t\t// U_16 bsmArgCount = (U_16)J9JAVAARRAYOFINT_LOAD(currentThread, indexInfoArray, 0);\n+\t\t\tU_16 cpIndex = (U_16)J9JAVAARRAYOFINT_LOAD(currentThread, indexInfoArray, 1);\n+\t\t\tJ9ROMClass *romClass = callerClass->romClass;\n+\t\t\tU_32 * cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(romClass);\n+\t\t\tif (J9_CP_TYPE(cpShapeDescription, cpIndex) == J9CPTYPE_CONSTANT_DYNAMIC) {\n+\t\t\t\tJ9ROMConstantDynamicRef *romConstantRef = (J9ROMConstantDynamicRef*)(J9_ROM_CP_FROM_ROM_CLASS(romClass) + cpIndex);\n+\t\t\t\tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n+\t\t\t\tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n+\t\t\t\tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n+\n+\t\t\t\t/* clear the J9DescriptionCpPrimitiveType flag with mask to get bsmIndex */\n+\t\t\t\tU_32 bsmIndex = (romConstantRef->bsmIndexAndCpType >> J9DescriptionCpTypeShift) & J9DescriptionCpBsmIndexMask;\n+\t\t\t\tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(&romConstantRef->nameAndSignature, J9ROMNameAndSignature*);\n+\n+\t\t\t\t/* Walk bsmData - skip all bootstrap methods before bsmIndex */\n+\t\t\t\tfor (U_32 i = 0; i < bsmIndex; i++) {\n+\t\t\t\t\t/* increment by size of bsm data plus header */\n+\t\t\t\t\tbsmData += (bsmData[1] + 2);\n+\t\t\t\t}\n+\n+\t\t\t\tU_16 bsmCPIndex = bsmData[0];\n+\t\t\t\tU_16 argCount = bsmData[1];\n+\t\t\t\tbsmData += 2;\n+\n+\t\t\t\tj9object_t obj;\n+\t\t\t\tj9object_t ifNotAvailableObject = NULL;\n+\t\t\t\tif (NULL != ifNotAvailable) {\n+\t\t\t\t\tifNotAvailableObject = J9_JNI_UNWRAP_REFERENCE(ifNotAvailable);\n+\t\t\t\t}\n+\t\t\t\twhile (start < end) {\n+\t\t\t\t\t/* Copy the arguments between start and end to the buf array\n+\t\t\t\t\t *\n+\t\t\t\t\t * Negative start index refer to the mandatory arguments for a bootstrap method\n+\t\t\t\t\t * -4 -> Lookup\n+\t\t\t\t\t * -3 -> name (String)\n+\t\t\t\t\t * -2 -> signature (MethodType)\n+\t\t\t\t\t * -1 -> argCount of optional arguments\n+\t\t\t\t\t */\n+\t\t\t\t\tobj = NULL;\n+\t\t\t\t\tif (start >= 0) {\n+\t\t\t\t\t\tU_16 argIndex = bsmData[start];\n+\t\t\t\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_CLASS(callerClass);\n+\t\t\t\t\t\tobj = resolveRefToObject(currentThread, ramConstantPool, argIndex, (JNI_TRUE == resolve));\n+\t\t\t\t\t\tif ((NULL == obj) && (JNI_TRUE != resolve)) {\n+\t\t\t\t\t\t\tobj = ifNotAvailableObject;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (start == -4) {\n+\t\t\t\t\t\tobj = resolveRefToObject(currentThread, J9_CP_FROM_CLASS(callerClass), bsmCPIndex, true);\n+\t\t\t\t\t} else if (start == -3) {\n+\t\t\t\t\t\tJ9UTF8 *name = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n+\t\t\t\t\t\tobj = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\t} else if (start == -2) {\n+\t\t\t\t\t\tJ9UTF8 *signature = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n+\t\t\t\t\t\t/* Call VM Entry point to create the MethodType - Result is put into the\n+\t\t\t\t\t\t* currentThread->returnValue as entry points don't \"return\" in the expected way\n+\t\t\t\t\t\t*/\n+\t\t\t\t\t\tvmFuncs->sendFromMethodDescriptorString(currentThread, signature, callerClass->classLoader, NULL);\n+\t\t\t\t\t\tobj = (j9object_t)currentThread->returnValue;\n+\t\t\t\t\t} else if (start == -1) {\n+\t\t\t\t\t\tobj = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\t\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, obj, argCount);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, bufferArray, pos, obj);\n+\t\t\t\t\tstart += 1;\n+\t\t\t\t\tpos += 1;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * private static native void clearCallSiteContext(CallSiteContext context);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_clearCallSiteContext(JNIEnv *env, jclass clazz, jobject context)\n+{\n+\treturn;\n+}\n+\n+/**\n+ * private static native int getNamedCon(int which, Object[] name);\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getNamedCon(JNIEnv *env, jclass clazz, jint which, jobjectArray name)\n+{\n+\treturn 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 1523}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTAwMTgyOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjoyOTowNlrOH7DtHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjoyOTowNlrOH7DtHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODczNA==", "bodyText": "Why export the functions and make all the prototype changes to different headers rather than using the registerNatives function?  Given we're going to have to call it, using it would seem worthwhile....", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531688734", "createdAt": "2020-11-27T16:29:06Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (clazzObject == NULL) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, clazzObject, callerObject, nameObject, typeObject, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\tint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\t\t\tUDATA nameLength = vmFuncs->getStringUTF8Length(currentThread, nameObject) + 1;\n+\t\t\tchar *name = (char*)j9mem_allocate_memory(nameLength, OMRMEM_CATEGORY_VM);\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignatureLength = vmFuncs->getStringUTF8Length(currentThread, sigString) + 1;\n+\t\t\t\t\tsignature = (char*)j9mem_allocate_memory(signatureLength, OMRMEM_CATEGORY_VM);\n+\t\t\t\t\tvmFuncs->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT , 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8 *)signature, signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignatureLength = vmFuncs->getStringUTF8Length(currentThread, typeObject) + 1;\n+\t\t\t\tsignature = (char*)j9mem_allocate_memory(signatureLength, OMRMEM_CATEGORY_VM);\n+\t\t\t\tUDATA stringLength = J9VMJAVALANGSTRING_LENGTH(currentThread, typeObject);\n+\t\t\t\tvmFuncs->copyStringToUTF8Helper(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT , 0, stringLength, (U_8 *)signature, signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = sigForPrimitiveOrVoid(vm, rclass);\n+\t\t\t\tif (!signature) {\n+\t\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\t}\n+\n+\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tvmFuncs->internalExitVMToJNI(currentThread);\n+\t\t\t\treturn NULL;\n+\t\t\t}\n+\t\t\tvmFuncs->copyStringToUTF8Helper(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT , 0, J9VMJAVALANGSTRING_LENGTH(currentThread, nameObject), (U_8 *)name, nameLength);\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)strlen(name);\n+\t\t\t\tnas.signatureLength = (U_32)strlen(signature);\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results)) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\tj9object_t nameObject = ((NULL == matchName) ? NULL : J9_JNI_UNWRAP_REFERENCE(matchName));\n+\t\tj9object_t sigObject = ((NULL == matchSig) ? NULL : J9_JNI_UNWRAP_REFERENCE(matchSig));\n+\t\t// j9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\t\tif (NULL == defcObject) {\n+\t\t\tresult = -1;\n+\t\t} else if (!(((NULL != matchName) && (NULL == nameObject)) || ((NULL != matchSig) && (NULL == sigObject)))) {\n+\t\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\t\t\tif (!((NULL != nameObject) && (0 == J9VMJAVALANGSTRING_LENGTH(currentThread, nameObject)))) {\n+\t\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\t\tresult = -1;\n+\t\t\t\t} else {\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\t\t\t\t\t\t\t\tif (((NULL == nameObject) || (0 != vmFuncs->compareStringToUTF8(currentThread, nameObject, FALSE, J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF))))\n+\t\t\t\t\t\t\t\t&& ((NULL != sigObject) && (0 == vmFuncs->compareStringToUTF8(currentThread, sigObject, FALSE, J9UTF8_DATA(signatureUTF), J9UTF8_LENGTH(signatureUTF))))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tvmFuncs->internalExitVMToJNI(currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\treturn -99;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (romField->modifiers & J9AccStatic) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = createFieldObject(currentThread, romField, defClass, nameUTF, signatureUTF, true);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create instance field object */\n+\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = createFieldObject(currentThread, romField, defClass, nameUTF, signatureUTF, false);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\t\t\t\t\t\t\t\t\tif (((NULL == nameObject) || (0 != vmFuncs->compareStringToUTF8(currentThread, nameObject, FALSE, J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF))))\n+\t\t\t\t\t\t\t\t\t&& ((NULL != sigObject) && (0 == vmFuncs->compareStringToUTF8(currentThread, sigObject, FALSE, J9UTF8_DATA(signatureUTF), J9UTF8_LENGTH(signatureUTF))))\n+\t\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tvmFuncs->internalExitVMToJNI(currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t\treturn -99;\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tif (romField->modifiers & J9AccStatic) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = createFieldObject(currentThread, romField, defClass, nameUTF, signatureUTF, true);\n+\t\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create instance field object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = createFieldObject(currentThread, romField, defClass, nameUTF, signatureUTF, false);\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t\tif (!J9ROMCLASS_IS_PRIMITIVE_OR_ARRAY(currentClass->romClass)) {\n+\t\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\t\tif (((NULL == nameObject) || (0 != vmFuncs->compareStringToUTF8(currentThread, nameObject, FALSE, J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF))))\n+\t\t\t\t\t\t\t\t\t&& ((NULL != sigObject) && (0 == vmFuncs->compareStringToUTF8(currentThread, sigObject, FALSE, J9UTF8_DATA(signatureUTF), J9UTF8_LENGTH(signatureUTF))))\n+\t\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tvmFuncs->internalExitVMToJNI(currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t\treturn -99;\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\t\tJ9Class *currentClass = currentITable->interfaceClass;\n+\t\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\t\tif (((NULL == nameObject) || (0 != vmFuncs->compareStringToUTF8(currentThread, nameObject, FALSE, J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF))))\n+\t\t\t\t\t\t\t\t\t&& ((NULL != sigObject) && (0 == vmFuncs->compareStringToUTF8(currentThread, sigObject, FALSE, J9UTF8_DATA(signatureUTF), J9UTF8_LENGTH(signatureUTF))))\n+\t\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tvmFuncs->internalExitVMToJNI(currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t\treturn -99;\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long objectFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the objectFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.objectFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD) && J9_ARE_NO_BITS_SET(flags, J9AccStatic)) {\n+\t\t\t\tJ9JNIFieldID *fieldID = (J9JNIFieldID*)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tresult = (jlong)fieldID->offset + J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long staticFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the staticFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object staticFieldBase(MemberName self);  // e.g., returns clazz\n+ * \n+ * Returns the staticFieldBase of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldBase with the actual field object\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldBase(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjobject result = NULL;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object getMemberVMInfo(MemberName self);  // returns {vmindex,vmtarget}\n+ * \n+ * Return a 2-element java array containing the vm offset/target data\n+ * For a field MemberName, array contains:\n+ * \t\t(field offset, declaring class)\n+ * For a method MemberName, array contains:\n+ * \t\t(vtable index, MemberName object)\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Entry(env, self);\n+\tif (NULL != self) {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tj9object_t target;\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\tvmindex = ((J9JNIFieldID*)vmindex)->offset;\n+\t\t\ttarget = clazzObject;\n+\t\t} else {\n+\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\t\tvmindex = methodID->vTableIndex & ~J9_JNI_MID_INTERFACE;\n+\t\t\t} else if (0 == methodID->vTableIndex) {\n+\t\t\t\tvmindex = -1;\n+\t\t\t} else {\n+\t\t\t\tvmindex = methodID->vTableIndex;\n+\t\t\t}\n+\t\t\ttarget = membernameObject;\n+\t\t}\n+\n+\t\tj9object_t box = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, box, vmindex);\n+\n+\t\tJ9Class *arrayClass = fetchArrayClass(currentThread, J9VMJAVALANGOBJECT(vm));\n+\t\tj9object_t arrayObject = vm->memoryManagerFunctions->J9AllocateIndexableObject(currentThread, arrayClass, 2, J9_GC_ALLOCATE_OBJECT_INSTRUMENTABLE);\n+\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, box);\n+\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, target);\n+\n+\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+\n+}\n+\n+/**\n+ * static native void setCallSiteTargetNormal(CallSite site, MethodHandle target)\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetNormal(JNIEnv *env, jclass clazz, jobject callsite, jobject target)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == callsite) || (NULL == target)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t callsiteObject = J9_JNI_UNWRAP_REFERENCE(callsite);\n+\t\tj9object_t targetObject = J9_JNI_UNWRAP_REFERENCE(target);\n+\n+\t\tUDATA offset = (UDATA)vmFuncs->instanceFieldOffset(currentThread, J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callsiteObject), (U_8*)\"target\", strlen(\"target\"),  (U_8*)\"Ljava/lang/invoke/MethodHandle;\", strlen(\"Ljava/lang/invoke/MethodHandle;\"), NULL, NULL, 0);\n+\t\tMM_ObjectAccessBarrierAPI objectAccessBarrier = MM_ObjectAccessBarrierAPI(currentThread);\n+\t\tobjectAccessBarrier.inlineMixedObjectStoreObject(currentThread, callsiteObject, offset, targetObject, false);\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void setCallSiteTargetVolatile(CallSite site, MethodHandle target);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetVolatile(JNIEnv *env, jclass clazz, jobject callsite, jobject target)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == callsite) || (NULL == target)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t callsiteObject = J9_JNI_UNWRAP_REFERENCE(callsite);\n+\t\tj9object_t targetObject = J9_JNI_UNWRAP_REFERENCE(target);\n+\n+\t\tUDATA offset = (UDATA)vmFuncs->instanceFieldOffset(currentThread, J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callsiteObject), (U_8*)\"target\", strlen(\"target\"), (U_8*)\"Ljava/lang/invoke/MethodHandle;\", strlen(\"Ljava/lang/invoke/MethodHandle;\"), NULL, NULL, 0);\n+\t\tMM_ObjectAccessBarrierAPI objectAccessBarrier = MM_ObjectAccessBarrierAPI(currentThread);\n+\t\tobjectAccessBarrier.inlineMixedObjectStoreObject(currentThread, callsiteObject, offset, targetObject, true);\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void copyOutBootstrapArguments(Class<?> caller, int[] indexInfo,\n+\t\t\t\t\t\t\t\t\t\t\t\tint start, int end,\n+\t\t\t\t\t\t\t\t\t\t\t\tObject[] buf, int pos,\n+\t\t\t\t\t\t\t\t\t\t\t\tboolean resolve,\n+\t\t\t\t\t\t\t\t\t\t\t\tObject ifNotAvailable);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_copyOutBootstrapArguments(JNIEnv *env, jclass clazz, jclass caller, jintArray indexInfo, jint start, jint end, jobjectArray buf, jint pos, jboolean resolve, jobject ifNotAvailable)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == caller) || (NULL == indexInfo) || (NULL == buf)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_JCLASS(currentThread, caller);\n+\t\tj9array_t indexInfoArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(indexInfo);\n+\t\tj9array_t bufferArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(buf);\n+\n+\t\tif ((NULL == callerClass) || (NULL == indexInfoArray) || (NULL == bufferArray) || (J9INDEXABLEOBJECT_SIZE(currentThread, indexInfoArray) < 2)) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else if (((start < -4) || (start > end) || (pos < 0)) || ((jint)J9INDEXABLEOBJECT_SIZE(currentThread, bufferArray) <= pos) || ((jint)J9INDEXABLEOBJECT_SIZE(currentThread, bufferArray) <= (pos + end - start))) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t} else {\n+\t\t\t// U_16 bsmArgCount = (U_16)J9JAVAARRAYOFINT_LOAD(currentThread, indexInfoArray, 0);\n+\t\t\tU_16 cpIndex = (U_16)J9JAVAARRAYOFINT_LOAD(currentThread, indexInfoArray, 1);\n+\t\t\tJ9ROMClass *romClass = callerClass->romClass;\n+\t\t\tU_32 * cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(romClass);\n+\t\t\tif (J9_CP_TYPE(cpShapeDescription, cpIndex) == J9CPTYPE_CONSTANT_DYNAMIC) {\n+\t\t\t\tJ9ROMConstantDynamicRef *romConstantRef = (J9ROMConstantDynamicRef*)(J9_ROM_CP_FROM_ROM_CLASS(romClass) + cpIndex);\n+\t\t\t\tJ9SRP *callSiteData = (J9SRP *) J9ROMCLASS_CALLSITEDATA(romClass);\n+\t\t\t\tU_16 *bsmIndices = (U_16 *) (callSiteData + romClass->callSiteCount);\n+\t\t\t\tU_16 *bsmData = bsmIndices + romClass->callSiteCount;\n+\n+\t\t\t\t/* clear the J9DescriptionCpPrimitiveType flag with mask to get bsmIndex */\n+\t\t\t\tU_32 bsmIndex = (romConstantRef->bsmIndexAndCpType >> J9DescriptionCpTypeShift) & J9DescriptionCpBsmIndexMask;\n+\t\t\t\tJ9ROMNameAndSignature* nameAndSig = SRP_PTR_GET(&romConstantRef->nameAndSignature, J9ROMNameAndSignature*);\n+\n+\t\t\t\t/* Walk bsmData - skip all bootstrap methods before bsmIndex */\n+\t\t\t\tfor (U_32 i = 0; i < bsmIndex; i++) {\n+\t\t\t\t\t/* increment by size of bsm data plus header */\n+\t\t\t\t\tbsmData += (bsmData[1] + 2);\n+\t\t\t\t}\n+\n+\t\t\t\tU_16 bsmCPIndex = bsmData[0];\n+\t\t\t\tU_16 argCount = bsmData[1];\n+\t\t\t\tbsmData += 2;\n+\n+\t\t\t\tj9object_t obj;\n+\t\t\t\tj9object_t ifNotAvailableObject = NULL;\n+\t\t\t\tif (NULL != ifNotAvailable) {\n+\t\t\t\t\tifNotAvailableObject = J9_JNI_UNWRAP_REFERENCE(ifNotAvailable);\n+\t\t\t\t}\n+\t\t\t\twhile (start < end) {\n+\t\t\t\t\t/* Copy the arguments between start and end to the buf array\n+\t\t\t\t\t *\n+\t\t\t\t\t * Negative start index refer to the mandatory arguments for a bootstrap method\n+\t\t\t\t\t * -4 -> Lookup\n+\t\t\t\t\t * -3 -> name (String)\n+\t\t\t\t\t * -2 -> signature (MethodType)\n+\t\t\t\t\t * -1 -> argCount of optional arguments\n+\t\t\t\t\t */\n+\t\t\t\t\tobj = NULL;\n+\t\t\t\t\tif (start >= 0) {\n+\t\t\t\t\t\tU_16 argIndex = bsmData[start];\n+\t\t\t\t\t\tJ9ConstantPool *ramConstantPool = J9_CP_FROM_CLASS(callerClass);\n+\t\t\t\t\t\tobj = resolveRefToObject(currentThread, ramConstantPool, argIndex, (JNI_TRUE == resolve));\n+\t\t\t\t\t\tif ((NULL == obj) && (JNI_TRUE != resolve)) {\n+\t\t\t\t\t\t\tobj = ifNotAvailableObject;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (start == -4) {\n+\t\t\t\t\t\tobj = resolveRefToObject(currentThread, J9_CP_FROM_CLASS(callerClass), bsmCPIndex, true);\n+\t\t\t\t\t} else if (start == -3) {\n+\t\t\t\t\t\tJ9UTF8 *name = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n+\t\t\t\t\t\tobj = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\t} else if (start == -2) {\n+\t\t\t\t\t\tJ9UTF8 *signature = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n+\t\t\t\t\t\t/* Call VM Entry point to create the MethodType - Result is put into the\n+\t\t\t\t\t\t* currentThread->returnValue as entry points don't \"return\" in the expected way\n+\t\t\t\t\t\t*/\n+\t\t\t\t\t\tvmFuncs->sendFromMethodDescriptorString(currentThread, signature, callerClass->classLoader, NULL);\n+\t\t\t\t\t\tobj = (j9object_t)currentThread->returnValue;\n+\t\t\t\t\t} else if (start == -1) {\n+\t\t\t\t\t\tobj = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\t\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, obj, argCount);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, bufferArray, pos, obj);\n+\t\t\t\t\tstart += 1;\n+\t\t\t\t\tpos += 1;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * private static native void clearCallSiteContext(CallSiteContext context);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_clearCallSiteContext(JNIEnv *env, jclass clazz, jobject context)\n+{\n+\treturn;\n+}\n+\n+/**\n+ * private static native int getNamedCon(int which, Object[] name);\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getNamedCon(JNIEnv *env, jclass clazz, jint which, jobjectArray name)\n+{\n+\treturn 0;\n+}\n+\n+/**\n+ * private static native void registerNatives();\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_registerNatives(JNIEnv *env, jclass clazz)\n+{\n+\treturn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 1532}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTAwNzM0OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozMTowOVrOH7DwQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozMTowOVrOH7DwQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4OTUzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n          \n          \n            \n            /* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants \n          \n          \n            \n             * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n          \n          \n            \n             * method when Java assertions are enabled\n          \n          \n            \n             */", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531689539", "createdAt": "2020-11-27T16:31:09Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTAxMTQ1OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozMjo1MVrOH7DysQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozMjo1MVrOH7DysQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5MDE2MQ==", "bodyText": "It would be good to indicate that the mask is shifted by the MN_REFERENCE_KIND_SHIFT", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531690161", "createdAt": "2020-11-27T16:32:51Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTAxODA3OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozNToyN1rOH7D2jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozNToyN1rOH7D2jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5MTE0OQ==", "bodyText": "Formatting\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tif (NULL == self || NULL == ref) {\n          \n          \n            \n            \tif ((NULL == self) || (NULL == ref)) {", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531691149", "createdAt": "2020-11-27T16:35:27Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 600}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTAyMjI5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozNzoxOVrOH7D5NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozNzoxOVrOH7D5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5MTgyOA==", "bodyText": "It's a good habit to mark these pointers as const\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tJ9JavaVM *vm = currentThread->javaVM;\n          \n          \n            \n            \tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n          \n          \n            \n            \tconst J9JavaVM *vm = currentThread->javaVM;\n          \n          \n            \n            \tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531691828", "createdAt": "2020-11-27T16:37:19Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTAyMzU5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozNzo1MlrOH7D6Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozNzo1MlrOH7D6Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5MjAzNA==", "bodyText": "This should state that the caller must have vmaccess", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531692034", "createdAt": "2020-11-27T16:37:52Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTAzNTA4OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjo0MjoxNlrOH7EAeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjo0MjoxNlrOH7EAeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5MzY4OQ==", "bodyText": "Name and Type are only set here for field handles.  Is this deliberate?  Shouldn't methods and constructors also have a name and (method)type?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531693689", "createdAt": "2020-11-27T16:42:16Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTA1NDk1OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjo1MTowNFrOH7EMkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjo1MTowNFrOH7EMkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5Njc4NQ==", "bodyText": "A reflect field already has a name.  Can you reuse it here rather than allocate another copy of it?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n          \n          \n            \n            \t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(vmThread, refObject);", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531696785", "createdAt": "2020-11-27T16:51:04Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTA1ODYwOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjo1MjozM1rOH7EOqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjo1MjozM1rOH7EOqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5NzMyMQ==", "bodyText": "Does typeObject need to be a string or can you set the class directly?  ie:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n          \n          \n            \n            \t\ttypeObject =J9VMJAVALANGREFLECTFIELD_TYPE(vmThread, refObject);", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531697321", "createdAt": "2020-11-27T16:52:33Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTI2MjIzOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODoyOToyOFrOH7GBDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODoyOToyOFrOH7GBDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcyNjYwNw==", "bodyText": "Where does this get used?  Should we be setting it for methods with the @CallerSensitive annotation?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531726607", "createdAt": "2020-11-27T18:29:28Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTI3MzU3OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODozNjowMVrOH7GHYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODozNjowMVrOH7GHYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcyODIyNQ==", "bodyText": "Can you open an issue for tracking how HCR will deal with updating these methodID->method pointers and field pointers that have been embedded in the MemberNames?  We have some code for the old MH implementation that might be adaptable.", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531728225", "createdAt": "2020-11-27T18:36:01Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTI4NTAwOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo0Mjo0NVrOH7GN8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzowNzo1MVrOIP0lRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcyOTkwNw==", "bodyText": "required data can you document what the required data is?\nIf I understand this correctly, expand() takes a MemberName with the VM metadata (target / index) and fills in the symbolic data, while resolve() does the opposite - looking up the VM metadata given the symbolic info.\nIs that correct?  If so please be more explicit in the comments about that duality", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531729907", "createdAt": "2020-11-27T18:42:45Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 618}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI0MzA5MA==", "bodyText": "Any response to this comment?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r545243090", "createdAt": "2020-12-17T16:52:12Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcyOTkwNw=="}, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 618}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ2MTA2MA==", "bodyText": "updated comment", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r553461060", "createdAt": "2021-01-07T17:07:51Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcyOTkwNw=="}, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 618}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTI5MDA5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo0NToyNlrOH7GQqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo0NToyNlrOH7GQqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczMDYwMg==", "bodyText": "Adding some details about which field is null will help service this in the field.", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531730602", "createdAt": "2020-11-27T18:45:26Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 658}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTI5MjA4OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo0NjoyNVrOH7GRtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo0NjoyNVrOH7GRtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczMDg3MA==", "bodyText": "Don't fetch objects here as they will be invalidate by the first GC.  Only attempt to fetch them when you need them", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531730870", "createdAt": "2020-11-27T18:46:25Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 636}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTI5NjEwOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo0OToxM1rOH7GULQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo0OToxM1rOH7GULQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczMTUwMQ==", "bodyText": "Ie, only fetch nameObject here and don't put it in a local as you never use it again\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n          \n          \n            \n            \t\t\t\tif (nameObject == NULL) {\n          \n          \n            \n            \t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n          \n          \n            \n            \t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n          \n          \n            \n            \t\t\t\t}\n          \n          \n            \n            \t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n          \n          \n            \n            \t\t\t\tif (J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject) == NULL) {\n          \n          \n            \n            \t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n          \n          \n            \n            \t\t\t\t\t/* Update memberName as GC may  have occurred */\n          \n          \n            \n            \t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n          \n          \n            \n            \t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n          \n          \n            \n            \t\t\t\t}", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531731501", "createdAt": "2020-11-27T18:49:13Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 652}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTI5Njk4OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo0OTo0M1rOH7GUoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo0OTo0M1rOH7GUoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczMTYxNw==", "bodyText": "Use a similar code pattern here as well", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531731617", "createdAt": "2020-11-27T18:49:43Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 655}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTI5OTc5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo1MToyN1rOH7GWRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo1MToyN1rOH7GWRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczMjAzNw==", "bodyText": "The same problem of losing objects happens here.  Shrink the lifetimes of the locals as much as possible and refresh membernameObject after after allocation", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531732037", "createdAt": "2020-11-27T18:51:27Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (clazzObject == NULL) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 680}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTMxMTI3OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo1ODoxMVrOH7GcvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxODo1ODoxMVrOH7GcvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczMzY5Mg==", "bodyText": "All of these variables should be declared somewhere else.  The life times are too long, especially given this is c++ and they can be declared at first use, not top of scope.", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531733692", "createdAt": "2020-11-27T18:58:11Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (clazzObject == NULL) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 723}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTMxNjIxOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOTowMDo1MlrOH7GfWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOTowMDo1MlrOH7GfWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczNDM2Mg==", "bodyText": "A way to simplify this is to \"chunk\" it a little bit more.  goto for exit conditions is OK\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tif (NULL == self) {\n          \n          \n            \n            \t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n          \n          \n            \n            \t} else {\n          \n          \n            \n            \t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n          \n          \n            \n            \t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n          \n          \n            \n            \t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n          \n          \n            \n            \t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n          \n          \n            \n            \t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n          \n          \n            \n            \t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n          \n          \n            \n            \t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n          \n          \n            \n            \n          \n          \n            \n            \t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n          \n          \n            \n            \t\tjint new_flags = 0;\n          \n          \n            \n            \t\tj9object_t new_clazz = NULL;\n          \n          \n            \n            \n          \n          \n            \n            \t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, clazzObject, callerObject, nameObject, typeObject, flags, vmindex, target);\n          \n          \n            \n            \t\t/* Check if MemberName is already resolved */\n          \n          \n            \n            \t\tif (0 != target) {\n          \n          \n            \n            \t\t\tresult = self;\n          \n          \n            \n            \tif (NULL == self) {\n          \n          \n            \n            \t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n          \n          \n            \n            \t\tgoto _throwExit;\t\t\n          \n          \n            \n            \t}\n          \n          \n            \n            \t\n          \n          \n            \n            \tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\t\n          \n          \n            \n            \tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n          \n          \n            \n            \tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, clazzObject, callerObject, nameObject, typeObject, flags, vmindex, target);\n          \n          \n            \n            \t/* Check if MemberName is already resolved */\n          \n          \n            \n            \tif (0 != target) {\n          \n          \n            \n            \t\tresult = self;\n          \n          \n            \n            \t\tgoto _exit;\n          \n          \n            \n            \t}\n          \n          \n            \n            \t\n          \n          \n            \n            \t..... rest of code ....", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531734362", "createdAt": "2020-11-27T19:00:52Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (clazzObject == NULL) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, clazzObject, callerObject, nameObject, typeObject, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 733}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTMxODAzOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOTowMTo1M1rOH7GgUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOTowMTo1M1rOH7GgUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczNDYxMQ==", "bodyText": "allocations need to be null checked.", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531734611", "createdAt": "2020-11-27T19:01:53Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (clazzObject == NULL) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, clazzObject, callerObject, nameObject, typeObject, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\tint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\t\t\tUDATA nameLength = vmFuncs->getStringUTF8Length(currentThread, nameObject) + 1;\n+\t\t\tchar *name = (char*)j9mem_allocate_memory(nameLength, OMRMEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 743}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTMxOTU0OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOTowMjo1M1rOH7GhOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOTowMzo0NVrOH7Gh5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczNDg0MQ==", "bodyText": "I don't think you meant to use int here - jint maybe?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531734841", "createdAt": "2020-11-27T19:02:53Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (clazzObject == NULL) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, clazzObject, callerObject, nameObject, typeObject, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\tint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 738}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczNTAxNQ==", "bodyText": "Also, can this be moved closer to where it's needed?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531735015", "createdAt": "2020-11-27T19:03:45Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (clazzObject == NULL) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, clazzObject, callerObject, nameObject, typeObject, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\tint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczNDg0MQ=="}, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 738}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTMyNDAyOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOTowNToyMFrOH7Gjkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOToyNTo1M1rOH7G1gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczNTQ0Mw==", "bodyText": "allocations need to be null checked", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531735443", "createdAt": "2020-11-27T19:05:20Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (clazzObject == NULL) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, clazzObject, callerObject, nameObject, typeObject, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\tint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\t\t\tUDATA nameLength = vmFuncs->getStringUTF8Length(currentThread, nameObject) + 1;\n+\t\t\tchar *name = (char*)j9mem_allocate_memory(nameLength, OMRMEM_CATEGORY_VM);\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignatureLength = vmFuncs->getStringUTF8Length(currentThread, sigString) + 1;\n+\t\t\t\t\tsignature = (char*)j9mem_allocate_memory(signatureLength, OMRMEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 757}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc0MDAzMg==", "bodyText": "These three lines can be replaced with a call to copyStringToJ9UTF8WithMemAlloc", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531740032", "createdAt": "2020-11-27T19:25:53Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (clazzObject == NULL) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, clazzObject, callerObject, nameObject, typeObject, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\tint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\t\t\tUDATA nameLength = vmFuncs->getStringUTF8Length(currentThread, nameObject) + 1;\n+\t\t\tchar *name = (char*)j9mem_allocate_memory(nameLength, OMRMEM_CATEGORY_VM);\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignatureLength = vmFuncs->getStringUTF8Length(currentThread, sigString) + 1;\n+\t\t\t\t\tsignature = (char*)j9mem_allocate_memory(signatureLength, OMRMEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTczNTQ0Mw=="}, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 757}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTM2NDg0OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOTozMDo1NlrOH7G5yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOTozMDo1NlrOH7G5yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc0MTEzMQ==", "bodyText": "Use copyStringToJ9UTF8WithMemAlloc here to simplify the code - though it will still need to validate the allocation succeeded, which is missing here", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531741131", "createdAt": "2020-11-27T19:30:56Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tchar* cursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t// Copy class signatures to descriptor string\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t\tj9mem_free_memory(signatures[i]);\n+\t}\n+\n+\t*cursor++ = ')';\n+\t// Copy return type signature to descriptor string\n+\tstrcpy(cursor, rSignature);\n+\tj9mem_free_memory(signatures);\n+\treturn methodDescriptor;\n+}\n+\n+static J9Class *\n+classForSignature(struct J9VMThread *vmThread, U_8 **sigDataPtr, struct J9ClassLoader *classLoader)\n+{\n+\tU_8 *sigData = *sigDataPtr;\n+\tJ9JavaVM *vm = vmThread->javaVM;\n+\tJ9Class *clazz = NULL;\n+\tUDATA arity = 0;\n+\tU_8 c = 0;\n+\tUDATA i = 0;\n+\n+\tfor (c = *sigData++; '[' == c; c = *sigData++) {\n+\t\tarity++;\n+\t}\n+\n+\t/* Non-array case */\n+\tswitch (c) {\n+\tcase 'Q':\n+\tcase 'L': {\n+\t\t/* object case */\n+\t\tU_8 *tempData = sigData;\n+\t\tUDATA length = 0;\n+\n+\t\t/* find the signature length -> up to the \";\" */\n+\t\twhile (';' != *sigData++) {\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\t/* find the class from the signature chunk */\n+\t\tclazz = vm->internalVMFunctions->internalFindClassUTF8(vmThread, tempData, length, classLoader, J9_FINDCLASS_FLAG_THROW_ON_FAIL);\n+\t\tbreak;\n+\t}\n+\tcase 'I':\n+\t\tclazz = vm->intReflectClass;\n+\t\tbreak;\n+\tcase 'Z':\n+\t\tclazz = vm->booleanReflectClass;\n+\t\tbreak;\n+\tcase 'J':\n+\t\tclazz = vm->longReflectClass;\n+\t\tbreak;\n+#if defined(J9VM_INTERP_FLOAT_SUPPORT)\n+\tcase 'D':\n+\t\tclazz = vm->doubleReflectClass;\n+\t\tbreak;\n+\tcase 'F':\n+\t\tclazz = vm->floatReflectClass;\n+\t\tbreak;\n+#endif\n+\tcase 'C':\n+\t\tclazz = vm->charReflectClass;\n+\t\tbreak;\n+\tcase 'B':\n+\t\tclazz = vm->byteReflectClass;\n+\t\tbreak;\n+\tcase 'S':\n+\t\tclazz = vm->shortReflectClass;\n+\t\tbreak;\n+\tcase 'V':\n+\t\tclazz = vm->voidReflectClass;\n+\t\tbreak;\n+\t}\n+\n+\tfor (i = 0; (i < arity) && (NULL != clazz); i++) {\n+\t\tclazz = fetchArrayClass(vmThread, clazz);\n+\t}\n+\n+\tif (NULL != clazz) {\n+\t\t*sigDataPtr = sigData;\n+\t}\n+\n+\treturn clazz;\n+}\n+\n+static j9object_t\n+createFieldFromID(struct J9VMThread *vmThread, J9JNIFieldID *j9FieldID)\n+{\n+\tJ9UTF8 *nameUTF = NULL;\n+\tj9object_t nameString = NULL;\n+\tU_8 *signatureData = NULL;\n+\tJ9Class *typeClass = NULL;\n+\tj9object_t fieldObject = NULL;\n+\tJ9Class *jlrFieldClass = J9VMJAVALANGREFLECTFIELD(vmThread->javaVM);\n+\n+\tif (NULL == jlrFieldClass) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (VM_VMHelpers::classRequiresInitialization(vmThread, jlrFieldClass)) {\n+\t\tvmThread->javaVM->internalVMFunctions->initializeClass(vmThread, jlrFieldClass);\n+\t\tif (vmThread->currentException != NULL) {\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\tfieldObject = vmThread->javaVM->memoryManagerFunctions->J9AllocateObject(vmThread, jlrFieldClass, J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\tif (NULL == fieldObject) {\n+\t\tvmThread->javaVM->internalVMFunctions->setHeapOutOfMemoryError(vmThread);\n+\t\treturn NULL;\n+\t}\n+\n+\tPUSH_OBJECT_IN_SPECIAL_FRAME(vmThread, fieldObject);\n+\n+\tsignatureData = J9UTF8_DATA(J9ROMFIELDSHAPE_SIGNATURE(j9FieldID->field));\n+\ttypeClass = classForSignature(vmThread, &signatureData, j9FieldID->declaringClass->classLoader);\n+\tif (NULL == typeClass) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_TYPE(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(typeClass));\n+\n+\tnameUTF = J9ROMFIELDSHAPE_NAME(j9FieldID->field);\n+\tnameString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(nameUTF), (U_32) J9UTF8_LENGTH(nameUTF), J9_STR_INTERN);\n+\tif (NULL == nameString) {\n+\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\treturn NULL;\n+\t}\n+\n+\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\tJ9VMJAVALANGREFLECTFIELD_SET_NAME(vmThread, fieldObject, nameString);\n+\n+\tif (0 != (j9FieldID->field->modifiers & J9FieldFlagHasGenericSignature)) {\n+\t\tJ9UTF8 *sigUTF = romFieldGenericSignature(j9FieldID->field);\n+\t\tj9object_t sigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(sigUTF), (U_32) J9UTF8_LENGTH(sigUTF), 0);\n+\t\tif (NULL == sigString) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+#if defined(USE_SUN_REFLECT)\n+\t\tJ9VMJAVALANGREFLECTFIELD_SET_SIGNATURE(vmThread, fieldObject, sigString);\n+#endif\n+\t}\n+\n+\t{\n+\t\tj9object_t byteArray = getFieldAnnotationData(vmThread, j9FieldID->declaringClass, j9FieldID);\n+\t\tif (NULL != vmThread->currentException) {\n+\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(vmThread); /* fieldObject */\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif (NULL != byteArray) {\n+\t\t\tfieldObject = PEEK_OBJECT_IN_SPECIAL_FRAME(vmThread, 0);\n+\t\t\tJ9VMJAVALANGREFLECTFIELD_SET_ANNOTATIONS(vmThread, fieldObject, byteArray);\n+\t\t}\n+\t}\n+\n+\tfieldObject = POP_OBJECT_IN_SPECIAL_FRAME(vmThread);\n+\n+\t/* Java 7 uses int field ID's to avoid modifying Sun JCL code */\n+\tJ9VMJAVALANGREFLECTFIELD_SET_INTFIELDID(vmThread, fieldObject, (U_32)(j9FieldID->index));\n+\n+\tJ9VMJAVALANGREFLECTFIELD_SET_DECLARINGCLASS(vmThread, fieldObject, J9VM_J9CLASS_TO_HEAPCLASS(j9FieldID->declaringClass));\n+#if defined(USE_SUN_REFLECT)\n+\tJ9VMJAVALANGREFLECTFIELD_SET_MODIFIERS(vmThread, fieldObject, j9FieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+#endif\n+\n+\treturn fieldObject;\n+}\n+\n+j9object_t\n+createFieldObject(J9VMThread *currentThread, J9ROMFieldShape *romField, J9Class *declaringClass, J9UTF8 *name, J9UTF8 *sig, bool isStaticField)\n+{\n+\tJ9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\n+\tJ9JNIFieldID *fieldID = NULL;\n+\tUDATA offset = 0;\n+\tUDATA inconsistentData = 0;\n+\n+\tif (isStaticField) {\n+\t\toffset = (UDATA)vmFuncs->staticFieldAddress(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0, NULL);\n+\t\toffset -= (UDATA)declaringClass->ramStatics;\n+\t} else {\n+\t\toffset = vmFuncs->instanceFieldOffset(currentThread, declaringClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(sig), J9UTF8_LENGTH(sig), NULL, NULL, 0);\n+\t}\n+\n+\tfieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\n+\treturn createFieldFromID(currentThread, fieldID);\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif (NULL == self || NULL == ref) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, clazzObject, nameObject, typeObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != clazzObject) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (clazzObject == NULL) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (nameObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t}\n+\t\t\t\tif (typeObject == NULL) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\tj9object_t nameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, clazzObject, callerObject, nameObject, typeObject, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\tint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\t\t\tUDATA nameLength = vmFuncs->getStringUTF8Length(currentThread, nameObject) + 1;\n+\t\t\tchar *name = (char*)j9mem_allocate_memory(nameLength, OMRMEM_CATEGORY_VM);\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignatureLength = vmFuncs->getStringUTF8Length(currentThread, sigString) + 1;\n+\t\t\t\t\tsignature = (char*)j9mem_allocate_memory(signatureLength, OMRMEM_CATEGORY_VM);\n+\t\t\t\t\tvmFuncs->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT , 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8 *)signature, signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignatureLength = vmFuncs->getStringUTF8Length(currentThread, typeObject) + 1;\n+\t\t\t\tsignature = (char*)j9mem_allocate_memory(signatureLength, OMRMEM_CATEGORY_VM);\n+\t\t\t\tUDATA stringLength = J9VMJAVALANGSTRING_LENGTH(currentThread, typeObject);\n+\t\t\t\tvmFuncs->copyStringToUTF8Helper(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT , 0, stringLength, (U_8 *)signature, signatureLength);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 766}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTM5ODk5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOTo1MTo0MFrOH7HMWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxOTo1MTo0MFrOH7HMWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc0NTg4MA==", "bodyText": "Check if the class already has it's name string set and then use the existing code to copy from that when possible:\nj9object_t string = J9VMJAVALANGCLASS_CLASSNAMESTRING(vmThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\ncopyStringToJ9UTF8WithMemAlloc(....)   // copy the string to a utf8 buffer\n\nOne way to handle this would be to fill in the class name if it isn't set yet and then convert it from there to the utf8 string.  To do that, this code - and the callers - would need to be safe to allocate which means protecting all the object pointers", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531745880", "createdAt": "2020-11-27T19:51:40Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTQzNDc3OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowMDo0MVrOH7HinQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowMDo0MVrOH7HinQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1MTU4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            char *\n          \n          \n            \n            static char *", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531751581", "createdAt": "2020-11-27T20:00:41Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTQ0NDUxOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowMjoxOVrOH7HpGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowMjoxOVrOH7HpGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1MzI0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tif (result) {\n          \n          \n            \n            \tif (result != 0) {", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531753240", "createdAt": "2020-11-27T20:02:19Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTQ0OTM1OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowMzowNVrOH7HsSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowNToxNlrOH7H1YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1NDA1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n          \n          \n            \n            \t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n          \n          \n            \n            \t\tif (signature == NULL) {\n          \n          \n            \n            \t\t\t// do something - set native oom and return?\n          \n          \n            \n            \t\t}", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531754059", "createdAt": "2020-11-27T20:03:05Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1NjM4NA==", "bodyText": "If this is setting oom directly, then callers need to be protecting their objects.  Maybe better to return an error code for oom and check in the callers so it can be propagated back to the correct spot", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531756384", "createdAt": "2020-11-27T20:05:16Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1NDA1OQ=="}, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTQ1NTMyOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowNDowNVrOH7HwVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowNDowNVrOH7HwVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1NTA5Mw==", "bodyText": "Needs to handle the NativeOOM case as well - likely by checking for a pending exception", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531755093", "createdAt": "2020-11-27T20:04:05Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTQ2NDg3OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowNTozNFrOH7H2pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowNTozNFrOH7H2pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1NjcxMQ==", "bodyText": "malloc with no check for returning null", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531756711", "createdAt": "2020-11-27T20:05:34Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTQ2NzIxOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowNTo1NlrOH7H4QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowNjoxOFrOH7H5sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1NzEyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tif (!rSignature) {\n          \n          \n            \n            \tif (rSignature == NULL) {", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531757121", "createdAt": "2020-11-27T20:05:56Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1NzQ4OA==", "bodyText": "rSignature isn't a boolean type so !rSignature isn't an appropriate check", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531757488", "createdAt": "2020-11-27T20:06:18Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1NzEyMQ=="}, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTQ3MDg0OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowNjozMlrOH7H6ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowNjozMlrOH7H6ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1NzcyNg==", "bodyText": "missing null check", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531757726", "createdAt": "2020-11-27T20:06:32Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tchar* methodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTQ3MjIyOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowNjo1MFrOH7H7hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMDowNjo1MFrOH7H7hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc1Nzk1OA==", "bodyText": "This needs to communicate allocation failures out as well", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r531757958", "createdAt": "2020-11-27T20:06:50Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1536 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(fieldID->field);\n+\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(fieldID->field);\n+\n+\t\tnameObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\n+\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, nameObject);\n+\t\ttypeObject = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\tnameObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setField(currentThread, (U_32)J9UTF8_LENGTH(name), J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(signature), J9UTF8_DATA(signature));\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tsignature[0] = result;\n+\t\tsignature[1] = '\\0';\n+\t\treturn signature;\n+\t}\n+\treturn NULL;\n+}\n+\n+char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class * myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 * romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name =  (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; //for null-termination\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tU_32 i;\n+\tfor (i = 0; i < numDims; i++) {\n+\t\tsig[i] = '[';\n+\t}\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = 'L';\n+\t}\n+\n+\tmemcpy(sig+i, name, len);\n+\ti += len;\n+\n+\tif (*name != '[') {\n+\t\tsig[i++] = ';';\n+\t}\n+\tsig[length-1] = '\\0';\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs + 1) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\t*signatureLength = 2; //space for '(', ')'\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(vm, pclass);\n+\t\tif (!signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t// Return type\n+\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\tchar* rSignature = sigForPrimitiveOrVoid(vm, rclass);\n+\tif (!rSignature) {\n+\t\trSignature = getClassSignature(currentThread, rclass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4fda0d7a5457bfd1cbf09638cc40eafef98634"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjU0NjIyOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToxMzozMFrOIHZY_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToxMzozMFrOIHZY_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyNjk0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\t\t\t\t\t\tif (romField->modifiers & J9AccStatic) {\n          \n          \n            \n            \t\t\t\t\t\t\t\t\t\t\t\t/* create static field object */\n          \n          \n            \n            \t\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, true);\n          \n          \n            \n            \t\t\t\t\t\t\t\t\t\t\t} else {\n          \n          \n            \n            \t\t\t\t\t\t\t\t\t\t\t\t/* create instance field object */\n          \n          \n            \n            \t\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, false);\n          \n          \n            \n            \t\t\t\t\t\t\t\t\t\t\t}\n          \n          \n            \n            \t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r544626940", "createdAt": "2020-12-16T21:13:30Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name = (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; /* for null-termination */\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tif (NULL == sig) {\n+\t\tcurrentThread->javaVM->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t} else {\n+\t\tU_32 i;\n+\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\tsig[i] = '[';\n+\t\t}\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = 'L';\n+\t\t}\n+\n+\t\tmemcpy(sig+i, name, len);\n+\t\ti += len;\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = ';';\n+\t\t}\n+\t\tsig[length-1] = '\\0';\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(currentThread, pclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (NULL == signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = sigForPrimitiveOrVoid(currentThread, rclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (rSignature == NULL) {\n+\t\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tif (NULL != rSignature) {\n+\t\tj9mem_free_memory(rSignature);\n+\t}\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tif (NULL != signatures[i]) {\n+\t\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = sigForPrimitiveOrVoid(currentThread, rclass);\n+\t\t\t\tif ((NULL == signature) && (!VM_VMHelpers::exceptionPending(currentThread))) {\n+\t\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\t}\n+\n+\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = NULL;\n+\t\t\t\t\t\t\t\t\t\tif (romField->modifiers & J9AccStatic) {\n+\t\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, TRUE);\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t/* create instance field object */\n+\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, FALSE);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (romField->modifiers & J9AccStatic) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, true);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create instance field object */\n+\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, false);\n+\t\t\t\t\t\t\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 1023}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjU1MDc0OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToxNDo0MVrOIHZbmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToxNDo0MVrOIHZbmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyNzYxMQ==", "bodyText": "Don't need the explicit branch here - pass (romField->modifiers & J9AccStatic) == J9AccStatic to the call", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r544627611", "createdAt": "2020-12-16T21:14:41Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name = (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; /* for null-termination */\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tif (NULL == sig) {\n+\t\tcurrentThread->javaVM->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t} else {\n+\t\tU_32 i;\n+\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\tsig[i] = '[';\n+\t\t}\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = 'L';\n+\t\t}\n+\n+\t\tmemcpy(sig+i, name, len);\n+\t\ti += len;\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = ';';\n+\t\t}\n+\t\tsig[length-1] = '\\0';\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(currentThread, pclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (NULL == signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = sigForPrimitiveOrVoid(currentThread, rclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (rSignature == NULL) {\n+\t\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tif (NULL != rSignature) {\n+\t\tj9mem_free_memory(rSignature);\n+\t}\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tif (NULL != signatures[i]) {\n+\t\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = sigForPrimitiveOrVoid(currentThread, rclass);\n+\t\t\t\tif ((NULL == signature) && (!VM_VMHelpers::exceptionPending(currentThread))) {\n+\t\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\t}\n+\n+\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = NULL;\n+\t\t\t\t\t\t\t\t\t\tif (romField->modifiers & J9AccStatic) {\n+\t\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, TRUE);\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t/* create instance field object */\n+\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, FALSE);\n+\t\t\t\t\t\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 968}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjU3OTk5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToyMjoxN1rOIHZsvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToyMjoxN1rOIHZsvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYzMTk5OQ==", "bodyText": "It's safe to pass null to free so don't add the null check\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tif (NULL != rSignature) {\n          \n          \n            \n            \t\tj9mem_free_memory(rSignature);\n          \n          \n            \n            \t}\n          \n          \n            \n            \tj9mem_free_memory(rSignature);", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r544631999", "createdAt": "2020-12-16T21:22:17Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name = (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; /* for null-termination */\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tif (NULL == sig) {\n+\t\tcurrentThread->javaVM->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t} else {\n+\t\tU_32 i;\n+\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\tsig[i] = '[';\n+\t\t}\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = 'L';\n+\t\t}\n+\n+\t\tmemcpy(sig+i, name, len);\n+\t\ti += len;\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = ';';\n+\t\t}\n+\t\tsig[length-1] = '\\0';\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(currentThread, pclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (NULL == signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = sigForPrimitiveOrVoid(currentThread, rclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (rSignature == NULL) {\n+\t\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tif (NULL != rSignature) {\n+\t\tj9mem_free_memory(rSignature);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjU4MzMzOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToyMzowMFrOIHZukQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToyMzowMFrOIHZukQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYzMjQ2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tif (NULL != signatures[i]) {\n          \n          \n            \n            \t\t\t\tj9mem_free_memory(signatures[i]);\n          \n          \n            \n            \t\t\t} else {\n          \n          \n            \n            \t\t\t\tbreak;\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\tj9mem_free_memory(signatures[i]);", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r544632465", "createdAt": "2020-12-16T21:23:00Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name = (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; /* for null-termination */\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tif (NULL == sig) {\n+\t\tcurrentThread->javaVM->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t} else {\n+\t\tU_32 i;\n+\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\tsig[i] = '[';\n+\t\t}\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = 'L';\n+\t\t}\n+\n+\t\tmemcpy(sig+i, name, len);\n+\t\ti += len;\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = ';';\n+\t\t}\n+\t\tsig[length-1] = '\\0';\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(currentThread, pclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (NULL == signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = sigForPrimitiveOrVoid(currentThread, rclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (rSignature == NULL) {\n+\t\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tif (NULL != rSignature) {\n+\t\tj9mem_free_memory(rSignature);\n+\t}\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tif (NULL != signatures[i]) {\n+\t\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 331}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjU4ODAzOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToyNDoxOVrOIHZxWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToyNDoxOVrOIHZxWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYzMzE3Nw==", "bodyText": "Much cleaner to have this return null and let the callers be responsible for setting the OOM", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r544633177", "createdAt": "2020-12-16T21:24:19Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjU5MTU3OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToyNTowN1rOIHZzTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToyNTowN1rOIHZzTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYzMzY3OA==", "bodyText": "Not strictly necessary, but better to use c++ casts in c++ code\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n          \n          \n            \n            \t\tchar* signature = static_cast<char*>(j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM));", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r544633678", "createdAt": "2020-12-16T21:25:07Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjU5OTE2OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToyNjo1NFrOIHZ3lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMToyNjo1NFrOIHZ3lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYzNDc3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            \tmemset(signatures, 0, (numArgs) * sizeof(char*));", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r544634773", "createdAt": "2020-12-16T21:26:54Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name = (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; /* for null-termination */\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tif (NULL == sig) {\n+\t\tcurrentThread->javaVM->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t} else {\n+\t\tU_32 i;\n+\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\tsig[i] = '[';\n+\t\t}\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = 'L';\n+\t\t}\n+\n+\t\tmemcpy(sig+i, name, len);\n+\t\ti += len;\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = ';';\n+\t\t}\n+\t\tsig[length-1] = '\\0';\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzc2ODM4OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDo0MjoxNVrOIIIAXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDo0MjoxNVrOIIIAXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5MDY4NQ==", "bodyText": "Better to let the caller - who knows the state of objects - throw the exception.  This api can just return null to indicate failure and have the caller take the appropriate action", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r545390685", "createdAt": "2020-12-17T20:42:15Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name = (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; /* for null-termination */\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tif (NULL == sig) {\n+\t\tcurrentThread->javaVM->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzc4MTE4OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDo0NjowMlrOIIIH5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzoxMDozOVrOIP0raQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5MjYxNA==", "bodyText": "Why the early break here before updating myClass?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r545392614", "createdAt": "2020-12-17T20:46:02Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ2MjYzMw==", "bodyText": "a primitive array class have the correct signature including the component class type", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r553462633", "createdAt": "2021-01-07T17:10:39Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5MjYxNA=="}, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzc4Nzc3OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDo0Nzo0M1rOIIILlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDo0Nzo0M1rOIIILlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5MzU1OQ==", "bodyText": "Having both len and length in this code makes it unclear why they are different.  Can you name them more clearly?  Mayne nameLength for len?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r545393559", "createdAt": "2020-12-17T20:47:43Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name = (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzc5NjA2OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDo1MDowN1rOIIIQYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDo1MDowN1rOIIIQYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NDc4Ng==", "bodyText": "Similar comment here - return null and let the caller set the exception", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r545394786", "createdAt": "2020-12-17T20:50:07Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name = (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; /* for null-termination */\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tif (NULL == sig) {\n+\t\tcurrentThread->javaVM->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t} else {\n+\t\tU_32 i;\n+\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\tsig[i] = '[';\n+\t\t}\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = 'L';\n+\t\t}\n+\n+\t\tmemcpy(sig+i, name, len);\n+\t\ti += len;\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = ';';\n+\t\t}\n+\t\tsig[length-1] = '\\0';\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzgwMzA5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDo1MTo1OVrOIIIUgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDo1MTo1OVrOIIIUgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NTg0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n          \n          \n            \n            \t\tcase J9CPTYPE_CLASS:\n          \n          \n            \n            \tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n          \n          \n            \n            \tcase J9CPTYPE_CLASS:\n          \n      \n    \n    \n  \n\nDon't indent case statements", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r545395840", "createdAt": "2020-12-17T20:51:59Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name = (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; /* for null-termination */\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tif (NULL == sig) {\n+\t\tcurrentThread->javaVM->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t} else {\n+\t\tU_32 i;\n+\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\tsig[i] = '[';\n+\t\t}\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = 'L';\n+\t\t}\n+\n+\t\tmemcpy(sig+i, name, len);\n+\t\ti += len;\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = ';';\n+\t\t}\n+\t\tsig[length-1] = '\\0';\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(currentThread, pclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (NULL == signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = sigForPrimitiveOrVoid(currentThread, rclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (rSignature == NULL) {\n+\t\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tif (NULL != rSignature) {\n+\t\tj9mem_free_memory(rSignature);\n+\t}\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tif (NULL != signatures[i]) {\n+\t\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 350}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzgzNDU4OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTowMDozMlrOIIIm5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTowMDozMlrOIIIm5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMDU0OA==", "bodyText": "It is better to get constants {int, float, double, long} from the ROM cp as they may be in the RAM cp.  When possible, we put constant data to the end of the ROM CP and have smaller RAM CPs.  Always fetch that kind of data from the ROM cp entries - see getSingleSlotConstant or getDouleSlotConstant from sun_reflect_constantpool.c", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r545400548", "createdAt": "2020-12-17T21:00:32Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name = (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; /* for null-termination */\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tif (NULL == sig) {\n+\t\tcurrentThread->javaVM->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t} else {\n+\t\tU_32 i;\n+\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\tsig[i] = '[';\n+\t\t}\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = 'L';\n+\t\t}\n+\n+\t\tmemcpy(sig+i, name, len);\n+\t\ti += len;\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = ';';\n+\t\t}\n+\t\tsig[length-1] = '\\0';\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(currentThread, pclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (NULL == signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = sigForPrimitiveOrVoid(currentThread, rclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (rSignature == NULL) {\n+\t\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tif (NULL != rSignature) {\n+\t\tj9mem_free_memory(rSignature);\n+\t}\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tif (NULL != signatures[i]) {\n+\t\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 346}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzg0NzAxOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTowNDowNlrOIIIuMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTowNDowNlrOIIIuMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMjQxOQ==", "bodyText": "memberName would have been lost between being fetched and used here.", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r545402419", "createdAt": "2020-12-17T21:04:06Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9VMThread *currentThread, J9Class *clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tchar result = 0;\n+\tif (clazz == vm->booleanReflectClass) {\n+\t\tresult = 'Z';\n+\t} else if (clazz == vm->byteReflectClass) {\n+\t\tresult = 'B';\n+\t} else if (clazz == vm->charReflectClass) {\n+\t\tresult = 'C';\n+\t} else if (clazz == vm->shortReflectClass) {\n+\t\tresult = 'S';\n+\t} else if (clazz == vm->intReflectClass) {\n+\t\tresult = 'I';\n+\t} else if (clazz == vm->longReflectClass) {\n+\t\tresult = 'J';\n+\t} else if (clazz == vm->floatReflectClass) {\n+\t\tresult = 'F';\n+\t} else if (clazz == vm->doubleReflectClass) {\n+\t\tresult = 'D';\n+\t} else if (clazz == vm->voidReflectClass) {\n+\t\tresult = 'V';\n+\t}\n+\n+\tif (result != 0) {\n+\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\t\tif (NULL != signature) {\n+\t\t\tsignature[0] = result;\n+\t\t\tsignature[1] = '\\0';\n+\t\t\treturn signature;\n+\t\t} else {\n+\t\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(currentThread->javaVM);\n+\n+\tU_32 numDims = 0;\n+\n+\tJ9Class *myClass = clazz;\n+\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tnumDims++;\n+\t\tmyClass = componentClass;\n+\t}\n+\n+\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\tU_32 len = J9UTF8_LENGTH(romName);\n+\tchar * name = (char *)J9UTF8_DATA(romName);\n+\tU_32 length = len + numDims;\n+\tif (* name != '[') {\n+\t\tlength += 2;\n+\t}\n+\n+\tlength++; /* for null-termination */\n+\tchar * sig = (char *)j9mem_allocate_memory(length, OMRMEM_CATEGORY_VM);\n+\tif (NULL == sig) {\n+\t\tcurrentThread->javaVM->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t} else {\n+\t\tU_32 i;\n+\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\tsig[i] = '[';\n+\t\t}\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = 'L';\n+\t\t}\n+\n+\t\tmemcpy(sig+i, name, len);\n+\t\ti += len;\n+\n+\t\tif (*name != '[') {\n+\t\t\tsig[i++] = ';';\n+\t\t}\n+\t\tsig[length-1] = '\\0';\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = sigForPrimitiveOrVoid(currentThread, pclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (NULL == signatures[i]) {\n+\t\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = sigForPrimitiveOrVoid(currentThread, rclass);\n+\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\tgoto done;\n+\t\t} else if (rSignature == NULL) {\n+\t\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tvm->internalVMFunctions->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tif (NULL != rSignature) {\n+\t\tj9mem_free_memory(rSignature);\n+\t}\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tif (NULL != signatures[i]) {\n+\t\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\t\tcase J9CPTYPE_CLASS:\n+\t\t{\n+\t\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\t\tif ((NULL == clazz) && resolve) {\n+\t\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tif (NULL != clazz) {\n+\t\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_STRING:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_INT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_FLOAT:\n+\t\t{\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, ramCP->value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_LONG:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_DOUBLE:\n+\t\t{\n+\t\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\t\tU_64 value = romCP->slot1;\n+\t\t\tvalue = (value << 32) + romCP->slot2;\n+\t\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == result) {\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHOD_TYPE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_METHODHANDLE:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase J9CPTYPE_CONSTANT_DYNAMIC:\n+\t\t{\n+\t\t\tresult = (j9object_t)ramCP->value;\n+\t\t\tif ((NULL == result) && resolve) {\n+\t\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing values.\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName using the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = sigForPrimitiveOrVoid(currentThread, rclass);\n+\t\t\t\tif ((NULL == signature) && (!VM_VMHelpers::exceptionPending(currentThread))) {\n+\t\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\t}\n+\n+\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = NULL;\n+\t\t\t\t\t\t\t\t\t\tif (romField->modifiers & J9AccStatic) {\n+\t\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, TRUE);\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t/* create instance field object */\n+\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, FALSE);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (romField->modifiers & J9AccStatic) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, true);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create instance field object */\n+\t\t\t\t\t\t\t\t\t\t\t\tfieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, false);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\tif (!J9ROMCLASS_IS_PRIMITIVE_OR_ARRAY(currentClass->romClass)) {\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2560da21b558b8aec18c567f3c8acf0df3cddfb"}, "originalPosition": 1079}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNzk2NjQ5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQwMzo0NToxMFrOIU6e9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxOTo1OTo0MFrOIbZMdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwMDYyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            void\n          \n          \n            \n            static void", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r558800628", "createdAt": "2021-01-16T03:45:10Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5NTI1Mw==", "bodyText": "fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r565595253", "createdAt": "2021-01-27T19:59:40Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwMDYyOA=="}, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNzk5NjczOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQwNDoyMjowOFrOIU6smw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxOTo1OTo0NlrOIbZMuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwNDEyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tnumDims++;\n          \n          \n            \n            \t\t\t\tnumDims += 1;", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r558804123", "createdAt": "2021-01-16T04:22:08Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5NTMyMA==", "bodyText": "fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r565595320", "createdAt": "2021-01-27T19:59:46Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwNDEyMw=="}, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNzk5NzA4OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQwNDoyMjoyOVrOIU6sxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxOTo1OTo1M1rOIbZNBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwNDE2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tU_32 i;\n          \n          \n            \n            \t\t\t\tU_32 i = 0;", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r558804166", "createdAt": "2021-01-16T04:22:29Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5NTM5OA==", "bodyText": "fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r565595398", "createdAt": "2021-01-27T19:59:53Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwNDE2Ng=="}, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNzk5NzIyOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQwNDoyMzoxOVrOIU6s4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxOTo1OTo1OVrOIbZNRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwNDE5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            char *\n          \n          \n            \n            static char *", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r558804193", "createdAt": "2021-01-16T04:23:19Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5NTQ2MA==", "bodyText": "fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r565595460", "createdAt": "2021-01-27T19:59:59Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwNDE5Mw=="}, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxODAyNjA1OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQwNTowMTowMlrOIU658w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxOTo1ODo1NlrOIbZK0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwNzUzOQ==", "bodyText": "Why -99?  Is there a meaning to this value?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r558807539", "createdAt": "2021-01-16T05:01:02Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tgoto done;\n+\t}\n+\n+\tmemset(signatures, 0, (numArgs) * sizeof(char*));\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\tif (NULL == signatures[i]) {\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\tif (NULL == rSignature) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tj9mem_free_memory(rSignature);\n+\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\tcase J9CPTYPE_CLASS: {\n+\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\tif ((NULL == clazz) && resolve) {\n+\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tif (NULL != clazz) {\n+\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_STRING: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_INT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_FLOAT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_LONG: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_DOUBLE: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHOD_TYPE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHODHANDLE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_CONSTANT_DYNAMIC: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\t} /* switch */\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing VM metadata.\n+ * Uses VM metadata (vmindex & vmtarget) to set symblic data fields (name & type & defc)\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName's symbolic data (name & type & defc) with the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\tif (NULL != signature) {\n+\t\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 957}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5NDgzMw==", "bodyText": "This is the value used by OJDK impl for this particular error case", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r565594833", "createdAt": "2021-01-27T19:58:56Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tgoto done;\n+\t}\n+\n+\tmemset(signatures, 0, (numArgs) * sizeof(char*));\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\tif (NULL == signatures[i]) {\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\tif (NULL == rSignature) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tj9mem_free_memory(rSignature);\n+\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\tcase J9CPTYPE_CLASS: {\n+\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\tif ((NULL == clazz) && resolve) {\n+\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tif (NULL != clazz) {\n+\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_STRING: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_INT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_FLOAT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_LONG: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_DOUBLE: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHOD_TYPE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHODHANDLE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_CONSTANT_DYNAMIC: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\t} /* switch */\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing VM metadata.\n+ * Uses VM metadata (vmindex & vmtarget) to set symblic data fields (name & type & defc)\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName's symbolic data (name & type & defc) with the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\tif (NULL != signature) {\n+\t\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwNzUzOQ=="}, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 957}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxODAzOTc5OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQwNToxOTowMFrOIU7AFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDowMDoxNFrOIbZN1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwOTExMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tj9object_t target;\n          \n          \n            \n            \t\t\t\tj9object_t target = null;", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r558809111", "createdAt": "2021-01-16T05:19:00Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tgoto done;\n+\t}\n+\n+\tmemset(signatures, 0, (numArgs) * sizeof(char*));\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\tif (NULL == signatures[i]) {\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\tif (NULL == rSignature) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tj9mem_free_memory(rSignature);\n+\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\tcase J9CPTYPE_CLASS: {\n+\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\tif ((NULL == clazz) && resolve) {\n+\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tif (NULL != clazz) {\n+\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_STRING: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_INT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_FLOAT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_LONG: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_DOUBLE: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHOD_TYPE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHODHANDLE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_CONSTANT_DYNAMIC: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\t} /* switch */\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing VM metadata.\n+ * Uses VM metadata (vmindex & vmtarget) to set symblic data fields (name & type & defc)\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName's symbolic data (name & type & defc) with the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\tif (NULL != signature) {\n+\t\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\t/* create field object */\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\tif (!J9ROMCLASS_IS_PRIMITIVE_OR_ARRAY(currentClass->romClass)) {\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tJ9Class *currentClass = currentITable->interfaceClass;\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tj9mem_free_memory(name);\n+\tj9mem_free_memory(sig);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long objectFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the objectFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.objectFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD) && J9_ARE_NO_BITS_SET(flags, J9AccStatic)) {\n+\t\t\t\tJ9JNIFieldID *fieldID = (J9JNIFieldID*)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tresult = (jlong)fieldID->offset + J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long staticFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the staticFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object staticFieldBase(MemberName self);  // e.g., returns clazz\n+ * \n+ * Returns the staticFieldBase of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldBase with the actual field object\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldBase(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjobject result = NULL;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object getMemberVMInfo(MemberName self);  // returns {vmindex,vmtarget}\n+ * \n+ * Return a 2-element java array containing the vm offset/target data\n+ * For a field MemberName, array contains:\n+ * \t\t(field offset, declaring class)\n+ * For a method MemberName, array contains:\n+ * \t\t(vtable index, MemberName object)\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Entry(env, self);\n+\tif (NULL != self) {\n+\t\tJ9Class *arrayClass = fetchArrayClass(currentThread, J9VMJAVALANGOBJECT(vm));\n+\t\tj9object_t arrayObject = vm->memoryManagerFunctions->J9AllocateIndexableObject(currentThread, arrayClass, 2, J9_GC_ALLOCATE_OBJECT_INSTRUMENTABLE);\n+\t\tif (NULL == arrayObject) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t} else {\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tj9object_t box = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == box) {\n+\t\t\t\t/* Drop arrayObject */\n+\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t} else {\n+\t\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tj9object_t target;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 1319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5NTYwNQ==", "bodyText": "fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r565595605", "createdAt": "2021-01-27T20:00:14Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tgoto done;\n+\t}\n+\n+\tmemset(signatures, 0, (numArgs) * sizeof(char*));\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\tif (NULL == signatures[i]) {\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\tif (NULL == rSignature) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tj9mem_free_memory(rSignature);\n+\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\tcase J9CPTYPE_CLASS: {\n+\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\tif ((NULL == clazz) && resolve) {\n+\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tif (NULL != clazz) {\n+\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_STRING: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_INT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_FLOAT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_LONG: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_DOUBLE: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHOD_TYPE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHODHANDLE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_CONSTANT_DYNAMIC: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\t} /* switch */\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing VM metadata.\n+ * Uses VM metadata (vmindex & vmtarget) to set symblic data fields (name & type & defc)\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName's symbolic data (name & type & defc) with the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\tif (NULL != signature) {\n+\t\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\t/* create field object */\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\tif (!J9ROMCLASS_IS_PRIMITIVE_OR_ARRAY(currentClass->romClass)) {\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tJ9Class *currentClass = currentITable->interfaceClass;\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tj9mem_free_memory(name);\n+\tj9mem_free_memory(sig);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long objectFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the objectFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.objectFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD) && J9_ARE_NO_BITS_SET(flags, J9AccStatic)) {\n+\t\t\t\tJ9JNIFieldID *fieldID = (J9JNIFieldID*)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tresult = (jlong)fieldID->offset + J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long staticFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the staticFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object staticFieldBase(MemberName self);  // e.g., returns clazz\n+ * \n+ * Returns the staticFieldBase of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldBase with the actual field object\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldBase(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjobject result = NULL;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object getMemberVMInfo(MemberName self);  // returns {vmindex,vmtarget}\n+ * \n+ * Return a 2-element java array containing the vm offset/target data\n+ * For a field MemberName, array contains:\n+ * \t\t(field offset, declaring class)\n+ * For a method MemberName, array contains:\n+ * \t\t(vtable index, MemberName object)\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Entry(env, self);\n+\tif (NULL != self) {\n+\t\tJ9Class *arrayClass = fetchArrayClass(currentThread, J9VMJAVALANGOBJECT(vm));\n+\t\tj9object_t arrayObject = vm->memoryManagerFunctions->J9AllocateIndexableObject(currentThread, arrayClass, 2, J9_GC_ALLOCATE_OBJECT_INSTRUMENTABLE);\n+\t\tif (NULL == arrayObject) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t} else {\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tj9object_t box = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == box) {\n+\t\t\t\t/* Drop arrayObject */\n+\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t} else {\n+\t\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tj9object_t target;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwOTExMQ=="}, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 1319}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxODA0MDI3OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQwNToxOTo0M1rOIU7AUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDowMDoyMFrOIbZOHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwOTE3MA==", "bodyText": "Why are both of these writing to index 0?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r558809170", "createdAt": "2021-01-16T05:19:43Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tgoto done;\n+\t}\n+\n+\tmemset(signatures, 0, (numArgs) * sizeof(char*));\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\tif (NULL == signatures[i]) {\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\tif (NULL == rSignature) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tj9mem_free_memory(rSignature);\n+\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\tcase J9CPTYPE_CLASS: {\n+\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\tif ((NULL == clazz) && resolve) {\n+\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tif (NULL != clazz) {\n+\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_STRING: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_INT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_FLOAT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_LONG: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_DOUBLE: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHOD_TYPE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHODHANDLE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_CONSTANT_DYNAMIC: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\t} /* switch */\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing VM metadata.\n+ * Uses VM metadata (vmindex & vmtarget) to set symblic data fields (name & type & defc)\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName's symbolic data (name & type & defc) with the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\tif (NULL != signature) {\n+\t\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\t/* create field object */\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\tif (!J9ROMCLASS_IS_PRIMITIVE_OR_ARRAY(currentClass->romClass)) {\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tJ9Class *currentClass = currentITable->interfaceClass;\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tj9mem_free_memory(name);\n+\tj9mem_free_memory(sig);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long objectFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the objectFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.objectFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD) && J9_ARE_NO_BITS_SET(flags, J9AccStatic)) {\n+\t\t\t\tJ9JNIFieldID *fieldID = (J9JNIFieldID*)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tresult = (jlong)fieldID->offset + J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long staticFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the staticFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object staticFieldBase(MemberName self);  // e.g., returns clazz\n+ * \n+ * Returns the staticFieldBase of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldBase with the actual field object\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldBase(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjobject result = NULL;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object getMemberVMInfo(MemberName self);  // returns {vmindex,vmtarget}\n+ * \n+ * Return a 2-element java array containing the vm offset/target data\n+ * For a field MemberName, array contains:\n+ * \t\t(field offset, declaring class)\n+ * For a method MemberName, array contains:\n+ * \t\t(vtable index, MemberName object)\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Entry(env, self);\n+\tif (NULL != self) {\n+\t\tJ9Class *arrayClass = fetchArrayClass(currentThread, J9VMJAVALANGOBJECT(vm));\n+\t\tj9object_t arrayObject = vm->memoryManagerFunctions->J9AllocateIndexableObject(currentThread, arrayClass, 2, J9_GC_ALLOCATE_OBJECT_INSTRUMENTABLE);\n+\t\tif (NULL == arrayObject) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t} else {\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tj9object_t box = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == box) {\n+\t\t\t\t/* Drop arrayObject */\n+\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t} else {\n+\t\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tj9object_t target;\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmindex = ((J9JNIFieldID*)vmindex)->offset;\n+\t\t\t\t\ttarget = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\t\t} else {\n+\t\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex & ~J9_JNI_MID_INTERFACE;\n+\t\t\t\t\t} else if (0 == methodID->vTableIndex) {\n+\t\t\t\t\t\tvmindex = -1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex;\n+\t\t\t\t\t}\n+\t\t\t\t\ttarget = membernameObject;\n+\t\t\t\t}\n+\n+\t\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, box, vmindex);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, box);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, target);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 1338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5NTY3Ng==", "bodyText": "fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r565595676", "createdAt": "2021-01-27T20:00:20Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tgoto done;\n+\t}\n+\n+\tmemset(signatures, 0, (numArgs) * sizeof(char*));\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\tif (NULL == signatures[i]) {\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\tif (NULL == rSignature) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tj9mem_free_memory(rSignature);\n+\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\tcase J9CPTYPE_CLASS: {\n+\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\tif ((NULL == clazz) && resolve) {\n+\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tif (NULL != clazz) {\n+\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_STRING: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_INT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_FLOAT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_LONG: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_DOUBLE: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHOD_TYPE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHODHANDLE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_CONSTANT_DYNAMIC: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\t} /* switch */\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing VM metadata.\n+ * Uses VM metadata (vmindex & vmtarget) to set symblic data fields (name & type & defc)\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName's symbolic data (name & type & defc) with the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\tif (NULL != signature) {\n+\t\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\t/* create field object */\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\tif (!J9ROMCLASS_IS_PRIMITIVE_OR_ARRAY(currentClass->romClass)) {\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tJ9Class *currentClass = currentITable->interfaceClass;\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tj9mem_free_memory(name);\n+\tj9mem_free_memory(sig);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long objectFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the objectFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.objectFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD) && J9_ARE_NO_BITS_SET(flags, J9AccStatic)) {\n+\t\t\t\tJ9JNIFieldID *fieldID = (J9JNIFieldID*)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tresult = (jlong)fieldID->offset + J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long staticFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the staticFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object staticFieldBase(MemberName self);  // e.g., returns clazz\n+ * \n+ * Returns the staticFieldBase of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldBase with the actual field object\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldBase(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjobject result = NULL;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object getMemberVMInfo(MemberName self);  // returns {vmindex,vmtarget}\n+ * \n+ * Return a 2-element java array containing the vm offset/target data\n+ * For a field MemberName, array contains:\n+ * \t\t(field offset, declaring class)\n+ * For a method MemberName, array contains:\n+ * \t\t(vtable index, MemberName object)\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Entry(env, self);\n+\tif (NULL != self) {\n+\t\tJ9Class *arrayClass = fetchArrayClass(currentThread, J9VMJAVALANGOBJECT(vm));\n+\t\tj9object_t arrayObject = vm->memoryManagerFunctions->J9AllocateIndexableObject(currentThread, arrayClass, 2, J9_GC_ALLOCATE_OBJECT_INSTRUMENTABLE);\n+\t\tif (NULL == arrayObject) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t} else {\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tj9object_t box = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == box) {\n+\t\t\t\t/* Drop arrayObject */\n+\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t} else {\n+\t\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tj9object_t target;\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmindex = ((J9JNIFieldID*)vmindex)->offset;\n+\t\t\t\t\ttarget = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\t\t} else {\n+\t\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex & ~J9_JNI_MID_INTERFACE;\n+\t\t\t\t\t} else if (0 == methodID->vTableIndex) {\n+\t\t\t\t\t\tvmindex = -1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex;\n+\t\t\t\t\t}\n+\t\t\t\t\ttarget = membernameObject;\n+\t\t\t\t}\n+\n+\t\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, box, vmindex);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, box);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, target);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwOTE3MA=="}, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 1338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxODA0MjE0OnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQwNToyMjo0MFrOIU7BNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxOTo1OToxNFrOIbZLaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwOTM5Ng==", "bodyText": "This API and Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetNormal are identical except for a boolean.  Can you introduce a helper and pass the boolean to it?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r558809396", "createdAt": "2021-01-16T05:22:40Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tgoto done;\n+\t}\n+\n+\tmemset(signatures, 0, (numArgs) * sizeof(char*));\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\tif (NULL == signatures[i]) {\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\tif (NULL == rSignature) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tj9mem_free_memory(rSignature);\n+\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\tcase J9CPTYPE_CLASS: {\n+\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\tif ((NULL == clazz) && resolve) {\n+\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tif (NULL != clazz) {\n+\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_STRING: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_INT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_FLOAT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_LONG: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_DOUBLE: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHOD_TYPE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHODHANDLE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_CONSTANT_DYNAMIC: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\t} /* switch */\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing VM metadata.\n+ * Uses VM metadata (vmindex & vmtarget) to set symblic data fields (name & type & defc)\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName's symbolic data (name & type & defc) with the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\tif (NULL != signature) {\n+\t\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\t/* create field object */\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\tif (!J9ROMCLASS_IS_PRIMITIVE_OR_ARRAY(currentClass->romClass)) {\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tJ9Class *currentClass = currentITable->interfaceClass;\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tj9mem_free_memory(name);\n+\tj9mem_free_memory(sig);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long objectFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the objectFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.objectFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD) && J9_ARE_NO_BITS_SET(flags, J9AccStatic)) {\n+\t\t\t\tJ9JNIFieldID *fieldID = (J9JNIFieldID*)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tresult = (jlong)fieldID->offset + J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long staticFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the staticFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object staticFieldBase(MemberName self);  // e.g., returns clazz\n+ * \n+ * Returns the staticFieldBase of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldBase with the actual field object\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldBase(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjobject result = NULL;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object getMemberVMInfo(MemberName self);  // returns {vmindex,vmtarget}\n+ * \n+ * Return a 2-element java array containing the vm offset/target data\n+ * For a field MemberName, array contains:\n+ * \t\t(field offset, declaring class)\n+ * For a method MemberName, array contains:\n+ * \t\t(vtable index, MemberName object)\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Entry(env, self);\n+\tif (NULL != self) {\n+\t\tJ9Class *arrayClass = fetchArrayClass(currentThread, J9VMJAVALANGOBJECT(vm));\n+\t\tj9object_t arrayObject = vm->memoryManagerFunctions->J9AllocateIndexableObject(currentThread, arrayClass, 2, J9_GC_ALLOCATE_OBJECT_INSTRUMENTABLE);\n+\t\tif (NULL == arrayObject) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t} else {\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tj9object_t box = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == box) {\n+\t\t\t\t/* Drop arrayObject */\n+\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t} else {\n+\t\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tj9object_t target;\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmindex = ((J9JNIFieldID*)vmindex)->offset;\n+\t\t\t\t\ttarget = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\t\t} else {\n+\t\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex & ~J9_JNI_MID_INTERFACE;\n+\t\t\t\t\t} else if (0 == methodID->vTableIndex) {\n+\t\t\t\t\t\tvmindex = -1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex;\n+\t\t\t\t\t}\n+\t\t\t\t\ttarget = membernameObject;\n+\t\t\t\t}\n+\n+\t\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, box, vmindex);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, box);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, target);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, arrayObject);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+\n+}\n+\n+/**\n+ * static native void setCallSiteTargetNormal(CallSite site, MethodHandle target)\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetNormal(JNIEnv *env, jclass clazz, jobject callsite, jobject target)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == callsite) || (NULL == target)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t callsiteObject = J9_JNI_UNWRAP_REFERENCE(callsite);\n+\t\tj9object_t targetObject = J9_JNI_UNWRAP_REFERENCE(target);\n+\n+\t\tUDATA offset = (UDATA)vmFuncs->instanceFieldOffset(currentThread, J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callsiteObject), (U_8*)\"target\", strlen(\"target\"),  (U_8*)\"Ljava/lang/invoke/MethodHandle;\", strlen(\"Ljava/lang/invoke/MethodHandle;\"), NULL, NULL, 0);\n+\t\tMM_ObjectAccessBarrierAPI objectAccessBarrier = MM_ObjectAccessBarrierAPI(currentThread);\n+\t\tobjectAccessBarrier.inlineMixedObjectStoreObject(currentThread, callsiteObject, offset, targetObject, false);\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void setCallSiteTargetVolatile(CallSite site, MethodHandle target);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetVolatile(JNIEnv *env, jclass clazz, jobject callsite, jobject target)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 1376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5NDk4NQ==", "bodyText": "added common helper", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r565594985", "createdAt": "2021-01-27T19:59:14Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tgoto done;\n+\t}\n+\n+\tmemset(signatures, 0, (numArgs) * sizeof(char*));\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\tif (NULL == signatures[i]) {\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\tif (NULL == rSignature) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tj9mem_free_memory(rSignature);\n+\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\tcase J9CPTYPE_CLASS: {\n+\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\tif ((NULL == clazz) && resolve) {\n+\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tif (NULL != clazz) {\n+\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_STRING: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_INT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_FLOAT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_LONG: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_DOUBLE: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHOD_TYPE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHODHANDLE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_CONSTANT_DYNAMIC: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\t} /* switch */\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing VM metadata.\n+ * Uses VM metadata (vmindex & vmtarget) to set symblic data fields (name & type & defc)\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName's symbolic data (name & type & defc) with the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\tif (NULL != signature) {\n+\t\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\t/* create field object */\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\tif (!J9ROMCLASS_IS_PRIMITIVE_OR_ARRAY(currentClass->romClass)) {\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tJ9Class *currentClass = currentITable->interfaceClass;\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tj9mem_free_memory(name);\n+\tj9mem_free_memory(sig);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long objectFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the objectFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.objectFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD) && J9_ARE_NO_BITS_SET(flags, J9AccStatic)) {\n+\t\t\t\tJ9JNIFieldID *fieldID = (J9JNIFieldID*)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tresult = (jlong)fieldID->offset + J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long staticFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the staticFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object staticFieldBase(MemberName self);  // e.g., returns clazz\n+ * \n+ * Returns the staticFieldBase of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldBase with the actual field object\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldBase(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjobject result = NULL;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object getMemberVMInfo(MemberName self);  // returns {vmindex,vmtarget}\n+ * \n+ * Return a 2-element java array containing the vm offset/target data\n+ * For a field MemberName, array contains:\n+ * \t\t(field offset, declaring class)\n+ * For a method MemberName, array contains:\n+ * \t\t(vtable index, MemberName object)\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Entry(env, self);\n+\tif (NULL != self) {\n+\t\tJ9Class *arrayClass = fetchArrayClass(currentThread, J9VMJAVALANGOBJECT(vm));\n+\t\tj9object_t arrayObject = vm->memoryManagerFunctions->J9AllocateIndexableObject(currentThread, arrayClass, 2, J9_GC_ALLOCATE_OBJECT_INSTRUMENTABLE);\n+\t\tif (NULL == arrayObject) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t} else {\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tj9object_t box = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == box) {\n+\t\t\t\t/* Drop arrayObject */\n+\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t} else {\n+\t\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tj9object_t target;\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmindex = ((J9JNIFieldID*)vmindex)->offset;\n+\t\t\t\t\ttarget = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\t\t} else {\n+\t\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex & ~J9_JNI_MID_INTERFACE;\n+\t\t\t\t\t} else if (0 == methodID->vTableIndex) {\n+\t\t\t\t\t\tvmindex = -1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex;\n+\t\t\t\t\t}\n+\t\t\t\t\ttarget = membernameObject;\n+\t\t\t\t}\n+\n+\t\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, box, vmindex);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, box);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, target);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, arrayObject);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+\n+}\n+\n+/**\n+ * static native void setCallSiteTargetNormal(CallSite site, MethodHandle target)\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetNormal(JNIEnv *env, jclass clazz, jobject callsite, jobject target)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == callsite) || (NULL == target)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t callsiteObject = J9_JNI_UNWRAP_REFERENCE(callsite);\n+\t\tj9object_t targetObject = J9_JNI_UNWRAP_REFERENCE(target);\n+\n+\t\tUDATA offset = (UDATA)vmFuncs->instanceFieldOffset(currentThread, J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callsiteObject), (U_8*)\"target\", strlen(\"target\"),  (U_8*)\"Ljava/lang/invoke/MethodHandle;\", strlen(\"Ljava/lang/invoke/MethodHandle;\"), NULL, NULL, 0);\n+\t\tMM_ObjectAccessBarrierAPI objectAccessBarrier = MM_ObjectAccessBarrierAPI(currentThread);\n+\t\tobjectAccessBarrier.inlineMixedObjectStoreObject(currentThread, callsiteObject, offset, targetObject, false);\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void setCallSiteTargetVolatile(CallSite site, MethodHandle target);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetVolatile(JNIEnv *env, jclass clazz, jobject callsite, jobject target)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwOTM5Ng=="}, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 1376}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxODA0MzIxOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQwNToyNDo1M1rOIU7Bxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDowMzo0NlrOIbZVnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwOTU0Mw==", "bodyText": "Why the commented code?", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r558809543", "createdAt": "2021-01-16T05:24:53Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tgoto done;\n+\t}\n+\n+\tmemset(signatures, 0, (numArgs) * sizeof(char*));\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\tif (NULL == signatures[i]) {\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\tif (NULL == rSignature) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tj9mem_free_memory(rSignature);\n+\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\tcase J9CPTYPE_CLASS: {\n+\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\tif ((NULL == clazz) && resolve) {\n+\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tif (NULL != clazz) {\n+\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_STRING: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_INT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_FLOAT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_LONG: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_DOUBLE: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHOD_TYPE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHODHANDLE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_CONSTANT_DYNAMIC: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\t} /* switch */\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing VM metadata.\n+ * Uses VM metadata (vmindex & vmtarget) to set symblic data fields (name & type & defc)\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName's symbolic data (name & type & defc) with the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\tif (NULL != signature) {\n+\t\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\t/* create field object */\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\tif (!J9ROMCLASS_IS_PRIMITIVE_OR_ARRAY(currentClass->romClass)) {\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tJ9Class *currentClass = currentITable->interfaceClass;\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tj9mem_free_memory(name);\n+\tj9mem_free_memory(sig);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long objectFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the objectFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.objectFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD) && J9_ARE_NO_BITS_SET(flags, J9AccStatic)) {\n+\t\t\t\tJ9JNIFieldID *fieldID = (J9JNIFieldID*)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tresult = (jlong)fieldID->offset + J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long staticFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the staticFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object staticFieldBase(MemberName self);  // e.g., returns clazz\n+ * \n+ * Returns the staticFieldBase of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldBase with the actual field object\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldBase(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjobject result = NULL;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object getMemberVMInfo(MemberName self);  // returns {vmindex,vmtarget}\n+ * \n+ * Return a 2-element java array containing the vm offset/target data\n+ * For a field MemberName, array contains:\n+ * \t\t(field offset, declaring class)\n+ * For a method MemberName, array contains:\n+ * \t\t(vtable index, MemberName object)\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Entry(env, self);\n+\tif (NULL != self) {\n+\t\tJ9Class *arrayClass = fetchArrayClass(currentThread, J9VMJAVALANGOBJECT(vm));\n+\t\tj9object_t arrayObject = vm->memoryManagerFunctions->J9AllocateIndexableObject(currentThread, arrayClass, 2, J9_GC_ALLOCATE_OBJECT_INSTRUMENTABLE);\n+\t\tif (NULL == arrayObject) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t} else {\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tj9object_t box = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == box) {\n+\t\t\t\t/* Drop arrayObject */\n+\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t} else {\n+\t\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tj9object_t target;\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmindex = ((J9JNIFieldID*)vmindex)->offset;\n+\t\t\t\t\ttarget = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\t\t} else {\n+\t\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex & ~J9_JNI_MID_INTERFACE;\n+\t\t\t\t\t} else if (0 == methodID->vTableIndex) {\n+\t\t\t\t\t\tvmindex = -1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex;\n+\t\t\t\t\t}\n+\t\t\t\t\ttarget = membernameObject;\n+\t\t\t\t}\n+\n+\t\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, box, vmindex);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, box);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, target);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, arrayObject);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+\n+}\n+\n+/**\n+ * static native void setCallSiteTargetNormal(CallSite site, MethodHandle target)\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetNormal(JNIEnv *env, jclass clazz, jobject callsite, jobject target)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == callsite) || (NULL == target)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t callsiteObject = J9_JNI_UNWRAP_REFERENCE(callsite);\n+\t\tj9object_t targetObject = J9_JNI_UNWRAP_REFERENCE(target);\n+\n+\t\tUDATA offset = (UDATA)vmFuncs->instanceFieldOffset(currentThread, J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callsiteObject), (U_8*)\"target\", strlen(\"target\"),  (U_8*)\"Ljava/lang/invoke/MethodHandle;\", strlen(\"Ljava/lang/invoke/MethodHandle;\"), NULL, NULL, 0);\n+\t\tMM_ObjectAccessBarrierAPI objectAccessBarrier = MM_ObjectAccessBarrierAPI(currentThread);\n+\t\tobjectAccessBarrier.inlineMixedObjectStoreObject(currentThread, callsiteObject, offset, targetObject, false);\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void setCallSiteTargetVolatile(CallSite site, MethodHandle target);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetVolatile(JNIEnv *env, jclass clazz, jobject callsite, jobject target)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == callsite) || (NULL == target)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t callsiteObject = J9_JNI_UNWRAP_REFERENCE(callsite);\n+\t\tj9object_t targetObject = J9_JNI_UNWRAP_REFERENCE(target);\n+\n+\t\tUDATA offset = (UDATA)vmFuncs->instanceFieldOffset(currentThread, J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callsiteObject), (U_8*)\"target\", strlen(\"target\"), (U_8*)\"Ljava/lang/invoke/MethodHandle;\", strlen(\"Ljava/lang/invoke/MethodHandle;\"), NULL, NULL, 0);\n+\t\tMM_ObjectAccessBarrierAPI objectAccessBarrier = MM_ObjectAccessBarrierAPI(currentThread);\n+\t\tobjectAccessBarrier.inlineMixedObjectStoreObject(currentThread, callsiteObject, offset, targetObject, true);\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void copyOutBootstrapArguments(Class<?> caller, int[] indexInfo,\n+\t\t\t\t\t\t\t\t\t\t\t\tint start, int end,\n+\t\t\t\t\t\t\t\t\t\t\t\tObject[] buf, int pos,\n+\t\t\t\t\t\t\t\t\t\t\t\tboolean resolve,\n+\t\t\t\t\t\t\t\t\t\t\t\tObject ifNotAvailable);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_copyOutBootstrapArguments(JNIEnv *env, jclass clazz, jclass caller, jintArray indexInfo, jint start, jint end, jobjectArray buf, jint pos, jboolean resolve, jobject ifNotAvailable)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == caller) || (NULL == indexInfo) || (NULL == buf)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_JCLASS(currentThread, caller);\n+\t\tj9array_t indexInfoArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(indexInfo);\n+\t\tj9array_t bufferArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(buf);\n+\n+\t\tif ((J9INDEXABLEOBJECT_SIZE(currentThread, indexInfoArray) < 2)) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else if (((start < -4) || (start > end) || (pos < 0)) || ((jint)J9INDEXABLEOBJECT_SIZE(currentThread, bufferArray) <= pos) || ((jint)J9INDEXABLEOBJECT_SIZE(currentThread, bufferArray) <= (pos + end - start))) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t} else {\n+\t\t\t/* U_16 bsmArgCount = (U_16)J9JAVAARRAYOFINT_LOAD(currentThread, indexInfoArray, 0); */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 1422}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5NzU5Nw==", "bodyText": "This should be identical to the argCount value from bsmData, I double checked against OJDK behavior and added a check that user value should be equal to jvm value.", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r565597597", "createdAt": "2021-01-27T20:03:46Z", "author": {"login": "fengxue-IS"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1529 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims++;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tgoto done;\n+\t}\n+\n+\tmemset(signatures, 0, (numArgs) * sizeof(char*));\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\tif (NULL == signatures[i]) {\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\tif (NULL == rSignature) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tj9mem_free_memory(rSignature);\n+\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\tcase J9CPTYPE_CLASS: {\n+\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\tif ((NULL == clazz) && resolve) {\n+\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tif (NULL != clazz) {\n+\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_STRING: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_INT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_FLOAT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_LONG: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_DOUBLE: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHOD_TYPE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHODHANDLE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_CONSTANT_DYNAMIC: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\t} /* switch */\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+\n+/**\n+ * static native void init(MemberName self, Object ref);\n+ *\n+ * Initializes a MemberName object using the given ref object.\n+ *\t\tsee initImpl for detail\n+ * Throw NPE if self or ref is null\n+ * Throw IllegalArgumentException if ref is not a field/method/constructor\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_init(JNIEnv *env, jclass clazz, jobject self, jobject ref)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Entry(env, self, ref);\n+\tif ((NULL == self) || (NULL == ref)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t refObject = J9_JNI_UNWRAP_REFERENCE(ref);\n+\n+\t\tinitImpl(currentThread, membernameObject, refObject);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_init_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void expand(MemberName self);\n+ *\n+ * Given a MemberName object, try to set the uninitialized fields from existing VM metadata.\n+ * Uses VM metadata (vmindex & vmtarget) to set symblic data fields (name & type & defc)\n+ *\n+ * Throws NullPointerException if MemberName object is null.\n+ * Throws IllegalArgumentException if MemberName doesn't contain required data to expand.\n+ * Throws InternalError if the MemberName object contains invalid data or completely uninitialized.\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_expand(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjlong vmindex = (jlong)J9OBJECT_ADDRESS_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Data(env, membernameObject, flags, vmindex);\n+\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t/* For Field MemberName, the clazz and vmindex fields must be set. */\n+\t\t\tif ((NULL != J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) && (NULL != (void*)vmindex)) {\n+\t\t\t\tJ9JNIFieldID *field = (J9JNIFieldID*)vmindex;\n+\n+\t\t\t\t/* if name/type field is uninitialized, create j.l.String from ROM field name/sig and store in MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMFIELDSHAPE_NAME(field->field);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMFIELDSHAPE_SIGNATURE(field->field);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\tif (NULL != (void*)vmindex) {\n+\t\t\t\t/* For method/constructor MemberName, the vmindex field is required for expand.*/\n+\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\t\t\t/* Retrieve method info using JNIMethodID, store to MN fields. */\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject)) {\n+\t\t\t\t\tj9object_t newClassObject = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(methodID->method));\n+\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, newClassObject);\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *name = J9ROMMETHOD_NAME(romMethod);\n+\t\t\t\t\tj9object_t nameString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(name), (U_32)J9UTF8_LENGTH(name), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != nameString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (NULL == J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject)) {\n+\t\t\t\t\tJ9UTF8 *signature = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\tj9object_t signatureString = vm->memoryManagerFunctions->j9gc_createJavaLangString(currentThread, J9UTF8_DATA(signature), (U_32)J9UTF8_LENGTH(signature), J9_STR_INTERN);\n+\t\t\t\t\tif (NULL != signatureString) {\n+\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, signatureString);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_expand_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native MemberName resolve(MemberName self, Class<?> caller,\n+ *      boolean speculativeResolve) throws LinkageError, ClassNotFoundException;\n+ *\n+ * Resolve the method/field represented by the MemberName's symbolic data (name & type & defc) with the supplied caller\n+ * Store the resolved Method/Field's JNI-id in vmindex, field offset / method pointer in vmtarget\n+ *\n+ * If the speculativeResolve flag is not set, failed resolution will throw the corresponding exception.\n+ * If the resolution failed with no exception:\n+ * Throw NoSuchFieldError for field MemberName\n+ * Throw NoSuchMethodError for method/constructor MemberName\n+ * Throw LinkageError for other\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_resolve(JNIEnv *env, jclass clazz, jobject self, jclass caller, jboolean speculativeResolve)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Entry(env, self, caller, (speculativeResolve ? \"true\" : \"false\"));\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\tjlong target = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\n+\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\tjint new_flags = 0;\n+\t\tj9object_t new_clazz = NULL;\n+\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Data(env, membernameObject, caller, flags, vmindex, target);\n+\t\t/* Check if MemberName is already resolved */\n+\t\tif (0 != target) {\n+\t\t\tresult = self;\n+\t\t} else {\n+\t\t\t/* Initialize nameObject after creating typeString which could trigger GC */\n+\t\t\tj9object_t nameObject = NULL;\n+\t\t\tj9object_t typeObject = J9VMJAVALANGINVOKEMEMBERNAME_TYPE(currentThread, membernameObject);\n+\t\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\tJ9Class *resolvedClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, clazzObject);\n+\n+\t\t\tjint ref_kind = (flags >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK;\n+\n+\t\t\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\t\t\tUDATA nameLength = 0;\n+\t\t\tchar *name = NULL;\n+\t\t\tUDATA signatureLength = 0;\n+\t\t\tchar *signature = NULL;\n+\t\t\tJ9Class *typeClass = J9OBJECT_CLAZZ(currentThread, typeObject);\n+\n+\t\t\t/* The type field of a MemberName could be in:\n+\t\t\t *     MethodType:\tMethodType representing method/constructor MemberName's method signature\n+\t\t\t *     String:\t\tString representing MemberName's signature (field or method)\n+\t\t\t *     Class:\t\tClass representing field MemberName's field type\n+\t\t\t */\n+\t\t\tif (J9VMJAVALANGINVOKEMETHODTYPE(vm) == typeClass) {\n+\t\t\t\tj9object_t sigString = J9VMJAVALANGINVOKEMETHODTYPE_METHODDESCRIPTOR(currentThread, typeObject);\n+\t\t\t\tif (NULL != sigString) {\n+\t\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsignature = getSignatureFromMethodType(currentThread, typeObject, &signatureLength);\n+\t\t\t\t\t// TODO store this signature as j.l.String in MT\n+\t\t\t\t}\n+\t\t\t} else if (J9VMJAVALANGSTRING_OR_NULL(vm) == typeClass) {\n+\t\t\t\tsignature = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, typeObject, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, \"\", 0, NULL, 0, &signatureLength);\n+\t\t\t} else if (J9VMJAVALANGCLASS(vm) == typeClass) {\n+\t\t\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, typeObject);\n+\t\t\t\tsignature = getClassSignature(currentThread, rclass);\n+\t\t\t\tif (NULL != signature) {\n+\t\t\t\t\tsignatureLength = strlen(signature);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Check if signature string is correctly generated */\n+\t\t\tif (NULL == signature) {\n+\t\t\t\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\t}\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\t/* Refetch reference after GC point */\n+\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\tnameObject = J9VMJAVALANGINVOKEMEMBERNAME_NAME(currentThread, membernameObject);\n+\t\t\tname = vmFuncs->copyStringToUTF8WithMemAlloc(currentThread, nameObject, J9_STR_NULL_TERMINATE_RESULT, \"\", 0, NULL, 0, &nameLength);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tj9mem_free_memory(signature);\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_NAS(env, name, signature);\n+\n+\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_METHOD | MN_IS_CONSTRUCTOR)) {\n+\t\t\t\tj9object_t callerObject = (NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller);\n+\t\t\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callerObject);\n+\n+\t\t\t\tJ9JNINameAndSignature nas;\n+\t\t\t\tUDATA lookupOptions = J9_LOOK_JNI;\n+\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_LOOK_NO_THROW;\n+\t\t\t\t}\n+\n+\t\t\t\t/* Determine the lookup type based on reference kind and resolved class flags */\n+\t\t\t\tswitch (ref_kind)\n+\t\t\t\t{\n+\t\t\t\t\tcase MH_REF_INVOKEINTERFACE:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESPECIAL:\n+\t\t\t\t\t\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase MH_REF_INVOKESTATIC:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_STATIC;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n+\t\t\t\t\t\t\tlookupOptions |= J9_LOOK_INTERFACE;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tnas.name = name;\n+\t\t\t\tnas.signature = signature;\n+\t\t\t\tnas.nameLength = (U_32)nameLength;\n+\t\t\t\tnas.signatureLength = (U_32)signatureLength;\n+\n+\t\t\t\t/* Check if signature polymorphic native calls */\n+\t\t\t\tJ9Method *method = lookupMethod(currentThread, resolvedClass, &nas, callerClass, lookupOptions);\n+\n+\t\t\t\t/* Check for resolution exception */\n+\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\tgoto done;\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != method) {\n+\t\t\t\t\tJ9JNIMethodID *methodID = vmFuncs->getJNIMethodID(currentThread, method);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)methodID;\n+\t\t\t\t\ttarget = (jlong)(UDATA)method;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(J9_CLASS_FROM_METHOD(method));\n+\n+\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\t\t\t\t\tnew_flags = flags | (romMethod->modifiers & CFR_METHOD_ACCESS_MASK);\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\t\t\t\tnew_flags |= MN_CALLER_SENSITIVE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} if (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\tJ9Class *declaringClass;\n+\t\t\t\tJ9ROMFieldShape *romField;\n+\t\t\t\tUDATA lookupOptions = 0;\n+\t\t\t\tUDATA offset = 0;\n+\t\t\t\tif (JNI_TRUE == speculativeResolve) {\n+\t\t\t\t\tlookupOptions |= J9_RESOLVE_FLAG_NO_THROW_ON_FAIL;\n+\t\t\t\t}\n+\n+\t\t\t\t/* MemberName doesn't differentiate if a field is static or not,\n+\t\t\t\t * the resolve code have to attempt to resolve as instance field first,\n+\t\t\t\t * then as static field if the first attempt failed.\n+\t\t\t\t */\n+\t\t\t\toffset = vmFuncs->instanceFieldOffset(currentThread,\n+\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\tlookupOptions);\n+\n+\t\t\t\tif (offset == (UDATA)-1) {\n+\t\t\t\t\tdeclaringClass = NULL;\n+\n+\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\tVM_VMHelpers::clearException(currentThread);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tvoid* fieldAddress = vmFuncs->staticFieldAddress(currentThread,\n+\t\t\t\t\t\tresolvedClass,\n+\t\t\t\t\t\t(U_8*)name, strlen(name),\n+\t\t\t\t\t\t(U_8*)signature, strlen(signature),\n+\t\t\t\t\t\t&declaringClass, (UDATA*)&romField,\n+\t\t\t\t\t\tlookupOptions,\n+\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\tif (fieldAddress == NULL) {\n+\t\t\t\t\t\tdeclaringClass = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\toffset = (UDATA)fieldAddress - (UDATA)declaringClass->ramStatics;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != declaringClass) {\n+\t\t\t\t\tUDATA inconsistentData = 0;\n+\t\t\t\t\tJ9JNIFieldID *fieldID = vmFuncs->getJNIFieldID(currentThread, declaringClass, romField, offset, &inconsistentData);\n+\t\t\t\t\tvmindex = (jlong)(UDATA)fieldID;\n+\n+\t\t\t\t\tnew_clazz = J9VM_J9CLASS_TO_HEAPCLASS(declaringClass);\n+\t\t\t\t\tnew_flags = MN_IS_FIELD | (fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK);\n+\t\t\t\t\tromField = fieldID->field;\n+\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccStatic)) {\n+\t\t\t\t\t\toffset = fieldID->offset | J9_SUN_STATIC_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(romField->modifiers, J9AccFinal)) {\n+\t\t\t\t\t\t\toffset |= J9_SUN_FINAL_FIELD_OFFSET_TAG;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETSTATIC << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif ((MH_REF_PUTFIELD == ref_kind) || (MH_REF_PUTSTATIC == ref_kind)) {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_PUTFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tnew_flags |= (MH_REF_GETFIELD << MN_REFERENCE_KIND_SHIFT);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\ttarget = (jlong)offset;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tj9mem_free_memory(name);\n+\t\t\tj9mem_free_memory(signature);\n+\n+\t\t\tif ((0 != vmindex) && (0 != target)) {\n+\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\tmembernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, new_flags);\n+\t\t\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, new_clazz);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\t\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\n+\t\t\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_resolved(env, vmindex, target, new_clazz, flags);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, membernameObject);\n+\t\t\t}\n+\n+\t\t\tif ((NULL == result) && (JNI_TRUE != speculativeResolve) && !VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHFIELDERROR, NULL);\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(flags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNOSUCHMETHODERROR, NULL);\n+\t\t\t\t} else {\n+\t\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+done:\n+\tif ((JNI_TRUE == speculativeResolve) && VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tVM_VMHelpers::clearException(currentThread);\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_resolve_Exit(env);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native int getMembers(Class<?> defc, String matchName, String matchSig,\n+ *      int matchFlags, Class<?> caller, int skip, MemberName[] results);\n+ *\n+ * Search the defc (defining class) chain for field/method that matches the given search parameters,\n+ * for each matching result found, initialize the next MemberName object in results array to reference the found field/method\n+ *\n+ *  - defc: the class to start the search\n+ *  - matchName: name to match, NULL to match any field/method name\n+ *  - matchSig: signature to match, NULL to match any field/method type\n+ *  - matchFlags: flags defining search options:\n+ *  \t\tMN_IS_FIELD - search for fields\n+ *  \t\tMN_IS_CONSTRUCTOR | MN_IS_METHOD - search for method/constructor\n+ *  \t\tMN_SEARCH_SUPERCLASSES - search the superclasses of the defining class\n+ *  \t\tMN_SEARCH_INTERFACES - search the interfaces implemented by the defining class\n+ *  - caller: the caller class performing the lookup\n+ *  - skip: number of matching results to skip before storing\n+ *  - results: an array of MemberName objects to hold the matched field/method\n+ */\n+jint JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMembers(JNIEnv *env, jclass clazz, jclass defc, jstring matchName, jstring matchSig, jint matchFlags, jclass caller, jint skip, jobjectArray results)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjint result = 0;\n+\tJ9UTF8 *name = NULL;\n+\tJ9UTF8 *sig = NULL;\n+\tj9object_t callerObject = ((NULL == caller) ? NULL : J9_JNI_UNWRAP_REFERENCE(caller));\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Entry(env, defc, matchName, matchSig, matchFlags, caller, skip, results);\n+\n+\tif ((NULL == defc) || (NULL == results) || ((NULL != callerObject) && (J9VMJAVALANGCLASS(vm) != J9OBJECT_CLAZZ(currentThread, callerObject)))) {\n+\t\tresult = -1;\n+\t} else {\n+\t\tj9object_t defcObject = J9_JNI_UNWRAP_REFERENCE(defc);\n+\t\tJ9Class *defClass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, defcObject);\n+\n+\t\tif (NULL != matchName) {\n+\t\t\tname = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchName), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == name) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\t\tif (NULL != matchSig) {\n+\t\t\tsig = vmFuncs->copyStringToJ9UTF8WithMemAlloc(currentThread, J9_JNI_UNWRAP_REFERENCE(matchSig), J9_STR_NONE, \"\", 0, NULL, 0);\n+\t\t\tif (NULL == sig) {\n+\t\t\t\tvmFuncs->setNativeOutOfMemoryError(currentThread, 0, 0);\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!(((NULL != matchName) && (0 == J9UTF8_LENGTH(name))) || ((NULL != matchSig) && (0 == J9UTF8_LENGTH(sig))))) {\n+\t\t\tj9array_t resultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\tUDATA length = J9INDEXABLEOBJECT_SIZE(currentThread, resultsArray);\n+\t\t\tUDATA index = 0;\n+\n+\t\t\tif (J9ROMCLASS_IS_INTERFACE(defClass->romClass)) {\n+\t\t\t\tresult = -1;\n+\t\t\t} else {\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_FIELD)) {\n+\t\t\t\t\tJ9ROMFieldShape *romField = NULL;\n+\t\t\t\t\tJ9ROMFieldWalkState walkState;\n+\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\t/* walk currentClass */\n+\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\tromField = romFieldsStartDo(currentClass->romClass, &walkState);\n+\n+\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t/* create static field object */\n+\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tmemset(&walkState, 0, sizeof(walkState));\n+\t\t\t\t\t\t\tromField = romFieldsStartDo(currentITable->interfaceClass->romClass, &walkState);\n+\t\t\t\t\t\t\twhile (NULL != romField) {\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMFIELDSHAPE_NAME(romField);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMFIELDSHAPE_SIGNATURE(romField);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\t/* create field object */\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t fieldObj = vm->reflectFunctions.createFieldObject(currentThread, romField, defClass, (romField->modifiers & J9AccStatic) == J9AccStatic);\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != fieldObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, fieldObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tromField = romFieldsNextDo(&walkState);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else if (J9_ARE_ANY_BITS_SET(matchFlags, MN_IS_CONSTRUCTOR | MN_IS_METHOD)) {\n+\t\t\t\t\tUDATA classDepth = 0;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_SUPERCLASSES)) {\n+\t\t\t\t\t\t/* walk superclasses */\n+\t\t\t\t\t\tJ9CLASS_DEPTH(defClass);\n+\t\t\t\t\t}\n+\t\t\t\t\tJ9Class *currentClass = defClass;\n+\n+\t\t\t\t\twhile (NULL != currentClass) {\n+\t\t\t\t\t\tif (!J9ROMCLASS_IS_PRIMITIVE_OR_ARRAY(currentClass->romClass)) {\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* get the superclass */\n+\t\t\t\t\t\tif (classDepth >= 1) {\n+\t\t\t\t\t\t\tclassDepth -= 1;\n+\t\t\t\t\t\t\tcurrentClass = defClass->superclasses[classDepth];\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tcurrentClass = NULL;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* walk interfaces */\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(matchFlags, MN_SEARCH_INTERFACES)) {\n+\t\t\t\t\t\tJ9ITable *currentITable = (J9ITable *)defClass->iTable;\n+\n+\t\t\t\t\t\twhile (NULL != currentITable) {\n+\t\t\t\t\t\t\tJ9Class *currentClass = currentITable->interfaceClass;\n+\t\t\t\t\t\t\tJ9Method *currentMethod = currentClass->ramMethods;\n+\t\t\t\t\t\t\tJ9Method *endOfMethods = currentMethod + currentClass->romClass->romMethodCount;\n+\t\t\t\t\t\t\twhile (currentMethod != endOfMethods) {\n+\t\t\t\t\t\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(currentMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *nameUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\t\t\t\t\t\t\t\tJ9UTF8 *signatureUTF = J9ROMMETHOD_SIGNATURE(romMethod);\n+\n+\t\t\t\t\t\t\t\tif (((NULL == matchName) || J9UTF8_EQUALS(name, nameUTF))\n+\t\t\t\t\t\t\t\t&& ((NULL == matchSig) || J9UTF8_EQUALS(sig, signatureUTF))\n+\t\t\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\t\t\tif (skip > 0) {\n+\t\t\t\t\t\t\t\t\t\tskip -=1;\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tif (index < length) {\n+\t\t\t\t\t\t\t\t\t\t\t/* Refetch reference after GC point */\n+\t\t\t\t\t\t\t\t\t\t\tresultsArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(results);\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t memberName = J9JAVAARRAYOFOBJECT_LOAD(currentThread, resultsArray, index);\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL == memberName) {\n+\t\t\t\t\t\t\t\t\t\t\t\tresult = -99;\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, memberName);\n+\n+\t\t\t\t\t\t\t\t\t\t\tj9object_t methodObj = NULL;\n+\t\t\t\t\t\t\t\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccStatic) && ('<' == (char)*J9UTF8_DATA(J9ROMMETHOD_NAME(romMethod)))) {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create constructor object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createConstructorObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\t\t/* create method object */\n+\t\t\t\t\t\t\t\t\t\t\t\tmethodObj = vm->reflectFunctions.createMethodObject(currentMethod, currentClass, NULL, currentThread);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tmemberName = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\n+\t\t\t\t\t\t\t\t\t\t\tif (NULL != methodObj) {\n+\t\t\t\t\t\t\t\t\t\t\t\tinitImpl(currentThread, memberName, methodObj);\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\tif (VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\t\t\t\t\t\t\t\t\t\t\tgoto done;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tresult += 1;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcurrentMethod += 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcurrentITable = currentITable->next;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tj9mem_free_memory(name);\n+\tj9mem_free_memory(sig);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMembers_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long objectFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the objectFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.objectFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_objectFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD) && J9_ARE_NO_BITS_SET(flags, J9AccStatic)) {\n+\t\t\t\tJ9JNIFieldID *fieldID = (J9JNIFieldID*)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tresult = (jlong)fieldID->offset + J9VMTHREAD_OBJECT_HEADER_SIZE(currentThread);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_objectFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native long staticFieldOffset(MemberName self);  // e.g., returns vmindex\n+ * \n+ * Returns the staticFieldOffset of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldOffset with the actual field object\n+ */\n+jlong JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldOffset(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjlong result = 0;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Entry(env, self);\n+\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmtargetOffset);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldOffset_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object staticFieldBase(MemberName self);  // e.g., returns clazz\n+ * \n+ * Returns the staticFieldBase of the field represented by the MemberName\n+ * result should be same as if calling Unsafe.staticFieldBase with the actual field object\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_staticFieldBase(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\tjobject result = NULL;\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Entry(env, self);\n+\tif (NULL == self) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\tj9object_t clazzObject = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\n+\t\tif (NULL == clazzObject) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else {\n+\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\tif (J9_ARE_ALL_BITS_SET(flags, MN_IS_FIELD & J9AccStatic)) {\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, clazzObject);\n+\t\t\t} else {\n+\t\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_staticFieldBase_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+}\n+\n+/**\n+ * static native Object getMemberVMInfo(MemberName self);  // returns {vmindex,vmtarget}\n+ * \n+ * Return a 2-element java array containing the vm offset/target data\n+ * For a field MemberName, array contains:\n+ * \t\t(field offset, declaring class)\n+ * For a method MemberName, array contains:\n+ * \t\t(vtable index, MemberName object)\n+ */\n+jobject JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_getMemberVMInfo(JNIEnv *env, jclass clazz, jobject self)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tjobject result = NULL;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Entry(env, self);\n+\tif (NULL != self) {\n+\t\tJ9Class *arrayClass = fetchArrayClass(currentThread, J9VMJAVALANGOBJECT(vm));\n+\t\tj9object_t arrayObject = vm->memoryManagerFunctions->J9AllocateIndexableObject(currentThread, arrayClass, 2, J9_GC_ALLOCATE_OBJECT_INSTRUMENTABLE);\n+\t\tif (NULL == arrayObject) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t} else {\n+\t\t\tPUSH_OBJECT_IN_SPECIAL_FRAME(currentThread, arrayObject);\n+\t\t\tj9object_t box = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\t\tif (NULL == box) {\n+\t\t\t\t/* Drop arrayObject */\n+\t\t\t\tDROP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\t} else {\n+\t\t\t\tarrayObject = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);\n+\t\t\t\tj9object_t membernameObject = J9_JNI_UNWRAP_REFERENCE(self);\n+\t\t\t\tjint flags = J9VMJAVALANGINVOKEMEMBERNAME_FLAGS(currentThread, membernameObject);\n+\t\t\t\tjlong vmindex = (jlong)(UDATA)J9OBJECT_U64_LOAD(currentThread, membernameObject, vm->vmindexOffset);\n+\t\t\t\tj9object_t target;\n+\t\t\t\tif (J9_ARE_ANY_BITS_SET(flags, MN_IS_FIELD)) {\n+\t\t\t\t\tvmindex = ((J9JNIFieldID*)vmindex)->offset;\n+\t\t\t\t\ttarget = J9VMJAVALANGINVOKEMEMBERNAME_CLAZZ(currentThread, membernameObject);\n+\t\t\t\t} else {\n+\t\t\t\t\tJ9JNIMethodID *methodID = (J9JNIMethodID*)vmindex;\n+\t\t\t\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex & ~J9_JNI_MID_INTERFACE;\n+\t\t\t\t\t} else if (0 == methodID->vTableIndex) {\n+\t\t\t\t\t\tvmindex = -1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvmindex = methodID->vTableIndex;\n+\t\t\t\t\t}\n+\t\t\t\t\ttarget = membernameObject;\n+\t\t\t\t}\n+\n+\t\t\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, box, vmindex);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, box);\n+\t\t\t\tJ9JAVAARRAYOFOBJECT_STORE(currentThread, arrayObject, 0, target);\n+\n+\t\t\t\tresult = vmFuncs->j9jni_createLocalRef(env, arrayObject);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tTrc_JCL_java_lang_invoke_MethodHandleNatives_getMemberVMInfo_Exit(env, result);\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+\treturn result;\n+\n+}\n+\n+/**\n+ * static native void setCallSiteTargetNormal(CallSite site, MethodHandle target)\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetNormal(JNIEnv *env, jclass clazz, jobject callsite, jobject target)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == callsite) || (NULL == target)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t callsiteObject = J9_JNI_UNWRAP_REFERENCE(callsite);\n+\t\tj9object_t targetObject = J9_JNI_UNWRAP_REFERENCE(target);\n+\n+\t\tUDATA offset = (UDATA)vmFuncs->instanceFieldOffset(currentThread, J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callsiteObject), (U_8*)\"target\", strlen(\"target\"),  (U_8*)\"Ljava/lang/invoke/MethodHandle;\", strlen(\"Ljava/lang/invoke/MethodHandle;\"), NULL, NULL, 0);\n+\t\tMM_ObjectAccessBarrierAPI objectAccessBarrier = MM_ObjectAccessBarrierAPI(currentThread);\n+\t\tobjectAccessBarrier.inlineMixedObjectStoreObject(currentThread, callsiteObject, offset, targetObject, false);\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void setCallSiteTargetVolatile(CallSite site, MethodHandle target);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_setCallSiteTargetVolatile(JNIEnv *env, jclass clazz, jobject callsite, jobject target)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == callsite) || (NULL == target)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t callsiteObject = J9_JNI_UNWRAP_REFERENCE(callsite);\n+\t\tj9object_t targetObject = J9_JNI_UNWRAP_REFERENCE(target);\n+\n+\t\tUDATA offset = (UDATA)vmFuncs->instanceFieldOffset(currentThread, J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callsiteObject), (U_8*)\"target\", strlen(\"target\"), (U_8*)\"Ljava/lang/invoke/MethodHandle;\", strlen(\"Ljava/lang/invoke/MethodHandle;\"), NULL, NULL, 0);\n+\t\tMM_ObjectAccessBarrierAPI objectAccessBarrier = MM_ObjectAccessBarrierAPI(currentThread);\n+\t\tobjectAccessBarrier.inlineMixedObjectStoreObject(currentThread, callsiteObject, offset, targetObject, true);\n+\t}\n+\tvmFuncs->internalExitVMToJNI(currentThread);\n+}\n+\n+/**\n+ * static native void copyOutBootstrapArguments(Class<?> caller, int[] indexInfo,\n+\t\t\t\t\t\t\t\t\t\t\t\tint start, int end,\n+\t\t\t\t\t\t\t\t\t\t\t\tObject[] buf, int pos,\n+\t\t\t\t\t\t\t\t\t\t\t\tboolean resolve,\n+\t\t\t\t\t\t\t\t\t\t\t\tObject ifNotAvailable);\n+ */\n+void JNICALL\n+Java_java_lang_invoke_MethodHandleNatives_copyOutBootstrapArguments(JNIEnv *env, jclass clazz, jclass caller, jintArray indexInfo, jint start, jint end, jobjectArray buf, jint pos, jboolean resolve, jobject ifNotAvailable)\n+{\n+\tJ9VMThread *currentThread = (J9VMThread*)env;\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == caller) || (NULL == indexInfo) || (NULL == buf)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t} else {\n+\t\tJ9Class *callerClass = J9VM_J9CLASS_FROM_JCLASS(currentThread, caller);\n+\t\tj9array_t indexInfoArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(indexInfo);\n+\t\tj9array_t bufferArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(buf);\n+\n+\t\tif ((J9INDEXABLEOBJECT_SIZE(currentThread, indexInfoArray) < 2)) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGINTERNALERROR, NULL);\n+\t\t} else if (((start < -4) || (start > end) || (pos < 0)) || ((jint)J9INDEXABLEOBJECT_SIZE(currentThread, bufferArray) <= pos) || ((jint)J9INDEXABLEOBJECT_SIZE(currentThread, bufferArray) <= (pos + end - start))) {\n+\t\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, NULL);\n+\t\t} else {\n+\t\t\t/* U_16 bsmArgCount = (U_16)J9JAVAARRAYOFINT_LOAD(currentThread, indexInfoArray, 0); */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgwOTU0Mw=="}, "originalCommit": {"oid": "a7bf780bff333f7df479c7e92728a957f8ac0085"}, "originalPosition": 1422}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3MTg3MDUxOnYy", "diffSide": "RIGHT", "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxOToxMzoyMFrOIcxOVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxOToxMzoyMFrOIcxOVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzAzNzUyNQ==", "bodyText": "This seems like a good candidate to put these in the VMConstantpool", "url": "https://github.com/eclipse-openj9/openj9/pull/10690#discussion_r567037525", "createdAt": "2021-01-29T19:13:20Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/java_lang_invoke_MethodHandleNatives.cpp", "diffHunk": "@@ -0,0 +1,1527 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021, 2021 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"jclprots.h\"\n+#include \"j9cp.h\"\n+#include \"j9protos.h\"\n+#include \"ut_j9jcl.h\"\n+#include \"j9port.h\"\n+#include \"jclglob.h\"\n+#include \"jcl_internal.h\"\n+#include \"util_api.h\"\n+#include \"j9vmconstantpool.h\"\n+#include \"ObjectAccessBarrierAPI.hpp\"\n+#include \"objhelp.h\"\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+#include \"VMHelpers.hpp\"\n+\n+extern \"C\" {\n+\n+/* Constants mapped from java.lang.invoke.MethodHandleNatives$Constants\n+ * These constants are validated by the MethodHandleNatives$Constants.verifyConstants()\n+ * method when Java assertions are enabled\n+ */\n+#define MN_IS_METHOD\t\t0x00010000\n+#define MN_IS_CONSTRUCTOR\t0x00020000\n+#define MN_IS_FIELD\t\t\t0x00040000\n+#define MN_IS_TYPE\t\t\t0x00080000\n+#define MN_CALLER_SENSITIVE\t0x00100000\n+\n+#define MN_REFERENCE_KIND_SHIFT\t24\n+#define MN_REFERENCE_KIND_MASK\t0xF\t\t/* (flag >> MN_REFERENCE_KIND_SHIFT) & MN_REFERENCE_KIND_MASK */\n+\n+#define MN_SEARCH_SUPERCLASSES\t0x00100000\n+#define MN_SEARCH_INTERFACES\t0x00200000\n+\n+/* Private MemberName object init helper \n+ *\n+ * Set the MemberName fields based on the refObject given:\n+ * For j.l.reflect.Field:\n+ *\t\tfind JNIFieldID for refObject, create j.l.String for name and signature and store in MN.name/type fields.\n+ *\t\tset vmindex to the fieldID pointer and target to the J9ROMFieldShape struct.\n+ *\t\tset MN.clazz to declaring class in the fieldID struct.\n+ * For j.l.reflect.Method or j.l.reflect.Constructor:\n+ *\t\tfind JNIMethodID, set vmindex to the methodID pointer and target to the J9Method struct.\n+ *\t\tset MN.clazz to the refObject's declaring class.\n+ *\n+ * Then for both, compute the MN.flags using access flags and invocation type based on the JNI-id.\n+ *\n+ * Throw an IllegalArgumentException if the refObject is not a Field/Method/Constructor\n+ *\n+ * Note: caller must have vmaccess before invoking this helper\n+ */\n+static void\n+initImpl(J9VMThread *currentThread, j9object_t membernameObject, j9object_t refObject)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tJ9Class* refClass = J9OBJECT_CLAZZ(currentThread, refObject);\n+\n+\tjint flags = 0;\n+\tjlong vmindex = 0;\n+\tjlong target = 0;\n+\tj9object_t clazzObject = NULL;\n+\tj9object_t nameObject = NULL;\n+\tj9object_t typeObject = NULL;\n+\n+\tif (refClass == J9VMJAVALANGREFLECTFIELD(vm)) {\n+\t\tJ9JNIFieldID *fieldID = vm->reflectFunctions.idFromFieldObject(currentThread, NULL, refObject);\n+\t\tvmindex = (jlong)fieldID;\n+\t\ttarget = (jlong)fieldID->field;\n+\n+\t\tflags = fieldID->field->modifiers & CFR_FIELD_ACCESS_MASK;\n+\t\tflags |= MN_IS_FIELD;\n+\t\tflags |= (J9_ARE_ANY_BITS_SET(flags, J9AccStatic) ? MH_REF_GETSTATIC : MH_REF_GETFIELD) << MN_REFERENCE_KIND_SHIFT;\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTFIELD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTFIELD_TYPE(currentThread, refObject);\n+\n+\t\tclazzObject = J9VM_J9CLASS_TO_HEAPCLASS(fieldID->declaringClass);\n+\t} else if (refClass == J9VMJAVALANGREFLECTMETHOD(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromMethodObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_METHOD;\n+\t\tif (J9_ARE_ANY_BITS_SET(methodID->vTableIndex, J9_JNI_MID_INTERFACE)) {\n+\t\t\tflags |= MH_REF_INVOKEINTERFACE << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccStatic)) {\n+\t\t\tflags |= MH_REF_INVOKESTATIC << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else if (J9_ARE_ANY_BITS_SET(romMethod->modifiers , J9AccFinal) || !J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n+\t\t\tflags |= MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t} else {\n+\t\t\tflags |= MH_REF_INVOKEVIRTUAL << MN_REFERENCE_KIND_SHIFT;\n+\t\t}\n+\n+\t\tnameObject = J9VMJAVALANGREFLECTMETHOD_NAME(currentThread, refObject);\n+\t\ttypeObject = J9VMJAVALANGREFLECTMETHOD_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else if (refClass == J9VMJAVALANGREFLECTCONSTRUCTOR(vm)) {\n+\t\tJ9JNIMethodID *methodID = vm->reflectFunctions.idFromConstructorObject(currentThread, refObject);\n+\t\tvmindex = (jlong)methodID;\n+\t\ttarget = (jlong)methodID->method;\n+\n+\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(methodID->method);\n+\n+\t\tflags = romMethod->modifiers & CFR_METHOD_ACCESS_MASK;\n+\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccMethodCallerSensitive)) {\n+\t\t\tflags |= MN_CALLER_SENSITIVE;\n+\t\t}\n+\t\tflags |= MN_IS_CONSTRUCTOR | (MH_REF_INVOKESPECIAL << MN_REFERENCE_KIND_SHIFT);\n+\n+\t\ttypeObject = J9VMJAVALANGREFLECTCONSTRUCTOR_SIGNATURE(currentThread, refObject);\n+\t\tclazzObject = J9VMJAVALANGREFLECTMETHOD_DECLARINGCLASS(currentThread, refObject);\n+\t} else {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGILLEGALARGUMENTEXCEPTION, NULL);\n+\t}\n+\n+\tif (!VM_VMHelpers::exceptionPending(currentThread)) {\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_FLAGS(currentThread, membernameObject, flags);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_NAME(currentThread, membernameObject, nameObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_TYPE(currentThread, membernameObject, typeObject);\n+\t\tJ9VMJAVALANGINVOKEMEMBERNAME_SET_CLAZZ(currentThread, membernameObject, clazzObject);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmindexOffset, (U_64)vmindex);\n+\t\tJ9OBJECT_U64_STORE(currentThread, membernameObject, vm->vmtargetOffset, (U_64)target);\n+\t\tTrc_JCL_java_lang_invoke_MethodHandleNatives_initImpl_setData(currentThread, flags, nameObject, typeObject, clazzObject, vmindex, target);\n+\t}\n+}\n+\n+static char *\n+sigForPrimitiveOrVoid(J9JavaVM *vm, J9Class *clazz)\n+{\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar* signature = (char*)j9mem_allocate_memory(2, OMRMEM_CATEGORY_VM);\n+\n+\tif (NULL != signature) {\n+\t\tif (clazz == vm->booleanReflectClass) {\n+\t\t\tsignature[0] = 'Z';\n+\t\t} else if (clazz == vm->byteReflectClass) {\n+\t\t\tsignature[0] = 'B';\n+\t\t} else if (clazz == vm->charReflectClass) {\n+\t\t\tsignature[0] = 'C';\n+\t\t} else if (clazz == vm->shortReflectClass) {\n+\t\t\tsignature[0] = 'S';\n+\t\t} else if (clazz == vm->intReflectClass) {\n+\t\t\tsignature[0] = 'I';\n+\t\t} else if (clazz == vm->longReflectClass) {\n+\t\t\tsignature[0] = 'J';\n+\t\t} else if (clazz == vm->floatReflectClass) {\n+\t\t\tsignature[0] = 'F';\n+\t\t} else if (clazz == vm->doubleReflectClass) {\n+\t\t\tsignature[0] = 'D';\n+\t\t} else if (clazz == vm->voidReflectClass) {\n+\t\t\tsignature[0] = 'V';\n+\t\t}\n+\n+\t\tsignature[1] = '\\0';\n+\t}\n+\n+\treturn signature;\n+}\n+\n+static char *\n+getClassSignature(J9VMThread *currentThread, J9Class * clazz)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\tchar *sig = NULL;\n+\n+\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(clazz->romClass)) {\n+\t\tsig = sigForPrimitiveOrVoid(vm, clazz);\n+\t} else {\n+\t\tj9object_t sigString = J9VMJAVALANGCLASS_CLASSNAMESTRING(currentThread, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n+\t\tif (NULL != sigString) {\n+\t\t\t/* +3 so that we can fit 'L' and ';' around the class name with the null-terminator */\n+\t\t\tUDATA utfLength = vm->internalVMFunctions->getStringUTF8Length(currentThread, sigString) + 3;\n+\t\t\tsig = (char *)j9mem_allocate_memory(utfLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tif (J9ROMCLASS_IS_ARRAY(clazz->romClass)) {\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_NULL_TERMINATE_RESULT | J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)sig, utfLength);\n+\t\t\t\t} else {\n+\t\t\t\t\tsig[0] = 'L';\n+\t\t\t\t\tvm->internalVMFunctions->copyStringToUTF8Helper(currentThread, sigString, J9_STR_XLAT, 0, J9VMJAVALANGSTRING_LENGTH(currentThread, sigString), (U_8*)(sig + 1), utfLength - 1);\n+\t\t\t\t\tsig[utfLength - 2] = ';';\n+\t\t\t\t\tsig[utfLength - 1] = '\\0';\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tU_32 numDims = 0;\n+\n+\t\t\tJ9Class *myClass = clazz;\n+\t\t\twhile (J9ROMCLASS_IS_ARRAY(myClass->romClass)) {\n+\t\t\t\tJ9Class * componentClass = (J9Class *)(((J9ArrayClass*)myClass)->componentType);\n+\t\t\t\tif (J9ROMCLASS_IS_PRIMITIVE_TYPE(componentClass->romClass)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tnumDims += 1;\n+\t\t\t\tmyClass = componentClass;\n+\t\t\t}\n+\n+\t\t\tJ9UTF8 *romName = J9ROMCLASS_CLASSNAME(myClass->romClass);\n+\t\t\tU_32 nameLength = J9UTF8_LENGTH(romName);\n+\t\t\tchar * name = (char *)J9UTF8_DATA(romName);\n+\t\t\tU_32 sigLength = nameLength + numDims;\n+\t\t\tif (* name != '[') {\n+\t\t\t\tsigLength += 2;\n+\t\t\t}\n+\n+\t\t\tsigLength++; /* for null-termination */\n+\t\t\tsig = (char *)j9mem_allocate_memory(sigLength, OMRMEM_CATEGORY_VM);\n+\t\t\tif (NULL != sig) {\n+\t\t\t\tU_32 i = 0;\n+\t\t\t\tfor (i = 0; i < numDims; i++) {\n+\t\t\t\t\tsig[i] = '[';\n+\t\t\t\t}\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = 'L';\n+\t\t\t\t}\n+\n+\t\t\t\tmemcpy(sig+i, name, nameLength);\n+\t\t\t\ti += nameLength;\n+\n+\t\t\t\tif (*name != '[') {\n+\t\t\t\t\tsig[i++] = ';';\n+\t\t\t\t}\n+\t\t\t\tsig[sigLength-1] = '\\0';\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn sig;\n+}\n+\n+static char *\n+getSignatureFromMethodType(J9VMThread *currentThread, j9object_t typeObject, UDATA *signatureLength)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tj9object_t ptypes = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(currentThread, typeObject);\n+\tU_32 numArgs = J9INDEXABLEOBJECT_SIZE(currentThread, ptypes);\n+\n+\tchar* methodDescriptor = NULL;\n+\tchar* cursor = NULL;\n+\tchar* rSignature = NULL;\n+\n+\tPORT_ACCESS_FROM_JAVAVM(vm);\n+\n+\tchar** signatures = (char**)j9mem_allocate_memory((numArgs) * sizeof(char*), OMRMEM_CATEGORY_VM);\n+\tif (NULL == signatures) {\n+\t\tgoto done;\n+\t}\n+\n+\tmemset(signatures, 0, (numArgs) * sizeof(char*));\n+\n+\t*signatureLength = 2; /* space for '(', ')' */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tj9object_t pObject = J9JAVAARRAYOFOBJECT_LOAD(currentThread, ptypes, i);\n+\t\tJ9Class *pclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, pObject);\n+\t\tsignatures[i] = getClassSignature(currentThread, pclass);\n+\t\tif (NULL == signatures[i]) {\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t\t*signatureLength += strlen(signatures[i]);\n+\t}\n+\n+\t{\n+\t\t/* Return type */\n+\t\tj9object_t rtype = J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(currentThread, typeObject);\n+\t\tJ9Class *rclass = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, rtype);\n+\t\trSignature = getClassSignature(currentThread, rclass);\n+\t\tif (NULL == rSignature) {\n+\t\t\tgoto done;\n+\t\t}\n+\t}\n+\n+\t*signatureLength += strlen(rSignature);\n+\n+\tmethodDescriptor = (char*)j9mem_allocate_memory(*signatureLength+1, OMRMEM_CATEGORY_VM);\n+\tif (NULL == methodDescriptor) {\n+\t\tgoto done;\n+\t}\n+\tcursor = methodDescriptor;\n+\t*cursor++ = '(';\n+\n+\t/* Copy class signatures to descriptor string */\n+\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\tU_32 len = strlen(signatures[i]);\n+\t\tstrncpy(cursor, signatures[i], len);\n+\t\tcursor += len;\n+\t}\n+\n+\t*cursor++ = ')';\n+\t/* Copy return type signature to descriptor string */\n+\tstrcpy(cursor, rSignature);\n+\n+done:\n+\tj9mem_free_memory(rSignature);\n+\n+\tif (NULL != signatures) {\n+\t\tfor (U_32 i = 0; i < numArgs; i++) {\n+\t\t\tj9mem_free_memory(signatures[i]);\n+\t\t}\n+\t\tj9mem_free_memory(signatures);\n+\t}\n+\treturn methodDescriptor;\n+}\n+\n+j9object_t\n+resolveRefToObject(J9VMThread *currentThread, J9ConstantPool *ramConstantPool, U_16 cpIndex, bool resolve)\n+{\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tconst J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;\n+\n+\tj9object_t result = NULL;\n+\n+\tJ9RAMSingleSlotConstantRef *ramCP = (J9RAMSingleSlotConstantRef*)ramConstantPool + cpIndex;\n+\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramConstantPool)->romClass);\n+\n+\tswitch (J9_CP_TYPE(cpShapeDescription, cpIndex)) {\n+\tcase J9CPTYPE_CLASS: {\n+\t\tJ9Class *clazz = (J9Class*)ramCP->value;\n+\t\tif ((NULL == clazz) && resolve) {\n+\t\t\tclazz = vmFuncs->resolveClassRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tif (NULL != clazz) {\n+\t\t\tresult = J9VM_J9CLASS_TO_HEAPCLASS(clazz);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_STRING: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveStringRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_INT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGINTEGER_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGINTEGER_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_FLOAT: {\n+\t\tJ9ROMSingleSlotConstantRef *romCP = (J9ROMSingleSlotConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGFLOAT_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGFLOAT_SET_VALUE(currentThread, result, romCP->data);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_LONG: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGLONG_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGLONG_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_DOUBLE: {\n+\t\tJ9ROMConstantRef *romCP = (J9ROMConstantRef*)J9_ROM_CP_FROM_CP(ramConstantPool) + cpIndex;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+\t\tU_64 value = (((U_64)(romCP->slot2)) << 32) | ((U_64)(romCP->slot1));\n+#else\n+\t\tU_64 value = (((U_64)(romCP->slot1)) << 32) | ((U_64)(romCP->slot2));\n+#endif\n+\t\tresult = vm->memoryManagerFunctions->J9AllocateObject(currentThread, J9VMJAVALANGDOUBLE_OR_NULL(vm), J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE);\n+\t\tif (NULL == result) {\n+\t\t\tvmFuncs->setHeapOutOfMemoryError(currentThread);\n+\t\t\tgoto done;\n+\t\t}\n+\t\tJ9VMJAVALANGDOUBLE_SET_VALUE(currentThread, result, value);\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHOD_TYPE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodTypeRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_METHODHANDLE: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveMethodHandleRef(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_CLASS_INIT);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase J9CPTYPE_CONSTANT_DYNAMIC: {\n+\t\tresult = (j9object_t)ramCP->value;\n+\t\tif ((NULL == result) && resolve) {\n+\t\t\tresult = vmFuncs->resolveConstantDynamic(currentThread, ramConstantPool, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\t} /* switch */\n+done:\n+\treturn result;\n+}\n+\n+J9Method *\n+lookupMethod(J9VMThread *currentThread, J9Class *resolvedClass, J9JNINameAndSignature *nas, J9Class *callerClass, UDATA lookupOptions)\n+{\n+\tJ9Method *result = NULL;\n+\n+\t/* If looking for a MethodHandle polymorphic INL method, allow any caller signature. */\n+\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(currentThread->javaVM)) {\n+\t\tif ((0 == strcmp(nas->name, \"linkToVirtual\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToStatic\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToSpecial\"))\n+\t\t|| (0 == strcmp(nas->name, \"linkToInterface\"))\n+\t\t|| (0 == strcmp(nas->name, \"invokeBasic\"))\n+\t\t) {\n+\t\t\tnas->signature = NULL;\n+\t\t\tnas->signatureLength = 0;\n+\n+\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n+\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n+\t\t}\n+\t}\n+\n+\tresult = (J9Method*)currentThread->javaVM->internalVMFunctions->javaLookupMethod(currentThread, resolvedClass, (J9ROMNameAndSignature*)nas, callerClass, lookupOptions);\n+\n+\treturn result;\n+}\n+\n+static void\n+setCallSiteTargetImpl(J9VMThread *currentThread, jobject callsite, jobject target, bool isVolatile)\n+{\n+\tconst J9InternalVMFunctions *vmFuncs = currentThread->javaVM->internalVMFunctions;\n+\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\n+\tif ((NULL == callsite) || (NULL == target)) {\n+\t\tvmFuncs->setCurrentExceptionUTF(currentThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n+\t} else {\n+\t\tj9object_t callsiteObject = J9_JNI_UNWRAP_REFERENCE(callsite);\n+\t\tj9object_t targetObject = J9_JNI_UNWRAP_REFERENCE(target);\n+\n+\t\tUDATA offset = (UDATA)vmFuncs->instanceFieldOffset(currentThread, J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, callsiteObject), (U_8*)\"target\", strlen(\"target\"), (U_8*)\"Ljava/lang/invoke/MethodHandle;\", strlen(\"Ljava/lang/invoke/MethodHandle;\"), NULL, NULL, 0);\n+\t\tMM_ObjectAccessBarrierAPI objectAccessBarrier = MM_ObjectAccessBarrierAPI(currentThread);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f43221a76d0a2862747965e55a8d6d822450b9f"}, "originalPosition": 482}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1232, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}