{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxOTEzMDY0", "number": 10678, "title": "Use a separate mutex for small freed block lists of persistent allocator", "bodyText": "Small freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\nmemoryAllocMonitor. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called _smallBlockListsMonitor.\nSome refactoring of the code has also been performed.\nAlso, the number of small-freed-block lists has been increased\nfrom 11 to 15.\nSigned-off-by: Marius Pirvu mpirvu@ca.ibm.com", "createdAt": "2020-09-23T16:52:49Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10678", "merged": true, "mergeCommit": {"oid": "ecd284b6c878cd4b4cc2ab16275ba6b48c057212"}, "closed": true, "closedAt": "2020-09-25T12:30:59Z", "author": {"login": "mpirvu"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLhjG6gH2gAyNDkxOTEzMDY0OjJmMmY0ZTY3YzZmYmEyNTlkNDE2ODZjNmE1MmY5YjQ0OTIyMDVjMjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMFp9cgFqTQ5NTg1MzkxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2f2f4e67c6fba259d41686c6a52f9b4492205c27", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2f2f4e67c6fba259d41686c6a52f9b4492205c27", "committedDate": "2020-09-23T00:35:37Z", "message": "Increase number of buckets for fixed size blocks from 12 to 16\n\nAllocations from fixed size block lists are very fast because\nwe only need to access the head of a linked list. Increasing\nthe number of such lists may speed up the persistent allocator\na little.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "69882d1e7774f573a8cbcd3dec1ef5a8aecba358", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/69882d1e7774f573a8cbcd3dec1ef5a8aecba358", "committedDate": "2020-09-23T16:30:54Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only containes blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhed to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}, "afterCommit": {"oid": "939f3f838a5e4960a63459e54a69b14241c0c498", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/939f3f838a5e4960a63459e54a69b14241c0c498", "committedDate": "2020-09-23T16:54:35Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only containes blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "939f3f838a5e4960a63459e54a69b14241c0c498", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/939f3f838a5e4960a63459e54a69b14241c0c498", "committedDate": "2020-09-23T16:54:35Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only containes blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}, "afterCommit": {"oid": "9d44752c1c70789c2e430f34dd8fe411a925dbda", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9d44752c1c70789c2e430f34dd8fe411a925dbda", "committedDate": "2020-09-23T17:41:42Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only containes blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9d44752c1c70789c2e430f34dd8fe411a925dbda", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9d44752c1c70789c2e430f34dd8fe411a925dbda", "committedDate": "2020-09-23T17:41:42Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only containes blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}, "afterCommit": {"oid": "c7253e3a972daecedeb280787f8d1b8687e72937", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c7253e3a972daecedeb280787f8d1b8687e72937", "committedDate": "2020-09-23T19:00:31Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only containes blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c7253e3a972daecedeb280787f8d1b8687e72937", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c7253e3a972daecedeb280787f8d1b8687e72937", "committedDate": "2020-09-23T19:00:31Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only containes blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}, "afterCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/76e2109024567dcc6d7757bcc604ab0dc73d9649", "committedDate": "2020-09-23T19:03:12Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0OTg4NzMw", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#pullrequestreview-494988730", "createdAt": "2020-09-23T19:38:27Z", "commit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxOTozODoyN1rOHW-HZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDowNzo0NFrOHW_FVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0ODQyMA==", "bodyText": "Is the 0th index special? If so then maybe it's worth having an enum or maybe a static const size_t rather than using the literal 0.", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493848420", "createdAt": "2020-09-23T19:38:27Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0ODU5Nw==", "bodyText": "Better to use OMR::Critical Section(_smallBlockListsMonitor);", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493848597", "createdAt": "2020-09-23T19:38:47Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0OTE2MQ==", "bodyText": "Same comment as above regarding the literal 0.", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493849161", "createdAt": "2020-09-23T19:39:53Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg0OTQwNQ==", "bodyText": "Same comment as above regarding OMR::CriticalSection.", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493849405", "createdAt": "2020-09-23T19:40:17Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MTcyNw==", "bodyText": "I don't think this is a good idea; it's better to just wrap the call to allocateFromSegmentLocked in a scope and use OMR::CriticalSection(::memoryAllocMonitor)", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493851727", "createdAt": "2020-09-23T19:44:29Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MjQwNg==", "bodyText": "Better to use OMR::CriticalSection. Is it ever possible that ::memoryAllocMonitor is NULL? Wouldn't that cause all sorts of issues?", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493852406", "createdAt": "2020-09-23T19:45:51Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      }\n+   else // Variable size block allocation\n+      {\n+      if (::memoryAllocMonitor)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NjI1MA==", "bodyText": "Might be worth just 1. using OMR::CriticalSection, and 2. moving the critical section to inside freeFixedSizeBlock.\nAn unfortunate side effect of using a critical section for ::memoryAllocMonitor though is that we'll end up acquiring both monitors here. Maybe this is an infrequent enough scenario that it shouldn't be a problem?", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493856250", "createdAt": "2020-09-23T19:52:52Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      }\n+   else // Variable size block allocation\n+      {\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      Block * block = allocateFromVariableSizeListLocked(allocSize);\n+      if (block)\n          {\n-         block->_size = allocSize;\n-         freeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+         // If the block I found is bigger than what I need,\n+         // split it and put the remaining block back onto the free list\n+         size_t const excess = block->_size - allocSize;\n+         if (excess > sizeof(Block))\n+            {\n+            block->_size = allocSize;\n+            const size_t excessIndex = freeBlocksIndex(excess);\n+            if (excessIndex > 0)\n+               {\n+               // Exit the variable size list monitor and grab a fixed size list monitor\n+               if (::memoryAllocMonitor)\n+                  ::memoryAllocMonitor->exit();\n+\n+               j9thread_monitor_enter(_smallBlockListsMonitor);\n+               freeFixedSizeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+               j9thread_monitor_exit(_smallBlockListsMonitor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NzQxOQ==", "bodyText": "Same comment as above regarding literal 0.", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493857419", "createdAt": "2020-09-23T19:55:02Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      }\n+   else // Variable size block allocation\n+      {\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      Block * block = allocateFromVariableSizeListLocked(allocSize);\n+      if (block)\n          {\n-         block->_size = allocSize;\n-         freeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+         // If the block I found is bigger than what I need,\n+         // split it and put the remaining block back onto the free list\n+         size_t const excess = block->_size - allocSize;\n+         if (excess > sizeof(Block))\n+            {\n+            block->_size = allocSize;\n+            const size_t excessIndex = freeBlocksIndex(excess);\n+            if (excessIndex > 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1Nzc0NA==", "bodyText": "As stated above, better to use a critical section here in a nested scope.", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493857744", "createdAt": "2020-09-23T19:55:38Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      }\n+   else // Variable size block allocation\n+      {\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      Block * block = allocateFromVariableSizeListLocked(allocSize);\n+      if (block)\n          {\n-         block->_size = allocSize;\n-         freeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+         // If the block I found is bigger than what I need,\n+         // split it and put the remaining block back onto the free list\n+         size_t const excess = block->_size - allocSize;\n+         if (excess > sizeof(Block))\n+            {\n+            block->_size = allocSize;\n+            const size_t excessIndex = freeBlocksIndex(excess);\n+            if (excessIndex > 0)\n+               {\n+               // Exit the variable size list monitor and grab a fixed size list monitor\n+               if (::memoryAllocMonitor)\n+                  ::memoryAllocMonitor->exit();\n+\n+               j9thread_monitor_enter(_smallBlockListsMonitor);\n+               freeFixedSizeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+               j9thread_monitor_exit(_smallBlockListsMonitor);\n+               // No monitor held at this point, so we can return\n+               return block + 1;\n+               }\n+            else\n+               {\n+               freeVariableSizeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+               }\n+            }\n+         if (::memoryAllocMonitor)\n+            ::memoryAllocMonitor->exit();\n+         return block + 1;\n          }\n-\n-      return block + 1;\n       }\n-\n+   // At this point I have to allocate memory from a segment\n    // Find the first persistent segment with enough free space\n+   // Required mutex has already been obtained\n    //\n+   void *allocation = allocateFromSegmentLocked(allocSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1ODExMQ==", "bodyText": "Might even be worth considering creating the critical section inside allocateFromSegmentLocked now that I think of it.", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493858111", "createdAt": "2020-09-23T19:56:19Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      }\n+   else // Variable size block allocation\n+      {\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      Block * block = allocateFromVariableSizeListLocked(allocSize);\n+      if (block)\n          {\n-         block->_size = allocSize;\n-         freeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+         // If the block I found is bigger than what I need,\n+         // split it and put the remaining block back onto the free list\n+         size_t const excess = block->_size - allocSize;\n+         if (excess > sizeof(Block))\n+            {\n+            block->_size = allocSize;\n+            const size_t excessIndex = freeBlocksIndex(excess);\n+            if (excessIndex > 0)\n+               {\n+               // Exit the variable size list monitor and grab a fixed size list monitor\n+               if (::memoryAllocMonitor)\n+                  ::memoryAllocMonitor->exit();\n+\n+               j9thread_monitor_enter(_smallBlockListsMonitor);\n+               freeFixedSizeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+               j9thread_monitor_exit(_smallBlockListsMonitor);\n+               // No monitor held at this point, so we can return\n+               return block + 1;\n+               }\n+            else\n+               {\n+               freeVariableSizeBlock( new (pointer_cast<uint8_t *>(block) + allocSize) Block(excess) );\n+               }\n+            }\n+         if (::memoryAllocMonitor)\n+            ::memoryAllocMonitor->exit();\n+         return block + 1;\n          }\n-\n-      return block + 1;\n       }\n-\n+   // At this point I have to allocate memory from a segment\n    // Find the first persistent segment with enough free space\n+   // Required mutex has already been obtained\n    //\n+   void *allocation = allocateFromSegmentLocked(allocSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1Nzc0NA=="}, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1OTY2MQ==", "bodyText": "Same comment as above regarding literal 0", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493859661", "createdAt": "2020-09-23T19:59:12Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -164,26 +216,34 @@ PersistentAllocator::remainingSpace(J9MemorySegment &segment) throw()\n    }\n \n void\n-PersistentAllocator::freeBlock(Block * block)\n+PersistentAllocator::freeFixedSizeBlock(Block * block)\n+   {\n+   // Appropriate lock should have been obtained\n+   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(index, \"freeFixedSizeBlock should be used for small blocks, so index cannot be 0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2MDI0MA==", "bodyText": "same comment as above regarding literal 0.", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493860240", "createdAt": "2020-09-23T20:00:12Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -164,26 +216,34 @@ PersistentAllocator::remainingSpace(J9MemorySegment &segment) throw()\n    }\n \n void\n-PersistentAllocator::freeBlock(Block * block)\n+PersistentAllocator::freeFixedSizeBlock(Block * block)\n+   {\n+   // Appropriate lock should have been obtained\n+   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n+   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(index, \"freeFixedSizeBlock should be used for small blocks, so index cannot be 0\");\n+   block->_next = _freeBlocks[index];\n+   _freeBlocks[index] = block;\n+   }\n+\n+void\n+PersistentAllocator::freeVariableSizeBlock(Block * block)\n    {\n+   // Appropriate lock should have been obtained\n    TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   TR_ASSERT(block->_next == NULL, \"In-use persistent memory block @ belongs to a free block chain.\", block);\n    block->_next = NULL;\n \n-   // If this is a small block, add it to the appropriate fixed-size-block\n-   // chain. Otherwise add it to the variable-size-block chain which is in\n-   // ascending size order.\n+   // Add block to the variable-size-block chain which is in ascending size order.\n    //\n-   size_t const index = freeBlocksIndex(block->_size);\n-   Block * blockIterator = _freeBlocks[index];\n+   TR_ASSERT(freeBlocksIndex(block->_size) == 0, \"freeVariableSizeBlock should be used for large blocks, so index should be 0\");\n+   Block * blockIterator = _freeBlocks[0];\n    if (!blockIterator || !(blockIterator->_size < block->_size) )\n       {\n-      block->_next = _freeBlocks[index];\n-      _freeBlocks[index] = block;\n+      block->_next = _freeBlocks[0];\n+      _freeBlocks[0] = block;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2MjUxMw==", "bodyText": "Shouldn't the message say something like \"Freeing a block that is in the free list\"?", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493862513", "createdAt": "2020-09-23T20:04:29Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -194,25 +254,49 @@ PersistentAllocator::freeBlock(Block * block)\n    }\n \n void\n-PersistentAllocator::deallocate(void * mem, size_t) throw()\n+PersistentAllocator::freeBlock(Block * block)\n    {\n-   if (::memoryAllocMonitor)\n-      ::memoryAllocMonitor->enter();\n-\n-\n-   Block * block = static_cast<Block *>(mem) - 1;\n+   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n \n-   // adjust the used persistent memory here and not in freePersistentmemory(block, size)\n+   // Adjust the used persistent memory here and not in freePersistentmemory(block, size)\n    // because that call is also used to free memory that wasn't actually committed\n-   TR::AllocatedMemoryMeter::update_freed(block->_size, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_freed(block->_size, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n+  \n+   // If this is a small block, add it to the appropriate fixed-size-block\n+   // chain. Otherwise add it to the variable-size-block chain which is in\n+   // ascending size order.\n+   //\n+   size_t const index = freeBlocksIndex(block->_size);\n+   if (index > 0)\n+      {\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      freeFixedSizeBlock(block);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n+   else\n+      {\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      freeVariableSizeBlock(block);\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->exit();\n+      }\n+   }\n \n+void\n+PersistentAllocator::deallocate(void * mem, size_t) throw()\n+   {\n+   Block * block = static_cast<Block *>(mem) - 1;\n+   TR_ASSERT_FATAL(block->_next == NULL, \"Freeing a block that is in use. block=%p next=%p\", block, block->_next);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2NDI3OQ==", "bodyText": "Same comments as above regarding critical section and the literal 0.", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r493864279", "createdAt": "2020-09-23T20:07:44Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -194,25 +254,49 @@ PersistentAllocator::freeBlock(Block * block)\n    }\n \n void\n-PersistentAllocator::deallocate(void * mem, size_t) throw()\n+PersistentAllocator::freeBlock(Block * block)\n    {\n-   if (::memoryAllocMonitor)\n-      ::memoryAllocMonitor->enter();\n-\n-\n-   Block * block = static_cast<Block *>(mem) - 1;\n+   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n \n-   // adjust the used persistent memory here and not in freePersistentmemory(block, size)\n+   // Adjust the used persistent memory here and not in freePersistentmemory(block, size)\n    // because that call is also used to free memory that wasn't actually committed\n-   TR::AllocatedMemoryMeter::update_freed(block->_size, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_freed(block->_size, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n+  \n+   // If this is a small block, add it to the appropriate fixed-size-block\n+   // chain. Otherwise add it to the variable-size-block chain which is in\n+   // ascending size order.\n+   //\n+   size_t const index = freeBlocksIndex(block->_size);\n+   if (index > 0)\n+      {\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      freeFixedSizeBlock(block);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n+   else\n+      {\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();\n+      freeVariableSizeBlock(block);\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->exit();\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 302}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/76e2109024567dcc6d7757bcc604ab0dc73d9649", "committedDate": "2020-09-23T19:03:12Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}, "afterCommit": {"oid": "9fe189119d74d146713adff18fb774ec4da5a2e4", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9fe189119d74d146713adff18fb774ec4da5a2e4", "committedDate": "2020-09-23T20:44:33Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NjcwODYx", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#pullrequestreview-495670861", "createdAt": "2020-09-24T15:04:13Z", "commit": {"oid": "9fe189119d74d146713adff18fb774ec4da5a2e4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNTowNDoxM1rOHXfYcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNTowNDoxM1rOHXfYcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5MzQ1OQ==", "bodyText": "Given that this is at the end of the if block, why does the monitor need to be acquired here? Wouldn't it be better to just move it right before the call to allocateFromSegmentLocked below? The else block looks self contained, so the only way to end up in the call to allocateFromSegmentLocked is if the code enter the if block here.", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r494393459", "createdAt": "2020-09-24T15:04:13Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -68,78 +65,133 @@ PersistentAllocator::allocate(size_t size, void *hint)\n    return alloc;\n    }\n \n+PersistentAllocator::Block *\n+PersistentAllocator::allocateFromVariableSizeListLocked(size_t allocSize)\n+   {\n+   Block * block = NULL;\n+   Block * prev = NULL;\n+   for (block = _freeBlocks[0]; block && block->_size < allocSize; prev = block, block = prev->next())\n+      {}\n+\n+   if (block)\n+      {\n+      if (prev)\n+         prev->_next = block->next();\n+      else\n+         _freeBlocks[0] = block->next();\n+\n+      block->_next = NULL;\n+      }\n+   return block;\n+   }\n+\n void *\n-PersistentAllocator::allocateLocked(size_t requestedSize)\n+PersistentAllocator::allocateInternal(size_t requestedSize)\n    {\n    TR_ASSERT( sizeof(Block) == mem_round( sizeof(Block) ),\"Persistent block size will prevent us from properly aligning allocations.\");\n    size_t const dataSize = mem_round(requestedSize);\n    size_t const allocSize = sizeof(Block) + dataSize;\n \n-   TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+   if (TR::AllocatedMemoryMeter::_enabled & persistentAlloc)\n+      {\n+      // Use _smallBlockListsMonitor to protect TR::AllocatedMemoryMeter::update_allocated\n+      // because accessing the variable-size-block list protected by ::memoryAllocMonitor\n+      // takes longer and we may be penalizing access to fixed size block which should be very fast\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      TR::AllocatedMemoryMeter::update_allocated(allocSize, persistentAlloc);\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      }\n \n    // If this is a small block try to allocate it from the appropriate\n    // fixed-size-block chain.\n    //\n    size_t const index = freeBlocksIndex(allocSize);\n-   Block * block = 0;\n-   Block * prev = 0;\n-   for (\n-      block = _freeBlocks[index];\n-      block && block->_size < allocSize;\n-      prev = block, block = prev->next()\n-      )\n-      { TR_ASSERT(index == 0, \"Iterating through a fixed-size block bin.\"); }\n-\n-   if (block)\n+   if (index != 0) // fixed-size-block chain\n       {\n-\n-      TR_ASSERT(\n-         ( index == 0 ) || ( block->_size == allocSize ),\n-         \"block %p in chain for index %d has size %d (not %d)\\n\",\n-         block,\n-         index,\n-         block->_size,\n-         (index * sizeof(void *)) + sizeof(Block)\n-         );\n-\n-      if (prev)\n-         prev->_next = block->next();\n-      else\n+      j9thread_monitor_enter(_smallBlockListsMonitor);\n+      Block * block = _freeBlocks[index];\n+      if (block)\n+         {\n          _freeBlocks[index] = block->next();\n-\n-      block->_next = NULL;\n-\n-      size_t const excess = block->_size - allocSize;\n-\n-      if (excess > sizeof(Block))\n+         block->_next = NULL;\n+         j9thread_monitor_exit(_smallBlockListsMonitor);\n+         return block + 1; // Return pointer after the header\n+         }\n+      j9thread_monitor_exit(_smallBlockListsMonitor);\n+      // Need to allocate from segment\n+      // Preemtively acquire the mutex that protects the segment allocation\n+      if (::memoryAllocMonitor)\n+         ::memoryAllocMonitor->enter();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MTcyNw=="}, "originalCommit": {"oid": "76e2109024567dcc6d7757bcc604ab0dc73d9649"}, "originalPosition": 132}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9fe189119d74d146713adff18fb774ec4da5a2e4", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9fe189119d74d146713adff18fb774ec4da5a2e4", "committedDate": "2020-09-23T20:44:33Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}, "afterCommit": {"oid": "fc67d852c87273d0cc9b26c6745dc86e0f7b5596", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/fc67d852c87273d0cc9b26c6745dc86e0f7b5596", "committedDate": "2020-09-24T17:57:04Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1ODI2NjM2", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#pullrequestreview-495826636", "createdAt": "2020-09-24T18:08:41Z", "commit": {"oid": "fc67d852c87273d0cc9b26c6745dc86e0f7b5596"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODowODo0MVrOHXmruw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODowODo0MVrOHXmruw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxMzA4Mw==", "bodyText": "This line was added as part of your last update; doesn't seem to be used.", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#discussion_r494513083", "createdAt": "2020-09-24T18:08:41Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/PersistentAllocator.cpp", "diffHunk": "@@ -164,26 +225,34 @@ PersistentAllocator::remainingSpace(J9MemorySegment &segment) throw()\n    }\n \n void\n-PersistentAllocator::freeBlock(Block * block)\n+PersistentAllocator::freeFixedSizeBlock(Block * block)\n    {\n+   // Appropriate lock should have been obtained\n    TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n-   TR_ASSERT(block->_next == NULL, \"In-use persistent memory block @ belongs to a free block chain.\", block);\n-   block->_next = NULL;\n+   size_t const index = freeBlocksIndex(block->_size);\n+   TR_ASSERT(index != LARGE_BLOCK_LIST_INDEX, \"freeFixedSizeBlock should be used for small blocks, so index cannot be LARGE_BLOCK_LIST_INDEX\");\n+   block->_next = _freeBlocks[index];\n+   _freeBlocks[index] = block;\n+   }\n \n-   // If this is a small block, add it to the appropriate fixed-size-block\n-   // chain. Otherwise add it to the variable-size-block chain which is in\n-   // ascending size order.\n+void\n+PersistentAllocator::freeVariableSizeBlock(Block * block)\n+   {\n+   // Appropriate lock should have been obtained\n+   TR_ASSERT(block->_size > 0, \"Block size is non-positive\");\n+   block->_next = NULL;\n+   Block * volatile next = block->_next;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc67d852c87273d0cc9b26c6745dc86e0f7b5596"}, "originalPosition": 250}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f4057ef37b649b81570ecee08ee5e04af9b93ce", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0f4057ef37b649b81570ecee08ee5e04af9b93ce", "committedDate": "2020-09-24T18:28:41Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc67d852c87273d0cc9b26c6745dc86e0f7b5596", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/fc67d852c87273d0cc9b26c6745dc86e0f7b5596", "committedDate": "2020-09-24T17:57:04Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}, "afterCommit": {"oid": "0f4057ef37b649b81570ecee08ee5e04af9b93ce", "author": {"user": {"login": "mpirvu", "name": "Marius Pirvu"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0f4057ef37b649b81570ecee08ee5e04af9b93ce", "committedDate": "2020-09-24T18:28:41Z", "message": "Use a separate mutex for small freed block lists of persistent allocator\n\nSmall freed memory blocks using persistent memory are kept in some\nlinked lists, where each list only contains blocks of same size.\nThis allows the JIT to rapidly allocate/deallocate a small block\nof memory by detaching the head (or adding to the head) of an\nappropriate such list.\nLarger freed blocks are kept in a separate list where blocks are\nordered by size. The overhead to access this list can sometimes be\nquite large, depending on the number of entries in this list (we\nneed to traverse the list to find the right location for adding\nto or deleting from it).\nCurrently, all these lists are protected by the same monitor:\n`memoryAllocMonitor`. In order to avoid a fast allocation or\ndeallocation of a small block to be delayed by a concurrent access\nto the large-block list (which can take time), this commit\nintroduces a dedicated mutex for the set of small-freed-block\nlists, called `_smallBlockListsMonitor`.\nSome refactoring of the code has also been performed.\n\nSigned-off-by: Marius Pirvu <mpirvu@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1ODUzOTE4", "url": "https://github.com/eclipse-openj9/openj9/pull/10678#pullrequestreview-495853918", "createdAt": "2020-09-24T18:39:41Z", "commit": {"oid": "0f4057ef37b649b81570ecee08ee5e04af9b93ce"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 277, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}