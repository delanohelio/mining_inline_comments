{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1MDQ3MDcy", "number": 10912, "title": "JEP358 NPE extended message part 2 - the cause of NPE", "bodyText": "Added J9NPEMessageData to pass vmThread/romClass/romMethod/bytecodeOffset;\nEnabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\nsimulateStack() is similar with verifier version and utility methods but not sharing the actual code to avoid interference to those already complicated code;\nNPE message generation is computed based on the method PC (npePC) and the method bytecode;\nThe bytecode stack simulation algorithm is similar with the verifier, but the bytecode offset is pushed onto the stack instead of verifier elements;\nWhen those stack elements are popped, the offset of previous bytecode executed are recorded at BytecodeOffset *bytecodeOffset via setSrcBytecodeOffset();\nAdded trace points;\nAdded tests.\n\nRelated #8450\nSigned-off-by: Jason Feng fengj@ca.ibm.com", "createdAt": "2020-10-16T19:13:18Z", "url": "https://github.com/eclipse-openj9/openj9/pull/10912", "merged": true, "mergeCommit": {"oid": "9470d96c35aeaf1b91665720b7d08a76a329e687"}, "closed": true, "closedAt": "2020-11-05T19:40:32Z", "author": {"login": "JasonFengJ9"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdTLtXNAFqTUxMDc1MjMwNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZoUe3gFqTUyNDYzNzgwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzUyMzA3", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#pullrequestreview-510752307", "createdAt": "2020-10-16T19:40:18Z", "commit": {"oid": "98a602fb460236b3e9b5acc7ecdc891ee3750538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOTo0MDoxOFrOHjNnbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOTo0MDoxOFrOHjNnbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4NTI5NA==", "bodyText": "Why malloc this instead of just using the struct as the local (i.e. no pointer)?", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#discussion_r506685294", "createdAt": "2020-10-16T19:40:18Z", "author": {"login": "gacholio"}, "path": "runtime/j9vm/javanextvmi.c", "diffHunk": "@@ -115,9 +115,10 @@ JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwableObj)\n \t\t\t&& (NULL != userData.romMethod)\n \t\t\t&& (UDATA_MAX != userData.bytecodeOffset)\n \t\t) {\n+\t\t\tPORT_ACCESS_FROM_VMC(vmThread);\n+\t\t\tJ9NPEMessageData *npeMsgData = (J9NPEMessageData *)j9mem_allocate_memory(sizeof(J9NPEMessageData), OMRMEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a602fb460236b3e9b5acc7ecdc891ee3750538"}, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "98a602fb460236b3e9b5acc7ecdc891ee3750538", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/98a602fb460236b3e9b5acc7ecdc891ee3750538", "committedDate": "2020-10-16T19:07:57Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifer,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}, "afterCommit": {"oid": "73c0da211cccbb8e1f29a06c87657041db0320ee", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/73c0da211cccbb8e1f29a06c87657041db0320ee", "committedDate": "2020-10-16T20:05:32Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "73c0da211cccbb8e1f29a06c87657041db0320ee", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/73c0da211cccbb8e1f29a06c87657041db0320ee", "committedDate": "2020-10-16T20:05:32Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}, "afterCommit": {"oid": "00a91ee7dae620cdc853caaeae61987bd5160b9f", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/00a91ee7dae620cdc853caaeae61987bd5160b9f", "committedDate": "2020-10-17T01:22:52Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExOTM5MDMx", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#pullrequestreview-511939031", "createdAt": "2020-10-19T16:21:06Z", "commit": {"oid": "00a91ee7dae620cdc853caaeae61987bd5160b9f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNjoyMTowNlrOHkWzQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNjoyMTowNlrOHkWzQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4NDM1NQ==", "bodyText": "Is this legal (obsoleting and reusing the same tracepoint later)?", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#discussion_r507884355", "createdAt": "2020-10-19T16:21:06Z", "author": {"login": "gacholio"}, "path": "runtime/vm/j9vm.tdf", "diffHunk": "@@ -786,7 +786,7 @@ TraceEvent=Trc_VM_classInitStateMachine_verifyFlattenableField Group=classinit O\n TraceEvent=Trc_VM_classInitStateMachine_prepareFlattenableField Group=classinit Overhead=1 Level=3 Template=\"prepare flattenable field clazz=%p\"\n TraceEvent=Trc_VM_classInitStateMachine_initFlattenableField Group=classinit Overhead=1 Level=3 Template=\"initialize flattenable field clazz=%p\"\n \n-TraceEntry=Trc_VM_GetCompleteNPEMessage_Entry Overhead=1 Level=3 Template=\"GetCompleteNPEMessage - bcCurrentPtr (0x%p) bcCurrent (0x%x) romClass (0x%p) npeCauseMsg (%s)\"\n+TraceEntry=Trc_VM_GetCompleteNPEMessage_Entry Obsolete Overhead=1 Level=3 Template=\"GetCompleteNPEMessage - bcCurrentPtr (0x%p) bcCurrent (0x%x) romClass (0x%p) npeCauseMsg (%s)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00a91ee7dae620cdc853caaeae61987bd5160b9f"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00a91ee7dae620cdc853caaeae61987bd5160b9f", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/00a91ee7dae620cdc853caaeae61987bd5160b9f", "committedDate": "2020-10-17T01:22:52Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}, "afterCommit": {"oid": "2b5aba125cc9da2d8ca33a414d16ee7fba0ce55b", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2b5aba125cc9da2d8ca33a414d16ee7fba0ce55b", "committedDate": "2020-10-19T17:49:03Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDMzODIx", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#pullrequestreview-512033821", "createdAt": "2020-10-19T18:12:28Z", "commit": {"oid": "2b5aba125cc9da2d8ca33a414d16ee7fba0ce55b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2b5aba125cc9da2d8ca33a414d16ee7fba0ce55b", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2b5aba125cc9da2d8ca33a414d16ee7fba0ce55b", "committedDate": "2020-10-19T17:49:03Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}, "afterCommit": {"oid": "d185aeaf8af6ba2f2d350c6448715e7a08f23daf", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/d185aeaf8af6ba2f2d350c6448715e7a08f23daf", "committedDate": "2020-10-19T18:41:24Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDE3NTky", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#pullrequestreview-516017592", "createdAt": "2020-10-23T21:21:52Z", "commit": {"oid": "d185aeaf8af6ba2f2d350c6448715e7a08f23daf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMToyMTo1MlrOHney1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMToyMTo1MlrOHney1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2MTA0NA==", "bodyText": "I don't thnk these endian macros are necessary - there are no supported platforms that can't just cast to the correct type and dereference.\n#define _GETNEXT_U16(value, index) (value = *(U_16*)index, index += 2, value)\n\nAlso best not to start macros with an underscore (technically reserved in C).", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#discussion_r511161044", "createdAt": "2020-10-23T21:21:52Z", "author": {"login": "gacholio"}, "path": "runtime/vm/extendedMessageNPE.cpp", "diffHunk": "@@ -20,21 +20,114 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n+#include \"bcverify.h\"\n #include \"cfreader.h\"\n+#include \"pcstack.h\"\n+#include \"rommeth.h\"\n #include \"stackwalk.h\"\n-#include \"util_api.h\"\n #include \"ut_j9vm.h\"\n+#include \"vrfytbl.h\"\n \n extern \"C\" {\n \n+/* Define for debug\n+#define DEBUG_BCV\n+*/\n+\n+static IDATA buildBranchMap(J9NPEMessageData *npeMsgData);\n+static void computeNPEMsgAtPC(J9VMThread *vmThread, J9ROMMethod *romMethod, J9ROMClass *romClass, UDATA npePC,\n+\t\tBOOLEAN npeFinalFlag, char **npeMsg, BOOLEAN *isMethodFlag, UDATA *temps, J9BytecodeOffset *bytecodeOffset);\n static char* convertToJavaFullyQualifiedName(J9VMThread *vmThread, J9UTF8 *fullyQualifiedNameUTF);\n static char* convertMethodSignature(J9VMThread *vmThread, J9UTF8 *methodSig);\n+static IDATA copyToTargetStack(J9NPEMessageData *npeMsgData, UDATA target);\n+static char* getCompleteNPEMessage(J9VMThread *vmThread, U_8 *bcCurrentPtr, J9ROMClass *romClass, char *npeCauseMsg, BOOLEAN isMethodFlag);\n+static char* getFullyQualifiedMethodName(J9VMThread *vmThread, J9ROMClass *romClass, U_8 *bcIndex);\n+static char* getLocalsName(J9VMThread *vmThread, J9ROMMethod *romMethod, U_16 localVar, UDATA bcCausePos, UDATA *temps);\n+static char* getMsgWithAllocation(J9VMThread *vmThread, const char *msgTemplate, ...);\n+static IDATA initializeNPEMessageData(J9NPEMessageData *npeMsgData);\n+static void initStackFromMethodSignature(J9VMThread *vmThread, J9ROMMethod *romMethod, UDATA **stackTopPtr);\n+static UDATA* pushViaSiganature(J9VMThread *vmThread, U_8 *signature, UDATA *stackTop, UDATA bcPos);\n+static void setSrcBytecodeOffset(J9BytecodeOffset *bytecodeOffset, UDATA bcPos, UDATA first, UDATA second);\n+static char* simulateStack(J9NPEMessageData *npeMsgData);\n+\n+#define BCV_INTERNAL_DEFAULT_SIZE (32*1024)\n+#define BYTECODE_BRANCH_TARGET 0xFEFEFEFE\n+#define BYTECODE_TEMP_CHANGED 0xFDFDFDFD\n+#define BYTECODE_OFFSET_SHIFT 16\n+#define BYTECODE_OFFSET_MASK 0xFFFF\n+\n+#define NPEMSG_FIRST_STACK() \\\n+\t((J9BranchTargetStack *) (npeMsgData->stackMaps))\n+#define NPEMSG_NEXT_STACK(thisStack) \\\n+\t((J9BranchTargetStack *) (((U_8 *) (thisStack)) + (npeMsgData->stackSize)))\n+#define NPEMSG_INDEX_STACK(stackCount) \\\n+\t((J9BranchTargetStack *) (((U_8 *) NPEMSG_FIRST_STACK()) + (npeMsgData->stackSize * (stackCount))))\n+#define NPEMSG_CHECK_STACK_UNDERFLOW \\\n+\tif( stackTop < stackBase ) { \\\n+\t\tgoto _internalError; \\\n+\t}\n+#define NPEMSG_DROP( x )\t\\\n+\tstackTop -= x;\t\\\n+\tNPEMSG_CHECK_STACK_UNDERFLOW\n+#define NPEMSG_POP\t\\\n+\t*(--stackTop); \\\n+\tNPEMSG_CHECK_STACK_UNDERFLOW\n+#define _NEXT_LE_U16(value, index) ((value = (U_16)index[0] | ((U_16)index[1] << 8)), index += 2, value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d185aeaf8af6ba2f2d350c6448715e7a08f23daf"}, "originalPosition": 57}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d185aeaf8af6ba2f2d350c6448715e7a08f23daf", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/d185aeaf8af6ba2f2d350c6448715e7a08f23daf", "committedDate": "2020-10-19T18:41:24Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}, "afterCommit": {"oid": "711f877fa44f1f86dd34ac5ecae0bb1c2b00d139", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/711f877fa44f1f86dd34ac5ecae0bb1c2b00d139", "committedDate": "2020-10-24T03:50:14Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTk0MjU4", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#pullrequestreview-523594258", "createdAt": "2020-11-04T17:43:11Z", "commit": {"oid": "711f877fa44f1f86dd34ac5ecae0bb1c2b00d139"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzo0MzoxMVrOHti9Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzo0MzoxMVrOHti9Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUyMDcyMg==", "bodyText": "I dislike all caps variable names - using msgTemplate like above would be better.", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#discussion_r517520722", "createdAt": "2020-11-04T17:43:11Z", "author": {"login": "gacholio"}, "path": "runtime/vm/extendedMessageNPE.cpp", "diffHunk": "@@ -291,43 +383,85 @@ getCompleteNPEMessage(J9VMThread *vmThread, U_8 *bcCurrentPtr, J9ROMClass *romCl\n \t\tdefault:\n \t\t\tTrc_VM_GetCompleteNPEMessage_Unreachable(vmThread, bcCurrent);\n \t\t}\n-\t\tif ((bcCurrent >= JBiaload) && (bcCurrent <= JBsaload)) {\n-\t\t\tmsgTemplate = \"Cannot load from %s array\";\n+\t\tif (NULL == npeCauseMsg) {\n+\t\t\tif ((bcCurrent >= JBiaload) && (bcCurrent <= JBsaload)) {\n+\t\t\t\tmsgTemplate = \"Cannot load from %s array\";\n+\t\t\t} else {\n+\t\t\t\tmsgTemplate = \"Cannot store to %s array\";\n+\t\t\t}\n+\t\t\tnpeMsg = getMsgWithAllocation(vmThread, msgTemplate, elementType);\n \t\t} else {\n-\t\t\tmsgTemplate = \"Cannot store to %s array\";\n+\t\t\tif ((bcCurrent >= JBiaload) && (bcCurrent <= JBsaload)) {\n+\t\t\t\tif (isMethodFlag) {\n+\t\t\t\t\tmsgTemplate = \"Cannot load from %s array because the return value of \\\"%s\\\" is null\";\n+\t\t\t\t} else {\n+\t\t\t\t\tmsgTemplate = \"Cannot load from %s array because \\\"%s\\\" is null\";\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (isMethodFlag) {\n+\t\t\t\t\tmsgTemplate = \"Cannot store to %s array because the return value of \\\"%s\\\" is null\";\n+\t\t\t\t} else {\n+\t\t\t\t\tmsgTemplate = \"Cannot store to %s array because \\\"%s\\\" is null\";\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tnpeMsg = getMsgWithAllocation(vmThread, msgTemplate, elementType, npeCauseMsg);\n \t\t}\n-\t\tmsgLen = j9str_printf(PORTLIB, NULL, 0, msgTemplate, elementType);\n-\t\t/* msg NULL check omitted since str_printf accepts NULL (as above) */\n-\t\tnpeMsg = (char *)j9mem_allocate_memory(msgLen + 1, OMRMEM_CATEGORY_VM);\n-\t\tj9str_printf(PORTLIB, npeMsg, msgLen, msgTemplate, elementType);\n \t} else {\n \t\tswitch (bcCurrent) {\n \t\tcase JBarraylength: {\n-\t\t\tconst char *VM_NPE_ARRAYLENGTH = \"Cannot read the array length\";\n-\t\t\tmsgLen = j9str_printf(PORTLIB, NULL, 0, VM_NPE_ARRAYLENGTH);\n-\t\t\tnpeMsg = (char *)j9mem_allocate_memory(msgLen + 1, OMRMEM_CATEGORY_VM);\n-\t\t\tj9str_printf(PORTLIB, npeMsg, msgLen, VM_NPE_ARRAYLENGTH);\n+\t\t\tif (NULL == npeCauseMsg) {\n+\t\t\t\tnpeMsg = getMsgWithAllocation(vmThread, msgTemplate, \"Cannot read the array length\");\n+\t\t\t} else {\n+\t\t\t\tconst char *VM_NPE_ARRAYLENGTH = NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "711f877fa44f1f86dd34ac5ecae0bb1c2b00d139"}, "originalPosition": 190}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "711f877fa44f1f86dd34ac5ecae0bb1c2b00d139", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/711f877fa44f1f86dd34ac5ecae0bb1c2b00d139", "committedDate": "2020-10-24T03:50:14Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}, "afterCommit": {"oid": "dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0", "committedDate": "2020-11-04T23:28:49Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0Mzk3NTc3", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#pullrequestreview-524397577", "createdAt": "2020-11-05T15:45:46Z", "commit": {"oid": "dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo0NTo0N1rOHuJkzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo0NTo0N1rOHuJkzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1MzQyMA==", "bodyText": "Extra brackets around bytecodeMap.", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#discussion_r518153420", "createdAt": "2020-11-05T15:45:47Z", "author": {"login": "gacholio"}, "path": "runtime/vm/extendedMessageNPE.cpp", "diffHunk": "@@ -374,30 +519,1493 @@ getCompleteNPEMessage(J9VMThread *vmThread, U_8 *bcCurrentPtr, J9ROMClass *romCl\n \t\t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&constantPool[index];\n \t\t\tJ9ROMNameAndSignature *methodNameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n \t\t\tJ9UTF8 *methodName = J9ROMNAMEANDSIGNATURE_NAME(methodNameAndSig);\n-\t\t\tconst char *VM_NPE_INVOKEMETHOD = \"Cannot invoke \\\"%s.%.*s%s\\\"\";\n-\n \t\t\tJ9UTF8 *definingClassFullQualifiedName = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&constantPool[romMethodRef->classRefCPIndex]);\n-\t\t\tchar *fullyQualifiedDefiningClassName = convertToJavaFullyQualifiedName(vmThread, definingClassFullQualifiedName);\n-\t\t\tchar *methodSigParameters = convertMethodSignature(vmThread, J9ROMNAMEANDSIGNATURE_SIGNATURE(methodNameAndSig));\n+\t\t\tJ9UTF8* methodSig = J9ROMNAMEANDSIGNATURE_SIGNATURE(methodNameAndSig);\n+\t\t\tBOOLEAN npeMsgRequired = TRUE;\n+\n+\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(definingClassFullQualifiedName), J9UTF8_LENGTH(definingClassFullQualifiedName), \"java/lang/NullPointerException\")) {\n+\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(methodName), J9UTF8_LENGTH(methodName), \"<init>\")) {\n+\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(methodSig), J9UTF8_LENGTH(methodSig), \"()V\")) {\n+\t\t\t\t\t\t/* No message generated for new NullPointerException().getMessage() */\n+\t\t\t\t\t\tnpeMsgRequired = FALSE;\n+\t\t\t\t\t\tTrc_VM_GetCompleteNPEMessage_Not_Required(vmThread);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \n-\t\t\tif ((NULL != definingClassFullQualifiedName) && (NULL != methodSigParameters)) {\n-\t\t\t\tmsgLen = j9str_printf(PORTLIB, NULL, 0, VM_NPE_INVOKEMETHOD,\n-\t\t\t\t\tfullyQualifiedDefiningClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters);\n-\t\t\t\tnpeMsg = (char *)j9mem_allocate_memory(msgLen + 1, OMRMEM_CATEGORY_VM);\n-\t\t\t\tj9str_printf(PORTLIB, npeMsg, msgLen, VM_NPE_INVOKEMETHOD,\n-\t\t\t\t\tfullyQualifiedDefiningClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters);\n \t\t\t}\n-\t\t\tj9mem_free_memory(fullyQualifiedDefiningClassName);\n-\t\t\tj9mem_free_memory(methodSigParameters);\n+\t\t\tif (npeMsgRequired) {\n+\t\t\t\tchar *fullyQualifiedClassName = convertToJavaFullyQualifiedName(vmThread, definingClassFullQualifiedName);\n+\t\t\t\tchar *methodSigParameters = convertMethodSignature(vmThread, methodSig);\n+\t\t\t\tif (NULL == npeCauseMsg) {\n+\t\t\t\t\tnpeMsg = getMsgWithAllocation(vmThread, \"Cannot invoke \\\"%s.%.*s%s\\\"\",\n+\t\t\t\t\t\tfullyQualifiedClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters);\n+\t\t\t\t} else {\n+\t\t\t\t\tif (isMethodFlag) {\n+\t\t\t\t\t\tmsgTemplate = \"Cannot invoke \\\"%s.%.*s%s\\\" because the return value of \\\"%s\\\" is null\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tmsgTemplate = \"Cannot invoke \\\"%s.%.*s%s\\\" because \\\"%s\\\" is null\";\n+\t\t\t\t\t}\n+\t\t\t\t\tnpeMsg = getMsgWithAllocation(vmThread, msgTemplate,\n+\t\t\t\t\t\t\tfullyQualifiedClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters, npeCauseMsg);\n+\t\t\t\t}\n+\t\t\t\tj9mem_free_memory(fullyQualifiedClassName);\n+\t\t\t\tj9mem_free_memory(methodSigParameters);\n+\t\t\t}\n \t\t\tbreak;\n \t\t}\n \t\tdefault:\n \t\t\tTrc_VM_GetCompleteNPEMessage_MissedBytecode(vmThread, bcCurrent);\n \t\t}\n \t}\n+\tj9mem_free_memory(npeCauseMsg);\n \tTrc_VM_GetCompleteNPEMessage_Exit(vmThread, npeMsg);\n \n \treturn npeMsg;\n }\n \n+/*\n+ * Initialize npeMsgData with incoming romMethod\n+ * @param[in] npeMsgData - the J9NPEMessageData structure holding romClass/romMethod/npePC\n+ *\n+ * @return IDATA BCV_SUCCESS if it succeeded, BCV_ERR_INTERNAL_ERROR for any unexpected error\n+ */\n+static IDATA\n+initializeNPEMessageData(J9NPEMessageData *npeMsgData)\n+{\n+\tPORT_ACCESS_FROM_VMC(npeMsgData->vmThread);\n+\tJ9ROMMethod *romMethod = npeMsgData->romMethod;\n+\tIDATA result = BCV_SUCCESS;\n+\n+\t/* BCV_TARGET_STACK_HEADER_UDATA_SIZE for pc/stackBase/stackEnd in J9BranchTargetStack and\n+\t * BCV_STACK_OVERFLOW_BUFFER_UDATA_SIZE for late overflow detection of longs/doubles\n+\t */\n+\tnpeMsgData->stackSize = (J9_MAX_STACK_FROM_ROM_METHOD(romMethod)\n+\t\t\t\t\t\t\t+ J9_ARG_COUNT_FROM_ROM_METHOD(romMethod)\n+\t\t\t\t\t\t\t+ J9_TEMP_COUNT_FROM_ROM_METHOD(romMethod)\n+\t\t\t\t\t\t\t+ BCV_TARGET_STACK_HEADER_UDATA_SIZE\n+\t\t\t\t\t\t\t+ BCV_STACK_OVERFLOW_BUFFER_UDATA_SIZE) * sizeof(UDATA);\n+\tALLOC_BUFFER(npeMsgData->liveStack, npeMsgData->stackSize, (J9BranchTargetStack *));\n+\n+\tUDATA bytecodeSize = J9_BYTECODE_SIZE_FROM_ROM_METHOD(romMethod);\n+\tUDATA bytecodeBufferSize = bytecodeSize * sizeof(U_32) * 2;\n+\tALLOC_BUFFER(npeMsgData->bytecodeOffset, bytecodeBufferSize, (J9BytecodeOffset *));\n+\tALLOC_BUFFER(npeMsgData->bytecodeMap, bytecodeBufferSize, (U_32 *));\n+\n+\tresult = buildBranchMap(npeMsgData);\n+\tif (result >= 0) {\n+\t\tJ9BranchTargetStack *liveStack = NULL;\n+\n+\t\tif (result > 0) {\n+\t\t\tnpeMsgData->stackMapsCount = result;\n+\n+\t\t\tUDATA stackMapsSize = (npeMsgData->stackSize) * (npeMsgData->stackMapsCount);\n+\t\t\tALLOC_BUFFER(npeMsgData->stackMaps, stackMapsSize, (UDATA *));\n+\t\t\tUDATA mapIndex = 0;\n+\t\t\tUDATA j = 0;\n+\t\t\tU_32 *bytecodeMap = npeMsgData->bytecodeMap;\n+\n+\t\t\tliveStack = NPEMSG_FIRST_STACK ();\n+\t\t\tfor (j = 0; j < bytecodeSize; j++) {\n+\t\t\t\tif ((bytecodeMap)[j] & BRANCH_TARGET) {\n+\t\t\t\t\tliveStack->pc = j;\t\t/* offset of the branch target */\n+\t\t\t\t\tliveStack->stackBaseIndex = -1;\n+\t\t\t\t\tliveStack->stackTopIndex = -1;\n+\t\t\t\t\tliveStack = NPEMSG_NEXT_STACK(liveStack);\n+\t\t\t\t\t(bytecodeMap)[j] |= (mapIndex << BRANCH_INDEX_SHIFT); /* adding the stack # */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0"}, "originalPosition": 395}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDExMzQx", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#pullrequestreview-524411341", "createdAt": "2020-11-05T15:58:59Z", "commit": {"oid": "dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo1ODo1OVrOHuKMlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo1ODo1OVrOHuKMlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE2MzYwNg==", "bodyText": "As this is a .cpp file, please use bool instead of BOOLEAN throughout.", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#discussion_r518163606", "createdAt": "2020-11-05T15:58:59Z", "author": {"login": "gacholio"}, "path": "runtime/vm/extendedMessageNPE.cpp", "diffHunk": "@@ -374,30 +519,1493 @@ getCompleteNPEMessage(J9VMThread *vmThread, U_8 *bcCurrentPtr, J9ROMClass *romCl\n \t\t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&constantPool[index];\n \t\t\tJ9ROMNameAndSignature *methodNameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n \t\t\tJ9UTF8 *methodName = J9ROMNAMEANDSIGNATURE_NAME(methodNameAndSig);\n-\t\t\tconst char *VM_NPE_INVOKEMETHOD = \"Cannot invoke \\\"%s.%.*s%s\\\"\";\n-\n \t\t\tJ9UTF8 *definingClassFullQualifiedName = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&constantPool[romMethodRef->classRefCPIndex]);\n-\t\t\tchar *fullyQualifiedDefiningClassName = convertToJavaFullyQualifiedName(vmThread, definingClassFullQualifiedName);\n-\t\t\tchar *methodSigParameters = convertMethodSignature(vmThread, J9ROMNAMEANDSIGNATURE_SIGNATURE(methodNameAndSig));\n+\t\t\tJ9UTF8* methodSig = J9ROMNAMEANDSIGNATURE_SIGNATURE(methodNameAndSig);\n+\t\t\tBOOLEAN npeMsgRequired = TRUE;\n+\n+\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(definingClassFullQualifiedName), J9UTF8_LENGTH(definingClassFullQualifiedName), \"java/lang/NullPointerException\")) {\n+\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(methodName), J9UTF8_LENGTH(methodName), \"<init>\")) {\n+\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(methodSig), J9UTF8_LENGTH(methodSig), \"()V\")) {\n+\t\t\t\t\t\t/* No message generated for new NullPointerException().getMessage() */\n+\t\t\t\t\t\tnpeMsgRequired = FALSE;\n+\t\t\t\t\t\tTrc_VM_GetCompleteNPEMessage_Not_Required(vmThread);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \n-\t\t\tif ((NULL != definingClassFullQualifiedName) && (NULL != methodSigParameters)) {\n-\t\t\t\tmsgLen = j9str_printf(PORTLIB, NULL, 0, VM_NPE_INVOKEMETHOD,\n-\t\t\t\t\tfullyQualifiedDefiningClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters);\n-\t\t\t\tnpeMsg = (char *)j9mem_allocate_memory(msgLen + 1, OMRMEM_CATEGORY_VM);\n-\t\t\t\tj9str_printf(PORTLIB, npeMsg, msgLen, VM_NPE_INVOKEMETHOD,\n-\t\t\t\t\tfullyQualifiedDefiningClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters);\n \t\t\t}\n-\t\t\tj9mem_free_memory(fullyQualifiedDefiningClassName);\n-\t\t\tj9mem_free_memory(methodSigParameters);\n+\t\t\tif (npeMsgRequired) {\n+\t\t\t\tchar *fullyQualifiedClassName = convertToJavaFullyQualifiedName(vmThread, definingClassFullQualifiedName);\n+\t\t\t\tchar *methodSigParameters = convertMethodSignature(vmThread, methodSig);\n+\t\t\t\tif (NULL == npeCauseMsg) {\n+\t\t\t\t\tnpeMsg = getMsgWithAllocation(vmThread, \"Cannot invoke \\\"%s.%.*s%s\\\"\",\n+\t\t\t\t\t\tfullyQualifiedClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters);\n+\t\t\t\t} else {\n+\t\t\t\t\tif (isMethodFlag) {\n+\t\t\t\t\t\tmsgTemplate = \"Cannot invoke \\\"%s.%.*s%s\\\" because the return value of \\\"%s\\\" is null\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tmsgTemplate = \"Cannot invoke \\\"%s.%.*s%s\\\" because \\\"%s\\\" is null\";\n+\t\t\t\t\t}\n+\t\t\t\t\tnpeMsg = getMsgWithAllocation(vmThread, msgTemplate,\n+\t\t\t\t\t\t\tfullyQualifiedClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters, npeCauseMsg);\n+\t\t\t\t}\n+\t\t\t\tj9mem_free_memory(fullyQualifiedClassName);\n+\t\t\t\tj9mem_free_memory(methodSigParameters);\n+\t\t\t}\n \t\t\tbreak;\n \t\t}\n \t\tdefault:\n \t\t\tTrc_VM_GetCompleteNPEMessage_MissedBytecode(vmThread, bcCurrent);\n \t\t}\n \t}\n+\tj9mem_free_memory(npeCauseMsg);\n \tTrc_VM_GetCompleteNPEMessage_Exit(vmThread, npeMsg);\n \n \treturn npeMsg;\n }\n \n+/*\n+ * Initialize npeMsgData with incoming romMethod\n+ * @param[in] npeMsgData - the J9NPEMessageData structure holding romClass/romMethod/npePC\n+ *\n+ * @return IDATA BCV_SUCCESS if it succeeded, BCV_ERR_INTERNAL_ERROR for any unexpected error\n+ */\n+static IDATA\n+initializeNPEMessageData(J9NPEMessageData *npeMsgData)\n+{\n+\tPORT_ACCESS_FROM_VMC(npeMsgData->vmThread);\n+\tJ9ROMMethod *romMethod = npeMsgData->romMethod;\n+\tIDATA result = BCV_SUCCESS;\n+\n+\t/* BCV_TARGET_STACK_HEADER_UDATA_SIZE for pc/stackBase/stackEnd in J9BranchTargetStack and\n+\t * BCV_STACK_OVERFLOW_BUFFER_UDATA_SIZE for late overflow detection of longs/doubles\n+\t */\n+\tnpeMsgData->stackSize = (J9_MAX_STACK_FROM_ROM_METHOD(romMethod)\n+\t\t\t\t\t\t\t+ J9_ARG_COUNT_FROM_ROM_METHOD(romMethod)\n+\t\t\t\t\t\t\t+ J9_TEMP_COUNT_FROM_ROM_METHOD(romMethod)\n+\t\t\t\t\t\t\t+ BCV_TARGET_STACK_HEADER_UDATA_SIZE\n+\t\t\t\t\t\t\t+ BCV_STACK_OVERFLOW_BUFFER_UDATA_SIZE) * sizeof(UDATA);\n+\tALLOC_BUFFER(npeMsgData->liveStack, npeMsgData->stackSize, (J9BranchTargetStack *));\n+\n+\tUDATA bytecodeSize = J9_BYTECODE_SIZE_FROM_ROM_METHOD(romMethod);\n+\tUDATA bytecodeBufferSize = bytecodeSize * sizeof(U_32) * 2;\n+\tALLOC_BUFFER(npeMsgData->bytecodeOffset, bytecodeBufferSize, (J9BytecodeOffset *));\n+\tALLOC_BUFFER(npeMsgData->bytecodeMap, bytecodeBufferSize, (U_32 *));\n+\n+\tresult = buildBranchMap(npeMsgData);\n+\tif (result >= 0) {\n+\t\tJ9BranchTargetStack *liveStack = NULL;\n+\n+\t\tif (result > 0) {\n+\t\t\tnpeMsgData->stackMapsCount = result;\n+\n+\t\t\tUDATA stackMapsSize = (npeMsgData->stackSize) * (npeMsgData->stackMapsCount);\n+\t\t\tALLOC_BUFFER(npeMsgData->stackMaps, stackMapsSize, (UDATA *));\n+\t\t\tUDATA mapIndex = 0;\n+\t\t\tUDATA j = 0;\n+\t\t\tU_32 *bytecodeMap = npeMsgData->bytecodeMap;\n+\n+\t\t\tliveStack = NPEMSG_FIRST_STACK ();\n+\t\t\tfor (j = 0; j < bytecodeSize; j++) {\n+\t\t\t\tif ((bytecodeMap)[j] & BRANCH_TARGET) {\n+\t\t\t\t\tliveStack->pc = j;\t\t/* offset of the branch target */\n+\t\t\t\t\tliveStack->stackBaseIndex = -1;\n+\t\t\t\t\tliveStack->stackTopIndex = -1;\n+\t\t\t\t\tliveStack = NPEMSG_NEXT_STACK(liveStack);\n+\t\t\t\t\t(bytecodeMap)[j] |= (mapIndex << BRANCH_INDEX_SHIFT); /* adding the stack # */\n+\t\t\t\t\tmapIndex++;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tUDATA unwalkedQueueSize = (npeMsgData->stackMapsCount + 1) * sizeof(UDATA);\n+\t\t\tALLOC_BUFFER(npeMsgData->unwalkedQueue, unwalkedQueueSize, (UDATA *));\n+\t\t}\n+\n+\t\tliveStack = (J9BranchTargetStack *)npeMsgData->liveStack;\n+\t\tUDATA *stackTop = &(liveStack->stackElements[0]);\n+\t\tinitStackFromMethodSignature(npeMsgData->vmThread, romMethod, &stackTop);\n+\t\tSAVE_STACKTOP(liveStack, stackTop);\n+\t\tliveStack->stackBaseIndex = liveStack->stackTopIndex;\n+\t\tresult = BCV_SUCCESS;\n+\t}\n+\n+\treturn result;\n+}\n+\n+/*\n+ * Initialize bytecodeMap with BRANCH_TARGET or BRANCH_EXCEPTION_START\n+ * @param[in] npeMsgData - the J9NPEMessageData structure holding romClass/romMethod/npePC\n+ *\n+ * @return IDATA the number of branch targets and exception handler starts\n+ *         BCV_ERR_INTERNAL_ERROR for any unexpected error\n+ */\n+static IDATA\n+buildBranchMap(J9NPEMessageData *npeMsgData)\n+{\n+\tJ9ROMMethod *romMethod = npeMsgData->romMethod;\n+\tU_32 *bytecodeMap = npeMsgData->bytecodeMap;\n+\tUDATA count = 0;\n+\tU_8 *bcStart = J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\tU_8 *bcIndex = bcStart;\n+\tU_8 *bcEnd = bcStart + J9_BYTECODE_SIZE_FROM_ROM_METHOD(romMethod);\n+\n+\twhile (bcIndex < bcEnd) {\n+\t\tIDATA start = 0;\n+\t\tI_32 longBranch = 0;\n+\t\tUDATA bc = *bcIndex;\n+\t\t/* high nybble = branch action, low nybble = instruction size */\n+\t\tUDATA size = J9JavaInstructionSizeAndBranchActionTable[bc];\n+\t\tif (0 == size) {\n+\t\t\treturn BCV_ERR_INTERNAL_ERROR;\n+\t\t}\n+\n+\t\tswitch (size >> 4) { /* branch action */\n+\t\tcase 5: { /* switches */\n+\t\t\tstart = bcIndex - bcStart;\n+\t\t\tIDATA pc = (start + 4) & ~3;\n+\t\t\tbcIndex = bcStart + pc;\n+\t\t\tlongBranch = (I_32) PARAM_32(bcIndex, 0);\n+\t\t\tbcIndex += 4;\n+\t\t\tif (0 == bytecodeMap[start + longBranch]) {\n+\t\t\t\tbytecodeMap[start + longBranch] = BRANCH_TARGET;\n+\t\t\t\tcount++;\n+\t\t\t}\n+\n+\t\t\tUDATA npairs = 0;\n+\t\t\tIDATA pcs = 0;\n+\t\t\tIDATA low = (I_32) PARAM_32(bcIndex, 0);\n+\t\t\tbcIndex += 4;\n+\t\t\tif (JBtableswitch == bc) {\n+\t\t\t\tIDATA high = (I_32) PARAM_32(bcIndex, 0);\n+\t\t\t\tbcIndex += 4;\n+\t\t\t\tnpairs = (UDATA) (high - low + 1);\n+\t\t\t\tpcs = 0;\n+\t\t\t} else {\n+\t\t\t\tnpairs = (UDATA) low;\n+\t\t\t\tpcs = 4;\n+\t\t\t}\n+\n+\t\t\tUDATA temp = 0;\n+\t\t\tfor (temp = 0; temp < npairs; temp++) {\n+\t\t\t\tbcIndex += pcs;\n+\t\t\t\tlongBranch = (I_32) PARAM_32(bcIndex, 0);\n+\t\t\t\tbcIndex += 4;\n+\t\t\t\tif (0 == bytecodeMap[start + longBranch]) {\n+\t\t\t\t\tbytecodeMap[start + longBranch] = BRANCH_TARGET;\n+\t\t\t\t\tcount++;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tcase 2: /* gotos */\n+\t\t\tif (JBgotow == bc) {\n+\t\t\t\tstart = bcIndex - bcStart;\n+\t\t\t\tlongBranch = (I_32) PARAM_32(bcIndex, 1);\n+\t\t\t\tif (0 == bytecodeMap[start + longBranch]) {\n+\t\t\t\t\tbytecodeMap[start + longBranch] = BRANCH_TARGET;\n+\t\t\t\t\tcount++;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t} /* fall through for JBgoto */\n+\n+\t\tcase 1: /* ifs */\n+\t\t\tI_16 shortBranch = (I_16) PARAM_16(bcIndex, 1);\n+\t\t\tstart = bcIndex - bcStart;\n+\t\t\tif (0 == bytecodeMap[start + shortBranch]) {\n+\t\t\t\tbytecodeMap[start + shortBranch] = BRANCH_TARGET;\n+\t\t\t\tcount++;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tbcIndex += size & 7;\n+\t}\n+\n+\t/* need to walk exceptions as well, since they are branch targets */\n+\tif (romMethod->modifiers & J9AccMethodHasExceptionInfo) {\n+\t\tJ9ExceptionInfo *exceptionData = J9_EXCEPTION_DATA_FROM_ROM_METHOD(romMethod);\n+\t\tJ9ExceptionHandler *handler = NULL;\n+\n+\t\tif (exceptionData->catchCount) {\n+\t\t\tUDATA temp = 0;\n+\t\t\tIDATA pc = 0;\n+\t\t\tIDATA pcs = 0;\n+\n+\t\t\thandler = J9EXCEPTIONINFO_HANDLERS(exceptionData);\n+\t\t\tfor (temp = 0; temp < (U_32) exceptionData->catchCount; temp++) {\n+\t\t\t\tpc = (IDATA) handler->startPC;\n+\t\t\t\tpcs = (IDATA) handler->handlerPC;\n+\t\t\t\t/* Avoid re-walking a handler that handles itself */\n+\t\t\t\tif (pc != pcs) {\n+\t\t\t\t\tbytecodeMap[pc] |= BRANCH_EXCEPTION_START;\n+\t\t\t\t}\n+\t\t\t\tif (0 == (bytecodeMap[pcs] & BRANCH_TARGET)) {\n+\t\t\t\t\tbytecodeMap[pcs] |= BRANCH_TARGET;\n+\t\t\t\t\tcount++;\n+\t\t\t\t}\n+\t\t\t\thandler++;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn count;\n+}\n+\n+/**\n+ * Compute NPE message at npePC supplied. This can be invoked recursively.\n+ *\n+ * @param[in] vmThread The current J9VMThread\n+ * @param[in] bcCurrentPtr The pointer to the bytecode being executed and caused the NPE\n+ * @param[in] romMethod The romMethod of the bytecode\n+ * @param[in] romClass The romClass of the bytecode\n+ * @param[in] npePC The bytecode offset where the NPE message is to be generated\n+ * @param[in] npeFinalFlag The flag indicates if getCompleteNPEMessage() is invoked\n+ * @param[in,out] npeMsg An extended NPE message generated so far\n+ * @param[in,out] isMethodFlag The flag indicates if \"the return value of\" should be added into the message\n+ * @param[in] temps The location of bytecode temps supplied via liveStack->stackElements\n+ * @param[in] bytecodeOffset The array storing the bytecode offset\n+ * @param[in] bytecodeOffset The cause of NPE\n+ */\n+static void\n+computeNPEMsgAtPC(J9VMThread *vmThread, J9ROMMethod *romMethod, J9ROMClass *romClass, UDATA npePC,\n+\t\tBOOLEAN npeFinalFlag, char **npeMsg, BOOLEAN *isMethodFlag, UDATA *temps, J9BytecodeOffset *bytecodeOffset)\n+{\n+\tJ9ROMConstantPoolItem *constantPool = J9_ROM_CP_FROM_ROM_CLASS(romClass);\n+\tU_8 *code = J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\tU_8 *bcCurrentPtr = code + npePC;\n+\tU_8 bcCurrent = *bcCurrentPtr;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+//\tUDATA bigEndian = BCT_LittleEndianOutput;\n+#else\n+//\tUDATA bigEndian = BCT_BigEndianOutput;\n+#endif\n+\tPORT_ACCESS_FROM_VMC(vmThread);\n+\n+\tTrc_VM_ComputeNPEMsgAtPC_Entry(vmThread, romClass, romMethod, temps, bytecodeOffset, bcCurrent, npePC, npeFinalFlag, *isMethodFlag, *npeMsg);\n+\tif ((bcCurrent >= JBiconstm1) && (bcCurrent <= JBdconst1)) {\n+\t\t/*\n+\t\t * JBiconstm1, JBiconst0, JBiconst1, JBiconst2, JBiconst3, JBiconst4, JBiconst5\n+\t\t * JBlconst0, JBlconst1\n+\t\t * JBfconst0, JBfconst1, JBfconst2\n+\t\t * JBdconst0, JBdconst1\n+\t\t */\n+\t\tI_8 constNum = 0;\n+\t\tBOOLEAN missedBCFlag = FALSE;\n+\n+\t\tif (JBiconstm1 == bcCurrent) {\n+\t\t\tconstNum = -1;\n+\t\t} else {\n+\t\t\tif ((bcCurrent >= JBiconst0) && (bcCurrent <= JBiconst5)) {\n+\t\t\t\tconstNum = bcCurrent - 3; /* iconst_0 = 3 (0x3) */\n+\t\t\t} else if ((JBlconst0 == bcCurrent) || (JBfconst0 == bcCurrent) || (JBdconst0 == bcCurrent)) {\n+\t\t\t\tconstNum = 0;\n+\t\t\t} else if ((JBlconst1 == bcCurrent) || (JBfconst1 == bcCurrent) || (JBdconst1 == bcCurrent)) {\n+\t\t\t\tconstNum = 1;\n+\t\t\t} else if (JBfconst2 == bcCurrent) {\n+\t\t\t\tconstNum = 2;\n+\t\t\t} else {\n+\t\t\t\tmissedBCFlag = TRUE;\n+\t\t\t\tTrc_VM_ComputeNPEMsgAtPC_Constants_UnexpectedBC(vmThread, bcCurrent);\n+\t\t\t}\n+\t\t}\n+\t\tif (!missedBCFlag) {\n+\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%d\", constNum);\n+\t\t}\n+\t} else if (((bcCurrent >= JBiadd) && (bcCurrent <= JBlxor))\n+\t\t|| ((bcCurrent >= JBlcmp) && (bcCurrent <= JBdcmpg))\n+\t) {\n+\t\t/* JBiadd, JBladd, JBfadd, JBdadd, JBisub, JBlsub, JBfsub, JBdsub, JBimul, JBlmul, JBfmul, JBdmul\n+\t\t * JBidiv, JBldiv, JBfdiv, JBddiv, JBirem, JBlrem, JBfrem, JBdrem, JBineg, JBlneg, JBfneg, JBdneg\n+\t\t * JBishl, JBlshl, JBishr, JBlshr, JBiushr, JBlushr, JBiand, JBland, JBior, JBlor, JBixor, JBlxor\n+\t\t *\n+\t\t * JBlcmp, JBfcmpl, JBfcmpg, JBdcmpl, JBdcmpg\n+\t\t */\n+\t\t*npeMsg = getMsgWithAllocation(vmThread, \"...\");\n+\t} else {\n+\t\tswitch (bcCurrent) {\n+\t\tcase JBaconstnull:\n+\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"null\");\n+\t\t\tbreak;\n+\n+\t\tcase JBbipush:\n+\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%lu\", *(bcCurrentPtr + 1));\n+\t\t\tbreak;\n+\n+\t\tcase JBsipush: {\n+\t\t\tUDATA sipushIndex = 0;\n+\t\t\tU_8 *tmpbcPtr = bcCurrentPtr + 1;\n+\n+\t\t\tGETNEXT_U16(sipushIndex, tmpbcPtr);\n+\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%lu\", sipushIndex);\n+\t\t\tbreak;\n+\t\t}\n+\t\t\n+\t\tcase JBldc:\t\t/* Fall through case !!! */\n+\t\tcase JBldcw:\t/* Fall through case !!! */\n+\t\tcase JBldc2dw:\t/* Fall through case !!! */\n+\t\tcase JBldc2lw: {\n+\t\t\tUDATA ldcIndex = 0;\n+\t\t\tU_8 *tmpbcPtr = bcCurrentPtr + 1;\n+\n+\t\t\tif (JBldc == bcCurrent) {\n+\t\t\t\tGETNEXT_U8(ldcIndex, tmpbcPtr);\n+\t\t\t} else if (JBldcw == bcCurrent) {\n+\t\t\t\tGETNEXT_U16(ldcIndex, tmpbcPtr);\n+\t\t\t} else {\n+\t\t\t\t/* bcCurrent is JBldc2lw or JBldc2dw */\n+\t\t\t\tGETNEXT_U8(ldcIndex, tmpbcPtr);\n+\t\t\t}\n+\n+\t\t\tJ9ROMConstantPoolItem *info = &constantPool[ldcIndex];\n+\t\t\tif (BCT_J9DescriptionCpTypeScalar == ((J9ROMSingleSlotConstantRef *) info)->cpType) {\n+\t\t\t\t/* this is a float/int constant */\n+\t\t\t\tldcIndex = ((J9ROMSingleSlotConstantRef *) info)->data;\n+\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%lu\", ldcIndex);\n+\t\t\t} else {\n+\t\t\t\t Trc_VM_ComputeNPEMsgAtPC_NotScalarType(vmThread, romClass, romMethod, constantPool, ldcIndex, info, ((J9ROMSingleSlotConstantRef *) info)->cpType);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBanewarray: {\n+\t\t\tUDATA index = PARAM_16(bcCurrentPtr, 1);\n+\t\t\tJ9ROMConstantPoolItem *info = &constantPool[index];\n+\t\t\tJ9UTF8 *className = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *) info);\n+\t\t\tchar *fullyQualifiedClassName = convertToJavaFullyQualifiedName(vmThread, className);\n+\n+\t\t\t*npeMsg = getMsgWithAllocation(vmThread, fullyQualifiedClassName);\n+\t\t\tj9mem_free_memory(fullyQualifiedClassName);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBinvokeinterface2:\t/* Fall through case !!! */\n+\t\tcase JBinvokevirtual:\t\t/* Fall through case !!! */\n+\t\tcase JBinvokespecial:\t\t/* Fall through case !!! */\n+\t\tcase JBinvokeinterface:\t\t/* Fall through case !!! */\n+\t\tcase JBinvokestatic: {\n+\t\t\tif (npeFinalFlag) {\n+\t\t\t\tUDATA objectrefPos = bytecodeOffset[npePC].first;\n+\n+\t\t\t\tif (BYTECODE_BRANCH_TARGET == objectrefPos) {\n+\t\t\t\t\t*npeMsg = NULL;\n+\t\t\t\t} else {\n+\t\t\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, objectrefPos, FALSE, npeMsg, isMethodFlag, temps, bytecodeOffset);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tU_8 *bcPtrTemp = (JBinvokeinterface2 == bcCurrent) ? bcCurrentPtr + 2 : bcCurrentPtr;\n+\t\t\t\tchar *methodName = getFullyQualifiedMethodName(vmThread, romClass, bcPtrTemp);\n+\n+\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, methodName);\n+\t\t\t\tj9mem_free_memory(methodName);\n+\t\t\t\t*isMethodFlag = TRUE;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBiload0:\t/* Fall through case !!! */\n+\t\tcase JBiload1:\t/* Fall through case !!! */\n+\t\tcase JBiload2:\t/* Fall through case !!! */\n+\t\tcase JBiload3:\t/* Fall through case !!! */\n+\t\tcase JBlload0:\t/* Fall through case !!! */\n+\t\tcase JBlload1:\t/* Fall through case !!! */\n+\t\tcase JBlload2:\t/* Fall through case !!! */\n+\t\tcase JBlload3:\t/* Fall through case !!! */\n+\t\tcase JBfload0:\t/* Fall through case !!! */\n+\t\tcase JBfload1:\t/* Fall through case !!! */\n+\t\tcase JBfload2:\t/* Fall through case !!! */\n+\t\tcase JBfload3:\t/* Fall through case !!! */\n+\t\tcase JBdload0:\t/* Fall through case !!! */\n+\t\tcase JBdload1:\t/* Fall through case !!! */\n+\t\tcase JBdload2:\t/* Fall through case !!! */\n+\t\tcase JBdload3:\t/* Fall through case !!! */\n+\t\tcase JBaload0:\t/* Fall through case !!! */\n+\t\tcase JBaload1:\t/* Fall through case !!! */\n+\t\tcase JBaload2:\t/* Fall through case !!! */\n+\t\tcase JBaload3:\t/* Fall through case !!! */\n+\t\tcase JBaload0getfield: {\n+\t\t\tU_16 localVar = 0;\n+\t\t\tif (bcCurrent >= JBiload0 && bcCurrent <= JBiload3) {\n+\t\t\t\tlocalVar = bcCurrent - JBiload0;\n+\t\t\t} else if (bcCurrent >= JBlload0 && bcCurrent <= JBlload3) {\n+\t\t\t\tlocalVar = bcCurrent - JBlload0;\n+\t\t\t} else if (bcCurrent >= JBfload0 && bcCurrent <= JBfload3) {\n+\t\t\t\tlocalVar = bcCurrent - JBfload0;\n+\t\t\t} else if (bcCurrent >= JBdload0 && bcCurrent <= JBdload3) {\n+\t\t\t\tlocalVar = bcCurrent - JBdload0;\n+\t\t\t} else if (bcCurrent >= JBaload0 && bcCurrent <= JBaload3) {\n+\t\t\t\tlocalVar = bcCurrent - JBaload0;\n+\t\t\t} else if (JBaload0getfield == bcCurrent) {\n+\t\t\t\tlocalVar = 0;\n+\t\t\t}\n+\t\t\t*npeMsg = getLocalsName(vmThread, romMethod, localVar, npePC, temps);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBiload:\t/* Fall through case !!! */\n+\t\tcase JBlload:\t/* Fall through case !!! */\n+\t\tcase JBfload:\t/* Fall through case !!! */\n+\t\tcase JBdload:\t/* Fall through case !!! */\n+\t\tcase JBaload: {\n+\t\t\t/* The index is an unsigned byte that must be an index into the local variable array of the current frame (\u00a72.6).\n+\t\t\t * The local variable at index must contain a reference.\n+\t\t\t */\n+\t\t\t*npeMsg = getLocalsName(vmThread, romMethod, *(bcCurrentPtr + 1), npePC, temps);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBiloadw:\t/* Fall through case !!! */\n+\t\tcase JBlloadw:\t/* Fall through case !!! */\n+\t\tcase JBfloadw:\t/* Fall through case !!! */\n+\t\tcase JBdloadw:\t/* Fall through case !!! */\n+\t\tcase JBaloadw: {\n+\t\t\tU_16 localVar = 0;\n+\t\t\tU_8 *tmpbcPtr = bcCurrentPtr + 1;\n+\n+\t\t\tGETNEXT_U16(localVar, tmpbcPtr);\n+\t\t\t*npeMsg = getLocalsName(vmThread, romMethod, localVar, npePC, temps);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBi2l:\t/* Fall through case !!! */\n+\t\tcase JBi2f:\t/* Fall through case !!! */\n+\t\tcase JBi2d:\t/* Fall through case !!! */\n+\t\tcase JBl2i:\t/* Fall through case !!! */\n+\t\tcase JBl2f:\t/* Fall through case !!! */\n+\t\tcase JBl2d:\t/* Fall through case !!! */\n+\t\tcase JBf2i:\t/* Fall through case !!! */\n+\t\tcase JBf2l:\t/* Fall through case !!! */\n+\t\tcase JBf2d:\t/* Fall through case !!! */\n+\t\tcase JBd2i:\t/* Fall through case !!! */\n+\t\tcase JBd2l:\t/* Fall through case !!! */\n+\t\tcase JBd2f:\t/* Fall through case !!! */\n+\t\tcase JBi2b:\t/* Fall through case !!! */\n+\t\tcase JBi2c:\t/* Fall through case !!! */\n+\t\tcase JBi2s:\t/* Fall through case !!! */\n+\t\tcase JBarraylength:\t/* Fall through case !!! */\n+\t\tcase JBathrow:\t/* Fall through case !!! */\n+\t\tcase JBmonitorenter:\t/* Fall through case !!! */\n+\t\tcase JBmonitorexit:\t/* Fall through case !!! */\n+\t\tcase JBdup:\t/* Fall through case !!! */\n+\t\tcase JBdupx1:\t/* Fall through case !!! */\n+\t\tcase JBdupx2:\t/* Fall through case !!! */\n+\t\tcase JBdup2:\t/* Fall through case !!! */\n+\t\tcase JBdup2x1:\t/* Fall through case !!! */\n+\t\tcase JBdup2x2:\n+\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, bytecodeOffset[npePC].first, FALSE, npeMsg, isMethodFlag, temps, bytecodeOffset);\n+\t\t\tbreak;\n+\n+\t\tcase JBiastore:\t/* Fall through case !!! */\n+\t\tcase JBlastore:\t/* Fall through case !!! */\n+\t\tcase JBfastore:\t/* Fall through case !!! */\n+\t\tcase JBdastore:\t/* Fall through case !!! */\n+\t\tcase JBbastore:\t/* Fall through case !!! */\n+\t\tcase JBcastore:\t/* Fall through case !!! */\n+\t\tcase JBsastore:\t/* Fall through case !!! */\n+\t\tcase JBaastore: {\n+\t\t\tUDATA bcCausePos2 = bytecodeOffset[npePC].second;\n+\t\t\tUDATA bcCausePos = bytecodeOffset[npePC].first;\n+\n+\t\t\tif ((BYTECODE_BRANCH_TARGET == bcCausePos)\n+\t\t\t\t|| (BYTECODE_BRANCH_TARGET == bcCausePos2)\n+\t\t\t) {\n+\t\t\t\t*npeMsg = NULL;\n+\t\t\t} else {\n+\t\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, bcCausePos, FALSE, npeMsg, isMethodFlag, temps, bytecodeOffset);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBiaload:\t/* Fall through case !!! */\n+\t\tcase JBlaload:\t/* Fall through case !!! */\n+\t\tcase JBfaload:\t/* Fall through case !!! */\n+\t\tcase JBdaload:\t/* Fall through case !!! */\n+\t\tcase JBbaload:\t/* Fall through case !!! */\n+\t\tcase JBcaload:\t/* Fall through case !!! */\n+\t\tcase JBsaload:\t/* Fall through case !!! */\n+\t\tcase JBaaload: {\n+\t\t\tUDATA bcCausePos = bytecodeOffset[npePC].first;\n+\n+\t\t\tconst char* npeMsgObjref = NULL;\n+\t\t\tUDATA aaloadIndexPos = 0;\n+\t\t\tif (BYTECODE_BRANCH_TARGET == bcCausePos) {\n+\t\t\t\tif (!npeFinalFlag) {\n+\t\t\t\t\tnpeMsgObjref = \"<array>\";\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, bcCausePos, FALSE, (char **)&npeMsgObjref, isMethodFlag, temps, bytecodeOffset);\n+\t\t\t}\n+\t\t\taaloadIndexPos = bytecodeOffset[npePC].second;\n+\t\t\tif (npeFinalFlag || (NULL == npeMsgObjref)) {\n+\t\t\t\t*npeMsg = (char *)npeMsgObjref;\n+\t\t\t} else {\n+\t\t\t\tconst char* npeMsgIndex = NULL;\n+\t\t\t\tif (BYTECODE_BRANCH_TARGET == aaloadIndexPos) {\n+\t\t\t\t\tnpeMsgIndex = \"...\";\n+\t\t\t\t} else {\n+\t\t\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, aaloadIndexPos, FALSE, (char **)&npeMsgIndex, isMethodFlag, temps, bytecodeOffset);\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != npeMsgIndex) {\n+\t\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%s[%s]\", npeMsgObjref, npeMsgIndex);\n+\t\t\t\t\t*isMethodFlag = FALSE;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBgetstatic: {\n+\t\t\tUDATA index = PARAM_16(bcCurrentPtr, 1);\n+\t\t\tJ9ROMConstantPoolItem *info = &constantPool[index];\n+\t\t\tJ9UTF8 *className = J9ROMCLASSREF_NAME((J9ROMClassRef *) &constantPool[((J9ROMFieldRef *) info)->classRefCPIndex]);\n+\t\t\tchar *fullyQualifiedClassName = convertToJavaFullyQualifiedName(vmThread, className);\n+\t\t\tJ9UTF8 *fieldName = ((J9UTF8 *) (J9ROMNAMEANDSIGNATURE_NAME(J9ROMFIELDREF_NAMEANDSIGNATURE((J9ROMFieldRef *) info))));\n+\n+\t\t\tif (NULL != fullyQualifiedClassName) {\n+\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%s.%.*s\", fullyQualifiedClassName, J9UTF8_LENGTH(fieldName), J9UTF8_DATA(fieldName));\n+\t\t\t}\n+\t\t\tj9mem_free_memory(fullyQualifiedClassName);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBgetfield: {\n+\t\t\tUDATA bcCausePos = bytecodeOffset[npePC].first;\n+\t\t\tchar *npeMsgObjref = NULL;\n+\t\t\tif (BYTECODE_BRANCH_TARGET != bcCausePos) {\n+\t\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, bcCausePos, FALSE, &npeMsgObjref, isMethodFlag, temps, bytecodeOffset);\n+\t\t\t}\n+\n+\t\t\tif (npeFinalFlag) {\n+\t\t\t\t*npeMsg = npeMsgObjref;\n+\t\t\t} else {\n+\t\t\t\tUDATA index = PARAM_16(bcCurrentPtr, 1);\n+\t\t\t\tJ9ROMConstantPoolItem *info = &constantPool[index];\n+\t\t\t\tJ9UTF8 *fieldName = ((J9UTF8 *) (J9ROMNAMEANDSIGNATURE_NAME(J9ROMFIELDREF_NAMEANDSIGNATURE((J9ROMFieldRef *) info))));\n+\n+\t\t\t\tif (NULL == npeMsgObjref) {\n+\t\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%.*s\", J9UTF8_LENGTH(fieldName), J9UTF8_DATA(fieldName));\n+\t\t\t\t} else {\n+\t\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%s.%.*s\", npeMsgObjref, J9UTF8_LENGTH(fieldName), J9UTF8_DATA(fieldName));\n+\t\t\t\t}\n+\t\t\t\t*isMethodFlag = FALSE;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBputfield: {\n+\t\t\tUDATA bcCausePos = bytecodeOffset[npePC].first;\n+\t\t\tchar *npeMsgObjref = NULL;\n+\n+\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, bcCausePos, FALSE, &npeMsgObjref, isMethodFlag, temps, bytecodeOffset);\n+\t\t\tif (npeFinalFlag || (NULL == npeMsgObjref)) {\n+\t\t\t\t*npeMsg = npeMsgObjref;\n+\t\t\t} else {\n+\t\t\t\tUDATA index = PARAM_16(bcCurrentPtr, 1);\n+\t\t\t\tJ9ROMConstantPoolItem *info = &constantPool[index];\n+\t\t\t\tJ9UTF8 *fieldName = ((J9UTF8 *) (J9ROMNAMEANDSIGNATURE_NAME(J9ROMFIELDREF_NAMEANDSIGNATURE((J9ROMFieldRef *) info))));\n+\n+\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%s.%.*s\", npeMsgObjref, J9UTF8_LENGTH(fieldName), J9UTF8_DATA(fieldName));\n+\t\t\t\tj9mem_free_memory(npeMsgObjref);\n+\t\t\t}\n+\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tdefault:\n+\t\t\tTrc_VM_ComputeNPEMsgAtPC_SkippedBC(vmThread, bcCurrent, npeFinalFlag);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (npeFinalFlag) {\n+\t\t*npeMsg = getCompleteNPEMessage(vmThread, bcCurrentPtr, romClass, *npeMsg, *isMethodFlag);\n+\t}\n+\n+\tTrc_VM_ComputeNPEMsgAtPC_Exit(vmThread, bcCurrent, npePC, npeFinalFlag, *isMethodFlag, *npeMsg);\n+}\n+\n+/**\n+ * Get a fully qualified method name.\n+ *\n+ * Note: the caller is responsible for freeing the returned string if it is not NULL.\n+ *\n+ * @param[in] vmThread current J9VMThread\n+ * @param[in] romClass the romClass containing the method\n+ * @param[in] bcIndex the bytecode byte stream where the method is to be computed\n+ *\n+ * @return a char pointer to a fully qualified method name,\n+ *         NULL if not successful, but keep application exception instead of throwing OOM.\n+ */\n+static char*\n+getFullyQualifiedMethodName(J9VMThread *vmThread, J9ROMClass *romClass, U_8 *bcIndex)\n+{\n+\tUDATA bc = *bcIndex;\n+\tUDATA index = PARAM_16(bcIndex, 1);\n+\tJ9ROMConstantPoolItem *constantPool = J9_ROM_CP_FROM_ROM_CLASS(romClass);\n+\n+\tPORT_ACCESS_FROM_VMC(vmThread);\n+\n+\tTrc_VM_GetFullyQualifiedMethodName_Entry(vmThread, bc, index, bcIndex);\n+\tif (JBinvokestaticsplit == bc) {\n+\t\tindex = *(U_16 *)(J9ROMCLASS_STATICSPLITMETHODREFINDEXES(romClass) + index);\n+\t} else if (JBinvokespecialsplit == bc) {\n+\t\tindex = *(U_16 *)(J9ROMCLASS_SPECIALSPLITMETHODREFINDEXES(romClass) + index);\n+\t}\n+\n+\tJ9ROMMethodRef *info = (J9ROMMethodRef *) &constantPool[index];\n+\tJ9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(info);\n+\tJ9UTF8 *methodName = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n+\tJ9UTF8 *methodSig = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n+\tJ9UTF8 *className = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *) &constantPool[info->classRefCPIndex]);\n+\tchar *fullyQualifiedClassName = convertToJavaFullyQualifiedName(vmThread, className);\n+\tchar *methodSigParameters = convertMethodSignature(vmThread, methodSig);\n+\tchar *result = NULL;\n+\n+\tif ((NULL != fullyQualifiedClassName) && (NULL != methodSigParameters)) {\n+\t\tresult = getMsgWithAllocation(vmThread, \"%s.%.*s%s\",\n+\t\t\tfullyQualifiedClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters);\n+\t}\n+\tj9mem_free_memory(fullyQualifiedClassName);\n+\tj9mem_free_memory(methodSigParameters);\n+\n+\tTrc_VM_GetFullyQualifiedMethodName_Exit(vmThread, index, info, fullyQualifiedClassName, methodSigParameters, result);\n+\treturn result;\n+}\n+\n+/**\n+ * Get a local name, the actual variable name,\n+ * parameter# if the temp wasn't changed, or local# if the temp has been changed.\n+ *\n+ * Note: the caller is responsible for freeing the returned string if it is not NULL.\n+ *\n+ * @param[in] vmThread current J9VMThread\n+ * @param[in] romMethod the romMethod containing the local\n+ * @param[in] localVar the local variable index\n+ * @param[in] bcIndex the bytecode index\n+ * @param[in] temps the location of bytecode temps supplied via liveStack->stackElements\n+ *\n+ * @return a char pointer to a local name, NULL if not successful\n+ */\n+static char*\n+getLocalsName(J9VMThread *vmThread, J9ROMMethod *romMethod, U_16 localVar, UDATA bcIndex, UDATA *temps)\n+{\n+\tJ9MethodDebugInfo *methodInfo = getMethodDebugInfoFromROMMethod(romMethod);\n+\tchar *result = NULL;\n+\tBOOLEAN foundName = FALSE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0"}, "originalPosition": 973}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDEyODA3", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#pullrequestreview-524412807", "createdAt": "2020-11-05T16:00:21Z", "commit": {"oid": "dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNjowMDoyMVrOHuKQ1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNjowMDoyMVrOHuKQ1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE2NDY5NA==", "bodyText": "Comment on the next line please.", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#discussion_r518164694", "createdAt": "2020-11-05T16:00:21Z", "author": {"login": "gacholio"}, "path": "runtime/vm/extendedMessageNPE.cpp", "diffHunk": "@@ -374,30 +519,1493 @@ getCompleteNPEMessage(J9VMThread *vmThread, U_8 *bcCurrentPtr, J9ROMClass *romCl\n \t\t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&constantPool[index];\n \t\t\tJ9ROMNameAndSignature *methodNameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n \t\t\tJ9UTF8 *methodName = J9ROMNAMEANDSIGNATURE_NAME(methodNameAndSig);\n-\t\t\tconst char *VM_NPE_INVOKEMETHOD = \"Cannot invoke \\\"%s.%.*s%s\\\"\";\n-\n \t\t\tJ9UTF8 *definingClassFullQualifiedName = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&constantPool[romMethodRef->classRefCPIndex]);\n-\t\t\tchar *fullyQualifiedDefiningClassName = convertToJavaFullyQualifiedName(vmThread, definingClassFullQualifiedName);\n-\t\t\tchar *methodSigParameters = convertMethodSignature(vmThread, J9ROMNAMEANDSIGNATURE_SIGNATURE(methodNameAndSig));\n+\t\t\tJ9UTF8* methodSig = J9ROMNAMEANDSIGNATURE_SIGNATURE(methodNameAndSig);\n+\t\t\tBOOLEAN npeMsgRequired = TRUE;\n+\n+\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(definingClassFullQualifiedName), J9UTF8_LENGTH(definingClassFullQualifiedName), \"java/lang/NullPointerException\")) {\n+\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(methodName), J9UTF8_LENGTH(methodName), \"<init>\")) {\n+\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(methodSig), J9UTF8_LENGTH(methodSig), \"()V\")) {\n+\t\t\t\t\t\t/* No message generated for new NullPointerException().getMessage() */\n+\t\t\t\t\t\tnpeMsgRequired = FALSE;\n+\t\t\t\t\t\tTrc_VM_GetCompleteNPEMessage_Not_Required(vmThread);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \n-\t\t\tif ((NULL != definingClassFullQualifiedName) && (NULL != methodSigParameters)) {\n-\t\t\t\tmsgLen = j9str_printf(PORTLIB, NULL, 0, VM_NPE_INVOKEMETHOD,\n-\t\t\t\t\tfullyQualifiedDefiningClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters);\n-\t\t\t\tnpeMsg = (char *)j9mem_allocate_memory(msgLen + 1, OMRMEM_CATEGORY_VM);\n-\t\t\t\tj9str_printf(PORTLIB, npeMsg, msgLen, VM_NPE_INVOKEMETHOD,\n-\t\t\t\t\tfullyQualifiedDefiningClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters);\n \t\t\t}\n-\t\t\tj9mem_free_memory(fullyQualifiedDefiningClassName);\n-\t\t\tj9mem_free_memory(methodSigParameters);\n+\t\t\tif (npeMsgRequired) {\n+\t\t\t\tchar *fullyQualifiedClassName = convertToJavaFullyQualifiedName(vmThread, definingClassFullQualifiedName);\n+\t\t\t\tchar *methodSigParameters = convertMethodSignature(vmThread, methodSig);\n+\t\t\t\tif (NULL == npeCauseMsg) {\n+\t\t\t\t\tnpeMsg = getMsgWithAllocation(vmThread, \"Cannot invoke \\\"%s.%.*s%s\\\"\",\n+\t\t\t\t\t\tfullyQualifiedClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters);\n+\t\t\t\t} else {\n+\t\t\t\t\tif (isMethodFlag) {\n+\t\t\t\t\t\tmsgTemplate = \"Cannot invoke \\\"%s.%.*s%s\\\" because the return value of \\\"%s\\\" is null\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tmsgTemplate = \"Cannot invoke \\\"%s.%.*s%s\\\" because \\\"%s\\\" is null\";\n+\t\t\t\t\t}\n+\t\t\t\t\tnpeMsg = getMsgWithAllocation(vmThread, msgTemplate,\n+\t\t\t\t\t\t\tfullyQualifiedClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters, npeCauseMsg);\n+\t\t\t\t}\n+\t\t\t\tj9mem_free_memory(fullyQualifiedClassName);\n+\t\t\t\tj9mem_free_memory(methodSigParameters);\n+\t\t\t}\n \t\t\tbreak;\n \t\t}\n \t\tdefault:\n \t\t\tTrc_VM_GetCompleteNPEMessage_MissedBytecode(vmThread, bcCurrent);\n \t\t}\n \t}\n+\tj9mem_free_memory(npeCauseMsg);\n \tTrc_VM_GetCompleteNPEMessage_Exit(vmThread, npeMsg);\n \n \treturn npeMsg;\n }\n \n+/*\n+ * Initialize npeMsgData with incoming romMethod\n+ * @param[in] npeMsgData - the J9NPEMessageData structure holding romClass/romMethod/npePC\n+ *\n+ * @return IDATA BCV_SUCCESS if it succeeded, BCV_ERR_INTERNAL_ERROR for any unexpected error\n+ */\n+static IDATA\n+initializeNPEMessageData(J9NPEMessageData *npeMsgData)\n+{\n+\tPORT_ACCESS_FROM_VMC(npeMsgData->vmThread);\n+\tJ9ROMMethod *romMethod = npeMsgData->romMethod;\n+\tIDATA result = BCV_SUCCESS;\n+\n+\t/* BCV_TARGET_STACK_HEADER_UDATA_SIZE for pc/stackBase/stackEnd in J9BranchTargetStack and\n+\t * BCV_STACK_OVERFLOW_BUFFER_UDATA_SIZE for late overflow detection of longs/doubles\n+\t */\n+\tnpeMsgData->stackSize = (J9_MAX_STACK_FROM_ROM_METHOD(romMethod)\n+\t\t\t\t\t\t\t+ J9_ARG_COUNT_FROM_ROM_METHOD(romMethod)\n+\t\t\t\t\t\t\t+ J9_TEMP_COUNT_FROM_ROM_METHOD(romMethod)\n+\t\t\t\t\t\t\t+ BCV_TARGET_STACK_HEADER_UDATA_SIZE\n+\t\t\t\t\t\t\t+ BCV_STACK_OVERFLOW_BUFFER_UDATA_SIZE) * sizeof(UDATA);\n+\tALLOC_BUFFER(npeMsgData->liveStack, npeMsgData->stackSize, (J9BranchTargetStack *));\n+\n+\tUDATA bytecodeSize = J9_BYTECODE_SIZE_FROM_ROM_METHOD(romMethod);\n+\tUDATA bytecodeBufferSize = bytecodeSize * sizeof(U_32) * 2;\n+\tALLOC_BUFFER(npeMsgData->bytecodeOffset, bytecodeBufferSize, (J9BytecodeOffset *));\n+\tALLOC_BUFFER(npeMsgData->bytecodeMap, bytecodeBufferSize, (U_32 *));\n+\n+\tresult = buildBranchMap(npeMsgData);\n+\tif (result >= 0) {\n+\t\tJ9BranchTargetStack *liveStack = NULL;\n+\n+\t\tif (result > 0) {\n+\t\t\tnpeMsgData->stackMapsCount = result;\n+\n+\t\t\tUDATA stackMapsSize = (npeMsgData->stackSize) * (npeMsgData->stackMapsCount);\n+\t\t\tALLOC_BUFFER(npeMsgData->stackMaps, stackMapsSize, (UDATA *));\n+\t\t\tUDATA mapIndex = 0;\n+\t\t\tUDATA j = 0;\n+\t\t\tU_32 *bytecodeMap = npeMsgData->bytecodeMap;\n+\n+\t\t\tliveStack = NPEMSG_FIRST_STACK ();\n+\t\t\tfor (j = 0; j < bytecodeSize; j++) {\n+\t\t\t\tif ((bytecodeMap)[j] & BRANCH_TARGET) {\n+\t\t\t\t\tliveStack->pc = j;\t\t/* offset of the branch target */\n+\t\t\t\t\tliveStack->stackBaseIndex = -1;\n+\t\t\t\t\tliveStack->stackTopIndex = -1;\n+\t\t\t\t\tliveStack = NPEMSG_NEXT_STACK(liveStack);\n+\t\t\t\t\t(bytecodeMap)[j] |= (mapIndex << BRANCH_INDEX_SHIFT); /* adding the stack # */\n+\t\t\t\t\tmapIndex++;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tUDATA unwalkedQueueSize = (npeMsgData->stackMapsCount + 1) * sizeof(UDATA);\n+\t\t\tALLOC_BUFFER(npeMsgData->unwalkedQueue, unwalkedQueueSize, (UDATA *));\n+\t\t}\n+\n+\t\tliveStack = (J9BranchTargetStack *)npeMsgData->liveStack;\n+\t\tUDATA *stackTop = &(liveStack->stackElements[0]);\n+\t\tinitStackFromMethodSignature(npeMsgData->vmThread, romMethod, &stackTop);\n+\t\tSAVE_STACKTOP(liveStack, stackTop);\n+\t\tliveStack->stackBaseIndex = liveStack->stackTopIndex;\n+\t\tresult = BCV_SUCCESS;\n+\t}\n+\n+\treturn result;\n+}\n+\n+/*\n+ * Initialize bytecodeMap with BRANCH_TARGET or BRANCH_EXCEPTION_START\n+ * @param[in] npeMsgData - the J9NPEMessageData structure holding romClass/romMethod/npePC\n+ *\n+ * @return IDATA the number of branch targets and exception handler starts\n+ *         BCV_ERR_INTERNAL_ERROR for any unexpected error\n+ */\n+static IDATA\n+buildBranchMap(J9NPEMessageData *npeMsgData)\n+{\n+\tJ9ROMMethod *romMethod = npeMsgData->romMethod;\n+\tU_32 *bytecodeMap = npeMsgData->bytecodeMap;\n+\tUDATA count = 0;\n+\tU_8 *bcStart = J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\tU_8 *bcIndex = bcStart;\n+\tU_8 *bcEnd = bcStart + J9_BYTECODE_SIZE_FROM_ROM_METHOD(romMethod);\n+\n+\twhile (bcIndex < bcEnd) {\n+\t\tIDATA start = 0;\n+\t\tI_32 longBranch = 0;\n+\t\tUDATA bc = *bcIndex;\n+\t\t/* high nybble = branch action, low nybble = instruction size */\n+\t\tUDATA size = J9JavaInstructionSizeAndBranchActionTable[bc];\n+\t\tif (0 == size) {\n+\t\t\treturn BCV_ERR_INTERNAL_ERROR;\n+\t\t}\n+\n+\t\tswitch (size >> 4) { /* branch action */\n+\t\tcase 5: { /* switches */\n+\t\t\tstart = bcIndex - bcStart;\n+\t\t\tIDATA pc = (start + 4) & ~3;\n+\t\t\tbcIndex = bcStart + pc;\n+\t\t\tlongBranch = (I_32) PARAM_32(bcIndex, 0);\n+\t\t\tbcIndex += 4;\n+\t\t\tif (0 == bytecodeMap[start + longBranch]) {\n+\t\t\t\tbytecodeMap[start + longBranch] = BRANCH_TARGET;\n+\t\t\t\tcount++;\n+\t\t\t}\n+\n+\t\t\tUDATA npairs = 0;\n+\t\t\tIDATA pcs = 0;\n+\t\t\tIDATA low = (I_32) PARAM_32(bcIndex, 0);\n+\t\t\tbcIndex += 4;\n+\t\t\tif (JBtableswitch == bc) {\n+\t\t\t\tIDATA high = (I_32) PARAM_32(bcIndex, 0);\n+\t\t\t\tbcIndex += 4;\n+\t\t\t\tnpairs = (UDATA) (high - low + 1);\n+\t\t\t\tpcs = 0;\n+\t\t\t} else {\n+\t\t\t\tnpairs = (UDATA) low;\n+\t\t\t\tpcs = 4;\n+\t\t\t}\n+\n+\t\t\tUDATA temp = 0;\n+\t\t\tfor (temp = 0; temp < npairs; temp++) {\n+\t\t\t\tbcIndex += pcs;\n+\t\t\t\tlongBranch = (I_32) PARAM_32(bcIndex, 0);\n+\t\t\t\tbcIndex += 4;\n+\t\t\t\tif (0 == bytecodeMap[start + longBranch]) {\n+\t\t\t\t\tbytecodeMap[start + longBranch] = BRANCH_TARGET;\n+\t\t\t\t\tcount++;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tcase 2: /* gotos */\n+\t\t\tif (JBgotow == bc) {\n+\t\t\t\tstart = bcIndex - bcStart;\n+\t\t\t\tlongBranch = (I_32) PARAM_32(bcIndex, 1);\n+\t\t\t\tif (0 == bytecodeMap[start + longBranch]) {\n+\t\t\t\t\tbytecodeMap[start + longBranch] = BRANCH_TARGET;\n+\t\t\t\t\tcount++;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t} /* fall through for JBgoto */\n+\n+\t\tcase 1: /* ifs */\n+\t\t\tI_16 shortBranch = (I_16) PARAM_16(bcIndex, 1);\n+\t\t\tstart = bcIndex - bcStart;\n+\t\t\tif (0 == bytecodeMap[start + shortBranch]) {\n+\t\t\t\tbytecodeMap[start + shortBranch] = BRANCH_TARGET;\n+\t\t\t\tcount++;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tbcIndex += size & 7;\n+\t}\n+\n+\t/* need to walk exceptions as well, since they are branch targets */\n+\tif (romMethod->modifiers & J9AccMethodHasExceptionInfo) {\n+\t\tJ9ExceptionInfo *exceptionData = J9_EXCEPTION_DATA_FROM_ROM_METHOD(romMethod);\n+\t\tJ9ExceptionHandler *handler = NULL;\n+\n+\t\tif (exceptionData->catchCount) {\n+\t\t\tUDATA temp = 0;\n+\t\t\tIDATA pc = 0;\n+\t\t\tIDATA pcs = 0;\n+\n+\t\t\thandler = J9EXCEPTIONINFO_HANDLERS(exceptionData);\n+\t\t\tfor (temp = 0; temp < (U_32) exceptionData->catchCount; temp++) {\n+\t\t\t\tpc = (IDATA) handler->startPC;\n+\t\t\t\tpcs = (IDATA) handler->handlerPC;\n+\t\t\t\t/* Avoid re-walking a handler that handles itself */\n+\t\t\t\tif (pc != pcs) {\n+\t\t\t\t\tbytecodeMap[pc] |= BRANCH_EXCEPTION_START;\n+\t\t\t\t}\n+\t\t\t\tif (0 == (bytecodeMap[pcs] & BRANCH_TARGET)) {\n+\t\t\t\t\tbytecodeMap[pcs] |= BRANCH_TARGET;\n+\t\t\t\t\tcount++;\n+\t\t\t\t}\n+\t\t\t\thandler++;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn count;\n+}\n+\n+/**\n+ * Compute NPE message at npePC supplied. This can be invoked recursively.\n+ *\n+ * @param[in] vmThread The current J9VMThread\n+ * @param[in] bcCurrentPtr The pointer to the bytecode being executed and caused the NPE\n+ * @param[in] romMethod The romMethod of the bytecode\n+ * @param[in] romClass The romClass of the bytecode\n+ * @param[in] npePC The bytecode offset where the NPE message is to be generated\n+ * @param[in] npeFinalFlag The flag indicates if getCompleteNPEMessage() is invoked\n+ * @param[in,out] npeMsg An extended NPE message generated so far\n+ * @param[in,out] isMethodFlag The flag indicates if \"the return value of\" should be added into the message\n+ * @param[in] temps The location of bytecode temps supplied via liveStack->stackElements\n+ * @param[in] bytecodeOffset The array storing the bytecode offset\n+ * @param[in] bytecodeOffset The cause of NPE\n+ */\n+static void\n+computeNPEMsgAtPC(J9VMThread *vmThread, J9ROMMethod *romMethod, J9ROMClass *romClass, UDATA npePC,\n+\t\tBOOLEAN npeFinalFlag, char **npeMsg, BOOLEAN *isMethodFlag, UDATA *temps, J9BytecodeOffset *bytecodeOffset)\n+{\n+\tJ9ROMConstantPoolItem *constantPool = J9_ROM_CP_FROM_ROM_CLASS(romClass);\n+\tU_8 *code = J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\tU_8 *bcCurrentPtr = code + npePC;\n+\tU_8 bcCurrent = *bcCurrentPtr;\n+#ifdef J9VM_ENV_LITTLE_ENDIAN\n+//\tUDATA bigEndian = BCT_LittleEndianOutput;\n+#else\n+//\tUDATA bigEndian = BCT_BigEndianOutput;\n+#endif\n+\tPORT_ACCESS_FROM_VMC(vmThread);\n+\n+\tTrc_VM_ComputeNPEMsgAtPC_Entry(vmThread, romClass, romMethod, temps, bytecodeOffset, bcCurrent, npePC, npeFinalFlag, *isMethodFlag, *npeMsg);\n+\tif ((bcCurrent >= JBiconstm1) && (bcCurrent <= JBdconst1)) {\n+\t\t/*\n+\t\t * JBiconstm1, JBiconst0, JBiconst1, JBiconst2, JBiconst3, JBiconst4, JBiconst5\n+\t\t * JBlconst0, JBlconst1\n+\t\t * JBfconst0, JBfconst1, JBfconst2\n+\t\t * JBdconst0, JBdconst1\n+\t\t */\n+\t\tI_8 constNum = 0;\n+\t\tBOOLEAN missedBCFlag = FALSE;\n+\n+\t\tif (JBiconstm1 == bcCurrent) {\n+\t\t\tconstNum = -1;\n+\t\t} else {\n+\t\t\tif ((bcCurrent >= JBiconst0) && (bcCurrent <= JBiconst5)) {\n+\t\t\t\tconstNum = bcCurrent - 3; /* iconst_0 = 3 (0x3) */\n+\t\t\t} else if ((JBlconst0 == bcCurrent) || (JBfconst0 == bcCurrent) || (JBdconst0 == bcCurrent)) {\n+\t\t\t\tconstNum = 0;\n+\t\t\t} else if ((JBlconst1 == bcCurrent) || (JBfconst1 == bcCurrent) || (JBdconst1 == bcCurrent)) {\n+\t\t\t\tconstNum = 1;\n+\t\t\t} else if (JBfconst2 == bcCurrent) {\n+\t\t\t\tconstNum = 2;\n+\t\t\t} else {\n+\t\t\t\tmissedBCFlag = TRUE;\n+\t\t\t\tTrc_VM_ComputeNPEMsgAtPC_Constants_UnexpectedBC(vmThread, bcCurrent);\n+\t\t\t}\n+\t\t}\n+\t\tif (!missedBCFlag) {\n+\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%d\", constNum);\n+\t\t}\n+\t} else if (((bcCurrent >= JBiadd) && (bcCurrent <= JBlxor))\n+\t\t|| ((bcCurrent >= JBlcmp) && (bcCurrent <= JBdcmpg))\n+\t) {\n+\t\t/* JBiadd, JBladd, JBfadd, JBdadd, JBisub, JBlsub, JBfsub, JBdsub, JBimul, JBlmul, JBfmul, JBdmul\n+\t\t * JBidiv, JBldiv, JBfdiv, JBddiv, JBirem, JBlrem, JBfrem, JBdrem, JBineg, JBlneg, JBfneg, JBdneg\n+\t\t * JBishl, JBlshl, JBishr, JBlshr, JBiushr, JBlushr, JBiand, JBland, JBior, JBlor, JBixor, JBlxor\n+\t\t *\n+\t\t * JBlcmp, JBfcmpl, JBfcmpg, JBdcmpl, JBdcmpg\n+\t\t */\n+\t\t*npeMsg = getMsgWithAllocation(vmThread, \"...\");\n+\t} else {\n+\t\tswitch (bcCurrent) {\n+\t\tcase JBaconstnull:\n+\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"null\");\n+\t\t\tbreak;\n+\n+\t\tcase JBbipush:\n+\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%lu\", *(bcCurrentPtr + 1));\n+\t\t\tbreak;\n+\n+\t\tcase JBsipush: {\n+\t\t\tUDATA sipushIndex = 0;\n+\t\t\tU_8 *tmpbcPtr = bcCurrentPtr + 1;\n+\n+\t\t\tGETNEXT_U16(sipushIndex, tmpbcPtr);\n+\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%lu\", sipushIndex);\n+\t\t\tbreak;\n+\t\t}\n+\t\t\n+\t\tcase JBldc:\t\t/* Fall through case !!! */\n+\t\tcase JBldcw:\t/* Fall through case !!! */\n+\t\tcase JBldc2dw:\t/* Fall through case !!! */\n+\t\tcase JBldc2lw: {\n+\t\t\tUDATA ldcIndex = 0;\n+\t\t\tU_8 *tmpbcPtr = bcCurrentPtr + 1;\n+\n+\t\t\tif (JBldc == bcCurrent) {\n+\t\t\t\tGETNEXT_U8(ldcIndex, tmpbcPtr);\n+\t\t\t} else if (JBldcw == bcCurrent) {\n+\t\t\t\tGETNEXT_U16(ldcIndex, tmpbcPtr);\n+\t\t\t} else {\n+\t\t\t\t/* bcCurrent is JBldc2lw or JBldc2dw */\n+\t\t\t\tGETNEXT_U8(ldcIndex, tmpbcPtr);\n+\t\t\t}\n+\n+\t\t\tJ9ROMConstantPoolItem *info = &constantPool[ldcIndex];\n+\t\t\tif (BCT_J9DescriptionCpTypeScalar == ((J9ROMSingleSlotConstantRef *) info)->cpType) {\n+\t\t\t\t/* this is a float/int constant */\n+\t\t\t\tldcIndex = ((J9ROMSingleSlotConstantRef *) info)->data;\n+\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%lu\", ldcIndex);\n+\t\t\t} else {\n+\t\t\t\t Trc_VM_ComputeNPEMsgAtPC_NotScalarType(vmThread, romClass, romMethod, constantPool, ldcIndex, info, ((J9ROMSingleSlotConstantRef *) info)->cpType);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBanewarray: {\n+\t\t\tUDATA index = PARAM_16(bcCurrentPtr, 1);\n+\t\t\tJ9ROMConstantPoolItem *info = &constantPool[index];\n+\t\t\tJ9UTF8 *className = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *) info);\n+\t\t\tchar *fullyQualifiedClassName = convertToJavaFullyQualifiedName(vmThread, className);\n+\n+\t\t\t*npeMsg = getMsgWithAllocation(vmThread, fullyQualifiedClassName);\n+\t\t\tj9mem_free_memory(fullyQualifiedClassName);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBinvokeinterface2:\t/* Fall through case !!! */\n+\t\tcase JBinvokevirtual:\t\t/* Fall through case !!! */\n+\t\tcase JBinvokespecial:\t\t/* Fall through case !!! */\n+\t\tcase JBinvokeinterface:\t\t/* Fall through case !!! */\n+\t\tcase JBinvokestatic: {\n+\t\t\tif (npeFinalFlag) {\n+\t\t\t\tUDATA objectrefPos = bytecodeOffset[npePC].first;\n+\n+\t\t\t\tif (BYTECODE_BRANCH_TARGET == objectrefPos) {\n+\t\t\t\t\t*npeMsg = NULL;\n+\t\t\t\t} else {\n+\t\t\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, objectrefPos, FALSE, npeMsg, isMethodFlag, temps, bytecodeOffset);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tU_8 *bcPtrTemp = (JBinvokeinterface2 == bcCurrent) ? bcCurrentPtr + 2 : bcCurrentPtr;\n+\t\t\t\tchar *methodName = getFullyQualifiedMethodName(vmThread, romClass, bcPtrTemp);\n+\n+\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, methodName);\n+\t\t\t\tj9mem_free_memory(methodName);\n+\t\t\t\t*isMethodFlag = TRUE;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBiload0:\t/* Fall through case !!! */\n+\t\tcase JBiload1:\t/* Fall through case !!! */\n+\t\tcase JBiload2:\t/* Fall through case !!! */\n+\t\tcase JBiload3:\t/* Fall through case !!! */\n+\t\tcase JBlload0:\t/* Fall through case !!! */\n+\t\tcase JBlload1:\t/* Fall through case !!! */\n+\t\tcase JBlload2:\t/* Fall through case !!! */\n+\t\tcase JBlload3:\t/* Fall through case !!! */\n+\t\tcase JBfload0:\t/* Fall through case !!! */\n+\t\tcase JBfload1:\t/* Fall through case !!! */\n+\t\tcase JBfload2:\t/* Fall through case !!! */\n+\t\tcase JBfload3:\t/* Fall through case !!! */\n+\t\tcase JBdload0:\t/* Fall through case !!! */\n+\t\tcase JBdload1:\t/* Fall through case !!! */\n+\t\tcase JBdload2:\t/* Fall through case !!! */\n+\t\tcase JBdload3:\t/* Fall through case !!! */\n+\t\tcase JBaload0:\t/* Fall through case !!! */\n+\t\tcase JBaload1:\t/* Fall through case !!! */\n+\t\tcase JBaload2:\t/* Fall through case !!! */\n+\t\tcase JBaload3:\t/* Fall through case !!! */\n+\t\tcase JBaload0getfield: {\n+\t\t\tU_16 localVar = 0;\n+\t\t\tif (bcCurrent >= JBiload0 && bcCurrent <= JBiload3) {\n+\t\t\t\tlocalVar = bcCurrent - JBiload0;\n+\t\t\t} else if (bcCurrent >= JBlload0 && bcCurrent <= JBlload3) {\n+\t\t\t\tlocalVar = bcCurrent - JBlload0;\n+\t\t\t} else if (bcCurrent >= JBfload0 && bcCurrent <= JBfload3) {\n+\t\t\t\tlocalVar = bcCurrent - JBfload0;\n+\t\t\t} else if (bcCurrent >= JBdload0 && bcCurrent <= JBdload3) {\n+\t\t\t\tlocalVar = bcCurrent - JBdload0;\n+\t\t\t} else if (bcCurrent >= JBaload0 && bcCurrent <= JBaload3) {\n+\t\t\t\tlocalVar = bcCurrent - JBaload0;\n+\t\t\t} else if (JBaload0getfield == bcCurrent) {\n+\t\t\t\tlocalVar = 0;\n+\t\t\t}\n+\t\t\t*npeMsg = getLocalsName(vmThread, romMethod, localVar, npePC, temps);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBiload:\t/* Fall through case !!! */\n+\t\tcase JBlload:\t/* Fall through case !!! */\n+\t\tcase JBfload:\t/* Fall through case !!! */\n+\t\tcase JBdload:\t/* Fall through case !!! */\n+\t\tcase JBaload: {\n+\t\t\t/* The index is an unsigned byte that must be an index into the local variable array of the current frame (\u00a72.6).\n+\t\t\t * The local variable at index must contain a reference.\n+\t\t\t */\n+\t\t\t*npeMsg = getLocalsName(vmThread, romMethod, *(bcCurrentPtr + 1), npePC, temps);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBiloadw:\t/* Fall through case !!! */\n+\t\tcase JBlloadw:\t/* Fall through case !!! */\n+\t\tcase JBfloadw:\t/* Fall through case !!! */\n+\t\tcase JBdloadw:\t/* Fall through case !!! */\n+\t\tcase JBaloadw: {\n+\t\t\tU_16 localVar = 0;\n+\t\t\tU_8 *tmpbcPtr = bcCurrentPtr + 1;\n+\n+\t\t\tGETNEXT_U16(localVar, tmpbcPtr);\n+\t\t\t*npeMsg = getLocalsName(vmThread, romMethod, localVar, npePC, temps);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBi2l:\t/* Fall through case !!! */\n+\t\tcase JBi2f:\t/* Fall through case !!! */\n+\t\tcase JBi2d:\t/* Fall through case !!! */\n+\t\tcase JBl2i:\t/* Fall through case !!! */\n+\t\tcase JBl2f:\t/* Fall through case !!! */\n+\t\tcase JBl2d:\t/* Fall through case !!! */\n+\t\tcase JBf2i:\t/* Fall through case !!! */\n+\t\tcase JBf2l:\t/* Fall through case !!! */\n+\t\tcase JBf2d:\t/* Fall through case !!! */\n+\t\tcase JBd2i:\t/* Fall through case !!! */\n+\t\tcase JBd2l:\t/* Fall through case !!! */\n+\t\tcase JBd2f:\t/* Fall through case !!! */\n+\t\tcase JBi2b:\t/* Fall through case !!! */\n+\t\tcase JBi2c:\t/* Fall through case !!! */\n+\t\tcase JBi2s:\t/* Fall through case !!! */\n+\t\tcase JBarraylength:\t/* Fall through case !!! */\n+\t\tcase JBathrow:\t/* Fall through case !!! */\n+\t\tcase JBmonitorenter:\t/* Fall through case !!! */\n+\t\tcase JBmonitorexit:\t/* Fall through case !!! */\n+\t\tcase JBdup:\t/* Fall through case !!! */\n+\t\tcase JBdupx1:\t/* Fall through case !!! */\n+\t\tcase JBdupx2:\t/* Fall through case !!! */\n+\t\tcase JBdup2:\t/* Fall through case !!! */\n+\t\tcase JBdup2x1:\t/* Fall through case !!! */\n+\t\tcase JBdup2x2:\n+\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, bytecodeOffset[npePC].first, FALSE, npeMsg, isMethodFlag, temps, bytecodeOffset);\n+\t\t\tbreak;\n+\n+\t\tcase JBiastore:\t/* Fall through case !!! */\n+\t\tcase JBlastore:\t/* Fall through case !!! */\n+\t\tcase JBfastore:\t/* Fall through case !!! */\n+\t\tcase JBdastore:\t/* Fall through case !!! */\n+\t\tcase JBbastore:\t/* Fall through case !!! */\n+\t\tcase JBcastore:\t/* Fall through case !!! */\n+\t\tcase JBsastore:\t/* Fall through case !!! */\n+\t\tcase JBaastore: {\n+\t\t\tUDATA bcCausePos2 = bytecodeOffset[npePC].second;\n+\t\t\tUDATA bcCausePos = bytecodeOffset[npePC].first;\n+\n+\t\t\tif ((BYTECODE_BRANCH_TARGET == bcCausePos)\n+\t\t\t\t|| (BYTECODE_BRANCH_TARGET == bcCausePos2)\n+\t\t\t) {\n+\t\t\t\t*npeMsg = NULL;\n+\t\t\t} else {\n+\t\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, bcCausePos, FALSE, npeMsg, isMethodFlag, temps, bytecodeOffset);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBiaload:\t/* Fall through case !!! */\n+\t\tcase JBlaload:\t/* Fall through case !!! */\n+\t\tcase JBfaload:\t/* Fall through case !!! */\n+\t\tcase JBdaload:\t/* Fall through case !!! */\n+\t\tcase JBbaload:\t/* Fall through case !!! */\n+\t\tcase JBcaload:\t/* Fall through case !!! */\n+\t\tcase JBsaload:\t/* Fall through case !!! */\n+\t\tcase JBaaload: {\n+\t\t\tUDATA bcCausePos = bytecodeOffset[npePC].first;\n+\n+\t\t\tconst char* npeMsgObjref = NULL;\n+\t\t\tUDATA aaloadIndexPos = 0;\n+\t\t\tif (BYTECODE_BRANCH_TARGET == bcCausePos) {\n+\t\t\t\tif (!npeFinalFlag) {\n+\t\t\t\t\tnpeMsgObjref = \"<array>\";\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, bcCausePos, FALSE, (char **)&npeMsgObjref, isMethodFlag, temps, bytecodeOffset);\n+\t\t\t}\n+\t\t\taaloadIndexPos = bytecodeOffset[npePC].second;\n+\t\t\tif (npeFinalFlag || (NULL == npeMsgObjref)) {\n+\t\t\t\t*npeMsg = (char *)npeMsgObjref;\n+\t\t\t} else {\n+\t\t\t\tconst char* npeMsgIndex = NULL;\n+\t\t\t\tif (BYTECODE_BRANCH_TARGET == aaloadIndexPos) {\n+\t\t\t\t\tnpeMsgIndex = \"...\";\n+\t\t\t\t} else {\n+\t\t\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, aaloadIndexPos, FALSE, (char **)&npeMsgIndex, isMethodFlag, temps, bytecodeOffset);\n+\t\t\t\t}\n+\n+\t\t\t\tif (NULL != npeMsgIndex) {\n+\t\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%s[%s]\", npeMsgObjref, npeMsgIndex);\n+\t\t\t\t\t*isMethodFlag = FALSE;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBgetstatic: {\n+\t\t\tUDATA index = PARAM_16(bcCurrentPtr, 1);\n+\t\t\tJ9ROMConstantPoolItem *info = &constantPool[index];\n+\t\t\tJ9UTF8 *className = J9ROMCLASSREF_NAME((J9ROMClassRef *) &constantPool[((J9ROMFieldRef *) info)->classRefCPIndex]);\n+\t\t\tchar *fullyQualifiedClassName = convertToJavaFullyQualifiedName(vmThread, className);\n+\t\t\tJ9UTF8 *fieldName = ((J9UTF8 *) (J9ROMNAMEANDSIGNATURE_NAME(J9ROMFIELDREF_NAMEANDSIGNATURE((J9ROMFieldRef *) info))));\n+\n+\t\t\tif (NULL != fullyQualifiedClassName) {\n+\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%s.%.*s\", fullyQualifiedClassName, J9UTF8_LENGTH(fieldName), J9UTF8_DATA(fieldName));\n+\t\t\t}\n+\t\t\tj9mem_free_memory(fullyQualifiedClassName);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBgetfield: {\n+\t\t\tUDATA bcCausePos = bytecodeOffset[npePC].first;\n+\t\t\tchar *npeMsgObjref = NULL;\n+\t\t\tif (BYTECODE_BRANCH_TARGET != bcCausePos) {\n+\t\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, bcCausePos, FALSE, &npeMsgObjref, isMethodFlag, temps, bytecodeOffset);\n+\t\t\t}\n+\n+\t\t\tif (npeFinalFlag) {\n+\t\t\t\t*npeMsg = npeMsgObjref;\n+\t\t\t} else {\n+\t\t\t\tUDATA index = PARAM_16(bcCurrentPtr, 1);\n+\t\t\t\tJ9ROMConstantPoolItem *info = &constantPool[index];\n+\t\t\t\tJ9UTF8 *fieldName = ((J9UTF8 *) (J9ROMNAMEANDSIGNATURE_NAME(J9ROMFIELDREF_NAMEANDSIGNATURE((J9ROMFieldRef *) info))));\n+\n+\t\t\t\tif (NULL == npeMsgObjref) {\n+\t\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%.*s\", J9UTF8_LENGTH(fieldName), J9UTF8_DATA(fieldName));\n+\t\t\t\t} else {\n+\t\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%s.%.*s\", npeMsgObjref, J9UTF8_LENGTH(fieldName), J9UTF8_DATA(fieldName));\n+\t\t\t\t}\n+\t\t\t\t*isMethodFlag = FALSE;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase JBputfield: {\n+\t\t\tUDATA bcCausePos = bytecodeOffset[npePC].first;\n+\t\t\tchar *npeMsgObjref = NULL;\n+\n+\t\t\tcomputeNPEMsgAtPC(vmThread, romMethod, romClass, bcCausePos, FALSE, &npeMsgObjref, isMethodFlag, temps, bytecodeOffset);\n+\t\t\tif (npeFinalFlag || (NULL == npeMsgObjref)) {\n+\t\t\t\t*npeMsg = npeMsgObjref;\n+\t\t\t} else {\n+\t\t\t\tUDATA index = PARAM_16(bcCurrentPtr, 1);\n+\t\t\t\tJ9ROMConstantPoolItem *info = &constantPool[index];\n+\t\t\t\tJ9UTF8 *fieldName = ((J9UTF8 *) (J9ROMNAMEANDSIGNATURE_NAME(J9ROMFIELDREF_NAMEANDSIGNATURE((J9ROMFieldRef *) info))));\n+\n+\t\t\t\t*npeMsg = getMsgWithAllocation(vmThread, \"%s.%.*s\", npeMsgObjref, J9UTF8_LENGTH(fieldName), J9UTF8_DATA(fieldName));\n+\t\t\t\tj9mem_free_memory(npeMsgObjref);\n+\t\t\t}\n+\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tdefault:\n+\t\t\tTrc_VM_ComputeNPEMsgAtPC_SkippedBC(vmThread, bcCurrent, npeFinalFlag);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (npeFinalFlag) {\n+\t\t*npeMsg = getCompleteNPEMessage(vmThread, bcCurrentPtr, romClass, *npeMsg, *isMethodFlag);\n+\t}\n+\n+\tTrc_VM_ComputeNPEMsgAtPC_Exit(vmThread, bcCurrent, npePC, npeFinalFlag, *isMethodFlag, *npeMsg);\n+}\n+\n+/**\n+ * Get a fully qualified method name.\n+ *\n+ * Note: the caller is responsible for freeing the returned string if it is not NULL.\n+ *\n+ * @param[in] vmThread current J9VMThread\n+ * @param[in] romClass the romClass containing the method\n+ * @param[in] bcIndex the bytecode byte stream where the method is to be computed\n+ *\n+ * @return a char pointer to a fully qualified method name,\n+ *         NULL if not successful, but keep application exception instead of throwing OOM.\n+ */\n+static char*\n+getFullyQualifiedMethodName(J9VMThread *vmThread, J9ROMClass *romClass, U_8 *bcIndex)\n+{\n+\tUDATA bc = *bcIndex;\n+\tUDATA index = PARAM_16(bcIndex, 1);\n+\tJ9ROMConstantPoolItem *constantPool = J9_ROM_CP_FROM_ROM_CLASS(romClass);\n+\n+\tPORT_ACCESS_FROM_VMC(vmThread);\n+\n+\tTrc_VM_GetFullyQualifiedMethodName_Entry(vmThread, bc, index, bcIndex);\n+\tif (JBinvokestaticsplit == bc) {\n+\t\tindex = *(U_16 *)(J9ROMCLASS_STATICSPLITMETHODREFINDEXES(romClass) + index);\n+\t} else if (JBinvokespecialsplit == bc) {\n+\t\tindex = *(U_16 *)(J9ROMCLASS_SPECIALSPLITMETHODREFINDEXES(romClass) + index);\n+\t}\n+\n+\tJ9ROMMethodRef *info = (J9ROMMethodRef *) &constantPool[index];\n+\tJ9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(info);\n+\tJ9UTF8 *methodName = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n+\tJ9UTF8 *methodSig = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n+\tJ9UTF8 *className = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *) &constantPool[info->classRefCPIndex]);\n+\tchar *fullyQualifiedClassName = convertToJavaFullyQualifiedName(vmThread, className);\n+\tchar *methodSigParameters = convertMethodSignature(vmThread, methodSig);\n+\tchar *result = NULL;\n+\n+\tif ((NULL != fullyQualifiedClassName) && (NULL != methodSigParameters)) {\n+\t\tresult = getMsgWithAllocation(vmThread, \"%s.%.*s%s\",\n+\t\t\tfullyQualifiedClassName, J9UTF8_LENGTH(methodName), J9UTF8_DATA(methodName), methodSigParameters);\n+\t}\n+\tj9mem_free_memory(fullyQualifiedClassName);\n+\tj9mem_free_memory(methodSigParameters);\n+\n+\tTrc_VM_GetFullyQualifiedMethodName_Exit(vmThread, index, info, fullyQualifiedClassName, methodSigParameters, result);\n+\treturn result;\n+}\n+\n+/**\n+ * Get a local name, the actual variable name,\n+ * parameter# if the temp wasn't changed, or local# if the temp has been changed.\n+ *\n+ * Note: the caller is responsible for freeing the returned string if it is not NULL.\n+ *\n+ * @param[in] vmThread current J9VMThread\n+ * @param[in] romMethod the romMethod containing the local\n+ * @param[in] localVar the local variable index\n+ * @param[in] bcIndex the bytecode index\n+ * @param[in] temps the location of bytecode temps supplied via liveStack->stackElements\n+ *\n+ * @return a char pointer to a local name, NULL if not successful\n+ */\n+static char*\n+getLocalsName(J9VMThread *vmThread, J9ROMMethod *romMethod, U_16 localVar, UDATA bcIndex, UDATA *temps)\n+{\n+\tJ9MethodDebugInfo *methodInfo = getMethodDebugInfoFromROMMethod(romMethod);\n+\tchar *result = NULL;\n+\tBOOLEAN foundName = FALSE;\n+\n+\tif (NULL != methodInfo) {\n+\t\tJ9VariableInfoWalkState state = {0};\n+\t\tJ9VariableInfoValues *values = variableInfoStartDo(methodInfo, &state);\n+\n+\t\twhile (NULL != values) {\n+\t\t\tif ((values->slotNumber == localVar)\n+\t\t\t\t&& (bcIndex >= values->startVisibility)\n+\t\t\t\t&& (bcIndex < (values->startVisibility + values->visibilityLength))\n+\t\t\t) {\n+\t\t\t\tif ((NULL != values->signature) && (NULL != values->name)) {\n+\t\t\t\t\tresult = getMsgWithAllocation(vmThread, \"%.*s\", J9UTF8_LENGTH(values->name), J9UTF8_DATA(values->name));\n+\t\t\t\t\tfoundName = TRUE;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tvalues = variableInfoNextDo(&state);\n+\t\t}\n+\t}\n+\n+\tif (!foundName) {\n+\t\t/* debug info not available */\n+\t\tif ((0 == localVar)\n+\t\t\t&& !(romMethod->modifiers & J9AccStatic)\n+\t\t) {\n+\t\t\tresult = getMsgWithAllocation(vmThread, \"this\");\n+\t\t} else {\n+\t\t\tUDATA temp = temps[localVar];\n+\t\t\tif (BYTECODE_TEMP_CHANGED == temp) {\n+\t\t\t\t/* there was a change to the temp, use <local%d> instead */\n+\t\t\t\tresult = getMsgWithAllocation(vmThread, \"<local%d>\", localVar);\n+\t\t\t} else {\n+\t\t\t\t/* there was no change to the temp, use <parameter%d>, and the number was saved within temps[localVar] */\n+\t\t\t\tTrc_VM_GetLocalsName_LocalVar(vmThread, localVar, temps[localVar]);\n+\t\t\t\tresult = getMsgWithAllocation(vmThread, \"<parameter%d>\", temp);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tTrc_VM_GetLocalsName_Exit(vmThread, result, localVar, bcIndex, temps, methodInfo);\n+\treturn result;\n+}\n+\n+/**\n+ * Push the bytecode offset onto the simulation stack according to the signature\n+ *\n+ * @param[in] vmThread current J9VMThread\n+ * @param[in] signature class/field signature\n+ * @param[in,out] stackTop the pointer to the simulation stack top\n+ * @param[in] bcPos the bytecode offset to be pushed onto the stack\n+ *\n+ * @return the stackTop\n+ */\n+static UDATA *\n+pushViaSiganature(J9VMThread *vmThread, U_8 *signature, UDATA *stackTop, UDATA bcPos)\n+{\n+\tif ('V' != *signature) {\n+\t\tPUSH(bcPos);\n+\t\tif (('J' == *signature) || ('D' == *signature)) {\n+\t\t\tPUSH(bcPos);\n+\t\t}\n+\t}\n+\tTrc_VM_PushViaSiganature_Exit(vmThread, *signature, stackTop, bcPos);\n+\treturn stackTop;\n+}\n+\n+/**\n+ * Create a message according to the template and incoming arguments\n+ *\n+ * Note: the caller is responsible for freeing the returned string if it is not NULL.\n+ *\n+ * @param[in] vmThread current J9VMThread\n+ * @param[in] msgTemplate the message template\n+ * @param[in] ... arguments to be substituted into the message\n+ *\n+ * @return a message string, NULL if not successful\n+ */\n+static char *\n+getMsgWithAllocation(J9VMThread *vmThread, const char *msgTemplate, ...)\n+{\n+\tva_list args;\n+\tPORT_ACCESS_FROM_VMC(vmThread);\n+\n+\tva_start(args, msgTemplate);\n+\tUDATA msgLen = j9str_vprintf(NULL, 0, msgTemplate, args);\n+\tchar *resultMsg = (char *)j9mem_allocate_memory(msgLen, OMRMEM_CATEGORY_VM);\n+\t/* NULL check omitted since j9str_vprintf accepts NULL (as above) */\n+\tj9str_vprintf(resultMsg, msgLen, msgTemplate, args);\n+\tva_end(args);\n+\t\n+\tTrc_VM_GetMsgWithAllocation_Exit(vmThread, msgTemplate, resultMsg);\n+\n+\treturn resultMsg;\n+}\n+\n+/**\n+ * Set bytecodeOffset[bcPos] value to first << BYTECODE_OFFSET_SHIFT + second\n+ *\n+ * Note: Usually first is the offset of a bytecode which puts an arrayref/objectref onto the operand stack,\n+ * \t\tand the second is the offset of a bytecode which puts an index value onto the operand stack.\n+ * \t\tWhen either first or second is BYTECODE_BRANCH_TARGET which means there are more than one path to put\n+ * \t\tsuch a value onto the stack, a BYTECODE_BRANCH_TARGET will be saved instead.\n+ *\n+ * @param[in] bytecodeOffset the array storing the bytecode offset\n+ * @param[in] bcPos the location of the array bytecodeOffset\n+ * @param[in] first the first bytecode offset stored at bytecodeOffset[bcPos] higher 16 bits\n+ * @param[in] second the second bytecode offset stored at bytecodeOffset[bcPos] lower 16 bits\n+ */\n+static void\n+setSrcBytecodeOffset(J9BytecodeOffset *bytecodeOffset, UDATA bcPos, UDATA first, UDATA second)\n+{\n+\tif (BYTECODE_BRANCH_TARGET == first) {\n+\t\tbytecodeOffset[bcPos].first = BYTECODE_BRANCH_TARGET;\n+\t} else {\n+\t\tbytecodeOffset[bcPos].first = (U_32)first;\n+\t}\n+\tif (BYTECODE_BRANCH_TARGET == second) {\n+\t\tbytecodeOffset[bcPos].second = BYTECODE_BRANCH_TARGET;\n+\t} else {\n+\t\tbytecodeOffset[bcPos].second = (U_32)second;\n+\t}\n+}\n+\n+char*\n+getNPEMessage(J9NPEMessageData *npeMsgData)\n+{\n+\tchar *npeMsg = NULL;\n+\tif (BCV_SUCCESS == initializeNPEMessageData(npeMsgData)) {\n+\t\tnpeMsg = simulateStack(npeMsgData);\n+\t}\n+\n+\treturn npeMsg;\n+}\n+\n+/**\n+ * Simulate stack push/pop with incoming romMethod bytecode until the offset specified via npePC,\n+ * then invoke computeNPEMsgAtPC() to generate NPE extended message.\n+ *\n+ * Note: the caller is responsible for freeing the returned string if it is not NULL.\n+ *\n+ * @param[in] npeMsgData - the J9NPEMessageData structure holding romClass/romMethod/npePC\n+ *\n+ * @return an extended NPE message or NULL if such a message can't be generated\n+ */\n+static char*\n+simulateStack(J9NPEMessageData *npeMsgData)\n+{\n+\tchar *npeMsg = NULL;\n+\tUDATA npePC = npeMsgData->npePC;\n+\tJ9ROMClass *romClass = npeMsgData->romClass;\n+\tJ9ROMMethod *romMethod = npeMsgData->romMethod;\n+\tJ9VMThread *vmThread = npeMsgData->vmThread;\n+\tU_32 *bytecodeMap = npeMsgData->bytecodeMap;\n+\tJ9ROMConstantPoolItem *constantPool = J9_ROM_CP_FROM_ROM_CLASS(romClass);\n+\tBOOLEAN checkIfInsideException = romMethod->modifiers & J9AccMethodHasExceptionInfo;\n+\tU_8 *bytecode = J9_BYTECODE_START_FROM_ROM_METHOD(romMethod);\n+\tUDATA bytecodeLength = J9_BYTECODE_SIZE_FROM_ROM_METHOD(romMethod);\n+\tJ9ExceptionInfo *exceptionData = J9_EXCEPTION_DATA_FROM_ROM_METHOD(romMethod);\n+\tJ9BytecodeOffset *bytecodeOffset = npeMsgData->bytecodeOffset;\n+\tJ9BranchTargetStack *liveStack = npeMsgData->liveStack;\n+\n+\t/* required by macro NPEMSG_POP/DROP/RELOAD_LIVESTACK etc. */\n+\tUDATA *stackBase = NULL;\n+\tUDATA *stackTop = NULL;\n+\tUDATA *temps = NULL;\n+\tUDATA temp1 = 0;\n+\tRELOAD_LIVESTACK;\n+\n+\tU_8 *bcIndex = bytecode;\n+\tUDATA pc = 0;\n+\tUDATA currentBytecode = 0;\n+\tUDATA bcPos = 0;\n+\n+\tBOOLEAN foundFlag = FALSE;\n+\tBOOLEAN justLoadedStack = FALSE;\n+\tBOOLEAN wideIndex = FALSE;\n+\tUDATA popCount = 0;\n+\n+\twhile (pc < bytecodeLength) {\n+\t\tbcIndex = bytecode + pc;\n+\t\tcurrentBytecode = *bcIndex;\n+\t\tif (pc == npePC) {\n+\t\t\t/* mark the NPE PC is found, need proceed to prepare the data structures while the pc value could be updated later */\n+\t\t\tfoundFlag = TRUE;\n+\t\t} else if (JBinvokeinterface2 == currentBytecode) {\n+\t\t\tif ((pc + 2) == npePC) {\n+\t\t\t\tfoundFlag = TRUE;\n+\t\t\t}\n+\t\t}\n+\t\tbcPos = pc;\n+\n+\t\t/* If exception start PC, or possible branch to inside an exception range,\n+\t\t * copy the existing stack shape into the exception stack.\n+\t\t */\n+\t\tif ((bytecodeMap[pc] & BRANCH_EXCEPTION_START) || (justLoadedStack && checkIfInsideException)) {\n+\t\t\tUDATA exception = 0;\n+\t\t\tUDATA *originalStackTop = NULL;\n+\t\t\tUDATA originalStackZeroEntry = 0;\n+\t\t\tJ9ExceptionHandler *handler = J9EXCEPTIONINFO_HANDLERS(exceptionData);\n+\n+\t\t\tSAVE_STACKTOP(liveStack, stackTop);\n+\t\t\t/* Save the current liveStack element zero,\n+\t\t\t * Reset the stack pointer to push the exception on the empty stack\n+\t\t\t */\n+\t\t\toriginalStackTop = stackTop;\n+\t\t\toriginalStackZeroEntry = liveStack->stackElements[liveStack->stackBaseIndex];\n+\t\t\tfor (exception = 0; exception < (UDATA) exceptionData->catchCount; exception++) {\n+\t\t\t\t/* find the matching branch target, and copy/merge the stack with the exception object */\n+\t\t\t\tif ((pc >= handler->startPC) && (pc < handler->endPC)) {\n+\t\t\t\t\t/* Empty the stack */\n+\t\t\t\t\tstackTop = &(liveStack->stackElements[liveStack->stackBaseIndex]);\n+\t\t\t\t\tPUSH(bcPos); /* the equivalent stack operation of PUSH the exception object */\n+\t\t\t\t\tSAVE_STACKTOP(liveStack, stackTop);\n+\t\t\t\t\tif (BCV_SUCCESS != copyToTargetStack(npeMsgData, handler->handlerPC)) {\n+\t\t\t\t\t\tgoto _internalError;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\thandler++;\n+\t\t\t}\n+\t\t\t/* Restore liveStack */\n+\t\t\tliveStack->stackElements[liveStack->stackBaseIndex] = originalStackZeroEntry;\n+\t\t\tstackTop = originalStackTop;\n+\t\t\tSAVE_STACKTOP(liveStack, stackTop);\n+\t\t}\n+\n+\t\t/* Format: 8bits action, 4bits type Y (type 2), 4bits type X (type 1) */\n+\t\tUDATA typeTableEntry = (UDATA) J9JavaBytecodeVerificationTable[currentBytecode];\n+\t\tUDATA action = typeTableEntry >> 8;\n+\t\tUDATA type1 = decodeTable[typeTableEntry & 0xF];\n+\t\tUDATA type2 = decodeTable[(typeTableEntry >> 4) & 0xF];\n+\n+\t\t/* Merge all branchTargets encountered */\n+\t\tif (bytecodeMap[pc] & BRANCH_TARGET) {\n+\t\t\t/* Skip the stack just loaded */\n+\t\t\tif (!justLoadedStack) {\n+\t\t\t\tSAVE_STACKTOP(liveStack, stackTop);\n+\t\t\t\tTrc_VM_SimulateStack_BranchTarget(vmThread, pc, bytecodeMap[pc], bcPos);\n+\t\t\t\tif (BCV_SUCCESS != copyToTargetStack(npeMsgData, bcPos)) {\n+\t\t\t\t\tgoto _internalError;\n+\t\t\t\t}\n+\t\t\t\tgoto _checkFinished;\n+\t\t\t}\n+\t\t}\n+\t\tjustLoadedStack = FALSE;\n+\n+\t\t/* high nybble = branch action, low nybble = instruction size */\n+\t\tpc += (J9JavaInstructionSizeAndBranchActionTable[currentBytecode] & 7);\n+\n+\t\t/* Layout:\n+\t\t * bit 7:\tspecial\n+\t\t * bit 6:\tint/object pushes 0=int, 1=object.\n+\t\t * bit 4-5:\tpushes.\n+\t\t * bit 0-3: pops\n+\t\t */\n+\t\tpopCount = JavaStackActionTable[currentBytecode] & 0x07;\n+\t\tif ((stackTop - popCount) < stackBase) {\n+\t\t\tTrc_VM_SimulateStack_MalformedStack_One(vmThread, stackTop, popCount, stackBase);\n+\t\t\tgoto _internalError;\n+\t\t}\n+\n+\t\tswitch (action) {\n+\t\tcase RTV_ARRAY_FETCH_PUSH: {\n+\t\t\tUDATA indexBytecodeOffset = NPEMSG_POP; /* the offset of the bytecode putting index onto the operand stack */\n+\t\t\tUDATA arrayrefBytecodeOffset = NPEMSG_POP; /* the offset of the bytecode putting arrayref onto the operand stack */\n+\t\t\tsetSrcBytecodeOffset(bytecodeOffset, bcPos, arrayrefBytecodeOffset, indexBytecodeOffset);\n+\t\t}\t/* Fall through case !!! */\n+\n+\t\tcase RTV_WIDE_LOAD_TEMP_PUSH:\t/* Fall through case !!! */\n+\t\tcase RTV_LOAD_TEMP_PUSH:\t\t/* Fall through case !!! */\n+\t\tcase RTV_PUSH_CONSTANT:\t\t\t/* Fall through case !!! */\n+\t\tcase RTV_PUSH_CONSTANT_POOL_ITEM:\n+\n+\t\t_pushConstant:\n+\t\t\tPUSH(bcPos);\n+\t\t\tif ((type1 & BCV_WIDE_TYPE_MASK)\n+\t\t\t\t|| (JBldc2lw == currentBytecode)\n+\t\t\t\t|| (JBldc2dw == currentBytecode)\n+\t\t\t) {\n+\t\t\t\tPUSH(bcPos);\n+\t\t\t}\n+\t\t\tbreak;\n+\n+\t\tcase RTV_WIDE_POP_STORE_TEMP:\n+\t\t\twideIndex = TRUE;\t/* Fall through case !!! */\n+\n+\t\tcase RTV_POP_STORE_TEMP: {\n+\t\t\tUDATA index = type2 & 0x7;\n+\t\t\tif (0 == type2) {\n+\t\t\t\tindex = PARAM_8(bcIndex, 1);\n+\t\t\t\tif (wideIndex) {\n+\t\t\t\t\tindex = PARAM_16(bcIndex, 1);\n+\t\t\t\t\twideIndex = FALSE;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (BCV_GENERIC_OBJECT == type1) {\n+\t\t\t\t/* astore family */\n+\t\t\t\tNPEMSG_DROP(1);\n+\t\t\t\ttemps[index] = BYTECODE_TEMP_CHANGED;\n+\t\t\t} else {\n+\t\t\t\tNPEMSG_DROP(popCount);\n+\t\t\t\tif (type1 & BCV_WIDE_TYPE_MASK) {\n+\t\t\t\t\ttemps[index + 1] = BYTECODE_TEMP_CHANGED;\n+\t\t\t\t}\n+\t\t\t\ttemps[index] = BYTECODE_TEMP_CHANGED;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase RTV_POP_X_PUSH_X:\n+\t\t\tpopCount = 0;\n+\t\t\tif (0 != type2) {\n+\t\t\t\t/* shift family */\n+\t\t\t\tpopCount = 1;\n+\t\t\t}\t/* Fall through case !!! */\n+\n+\t\tcase RTV_ARRAY_STORE:\n+\t\t\t/*  *(stackTop - popCount + 1) - the offset of the bytecode putting index onto the operand stack */\n+\t\t\t/* *(stackTop - popCount) - the offset of the bytecode putting arrayref onto the operand stack */\n+\t\t\tsetSrcBytecodeOffset(bytecodeOffset, bcPos, *(stackTop - popCount), *(stackTop - popCount + 1));\n+\t\t\tNPEMSG_DROP(popCount);\n+\t\t\tbreak;\n+\n+\t\tcase RTV_POP_X_PUSH_Y:\n+\t\t\ttype1 = type2; /* Fall through case !!! */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0"}, "originalPosition": 1297}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDE0MTI0", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#pullrequestreview-524414124", "createdAt": "2020-11-05T16:01:42Z", "commit": {"oid": "dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNjowMTo0MlrOHuKUsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNjowMTo0MlrOHuKUsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE2NTY4MA==", "bodyText": "Please put a blank line between the macros definitions.", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#discussion_r518165680", "createdAt": "2020-11-05T16:01:42Z", "author": {"login": "gacholio"}, "path": "runtime/vm/extendedMessageNPE.cpp", "diffHunk": "@@ -20,21 +20,100 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n+#include \"bcverify.h\"\n #include \"cfreader.h\"\n+#include \"pcstack.h\"\n+#include \"rommeth.h\"\n #include \"stackwalk.h\"\n-#include \"util_api.h\"\n #include \"ut_j9vm.h\"\n+#include \"vrfytbl.h\"\n \n extern \"C\" {\n \n+/* Define for debug\n+#define DEBUG_BCV\n+*/\n+\n+static IDATA buildBranchMap(J9NPEMessageData *npeMsgData);\n+static void computeNPEMsgAtPC(J9VMThread *vmThread, J9ROMMethod *romMethod, J9ROMClass *romClass, UDATA npePC,\n+\t\tBOOLEAN npeFinalFlag, char **npeMsg, BOOLEAN *isMethodFlag, UDATA *temps, J9BytecodeOffset *bytecodeOffset);\n static char* convertToJavaFullyQualifiedName(J9VMThread *vmThread, J9UTF8 *fullyQualifiedNameUTF);\n static char* convertMethodSignature(J9VMThread *vmThread, J9UTF8 *methodSig);\n+static IDATA copyToTargetStack(J9NPEMessageData *npeMsgData, UDATA target);\n+static char* getCompleteNPEMessage(J9VMThread *vmThread, U_8 *bcCurrentPtr, J9ROMClass *romClass, char *npeCauseMsg, BOOLEAN isMethodFlag);\n+static char* getFullyQualifiedMethodName(J9VMThread *vmThread, J9ROMClass *romClass, U_8 *bcIndex);\n+static char* getLocalsName(J9VMThread *vmThread, J9ROMMethod *romMethod, U_16 localVar, UDATA bcCausePos, UDATA *temps);\n+static char* getMsgWithAllocation(J9VMThread *vmThread, const char *msgTemplate, ...);\n+static IDATA initializeNPEMessageData(J9NPEMessageData *npeMsgData);\n+static void initStackFromMethodSignature(J9VMThread *vmThread, J9ROMMethod *romMethod, UDATA **stackTopPtr);\n+static UDATA* pushViaSiganature(J9VMThread *vmThread, U_8 *signature, UDATA *stackTop, UDATA bcPos);\n+static void setSrcBytecodeOffset(J9BytecodeOffset *bytecodeOffset, UDATA bcPos, UDATA first, UDATA second);\n+static char* simulateStack(J9NPEMessageData *npeMsgData);\n+\n+#define BCV_INTERNAL_DEFAULT_SIZE (32*1024)\n+#define BYTECODE_BRANCH_TARGET 0xFEFEFEFE\n+#define BYTECODE_TEMP_CHANGED 0xFDFDFDFD\n+#define BYTECODE_OFFSET_SHIFT 16\n+#define BYTECODE_OFFSET_MASK 0xFFFF\n+\n+#define NPEMSG_FIRST_STACK() \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a10e6bf12442ca0696fd39c3598ea93e7817334b", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a10e6bf12442ca0696fd39c3598ea93e7817334b", "committedDate": "2020-11-05T16:37:14Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/dd30c1d38b215d1fa8c5c7888c7f5d962b858ca0", "committedDate": "2020-11-04T23:28:49Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}, "afterCommit": {"oid": "a10e6bf12442ca0696fd39c3598ea93e7817334b", "author": {"user": {"login": "JasonFengJ9", "name": "Jason Feng"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a10e6bf12442ca0696fd39c3598ea93e7817334b", "committedDate": "2020-11-05T16:37:14Z", "message": "JEP358 NPE extended message part 2 - the cause of NPE\n* Added J9NPEMessageData to pass\nvmThread/romClass/romMethod/bytecodeOffset;\n* Enabled J9VM_DEBUG_ATTRIBUTE_LOCAL_VARIABLE_TABLE when JEP358 is on;\n* simulateStack() is similar with verifier version and utility methods\nbut not sharing the actual code to avoid interference to those already\ncomplicated code;\n* NPE message generation is computed based on the method PC (npePC) and\nthe method bytecode;\n* The bytecode stack simulation algorithm is similar with the verifier,\nbut the bytecode offset is pushed onto the stack instead of verifier\nelements;\n* When those stack elements are popped, the offset of previous bytecode\nexecuted are recorded at BytecodeOffset *bytecodeOffset via\nsetSrcBytecodeOffset;\n* Added trace points;\n* Added tests.\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDU2NjE1", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#pullrequestreview-524456615", "createdAt": "2020-11-05T16:44:32Z", "commit": {"oid": "a10e6bf12442ca0696fd39c3598ea93e7817334b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NjM3ODA0", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#pullrequestreview-524637804", "createdAt": "2020-11-05T20:23:55Z", "commit": {"oid": "a10e6bf12442ca0696fd39c3598ea93e7817334b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDoyMzo1NVrOHuVGpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDoyMzo1NVrOHuVGpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM0MjMwOQ==", "bodyText": "The signature of this tracepoint should be restored (and marked obsolete); a new one is required for a different signature.", "url": "https://github.com/eclipse-openj9/openj9/pull/10912#discussion_r518342309", "createdAt": "2020-11-05T20:23:55Z", "author": {"login": "keithc-ca"}, "path": "runtime/vm/j9vm.tdf", "diffHunk": "@@ -786,7 +786,7 @@ TraceEvent=Trc_VM_classInitStateMachine_verifyFlattenableField Group=classinit O\n TraceEvent=Trc_VM_classInitStateMachine_prepareFlattenableField Group=classinit Overhead=1 Level=3 Template=\"prepare flattenable field clazz=%p\"\n TraceEvent=Trc_VM_classInitStateMachine_initFlattenableField Group=classinit Overhead=1 Level=3 Template=\"initialize flattenable field clazz=%p\"\n \n-TraceEntry=Trc_VM_GetCompleteNPEMessage_Entry Overhead=1 Level=3 Template=\"GetCompleteNPEMessage - bcCurrentPtr (0x%p) bcCurrent (0x%x) romClass (0x%p) npeCauseMsg (%s)\"\n+TraceEntry=Trc_VM_GetCompleteNPEMessage_Entry Overhead=1 Level=3 Template=\"GetCompleteNPEMessage - bcCurrentPtr (0x%p) romClass (0x%p) bcCurrent (0x%x) npeCauseMsg (%s) isMethodFlag (%d)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10e6bf12442ca0696fd39c3598ea93e7817334b"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 202, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}