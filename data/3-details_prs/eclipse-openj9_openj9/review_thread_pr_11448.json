{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM2ODc0ODgy", "number": 11448, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNDo0MTowNlrOFEBDdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNDo0MTowNlrOFEBDdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NzU1ODk1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/net/ClientStream.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNDo0MTowNlrOID7tAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNTozMzoxN1rOID977w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk5NDgxOA==", "bodyText": "This check isn't done elsewhere and seems unnecessary and since getaddrinfo will return at least one element if it succeeded.", "url": "https://github.com/eclipse-openj9/openj9/pull/11448#discussion_r540994818", "createdAt": "2020-12-11T14:41:06Z", "author": {"login": "ymanton"}, "path": "runtime/compiler/net/ClientStream.cpp", "diffHunk": "@@ -130,60 +130,86 @@ SSL_CTX *ClientStream::_sslCtx = NULL;\n \n int openConnection(const std::string &address, uint32_t port, uint32_t timeoutMs)\n    {\n-   // TODO consider using newer API like getaddrinfo to support IPv6\n-   struct hostent *entSer = gethostbyname(address.c_str());\n-   if (!entSer)\n+   // TODO consider support for IPv6\n+   struct addrinfo hints;\n+   memset(&hints, 0, sizeof(hints));\n+   hints.ai_family = AF_INET;    // Allow IPv4 only; could use AF_UNSPEC to allow IPv6 too\n+   hints.ai_socktype = SOCK_STREAM;\n+   hints.ai_flags = 0;\n+   hints.ai_protocol = 0; // Any protocol\n+\n+   char portName[12];\n+   int r = snprintf(portName, 12, \"%d\", port);\n+   if (r < 0 || r > 11)\n+      throw StreamFailure(\"snprintf failed\");\n+\n+   struct addrinfo *addrList = NULL;\n+   int res = getaddrinfo(address.c_str(), portName, &hints, &addrList);\n+   if (res != 0)\n+      {\n+      // Can use gai_strerror(res) to show error code\n       throw StreamFailure(\"Cannot resolve server name\");\n-\n-   struct sockaddr_in servAddr;\n-   memset(&servAddr, 0, sizeof(servAddr));\n-   memcpy(&servAddr.sin_addr.s_addr, entSer->h_addr, entSer->h_length);\n-   servAddr.sin_family = AF_INET;\n-   servAddr.sin_port = htons(port);\n-\n-   int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n+      }\n+   struct addrinfo *pAddr;\n+   int sockfd = -1;\n+   for (pAddr = addrList; pAddr; pAddr = pAddr->ai_next) \n+      {\n+      sockfd = socket(pAddr->ai_family, pAddr->ai_socktype, pAddr->ai_protocol);\n+      if (sockfd >= 0)\n+         break; // Use the first address for which a socket could be created\n+      // Try next address\n+      }\n    if (sockfd < 0)\n+      {\n+      if (addrList)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d335a86e0d51a854fce9e8bcc6b6a28fd84983"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAyMTMxMQ==", "bodyText": "I was thinking about the following sequence of events:\n\ngetaddrinfo returns an empty list (but does not return an error code)\nThe for loop is never executed, thus sockfd==-1\nWe enter this if statement and execute freeaddrinfo(NULL). This may be benign, but I didn't want to take any chances.\n\nThe check addrList != NULL is not needed in other parts because we throw if a socket cannot be opened, and a socket being opened guarantees that addrList != NULL", "url": "https://github.com/eclipse-openj9/openj9/pull/11448#discussion_r541021311", "createdAt": "2020-12-11T15:19:15Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/ClientStream.cpp", "diffHunk": "@@ -130,60 +130,86 @@ SSL_CTX *ClientStream::_sslCtx = NULL;\n \n int openConnection(const std::string &address, uint32_t port, uint32_t timeoutMs)\n    {\n-   // TODO consider using newer API like getaddrinfo to support IPv6\n-   struct hostent *entSer = gethostbyname(address.c_str());\n-   if (!entSer)\n+   // TODO consider support for IPv6\n+   struct addrinfo hints;\n+   memset(&hints, 0, sizeof(hints));\n+   hints.ai_family = AF_INET;    // Allow IPv4 only; could use AF_UNSPEC to allow IPv6 too\n+   hints.ai_socktype = SOCK_STREAM;\n+   hints.ai_flags = 0;\n+   hints.ai_protocol = 0; // Any protocol\n+\n+   char portName[12];\n+   int r = snprintf(portName, 12, \"%d\", port);\n+   if (r < 0 || r > 11)\n+      throw StreamFailure(\"snprintf failed\");\n+\n+   struct addrinfo *addrList = NULL;\n+   int res = getaddrinfo(address.c_str(), portName, &hints, &addrList);\n+   if (res != 0)\n+      {\n+      // Can use gai_strerror(res) to show error code\n       throw StreamFailure(\"Cannot resolve server name\");\n-\n-   struct sockaddr_in servAddr;\n-   memset(&servAddr, 0, sizeof(servAddr));\n-   memcpy(&servAddr.sin_addr.s_addr, entSer->h_addr, entSer->h_length);\n-   servAddr.sin_family = AF_INET;\n-   servAddr.sin_port = htons(port);\n-\n-   int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n+      }\n+   struct addrinfo *pAddr;\n+   int sockfd = -1;\n+   for (pAddr = addrList; pAddr; pAddr = pAddr->ai_next) \n+      {\n+      sockfd = socket(pAddr->ai_family, pAddr->ai_socktype, pAddr->ai_protocol);\n+      if (sockfd >= 0)\n+         break; // Use the first address for which a socket could be created\n+      // Try next address\n+      }\n    if (sockfd < 0)\n+      {\n+      if (addrList)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk5NDgxOA=="}, "originalCommit": {"oid": "44d335a86e0d51a854fce9e8bcc6b6a28fd84983"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAzMTQwNw==", "bodyText": "I removed the check", "url": "https://github.com/eclipse-openj9/openj9/pull/11448#discussion_r541031407", "createdAt": "2020-12-11T15:33:17Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/net/ClientStream.cpp", "diffHunk": "@@ -130,60 +130,86 @@ SSL_CTX *ClientStream::_sslCtx = NULL;\n \n int openConnection(const std::string &address, uint32_t port, uint32_t timeoutMs)\n    {\n-   // TODO consider using newer API like getaddrinfo to support IPv6\n-   struct hostent *entSer = gethostbyname(address.c_str());\n-   if (!entSer)\n+   // TODO consider support for IPv6\n+   struct addrinfo hints;\n+   memset(&hints, 0, sizeof(hints));\n+   hints.ai_family = AF_INET;    // Allow IPv4 only; could use AF_UNSPEC to allow IPv6 too\n+   hints.ai_socktype = SOCK_STREAM;\n+   hints.ai_flags = 0;\n+   hints.ai_protocol = 0; // Any protocol\n+\n+   char portName[12];\n+   int r = snprintf(portName, 12, \"%d\", port);\n+   if (r < 0 || r > 11)\n+      throw StreamFailure(\"snprintf failed\");\n+\n+   struct addrinfo *addrList = NULL;\n+   int res = getaddrinfo(address.c_str(), portName, &hints, &addrList);\n+   if (res != 0)\n+      {\n+      // Can use gai_strerror(res) to show error code\n       throw StreamFailure(\"Cannot resolve server name\");\n-\n-   struct sockaddr_in servAddr;\n-   memset(&servAddr, 0, sizeof(servAddr));\n-   memcpy(&servAddr.sin_addr.s_addr, entSer->h_addr, entSer->h_length);\n-   servAddr.sin_family = AF_INET;\n-   servAddr.sin_port = htons(port);\n-\n-   int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n+      }\n+   struct addrinfo *pAddr;\n+   int sockfd = -1;\n+   for (pAddr = addrList; pAddr; pAddr = pAddr->ai_next) \n+      {\n+      sockfd = socket(pAddr->ai_family, pAddr->ai_socktype, pAddr->ai_protocol);\n+      if (sockfd >= 0)\n+         break; // Use the first address for which a socket could be created\n+      // Try next address\n+      }\n    if (sockfd < 0)\n+      {\n+      if (addrList)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk5NDgxOA=="}, "originalCommit": {"oid": "44d335a86e0d51a854fce9e8bcc6b6a28fd84983"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 869, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}