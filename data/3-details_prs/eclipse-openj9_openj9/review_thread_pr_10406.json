{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5NTcyMjU5", "number": 10406, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODo1NToxNVrOEqcQsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNToyODowM1rOE4NqwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTM4Njc1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODo1NToxNVrOHcpq_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODo1NToxNVrOHcpq_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwNDkyNw==", "bodyText": "Loop body is not indented", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r499804927", "createdAt": "2020-10-05T18:55:15Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6393,6 +6418,148 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+static char * removeTopLevelPrefixForFlattenedFields(const char * fieldName, uint32_t numCharactersToRemove, TR::Region &region)\n+   {\n+   uint32_t newStringLen = strlen(fieldName) - numCharactersToRemove;\n+\n+   char * newName = new (region) char[newStringLen+1];\n+   strncpy(newName, fieldName + numCharactersToRemove, newStringLen);\n+\n+   newName[newStringLen] = '\\0';\n+   return newName;\n+   }\n+\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value FlattenedLine2D {\n+    *   flattened Point2D st;\n+    *   flattened Point2D en;\n+    * }\n+    * /--- trees inserted ------------------------\n+    * n68n     (  0)  NULLCHK on n63n\n+    * n67n     (  2)    iloadi  FlattenedLine2D.st.x\n+    * n63n     (  3)      ==>newvalue (Identityless sharedMemory )\n+    * n70n     (  0)  NULLCHK on n63n\n+    * n69n     (  2)    iloadi  FlattenedLine2D.st.y I\n+    * n63n     (  3)      ==>newvalue (Identityless sharedMemory )\n+    * n72n     (  0)  NULLCHK on n65n\n+    * n71n     (  2)    iloadi  Point2D.x I\n+    * n65n     (  2)      aload  <parm 1 P>\n+    * n74n     (  0)  NULLCHK on n65n\n+    * n73n     (  2)    iloadi  Point2D.y I\n+    * n65n     (  2)      ==>aload\n+    * n76n     (  0)  treetop\n+    * n75n     (  1)    newvalue  jitNewValue[#100  helper Method]\n+    * n66n     (  1)      loadaddr  FlattenedLine2D\n+    * n67n     (  2)      ==>iloadi\n+    * n69n     (  2)      ==>iloadi\n+    * n71n     (  2)      ==>iloadi\n+    * n73n     (  2)      ==>iloadi\n+    * /--- stack after ------------------------\n+    * @0 n75n     (  1)  ==>newvalue (Identityless sharedMemory )\n+    * ============================================================\n+    */\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (isFieldResolved(comp(), owningMethod, fieldCpIndex, false))\n+      {\n+      TR::Node *newFieldValue = pop();\n+      TR::Node *originalObject = pop();\n+\n+      int32_t prefixLen = 0;\n+      char * fieldNamePrefix = getTopLevelPrefixForFlattenedFields(owningMethod, fieldCpIndex, prefixLen, comp()->trMemory()->currentStackRegion());\n+\n+      int len;\n+      const char * fieldClassChars = owningMethod->fieldSignatureChars(fieldCpIndex, len);\n+      TR_OpaqueClassBlock * fieldClass = fej9()->getClassFromSignature(fieldClassChars, len, owningMethod);\n+\n+      loadClassObject(valueClass);\n+\n+      const TR::TypeLayout *typeLayout = comp()->typeLayout(valueClass);\n+      size_t fieldCount = typeLayout->count();\n+\n+      TR_OpaqueClassBlock * containingClass = owningMethod->definingClassFromCPFieldRef(comp(), fieldCpIndex, _methodSymbol->isStatic());\n+\n+      for (size_t idx = 0; idx < fieldCount; idx++)\n+      {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbec6d2fb22da6813b35cbdaba7f9d88374d7c2b"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDQ4MjgyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMjo0MjoxOVrOHc0Ctg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxOToyMzozM1rOHdWoKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NDgzOA==", "bodyText": "This example should probably show what bytecode is being processed to produce these trees or at least some Java pseudo-code.  It might also be a little easier to understand if the value at n63n was an existing value that could be referenced with a name rather than another newly constructed value.", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r499974838", "createdAt": "2020-10-06T02:42:19Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6393,6 +6418,148 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+static char * removeTopLevelPrefixForFlattenedFields(const char * fieldName, uint32_t numCharactersToRemove, TR::Region &region)\n+   {\n+   uint32_t newStringLen = strlen(fieldName) - numCharactersToRemove;\n+\n+   char * newName = new (region) char[newStringLen+1];\n+   strncpy(newName, fieldName + numCharactersToRemove, newStringLen);\n+\n+   newName[newStringLen] = '\\0';\n+   return newName;\n+   }\n+\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value FlattenedLine2D {\n+    *   flattened Point2D st;\n+    *   flattened Point2D en;\n+    * }\n+    * /--- trees inserted ------------------------", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbec6d2fb22da6813b35cbdaba7f9d88374d7c2b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU0MTQ4MQ==", "bodyText": "I'll add java pseudo-code and its tree example.", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r500541481", "createdAt": "2020-10-06T19:23:33Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6393,6 +6418,148 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+static char * removeTopLevelPrefixForFlattenedFields(const char * fieldName, uint32_t numCharactersToRemove, TR::Region &region)\n+   {\n+   uint32_t newStringLen = strlen(fieldName) - numCharactersToRemove;\n+\n+   char * newName = new (region) char[newStringLen+1];\n+   strncpy(newName, fieldName + numCharactersToRemove, newStringLen);\n+\n+   newName[newStringLen] = '\\0';\n+   return newName;\n+   }\n+\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value FlattenedLine2D {\n+    *   flattened Point2D st;\n+    *   flattened Point2D en;\n+    * }\n+    * /--- trees inserted ------------------------", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NDgzOA=="}, "originalCommit": {"oid": "fbec6d2fb22da6813b35cbdaba7f9d88374d7c2b"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDU4MTk5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMzo0NzoyN1rOHc098A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMzo0NzoyN1rOHc098A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5MDAwMA==", "bodyText": "I would suggest making the operands a little more explicit here with bytecode or some Java/pseudo-code so that it's easier to tie this to the trees that are shown in the example.", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r499990000", "createdAt": "2020-10-06T03:47:27Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -7012,6 +7186,89 @@ TR_J9ByteCodeIlGenerator::storeFlattenableInstanceWithHelper(int32_t cpIndex)\n    genTreeTop(helperCallNode);\n    }\n \n+void\n+TR_J9ByteCodeIlGenerator::storeFlattenableInstance(int32_t cpIndex)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * class AssortedReftWithLongAlignment {\n+    *    flattened Point2D point;\n+    *    flattened Line2D line;\n+    *    flattened ValueObject o;\n+    *    flattened ValueLong l;\n+    *    flattened ValueDouble d;\n+    *    flattened ValueInt i;\n+    *    flattened Triangle2D tri;\n+    * }\n+    *\n+    * AssortedRefWithLongAlignment.setpoint(QPoint2D;)V", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbec6d2fb22da6813b35cbdaba7f9d88374d7c2b"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDU4Mzc4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMzo0ODo1MFrOHc0-9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMzo0ODo1MFrOHc0-9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5MDI2Mw==", "bodyText": "I don't think all these fields are relevant for this example.  If they're not, I suggest you remove them to avoid confusion.", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r499990263", "createdAt": "2020-10-06T03:48:50Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -7012,6 +7186,89 @@ TR_J9ByteCodeIlGenerator::storeFlattenableInstanceWithHelper(int32_t cpIndex)\n    genTreeTop(helperCallNode);\n    }\n \n+void\n+TR_J9ByteCodeIlGenerator::storeFlattenableInstance(int32_t cpIndex)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * class AssortedReftWithLongAlignment {\n+    *    flattened Point2D point;\n+    *    flattened Line2D line;\n+    *    flattened ValueObject o;\n+    *    flattened ValueLong l;\n+    *    flattened ValueDouble d;\n+    *    flattened ValueInt i;\n+    *    flattened Triangle2D tri;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbec6d2fb22da6813b35cbdaba7f9d88374d7c2b"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDU4NTYzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMzo1MDowNlrOHc1ACQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMDo1Nzo0MFrOHdZqlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5MDUzNw==", "bodyText": "Does this actually need to create a copy of the name with the prefix removed or could it simply be written as follows?\nchar *fieldNameRemovedTopLevelPrefix = fieldEntry._fieldname + prefixLen;", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r499990537", "createdAt": "2020-10-06T03:50:06Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6393,6 +6418,148 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+static char * removeTopLevelPrefixForFlattenedFields(const char * fieldName, uint32_t numCharactersToRemove, TR::Region &region)\n+   {\n+   uint32_t newStringLen = strlen(fieldName) - numCharactersToRemove;\n+\n+   char * newName = new (region) char[newStringLen+1];\n+   strncpy(newName, fieldName + numCharactersToRemove, newStringLen);\n+\n+   newName[newStringLen] = '\\0';\n+   return newName;\n+   }\n+\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value FlattenedLine2D {\n+    *   flattened Point2D st;\n+    *   flattened Point2D en;\n+    * }\n+    * /--- trees inserted ------------------------\n+    * n68n     (  0)  NULLCHK on n63n\n+    * n67n     (  2)    iloadi  FlattenedLine2D.st.x\n+    * n63n     (  3)      ==>newvalue (Identityless sharedMemory )\n+    * n70n     (  0)  NULLCHK on n63n\n+    * n69n     (  2)    iloadi  FlattenedLine2D.st.y I\n+    * n63n     (  3)      ==>newvalue (Identityless sharedMemory )\n+    * n72n     (  0)  NULLCHK on n65n\n+    * n71n     (  2)    iloadi  Point2D.x I\n+    * n65n     (  2)      aload  <parm 1 P>\n+    * n74n     (  0)  NULLCHK on n65n\n+    * n73n     (  2)    iloadi  Point2D.y I\n+    * n65n     (  2)      ==>aload\n+    * n76n     (  0)  treetop\n+    * n75n     (  1)    newvalue  jitNewValue[#100  helper Method]\n+    * n66n     (  1)      loadaddr  FlattenedLine2D\n+    * n67n     (  2)      ==>iloadi\n+    * n69n     (  2)      ==>iloadi\n+    * n71n     (  2)      ==>iloadi\n+    * n73n     (  2)      ==>iloadi\n+    * /--- stack after ------------------------\n+    * @0 n75n     (  1)  ==>newvalue (Identityless sharedMemory )\n+    * ============================================================\n+    */\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (isFieldResolved(comp(), owningMethod, fieldCpIndex, false))\n+      {\n+      TR::Node *newFieldValue = pop();\n+      TR::Node *originalObject = pop();\n+\n+      int32_t prefixLen = 0;\n+      char * fieldNamePrefix = getTopLevelPrefixForFlattenedFields(owningMethod, fieldCpIndex, prefixLen, comp()->trMemory()->currentStackRegion());\n+\n+      int len;\n+      const char * fieldClassChars = owningMethod->fieldSignatureChars(fieldCpIndex, len);\n+      TR_OpaqueClassBlock * fieldClass = fej9()->getClassFromSignature(fieldClassChars, len, owningMethod);\n+\n+      loadClassObject(valueClass);\n+\n+      const TR::TypeLayout *typeLayout = comp()->typeLayout(valueClass);\n+      size_t fieldCount = typeLayout->count();\n+\n+      TR_OpaqueClassBlock * containingClass = owningMethod->definingClassFromCPFieldRef(comp(), fieldCpIndex, _methodSymbol->isStatic());\n+\n+      for (size_t idx = 0; idx < fieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = typeLayout->entry(idx);\n+      if (!strncmp(fieldNamePrefix, fieldEntry._fieldname, prefixLen))\n+         {\n+         char * fieldNameRemovedTopLevelPrefix = removeTopLevelPrefixForFlattenedFields(fieldEntry._fieldname, prefixLen,\n+                                                                                        comp()->trMemory()->currentStackRegion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbec6d2fb22da6813b35cbdaba7f9d88374d7c2b"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU5MTI1Mw==", "bodyText": "Ah, it is \ud83d\udc4d. No need to do all those manipulation in removeTopLevelPrefixForFlattenedFields", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r500591253", "createdAt": "2020-10-06T20:57:40Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6393,6 +6418,148 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+static char * removeTopLevelPrefixForFlattenedFields(const char * fieldName, uint32_t numCharactersToRemove, TR::Region &region)\n+   {\n+   uint32_t newStringLen = strlen(fieldName) - numCharactersToRemove;\n+\n+   char * newName = new (region) char[newStringLen+1];\n+   strncpy(newName, fieldName + numCharactersToRemove, newStringLen);\n+\n+   newName[newStringLen] = '\\0';\n+   return newName;\n+   }\n+\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value FlattenedLine2D {\n+    *   flattened Point2D st;\n+    *   flattened Point2D en;\n+    * }\n+    * /--- trees inserted ------------------------\n+    * n68n     (  0)  NULLCHK on n63n\n+    * n67n     (  2)    iloadi  FlattenedLine2D.st.x\n+    * n63n     (  3)      ==>newvalue (Identityless sharedMemory )\n+    * n70n     (  0)  NULLCHK on n63n\n+    * n69n     (  2)    iloadi  FlattenedLine2D.st.y I\n+    * n63n     (  3)      ==>newvalue (Identityless sharedMemory )\n+    * n72n     (  0)  NULLCHK on n65n\n+    * n71n     (  2)    iloadi  Point2D.x I\n+    * n65n     (  2)      aload  <parm 1 P>\n+    * n74n     (  0)  NULLCHK on n65n\n+    * n73n     (  2)    iloadi  Point2D.y I\n+    * n65n     (  2)      ==>aload\n+    * n76n     (  0)  treetop\n+    * n75n     (  1)    newvalue  jitNewValue[#100  helper Method]\n+    * n66n     (  1)      loadaddr  FlattenedLine2D\n+    * n67n     (  2)      ==>iloadi\n+    * n69n     (  2)      ==>iloadi\n+    * n71n     (  2)      ==>iloadi\n+    * n73n     (  2)      ==>iloadi\n+    * /--- stack after ------------------------\n+    * @0 n75n     (  1)  ==>newvalue (Identityless sharedMemory )\n+    * ============================================================\n+    */\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   if (isFieldResolved(comp(), owningMethod, fieldCpIndex, false))\n+      {\n+      TR::Node *newFieldValue = pop();\n+      TR::Node *originalObject = pop();\n+\n+      int32_t prefixLen = 0;\n+      char * fieldNamePrefix = getTopLevelPrefixForFlattenedFields(owningMethod, fieldCpIndex, prefixLen, comp()->trMemory()->currentStackRegion());\n+\n+      int len;\n+      const char * fieldClassChars = owningMethod->fieldSignatureChars(fieldCpIndex, len);\n+      TR_OpaqueClassBlock * fieldClass = fej9()->getClassFromSignature(fieldClassChars, len, owningMethod);\n+\n+      loadClassObject(valueClass);\n+\n+      const TR::TypeLayout *typeLayout = comp()->typeLayout(valueClass);\n+      size_t fieldCount = typeLayout->count();\n+\n+      TR_OpaqueClassBlock * containingClass = owningMethod->definingClassFromCPFieldRef(comp(), fieldCpIndex, _methodSymbol->isStatic());\n+\n+      for (size_t idx = 0; idx < fieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = typeLayout->entry(idx);\n+      if (!strncmp(fieldNamePrefix, fieldEntry._fieldname, prefixLen))\n+         {\n+         char * fieldNameRemovedTopLevelPrefix = removeTopLevelPrefixForFlattenedFields(fieldEntry._fieldname, prefixLen,\n+                                                                                        comp()->trMemory()->currentStackRegion());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5MDUzNw=="}, "originalCommit": {"oid": "fbec6d2fb22da6813b35cbdaba7f9d88374d7c2b"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDU4NzQ1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMzo1MDo1M1rOHc1A7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMzo1MDo1M1rOHc1A7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5MDc2NQ==", "bodyText": "As above, does this actually need to create a copy of the name with the prefix removed or could it simply be written as follows?\nchar *fieldNameRemovedTopLevelPrefix = fieldEntry._fieldname + prefixLen;", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r499990765", "createdAt": "2020-10-06T03:50:53Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -7012,6 +7186,89 @@ TR_J9ByteCodeIlGenerator::storeFlattenableInstanceWithHelper(int32_t cpIndex)\n    genTreeTop(helperCallNode);\n    }\n \n+void\n+TR_J9ByteCodeIlGenerator::storeFlattenableInstance(int32_t cpIndex)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * class AssortedReftWithLongAlignment {\n+    *    flattened Point2D point;\n+    *    flattened Line2D line;\n+    *    flattened ValueObject o;\n+    *    flattened ValueLong l;\n+    *    flattened ValueDouble d;\n+    *    flattened ValueInt i;\n+    *    flattened Triangle2D tri;\n+    * }\n+    *\n+    * AssortedRefWithLongAlignment.setpoint(QPoint2D;)V\n+    *\n+    * /--- trees inserted ------------------------\n+    * n6n      (  0)  NULLCHK on n4n [#32]\n+    * n5n      (  2)    iloadi  Point2D.x I[#355  final Point2D.x I +4]\n+    * n4n      (  2)      aload  <parm 1 Q>[#353  Parm]\n+    * n7n      (  0)  istorei  AssortedRefWithLongAlignment.point.x I[#354  final AssortedRefWithLongAlignment.point.x I +28]\n+    * n3n      (  2)    aload  <'this' parm LAssortedRefWithLongAlignment;>[#352  Parm]\n+    * n5n      (  2)    ==>iloadi\n+    * n9n      (  0)  NULLCHK on n4n [#32]\n+    * n8n      (  2)    iloadi  Point2D.y I[#357  final Point2D.y I +8]\n+    * n4n      (  2)      ==>aload\n+    * n10n     (  0)  istorei  AssortedRefWithLongAlignment.point.y I[#356  final AssortedRefWithLongAlignment.point.y I +32]\n+    * n3n      (  2)    ==>aload (X!=0 sharedMemory )\n+    * n8n      (  2)    ==>iloadi\n+    * ---- stack after: empty -----------------\n+    */\n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+\n+   int32_t prefixLen = 0;\n+   char * fieldNamePrefix = getTopLevelPrefixForFlattenedFields(owningMethod, cpIndex, prefixLen, comp()->trMemory()->currentStackRegion());\n+\n+   TR_OpaqueClassBlock * containingClass = owningMethod->definingClassFromCPFieldRef(comp(), cpIndex, _methodSymbol->isStatic());\n+   const TR::TypeLayout *containingClassLayout = comp()->typeLayout(containingClass);\n+   size_t fieldCount = containingClassLayout->count();\n+\n+   TR::Node * value = pop();\n+   TR::Node * address = pop();\n+\n+   int len;\n+   const char *fieldClassChars = owningMethod->fieldSignatureChars(cpIndex, len);\n+   TR_OpaqueClassBlock * fieldClass = fej9()->getClassFromSignature(fieldClassChars, len, owningMethod);\n+\n+   for (size_t idx = 0; idx < fieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = containingClassLayout->entry(idx);\n+      if (!strncmp(fieldNamePrefix, fieldEntry._fieldname, prefixLen))\n+         {\n+         auto * fieldSymRef = comp()->getSymRefTab()->findOrFabricateShadowSymbol(containingClass,\n+                                                                     fieldEntry._datatype,\n+                                                                     fieldEntry._offset,\n+                                                                     fieldEntry._isVolatile,\n+                                                                     fieldEntry._isPrivate,\n+                                                                     fieldEntry._isFinal,\n+                                                                     fieldEntry._fieldname,\n+                                                                     fieldEntry._typeSignature\n+                                                                     );\n+\n+         char * fieldNameRemovedTopLevelPrefix = removeTopLevelPrefixForFlattenedFields(fieldEntry._fieldname, prefixLen,\n+                                                                                        comp()->trMemory()->currentStackRegion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbec6d2fb22da6813b35cbdaba7f9d88374d7c2b"}, "originalPosition": 309}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Njg3MjE3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDoxNzoxM1rOHgpGLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDozNjowNVrOHgqB9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4OTgwNg==", "bodyText": "I hate to poke at these examples again, but as this example depends on a kludge that was implemented as a way of accessing support for withfield, it's certain that the Java syntax will change in the future. We're not likely to come back to fix the example, so maybe it would be better to express this example directly in bytecode", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r503989806", "createdAt": "2020-10-13T14:17:13Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6393,6 +6418,148 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value Point2D {\n+    *    public final int x;\n+    *    public final int y;\n+    * }\n+    *\n+    * value FlattenedLine2D {\n+    *    public final Point2D st;\n+    *    public final Point2D en;\n+    *\n+    *    public static FlattenedLine2D withSt(FlattenedLine2D line, Point2D st) {\n+    *       FlattenedLine2D l1 = __WithField(line.st, st);\n+    *       return l1;\n+    *    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ca43934d5ecea4d929a00b7f7d58f479102a1ee"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAwNTExMA==", "bodyText": "I meant \ud83d\udc4d not \ud83d\ude15", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r504005110", "createdAt": "2020-10-13T14:36:05Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6393,6 +6418,148 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value Point2D {\n+    *    public final int x;\n+    *    public final int y;\n+    * }\n+    *\n+    * value FlattenedLine2D {\n+    *    public final Point2D st;\n+    *    public final Point2D en;\n+    *\n+    *    public static FlattenedLine2D withSt(FlattenedLine2D line, Point2D st) {\n+    *       FlattenedLine2D l1 = __WithField(line.st, st);\n+    *       return l1;\n+    *    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4OTgwNg=="}, "originalCommit": {"oid": "6ca43934d5ecea4d929a00b7f7d58f479102a1ee"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzU4MTU2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDo0MzowM1rOHx9_DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTozMTo0M1rOHyAS8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE1NzgzNg==", "bodyText": "Isn't the null check done by the helper?", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r522157836", "createdAt": "2020-11-12T14:43:03Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6408,8 +6415,26 @@ TR_J9ByteCodeIlGenerator::genWithField(uint16_t fieldCpIndex)\n    }\n \n void\n-TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpIndex, TR::Node * newFieldValue, TR::Node * originalObject)\n+TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpIndex)\n    {\n+   bool isStore = false;\n+   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, fieldCpIndex, isStore);\n+   if (symRef->isUnresolved())\n+      {\n+      abortForUnresolvedValueTypeOp(\"withfield\", \"field\");\n+      }\n+\n+   TR::Node *newFieldValue = pop();\n+   TR::Node *originalObject = pop();\n+\n+   /*\n+    * Insert nullchk for the original object as requested by the JVM spec.\n+    * Especially in case of value type class with a single field, the nullchk is still\n+    * necessary even though the original object is actually not needed.\n+    */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505d1ba73b63dc8f35770717ea37eb3fbe9bd011"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5NTY5Nw==", "bodyText": "The existing code that calls genFlattenableWithFieldWithHelper happens after the nullchk as below.\nhttps://github.com/eclipse/openj9/blob/3c9c23bc68e6d882e840872845a2a8e0ed4a2d22/runtime/compiler/ilgen/Walker.cpp#L6364-L6374\nThis change moves genFlattenableWithFieldWithHelper up to L6352, to keep it function as it is today, the code between L6353-L6369 is added to genFlattenableWithFieldWithHelper", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r522195697", "createdAt": "2020-11-12T15:31:43Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6408,8 +6415,26 @@ TR_J9ByteCodeIlGenerator::genWithField(uint16_t fieldCpIndex)\n    }\n \n void\n-TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpIndex, TR::Node * newFieldValue, TR::Node * originalObject)\n+TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpIndex)\n    {\n+   bool isStore = false;\n+   TR::SymbolReference * symRef = symRefTab()->findOrCreateShadowSymbol(_methodSymbol, fieldCpIndex, isStore);\n+   if (symRef->isUnresolved())\n+      {\n+      abortForUnresolvedValueTypeOp(\"withfield\", \"field\");\n+      }\n+\n+   TR::Node *newFieldValue = pop();\n+   TR::Node *originalObject = pop();\n+\n+   /*\n+    * Insert nullchk for the original object as requested by the JVM spec.\n+    * Especially in case of value type class with a single field, the nullchk is still\n+    * necessary even though the original object is actually not needed.\n+    */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE1NzgzNg=="}, "originalCommit": {"oid": "505d1ba73b63dc8f35770717ea37eb3fbe9bd011"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzc5NTQ3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNToyNzo0OVrOHyAGYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxODoxMjowN1rOH17tqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5MjQ4Mw==", "bodyText": "this NULLCHK is redundant - could we avoid generating it if it is still being generated?", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r522192483", "createdAt": "2020-11-12T15:27:49Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6419,6 +6444,152 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value Point2D {\n+    *    public final int x;\n+    *    public final int y;\n+    * }\n+    *\n+    * value FlattenedLine2D {\n+    *    public final Point2D st;\n+    *    public final Point2D en;\n+    *\n+    *    public static FlattenedLine2D withSt(FlattenedLine2D line, Point2D st) {\n+    *       0: aload_1\n+    *       1: aload_0\n+    *       3: withfield #3 // Field st:QPoint2D;\n+    *       6: astore_2\n+    *       7: aload_2\n+    *       8: areturn\n+    *    }\n+    * }\n+    *\n+    * method=\"FlattenedLine2D.withSt(QFlattenedLine2D;QPoint2D;)QFlattenedLine2D;\"\n+    * 3: JBwithfield\n+    * /--- trees inserted ------------------------\n+    * n7n      (  0)  NULLCHK on n3n [#32]\n+    * n6n      (  2)    iloadi  Point2D.x I[#355  final Point2D.x I +4]\n+    * n3n      (  2)      aload  <parm 1 F>[#353  Parm]\n+    * n9n      (  0)  NULLCHK on n3n [#32]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505d1ba73b63dc8f35770717ea37eb3fbe9bd011"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2MTIyMA==", "bodyText": "genFlattenableWithField() uses loadInstance() to load each field. When it gets to loadInstance, it doesn't know if the nullchk has been added to the address because of the last load. To avoid the redundancy, initially I was thinking of adding an argument to loadInstance() to avoid the redundant nullchk, something like loadInstance(TR::SymbolReference * symRef, bool skipNullChk = false) and in genFlattenableWithField(), we track when to pass skipNullChk=true to loadInstance().  But this way, the API gets more complicated. Not sure if that's the route we'd prefer.", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r525561220", "createdAt": "2020-11-17T22:16:08Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6419,6 +6444,152 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value Point2D {\n+    *    public final int x;\n+    *    public final int y;\n+    * }\n+    *\n+    * value FlattenedLine2D {\n+    *    public final Point2D st;\n+    *    public final Point2D en;\n+    *\n+    *    public static FlattenedLine2D withSt(FlattenedLine2D line, Point2D st) {\n+    *       0: aload_1\n+    *       1: aload_0\n+    *       3: withfield #3 // Field st:QPoint2D;\n+    *       6: astore_2\n+    *       7: aload_2\n+    *       8: areturn\n+    *    }\n+    * }\n+    *\n+    * method=\"FlattenedLine2D.withSt(QFlattenedLine2D;QPoint2D;)QFlattenedLine2D;\"\n+    * 3: JBwithfield\n+    * /--- trees inserted ------------------------\n+    * n7n      (  0)  NULLCHK on n3n [#32]\n+    * n6n      (  2)    iloadi  Point2D.x I[#355  final Point2D.x I +4]\n+    * n3n      (  2)      aload  <parm 1 F>[#353  Parm]\n+    * n9n      (  0)  NULLCHK on n3n [#32]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5MjQ4Mw=="}, "originalCommit": {"oid": "505d1ba73b63dc8f35770717ea37eb3fbe9bd011"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI5NDQ5OQ==", "bodyText": "ok I guess we can leave it for now, but you should make sure the redundant checks are eliminated successfully by the optimizer. I agree the boolean in the API is not ideal", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r526294499", "createdAt": "2020-11-18T17:42:48Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6419,6 +6444,152 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value Point2D {\n+    *    public final int x;\n+    *    public final int y;\n+    * }\n+    *\n+    * value FlattenedLine2D {\n+    *    public final Point2D st;\n+    *    public final Point2D en;\n+    *\n+    *    public static FlattenedLine2D withSt(FlattenedLine2D line, Point2D st) {\n+    *       0: aload_1\n+    *       1: aload_0\n+    *       3: withfield #3 // Field st:QPoint2D;\n+    *       6: astore_2\n+    *       7: aload_2\n+    *       8: areturn\n+    *    }\n+    * }\n+    *\n+    * method=\"FlattenedLine2D.withSt(QFlattenedLine2D;QPoint2D;)QFlattenedLine2D;\"\n+    * 3: JBwithfield\n+    * /--- trees inserted ------------------------\n+    * n7n      (  0)  NULLCHK on n3n [#32]\n+    * n6n      (  2)    iloadi  Point2D.x I[#355  final Point2D.x I +4]\n+    * n3n      (  2)      aload  <parm 1 F>[#353  Parm]\n+    * n9n      (  0)  NULLCHK on n3n [#32]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5MjQ4Mw=="}, "originalCommit": {"oid": "505d1ba73b63dc8f35770717ea37eb3fbe9bd011"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMxNDkyMw==", "bodyText": "It looks to me the redundant nullchk is eliminated after optimization.\nn1n       BBStart <block_2> (freq 8001)                                                      \nn54n        GlRegDeps                                                                        \nn55n          aRegLoad esi   <parm 1 F>[#354  Parm] [flags 0x40000107 0x0 ] (X>=0 SeenRealReference sharedMemory ) \nn56n          aRegLoad eax   <parm 0 Q>[#353  Parm] [flags 0x40000107 0x0 ] (X>=0 SeenRealReference sharedMemory ) \nn7n       NULLCHK on n55n [#32]                                                              \nn6n         iloadi  Point2D.x I[#356  final Point2D.x I +4] [flags 0x20603 0x200 ] (cannotOverflow ) \nn55n          ==>aRegLoad\nn11n      NULLCHK on n56n [#32]                                                              \nn10n        iloadi  FlattenedLine2D.en.x I[#358  final FlattenedLine2D.en.x I +12] [flags 0x20603 0x200 ] (cannotOverflow ) \nn56n          ==>aRegLoad\nn15n      treetop                                                                            \nn14n        newvalue  jitNewValue[#100  helper Method] [flags 0x400 0x0 ] (Identityless sharedMemory ) \nn5n           loadaddr  FlattenedLine2D[#355  Static] [flags 0x18307 0x0 ]                   \nn6n           ==>iloadi\nn8n           iloadi  Point2D.y I[#357  final Point2D.y I +8] [flags 0x20603 0x200 ] (cannotOverflow ) \nn55n            ==>aRegLoad\nn10n          ==>iloadi\nn12n          iloadi  FlattenedLine2D.en.y I[#359  final FlattenedLine2D.en.y I +16] [flags 0x20603 0x200 ] (cannotOverflow ) \nn56n            ==>aRegLoad\nn18n      areturn                                                                            \nn14n        ==>newvalue\nn2n       BBEnd </block_2> =====", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r526314923", "createdAt": "2020-11-18T18:12:07Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6419,6 +6444,152 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value Point2D {\n+    *    public final int x;\n+    *    public final int y;\n+    * }\n+    *\n+    * value FlattenedLine2D {\n+    *    public final Point2D st;\n+    *    public final Point2D en;\n+    *\n+    *    public static FlattenedLine2D withSt(FlattenedLine2D line, Point2D st) {\n+    *       0: aload_1\n+    *       1: aload_0\n+    *       3: withfield #3 // Field st:QPoint2D;\n+    *       6: astore_2\n+    *       7: aload_2\n+    *       8: areturn\n+    *    }\n+    * }\n+    *\n+    * method=\"FlattenedLine2D.withSt(QFlattenedLine2D;QPoint2D;)QFlattenedLine2D;\"\n+    * 3: JBwithfield\n+    * /--- trees inserted ------------------------\n+    * n7n      (  0)  NULLCHK on n3n [#32]\n+    * n6n      (  2)    iloadi  Point2D.x I[#355  final Point2D.x I +4]\n+    * n3n      (  2)      aload  <parm 1 F>[#353  Parm]\n+    * n9n      (  0)  NULLCHK on n3n [#32]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5MjQ4Mw=="}, "originalCommit": {"oid": "505d1ba73b63dc8f35770717ea37eb3fbe9bd011"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Mzc5NjQ5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNToyODowM1rOHyAHBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjoxNjozNVrOH1NuXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5MjY0Ng==", "bodyText": "ditto", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r522192646", "createdAt": "2020-11-12T15:28:03Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6419,6 +6444,152 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value Point2D {\n+    *    public final int x;\n+    *    public final int y;\n+    * }\n+    *\n+    * value FlattenedLine2D {\n+    *    public final Point2D st;\n+    *    public final Point2D en;\n+    *\n+    *    public static FlattenedLine2D withSt(FlattenedLine2D line, Point2D st) {\n+    *       0: aload_1\n+    *       1: aload_0\n+    *       3: withfield #3 // Field st:QPoint2D;\n+    *       6: astore_2\n+    *       7: aload_2\n+    *       8: areturn\n+    *    }\n+    * }\n+    *\n+    * method=\"FlattenedLine2D.withSt(QFlattenedLine2D;QPoint2D;)QFlattenedLine2D;\"\n+    * 3: JBwithfield\n+    * /--- trees inserted ------------------------\n+    * n7n      (  0)  NULLCHK on n3n [#32]\n+    * n6n      (  2)    iloadi  Point2D.x I[#355  final Point2D.x I +4]\n+    * n3n      (  2)      aload  <parm 1 F>[#353  Parm]\n+    * n9n      (  0)  NULLCHK on n3n [#32]\n+    * n8n      (  2)    iloadi  Point2D.y I[#356  final Point2D.y I +8]\n+    * n3n      (  2)      ==>aload\n+    * n11n     (  0)  NULLCHK on n4n [#32]\n+    * n10n     (  2)    iloadi  FlattenedLine2D.en.x I[#357  final FlattenedLine2D.en.x I +12]\n+    * n4n      (  2)      aload  <parm 0 Q>[#352  Parm]\n+    * n13n     (  0)  NULLCHK on n4n [#32]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505d1ba73b63dc8f35770717ea37eb3fbe9bd011"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2MTQzOQ==", "bodyText": "Explained on the above", "url": "https://github.com/eclipse-openj9/openj9/pull/10406#discussion_r525561439", "createdAt": "2020-11-17T22:16:35Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6419,6 +6444,152 @@ TR_J9ByteCodeIlGenerator::genFlattenableWithFieldWithHelper(uint16_t fieldCpInde\n    push(helperCallNode);\n    }\n \n+static TR::SymbolReference * createLoadFieldSymRef(TR::Compilation * comp, TR_OpaqueClassBlock * fieldClass, const char * fieldname)\n+   {\n+   const TR::TypeLayout *fieldClassLayout = comp->typeLayout(fieldClass);\n+   size_t fieldClassFieldCount = fieldClassLayout->count();\n+\n+   for (size_t idx = 0; idx < fieldClassFieldCount; idx++)\n+      {\n+      const TR::TypeLayoutEntry &fieldEntry = fieldClassLayout->entry(idx);\n+      if (!strcmp(fieldname, fieldEntry._fieldname))\n+         {\n+         auto * fieldSymRef = comp->getSymRefTab()->findOrFabricateShadowSymbol(fieldClass,\n+                                                                              fieldEntry._datatype,\n+                                                                              fieldEntry._offset,\n+                                                                              fieldEntry._isVolatile,\n+                                                                              fieldEntry._isPrivate,\n+                                                                              fieldEntry._isFinal,\n+                                                                              fieldEntry._fieldname,\n+                                                                              fieldEntry._typeSignature\n+                                                                              );\n+         return fieldSymRef;\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(false, \"Did not find the matching fieldname %s\", fieldname);\n+   return NULL;\n+   }\n+\n+void\n+TR_J9ByteCodeIlGenerator::genFlattenableWithField(uint16_t fieldCpIndex, TR_OpaqueClassBlock * valueClass)\n+   {\n+   /* An example on what the tree with flattened fields would look like\n+    *\n+    * value Point2D {\n+    *    public final int x;\n+    *    public final int y;\n+    * }\n+    *\n+    * value FlattenedLine2D {\n+    *    public final Point2D st;\n+    *    public final Point2D en;\n+    *\n+    *    public static FlattenedLine2D withSt(FlattenedLine2D line, Point2D st) {\n+    *       0: aload_1\n+    *       1: aload_0\n+    *       3: withfield #3 // Field st:QPoint2D;\n+    *       6: astore_2\n+    *       7: aload_2\n+    *       8: areturn\n+    *    }\n+    * }\n+    *\n+    * method=\"FlattenedLine2D.withSt(QFlattenedLine2D;QPoint2D;)QFlattenedLine2D;\"\n+    * 3: JBwithfield\n+    * /--- trees inserted ------------------------\n+    * n7n      (  0)  NULLCHK on n3n [#32]\n+    * n6n      (  2)    iloadi  Point2D.x I[#355  final Point2D.x I +4]\n+    * n3n      (  2)      aload  <parm 1 F>[#353  Parm]\n+    * n9n      (  0)  NULLCHK on n3n [#32]\n+    * n8n      (  2)    iloadi  Point2D.y I[#356  final Point2D.y I +8]\n+    * n3n      (  2)      ==>aload\n+    * n11n     (  0)  NULLCHK on n4n [#32]\n+    * n10n     (  2)    iloadi  FlattenedLine2D.en.x I[#357  final FlattenedLine2D.en.x I +12]\n+    * n4n      (  2)      aload  <parm 0 Q>[#352  Parm]\n+    * n13n     (  0)  NULLCHK on n4n [#32]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5MjY0Ng=="}, "originalCommit": {"oid": "505d1ba73b63dc8f35770717ea37eb3fbe9bd011"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4707, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}