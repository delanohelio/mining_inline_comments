{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNTYwMDk2", "number": 11051, "title": "Add Dynamic Breadth First Scan Ordering to Balanced GC", "bodyText": "Add a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced GC policy.\nIssue: #7552\nSigned-off-by: Jonathan Oommen jon.oommen@gmail.com", "createdAt": "2020-10-29T20:53:12Z", "url": "https://github.com/eclipse-openj9/openj9/pull/11051", "merged": true, "mergeCommit": {"oid": "bf729d3b62a85edb0357d2c38ef304a593460a64"}, "closed": true, "closedAt": "2020-11-27T19:27:07Z", "author": {"login": "jonoommen"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXYrCAgBqjM5Mzg0MjUzMjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdgEU2EAFqTUzODgyNTI4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "233fca6a21d5d75401f7b783166bfa4aa1715dc9", "author": {"user": {"login": "jonoommen", "name": "Jon Oommen"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/233fca6a21d5d75401f7b783166bfa4aa1715dc9", "committedDate": "2020-10-28T21:35:14Z", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen jon.oommen@gmail.com"}, "afterCommit": {"oid": "ae3fb2abdeb9e56e73b3238989914fd0885847cb", "author": {"user": {"login": "jonoommen", "name": "Jon Oommen"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ae3fb2abdeb9e56e73b3238989914fd0885847cb", "committedDate": "2020-10-29T21:01:09Z", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae3fb2abdeb9e56e73b3238989914fd0885847cb", "author": {"user": {"login": "jonoommen", "name": "Jon Oommen"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/ae3fb2abdeb9e56e73b3238989914fd0885847cb", "committedDate": "2020-10-29T21:01:09Z", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>"}, "afterCommit": {"oid": "f4d59d9e6896cabb34c4fb74dd2632fe5accd7bb", "author": {"user": {"login": "jonoommen", "name": "Jon Oommen"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f4d59d9e6896cabb34c4fb74dd2632fe5accd7bb", "committedDate": "2020-11-12T15:30:23Z", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNDY1OTYz", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-531465963", "createdAt": "2020-11-16T16:04:22Z", "commit": {"oid": "f4d59d9e6896cabb34c4fb74dd2632fe5accd7bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNjowNDoyM1rOH0Fsbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNjowNDoyM1rOH0Fsbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MTI5NA==", "bodyText": "We should share this sorting code with Scavenger(Delegate).\nWe could also move it to core VM, and pass a few GC specific parameters from GC Extensions through method arguments.\n@dmitripivkine do you have a preference if this should stay in GC or VM?", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r524381294", "createdAt": "2020-11-16T16:04:23Z", "author": {"login": "amicic"}, "path": "runtime/gc_vlhgc/CopyForwardScheme.cpp", "diffHunk": "@@ -1452,6 +1463,92 @@ MM_CopyForwardScheme::mainSetupForCopyForward(MM_EnvironmentVLHGC *env)\n \t_shouldScanFinalizableObjects = _extensions->finalizeListManager->isFinalizableObjectProcessingRequired();\n }\n \n+void\n+MM_CopyForwardScheme::sortAllHotFieldData()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d59d9e6896cabb34c4fb74dd2632fe5accd7bb"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTMzODU0", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-531533854", "createdAt": "2020-11-16T17:14:32Z", "commit": {"oid": "f4d59d9e6896cabb34c4fb74dd2632fe5accd7bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNzoxNDozM1rOH0JCUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNzoxNDozM1rOH0JCUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzNjA0OA==", "bodyText": "this should probably move together with sorting code", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r524436048", "createdAt": "2020-11-16T17:14:33Z", "author": {"login": "amicic"}, "path": "runtime/vm/jvmfree.c", "diffHunk": "@@ -341,6 +341,31 @@ freeJ9Module(J9JavaVM *javaVM, J9Module *j9module) {\n \tTrc_MODULE_freeJ9Module_exit(j9module);\n }\n \n+/**\n+ * Reset all hot fields for all classes.\n+ * Used when scavenger dynamicBreadthFirstScanOrdering is enabled and hotFieldResettingEnabled is true.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ */\n+void\n+resetAllHotFieldData(J9JavaVM *javaVM)\n+{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4d59d9e6896cabb34c4fb74dd2632fe5accd7bb"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzYyNDU3", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-532762457", "createdAt": "2020-11-17T19:59:10Z", "commit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOTo1OToxMFrOH1HyeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOTo1OToxMFrOH1HyeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NDE4NA==", "bodyText": "It's enough to just pass Ext - you can get JavaVM from there.", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525464184", "createdAt": "2020-11-17T19:59:10Z", "author": {"login": "amicic"}, "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzYzMjAx", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-532763201", "createdAt": "2020-11-17T20:00:10Z", "commit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowMDoxMVrOH1H3Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowMDoxMVrOH1H3Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NTQyNw==", "bodyText": "a file needs to finish with an empty line", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525465427", "createdAt": "2020-11-17T20:00:11Z", "author": {"login": "amicic"}, "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif ((NULL != javaVM->hotFieldClassInfoPool) && ((extensions->scavengerStats._gcCount  % extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;\n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_startDo(javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile ((NULL != hotFieldClassInfoTemp) && (U_8_MAX != hotFieldClassInfoTemp->consecutiveHotFieldSelections)) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tsortClassHotFieldList(hotFieldClassInfoTemp, extensions);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif ((extensions->adaptiveGcCountBetweenHotFieldSort) && (extensions->gcCountBetweenHotFieldSort < extensions->gcCountBetweenHotFieldSortMax) && ((extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT) == 0)) {\n+\t\textensions->gcCountBetweenHotFieldSort++;\n+\t}\n+\t/* If hotFieldResettingEnabled, update the gc count required between resetting all hot fields */\n+\tif ((extensions->hotFieldResettingEnabled) && ((extensions->scavengerStats._gcCount % extensions->gcCountBetweenHotFieldReset) == 0)) {\n+\t\tresetAllHotFieldData(javaVM);\n+\t}\n+}\n+\n+MMINLINE void\n+MM_HotFieldUtil::sortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo, MM_GCExtensions *extensions) {\n+\t/* store initial hot field offsets before hotFieldClassInfo hot field offsets are updated */\n+\tuint8_t initialHotFieldOffset1 = hotFieldClassInfo->hotFieldOffset1;\n+\tuint8_t initialHotFieldOffset2 = hotFieldClassInfo->hotFieldOffset2;\n+\tuint8_t initialHotFieldOffset3 = hotFieldClassInfo->hotFieldOffset3;\n+\n+\t/* compute and update the hot fields for each class */\n+\tif (1 == hotFieldClassInfo->hotFieldListLength) {\n+\t\thotFieldClassInfo->hotFieldOffset1 = hotFieldClassInfo->hotFieldListHead->hotFieldOffset;\n+\t} else {\n+\t\tJ9HotField* currentHotField = hotFieldClassInfo->hotFieldListHead;\n+\t\tuint64_t hottest = 0;\n+\t\tuint64_t secondHottest = 0;\n+\t\tuint64_t thirdHottest = 0;\n+\t\tuint64_t current = 0;\n+\t\twhile (NULL != currentHotField) {\n+\t\t\tif(currentHotField->cpuUtil > extensions->minCpuUtil) {\n+\t\t\t\tcurrent = currentHotField->hotness;\n+\t\t\t\t/* compute the three hottest fields if depthCopyThreePaths is enabled, or the two hottest fields if only depthCopyTwoPaths is enabled, otherwise, compute just the hottest field if both depthCopyTwoPaths and depthCopyThreePaths are disabled */\n+\t\t\t\tif (extensions->depthCopyThreePaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t} else if (current > thirdHottest) {\n+\t\t\t\t\t\tthirdHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (extensions->depthCopyTwoPaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t}\n+\t\t\t\t} else if (current > hottest) {\n+\t\t\t\t\thottest = current;\n+\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcurrentHotField = currentHotField->next;\n+\t\t}\n+\t\tif (thirdHottest < MINIMUM_THIRD_HOT_FIELD_HOTNESS) { \n+\t\t\thotFieldClassInfo->hotFieldOffset3 = U_8_MAX;\n+\t\t}\n+\t}\n+\t/* if permanantHotFields are allowed, update consecutiveHotFieldSelections counter if hot field offsets are the same as the previous time the class hot field list was sorted  */\n+\tif (extensions->allowPermanantHotFields) {\n+\t\tif ((initialHotFieldOffset1 == hotFieldClassInfo->hotFieldOffset1) && (initialHotFieldOffset2 == hotFieldClassInfo->hotFieldOffset2) && (initialHotFieldOffset3 == hotFieldClassInfo->hotFieldOffset3)) {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections++;\n+\t\t\tif (hotFieldClassInfo->consecutiveHotFieldSelections == extensions->maxConsecutiveHotFieldSelections) { \n+\t\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = U_8_MAX;\n+\t\t\t}\n+\t\t} else {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = 0;\n+\t\t}\n+\t}\n+\thotFieldClassInfo->isClassHotFieldListDirty = false;\n+}\n+\n+/**\n+ * Reset all hot fields for all classes.\n+ * Used when dynamicBreadthFirstScanOrdering is enabled and hotFieldResettingEnabled is true.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ */\n+MMINLINE void\n+MM_HotFieldUtil::resetAllHotFieldData(J9JavaVM *javaVM)\n+{\n+\tpool_state hotFieldClassInfoPoolState;\n+\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;\n+\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo *)pool_startDo(javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\twhile (NULL != hotFieldClassInfoTemp) {\n+\t\tJ9HotField* currentHotField = hotFieldClassInfoTemp->hotFieldListHead;\n+\t\twhile (NULL != currentHotField) {\n+\t\t\tcurrentHotField->hotness = 0;\n+\t\t\tcurrentHotField->cpuUtil = 0;\n+\t\t\tcurrentHotField = currentHotField->next;\n+\t\t}\n+\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t}\n+\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+}\n+\n+#endif /* J9VM_GC_MODRON_SCAVENGER || J9VM_GC_VLHGC */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "originalPosition": 163}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzYzODYy", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-532763862", "createdAt": "2020-11-17T20:01:02Z", "commit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowMTowMlrOH1H7Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowMTowMlrOH1H7Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NjQ0Ng==", "bodyText": "move the declaration down, where you initialize it", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525466446", "createdAt": "2020-11-17T20:01:02Z", "author": {"login": "amicic"}, "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif ((NULL != javaVM->hotFieldClassInfoPool) && ((extensions->scavengerStats._gcCount  % extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzY0NjY3", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-532764667", "createdAt": "2020-11-17T20:02:04Z", "commit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowMjowNVrOH1IACg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowMjowNVrOH1IACg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ2NzY1OA==", "bodyText": "move declaration down", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525467658", "createdAt": "2020-11-17T20:02:05Z", "author": {"login": "amicic"}, "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif ((NULL != javaVM->hotFieldClassInfoPool) && ((extensions->scavengerStats._gcCount  % extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;\n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_startDo(javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile ((NULL != hotFieldClassInfoTemp) && (U_8_MAX != hotFieldClassInfoTemp->consecutiveHotFieldSelections)) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tsortClassHotFieldList(hotFieldClassInfoTemp, extensions);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif ((extensions->adaptiveGcCountBetweenHotFieldSort) && (extensions->gcCountBetweenHotFieldSort < extensions->gcCountBetweenHotFieldSortMax) && ((extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT) == 0)) {\n+\t\textensions->gcCountBetweenHotFieldSort++;\n+\t}\n+\t/* If hotFieldResettingEnabled, update the gc count required between resetting all hot fields */\n+\tif ((extensions->hotFieldResettingEnabled) && ((extensions->scavengerStats._gcCount % extensions->gcCountBetweenHotFieldReset) == 0)) {\n+\t\tresetAllHotFieldData(javaVM);\n+\t}\n+}\n+\n+MMINLINE void\n+MM_HotFieldUtil::sortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo, MM_GCExtensions *extensions) {\n+\t/* store initial hot field offsets before hotFieldClassInfo hot field offsets are updated */\n+\tuint8_t initialHotFieldOffset1 = hotFieldClassInfo->hotFieldOffset1;\n+\tuint8_t initialHotFieldOffset2 = hotFieldClassInfo->hotFieldOffset2;\n+\tuint8_t initialHotFieldOffset3 = hotFieldClassInfo->hotFieldOffset3;\n+\n+\t/* compute and update the hot fields for each class */\n+\tif (1 == hotFieldClassInfo->hotFieldListLength) {\n+\t\thotFieldClassInfo->hotFieldOffset1 = hotFieldClassInfo->hotFieldListHead->hotFieldOffset;\n+\t} else {\n+\t\tJ9HotField* currentHotField = hotFieldClassInfo->hotFieldListHead;\n+\t\tuint64_t hottest = 0;\n+\t\tuint64_t secondHottest = 0;\n+\t\tuint64_t thirdHottest = 0;\n+\t\tuint64_t current = 0;\n+\t\twhile (NULL != currentHotField) {\n+\t\t\tif(currentHotField->cpuUtil > extensions->minCpuUtil) {\n+\t\t\t\tcurrent = currentHotField->hotness;\n+\t\t\t\t/* compute the three hottest fields if depthCopyThreePaths is enabled, or the two hottest fields if only depthCopyTwoPaths is enabled, otherwise, compute just the hottest field if both depthCopyTwoPaths and depthCopyThreePaths are disabled */\n+\t\t\t\tif (extensions->depthCopyThreePaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t} else if (current > thirdHottest) {\n+\t\t\t\t\t\tthirdHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (extensions->depthCopyTwoPaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t}\n+\t\t\t\t} else if (current > hottest) {\n+\t\t\t\t\thottest = current;\n+\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcurrentHotField = currentHotField->next;\n+\t\t}\n+\t\tif (thirdHottest < MINIMUM_THIRD_HOT_FIELD_HOTNESS) { \n+\t\t\thotFieldClassInfo->hotFieldOffset3 = U_8_MAX;\n+\t\t}\n+\t}\n+\t/* if permanantHotFields are allowed, update consecutiveHotFieldSelections counter if hot field offsets are the same as the previous time the class hot field list was sorted  */\n+\tif (extensions->allowPermanantHotFields) {\n+\t\tif ((initialHotFieldOffset1 == hotFieldClassInfo->hotFieldOffset1) && (initialHotFieldOffset2 == hotFieldClassInfo->hotFieldOffset2) && (initialHotFieldOffset3 == hotFieldClassInfo->hotFieldOffset3)) {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections++;\n+\t\t\tif (hotFieldClassInfo->consecutiveHotFieldSelections == extensions->maxConsecutiveHotFieldSelections) { \n+\t\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = U_8_MAX;\n+\t\t\t}\n+\t\t} else {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = 0;\n+\t\t}\n+\t}\n+\thotFieldClassInfo->isClassHotFieldListDirty = false;\n+}\n+\n+/**\n+ * Reset all hot fields for all classes.\n+ * Used when dynamicBreadthFirstScanOrdering is enabled and hotFieldResettingEnabled is true.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ */\n+MMINLINE void\n+MM_HotFieldUtil::resetAllHotFieldData(J9JavaVM *javaVM)\n+{\n+\tpool_state hotFieldClassInfoPoolState;\n+\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "originalPosition": 148}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzY3ODI1", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-532767825", "createdAt": "2020-11-17T20:06:20Z", "commit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowNjoyMVrOH1IULw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowNjoyMVrOH1IULw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ3MjgxNQ==", "bodyText": "could've been just plain C methods without a class. not a strong preference, so you can leave it as is (@dmitripivkine do you prefer one or the other?)", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525472815", "createdAt": "2020-11-17T20:06:21Z", "author": {"login": "amicic"}, "path": "runtime/gc_base/HotFieldUtil.hpp", "diffHunk": "@@ -0,0 +1,69 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+/**\n+ * @file\n+ * @ingroup GC_Base\n+ */\n+\n+#if !defined(HOTFIELDUTIL_HPP_)\n+#define HOTFIELDUTIL_HPP_\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"BaseNonVirtual.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+\n+/**\n+ * @todo Provide class documentation\n+ * @ingroup GC_Base\n+ */\n+class MM_HotFieldUtil : public MM_BaseNonVirtual\n+{\n+public:\n+    /**\n+\t * Sort all hot fields for all classes.\n+\t * Used when scavenger dynamicBreadthFirstScanOrdering is enabled\n+\t */\n+\tstatic void sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions);\n+\n+\t/**\n+\t * Sort all hot fields for a single class.\n+\t * Used when scavenger dynamicBreadthFirstScanOrdering is enabled\n+\t */\n+\tMMINLINE static void sortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo, MM_GCExtensions *extensions);\n+\n+\t/**\n+\t * Reset all hot fields for all classes.\n+\t * Used when scavenger dynamicBreadthFirstScanOrdering is enabled and hotFieldResettingEnabled is true.\n+\t *\n+\t * @param javaVM[in] pointer to the J9JavaVM\n+\t */\n+\tMMINLINE static void resetAllHotFieldData(J9JavaVM *javaVM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzY4Mjk2", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-532768296", "createdAt": "2020-11-17T20:06:58Z", "commit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowNjo1OFrOH1IXDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowNjo1OFrOH1IXDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ3MzU0OQ==", "bodyText": "put Ext as first arg", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525473549", "createdAt": "2020-11-17T20:06:58Z", "author": {"login": "amicic"}, "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif ((NULL != javaVM->hotFieldClassInfoPool) && ((extensions->scavengerStats._gcCount  % extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;\n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_startDo(javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile ((NULL != hotFieldClassInfoTemp) && (U_8_MAX != hotFieldClassInfoTemp->consecutiveHotFieldSelections)) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tsortClassHotFieldList(hotFieldClassInfoTemp, extensions);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif ((extensions->adaptiveGcCountBetweenHotFieldSort) && (extensions->gcCountBetweenHotFieldSort < extensions->gcCountBetweenHotFieldSortMax) && ((extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT) == 0)) {\n+\t\textensions->gcCountBetweenHotFieldSort++;\n+\t}\n+\t/* If hotFieldResettingEnabled, update the gc count required between resetting all hot fields */\n+\tif ((extensions->hotFieldResettingEnabled) && ((extensions->scavengerStats._gcCount % extensions->gcCountBetweenHotFieldReset) == 0)) {\n+\t\tresetAllHotFieldData(javaVM);\n+\t}\n+}\n+\n+MMINLINE void\n+MM_HotFieldUtil::sortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo, MM_GCExtensions *extensions) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzY4Nzc4", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-532768778", "createdAt": "2020-11-17T20:07:38Z", "commit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowNzozOFrOH1IaJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDowNzozOFrOH1IaJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ3NDM0Mw==", "bodyText": "to be more consistent with other methods, you can pass Ext", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525474343", "createdAt": "2020-11-17T20:07:38Z", "author": {"login": "amicic"}, "path": "runtime/gc_base/HotFieldUtil.cpp", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+\n+#include \"j9.h\"\n+#include \"j9cfg.h\"\n+\n+#if defined(J9VM_GC_MODRON_SCAVENGER) || defined(J9VM_GC_VLHGC)\n+\n+#include \"HotFieldUtil.hpp\"\n+#include \"GCExtensions.hpp\"\n+\n+/* Value used to help with the incrementing of the gc count between hot field sorting for dynamicBreadthFirstScanOrdering */\n+#define INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT 100\n+\n+/* Minimum hotness value for a third hot field offset if depthCopyThreePaths is enabled for dynamicBreadthFirstScanOrdering */\n+#define MINIMUM_THIRD_HOT_FIELD_HOTNESS 50000\n+\n+void\n+MM_HotFieldUtil::sortAllHotFieldData(J9JavaVM *javaVM, MM_GCExtensions *extensions)\n+{\t\n+\t/* update hottest fields for all elements of the hotFieldClassInfoPool where isClassHotFieldListDirty is true */\n+\tif ((NULL != javaVM->hotFieldClassInfoPool) && ((extensions->scavengerStats._gcCount  % extensions->gcCountBetweenHotFieldSort) == 0)) {\n+\t\tpool_state hotFieldClassInfoPoolState;\n+\t\tJ9ClassHotFieldsInfo *hotFieldClassInfoTemp;\n+\t\tomrthread_monitor_enter(javaVM->hotFieldClassInfoPoolMutex);\n+\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_startDo(javaVM->hotFieldClassInfoPool, &hotFieldClassInfoPoolState);\n+\t\t\n+\t\t/* sort hot field list for the class if the hot field list of the class is dirty */\n+\t\twhile ((NULL != hotFieldClassInfoTemp) && (U_8_MAX != hotFieldClassInfoTemp->consecutiveHotFieldSelections)) {\n+\t\t\tif (hotFieldClassInfoTemp->isClassHotFieldListDirty) {\n+\t\t\t\tsortClassHotFieldList(hotFieldClassInfoTemp, extensions);\n+\t\t\t}\n+\t\t\thotFieldClassInfoTemp = (struct J9ClassHotFieldsInfo*)pool_nextDo(&hotFieldClassInfoPoolState);\n+\t\t}\n+\t\tomrthread_monitor_exit(javaVM->hotFieldClassInfoPoolMutex);\n+\t}\n+\t/* If adaptiveGcCountBetweenHotFieldSort, update the gc count required between sorting all hot fields as the application runs longer */\n+\tif ((extensions->adaptiveGcCountBetweenHotFieldSort) && (extensions->gcCountBetweenHotFieldSort < extensions->gcCountBetweenHotFieldSortMax) && ((extensions->scavengerStats._gcCount % INCREMENT_GC_COUNT_BETWEEN_HOT_FIELD_SORT) == 0)) {\n+\t\textensions->gcCountBetweenHotFieldSort++;\n+\t}\n+\t/* If hotFieldResettingEnabled, update the gc count required between resetting all hot fields */\n+\tif ((extensions->hotFieldResettingEnabled) && ((extensions->scavengerStats._gcCount % extensions->gcCountBetweenHotFieldReset) == 0)) {\n+\t\tresetAllHotFieldData(javaVM);\n+\t}\n+}\n+\n+MMINLINE void\n+MM_HotFieldUtil::sortClassHotFieldList(J9ClassHotFieldsInfo* hotFieldClassInfo, MM_GCExtensions *extensions) {\n+\t/* store initial hot field offsets before hotFieldClassInfo hot field offsets are updated */\n+\tuint8_t initialHotFieldOffset1 = hotFieldClassInfo->hotFieldOffset1;\n+\tuint8_t initialHotFieldOffset2 = hotFieldClassInfo->hotFieldOffset2;\n+\tuint8_t initialHotFieldOffset3 = hotFieldClassInfo->hotFieldOffset3;\n+\n+\t/* compute and update the hot fields for each class */\n+\tif (1 == hotFieldClassInfo->hotFieldListLength) {\n+\t\thotFieldClassInfo->hotFieldOffset1 = hotFieldClassInfo->hotFieldListHead->hotFieldOffset;\n+\t} else {\n+\t\tJ9HotField* currentHotField = hotFieldClassInfo->hotFieldListHead;\n+\t\tuint64_t hottest = 0;\n+\t\tuint64_t secondHottest = 0;\n+\t\tuint64_t thirdHottest = 0;\n+\t\tuint64_t current = 0;\n+\t\twhile (NULL != currentHotField) {\n+\t\t\tif(currentHotField->cpuUtil > extensions->minCpuUtil) {\n+\t\t\t\tcurrent = currentHotField->hotness;\n+\t\t\t\t/* compute the three hottest fields if depthCopyThreePaths is enabled, or the two hottest fields if only depthCopyTwoPaths is enabled, otherwise, compute just the hottest field if both depthCopyTwoPaths and depthCopyThreePaths are disabled */\n+\t\t\t\tif (extensions->depthCopyThreePaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tthirdHottest = secondHottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = hotFieldClassInfo->hotFieldOffset2;\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t} else if (current > thirdHottest) {\n+\t\t\t\t\t\tthirdHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset3 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (extensions->depthCopyTwoPaths) {\n+\t\t\t\t\tif (current > hottest) {\n+\t\t\t\t\t\tsecondHottest = hottest;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = hotFieldClassInfo->hotFieldOffset1;\n+\t\t\t\t\t\thottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t\t} else if (current > secondHottest) {\n+\t\t\t\t\t\tsecondHottest = current;\n+\t\t\t\t\t\thotFieldClassInfo->hotFieldOffset2 = currentHotField->hotFieldOffset;\t\t\n+\t\t\t\t\t}\n+\t\t\t\t} else if (current > hottest) {\n+\t\t\t\t\thottest = current;\n+\t\t\t\t\thotFieldClassInfo->hotFieldOffset1 = currentHotField->hotFieldOffset;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcurrentHotField = currentHotField->next;\n+\t\t}\n+\t\tif (thirdHottest < MINIMUM_THIRD_HOT_FIELD_HOTNESS) { \n+\t\t\thotFieldClassInfo->hotFieldOffset3 = U_8_MAX;\n+\t\t}\n+\t}\n+\t/* if permanantHotFields are allowed, update consecutiveHotFieldSelections counter if hot field offsets are the same as the previous time the class hot field list was sorted  */\n+\tif (extensions->allowPermanantHotFields) {\n+\t\tif ((initialHotFieldOffset1 == hotFieldClassInfo->hotFieldOffset1) && (initialHotFieldOffset2 == hotFieldClassInfo->hotFieldOffset2) && (initialHotFieldOffset3 == hotFieldClassInfo->hotFieldOffset3)) {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections++;\n+\t\t\tif (hotFieldClassInfo->consecutiveHotFieldSelections == extensions->maxConsecutiveHotFieldSelections) { \n+\t\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = U_8_MAX;\n+\t\t\t}\n+\t\t} else {\n+\t\t\thotFieldClassInfo->consecutiveHotFieldSelections = 0;\n+\t\t}\n+\t}\n+\thotFieldClassInfo->isClassHotFieldListDirty = false;\n+}\n+\n+/**\n+ * Reset all hot fields for all classes.\n+ * Used when dynamicBreadthFirstScanOrdering is enabled and hotFieldResettingEnabled is true.\n+ *\n+ * @param javaVM[in] pointer to the J9JavaVM\n+ */\n+MMINLINE void\n+MM_HotFieldUtil::resetAllHotFieldData(J9JavaVM *javaVM)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ae5112182a5331b7bfa2b4fa7bfa8e288bdb49"}, "originalPosition": 145}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzgwODU1", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-532780855", "createdAt": "2020-11-17T20:24:24Z", "commit": {"oid": "e1aea6ba0a805778b85f0db15246c9ecdf627794"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNDoyNFrOH1Jowg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNDoyNFrOH1Jowg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NDQ2Ng==", "bodyText": "I don't think we need to change anything here, until we enable dynamic ordering by default.", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525494466", "createdAt": "2020-11-17T20:24:24Z", "author": {"login": "amicic"}, "path": "runtime/gc_vlhgc/ConfigurationIncrementalGenerational.cpp", "diffHunk": "@@ -272,8 +272,16 @@ MM_ConfigurationIncrementalGenerational::initialize(MM_EnvironmentBase *env)\n \n \tbool result = MM_Configuration::initialize(env);\n \n+\t/* By default disable hot field depth copying */\n+\tenv->disableHotFieldDepthCopy();\n+\n \tif (result) {\n-\t\textensions->scavengerScanOrdering = MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_BREADTH_FIRST;\n+\t\tif (extensions->scavengerScanOrdering != MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_DYNAMIC_BREADTH_FIRST) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1aea6ba0a805778b85f0db15246c9ecdf627794"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzgxODcw", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-532781870", "createdAt": "2020-11-17T20:25:44Z", "commit": {"oid": "e1aea6ba0a805778b85f0db15246c9ecdf627794"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNTo0NFrOH1JvgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDoyNTo0NFrOH1JvgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NjE5Mg==", "bodyText": "Do we really have to force disabling of these two flags - what bad can happen if somebody enables them through an option?", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r525496192", "createdAt": "2020-11-17T20:25:44Z", "author": {"login": "amicic"}, "path": "runtime/gc_vlhgc/ConfigurationIncrementalGenerational.cpp", "diffHunk": "@@ -272,8 +272,16 @@ MM_ConfigurationIncrementalGenerational::initialize(MM_EnvironmentBase *env)\n \n \tbool result = MM_Configuration::initialize(env);\n \n+\t/* By default disable hot field depth copying */\n+\tenv->disableHotFieldDepthCopy();\n+\n \tif (result) {\n-\t\textensions->scavengerScanOrdering = MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_BREADTH_FIRST;\n+\t\tif (extensions->scavengerScanOrdering != MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_DYNAMIC_BREADTH_FIRST) {\n+\t\t\textensions->scavengerScanOrdering = MM_GCExtensions::OMR_GC_SCAVENGER_SCANORDERING_BREADTH_FIRST;\n+\t\t} else {\n+\t\t\textensions->adaptiveGcCountBetweenHotFieldSort = false;\n+\t\t\textensions->hotFieldResettingEnabled = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1aea6ba0a805778b85f0db15246c9ecdf627794"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3b97973c7fcf2f758426333d4c747fc0abb51608", "author": {"user": {"login": "jonoommen", "name": "Jon Oommen"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3b97973c7fcf2f758426333d4c747fc0abb51608", "committedDate": "2020-11-18T17:50:37Z", "message": "disable adaptiveGcCountBetweenHotFieldSort"}, "afterCommit": {"oid": "0ab7051b3baff2ba6d5a6acbb62bc6548eb9f547", "author": {"user": {"login": "jonoommen", "name": "Jon Oommen"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0ab7051b3baff2ba6d5a6acbb62bc6548eb9f547", "committedDate": "2020-11-19T19:25:59Z", "message": "disable adaptiveGcCountBetweenHotFieldSort"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0ab7051b3baff2ba6d5a6acbb62bc6548eb9f547", "author": {"user": {"login": "jonoommen", "name": "Jon Oommen"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/0ab7051b3baff2ba6d5a6acbb62bc6548eb9f547", "committedDate": "2020-11-19T19:25:59Z", "message": "disable adaptiveGcCountBetweenHotFieldSort"}, "afterCommit": {"oid": "187929992bd296659245ca55d2bf57c2ff9fb90b", "author": {"user": {"login": "jonoommen", "name": "Jon Oommen"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/187929992bd296659245ca55d2bf57c2ff9fb90b", "committedDate": "2020-11-25T16:35:23Z", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4Njk1MTU0", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-538695154", "createdAt": "2020-11-25T17:00:02Z", "commit": {"oid": "187929992bd296659245ca55d2bf57c2ff9fb90b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzowMDowMlrOH58eWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzowMDowMlrOH58eWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMTY5MQ==", "bodyText": "use C style comment", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#discussion_r530521691", "createdAt": "2020-11-25T17:00:02Z", "author": {"login": "amicic"}, "path": "runtime/gc_vlhgc/CopyForwardScheme.cpp", "diffHunk": "@@ -2096,6 +2107,43 @@ MM_CopyForwardScheme::updateInternalLeafPointersAfterCopy(J9IndexableObject *des\n \t}\n }\n \n+MMINLINE void\n+MM_CopyForwardScheme::depthCopyHotFields(MM_EnvironmentVLHGC *env, J9Class *clazz, J9Object *destinationObjectPtr, MM_AllocationContextTarok *reservingContext) {\n+\t/* depth copy the hot fields of an object up to a depth specified by depthCopyMax */\n+\tJ9ClassHotFieldsInfo* hotFieldsInfo = clazz->hotFieldsInfo;\n+\tif (env->_hotFieldCopyDepthCount < _extensions->depthCopyMax && NULL != hotFieldsInfo) {\n+\t\tU_8 hotFieldOffset = hotFieldsInfo->hotFieldOffset1;\n+\t\tif (U_8_MAX != hotFieldOffset) {\n+\t\t\tcopyHotField(env, destinationObjectPtr, hotFieldOffset, reservingContext);\n+\t\t\tU_8 hotFieldOffset2 = hotFieldsInfo->hotFieldOffset2;\n+\t\t\tif (U_8_MAX !=hotFieldOffset2) {\n+\t\t\t\tcopyHotField(env, destinationObjectPtr, hotFieldOffset2, reservingContext);\n+\t\t\t\tU_8 hotFieldOffset3 = hotFieldsInfo->hotFieldOffset3;\n+\t\t\t\tif (U_8_MAX != hotFieldOffset3) {\n+\t\t\t\t\tcopyHotField(env, destinationObjectPtr, hotFieldOffset3, reservingContext);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else if ((_extensions->alwaysDepthCopyFirstOffset) && (false == _extensions->objectModel.isIndexable(destinationObjectPtr))) {\n+\t\t\tcopyHotField(env, destinationObjectPtr, DEFAULT_HOT_FIELD_OFFSET, reservingContext);\n+\t\t}\n+\t}\t\n+}\n+\n+MMINLINE void\n+MM_CopyForwardScheme::copyHotField(MM_EnvironmentVLHGC *env, J9Object *destinationObjectPtr, U_8 offset, MM_AllocationContextTarok *reservingContext) {\n+\tGC_SlotObject hotFieldObject(_javaVM->omrVM, (fomrobject_t*)(destinationObjectPtr + offset));\n+\tomrobjectptr_t objectPtr = hotFieldObject.readReferenceFromSlot();\t\t\t\t\t\t\t\n+\tif (isObjectInEvacuateMemory(objectPtr)) {\n+\t\t// Hot field needs to be copy and forwarded.  Check if the work has already been done", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "187929992bd296659245ca55d2bf57c2ff9fb90b"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "221774d8125af8af4df4b3f035b0762eeb95fc97", "author": {"user": {"login": "jonoommen", "name": "Jon Oommen"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/221774d8125af8af4df4b3f035b0762eeb95fc97", "committedDate": "2020-11-25T17:39:20Z", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "187929992bd296659245ca55d2bf57c2ff9fb90b", "author": {"user": {"login": "jonoommen", "name": "Jon Oommen"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/187929992bd296659245ca55d2bf57c2ff9fb90b", "committedDate": "2020-11-25T16:35:23Z", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>"}, "afterCommit": {"oid": "221774d8125af8af4df4b3f035b0762eeb95fc97", "author": {"user": {"login": "jonoommen", "name": "Jon Oommen"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/221774d8125af8af4df4b3f035b0762eeb95fc97", "committedDate": "2020-11-25T17:39:20Z", "message": "Add Dynamic Breadth First Scan Ordering to Balanced GC\n\nAdd a gc scavenger scan ordering feature that enables the\ncopying of a hot field marked by the JIT immediately after the\nobject containing the hot field is copied for balanced gc policy.\n\nSigned-off-by: Jonathan Oommen <jon.oommen@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NzI2Njg5", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-538726689", "createdAt": "2020-11-25T17:41:27Z", "commit": {"oid": "221774d8125af8af4df4b3f035b0762eeb95fc97"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4ODI1Mjg4", "url": "https://github.com/eclipse-openj9/openj9/pull/11051#pullrequestreview-538825288", "createdAt": "2020-11-25T20:25:12Z", "commit": {"oid": "221774d8125af8af4df4b3f035b0762eeb95fc97"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 56, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}