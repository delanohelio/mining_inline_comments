{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MTYyMzMw", "number": 9542, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzo1Njo1NFrOEAnWdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMzowMjo1MVrOEAtCqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDgwMTgxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzo1Njo1NFrOGcAZtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMTowMjozOVrOGcLluA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxOTg5NA==", "bodyText": "What does the offset \"4\" represent?  Perhaps use a more descriptive constant name.", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432019894", "createdAt": "2020-05-28T17:56:54Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwMzE5Mg==", "bodyText": "It is not an offset but a length parameter.\nIt is meaningless, and is addressed by eclipse/omr#4137 .", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432203192", "createdAt": "2020-05-29T01:02:39Z", "author": {"login": "knn-k"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxOTg5NA=="}, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTE4MDE4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTo1MDoyMlrOGcEMPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTo1MDoyMlrOGcEMPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4MTk4Mg==", "bodyText": "Use the comp variable that you cached earlier.", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432081982", "createdAt": "2020-05-28T19:50:22Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTIyODc1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDowMDowN1rOGcEqUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMDozNzo0OFrOGcLNiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4OTY4MA==", "bodyText": "What does it mean to assign metaReg to a NoReg dependence (i.e., any available real register)?  Shouldn't this be the actual real register representing the vmThread?", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432089680", "createdAt": "2020-05-28T20:00:07Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NzAwMQ==", "bodyText": "It came from the p version.", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432197001", "createdAt": "2020-05-29T00:37:48Z", "author": {"login": "knn-k"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4OTY4MA=="}, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTY5NTU5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjo0NToxNVrOGcJOyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozMTo0NVrOGcQXLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDU1Mw==", "bodyText": "Can you call this metaDataReg or more conventionally vmThreadReg ?", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432164553", "createdAt": "2020-05-28T22:45:15Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MTM4OA==", "bodyText": "Changed to vmThreadReg.", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432281388", "createdAt": "2020-05-29T06:31:45Z", "author": {"login": "knn-k"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDU1Mw=="}, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTY5OTg4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjo0NzoxNVrOGcJRXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozMjoyM1rOGcQX8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NTIxMg==", "bodyText": "Use comp here instead of cg->comp().", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432165212", "createdAt": "2020-05-28T22:47:15Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MTU4Nw==", "bodyText": "Changed to comp, here and other locations.", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432281587", "createdAt": "2020-05-29T06:32:23Z", "author": {"login": "knn-k"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NTIxMg=="}, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTcwMTEyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjo0Nzo0NlrOGcJSCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjo0Nzo0NlrOGcJSCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NTM4NQ==", "bodyText": "Use comp here", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432165385", "createdAt": "2020-05-28T22:47:46Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTcxMDkwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjo1MjoyMVrOGcJYDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMDozNDoxNFrOGcLJ7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NjkyNA==", "bodyText": "Is this necessary?  What are you prefetching here and why?", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432166924", "createdAt": "2020-05-28T22:52:21Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());\n+\n+   if (needSync)\n+      {\n+      generateSynchronizationInstruction(cg, TR::InstOpCode::dsb, node, 0xF); // dsb SY\n+      }\n+\n+   cg->insertPrefetchIfNecessary(node, objReg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NjA3Nw==", "bodyText": "It came from the p version.  Removing.", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432196077", "createdAt": "2020-05-29T00:34:14Z", "author": {"login": "knn-k"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());\n+\n+   if (needSync)\n+      {\n+      generateSynchronizationInstruction(cg, TR::InstOpCode::dsb, node, 0xF); // dsb SY\n+      }\n+\n+   cg->insertPrefetchIfNecessary(node, objReg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NjkyNA=="}, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTczNDE4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMzowMjo1MVrOGcJl_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjozMzo0MVrOGcQZkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDQ5NA==", "bodyText": "The DNA of this method is about 80-90% identical to the iGenerateSoftwareReadBarrier method.  Is there any way you could combine them to save some code space?", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432170494", "createdAt": "2020-05-28T23:02:51Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());\n+\n+   if (needSync)\n+      {\n+      generateSynchronizationInstruction(cg, TR::InstOpCode::dsb, node, 0xF); // dsb SY\n+      }\n+\n+   cg->insertPrefetchIfNecessary(node, objReg);\n+\n+   tempMR->decNodeReferenceCounts(cg);\n+\n+   cg->stopUsingRegister(evacuateReg);\n+   cg->stopUsingRegister(locationReg);\n+   cg->stopUsingRegister(x0Reg);\n+\n+   cg->machine()->setLinkRegisterKilled(true);\n+\n+   return objReg;\n+#endif // OMR_GC_CONCURRENT_SCAVENGER\n+   }\n+\n+static TR::Register *\n+aGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDczMw==", "bodyText": "Most of my comments in iGenerateSoftwareReadBarrier apply to this function as well so I'm not going to repeat them.", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432170733", "createdAt": "2020-05-28T23:03:35Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());\n+\n+   if (needSync)\n+      {\n+      generateSynchronizationInstruction(cg, TR::InstOpCode::dsb, node, 0xF); // dsb SY\n+      }\n+\n+   cg->insertPrefetchIfNecessary(node, objReg);\n+\n+   tempMR->decNodeReferenceCounts(cg);\n+\n+   cg->stopUsingRegister(evacuateReg);\n+   cg->stopUsingRegister(locationReg);\n+   cg->stopUsingRegister(x0Reg);\n+\n+   cg->machine()->setLinkRegisterKilled(true);\n+\n+   return objReg;\n+#endif // OMR_GC_CONCURRENT_SCAVENGER\n+   }\n+\n+static TR::Register *\n+aGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDQ5NA=="}, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4MjAwMQ==", "bodyText": "Merged the two functions into generateSoftwareReadBarrier(), which takes bool isArdbari as its third argument.", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432282001", "createdAt": "2020-05-29T06:33:41Z", "author": {"login": "knn-k"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());\n+\n+   if (needSync)\n+      {\n+      generateSynchronizationInstruction(cg, TR::InstOpCode::dsb, node, 0xF); // dsb SY\n+      }\n+\n+   cg->insertPrefetchIfNecessary(node, objReg);\n+\n+   tempMR->decNodeReferenceCounts(cg);\n+\n+   cg->stopUsingRegister(evacuateReg);\n+   cg->stopUsingRegister(locationReg);\n+   cg->stopUsingRegister(x0Reg);\n+\n+   cg->machine()->setLinkRegisterKilled(true);\n+\n+   return objReg;\n+#endif // OMR_GC_CONCURRENT_SCAVENGER\n+   }\n+\n+static TR::Register *\n+aGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDQ5NA=="}, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 151, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}