{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3MzE4NTg0", "number": 8844, "title": "Add mechanism for JITServer termination", "bodyText": "Added new API JITServer_DestroyServer to destroy JITServer.\nAdded new API stopJITServer destroyJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\nCloses: #8228\nSigned-off-by: Ashutosh Mehra mehra.ashutosh@ibm.com", "createdAt": "2020-03-12T15:44:01Z", "url": "https://github.com/eclipse-openj9/openj9/pull/8844", "merged": true, "mergeCommit": {"oid": "361acd76532c3b6acd0d5333bd6b16aac5a7f6fc"}, "closed": true, "closedAt": "2020-04-03T16:40:19Z", "author": {"login": "ashu-mehra"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcM99nagBqjMxMjM0ODI3MTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTbUKPAFqTM4NTgwNzY2NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6ea3323578748ba6ea2cb71f354834f1bd884d68", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/6ea3323578748ba6ea2cb71f354834f1bd884d68", "committedDate": "2020-03-12T15:22:01Z", "message": "Add JITServer_DestroyServer api\n\nAdded new API JITServer_DestroyServer to destroy JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/25b5d856e087db5e896c501a3706fc370ed8f867", "committedDate": "2020-03-12T16:04:30Z", "message": "Add JITServer_DestroyServer api\n\nAdded new API JITServer_DestroyServer to destroy JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNzAxODQ1", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-373701845", "createdAt": "2020-03-12T16:16:31Z", "commit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoxNjozMVrOF1lfVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoxNjozMVrOF1lfVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczMzA3OQ==", "bodyText": "formatting?  Maybe?  Hard to tell when if statements don't always have { & }", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391733079", "createdAt": "2020-03-12T16:16:31Z", "author": {"login": "DanHeidinga"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 246}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNzg0MjE4", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-373784218", "createdAt": "2020-03-12T18:02:02Z", "commit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODowMjowM1rOF1pf8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODo1NjozOFrOF1rSaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5ODc3MQ==", "bodyText": "For a hard exit like this I would prefer a message to stderr, rather than the vlog (or in addition to the vlog). We used perror below, so we could use here as well.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391798771", "createdAt": "2020-03-12T18:02:03Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMTM5Ng==", "bodyText": "Comment needs to be changed to reflect the new implementation.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391811396", "createdAt": "2020-03-12T18:25:35Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.hpp", "diffHunk": "@@ -37,12 +38,33 @@\n  \n     The current implementation does not provide code for nicely terminating the listener thread.\n  */\n+\n+#define OPENJ9_LISTENER_POLL_TIMEOUT 10 // in milliseconds\n+\n+class BaseCompileDispatcher;\n+\n class TR_Listener\n    {\n public:\n    TR_Listener();\n    static TR_Listener* allocate();\n    void startListenerThread(J9JavaVM *javaVM);\n+   void stop();\n+   /**\n+      @brief Function called to deal with incoming connection requests\n+\n+      This function opens a socket, binds it and then waits for incoming connection", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMTc4Ng==", "bodyText": "Should we increase this to 100 ms?", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391811786", "createdAt": "2020-03-12T18:26:22Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.hpp", "diffHunk": "@@ -37,12 +38,33 @@\n  \n     The current implementation does not provide code for nicely terminating the listener thread.\n  */\n+\n+#define OPENJ9_LISTENER_POLL_TIMEOUT 10 // in milliseconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNjY4MQ==", "bodyText": "Is it possible for poll to fail with EINTR error code and still be able to continue?", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391826681", "createdAt": "2020-03-12T18:54:08Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNjg4Mg==", "bodyText": "If the exit flag is set and we have an incomming connection request we will proceed with the connection request. I believe we still want to exit without handling this request.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391826882", "createdAt": "2020-03-12T18:54:31Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);\n+         }\n+      int connfd = accept(sockfd, (struct sockaddr *)&cli_addr, &clilen);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyODA3Mw==", "bodyText": "Do we have to check the flags set in revent? We could have POLLIN/POLLERR/POLLHUP/POLLNVAL", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r391828073", "createdAt": "2020-03-12T18:56:38Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,284 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if ((rc == 0) && getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+            TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error in polling socket: errno=%d\", errno);\n+\t exit(1);\n+         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867"}, "originalPosition": 247}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25b5d856e087db5e896c501a3706fc370ed8f867", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/25b5d856e087db5e896c501a3706fc370ed8f867", "committedDate": "2020-03-12T16:04:30Z", "message": "Add JITServer_DestroyServer api\n\nAdded new API JITServer_DestroyServer to destroy JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "95d2e77935e71a9b3282fde00c58cb3260397681", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/95d2e77935e71a9b3282fde00c58cb3260397681", "committedDate": "2020-03-12T20:53:56Z", "message": "Add JITServer_DestroyServer api\n\nAdded new API JITServer_DestroyServer to destroy JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MjcwMjA2", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-375270206", "createdAt": "2020-03-16T14:28:11Z", "commit": {"oid": "0a32f9727ea13034a2b6d14b29fd818d1210c45c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDoyODoxMVrOF2247g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDoyODoxMVrOF2247g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2NjczNA==", "bodyText": "Could we please fix the alignment of these two lines", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r393066734", "createdAt": "2020-03-16T14:28:11Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,305 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      /* check if we are exiting; if yes, there is no need to accept() new connection */\n+      if (getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (errno == EINTR)\n+            {\n+            continue;\n+\t    }\n+         else\n+            {\n+            perror(\"error in polling listening socket\");\n+\t    exit(1);\n+\t    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a32f9727ea13034a2b6d14b29fd818d1210c45c"}, "originalPosition": 253}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MjcwOTI4", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-375270928", "createdAt": "2020-03-16T14:28:54Z", "commit": {"oid": "0a32f9727ea13034a2b6d14b29fd818d1210c45c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDoyODo1NFrOF227Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDoyODo1NFrOF227Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2NzI4Mw==", "bodyText": "This lines needs two extra spaces", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r393067283", "createdAt": "2020-03-16T14:28:54Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,305 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      /* check if we are exiting; if yes, there is no need to accept() new connection */\n+      if (getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (errno == EINTR)\n+            {\n+            continue;\n+\t    }\n+         else\n+            {\n+            perror(\"error in polling listening socket\");\n+\t    exit(1);\n+\t    }\n+         }\n+      else if (pfd.revents != POLLIN)\n+         {\n+         fprintf(stderr, \"Unexpected event occurred during poll for new connection: revents=%d\\n\", pfd.revents);\n+\t exit(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a32f9727ea13034a2b6d14b29fd818d1210c45c"}, "originalPosition": 258}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MjczMDUy", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-375273052", "createdAt": "2020-03-16T14:31:09Z", "commit": {"oid": "0a32f9727ea13034a2b6d14b29fd818d1210c45c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDozMTowOVrOF23Bag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDozMTowOVrOF23Bag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2ODkwNg==", "bodyText": "On my screen these lines are not properly aligned", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r393068906", "createdAt": "2020-03-16T14:31:09Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,305 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      /* check if we are exiting; if yes, there is no need to accept() new connection */\n+      if (getListenerThreadExitFlag())\n+         {\n+         break;\n+         }\n+      else if (rc < 0)\n+         {\n+         if (errno == EINTR)\n+            {\n+            continue;\n+\t    }\n+         else\n+            {\n+            perror(\"error in polling listening socket\");\n+\t    exit(1);\n+\t    }\n+         }\n+      else if (pfd.revents != POLLIN)\n+         {\n+         fprintf(stderr, \"Unexpected event occurred during poll for new connection: revents=%d\\n\", pfd.revents);\n+\t exit(1);\n+         }\n+      do\n+         {\n+         /* at this stage we should have a valid request for new connection */\n+         int connfd = accept(sockfd, (struct sockaddr *)&cli_addr, &clilen);\n+         if (connfd < 0)\n+            {\n+            if ((EAGAIN != errno) && (EWOULDBLOCK != errno))\n+               {\n+\t       if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+                  {\n+                  TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Error accepting connection: errno=%d\", errno);\n+\t\t  }\n+\t       }\n+            }\n+         else\n+            {\n+            struct timeval timeoutMsForConnection = {(timeoutMs / 1000), ((timeoutMs % 1000) * 1000)};\n+            if (setsockopt(connfd, SOL_SOCKET, SO_RCVTIMEO, (void *)&timeoutMsForConnection, sizeof(timeoutMsForConnection)) < 0)\n+               {\n+               perror(\"Can't set option SO_RCVTIMEO on connfd socket\");\n+               exit(-1);\n+               }\n+            if (setsockopt(connfd, SOL_SOCKET, SO_SNDTIMEO, (void *)&timeoutMsForConnection, sizeof(timeoutMsForConnection)) < 0)\n+               {\n+               perror(\"Can't set option SO_SNDTIMEO on connfd socket\");\n+               exit(-1);\n+               }\n+\n+            BIO *bio = NULL;\n+            if (sslCtx && !acceptOpenSSLConnection(sslCtx, connfd, bio))\n+               continue;\n+\n+            JITServer::ServerStream *stream = new (PERSISTENT_NEW) JITServer::ServerStream(connfd, bio);\n+            compiler->compile(stream);\n+\t    }\n+         } while ((-1 != connfd) && !getListenerThreadExitFlag());\n+      }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a32f9727ea13034a2b6d14b29fd818d1210c45c"}, "originalPosition": 297}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MjczODEz", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-375273813", "createdAt": "2020-03-16T14:32:00Z", "commit": {"oid": "0a32f9727ea13034a2b6d14b29fd818d1210c45c"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a32f9727ea13034a2b6d14b29fd818d1210c45c", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/0a32f9727ea13034a2b6d14b29fd818d1210c45c", "committedDate": "2020-03-16T13:47:39Z", "message": "Add doc for stopJITServer()\n\nAdded doc comments for stopJITServer().\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "921bf266683d23fee829a75245281116738f3885", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/921bf266683d23fee829a75245281116738f3885", "committedDate": "2020-03-16T15:01:09Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "921bf266683d23fee829a75245281116738f3885", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/921bf266683d23fee829a75245281116738f3885", "committedDate": "2020-03-16T15:01:09Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "066ff297056b631eb4b4b0bb678a120637c069aa", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/066ff297056b631eb4b4b0bb678a120637c069aa", "committedDate": "2020-03-16T18:09:41Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "066ff297056b631eb4b4b0bb678a120637c069aa", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/066ff297056b631eb4b4b0bb678a120637c069aa", "committedDate": "2020-03-16T18:09:41Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "f2199593d304483960533775336a776faba0775f", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/f2199593d304483960533775336a776faba0775f", "committedDate": "2020-03-19T15:19:34Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f2199593d304483960533775336a776faba0775f", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/f2199593d304483960533775336a776faba0775f", "committedDate": "2020-03-19T15:19:34Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "638129acd37bf636acc6f3df0d873c6821e9c633", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/638129acd37bf636acc6f3df0d873c6821e9c633", "committedDate": "2020-03-19T15:43:18Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "638129acd37bf636acc6f3df0d873c6821e9c633", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/638129acd37bf636acc6f3df0d873c6821e9c633", "committedDate": "2020-03-19T15:43:18Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "68c9014ea8432c2531457a5eef3754e2bc26be96", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/68c9014ea8432c2531457a5eef3754e2bc26be96", "committedDate": "2020-03-19T15:46:52Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NDI4MjEx", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-379428211", "createdAt": "2020-03-23T13:30:11Z", "commit": {"oid": "68c9014ea8432c2531457a5eef3754e2bc26be96"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMDoxMVrOF6Fa7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMDoxMVrOF6Fa7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MDU0Mw==", "bodyText": "These brackets are not aligned properly", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r396450543", "createdAt": "2020-03-23T13:30:11Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,309 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68c9014ea8432c2531457a5eef3754e2bc26be96"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NDMxMDEz", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-379431013", "createdAt": "2020-03-23T13:33:28Z", "commit": {"oid": "68c9014ea8432c2531457a5eef3754e2bc26be96"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMzoyOFrOF6Fjpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMzoyOFrOF6Fjpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1Mjc3NQ==", "bodyText": "I would leave if (getListenerThreadExitFlag()) as the first test. Error or not, timeout or not, if it's time to exit, we should exit.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r396452775", "createdAt": "2020-03-23T13:33:28Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/Listener.cpp", "diffHunk": "@@ -20,18 +20,309 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n  *******************************************************************************/\n \n-#include \"runtime/Listener.hpp\"\n-#include \"net/ServerStream.hpp\"\n+#include <arpa/inet.h>\n+#include <chrono>\n+#include <fcntl.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\t/* for TCP_NODELAY option */\n+#include <openssl/err.h>\n+#include <poll.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h> /// gethostname, read, write\n+#include \"control/CompilationRuntime.hpp\"\n+#include \"env/TRMemory.hpp\"\n #include \"env/VMJ9.h\"\n+#include \"net/CommunicationStream.hpp\"\n+#include \"net/LoadSSLLibs.hpp\"\n+#include \"net/ServerStream.hpp\"\n+#include \"net/SSLProtobufStream.hpp\"\n #include \"runtime/CompileService.hpp\"\n-#include \"control/CompilationRuntime.hpp\"\n+#include \"runtime/Listener.hpp\"\n+\n+static SSL_CTX *\n+createSSLContext(TR::PersistentInfo *info)\n+   {\n+   SSL_CTX *ctx = (*OSSL_CTX_new)((*OSSLv23_server_method)());\n+\n+   if (!ctx)\n+      {\n+      perror(\"can't create SSL context\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   const char *sessionIDContext = \"JITServer\";\n+   (*OSSL_CTX_set_session_id_context)(ctx, (const unsigned char*)sessionIDContext, strlen(sessionIDContext));\n+\n+   if ((*OSSL_CTX_set_ecdh_auto)(ctx, 1) != 1)\n+      {\n+      perror(\"failed to configure SSL ecdh\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   TR::CompilationInfo *compInfo = TR::CompilationInfo::get();\n+   auto &sslKeys = compInfo->getJITServerSslKeys();\n+   auto &sslCerts = compInfo->getJITServerSslCerts();\n+   auto &sslRootCerts = compInfo->getJITServerSslRootCerts();\n+\n+   TR_ASSERT_FATAL(sslKeys.size() == 1 && sslCerts.size() == 1, \"only one key and cert is supported for now\");\n+   TR_ASSERT_FATAL(sslRootCerts.size() == 0, \"server does not understand root certs yet\");\n+\n+   // Parse and set private key\n+   BIO *keyMem = (*OBIO_new_mem_buf)(&sslKeys[0][0], sslKeys[0].size());\n+   if (!keyMem)\n+      {\n+      perror(\"cannot create memory buffer for private key (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   EVP_PKEY *privKey = (*OPEM_read_bio_PrivateKey)(keyMem, NULL, NULL, NULL);\n+   if (!privKey)\n+      {\n+      perror(\"cannot parse private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_PrivateKey)(ctx, privKey) != 1)\n+      {\n+      perror(\"cannot use private key\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Parse and set certificate\n+   BIO *certMem = (*OBIO_new_mem_buf)(&sslCerts[0][0], sslCerts[0].size());\n+   if (!certMem)\n+      {\n+      perror(\"cannot create memory buffer for cert (OOM?)\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   X509 *certificate = (*OPEM_read_bio_X509)(certMem, NULL, NULL, NULL);\n+   if (!certificate)\n+      {\n+      perror(\"cannot parse cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+   if ((*OSSL_CTX_use_certificate)(ctx, certificate) != 1)\n+      {\n+      perror(\"cannot use cert\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // Verify key and cert are valid\n+   if ((*OSSL_CTX_check_private_key)(ctx) != 1)\n+      {\n+      perror(\"private key check failed\");\n+      (*OERR_print_errors_fp)(stderr);\n+      exit(1);\n+      }\n+\n+   // verify server identity using standard method\n+   (*OSSL_CTX_set_verify)(ctx, SSL_VERIFY_PEER, NULL);\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"Successfully initialized SSL context (%s)\\n\", (*OOpenSSL_version)(0));\n+\n+   return ctx;\n+   }\n+\n+static bool\n+handleOpenSSLConnectionError(int connfd, SSL *&ssl, BIO *&bio, const char *errMsg)\n+{\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+       TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"%s: errno=%d\", errMsg, errno);\n+   (*OERR_print_errors_fp)(stderr);\n+\n+   close(connfd);\n+   if (bio)\n+      {\n+      (*OBIO_free_all)(bio);\n+      bio = NULL;\n+      }\n+   if (ssl)\n+      {\n+      (*OSSL_free)(ssl);\n+      ssl = NULL;\n+      }\n+   return false;\n+}\n+\n+static bool\n+acceptOpenSSLConnection(SSL_CTX *sslCtx, int connfd, BIO *&bio)\n+   {\n+   SSL *ssl = (*OSSL_new)(sslCtx);\n+   if (!ssl)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating SSL connection\");\n+\n+   (*OSSL_set_accept_state)(ssl);\n+\n+   if ((*OSSL_set_fd)(ssl, connfd) != 1)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting SSL file descriptor\");\n+\n+   if ((*OSSL_accept)(ssl) <= 0)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error accepting SSL connection\");\n+\n+   bio = (*OBIO_new_ssl)(sslCtx, false);\n+   if (!bio)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error creating new BIO\");\n+\n+   if ((*OBIO_ctrl)(bio, BIO_C_SET_SSL, true, (char *)ssl) != 1) // BIO_set_ssl(bio, ssl, true)\n+      return handleOpenSSLConnectionError(connfd, ssl, bio, \"Error setting BIO SSL\");\n+\n+   if (TR::Options::getVerboseOption(TR_VerboseJITServer))\n+      TR_VerboseLog::writeLineLocked(TR_Vlog_JITServer, \"SSL connection on socket 0x%x, Version: %s, Cipher: %s\\n\",\n+                                                     connfd, (*OSSL_get_version)(ssl), (*OSSL_get_cipher)(ssl));\n+   return true;\n+   }\n \n TR_Listener::TR_Listener()\n    : _listenerThread(NULL), _listenerMonitor(NULL), _listenerOSThread(NULL), \n    _listenerThreadAttachAttempted(false), _listenerThreadExitFlag(false)\n    {\n    }\n \n+void\n+TR_Listener::serveRemoteCompilationRequests(BaseCompileDispatcher *compiler)\n+   {\n+   TR::PersistentInfo *info = getCompilationInfo(jitConfig)->getPersistentInfo();\n+   SSL_CTX *sslCtx = NULL;\n+   if (JITServer::CommunicationStream::useSSL())\n+      {\n+      JITServer::CommunicationStream::initSSL();\n+      sslCtx = createSSLContext(info);\n+      }\n+\n+   uint32_t port = info->getJITServerPort();\n+   uint32_t timeoutMs = info->getSocketTimeout();\n+   struct pollfd pfd = {0};\n+   int sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n+   if (sockfd < 0)\n+      {\n+      perror(\"can't open server socket\");\n+      exit(1);\n+      }\n+\n+   // see `man 7 socket` for option explanations\n+   int flag = true;\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_REUSEADDR\");\n+      exit(-1);\n+      }\n+   if (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flag, sizeof(flag)) < 0)\n+      {\n+      perror(\"Can't set SO_KEEPALIVE\");\n+      exit(-1);\n+      }\n+\n+   struct sockaddr_in serv_addr;\n+   memset((char *)&serv_addr, 0, sizeof(serv_addr));\n+   serv_addr.sin_family = AF_INET;\n+   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n+   serv_addr.sin_port = htons(port);\n+\n+   if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)\n+      {\n+      perror(\"can't bind server address\");\n+      exit(1);\n+      }\n+   if (listen(sockfd, SOMAXCONN) < 0)\n+      {\n+      perror(\"listen failed\");\n+      exit(1);\n+      }\n+\n+   pfd.fd = sockfd;\n+   pfd.events = POLLIN;\n+\n+   while (!getListenerThreadExitFlag())\n+      {\n+      int32_t rc = 0;\n+      struct sockaddr_in cli_addr;\n+      socklen_t clilen = sizeof(cli_addr);\n+      int connfd = -1;\n+\n+      rc = poll(&pfd, 1, OPENJ9_LISTENER_POLL_TIMEOUT);\n+      if (0 == rc) // poll() timed out and no fd is ready\n+         {\n+         continue;\n+         }\n+      else if (getListenerThreadExitFlag()) // if we are exiting, there is no need to accept() new connection", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68c9014ea8432c2531457a5eef3754e2bc26be96"}, "originalPosition": 243}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "68c9014ea8432c2531457a5eef3754e2bc26be96", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/68c9014ea8432c2531457a5eef3754e2bc26be96", "committedDate": "2020-03-19T15:46:52Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "84dba618b545b05f16e21b6366ea45d0a5b11086", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/84dba618b545b05f16e21b6366ea45d0a5b11086", "committedDate": "2020-03-23T14:57:42Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NjAzMDk4", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-379603098", "createdAt": "2020-03-23T16:31:10Z", "commit": {"oid": "84dba618b545b05f16e21b6366ea45d0a5b11086"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "84dba618b545b05f16e21b6366ea45d0a5b11086", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/84dba618b545b05f16e21b6366ea45d0a5b11086", "committedDate": "2020-03-23T14:57:42Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "0493378ca973e22e4243db6c1588ac7fe2378f89", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/0493378ca973e22e4243db6c1588ac7fe2378f89", "committedDate": "2020-03-23T17:34:33Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NjcyMjY0", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-379672264", "createdAt": "2020-03-23T17:44:59Z", "commit": {"oid": "0493378ca973e22e4243db6c1588ac7fe2378f89"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo0NDo1OVrOF6Q4UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo0NDo1OVrOF6Q4UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzODI4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Stopts the JITServer.\n          \n          \n            \n             * Stops the JITServer.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r396638288", "createdAt": "2020-03-23T17:44:59Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stopts the JITServer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0493378ca973e22e4243db6c1588ac7fe2378f89"}, "originalPosition": 33}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0493378ca973e22e4243db6c1588ac7fe2378f89", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/0493378ca973e22e4243db6c1588ac7fe2378f89", "committedDate": "2020-03-23T17:34:33Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/85f9af8d79769368bec576c717038cbdc2018ba8", "committedDate": "2020-03-23T19:40:11Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNDQ1MDYx", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-380445061", "createdAt": "2020-03-24T15:48:57Z", "commit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTo0ODo1OFrOF62xaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjowNTo0NlrOF63mFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTExNQ==", "bodyText": "If this is freeing the jitServer, it should take a pointer to the pointer and update it to null.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            stopJITServer(JITServer *jitServer)\n          \n          \n            \n            stopJITServer(JITServer **jitServer)", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397259115", "createdAt": "2020-03-24T15:48:58Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTQ1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tfree(jitServer);\n          \n          \n            \n            \tfree(*jitServer);\n          \n          \n            \n            \t*jitServer = NULL;", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397259457", "createdAt": "2020-03-24T15:49:23Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)\n+{\n+\tJavaVM *vm = jitServer->jvm;\n+\t(*vm)->DestroyJavaVM(vm);\n+\tfree(jitServer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzU0MQ==", "bodyText": "Should this return a jint /int32_t?  It would allow propagating the result from DestroyJavaVM", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397267541", "createdAt": "2020-03-24T15:59:22Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzkyNg==", "bodyText": "nitpick to make it consistent with the other 2 functions\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid (*stopJITServer)(struct JITServer *);\n          \n          \n            \n            \tvoid (* stopJITServer)(struct JITServer *);", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397267926", "createdAt": "2020-03-24T15:59:51Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -34,6 +34,7 @@ struct JITServer; /* Forward declaration */\n typedef struct JITServer {\n \tint32_t (* startJITServer)(struct JITServer *);\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\tvoid (*stopJITServer)(struct JITServer *);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTg4Ng==", "bodyText": "Does this actually stop the server?  DestroyJavaVM typically waits until there are no-non daemon threads - are you intentionally depending on that behaviour?  Would be good to add a comment here if that's the intention", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397269886", "createdAt": "2020-03-24T16:02:19Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1571,22 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer pointer to the JITServer interface\n+ *\n+ * @returns void\n+ */\n+static void\n+stopJITServer(JITServer *jitServer)\n+{\n+\tJavaVM *vm = jitServer->jvm;\n+\t(*vm)->DestroyJavaVM(vm);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MTg1NQ==", "bodyText": "It would be good to document each of these functions if they are intended to be used by end users akin to Java's Invocation API", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397271855", "createdAt": "2020-03-24T16:04:45Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -34,6 +34,7 @@ struct JITServer; /* Forward declaration */\n typedef struct JITServer {\n \tint32_t (* startJITServer)(struct JITServer *);\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\tvoid (*stopJITServer)(struct JITServer *);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzkyNg=="}, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MjU5OA==", "bodyText": "I don't see a call to this function occurring anywhere.  Should the jitserver launcher be updated to call it after waiting for waitForJITServerTermination() to free resources?\nhttps://github.com/eclipse/openj9/blob/f2034099d7765870ecae55540642096e847fac52/runtime/jitserver_launcher/jitserver.c#L361", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r397272598", "createdAt": "2020-03-24T16:05:46Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1492,6 +1495,7 @@ JITServer_CreateServer(JITServer **jitServer, void *serverArgs)\n \t}\n \tserver->startJITServer = startJITServer;\n \tserver->waitForJITServerTermination = waitForJITServerTermination;\n+\tserver->stopJITServer = stopJITServer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8"}, "originalPosition": 23}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85f9af8d79769368bec576c717038cbdc2018ba8", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/85f9af8d79769368bec576c717038cbdc2018ba8", "committedDate": "2020-03-23T19:40:11Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "5ad38de11689adf2ff4c6dd172a6a413e6134aeb", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/5ad38de11689adf2ff4c6dd172a6a413e6134aeb", "committedDate": "2020-03-25T18:47:02Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ad38de11689adf2ff4c6dd172a6a413e6134aeb", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/5ad38de11689adf2ff4c6dd172a6a413e6134aeb", "committedDate": "2020-03-25T18:47:02Z", "message": "Add code for terminating JITServer\n\nAdded new API stopJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "36cedd509de9259dfcc91a1734dacc0e8a160013", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/36cedd509de9259dfcc91a1734dacc0e8a160013", "committedDate": "2020-03-26T22:37:05Z", "message": "Add code for terminating JITServer\n\nAdded new API destroyJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "36cedd509de9259dfcc91a1734dacc0e8a160013", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/36cedd509de9259dfcc91a1734dacc0e8a160013", "committedDate": "2020-03-26T22:37:05Z", "message": "Add code for terminating JITServer\n\nAdded new API destroyJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/3a197144440bc0248e5ca915ee06838cdf8ee11d", "committedDate": "2020-03-27T17:53:26Z", "message": "Add code for terminating JITServer\n\nAdded new API destroyJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MDY0MjAw", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-385064200", "createdAt": "2020-03-31T20:06:00Z", "commit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDowNjowMFrOF-mLKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoxMDowMlrOF-mUVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MTQ4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Stops the JITServer.\n          \n          \n            \n             * Frees the resources allocated by JITServer_CreateServer.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401181480", "createdAt": "2020-03-31T20:06:00Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1572,31 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MTc2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @param jitServer double pointer to the JITServer interface\n          \n          \n            \n             * @param jitServer double pointer to the JITServer interface.  Must not be null", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401181768", "createdAt": "2020-03-31T20:06:35Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1572,31 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer double pointer to the JITServer interface", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MjEwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Stops the JITServer.\n          \n          \n            \n            \t * Frees the resources allocated by JITServer_CreateServer.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401182104", "createdAt": "2020-03-31T20:07:03Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -32,8 +32,32 @@ extern \"C\" {\n struct JITServer; /* Forward declaration */\n \n typedef struct JITServer {\n+\t/**\n+\t * Starts an instance of JITServer.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* startJITServer)(struct JITServer *);\n+\t/**\n+\t * Wait for JITServer to terminate.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\t/**\n+\t * Stops the JITServer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MzI3NQ==", "bodyText": "This loses the reason for why DestroyJavaVM failed.  Unfortunate given this is returning JITSERVER error codes.  Tracepoints would help here - something to consider for the future - but not for this PR.", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401183275", "createdAt": "2020-03-31T20:09:05Z", "author": {"login": "DanHeidinga"}, "path": "runtime/j9vm/jvm.c", "diffHunk": "@@ -1567,6 +1572,31 @@ waitForJITServerTermination(JITServer *jitServer)\n \t}\n \treturn rc;\n }\n+\n+/**\n+ * Stops the JITServer.\n+ *\n+ * @param jitServer double pointer to the JITServer interface\n+ *\n+ * @returns JITSERVER_OK on success, else negative error code\n+ *\n+ * @note on return *jitServer is set to NULL\n+ */\n+static int32_t\n+destroyJITServer(JITServer **jitServer)\n+{\n+\tJavaVM *vm = (*jitServer)->jvm;\n+\tjint rc = (*vm)->DestroyJavaVM(vm);\n+\tfree(*jitServer);\n+\t*jitServer = NULL;\n+\tif (JNI_OK == rc) {\n+\t\trc = JITSERVER_OK;\n+\t} else {\n+\t\trc = JITSERVER_DESTROY_ERROR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MzgyOA==", "bodyText": "Now that it's clear this frees the resources, I'd like to see it called by the jitserver launcher.  It can be called after 1 waitForJITServerTermination` returns", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#discussion_r401183828", "createdAt": "2020-03-31T20:10:02Z", "author": {"login": "DanHeidinga"}, "path": "runtime/oti/jitserver_api.h", "diffHunk": "@@ -32,8 +32,32 @@ extern \"C\" {\n struct JITServer; /* Forward declaration */\n \n typedef struct JITServer {\n+\t/**\n+\t * Starts an instance of JITServer.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* startJITServer)(struct JITServer *);\n+\t/**\n+\t * Wait for JITServer to terminate.\n+\t *\n+\t * @param jitServer pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t */\n \tint32_t (* waitForJITServerTermination)(struct JITServer *);\n+\t/**\n+\t * Stops the JITServer.\n+\t *\n+\t * @param jitServer double pointer to the JITServer interface\n+\t *\n+\t * @returns JITSERVER_OK on success, else negative error code\n+\t *\n+\t * @note on return *jitServer is set to NULL\n+\t */\n+\tint32_t (* destroyJITServer)(struct JITServer **);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1024582276da3ea16765289a11b13c5918c553b6", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/1024582276da3ea16765289a11b13c5918c553b6", "committedDate": "2020-04-01T14:55:07Z", "message": "Add code for terminating JITServer\n\nAdded new API destroyJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a197144440bc0248e5ca915ee06838cdf8ee11d", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/3a197144440bc0248e5ca915ee06838cdf8ee11d", "committedDate": "2020-03-27T17:53:26Z", "message": "Add code for terminating JITServer\n\nAdded new API destroyJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}, "afterCommit": {"oid": "1024582276da3ea16765289a11b13c5918c553b6", "author": {"user": null}, "url": "https://github.com/eclipse-openj9/openj9/commit/1024582276da3ea16765289a11b13c5918c553b6", "committedDate": "2020-04-01T14:55:07Z", "message": "Add code for terminating JITServer\n\nAdded new API destroyJITServer to shutdown the JITServer.\nAlso added code to gracefully terminate the Listener thread.\n\nSigned-off-by: Ashutosh Mehra <mehra.ashutosh@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1ODA3NjY1", "url": "https://github.com/eclipse-openj9/openj9/pull/8844#pullrequestreview-385807665", "createdAt": "2020-04-01T17:40:06Z", "commit": {"oid": "1024582276da3ea16765289a11b13c5918c553b6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 476, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}