{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ3MDk0NDY2", "number": 11554, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQwNDowNzowMlrOFYt0kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQyMjoxNTozOFrOFgEzDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxNDYwODgzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/CHTable.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQwNDowNzowMlrOIi3fXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxODoxMzoyNVrOIjXzXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQzMTY0NA==", "bodyText": "This may need corresponding changes in JITClientCommitVirtualGuard", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r573431644", "createdAt": "2021-02-10T04:07:02Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -618,12 +618,17 @@ TR_CHTable::commitVirtualGuard(TR_VirtualGuard *info, List<TR_VirtualGuardSite>\n       TR_ResolvedMethod *breakpointedMethod = comp->getInlinedResolvedMethod(info->getCalleeIndex());\n       TR_OpaqueMethodBlock *method = breakpointedMethod->getPersistentIdentifier();\n       if (comp->fej9()->isMethodBreakpointed(method))\n+         {\n          nopAssumptionIsValid = false;\n-      ListIterator<TR_VirtualGuardSite> it(&sites);\n-      for (TR_VirtualGuardSite *site = it.getFirst(); site; site = it.getNext())\n+         }\n+      else\n          {\n-         TR_PatchNOPedGuardSiteOnMethodBreakPoint\n-            ::make(comp->fe(), comp->trPersistentMemory(), method, site->getLocation(), site->getDestination(), comp->getMetadataAssumptionList());\n+         ListIterator<TR_VirtualGuardSite> it(&sites);\n+         for (TR_VirtualGuardSite *site = it.getFirst(); site; site = it.getNext())\n+            {\n+            TR_PatchNOPedGuardSiteOnMethodBreakPoint\n+               ::make(comp->fe(), comp->trPersistentMemory(), method, site->getLocation(), site->getDestination(), comp->getMetadataAssumptionList());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02911c8ed0e4b6a8ce4c3afe77122f8bf5987427"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk2MTA1Mg==", "bodyText": "Added in 23d89a5", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r573961052", "createdAt": "2021-02-10T18:13:25Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/CHTable.cpp", "diffHunk": "@@ -618,12 +618,17 @@ TR_CHTable::commitVirtualGuard(TR_VirtualGuard *info, List<TR_VirtualGuardSite>\n       TR_ResolvedMethod *breakpointedMethod = comp->getInlinedResolvedMethod(info->getCalleeIndex());\n       TR_OpaqueMethodBlock *method = breakpointedMethod->getPersistentIdentifier();\n       if (comp->fej9()->isMethodBreakpointed(method))\n+         {\n          nopAssumptionIsValid = false;\n-      ListIterator<TR_VirtualGuardSite> it(&sites);\n-      for (TR_VirtualGuardSite *site = it.getFirst(); site; site = it.getNext())\n+         }\n+      else\n          {\n-         TR_PatchNOPedGuardSiteOnMethodBreakPoint\n-            ::make(comp->fe(), comp->trPersistentMemory(), method, site->getLocation(), site->getDestination(), comp->getMetadataAssumptionList());\n+         ListIterator<TR_VirtualGuardSite> it(&sites);\n+         for (TR_VirtualGuardSite *site = it.getFirst(); site; site = it.getNext())\n+            {\n+            TR_PatchNOPedGuardSiteOnMethodBreakPoint\n+               ::make(comp->fe(), comp->trPersistentMemory(), method, site->getLocation(), site->getDestination(), comp->getMetadataAssumptionList());\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQzMTY0NA=="}, "originalCommit": {"oid": "02911c8ed0e4b6a8ce4c3afe77122f8bf5987427"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxNDY0MTAwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/RelocationRuntime.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQwNDoyNDozOVrOIi3yBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxODoxMzozOFrOIjXz4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQzNjQyMQ==", "bodyText": "I am guessing that those two bits are J9_JIT_METADATA_WIDE_EXCEPTIONS | J9_JIT_METADATA_HAS_BYTECODE_PC\nmaybe we can use code like below  numExcptionRanges &= ~(J9_JIT_METADATA_WIDE_EXCEPTIONS | J9_JIT_METADATA_HAS_BYTECODE_PC); to make it more explicit?", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r573436421", "createdAt": "2021-02-10T04:24:39Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/runtime/RelocationRuntime.cpp", "diffHunk": "@@ -544,37 +544,16 @@ TR_RelocationRuntime::relocateAOTCodeAndData(U_8 *tempDataStart,\n             }\n          }\n \n-#if 0\n-      // add this in later...\n-      /* Perform meta-data relocations */\n-      if (_aotMethodHeaderEntry->offsetToMetaDataRelocations != 0)\n-         {\n-         TR_RelocationRecordBinaryTemplate * binaryReloRecords = (TR_RelocationRecordBinaryTemplate * )((U_8 *)_aotMethodHeaderEntry - sizeof(J9JITDataCacheHeader) + _aotMethodHeaderEntry->offsetToMetaDataRelocationItems);\n-         TR_RelocationRecordGroup reloGroup(binaryReloRecords);\n-         int rc = reloGroup.applyRelocations(this, reloTarget, _exceptionTable);\n-         if (rc != 0)\n-            {\n-            _relocationStatus = RelocationFailure;\n-            return;\n-            }\n-         }\n-#endif\n-\n       reloTarget()->flushCache(codeStart, _aotMethodHeaderEntry->compileMethodCodeSize);\n \n-#if 1\n       // replace this with meta-data relocations above when we implement it\n \n       /* Fix up inlined exception table ram method entries if wide */\n       if (((UDATA)_exceptionTable->numExcptionRanges) & J9_JIT_METADATA_WIDE_EXCEPTIONS)\n          {\n          // Highest 2 bits indicate wide exceptions and FSD, unset them and extract\n          // the number of exception ranges\n-         UDATA numExcptionRanges = ((UDATA)_exceptionTable->numExcptionRanges) & 0x7fff;\n-#if defined(J9VM_OPT_JITSERVER)\n-         if (_comp->getOption(TR_FullSpeedDebug))\n-            numExcptionRanges &= ~(J9_JIT_METADATA_WIDE_EXCEPTIONS | J9_JIT_METADATA_HAS_BYTECODE_PC);\n-#endif /* defined(J9VM_OPT_JITSERVER) */\n+         uint16_t numExcptionRanges = _exceptionTable->numExcptionRanges & 0x3fff;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb86cf5cab7341f2698c08e2f3e5d46f6562b64a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk2MTE4Ng==", "bodyText": "Added in ed0d4c5", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r573961186", "createdAt": "2021-02-10T18:13:38Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/runtime/RelocationRuntime.cpp", "diffHunk": "@@ -544,37 +544,16 @@ TR_RelocationRuntime::relocateAOTCodeAndData(U_8 *tempDataStart,\n             }\n          }\n \n-#if 0\n-      // add this in later...\n-      /* Perform meta-data relocations */\n-      if (_aotMethodHeaderEntry->offsetToMetaDataRelocations != 0)\n-         {\n-         TR_RelocationRecordBinaryTemplate * binaryReloRecords = (TR_RelocationRecordBinaryTemplate * )((U_8 *)_aotMethodHeaderEntry - sizeof(J9JITDataCacheHeader) + _aotMethodHeaderEntry->offsetToMetaDataRelocationItems);\n-         TR_RelocationRecordGroup reloGroup(binaryReloRecords);\n-         int rc = reloGroup.applyRelocations(this, reloTarget, _exceptionTable);\n-         if (rc != 0)\n-            {\n-            _relocationStatus = RelocationFailure;\n-            return;\n-            }\n-         }\n-#endif\n-\n       reloTarget()->flushCache(codeStart, _aotMethodHeaderEntry->compileMethodCodeSize);\n \n-#if 1\n       // replace this with meta-data relocations above when we implement it\n \n       /* Fix up inlined exception table ram method entries if wide */\n       if (((UDATA)_exceptionTable->numExcptionRanges) & J9_JIT_METADATA_WIDE_EXCEPTIONS)\n          {\n          // Highest 2 bits indicate wide exceptions and FSD, unset them and extract\n          // the number of exception ranges\n-         UDATA numExcptionRanges = ((UDATA)_exceptionTable->numExcptionRanges) & 0x7fff;\n-#if defined(J9VM_OPT_JITSERVER)\n-         if (_comp->getOption(TR_FullSpeedDebug))\n-            numExcptionRanges &= ~(J9_JIT_METADATA_WIDE_EXCEPTIONS | J9_JIT_METADATA_HAS_BYTECODE_PC);\n-#endif /* defined(J9VM_OPT_JITSERVER) */\n+         uint16_t numExcptionRanges = _exceptionTable->numExcptionRanges & 0x3fff;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzQzNjQyMQ=="}, "originalCommit": {"oid": "bb86cf5cab7341f2698c08e2f3e5d46f6562b64a"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxNzEzNDg2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/CompilationThread.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxNToyNjo1MlrOIjPcgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxODoxMzo0OVrOIjX0cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzgyNDEzMQ==", "bodyText": "I think a comment is warranted here explaining why we exclude FSD from doing warm AOT", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r573824131", "createdAt": "2021-02-10T15:26:52Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/CompilationThread.cpp", "diffHunk": "@@ -8182,7 +8182,8 @@ TR::CompilationInfoPerThreadBase::wrappedCompile(J9PortLibrary *portLib, void *\n             TR_ASSERT(!that->_methodBeingCompiled->isOutOfProcessCompReq(), \"JITServer should not change options passed by client\");\n #endif /* defined(J9VM_OPT_JITSERVER) */\n             bool aotCompilationReUpgradedToWarm = false;\n-            if (that->_methodBeingCompiled->_useAotCompilation)\n+            if (that->_methodBeingCompiled->_useAotCompilation\n+                && !TR::Options::getCmdLineOptions()->getOption(TR_FullSpeedDebug))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "755fedeb5c841c06d0a4bc18e4335645317b1d05"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk2MTMzMQ==", "bodyText": "Added in b8505f4", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r573961331", "createdAt": "2021-02-10T18:13:49Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/control/CompilationThread.cpp", "diffHunk": "@@ -8182,7 +8182,8 @@ TR::CompilationInfoPerThreadBase::wrappedCompile(J9PortLibrary *portLib, void *\n             TR_ASSERT(!that->_methodBeingCompiled->isOutOfProcessCompReq(), \"JITServer should not change options passed by client\");\n #endif /* defined(J9VM_OPT_JITSERVER) */\n             bool aotCompilationReUpgradedToWarm = false;\n-            if (that->_methodBeingCompiled->_useAotCompilation)\n+            if (that->_methodBeingCompiled->_useAotCompilation\n+                && !TR::Options::getCmdLineOptions()->getOption(TR_FullSpeedDebug))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzgyNDEzMQ=="}, "originalCommit": {"oid": "755fedeb5c841c06d0a4bc18e4335645317b1d05"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYyMzg3MTY5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQyMjoyNDo0NlrOIkPNdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOToxMDowMVrOInGofQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDg2ODg1NA==", "bodyText": "This commit deserves a non-empty message summarizing these changes :) .", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r574868854", "createdAt": "2021-02-11T22:24:46Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -1150,6 +1150,18 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          }\n          break;\n \n+      case TR_Breakpoint:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23d89a50e80c81fa91d55122299f6c83a321bcc8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzIwMjY4Nw==", "bodyText": "That's true of the first 3 commits, actually :) .\nSorry I left this comment hanging here! i got distracted after making this one comment and have been on vacation until today.", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r577202687", "createdAt": "2021-02-16T23:08:41Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -1150,6 +1150,18 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          }\n          break;\n \n+      case TR_Breakpoint:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDg2ODg1NA=="}, "originalCommit": {"oid": "23d89a50e80c81fa91d55122299f6c83a321bcc8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg3NDA0NQ==", "bodyText": "Addressed in the latest force push.", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r577874045", "createdAt": "2021-02-17T19:10:01Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -1150,6 +1150,18 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          }\n          break;\n \n+      case TR_Breakpoint:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDg2ODg1NA=="}, "originalCommit": {"oid": "23d89a50e80c81fa91d55122299f6c83a321bcc8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzOTgzNzU5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQyMzowNToxNFrOImdjxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozMToxMVrOInHb0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzIwMTA5NA==", "bodyText": "imo a better way to do this would be to create a new relocation record that does the inlining relocation as you want it, rather than using the existing MethodPointer relocation. That would avoid storing empty payload data as a flag to \"process this one differently\".", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r577201094", "createdAt": "2021-02-16T23:05:14Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -546,12 +546,27 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          if (aconstNode->getOpCodeValue() == TR::loadaddr)\n             j9method = reinterpret_cast<TR_OpaqueMethodBlock *>(aconstNode->getSymbolReference()->getSymbol()->castToStaticSymbol()->getStaticAddress());\n \n-         TR_OpaqueClassBlock *j9class = fej9->getClassFromMethodBlock(j9method);\n+         TR_InlinedCallSite & ics = comp->getInlinedCallSite(inlinedSiteIndex);\n+         TR_ResolvedMethod *inlinedMethod = ((TR_AOTMethodInfo *)ics._methodInfo)->resolvedMethod;\n+         TR_OpaqueMethodBlock *inlinedJ9Method = inlinedMethod->getPersistentIdentifier();\n \n-         uintptr_t classChainOffsetOfCLInSharedCache = sharedCache->getClassChainOffsetOfIdentifyingLoaderForClazzInSharedCache(j9class);\n-         uintptr_t classChainForInlinedMethodOffsetInSharedCache = self()->getClassChainOffset(j9class);\n+         uintptr_t classChainOffsetOfCLInSharedCache = 0;\n+         uintptr_t classChainForInlinedMethodOffsetInSharedCache = 0;\n+         uintptr_t vTableOffset = 0;\n \n-         uintptr_t vTableOffset = static_cast<uintptr_t>(fej9->getInterpreterVTableSlot(j9method, j9class));\n+         /* If the j9method from the aconst node is the same as the j9method at\n+          * inlined call site at inlinedSiteIndex, don't set the remaining fields\n+          * in the binary template; at relo time, the inlined site index is\n+          * sufficient to materialize the j9method pointer\n+          */\n+         if (j9method != inlinedJ9Method)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13eecaf41e75acf030a9fb7ab8cb8f8e35450989"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc2OTM5Nw==", "bodyText": "I think that's in general a good idea. However, for the purposes of this PR, it might be best done in a separate PR later:\n\nAdding a new relo type requires a change to OMR, so that's tedious; additionally there are uses of TR_MethodPointer in OMR so we would need to do a coordinate change where we're not only adding FSD but also modifying unrelated relo changes. Or we'd have to do that in a separate PR prior to these changes, in which case we might as well do it after.\nTR_MethodPointer does nicely encapsulate the idea of \"we have a pointer to a j9method\". As such,  to determine in the code when we would use TR_MethodPointer and when we'd use the other might require us to check the inlinedSiteIndex every time we went to add the relo. This might be fine, but not something I want to do in this PR, especially because it should be done in a way that people shouldn't have to remember to always add the if.\n\nPersonally I don't mind the current approach ONLY because the \"if this then that\" logic is hidden away, and the two branches are still related to the same relocation. However, I do agree that it would be nice to have logical separation. So for the sake of not slowing down this PR, I'd prefer to just add it later on; in fact it could probably be bundled with the clean up that's needed in some of the inlined method relos where we use the cpIndex field for the SVM IDs heh.", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r577769397", "createdAt": "2021-02-17T16:43:43Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -546,12 +546,27 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          if (aconstNode->getOpCodeValue() == TR::loadaddr)\n             j9method = reinterpret_cast<TR_OpaqueMethodBlock *>(aconstNode->getSymbolReference()->getSymbol()->castToStaticSymbol()->getStaticAddress());\n \n-         TR_OpaqueClassBlock *j9class = fej9->getClassFromMethodBlock(j9method);\n+         TR_InlinedCallSite & ics = comp->getInlinedCallSite(inlinedSiteIndex);\n+         TR_ResolvedMethod *inlinedMethod = ((TR_AOTMethodInfo *)ics._methodInfo)->resolvedMethod;\n+         TR_OpaqueMethodBlock *inlinedJ9Method = inlinedMethod->getPersistentIdentifier();\n \n-         uintptr_t classChainOffsetOfCLInSharedCache = sharedCache->getClassChainOffsetOfIdentifyingLoaderForClazzInSharedCache(j9class);\n-         uintptr_t classChainForInlinedMethodOffsetInSharedCache = self()->getClassChainOffset(j9class);\n+         uintptr_t classChainOffsetOfCLInSharedCache = 0;\n+         uintptr_t classChainForInlinedMethodOffsetInSharedCache = 0;\n+         uintptr_t vTableOffset = 0;\n \n-         uintptr_t vTableOffset = static_cast<uintptr_t>(fej9->getInterpreterVTableSlot(j9method, j9class));\n+         /* If the j9method from the aconst node is the same as the j9method at\n+          * inlined call site at inlinedSiteIndex, don't set the remaining fields\n+          * in the binary template; at relo time, the inlined site index is\n+          * sufficient to materialize the j9method pointer\n+          */\n+         if (j9method != inlinedJ9Method)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzIwMTA5NA=="}, "originalCommit": {"oid": "13eecaf41e75acf030a9fb7ab8cb8f8e35450989"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg4NzA0NQ==", "bodyText": "ok, I accept that the better approach would be a more invasive change. But I would prefer that better change. It might be possible to handle it transparently by having the MethodPointer external iterated relocation constructor automatically morph itself into a different relocation kind if it detects that the pointer matches the inlined site's j9method point. That doesn't change the fact that you would need an OMR change as well...", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r577887045", "createdAt": "2021-02-17T19:30:57Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -546,12 +546,27 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          if (aconstNode->getOpCodeValue() == TR::loadaddr)\n             j9method = reinterpret_cast<TR_OpaqueMethodBlock *>(aconstNode->getSymbolReference()->getSymbol()->castToStaticSymbol()->getStaticAddress());\n \n-         TR_OpaqueClassBlock *j9class = fej9->getClassFromMethodBlock(j9method);\n+         TR_InlinedCallSite & ics = comp->getInlinedCallSite(inlinedSiteIndex);\n+         TR_ResolvedMethod *inlinedMethod = ((TR_AOTMethodInfo *)ics._methodInfo)->resolvedMethod;\n+         TR_OpaqueMethodBlock *inlinedJ9Method = inlinedMethod->getPersistentIdentifier();\n \n-         uintptr_t classChainOffsetOfCLInSharedCache = sharedCache->getClassChainOffsetOfIdentifyingLoaderForClazzInSharedCache(j9class);\n-         uintptr_t classChainForInlinedMethodOffsetInSharedCache = self()->getClassChainOffset(j9class);\n+         uintptr_t classChainOffsetOfCLInSharedCache = 0;\n+         uintptr_t classChainForInlinedMethodOffsetInSharedCache = 0;\n+         uintptr_t vTableOffset = 0;\n \n-         uintptr_t vTableOffset = static_cast<uintptr_t>(fej9->getInterpreterVTableSlot(j9method, j9class));\n+         /* If the j9method from the aconst node is the same as the j9method at\n+          * inlined call site at inlinedSiteIndex, don't set the remaining fields\n+          * in the binary template; at relo time, the inlined site index is\n+          * sufficient to materialize the j9method pointer\n+          */\n+         if (j9method != inlinedJ9Method)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzIwMTA5NA=="}, "originalCommit": {"oid": "13eecaf41e75acf030a9fb7ab8cb8f8e35450989"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg4NzE4Ng==", "bodyText": "if only the relocation framework were extensible....", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r577887186", "createdAt": "2021-02-17T19:31:11Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -546,12 +546,27 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          if (aconstNode->getOpCodeValue() == TR::loadaddr)\n             j9method = reinterpret_cast<TR_OpaqueMethodBlock *>(aconstNode->getSymbolReference()->getSymbol()->castToStaticSymbol()->getStaticAddress());\n \n-         TR_OpaqueClassBlock *j9class = fej9->getClassFromMethodBlock(j9method);\n+         TR_InlinedCallSite & ics = comp->getInlinedCallSite(inlinedSiteIndex);\n+         TR_ResolvedMethod *inlinedMethod = ((TR_AOTMethodInfo *)ics._methodInfo)->resolvedMethod;\n+         TR_OpaqueMethodBlock *inlinedJ9Method = inlinedMethod->getPersistentIdentifier();\n \n-         uintptr_t classChainOffsetOfCLInSharedCache = sharedCache->getClassChainOffsetOfIdentifyingLoaderForClazzInSharedCache(j9class);\n-         uintptr_t classChainForInlinedMethodOffsetInSharedCache = self()->getClassChainOffset(j9class);\n+         uintptr_t classChainOffsetOfCLInSharedCache = 0;\n+         uintptr_t classChainForInlinedMethodOffsetInSharedCache = 0;\n+         uintptr_t vTableOffset = 0;\n \n-         uintptr_t vTableOffset = static_cast<uintptr_t>(fej9->getInterpreterVTableSlot(j9method, j9class));\n+         /* If the j9method from the aconst node is the same as the j9method at\n+          * inlined call site at inlinedSiteIndex, don't set the remaining fields\n+          * in the binary template; at relo time, the inlined site index is\n+          * sufficient to materialize the j9method pointer\n+          */\n+         if (j9method != inlinedJ9Method)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzIwMTA5NA=="}, "originalCommit": {"oid": "13eecaf41e75acf030a9fb7ab8cb8f8e35450989"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzOTgzODkwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQyMzowNTozOVrOImdkiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOToxMDoxMFrOInGo_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzIwMTI4OQ==", "bodyText": "Please improve the commit summary \"MethodPointer Relo Change\" isn't the most generic you could have made it, but I think you could do better.", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r577201289", "createdAt": "2021-02-16T23:05:39Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -546,12 +546,27 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          if (aconstNode->getOpCodeValue() == TR::loadaddr)\n             j9method = reinterpret_cast<TR_OpaqueMethodBlock *>(aconstNode->getSymbolReference()->getSymbol()->castToStaticSymbol()->getStaticAddress());\n \n-         TR_OpaqueClassBlock *j9class = fej9->getClassFromMethodBlock(j9method);\n+         TR_InlinedCallSite & ics = comp->getInlinedCallSite(inlinedSiteIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13eecaf41e75acf030a9fb7ab8cb8f8e35450989"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg3NDE3Mw==", "bodyText": "Addressed in the latest force push.", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r577874173", "createdAt": "2021-02-17T19:10:10Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9AheadOfTimeCompile.cpp", "diffHunk": "@@ -546,12 +546,27 @@ J9::AheadOfTimeCompile::initializeCommonAOTRelocationHeader(TR::IteratedExternal\n          if (aconstNode->getOpCodeValue() == TR::loadaddr)\n             j9method = reinterpret_cast<TR_OpaqueMethodBlock *>(aconstNode->getSymbolReference()->getSymbol()->castToStaticSymbol()->getStaticAddress());\n \n-         TR_OpaqueClassBlock *j9class = fej9->getClassFromMethodBlock(j9method);\n+         TR_InlinedCallSite & ics = comp->getInlinedCallSite(inlinedSiteIndex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzIwMTI4OQ=="}, "originalCommit": {"oid": "13eecaf41e75acf030a9fb7ab8cb8f8e35450989"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0ODQ2MzQxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/RelocationRecord.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQxNTo1Nzo0N1rOInvGZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQxNjoyMToxOFrOInwPJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODUzNzA2MA==", "bodyText": "would you please add an assert on the else here that\nreloPrivatData->_clazz == reinterpret_cast<TR_OpaqueClassBlock *>(-1)", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r578537060", "createdAt": "2021-02-18T15:57:47Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -5684,6 +5687,74 @@ TR_RelocationRecordMethodPointer::activatePointer(TR_RelocationRuntime *reloRunt\n       registerHCRAssumption(reloRuntime, reloLocation);\n    }\n \n+char *\n+TR_RelocationRecordInlinedMethodPointer::name()\n+   {\n+   return \"TR_InlinedMethodPointer\";\n+   }\n+\n+void\n+TR_RelocationRecordInlinedMethodPointer::preparePrivateData(TR_RelocationRuntime *reloRuntime, TR_RelocationTarget *reloTarget)\n+   {\n+   TR_RelocationRecordPointerPrivateData *reloPrivateData = &(privateData()->pointer);\n+      J9Method *inlinedMethod =\n+            reinterpret_cast<J9Method *>(\n+               getInlinedSiteMethod(reloRuntime, inlinedSiteIndex(reloTarget)));\n+\n+   if (inlinedMethod != reinterpret_cast<J9Method *>(-1))\n+      {\n+      reloPrivateData->_activatePointer = true;\n+      reloPrivateData->_clazz = reinterpret_cast<TR_OpaqueClassBlock *>(J9_CLASS_FROM_METHOD(inlinedMethod));\n+      reloPrivateData->_pointer = reinterpret_cast<uintptr_t>(inlinedMethod);\n+      reloPrivateData->_needUnloadAssumption =\n+            !reloRuntime->fej9()->sameClassLoaders(\n+               reloPrivateData->_clazz,\n+               reloRuntime->comp()->getCurrentMethod()->classOfMethod());\n+\n+      RELO_LOG(reloRuntime->reloLogger(), 6,\"\\tpreparePrivateData: pointer %p\\n\", reloPrivateData->_pointer);\n+      }\n+   else\n+      {\n+      reloPrivateData->_activatePointer = false;\n+      reloPrivateData->_clazz = reinterpret_cast<TR_OpaqueClassBlock *>(-1);\n+      reloPrivateData->_pointer = static_cast<uintptr_t>(-1);\n+      reloPrivateData->_needUnloadAssumption = false;\n+\n+      RELO_LOG(reloRuntime->reloLogger(), 6,\"\\tpreparePrivateData: invalid site\\n\");\n+      }\n+   }\n+\n+int32_t\n+TR_RelocationRecordInlinedMethodPointer::applyRelocation(TR_RelocationRuntime *reloRuntime, TR_RelocationTarget *reloTarget, uint8_t *reloLocation)\n+   {\n+   TR_RelocationRecordPointerPrivateData *reloPrivateData = &(privateData()->pointer);\n+\n+   /* Apply relocation */\n+   reloTarget->storePointer((uint8_t *)reloPrivateData->_pointer, reloLocation);\n+\n+   if (reloPrivateData->_activatePointer)\n+      {\n+      /* Add class unload assumptions if needed */\n+      if (reloPrivateData->_needUnloadAssumption)\n+         reloTarget->addPICtoPatchPtrOnClassUnload(reloPrivateData->_clazz, reloLocation);\n+\n+      /* Add HCR assumptions if needed */\n+      if (reloRuntime->options()->getOption(TR_EnableHCR))\n+         {\n+         createClassRedefinitionPicSite(\n+                  reinterpret_cast<void *>(reloPrivateData->_pointer),\n+                  reinterpret_cast<void *>(reloLocation),\n+                  sizeof(uintptr_t),\n+                  false,\n+                  reloRuntime->comp()->getMetadataAssumptionList());\n+\n+         reloRuntime->comp()->setHasClassRedefinitionAssumptions();\n+         }\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75acda74099cd2581eecf411e14ecf3214d49e88"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODU1NTY4NQ==", "bodyText": "Made changes, see force push https://github.com/eclipse/openj9/compare/d11a837eafbc2a6a2406558cce5d4defaaa09ac9..4a69430d1d1603f0a4a8666a6ca4ed21fedce751", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r578555685", "createdAt": "2021-02-18T16:21:18Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -5684,6 +5687,74 @@ TR_RelocationRecordMethodPointer::activatePointer(TR_RelocationRuntime *reloRunt\n       registerHCRAssumption(reloRuntime, reloLocation);\n    }\n \n+char *\n+TR_RelocationRecordInlinedMethodPointer::name()\n+   {\n+   return \"TR_InlinedMethodPointer\";\n+   }\n+\n+void\n+TR_RelocationRecordInlinedMethodPointer::preparePrivateData(TR_RelocationRuntime *reloRuntime, TR_RelocationTarget *reloTarget)\n+   {\n+   TR_RelocationRecordPointerPrivateData *reloPrivateData = &(privateData()->pointer);\n+      J9Method *inlinedMethod =\n+            reinterpret_cast<J9Method *>(\n+               getInlinedSiteMethod(reloRuntime, inlinedSiteIndex(reloTarget)));\n+\n+   if (inlinedMethod != reinterpret_cast<J9Method *>(-1))\n+      {\n+      reloPrivateData->_activatePointer = true;\n+      reloPrivateData->_clazz = reinterpret_cast<TR_OpaqueClassBlock *>(J9_CLASS_FROM_METHOD(inlinedMethod));\n+      reloPrivateData->_pointer = reinterpret_cast<uintptr_t>(inlinedMethod);\n+      reloPrivateData->_needUnloadAssumption =\n+            !reloRuntime->fej9()->sameClassLoaders(\n+               reloPrivateData->_clazz,\n+               reloRuntime->comp()->getCurrentMethod()->classOfMethod());\n+\n+      RELO_LOG(reloRuntime->reloLogger(), 6,\"\\tpreparePrivateData: pointer %p\\n\", reloPrivateData->_pointer);\n+      }\n+   else\n+      {\n+      reloPrivateData->_activatePointer = false;\n+      reloPrivateData->_clazz = reinterpret_cast<TR_OpaqueClassBlock *>(-1);\n+      reloPrivateData->_pointer = static_cast<uintptr_t>(-1);\n+      reloPrivateData->_needUnloadAssumption = false;\n+\n+      RELO_LOG(reloRuntime->reloLogger(), 6,\"\\tpreparePrivateData: invalid site\\n\");\n+      }\n+   }\n+\n+int32_t\n+TR_RelocationRecordInlinedMethodPointer::applyRelocation(TR_RelocationRuntime *reloRuntime, TR_RelocationTarget *reloTarget, uint8_t *reloLocation)\n+   {\n+   TR_RelocationRecordPointerPrivateData *reloPrivateData = &(privateData()->pointer);\n+\n+   /* Apply relocation */\n+   reloTarget->storePointer((uint8_t *)reloPrivateData->_pointer, reloLocation);\n+\n+   if (reloPrivateData->_activatePointer)\n+      {\n+      /* Add class unload assumptions if needed */\n+      if (reloPrivateData->_needUnloadAssumption)\n+         reloTarget->addPICtoPatchPtrOnClassUnload(reloPrivateData->_clazz, reloLocation);\n+\n+      /* Add HCR assumptions if needed */\n+      if (reloRuntime->options()->getOption(TR_EnableHCR))\n+         {\n+         createClassRedefinitionPicSite(\n+                  reinterpret_cast<void *>(reloPrivateData->_pointer),\n+                  reinterpret_cast<void *>(reloLocation),\n+                  sizeof(uintptr_t),\n+                  false,\n+                  reloRuntime->comp()->getMetadataAssumptionList());\n+\n+         reloRuntime->comp()->setHasClassRedefinitionAssumptions();\n+         }\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODUzNzA2MA=="}, "originalCommit": {"oid": "75acda74099cd2581eecf411e14ecf3214d49e88"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY5MTc3MzU4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/VMJ9.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQyMjoxNTozOFrOIt-_vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQyMzoxOTo1N1rOIuBEJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTA4ODk1OQ==", "bodyText": "We need to change the definition at JITServer which now reads:\nbool\nTR_J9SharedCacheServerVM::methodsCanBeInlinedEvenIfEventHooksEnabled()\n   {\n   return true;\n   }\n\nThe complication is that we are returning the value from the global options, so I am proposing to add a comp parameter which can be used to retrieve the options: comp->getOption(TR_FullSpeedDebug)", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r585088959", "createdAt": "2021-03-01T22:15:38Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -8254,7 +8254,7 @@ TR_J9SharedCacheVM::canMethodExitEventBeHooked()\n bool\n TR_J9SharedCacheVM::methodsCanBeInlinedEvenIfEventHooksEnabled()\n    {\n-   return true;\n+   return !TR::Options::getCmdLineOptions()->getOption(TR_FullSpeedDebug);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3afec7da8a5a144511fa0193378d4cd00c2c0fb6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTEyMjg1Mw==", "bodyText": "Addressed in 6e15af8", "url": "https://github.com/eclipse-openj9/openj9/pull/11554#discussion_r585122853", "createdAt": "2021-03-01T23:19:57Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/env/VMJ9.cpp", "diffHunk": "@@ -8254,7 +8254,7 @@ TR_J9SharedCacheVM::canMethodExitEventBeHooked()\n bool\n TR_J9SharedCacheVM::methodsCanBeInlinedEvenIfEventHooksEnabled()\n    {\n-   return true;\n+   return !TR::Options::getCmdLineOptions()->getOption(TR_FullSpeedDebug);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTA4ODk1OQ=="}, "originalCommit": {"oid": "3afec7da8a5a144511fa0193378d4cd00c2c0fb6"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 820, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}