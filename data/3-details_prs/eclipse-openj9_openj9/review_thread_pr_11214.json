{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyNzU5Mjk1", "number": 11214, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzoxNDo0MlrOE6RmJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODo1OTowMVrOFFJjKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTQxMTU2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzoxNDo0MlrOH1PW4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjo1Mzo1NVrOH13g0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4ODE5Mg==", "bodyText": "@andrewcraik @liqunl This change sets a flag in CG to trigger rerunLivenessAnalysis whenever splitPostGRA is called. However based on my test, I don't think liveness analysis should be run once the flag is true. There might be other things to take into consideration, such as if the optLevel is noOpt, it doesn't seem to be right to rerun liveness analysis.\nMy question is what criteria should be used to allow liveness analysis to rerun after tree lowering?\nI found there are two places in our code that do liveness analysis. Should we rerun liveness analysis after tree lowering if the liveness analysis has been performed in both  TR_GlobalRegisterAllocator and TR_GlobalLiveVariablesForGC? Or they are irrelevant to rerun liveness analysis after tree lowering?\n\n\nTR_GlobalRegisterAllocator\nhttps://github.com/eclipse/openj9-omr/blob/ff84a120148d2eeba5a6fcc594b846cb93f809c5/compiler/optimizer/GlobalRegisterAllocator.cpp#L446\n\n\nTR_GlobalLiveVariablesForGC https://github.com/eclipse/openj9/blob/33d30b17a7c6329c55546a46c42e5fdae0ac8585/runtime/compiler/optimizer/LiveVariablesForGC.cpp#L266\n\n\n@Leonardo2718 @hzongaro FYI", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r525588192", "createdAt": "2020-11-17T23:14:42Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -785,6 +789,13 @@ J9::CodeGenerator::preLowerTrees()\n    _uncommonedNodes.init(64, true);\n    }\n \n+void\n+J9::CodeGenerator::postLowerTrees()\n+   {\n+   OMR::CodeGeneratorConnector::postLowerTrees();\n+   if ((self()->isRerunLivenessAnalysis() && (self()->comp()->getOptLevel() > noOpt))\n+      self()->rerunLivenessAnalysis();\n+   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50ecd8edddc7ea08913523eef8e834b4baa79b88"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzOTQ3Ng==", "bodyText": "If live info has been computed, and then gets invalidated by calling splitPostGRA, then we need to rerun the analysis.", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r526139476", "createdAt": "2020-11-18T14:41:11Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -785,6 +789,13 @@ J9::CodeGenerator::preLowerTrees()\n    _uncommonedNodes.init(64, true);\n    }\n \n+void\n+J9::CodeGenerator::postLowerTrees()\n+   {\n+   OMR::CodeGeneratorConnector::postLowerTrees();\n+   if ((self()->isRerunLivenessAnalysis() && (self()->comp()->getOptLevel() > noOpt))\n+      self()->rerunLivenessAnalysis();\n+   }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4ODE5Mg=="}, "originalCommit": {"oid": "50ecd8edddc7ea08913523eef8e834b4baa79b88"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4OTc2MA==", "bodyText": "If live info has been computed\n\nDoes it mean it's been computed in TR_GlobalRegisterAllocator or TR_GlobalLiveVariablesForGC? Or both?\nI found there are cases where the blocks' live locals might not be set in TR_GlobalRegisterAllocator::perform but they're set in TR_GlobalLiveVariablesForGC::perform.", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r526189760", "createdAt": "2020-11-18T15:43:47Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -785,6 +789,13 @@ J9::CodeGenerator::preLowerTrees()\n    _uncommonedNodes.init(64, true);\n    }\n \n+void\n+J9::CodeGenerator::postLowerTrees()\n+   {\n+   OMR::CodeGeneratorConnector::postLowerTrees();\n+   if ((self()->isRerunLivenessAnalysis() && (self()->comp()->getOptLevel() > noOpt))\n+      self()->rerunLivenessAnalysis();\n+   }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4ODE5Mg=="}, "originalCommit": {"oid": "50ecd8edddc7ea08913523eef8e834b4baa79b88"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0NjA5Ng==", "bodyText": "The two opts set cg()->setLiveLocals(liveVars); to let CG know about the liveness info they computed.", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r526246096", "createdAt": "2020-11-18T16:53:55Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -785,6 +789,13 @@ J9::CodeGenerator::preLowerTrees()\n    _uncommonedNodes.init(64, true);\n    }\n \n+void\n+J9::CodeGenerator::postLowerTrees()\n+   {\n+   OMR::CodeGeneratorConnector::postLowerTrees();\n+   if ((self()->isRerunLivenessAnalysis() && (self()->comp()->getOptLevel() > noOpt))\n+      self()->rerunLivenessAnalysis();\n+   }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4ODE5Mg=="}, "originalCommit": {"oid": "50ecd8edddc7ea08913523eef8e834b4baa79b88"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODgxMTY3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNDo0MjoyOFrOH1xEVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTo1MTo0OVrOH10eDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE0MDUwMQ==", "bodyText": "The similar code is duplicated in GRA, GlobalLiveVariablesForGC and here, can we extract it to a util and call that util instead?", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r526140501", "createdAt": "2020-11-18T14:42:28Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,7 +1541,93 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::rerunLivenessAnalysis()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19386cd6f73800e3e9c9505ef47ece447233bd9d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5NjIzOQ==", "bodyText": "They're all different slightly. TR_GlobalRegisterAllocator is in OMR and checks compilation object visit count but TR_GlobalLiveVariablesForGC doesn't. GRA doesn't mark collected locals initialized or uninitialized if they're at the start of the block, which GlobalLiveVariablesForGC does.", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r526196239", "createdAt": "2020-11-18T15:51:49Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,7 +1541,93 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::rerunLivenessAnalysis()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE0MDUwMQ=="}, "originalCommit": {"oid": "19386cd6f73800e3e9c9505ef47ece447233bd9d"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzUyODQ5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo1NToxMlrOH5-c3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo1NToxMlrOH5-c3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1NDA3OA==", "bodyText": "The rerun shouldn't be optional. It must happen or we'll have functional issue. Could you use dumpOptDetails inside the if statement?", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r530554078", "createdAt": "2020-11-25T17:55:12Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,7 +1542,92 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::rerunLivenessAnalysis()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (!comp->getFlowGraph()->getStructure())\n+      {\n+      comp->getFlowGraph()->setStructure(TR_RegionAnalysis::getRegions(comp));\n+      }\n+\n+      {\n+      TR_BitVector *liveVars = NULL;\n+      int32_t numLocals = 0;\n+      TR::AutomaticSymbol *a;\n+      ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+      for (a = locals.getFirst(); a != NULL; a = locals.getNext())\n+         {\n+         // Mark collected locals as initialized. We will reset this property for\n+         // any locals that are live at the start of the method.\n+         //\n+         if (a->isCollectedReference() &&\n+            (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+             !comp->areSlotsSharedByRefAndNonRef() ||\n+             a->isSlotSharedByRefAndNonRef()))\n+               a->setInitializedReference();\n+         ++numLocals;\n+         }\n+\n+      if (comp->getOption(TR_EnableAggressiveLiveness))\n+         {\n+         TR::ParameterSymbol *p;\n+         ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+         for (p = parms.getFirst(); p != NULL; p = parms.getNext())\n+            ++numLocals;\n+         }\n+\n+      if (numLocals > 0 && (performTransformation(comp, \"Rerunning liveness for CodeGen numLocals %d\\n\", numLocals)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf06ec873b7bad0eb4377c60e7841a63f096440"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTY1MjYzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDo0Mjo1M1rOH7-Mpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDo0Mjo1M1rOH7-Mpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY0NzA3OA==", "bodyText": "We should enable the check even if ValueType is not enabled", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r532647078", "createdAt": "2020-11-30T14:42:53Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,6 +1540,112 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTY4NTk5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDo0OTo0M1rOH7-hFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDoxODoyNFrOICW5QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY1MjMwOA==", "bodyText": "If live locals are already computed before CG by whatever opt, it may also be invalidated by any block split operation. Make sure you invalidate any live local in block split.", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r532652308", "createdAt": "2020-11-30T14:49:43Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,6 +1540,112 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\")))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   if (!comp->getFlowGraph()->getStructure())\n+      {\n+      comp->getFlowGraph()->setStructure(TR_RegionAnalysis::getRegions(comp));\n+      }\n+\n+   // Because only live locals are mapped for GC, there is normally no need to\n+   // make sure locals are cleared to NULL during method prologue.\n+   // However, we can have cases where GC-collected locals are live at the start\n+   // of the method. These locals will have to be cleared to NULL during method\n+   // prologue.\n+   // This can happen because of the way we treat non-inlined jsrs.\n+   //\n+   int32_t numLocals = 0;\n+   TR::AutomaticSymbol *p;\n+   ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+   for (p = locals.getFirst(); p != NULL; p = locals.getNext())\n+      {\n+      // Mark collected locals as initialized. We will reset this property for\n+      // any locals that are live at the start of the method.\n+      //\n+      if (p->isCollectedReference() &&\n+          (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+           !comp->areSlotsSharedByRefAndNonRef() ||\n+           p->isSlotSharedByRefAndNonRef()))\n+         p->setInitializedReference();\n+      ++numLocals;\n+      }\n+\n+   if (comp->getOption(TR_EnableAggressiveLiveness))\n+      {\n+      TR::ParameterSymbol *pp;\n+      ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+      for (pp = parms.getFirst(); pp != NULL; pp = parms.getNext())\n+         ++numLocals;\n+      }\n+\n+   // Nothing to do if there are no locals\n+   //\n+   if (numLocals == 0)\n+      return;\n+\n+   TR_BitVector *liveVars = NULL;\n+\n+   if ((comp->getOption(TR_EnableOSR) && (comp->getHCRMode() == TR::osr || comp->getOption(TR_FullSpeedDebug)))\n+       || !self()->getLiveLocals()) // under OSR existing live locals is likely computed without ignoring OSR uses", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwMzc3OQ==", "bodyText": "Make sure you invalidate any live local in block split.\n\nDoes it mean to set CG's livelocals to NULL at where the splitPostGRA is used such as comp->cg()->setLiveLocals(NULL)?", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r532703779", "createdAt": "2020-11-30T15:56:54Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,6 +1540,112 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\")))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   if (!comp->getFlowGraph()->getStructure())\n+      {\n+      comp->getFlowGraph()->setStructure(TR_RegionAnalysis::getRegions(comp));\n+      }\n+\n+   // Because only live locals are mapped for GC, there is normally no need to\n+   // make sure locals are cleared to NULL during method prologue.\n+   // However, we can have cases where GC-collected locals are live at the start\n+   // of the method. These locals will have to be cleared to NULL during method\n+   // prologue.\n+   // This can happen because of the way we treat non-inlined jsrs.\n+   //\n+   int32_t numLocals = 0;\n+   TR::AutomaticSymbol *p;\n+   ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+   for (p = locals.getFirst(); p != NULL; p = locals.getNext())\n+      {\n+      // Mark collected locals as initialized. We will reset this property for\n+      // any locals that are live at the start of the method.\n+      //\n+      if (p->isCollectedReference() &&\n+          (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+           !comp->areSlotsSharedByRefAndNonRef() ||\n+           p->isSlotSharedByRefAndNonRef()))\n+         p->setInitializedReference();\n+      ++numLocals;\n+      }\n+\n+   if (comp->getOption(TR_EnableAggressiveLiveness))\n+      {\n+      TR::ParameterSymbol *pp;\n+      ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+      for (pp = parms.getFirst(); pp != NULL; pp = parms.getNext())\n+         ++numLocals;\n+      }\n+\n+   // Nothing to do if there are no locals\n+   //\n+   if (numLocals == 0)\n+      return;\n+\n+   TR_BitVector *liveVars = NULL;\n+\n+   if ((comp->getOption(TR_EnableOSR) && (comp->getHCRMode() == TR::osr || comp->getOption(TR_FullSpeedDebug)))\n+       || !self()->getLiveLocals()) // under OSR existing live locals is likely computed without ignoring OSR uses", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY1MjMwOA=="}, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwNzI0NA==", "bodyText": "Updated in  29bb422 to invalid the live locals when splitPostGRA is used.", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r532807244", "createdAt": "2020-11-30T18:24:48Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,6 +1540,112 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\")))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   if (!comp->getFlowGraph()->getStructure())\n+      {\n+      comp->getFlowGraph()->setStructure(TR_RegionAnalysis::getRegions(comp));\n+      }\n+\n+   // Because only live locals are mapped for GC, there is normally no need to\n+   // make sure locals are cleared to NULL during method prologue.\n+   // However, we can have cases where GC-collected locals are live at the start\n+   // of the method. These locals will have to be cleared to NULL during method\n+   // prologue.\n+   // This can happen because of the way we treat non-inlined jsrs.\n+   //\n+   int32_t numLocals = 0;\n+   TR::AutomaticSymbol *p;\n+   ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+   for (p = locals.getFirst(); p != NULL; p = locals.getNext())\n+      {\n+      // Mark collected locals as initialized. We will reset this property for\n+      // any locals that are live at the start of the method.\n+      //\n+      if (p->isCollectedReference() &&\n+          (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+           !comp->areSlotsSharedByRefAndNonRef() ||\n+           p->isSlotSharedByRefAndNonRef()))\n+         p->setInitializedReference();\n+      ++numLocals;\n+      }\n+\n+   if (comp->getOption(TR_EnableAggressiveLiveness))\n+      {\n+      TR::ParameterSymbol *pp;\n+      ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+      for (pp = parms.getFirst(); pp != NULL; pp = parms.getNext())\n+         ++numLocals;\n+      }\n+\n+   // Nothing to do if there are no locals\n+   //\n+   if (numLocals == 0)\n+      return;\n+\n+   TR_BitVector *liveVars = NULL;\n+\n+   if ((comp->getOption(TR_EnableOSR) && (comp->getHCRMode() == TR::osr || comp->getOption(TR_FullSpeedDebug)))\n+       || !self()->getLiveLocals()) // under OSR existing live locals is likely computed without ignoring OSR uses", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY1MjMwOA=="}, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4MDE0Mw==", "bodyText": "We shouldn't trust any livelocals computed earlier given that anything can happen after the computation. But it's impossible to guarantee that anyone changing CFG knows they might break things in CG, and invalidate livelocals. Given that no one sets live locals on CG except GlobalLiveVariableForGC, which is to be moved to CG, I think we should just run the analysis even if CG has live locals.", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r534480143", "createdAt": "2020-12-02T21:04:20Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,6 +1540,112 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\")))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   if (!comp->getFlowGraph()->getStructure())\n+      {\n+      comp->getFlowGraph()->setStructure(TR_RegionAnalysis::getRegions(comp));\n+      }\n+\n+   // Because only live locals are mapped for GC, there is normally no need to\n+   // make sure locals are cleared to NULL during method prologue.\n+   // However, we can have cases where GC-collected locals are live at the start\n+   // of the method. These locals will have to be cleared to NULL during method\n+   // prologue.\n+   // This can happen because of the way we treat non-inlined jsrs.\n+   //\n+   int32_t numLocals = 0;\n+   TR::AutomaticSymbol *p;\n+   ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+   for (p = locals.getFirst(); p != NULL; p = locals.getNext())\n+      {\n+      // Mark collected locals as initialized. We will reset this property for\n+      // any locals that are live at the start of the method.\n+      //\n+      if (p->isCollectedReference() &&\n+          (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+           !comp->areSlotsSharedByRefAndNonRef() ||\n+           p->isSlotSharedByRefAndNonRef()))\n+         p->setInitializedReference();\n+      ++numLocals;\n+      }\n+\n+   if (comp->getOption(TR_EnableAggressiveLiveness))\n+      {\n+      TR::ParameterSymbol *pp;\n+      ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+      for (pp = parms.getFirst(); pp != NULL; pp = parms.getNext())\n+         ++numLocals;\n+      }\n+\n+   // Nothing to do if there are no locals\n+   //\n+   if (numLocals == 0)\n+      return;\n+\n+   TR_BitVector *liveVars = NULL;\n+\n+   if ((comp->getOption(TR_EnableOSR) && (comp->getHCRMode() == TR::osr || comp->getOption(TR_FullSpeedDebug)))\n+       || !self()->getLiveLocals()) // under OSR existing live locals is likely computed without ignoring OSR uses", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY1MjMwOA=="}, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU3NzQ1MA==", "bodyText": "I'll remove the check on !self()->getLiveLocals() and the extra invalidation. I'll run some tests first before pushing another commit.", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r534577450", "createdAt": "2020-12-03T00:34:51Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,6 +1540,112 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\")))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   if (!comp->getFlowGraph()->getStructure())\n+      {\n+      comp->getFlowGraph()->setStructure(TR_RegionAnalysis::getRegions(comp));\n+      }\n+\n+   // Because only live locals are mapped for GC, there is normally no need to\n+   // make sure locals are cleared to NULL during method prologue.\n+   // However, we can have cases where GC-collected locals are live at the start\n+   // of the method. These locals will have to be cleared to NULL during method\n+   // prologue.\n+   // This can happen because of the way we treat non-inlined jsrs.\n+   //\n+   int32_t numLocals = 0;\n+   TR::AutomaticSymbol *p;\n+   ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+   for (p = locals.getFirst(); p != NULL; p = locals.getNext())\n+      {\n+      // Mark collected locals as initialized. We will reset this property for\n+      // any locals that are live at the start of the method.\n+      //\n+      if (p->isCollectedReference() &&\n+          (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+           !comp->areSlotsSharedByRefAndNonRef() ||\n+           p->isSlotSharedByRefAndNonRef()))\n+         p->setInitializedReference();\n+      ++numLocals;\n+      }\n+\n+   if (comp->getOption(TR_EnableAggressiveLiveness))\n+      {\n+      TR::ParameterSymbol *pp;\n+      ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+      for (pp = parms.getFirst(); pp != NULL; pp = parms.getNext())\n+         ++numLocals;\n+      }\n+\n+   // Nothing to do if there are no locals\n+   //\n+   if (numLocals == 0)\n+      return;\n+\n+   TR_BitVector *liveVars = NULL;\n+\n+   if ((comp->getOption(TR_EnableOSR) && (comp->getHCRMode() == TR::osr || comp->getOption(TR_FullSpeedDebug)))\n+       || !self()->getLiveLocals()) // under OSR existing live locals is likely computed without ignoring OSR uses", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY1MjMwOA=="}, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4MTA0NA==", "bodyText": "I think this whole check should be removed\nif ((comp->getOption(TR_EnableOSR) && (comp->getHCRMode() == TR::osr || comp->getOption(TR_FullSpeedDebug)))\n       || !self()->getLiveLocals())", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r534581044", "createdAt": "2020-12-03T00:44:24Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,6 +1540,112 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\")))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   if (!comp->getFlowGraph()->getStructure())\n+      {\n+      comp->getFlowGraph()->setStructure(TR_RegionAnalysis::getRegions(comp));\n+      }\n+\n+   // Because only live locals are mapped for GC, there is normally no need to\n+   // make sure locals are cleared to NULL during method prologue.\n+   // However, we can have cases where GC-collected locals are live at the start\n+   // of the method. These locals will have to be cleared to NULL during method\n+   // prologue.\n+   // This can happen because of the way we treat non-inlined jsrs.\n+   //\n+   int32_t numLocals = 0;\n+   TR::AutomaticSymbol *p;\n+   ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+   for (p = locals.getFirst(); p != NULL; p = locals.getNext())\n+      {\n+      // Mark collected locals as initialized. We will reset this property for\n+      // any locals that are live at the start of the method.\n+      //\n+      if (p->isCollectedReference() &&\n+          (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+           !comp->areSlotsSharedByRefAndNonRef() ||\n+           p->isSlotSharedByRefAndNonRef()))\n+         p->setInitializedReference();\n+      ++numLocals;\n+      }\n+\n+   if (comp->getOption(TR_EnableAggressiveLiveness))\n+      {\n+      TR::ParameterSymbol *pp;\n+      ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+      for (pp = parms.getFirst(); pp != NULL; pp = parms.getNext())\n+         ++numLocals;\n+      }\n+\n+   // Nothing to do if there are no locals\n+   //\n+   if (numLocals == 0)\n+      return;\n+\n+   TR_BitVector *liveVars = NULL;\n+\n+   if ((comp->getOption(TR_EnableOSR) && (comp->getHCRMode() == TR::osr || comp->getOption(TR_FullSpeedDebug)))\n+       || !self()->getLiveLocals()) // under OSR existing live locals is likely computed without ignoring OSR uses", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY1MjMwOA=="}, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0NjQ0OQ==", "bodyText": "We still need this condition to adhere to old behavior\ncomp()->getOption(TR_EnableOSR) && (comp()->getHCRMode() == TR::osr || comp()->getOption(TR_FullSpeedDebug))", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r538946449", "createdAt": "2020-12-09T01:59:19Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,6 +1540,112 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\")))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   if (!comp->getFlowGraph()->getStructure())\n+      {\n+      comp->getFlowGraph()->setStructure(TR_RegionAnalysis::getRegions(comp));\n+      }\n+\n+   // Because only live locals are mapped for GC, there is normally no need to\n+   // make sure locals are cleared to NULL during method prologue.\n+   // However, we can have cases where GC-collected locals are live at the start\n+   // of the method. These locals will have to be cleared to NULL during method\n+   // prologue.\n+   // This can happen because of the way we treat non-inlined jsrs.\n+   //\n+   int32_t numLocals = 0;\n+   TR::AutomaticSymbol *p;\n+   ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+   for (p = locals.getFirst(); p != NULL; p = locals.getNext())\n+      {\n+      // Mark collected locals as initialized. We will reset this property for\n+      // any locals that are live at the start of the method.\n+      //\n+      if (p->isCollectedReference() &&\n+          (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+           !comp->areSlotsSharedByRefAndNonRef() ||\n+           p->isSlotSharedByRefAndNonRef()))\n+         p->setInitializedReference();\n+      ++numLocals;\n+      }\n+\n+   if (comp->getOption(TR_EnableAggressiveLiveness))\n+      {\n+      TR::ParameterSymbol *pp;\n+      ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+      for (pp = parms.getFirst(); pp != NULL; pp = parms.getNext())\n+         ++numLocals;\n+      }\n+\n+   // Nothing to do if there are no locals\n+   //\n+   if (numLocals == 0)\n+      return;\n+\n+   TR_BitVector *liveVars = NULL;\n+\n+   if ((comp->getOption(TR_EnableOSR) && (comp->getHCRMode() == TR::osr || comp->getOption(TR_FullSpeedDebug)))\n+       || !self()->getLiveLocals()) // under OSR existing live locals is likely computed without ignoring OSR uses", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY1MjMwOA=="}, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAxMjM4OA==", "bodyText": "I think we should just run the analysis even if CG has live locals.\n\nWith the checking on getLiveLocals being removed (|| !self()->getLiveLocals() ) since the analysis should be run regardless, wouldn't keeping the rest of the old condition check (comp()->getOption(TR_EnableOSR) && (...)))  cause the analysis to run only when OSR is enabled? What if OSR is disabled and getLiveLocals() == NULL or getLiveLocals() returns an already invalid result due to other splitPostGRA before CG?", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r539012388", "createdAt": "2020-12-09T05:17:11Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,6 +1540,112 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\")))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   if (!comp->getFlowGraph()->getStructure())\n+      {\n+      comp->getFlowGraph()->setStructure(TR_RegionAnalysis::getRegions(comp));\n+      }\n+\n+   // Because only live locals are mapped for GC, there is normally no need to\n+   // make sure locals are cleared to NULL during method prologue.\n+   // However, we can have cases where GC-collected locals are live at the start\n+   // of the method. These locals will have to be cleared to NULL during method\n+   // prologue.\n+   // This can happen because of the way we treat non-inlined jsrs.\n+   //\n+   int32_t numLocals = 0;\n+   TR::AutomaticSymbol *p;\n+   ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+   for (p = locals.getFirst(); p != NULL; p = locals.getNext())\n+      {\n+      // Mark collected locals as initialized. We will reset this property for\n+      // any locals that are live at the start of the method.\n+      //\n+      if (p->isCollectedReference() &&\n+          (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+           !comp->areSlotsSharedByRefAndNonRef() ||\n+           p->isSlotSharedByRefAndNonRef()))\n+         p->setInitializedReference();\n+      ++numLocals;\n+      }\n+\n+   if (comp->getOption(TR_EnableAggressiveLiveness))\n+      {\n+      TR::ParameterSymbol *pp;\n+      ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+      for (pp = parms.getFirst(); pp != NULL; pp = parms.getNext())\n+         ++numLocals;\n+      }\n+\n+   // Nothing to do if there are no locals\n+   //\n+   if (numLocals == 0)\n+      return;\n+\n+   TR_BitVector *liveVars = NULL;\n+\n+   if ((comp->getOption(TR_EnableOSR) && (comp->getHCRMode() == TR::osr || comp->getOption(TR_FullSpeedDebug)))\n+       || !self()->getLiveLocals()) // under OSR existing live locals is likely computed without ignoring OSR uses", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY1MjMwOA=="}, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0MzE2OQ==", "bodyText": "You're right, we should run the analysis regardless given the last condition being always true", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r539343169", "createdAt": "2020-12-09T14:18:24Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,6 +1540,112 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\")))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   if (!comp->getFlowGraph()->getStructure())\n+      {\n+      comp->getFlowGraph()->setStructure(TR_RegionAnalysis::getRegions(comp));\n+      }\n+\n+   // Because only live locals are mapped for GC, there is normally no need to\n+   // make sure locals are cleared to NULL during method prologue.\n+   // However, we can have cases where GC-collected locals are live at the start\n+   // of the method. These locals will have to be cleared to NULL during method\n+   // prologue.\n+   // This can happen because of the way we treat non-inlined jsrs.\n+   //\n+   int32_t numLocals = 0;\n+   TR::AutomaticSymbol *p;\n+   ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+   for (p = locals.getFirst(); p != NULL; p = locals.getNext())\n+      {\n+      // Mark collected locals as initialized. We will reset this property for\n+      // any locals that are live at the start of the method.\n+      //\n+      if (p->isCollectedReference() &&\n+          (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+           !comp->areSlotsSharedByRefAndNonRef() ||\n+           p->isSlotSharedByRefAndNonRef()))\n+         p->setInitializedReference();\n+      ++numLocals;\n+      }\n+\n+   if (comp->getOption(TR_EnableAggressiveLiveness))\n+      {\n+      TR::ParameterSymbol *pp;\n+      ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+      for (pp = parms.getFirst(); pp != NULL; pp = parms.getNext())\n+         ++numLocals;\n+      }\n+\n+   // Nothing to do if there are no locals\n+   //\n+   if (numLocals == 0)\n+      return;\n+\n+   TR_BitVector *liveVars = NULL;\n+\n+   if ((comp->getOption(TR_EnableOSR) && (comp->getHCRMode() == TR::osr || comp->getOption(TR_FullSpeedDebug)))\n+       || !self()->getLiveLocals()) // under OSR existing live locals is likely computed without ignoring OSR uses", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY1MjMwOA=="}, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTY5MDM0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDo1MDozN1rOH7-j0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDo1MDozN1rOH7-j0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY1MzAxMA==", "bodyText": "Region analysis is expensive, we should only do it if we're to run liveness analysis", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r532653010", "createdAt": "2020-11-30T14:50:37Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1530,6 +1540,112 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\")))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   if (!comp->getFlowGraph()->getStructure())\n+      {\n+      comp->getFlowGraph()->setStructure(TR_RegionAnalysis::getRegions(comp));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTY5NTA4OnYy", "diffSide": "LEFT", "path": "runtime/compiler/optimizer/LiveVariablesForGC.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDo1MTozN1rOH7-mpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDo1MTozN1rOH7-mpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY1MzczNQ==", "bodyText": "We should use StackMemoryRegion in the new code to reduce memory consumption.", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r532653735", "createdAt": "2020-11-30T14:51:37Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/optimizer/LiveVariablesForGC.cpp", "diffHunk": "@@ -182,109 +182,8 @@ int32_t TR_GlobalLiveVariablesForGC::perform()\n       return 0;\n       }\n \n-   TR::StackMemoryRegion stackMemoryRegion(*trMemory());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd83fc0cf1d6e3e947609f40855056ba0eb0a49"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwOTQzNjU5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODo1OTowMVrOIFgpqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMTo0MTowMlrOIFrVHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY0ODc0Nw==", "bodyText": "I wonder if this check is sufficient.  Presumably this means if structure is available already then we'll simply use it here.  But I think there are tree lowering transformations that might either introduce blocks or re-route control flow between them.  I'm not sure if we can guarantee that they will be diligent in repairing structure if they change it.\nPerhaps we should always rebuild structure here.  My understanding is that it should be a relatively inexpensive build especially since  globalLiveVariablesForGC is only enabled \"naturally\" at optlevels >= warm and a structure rebuild will just be in the noise in terms of compile time.", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r542648747", "createdAt": "2020-12-14T18:59:01Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1596,6 +1606,106 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\"))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   TR::StackMemoryRegion stackMemoryRegion(*trMemory);\n+   // Because only live locals are mapped for GC, there is normally no need to\n+   // make sure locals are cleared to NULL during method prologue.\n+   // However, we can have cases where GC-collected locals are live at the start\n+   // of the method. These locals will have to be cleared to NULL during method\n+   // prologue.\n+   // This can happen because of the way we treat non-inlined jsrs.\n+   //\n+   int32_t numLocals = 0;\n+   TR::AutomaticSymbol *p;\n+   ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+   for (p = locals.getFirst(); p != NULL; p = locals.getNext())\n+      {\n+      // Mark collected locals as initialized. We will reset this property for\n+      // any locals that are live at the start of the method.\n+      //\n+      if (p->isCollectedReference() &&\n+          (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+           !comp->areSlotsSharedByRefAndNonRef() ||\n+           p->isSlotSharedByRefAndNonRef()))\n+         p->setInitializedReference();\n+      ++numLocals;\n+      }\n+\n+   if (comp->getOption(TR_EnableAggressiveLiveness))\n+      {\n+      TR::ParameterSymbol *pp;\n+      ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+      for (pp = parms.getFirst(); pp != NULL; pp = parms.getNext())\n+         ++numLocals;\n+      }\n+\n+   // Nothing to do if there are no locals\n+   //\n+   if (numLocals == 0)\n+      return;\n+\n+   TR_BitVector *liveVars = NULL;\n+\n+   // Perform liveness analysis\n+   //\n+   bool ignoreOSRuses = false; // Used to be set to true but we cannot set this to true because a variable may not be live in compiled code but may still be needed (live) in the interpreter\n+   /* for mimicInterpreterShape, because OSR points can extend the live range of autos\n+    * autos sharing the same slot in interpreter might end up with overlapped\n+    * live range if OSRUses are not ignored\n+    */\n+   if (comp->getOption(TR_MimicInterpreterFrameShape))\n+      ignoreOSRuses = true;\n+\n+   if (!comp->getFlowGraph()->getStructure())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ff0cc85e1447f0575530a5c6cebae731933796d"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyMzcwOQ==", "bodyText": "I think there are tree lowering transformations that might either introduce blocks or re-route control flow between them. I'm not sure if we can guarantee that they will be diligent in repairing structure if they change it.\n\nRegarding to the current lowerTree manipulation such as where splitPostGRA is used, the structure is invalidated.  However as you've pointed out, we can't guarantee in the future or other places that would alway remember to invalidate the structure. I'll remove the check to rebuild the structure all the time.", "url": "https://github.com/eclipse-openj9/openj9/pull/11214#discussion_r542823709", "createdAt": "2020-12-14T21:41:02Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -1596,6 +1606,106 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n \n    }\n \n+void\n+J9::CodeGenerator::runGlobalLiveVariablesForGC()\n+   {\n+   auto comp = self()->comp();\n+   auto trHeapMemory = self()->trHeapMemory();\n+   auto trMemory = self()->trMemory();\n+\n+   if (comp->getOption(TR_EnableParanoidOptCheck) || debug(\"paranoidOptCheck\"))\n+      comp->verifyCFG(comp->getMethodSymbol());\n+\n+   TR::StackMemoryRegion stackMemoryRegion(*trMemory);\n+   // Because only live locals are mapped for GC, there is normally no need to\n+   // make sure locals are cleared to NULL during method prologue.\n+   // However, we can have cases where GC-collected locals are live at the start\n+   // of the method. These locals will have to be cleared to NULL during method\n+   // prologue.\n+   // This can happen because of the way we treat non-inlined jsrs.\n+   //\n+   int32_t numLocals = 0;\n+   TR::AutomaticSymbol *p;\n+   ListIterator<TR::AutomaticSymbol> locals(&comp->getMethodSymbol()->getAutomaticList());\n+   for (p = locals.getFirst(); p != NULL; p = locals.getNext())\n+      {\n+      // Mark collected locals as initialized. We will reset this property for\n+      // any locals that are live at the start of the method.\n+      //\n+      if (p->isCollectedReference() &&\n+          (!comp->getOption(TR_MimicInterpreterFrameShape) ||\n+           !comp->areSlotsSharedByRefAndNonRef() ||\n+           p->isSlotSharedByRefAndNonRef()))\n+         p->setInitializedReference();\n+      ++numLocals;\n+      }\n+\n+   if (comp->getOption(TR_EnableAggressiveLiveness))\n+      {\n+      TR::ParameterSymbol *pp;\n+      ListIterator<TR::ParameterSymbol> parms(&comp->getMethodSymbol()->getParameterList());\n+      for (pp = parms.getFirst(); pp != NULL; pp = parms.getNext())\n+         ++numLocals;\n+      }\n+\n+   // Nothing to do if there are no locals\n+   //\n+   if (numLocals == 0)\n+      return;\n+\n+   TR_BitVector *liveVars = NULL;\n+\n+   // Perform liveness analysis\n+   //\n+   bool ignoreOSRuses = false; // Used to be set to true but we cannot set this to true because a variable may not be live in compiled code but may still be needed (live) in the interpreter\n+   /* for mimicInterpreterShape, because OSR points can extend the live range of autos\n+    * autos sharing the same slot in interpreter might end up with overlapped\n+    * live range if OSRUses are not ignored\n+    */\n+   if (comp->getOption(TR_MimicInterpreterFrameShape))\n+      ignoreOSRuses = true;\n+\n+   if (!comp->getFlowGraph()->getStructure())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY0ODc0Nw=="}, "originalCommit": {"oid": "9ff0cc85e1447f0575530a5c6cebae731933796d"}, "originalPosition": 96}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 940, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}