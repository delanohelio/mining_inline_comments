{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0MDU0Mjcz", "number": 10462, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNzo1MzowNFrOEdU9Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTo0MDo0NFrOEfhCRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTg3NTE1OnYy", "diffSide": "RIGHT", "path": "test/functional/Valhalla/playlist.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNzo1MzowNFrOHIbIng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzo0NjowM1rOHJ5g1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU5NTIzMA==", "bodyText": "-Xgcpolicy:optthruput -Xnocompactgc is used in -Xint when both  -XX:ValueTypeFlatteningThreshold=99999 and -XX:+EnableArrayFlattening are enabled.  To be consistent as -Xint test variations, is this variation added here for future when we add -XX:+EnableArrayFlattening to -Xjit test?", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478595230", "createdAt": "2020-08-27T17:53:04Z", "author": {"login": "a7ehuo"}, "path": "test/functional/Valhalla/playlist.xml", "diffHunk": "@@ -62,6 +62,8 @@\n \t\t\t  -\t<variation>-Xjit:count=0</variation>\n \t\t\t  -->\n \t\t\t<variation>-Xjit:count=1,disableAsyncCompilation</variation>\n+\t\t\t<variation>-Xjit:count=1,disableAsyncCompilation -Xgcpolicy:nogc -XX:ValueTypeFlatteningThreshold=99999</variation>\n+\t\t\t<variation>-Xjit:count=1,disableAsyncCompilation -Xgcpolicy:optthruput -Xnocompactgc -XX:ValueTypeFlatteningThreshold=99999</variation>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7da170fc78566c7cb6e242c2ee9b402472bd9a6d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE0MTUyNg==", "bodyText": "My understanding is that these are the only configurations we are supporting, so these are the configurations I'm testing.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r480141526", "createdAt": "2020-08-31T13:46:03Z", "author": {"login": "Leonardo2718"}, "path": "test/functional/Valhalla/playlist.xml", "diffHunk": "@@ -62,6 +62,8 @@\n \t\t\t  -\t<variation>-Xjit:count=0</variation>\n \t\t\t  -->\n \t\t\t<variation>-Xjit:count=1,disableAsyncCompilation</variation>\n+\t\t\t<variation>-Xjit:count=1,disableAsyncCompilation -Xgcpolicy:nogc -XX:ValueTypeFlatteningThreshold=99999</variation>\n+\t\t\t<variation>-Xjit:count=1,disableAsyncCompilation -Xgcpolicy:optthruput -Xnocompactgc -XX:ValueTypeFlatteningThreshold=99999</variation>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU5NTIzMA=="}, "originalCommit": {"oid": "7da170fc78566c7cb6e242c2ee9b402472bd9a6d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTkxODYwOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/compile/J9SymbolReferenceTable.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxODowNTo0N1rOHIbkKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzozMzoxOVrOHJ5CZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYwMjI4MQ==", "bodyText": "Would it make the API cleaner by combining these helpers into one API such as findOrCreateFlattenableSymbolRef(owningMethodSymbol, opCode, isStatic, isArrayElment) and have an enum to switch on the different optCode and type?", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478602281", "createdAt": "2020-08-27T18:05:47Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/compile/J9SymbolReferenceTable.hpp", "diffHunk": "@@ -110,7 +110,17 @@ class SymbolReferenceTable : public OMR::SymbolReferenceTableConnector\n    TR::SymbolReference * findOrCreateWriteBarrierClassStoreRealTimeGCSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = 0);\n    TR::SymbolReference * findOrCreateWriteBarrierBatchStoreSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = 0);\n \n-   TR::SymbolReference * findOrCreateAcmpHelperSymbolRef(TR::ResolvedMethodSymbol * owningMEthodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateAcmpHelperSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+\n+   // these helpers are guarenteed to never throw if the receiving object is not null,\n+   // so we explicit generate NULLCHKs and assume the helpers will never throw\n+   TR::SymbolReference * findOrCreateGetFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateWithFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreatePutFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateGetFlattenableStaticFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreatePutFlattenableStaticFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateLoadFlattenableArrayElementSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateStoreFlattenableArrayElementSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a5f95c1fcffff186871f77a133cce7ddfdf1609"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzMzczMw==", "bodyText": "Using separate functions for each helper symbol seems to be the convention. There is findOrCreateRuntimeHelper(), which takes in the enum name for the helper as an argument. I don't see a need for having a separate enum just for flattened value type helpers.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r480133733", "createdAt": "2020-08-31T13:33:19Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/compile/J9SymbolReferenceTable.hpp", "diffHunk": "@@ -110,7 +110,17 @@ class SymbolReferenceTable : public OMR::SymbolReferenceTableConnector\n    TR::SymbolReference * findOrCreateWriteBarrierClassStoreRealTimeGCSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = 0);\n    TR::SymbolReference * findOrCreateWriteBarrierBatchStoreSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = 0);\n \n-   TR::SymbolReference * findOrCreateAcmpHelperSymbolRef(TR::ResolvedMethodSymbol * owningMEthodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateAcmpHelperSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+\n+   // these helpers are guarenteed to never throw if the receiving object is not null,\n+   // so we explicit generate NULLCHKs and assume the helpers will never throw\n+   TR::SymbolReference * findOrCreateGetFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateWithFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreatePutFlattenableFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateGetFlattenableStaticFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreatePutFlattenableStaticFieldSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateLoadFlattenableArrayElementSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);\n+   TR::SymbolReference * findOrCreateStoreFlattenableArrayElementSymbolRef(TR::ResolvedMethodSymbol * owningMethodSymbol = NULL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYwMjI4MQ=="}, "originalCommit": {"oid": "3a5f95c1fcffff186871f77a133cce7ddfdf1609"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTk3MjU0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxODoyMjowMlrOHIcGbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNDoxMToxOVrOHJ6flQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxMTA1NA==", "bodyText": "Should isStore is passed in as true for isFieldResolved here?", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478611054", "createdAt": "2020-08-27T18:22:02Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6735,6 +6735,20 @@ TR_J9ByteCodeIlGenerator::storeInstance(int32_t cpIndex)\n    if (_generateWriteBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n \n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+   if (TR::Compiler->om.areValueTypesEnabled() && owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (!isFieldResolved(comp(), owningMethod, cpIndex, false))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f8470e6f85d170f6181381d5b19834a382a1511"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE1NzU4OQ==", "bodyText": "Fixed in force push", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r480157589", "createdAt": "2020-08-31T14:11:19Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6735,6 +6735,20 @@ TR_J9ByteCodeIlGenerator::storeInstance(int32_t cpIndex)\n    if (_generateWriteBarriersForFieldWatch && comp()->compileRelocatableCode())\n       comp()->failCompilation<J9::AOTNoSupportForAOTFailure>(\"NO support for AOT in field watch\");\n \n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+   if (TR::Compiler->om.areValueTypesEnabled() && owningMethod->isFieldQType(cpIndex))\n+      {\n+      if (!isFieldResolved(comp(), owningMethod, cpIndex, false))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxMTA1NA=="}, "originalCommit": {"oid": "1f8470e6f85d170f6181381d5b19834a382a1511"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTk5MjA3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxODoyNzo1NlrOHIcSlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzo0MTo0NlrOHJ5WXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxNDE2NA==", "bodyText": "I wonder if genFlattenableWithFieldWithHelper should be moved before the stack manipulation at line 6222. genFlattenableWithFieldWithHelper will take care of pop and push and genNullCheck instead of piggy back on genWithField here. It'd be easier down the road to debug the code when the stack manipulation inside one function. Actually loadFlattenableInstanceWithHelper and storeFlattenableInstanceWithHelper already do so.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478614164", "createdAt": "2020-08-27T18:27:56Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6231,6 +6231,13 @@ TR_J9ByteCodeIlGenerator::genWithField(uint16_t fieldCpIndex)\n    TR::Node *passThruNode = TR::Node::create(TR::PassThrough, 1, originalObject);\n    genTreeTop(genNullCheck(passThruNode));\n \n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+   if (owningMethod->isFieldQType(fieldCpIndex) && owningMethod->isFieldFlattened(comp(), fieldCpIndex, _methodSymbol->isStatic()))\n+      {\n+      genFlattenableWithFieldWithHelper(fieldCpIndex, newFieldValue, originalObject);\n+      return;\n+      }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c05be6691f9b107a095ac7791d695a8ffb1536"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzODg0Ng==", "bodyText": "Maybe.\ngenWithField() is a bit different from loadInstance() and storeInstance() because it only gets called when value types are enabled (i.e. the check is already done by the caller and there isn't anything to do if value types are disabled other than aborting compilation). My thinking was that organizing the code this way reduces code duplication. I'm not sure I see how putting the stack manipulation in one function is going to help with debugging.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r480138846", "createdAt": "2020-08-31T13:41:46Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6231,6 +6231,13 @@ TR_J9ByteCodeIlGenerator::genWithField(uint16_t fieldCpIndex)\n    TR::Node *passThruNode = TR::Node::create(TR::PassThrough, 1, originalObject);\n    genTreeTop(genNullCheck(passThruNode));\n \n+   TR_ResolvedJ9Method * owningMethod = static_cast<TR_ResolvedJ9Method*>(_methodSymbol->getResolvedMethod());\n+   if (owningMethod->isFieldQType(fieldCpIndex) && owningMethod->isFieldFlattened(comp(), fieldCpIndex, _methodSymbol->isStatic()))\n+      {\n+      genFlattenableWithFieldWithHelper(fieldCpIndex, newFieldValue, originalObject);\n+      return;\n+      }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxNDE2NA=="}, "originalCommit": {"oid": "01c05be6691f9b107a095ac7791d695a8ffb1536"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjAwNTI1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxODozMTo0OFrOHIcasQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzo0MzoxOFrOHJ5aOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxNjI0MQ==", "bodyText": "Why isn't  push(helperCallNode) needed here?", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r478616241", "createdAt": "2020-08-27T18:31:48Z", "author": {"login": "a7ehuo"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6868,6 +6882,25 @@ TR_J9ByteCodeIlGenerator::storeInstance(int32_t cpIndex)\n       }\n    }\n \n+void\n+TR_J9ByteCodeIlGenerator::storeFlattenableInstanceWithHelper(int32_t cpIndex)\n+   {\n+   TR::Node * value = pop();\n+   TR::Node * address = pop();\n+   if (!address->isNonNull())\n+      {\n+      auto* nullchk = TR::Node::create(TR::PassThrough, 1, address);\n+      nullchk = genNullCheck(nullchk);\n+      genTreeTop(nullchk);\n+      }\n+   auto* j9ResolvedMethod = static_cast<TR_ResolvedJ9Method *>(_methodSymbol->getResolvedMethod());\n+   auto* ramFieldRef = reinterpret_cast<J9RAMFieldRef*>(j9ResolvedMethod->cp()) + cpIndex;\n+   auto* ramFieldRefNode = TR::Node::aconst(reinterpret_cast<uintptr_t>(ramFieldRef));\n+   auto* helperCallNode = TR::Node::createWithSymRef(TR::acall, 3, 3, value, address, ramFieldRefNode, comp()->getSymRefTab()->findOrCreatePutFlattenableFieldSymbolRef());\n+   handleSideEffect(helperCallNode);\n+   genTreeTop(helperCallNode);\n+   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f8470e6f85d170f6181381d5b19834a382a1511"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzOTgzNQ==", "bodyText": "putfield doesn't produce a result, so there is nothing to push on the stack.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r480139835", "createdAt": "2020-08-31T13:43:18Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -6868,6 +6882,25 @@ TR_J9ByteCodeIlGenerator::storeInstance(int32_t cpIndex)\n       }\n    }\n \n+void\n+TR_J9ByteCodeIlGenerator::storeFlattenableInstanceWithHelper(int32_t cpIndex)\n+   {\n+   TR::Node * value = pop();\n+   TR::Node * address = pop();\n+   if (!address->isNonNull())\n+      {\n+      auto* nullchk = TR::Node::create(TR::PassThrough, 1, address);\n+      nullchk = genNullCheck(nullchk);\n+      genTreeTop(nullchk);\n+      }\n+   auto* j9ResolvedMethod = static_cast<TR_ResolvedJ9Method *>(_methodSymbol->getResolvedMethod());\n+   auto* ramFieldRef = reinterpret_cast<J9RAMFieldRef*>(j9ResolvedMethod->cp()) + cpIndex;\n+   auto* ramFieldRefNode = TR::Node::aconst(reinterpret_cast<uintptr_t>(ramFieldRef));\n+   auto* helperCallNode = TR::Node::createWithSymRef(TR::acall, 3, 3, value, address, ramFieldRefNode, comp()->getSymRefTab()->findOrCreatePutFlattenableFieldSymbolRef());\n+   handleSideEffect(helperCallNode);\n+   genTreeTop(helperCallNode);\n+   }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxNjI0MQ=="}, "originalCommit": {"oid": "1f8470e6f85d170f6181381d5b19834a382a1511"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDEyODM4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/j9fieldsInfo.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyOToxMlrOHLHENg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTowMTo0N1rOHLzdrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMjE1MA==", "bodyText": "This is a real nit, and I know the loop was already coded this way, but if the value of the index variable i is never used in this loop, is there any reason for having this loop count down to zero rather than writing?\nfor (int32_t i = 0; i < numSupClasses; i++)", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r481412150", "createdAt": "2020-09-01T20:29:12Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -121,38 +103,18 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n             _statics = new (_comp->trMemory(), allocKind) TR_ScratchList<TR_VMField> (_comp->trMemory());\n             break;\n          default:\n-         \tbreak;\n+            TR_ASSERT_FATAL(false, \"Unknown allocation kind %d\", allocKind);\n          }\n-\t  }\n-   else\n-\t  {\n-      _fields = NULL;\n-      _statics = NULL;\n-\t  }\n-   _numRefSlotsInObject = 0;\n+      }\n \n    // self\n-   romCl = aClazz->romClass;\n-   TR_ASSERT(!(romCl->modifiers & J9AccClassArray), \"Cannot construct TR_VMFieldsInfo for array class %p\", aClazz);\n-   currentField = romFieldsStartDo(romCl, &state);\n-   while (currentField)\n-      {\n-      if ((currentField->modifiers & J9AccStatic) == 0)\n-         {\n-         totalNumFields++;\n-         _numRefSlotsInObject += buildField(aClazz, currentField);\n-         }\n-\t  else\n-\t\t {\n-         buildField(aClazz, currentField);\n-\t\t }\n-      currentField = romFieldsNextDo(&state);\n-      }\n+   TR_ASSERT(!(aClazz->romClass->modifiers & J9AccClassArray), \"Cannot construct TR_VMFieldsInfo for array class %p\", aClazz);\n+   collectFieldInfo(aClazz);\n \n    //supers\n-   int numSupClasses = J9CLASS_DEPTH(aClazz);\n+   const int32_t numSupClasses = J9CLASS_DEPTH(aClazz);\n    J9Class *supClass = aClazz;\n-   for (i=numSupClasses-1; i>=0; i--)\n+   for (int32_t i = numSupClasses-1; i>=0; i--)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae2c6b4d97fe082ef5994a6f31741e5a51db001"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzOTU2Ng==", "bodyText": "Yeah, migh as well make it a \"normal\" for loop. Fixed in force push.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482139566", "createdAt": "2020-09-02T15:01:47Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -121,38 +103,18 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n             _statics = new (_comp->trMemory(), allocKind) TR_ScratchList<TR_VMField> (_comp->trMemory());\n             break;\n          default:\n-         \tbreak;\n+            TR_ASSERT_FATAL(false, \"Unknown allocation kind %d\", allocKind);\n          }\n-\t  }\n-   else\n-\t  {\n-      _fields = NULL;\n-      _statics = NULL;\n-\t  }\n-   _numRefSlotsInObject = 0;\n+      }\n \n    // self\n-   romCl = aClazz->romClass;\n-   TR_ASSERT(!(romCl->modifiers & J9AccClassArray), \"Cannot construct TR_VMFieldsInfo for array class %p\", aClazz);\n-   currentField = romFieldsStartDo(romCl, &state);\n-   while (currentField)\n-      {\n-      if ((currentField->modifiers & J9AccStatic) == 0)\n-         {\n-         totalNumFields++;\n-         _numRefSlotsInObject += buildField(aClazz, currentField);\n-         }\n-\t  else\n-\t\t {\n-         buildField(aClazz, currentField);\n-\t\t }\n-      currentField = romFieldsNextDo(&state);\n-      }\n+   TR_ASSERT(!(aClazz->romClass->modifiers & J9AccClassArray), \"Cannot construct TR_VMFieldsInfo for array class %p\", aClazz);\n+   collectFieldInfo(aClazz);\n \n    //supers\n-   int numSupClasses = J9CLASS_DEPTH(aClazz);\n+   const int32_t numSupClasses = J9CLASS_DEPTH(aClazz);\n    J9Class *supClass = aClazz;\n-   for (i=numSupClasses-1; i>=0; i--)\n+   for (int32_t i = numSupClasses-1; i>=0; i--)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMjE1MA=="}, "originalCommit": {"oid": "fae2c6b4d97fe082ef5994a6f31741e5a51db001"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDE0MzM4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/j9fieldsInfo.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDozMzo1NVrOHLHNYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTowMjozMFrOHLzg3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDQ5Nw==", "bodyText": "Another nit - as long as you're correcting the indentation, I think this break is still indented too far.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r481414497", "createdAt": "2020-09-01T20:33:55Z", "author": {"login": "hzongaro"}, "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -166,127 +128,81 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n          TR_ASSERT_FATAL(supClass, \"Found NULL supClass in inheritance chain\");\n          }\n \n-      romCl = supClass->romClass;\n-\n-      // iterate through the fields creating TR_VMField and inserting them into a List\n-\n-      currentField = romFieldsStartDo(romCl, &state);\n-      while (currentField)\n-         {\n-         if ((currentField->modifiers & J9AccStatic) == 0)\n-            {\n-            totalNumFields++;\n-            _numRefSlotsInObject += buildField(supClass, currentField);\n-            }\n-         else\n-            {\n-            buildField(supClass, currentField);\n-            }\n-         currentField = romFieldsNextDo(&state);\n-         }\n+      collectFieldInfo(supClass);\n       }\n \n    // copy the GCData\n-   numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n-   numRefs = 0;\n-   descriptorPtr = aClazz->instanceDescription;\n-\n-   // null terminated\n-   _gcDescriptor = (int32_t *) _comp->trMemory()->allocateMemory((_numRefSlotsInObject+1)*sizeof(int32_t), allocKind);\n-   _gcDescriptor[_numRefSlotsInObject] = 0;\n+   UDATA *descriptorPtr = aClazz->instanceDescription;\n+   UDATA descriptorWord=0;\n \n-   slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n-   countSlots = slotsInHeader;\n-   bitIndex = 0;\n+   int32_t bitIndex = 0;\n    if ( ((UDATA) descriptorPtr) & BCT_J9DescriptionImmediate )\n       {\n       bitIndex++;\n       descriptorWord = ((UDATA) descriptorPtr) >> 1;\n       }\n    else\n-     {\n-     descriptorWord = descriptorPtr[0];\n-     }\n+      {\n+      descriptorWord = descriptorPtr[0];\n+      }\n \n+   const int32_t numBytesInSlot = TR::Compiler->om.sizeofReferenceField();\n+   const int32_t numBitsInWord = 8*sizeof(decltype(*(aClazz->instanceDescription)));\n+   const int32_t numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n+   const uintptr_t slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n+   uintptr_t countSlots = slotsInHeader;\n    while (1)\n       {\n-       if ( descriptorWord & 0x1 )\n-          {\n-           _gcDescriptor[numRefs++] = countSlots;\n-          }\n-       countSlots++;\n-       if (countSlots >= (slotsInHeader + numSlotsInObject))\n-          {\n-             break;\n-          }\n-       if (bitIndex == (numBitsInWord - 1))\n-          {\n-          descriptorPtr++;\n-          bitIndex = 0;\n-          descriptorWord = *descriptorPtr;\n-          }\n-       else\n-          {\n-          descriptorWord = descriptorWord >> 1;\n-          bitIndex++;\n-          }\n+      if ( descriptorWord & 0x1 )\n+         {\n+         _gcDescriptor.push_back(countSlots);\n+         }\n+      countSlots++;\n+      if (countSlots >= (slotsInHeader + numSlotsInObject))\n+         {\n+            break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae2c6b4d97fe082ef5994a6f31741e5a51db001"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE0MDM4MA==", "bodyText": "Yep, somehow I missed that one. \ud83d\ude05\nFixed in force push.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482140380", "createdAt": "2020-09-02T15:02:30Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -166,127 +128,81 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n          TR_ASSERT_FATAL(supClass, \"Found NULL supClass in inheritance chain\");\n          }\n \n-      romCl = supClass->romClass;\n-\n-      // iterate through the fields creating TR_VMField and inserting them into a List\n-\n-      currentField = romFieldsStartDo(romCl, &state);\n-      while (currentField)\n-         {\n-         if ((currentField->modifiers & J9AccStatic) == 0)\n-            {\n-            totalNumFields++;\n-            _numRefSlotsInObject += buildField(supClass, currentField);\n-            }\n-         else\n-            {\n-            buildField(supClass, currentField);\n-            }\n-         currentField = romFieldsNextDo(&state);\n-         }\n+      collectFieldInfo(supClass);\n       }\n \n    // copy the GCData\n-   numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n-   numRefs = 0;\n-   descriptorPtr = aClazz->instanceDescription;\n-\n-   // null terminated\n-   _gcDescriptor = (int32_t *) _comp->trMemory()->allocateMemory((_numRefSlotsInObject+1)*sizeof(int32_t), allocKind);\n-   _gcDescriptor[_numRefSlotsInObject] = 0;\n+   UDATA *descriptorPtr = aClazz->instanceDescription;\n+   UDATA descriptorWord=0;\n \n-   slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n-   countSlots = slotsInHeader;\n-   bitIndex = 0;\n+   int32_t bitIndex = 0;\n    if ( ((UDATA) descriptorPtr) & BCT_J9DescriptionImmediate )\n       {\n       bitIndex++;\n       descriptorWord = ((UDATA) descriptorPtr) >> 1;\n       }\n    else\n-     {\n-     descriptorWord = descriptorPtr[0];\n-     }\n+      {\n+      descriptorWord = descriptorPtr[0];\n+      }\n \n+   const int32_t numBytesInSlot = TR::Compiler->om.sizeofReferenceField();\n+   const int32_t numBitsInWord = 8*sizeof(decltype(*(aClazz->instanceDescription)));\n+   const int32_t numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n+   const uintptr_t slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n+   uintptr_t countSlots = slotsInHeader;\n    while (1)\n       {\n-       if ( descriptorWord & 0x1 )\n-          {\n-           _gcDescriptor[numRefs++] = countSlots;\n-          }\n-       countSlots++;\n-       if (countSlots >= (slotsInHeader + numSlotsInObject))\n-          {\n-             break;\n-          }\n-       if (bitIndex == (numBitsInWord - 1))\n-          {\n-          descriptorPtr++;\n-          bitIndex = 0;\n-          descriptorWord = *descriptorPtr;\n-          }\n-       else\n-          {\n-          descriptorWord = descriptorWord >> 1;\n-          bitIndex++;\n-          }\n+      if ( descriptorWord & 0x1 )\n+         {\n+         _gcDescriptor.push_back(countSlots);\n+         }\n+      countSlots++;\n+      if (countSlots >= (slotsInHeader + numSlotsInObject))\n+         {\n+            break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDQ5Nw=="}, "originalCommit": {"oid": "fae2c6b4d97fe082ef5994a6f31741e5a51db001"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDMxMTMzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/j9fieldsInfo.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMToyNDo1MlrOHLIzAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNToxMTo1NFrOHL0HIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MDUxNA==", "bodyText": "Is there a macro or other helper to do this test and the shifting? Just wanting to avoid magic values if possible...", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r481440514", "createdAt": "2020-09-01T21:24:52Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -166,127 +128,81 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n          TR_ASSERT_FATAL(supClass, \"Found NULL supClass in inheritance chain\");\n          }\n \n-      romCl = supClass->romClass;\n-\n-      // iterate through the fields creating TR_VMField and inserting them into a List\n-\n-      currentField = romFieldsStartDo(romCl, &state);\n-      while (currentField)\n-         {\n-         if ((currentField->modifiers & J9AccStatic) == 0)\n-            {\n-            totalNumFields++;\n-            _numRefSlotsInObject += buildField(supClass, currentField);\n-            }\n-         else\n-            {\n-            buildField(supClass, currentField);\n-            }\n-         currentField = romFieldsNextDo(&state);\n-         }\n+      collectFieldInfo(supClass);\n       }\n \n    // copy the GCData\n-   numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n-   numRefs = 0;\n-   descriptorPtr = aClazz->instanceDescription;\n-\n-   // null terminated\n-   _gcDescriptor = (int32_t *) _comp->trMemory()->allocateMemory((_numRefSlotsInObject+1)*sizeof(int32_t), allocKind);\n-   _gcDescriptor[_numRefSlotsInObject] = 0;\n+   UDATA *descriptorPtr = aClazz->instanceDescription;\n+   UDATA descriptorWord=0;\n \n-   slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n-   countSlots = slotsInHeader;\n-   bitIndex = 0;\n+   int32_t bitIndex = 0;\n    if ( ((UDATA) descriptorPtr) & BCT_J9DescriptionImmediate )\n       {\n       bitIndex++;\n       descriptorWord = ((UDATA) descriptorPtr) >> 1;\n       }\n    else\n-     {\n-     descriptorWord = descriptorPtr[0];\n-     }\n+      {\n+      descriptorWord = descriptorPtr[0];\n+      }\n \n+   const int32_t numBytesInSlot = TR::Compiler->om.sizeofReferenceField();\n+   const int32_t numBitsInWord = 8*sizeof(decltype(*(aClazz->instanceDescription)));\n+   const int32_t numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n+   const uintptr_t slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n+   uintptr_t countSlots = slotsInHeader;\n    while (1)\n       {\n-       if ( descriptorWord & 0x1 )\n-          {\n-           _gcDescriptor[numRefs++] = countSlots;\n-          }\n-       countSlots++;\n-       if (countSlots >= (slotsInHeader + numSlotsInObject))\n-          {\n-             break;\n-          }\n-       if (bitIndex == (numBitsInWord - 1))\n-          {\n-          descriptorPtr++;\n-          bitIndex = 0;\n-          descriptorWord = *descriptorPtr;\n-          }\n-       else\n-          {\n-          descriptorWord = descriptorWord >> 1;\n-          bitIndex++;\n-          }\n+      if ( descriptorWord & 0x1 )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE1MDE3Nw==", "bodyText": "Yeah, I don't like the magic constant either (actually I don't like any of this descriptorWord code). But, I couldn't find any macros for it and it looks like the GC also does it this way (although the code is much more elegant):\nhttps://github.com/eclipse/openj9/blob/a91c5af9b85a1894fd641c03956def8d97b0eea4/runtime/gc_base/ClassModel.hpp#L114-L138", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482150177", "createdAt": "2020-09-02T15:11:54Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/env/j9fieldsInfo.cpp", "diffHunk": "@@ -166,127 +128,81 @@ TR_VMFieldsInfo::TR_VMFieldsInfo(TR::Compilation * comp, J9Class *aClazz, int bu\n          TR_ASSERT_FATAL(supClass, \"Found NULL supClass in inheritance chain\");\n          }\n \n-      romCl = supClass->romClass;\n-\n-      // iterate through the fields creating TR_VMField and inserting them into a List\n-\n-      currentField = romFieldsStartDo(romCl, &state);\n-      while (currentField)\n-         {\n-         if ((currentField->modifiers & J9AccStatic) == 0)\n-            {\n-            totalNumFields++;\n-            _numRefSlotsInObject += buildField(supClass, currentField);\n-            }\n-         else\n-            {\n-            buildField(supClass, currentField);\n-            }\n-         currentField = romFieldsNextDo(&state);\n-         }\n+      collectFieldInfo(supClass);\n       }\n \n    // copy the GCData\n-   numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n-   numRefs = 0;\n-   descriptorPtr = aClazz->instanceDescription;\n-\n-   // null terminated\n-   _gcDescriptor = (int32_t *) _comp->trMemory()->allocateMemory((_numRefSlotsInObject+1)*sizeof(int32_t), allocKind);\n-   _gcDescriptor[_numRefSlotsInObject] = 0;\n+   UDATA *descriptorPtr = aClazz->instanceDescription;\n+   UDATA descriptorWord=0;\n \n-   slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n-   countSlots = slotsInHeader;\n-   bitIndex = 0;\n+   int32_t bitIndex = 0;\n    if ( ((UDATA) descriptorPtr) & BCT_J9DescriptionImmediate )\n       {\n       bitIndex++;\n       descriptorWord = ((UDATA) descriptorPtr) >> 1;\n       }\n    else\n-     {\n-     descriptorWord = descriptorPtr[0];\n-     }\n+      {\n+      descriptorWord = descriptorPtr[0];\n+      }\n \n+   const int32_t numBytesInSlot = TR::Compiler->om.sizeofReferenceField();\n+   const int32_t numBitsInWord = 8*sizeof(decltype(*(aClazz->instanceDescription)));\n+   const int32_t numSlotsInObject = (aClazz->totalInstanceSize + numBytesInSlot - 1)/numBytesInSlot;\n+   const uintptr_t slotsInHeader = (TR::Compiler->om.objectHeaderSizeInBytes()/numBytesInSlot);\n+   uintptr_t countSlots = slotsInHeader;\n    while (1)\n       {\n-       if ( descriptorWord & 0x1 )\n-          {\n-           _gcDescriptor[numRefs++] = countSlots;\n-          }\n-       countSlots++;\n-       if (countSlots >= (slotsInHeader + numSlotsInObject))\n-          {\n-             break;\n-          }\n-       if (bitIndex == (numBitsInWord - 1))\n-          {\n-          descriptorPtr++;\n-          bitIndex = 0;\n-          descriptorWord = *descriptorPtr;\n-          }\n-       else\n-          {\n-          descriptorWord = descriptorWord >> 1;\n-          bitIndex++;\n-          }\n+      if ( descriptorWord & 0x1 )", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MDUxNA=="}, "originalCommit": {"oid": "121d2f4f2b9d51a06caf82ced2fa3d92249ca4bd"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDgyNTY3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTo0MDo0NFrOHL1bAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNDoxOToxMFrOHPJtCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA==", "bodyText": "Why do we do runtime resolve when we can safely compile-time resolve it? Other fields only need resolve check when we can't compile-time resolve them. Are ValueType fields different?", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482171648", "createdAt": "2020-09-02T15:40:44Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,11 +5061,48 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+/**\n+ * @brief Returns whether a field ref in the constant pool resolved\n+ *\n+ * Importantly, when this function returns false, a ResolveCHK is guarenteed to be needed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4ODcyNg==", "bodyText": "My understanding was that a resolve check is still needed for compile-time resolved fields. @andrewcraik can you confirm what the correct behaviour is?", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482188726", "createdAt": "2020-09-02T16:05:28Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,11 +5061,48 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+/**\n+ * @brief Returns whether a field ref in the constant pool resolved\n+ *\n+ * Importantly, when this function returns false, a ResolveCHK is guarenteed to be needed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, "originalCommit": {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyNDIwMA==", "bodyText": "A compile-time resolve is not a true resolve - it is a promise from the VM that we know what the entry is going to resolve to - if the entry in the constant pool is not resolved when we start compiling and isn't genuinely resolved after the helper call the resolvechk is needed to make the resolution happen at the appropriate point at runtime.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482224200", "createdAt": "2020-09-02T17:01:15Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,11 +5061,48 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+/**\n+ * @brief Returns whether a field ref in the constant pool resolved\n+ *\n+ * Importantly, when this function returns false, a ResolveCHK is guarenteed to be needed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, "originalCommit": {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NDQzNw==", "bodyText": "@andrewcraik My understanding is that, if VM knows what the entry is going to resolve to, we'll treat it resolved even if the entry is not resolved in cp. That's what we do for other fields (we also do so for method calls except when rtResolve is on).\nMy impression is that when the JIT ask the VM to compile time resolve something, the VM looks up that thing with restrictions, such as no java code is allowed during the look up. So if a cp entry can be compile-time resolved, it means its resolution has no side effect, and the runtime resolution is not necessary since we know what it is.\nWhile my impression may be inaccurate, my question is with us treating other compile-time resolvable fields resolved, what makes the ValueType fields different? If there is a difference, may be a comment is needed to explain the difference.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482264437", "createdAt": "2020-09-02T18:03:47Z", "author": {"login": "liqunl"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,11 +5061,48 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+/**\n+ * @brief Returns whether a field ref in the constant pool resolved\n+ *\n+ * Importantly, when this function returns false, a ResolveCHK is guarenteed to be needed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, "originalCommit": {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NzEyMQ==", "bodyText": "I don't think there is a difference, but we should ask @tajila or @DanHeidinga to confirm if they want the JIT to call to resolve the CP entry or not or if we can skip that.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482267121", "createdAt": "2020-09-02T18:08:50Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,11 +5061,48 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+/**\n+ * @brief Returns whether a field ref in the constant pool resolved\n+ *\n+ * Importantly, when this function returns false, a ResolveCHK is guarenteed to be needed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, "originalCommit": {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxNDE1OQ==", "bodyText": "For fields, if the compile-time resolve is successful then we update the linkage state for the cpEntry. This is equivalent to what would happen in the case of a runtime resolve. If the compile-time resolve fails then the runtime resolution must be run, so that appropriate exceptions can be thrown.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482314159", "createdAt": "2020-09-02T19:02:41Z", "author": {"login": "tajila"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,11 +5061,48 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+/**\n+ * @brief Returns whether a field ref in the constant pool resolved\n+ *\n+ * Importantly, when this function returns false, a ResolveCHK is guarenteed to be needed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, "originalCommit": {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMyMDIyMw==", "bodyText": "Ok so that means for a field resolve that succeeds at compile time we can skip the ResolveCHK, but failure means the ResolveCHK must remain.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r482320223", "createdAt": "2020-09-02T19:09:36Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,11 +5061,48 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+/**\n+ * @brief Returns whether a field ref in the constant pool resolved\n+ *\n+ * Importantly, when this function returns false, a ResolveCHK is guarenteed to be needed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, "originalCommit": {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY0OTY3Mg==", "bodyText": "Changed in force push to return the result of the compile-time resolve.", "url": "https://github.com/eclipse-openj9/openj9/pull/10462#discussion_r485649672", "createdAt": "2020-09-09T14:19:10Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -5061,11 +5061,48 @@ TR_J9ByteCodeIlGenerator::loadAuto(TR::DataType type, int32_t slot, bool isAdjun\n    push(load);\n    }\n \n+/**\n+ * @brief Returns whether a field ref in the constant pool resolved\n+ *\n+ * Importantly, when this function returns false, a ResolveCHK is guarenteed to be needed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTY0OA=="}, "originalCommit": {"oid": "f6f521ed788389d01ba6f7836c0569ea970844f2"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4740, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}