{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2MTQxNzk5", "number": 9517, "title": "Fix instanceOf's dynamicCache sequence on IBM Z", "bodyText": "On IBM Z, for instanceOf node, we have a codegen optimization which caches the encountered classes for which it failed all the inline tests and has to call JIT helper to get the result. This cache is first tested to avoid a call to JIT helper. There was a bug in case we have to cache class of of child when cast class child of the node is runtime variable. We were loading and storing associated fields using two load and store instructions. This causes a potential data race condition which was exploited by highly parallel application where more than 500 threads were running same method and all were trying to update the cache, leaving with the classes in the cache which were not related and in the code which later can cause incorrect result for instanceof.\nFixes: #9457\nSigned-off-by: Rahil Shah rahil@ca.ibm.com", "createdAt": "2020-05-11T14:29:16Z", "url": "https://github.com/eclipse-openj9/openj9/pull/9517", "merged": true, "mergeCommit": {"oid": "fd8f8ec5133103c2f2c5aab0873bfe04010a7f08"}, "closed": true, "closedAt": "2020-06-01T15:05:48Z", "author": {"login": "r30shah"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABck2wOLABqjMzNzEyNzc2Nzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclwFfLgFqTQyMDI2NDYyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "69ec9e339685ad3bb0f074bab317876a78624cd3", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/69ec9e339685ad3bb0f074bab317876a78624cd3", "committedDate": "2020-05-13T21:50:27Z", "message": "Fix some functional Bugs and Add Comments\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "083195889ffe858775dd19742020aaa0d69d36ee", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/083195889ffe858775dd19742020aaa0d69d36ee", "committedDate": "2020-05-25T20:59:56Z", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "083195889ffe858775dd19742020aaa0d69d36ee", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/083195889ffe858775dd19742020aaa0d69d36ee", "committedDate": "2020-05-25T20:59:56Z", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "9a5b4fc232092e87260ec0df2853c26858214e5b", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9a5b4fc232092e87260ec0df2853c26858214e5b", "committedDate": "2020-05-25T21:16:02Z", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a5b4fc232092e87260ec0df2853c26858214e5b", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/9a5b4fc232092e87260ec0df2853c26858214e5b", "committedDate": "2020-05-25T21:16:02Z", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "3a4703eaf139c681caf30931dfc1308949d43e15", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3a4703eaf139c681caf30931dfc1308949d43e15", "committedDate": "2020-05-26T18:20:34Z", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5Mzk3OTAw", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#pullrequestreview-419397900", "createdAt": "2020-05-27T16:23:59Z", "commit": {"oid": "3a4703eaf139c681caf30931dfc1308949d43e15"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNjoyMzo1OVrOGbS8ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNjoyMzo1OVrOGbS8ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3NTE2Ng==", "bodyText": "I think we should limit this change to Z only. @dsouzai @mpirvu FYI regarding this change in AOT alignment.\nThere is a more general problem in that AOT methods are not being aligned to the same boundary that JIT methods are. I think this is due to not using the same APIs when allocating memory for an AOT load. In normal JIT compilations we will have used allocateCodeMemory [1] and a few lines below a call to alignBinaryBufferCursor [2] which aligns the entry point based off of getJitMethodEntryAlignmentBoundary which codegens override. Every codegen does this in the same way and this was all consolidated in a cross platform way in eclipse/omr#4314.\nI don't see AOT code allocations doing the same thing so we can run into various problems as seen in this PR. I think this needs to be addressed and the code being reviewed here needs to be deprecated in favor of the codegen APIs. Thoughts?\n[1] https://github.com/eclipse/omr/blob/99d7e521e1f8d083ab6bf558d3b8b9264579e46d/compiler/z/codegen/OMRCodeGenerator.cpp#L2431-L2435\n[2] https://github.com/eclipse/omr/blob/99d7e521e1f8d083ab6bf558d3b8b9264579e46d/compiler/codegen/OMRCodeGenerator.cpp#L2196-L2230", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431275166", "createdAt": "2020-05-27T16:23:59Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/runtime/codertinit.cpp", "diffHunk": "@@ -222,7 +222,7 @@ J9JITConfig * codert_onload(J9JavaVM * javaVM)\n #elif defined(TR_HOST_64BIT) || defined(TR_HOST_S390)\n    // 390 31-bit may generate 64-bit instruction (i.e. CGRL) which requires\n    // doubleword alignment for its operands\n-   jitConfig->codeCacheAlignment = 8;\n+   jitConfig->codeCacheAlignment = 16;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4703eaf139c681caf30931dfc1308949d43e15"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a4703eaf139c681caf30931dfc1308949d43e15", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3a4703eaf139c681caf30931dfc1308949d43e15", "committedDate": "2020-05-26T18:20:34Z", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "836d4b19681641d3c250d756ce09c06719a3f5f7", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/836d4b19681641d3c250d756ce09c06719a3f5f7", "committedDate": "2020-05-27T16:57:46Z", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NDA0MjU4", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#pullrequestreview-419404258", "createdAt": "2020-05-27T16:31:39Z", "commit": {"oid": "3a4703eaf139c681caf30931dfc1308949d43e15"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNjozMTozOVrOGbTPxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNjo1NDo1MFrOGbUSOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI4MDA2OA==", "bodyText": "These trace statements should be guarded by TR_TraceCG", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431280068", "createdAt": "2020-05-27T16:31:39Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6327,83 +6327,150 @@ static bool graDepsConflictWithInstanceOfDeps(TR::Node * depNode, TR::Node * nod\n  *     This function generates a sequence to check per site cache for object class and cast class before calling out to jitInstanceOf helper\n  */\n static\n-void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n+void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR::RegisterDependencyConditions *deps, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n    {\n    TR::Compilation                *comp = cg->comp();\n    bool needResult = resultReg != NULL;\n    if (!castClassReg)\n-      castClassReg = cg->evaluate(node->getSecondChild());\n+      castClassReg = cg->gprClobberEvaluate(node->getSecondChild());\n+\n    int32_t maxOnsiteCacheSlots = comp->getOptions()->getMaxOnsiteCacheSlotForInstanceOf();\n-   TR::Register *dynamicCacheReg = NULL;\n-   int32_t addressSize = TR::Compiler->om.sizeofReferenceAddress();\n+   int32_t fieldSize = TR::Compiler->om.sizeofReferenceField();\n+   bool isTarget64Bit = comp->target().is64Bit();\n+   bool isCompressedRef = comp->useCompressedPointers();\n    /* Layout of the writable data snippet\n     * Case - 1 : Cast class is runtime variable\n-    * [UpdateIndex][ObjClassSlot-0][CastClassSlot-0]...[ObjClassSlot-N][CastClassSlot-N]\n-    * Case - 2 : Cast Class is interface / unresolved\n-    * [UpdateIndex][ObjClassSlot-0]...[ObjClassSlot-N]\n+    *    Case - 1A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        8                   12                ... 8n                  8n+4\n+    *    Case - 1B: 64 Bit Non Compressedrefs\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        16                  24                ... 16n                 16n+8\n+    * Case - 2 : Cast Class is resolved\n+    *    Case - 2A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         4                   8                   ... 4n\n+    *    Case - 2B: 64 Bit Non Compressedrefs\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         8                   16                   ... 8n\n+    *\n     * If there is only one cache slot, we will not have header.\n     * Last bit of cached objectClass will set to 1 indicating false cast\n+    *\n+    * We can request the snippet size of power 2. Following Table summarizes bytes needed for corresponding number of cache slots.\n+    * \n+    * Following is the table for the number of bytes in snippet needed by each of the Cases mentioned above\n+    *\n+    * Number Of Slots | Case 1A | Case 1B | Case 2A | Case 2B |\n+    *       1         |    8    |   16    |    4    |    8    |\n+    *       2         |    16   |   64    |    16   |    32   |\n+    *       3         |    32   |   64    |    16   |    32   |\n+    *       4         |    64   |   128   |    32   |    64   |\n+    *       5         |    64   |   128   |    32   |    64   |\n+    *       6         |    64   |   128   |    32   |    64   |\n+    *\n     */\n-   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * addressSize) + (addressSize * (maxOnsiteCacheSlots != 1));\n+   \n+   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * fieldSize) + (fieldSize * (maxOnsiteCacheSlots != 1) * (cacheCastClass ? 2 : 1));\n+   TR::Register *dynamicCacheReg = NULL;\n+   \n    if (generateDynamicCache)\n       {\n       TR::S390WritableDataSnippet *dynamicCacheSnippet = NULL;\n-      /* We can only request the snippet size of power 2, following table summarizes bytes needed for corresponding number of cache slots\n-       * Case 1 : Cast class is runtime variable\n-       * Case 2 : Cast class is interface / unresolved\n-       * Number Of Slots |  Bytes needed for Case 1 | Bytes needed for Case 2\n-       *        1        |              16          |           8\n-       *        2        |              64          |           32\n-       *        3        |              64          |           32\n-       *        4        |              128         |           64\n-       *        5        |              128         |           64\n-       *        6        |              128         |           64\n-       */\n       int32_t requestedBytes = 1 << (int) (log2(snippetSizeInBytes-1)+1);\n-      traceMsg(comp, \"Requested Bytes = %d\\n\",requestedBytes);\n-      // NOTE: For single slot cache, we initialize snippet with addressSize (4/8) assuming which can not be objectClass\n-      // In all cases, we use first addressSize bytes to store offset of the circular buffer and rest of buffer will be initialized with 0xf.\n+      traceMsg(comp, \"Number Of Dynamic Cache Slots = %d, Caching CastClass: %s\\n\"\n+                     \"Bytes needed for Snippet = %d, requested Bytes = %d\\n\",maxOnsiteCacheSlots, cacheCastClass ? \"true\" : \"false\", snippetSizeInBytes, requestedBytes);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4703eaf139c681caf30931dfc1308949d43e15"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI4NDQxNg==", "bodyText": "Field of what type? It can be an int, byte[], Object, etc. I think this variable is better named as sizeofJ9ClassFieldWithinReference which directly indicates that we are talking about size of the J9Class* within an object reference.", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431284416", "createdAt": "2020-05-27T16:37:10Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6327,83 +6327,150 @@ static bool graDepsConflictWithInstanceOfDeps(TR::Node * depNode, TR::Node * nod\n  *     This function generates a sequence to check per site cache for object class and cast class before calling out to jitInstanceOf helper\n  */\n static\n-void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n+void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR::RegisterDependencyConditions *deps, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n    {\n    TR::Compilation                *comp = cg->comp();\n    bool needResult = resultReg != NULL;\n    if (!castClassReg)\n-      castClassReg = cg->evaluate(node->getSecondChild());\n+      castClassReg = cg->gprClobberEvaluate(node->getSecondChild());\n+\n    int32_t maxOnsiteCacheSlots = comp->getOptions()->getMaxOnsiteCacheSlotForInstanceOf();\n-   TR::Register *dynamicCacheReg = NULL;\n-   int32_t addressSize = TR::Compiler->om.sizeofReferenceAddress();\n+   int32_t fieldSize = TR::Compiler->om.sizeofReferenceField();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4703eaf139c681caf30931dfc1308949d43e15"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MzUzOA==", "bodyText": "I have a hunch this may not be correct due to @gacholio's work. I believe the size of this type is not going to be a compile time constant in the future which will cause us problems. GAC can you confirm?", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431293538", "createdAt": "2020-05-27T16:51:21Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6327,83 +6327,150 @@ static bool graDepsConflictWithInstanceOfDeps(TR::Node * depNode, TR::Node * nod\n  *     This function generates a sequence to check per site cache for object class and cast class before calling out to jitInstanceOf helper\n  */\n static\n-void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n+void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR::RegisterDependencyConditions *deps, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n    {\n    TR::Compilation                *comp = cg->comp();\n    bool needResult = resultReg != NULL;\n    if (!castClassReg)\n-      castClassReg = cg->evaluate(node->getSecondChild());\n+      castClassReg = cg->gprClobberEvaluate(node->getSecondChild());\n+\n    int32_t maxOnsiteCacheSlots = comp->getOptions()->getMaxOnsiteCacheSlotForInstanceOf();\n-   TR::Register *dynamicCacheReg = NULL;\n-   int32_t addressSize = TR::Compiler->om.sizeofReferenceAddress();\n+   int32_t fieldSize = TR::Compiler->om.sizeofReferenceField();\n+   bool isTarget64Bit = comp->target().is64Bit();\n+   bool isCompressedRef = comp->useCompressedPointers();\n    /* Layout of the writable data snippet\n     * Case - 1 : Cast class is runtime variable\n-    * [UpdateIndex][ObjClassSlot-0][CastClassSlot-0]...[ObjClassSlot-N][CastClassSlot-N]\n-    * Case - 2 : Cast Class is interface / unresolved\n-    * [UpdateIndex][ObjClassSlot-0]...[ObjClassSlot-N]\n+    *    Case - 1A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        8                   12                ... 8n                  8n+4\n+    *    Case - 1B: 64 Bit Non Compressedrefs\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        16                  24                ... 16n                 16n+8\n+    * Case - 2 : Cast Class is resolved\n+    *    Case - 2A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         4                   8                   ... 4n\n+    *    Case - 2B: 64 Bit Non Compressedrefs\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         8                   16                   ... 8n\n+    *\n     * If there is only one cache slot, we will not have header.\n     * Last bit of cached objectClass will set to 1 indicating false cast\n+    *\n+    * We can request the snippet size of power 2. Following Table summarizes bytes needed for corresponding number of cache slots.\n+    * \n+    * Following is the table for the number of bytes in snippet needed by each of the Cases mentioned above\n+    *\n+    * Number Of Slots | Case 1A | Case 1B | Case 2A | Case 2B |\n+    *       1         |    8    |   16    |    4    |    8    |\n+    *       2         |    16   |   64    |    16   |    32   |\n+    *       3         |    32   |   64    |    16   |    32   |\n+    *       4         |    64   |   128   |    32   |    64   |\n+    *       5         |    64   |   128   |    32   |    64   |\n+    *       6         |    64   |   128   |    32   |    64   |\n+    *\n     */\n-   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * addressSize) + (addressSize * (maxOnsiteCacheSlots != 1));\n+   \n+   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * fieldSize) + (fieldSize * (maxOnsiteCacheSlots != 1) * (cacheCastClass ? 2 : 1));\n+   TR::Register *dynamicCacheReg = NULL;\n+   \n    if (generateDynamicCache)\n       {\n       TR::S390WritableDataSnippet *dynamicCacheSnippet = NULL;\n-      /* We can only request the snippet size of power 2, following table summarizes bytes needed for corresponding number of cache slots\n-       * Case 1 : Cast class is runtime variable\n-       * Case 2 : Cast class is interface / unresolved\n-       * Number Of Slots |  Bytes needed for Case 1 | Bytes needed for Case 2\n-       *        1        |              16          |           8\n-       *        2        |              64          |           32\n-       *        3        |              64          |           32\n-       *        4        |              128         |           64\n-       *        5        |              128         |           64\n-       *        6        |              128         |           64\n-       */\n       int32_t requestedBytes = 1 << (int) (log2(snippetSizeInBytes-1)+1);\n-      traceMsg(comp, \"Requested Bytes = %d\\n\",requestedBytes);\n-      // NOTE: For single slot cache, we initialize snippet with addressSize (4/8) assuming which can not be objectClass\n-      // In all cases, we use first addressSize bytes to store offset of the circular buffer and rest of buffer will be initialized with 0xf.\n+      traceMsg(comp, \"Number Of Dynamic Cache Slots = %d, Caching CastClass: %s\\n\"\n+                     \"Bytes needed for Snippet = %d, requested Bytes = %d\\n\",maxOnsiteCacheSlots, cacheCastClass ? \"true\" : \"false\", snippetSizeInBytes, requestedBytes);\n+\n       TR_ASSERT_FATAL(maxOnsiteCacheSlots <= 7, \"Maximum 7 slots per site allowed because we use a fixed stack allocated buffer to construct the snippet\\n\");\n-      UDATA initialSnippet[16] = { static_cast<UDATA>(addressSize) };\n+      j9objectclass_t initialSnippet[16] = { 0 };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4703eaf139c681caf30931dfc1308949d43e15"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5NzA4Mw==", "bodyText": "This code is starting to become a mess by allocating these data snippets inline. This is outside the scope of this PR but I'd like to see these data snippets be implemented using a standalone documented snippet class eventually. Food for thought.", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431297083", "createdAt": "2020-05-27T16:54:50Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6327,83 +6327,150 @@ static bool graDepsConflictWithInstanceOfDeps(TR::Node * depNode, TR::Node * nod\n  *     This function generates a sequence to check per site cache for object class and cast class before calling out to jitInstanceOf helper\n  */\n static\n-void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n+void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR::RegisterDependencyConditions *deps, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n    {\n    TR::Compilation                *comp = cg->comp();\n    bool needResult = resultReg != NULL;\n    if (!castClassReg)\n-      castClassReg = cg->evaluate(node->getSecondChild());\n+      castClassReg = cg->gprClobberEvaluate(node->getSecondChild());\n+\n    int32_t maxOnsiteCacheSlots = comp->getOptions()->getMaxOnsiteCacheSlotForInstanceOf();\n-   TR::Register *dynamicCacheReg = NULL;\n-   int32_t addressSize = TR::Compiler->om.sizeofReferenceAddress();\n+   int32_t fieldSize = TR::Compiler->om.sizeofReferenceField();\n+   bool isTarget64Bit = comp->target().is64Bit();\n+   bool isCompressedRef = comp->useCompressedPointers();\n    /* Layout of the writable data snippet\n     * Case - 1 : Cast class is runtime variable\n-    * [UpdateIndex][ObjClassSlot-0][CastClassSlot-0]...[ObjClassSlot-N][CastClassSlot-N]\n-    * Case - 2 : Cast Class is interface / unresolved\n-    * [UpdateIndex][ObjClassSlot-0]...[ObjClassSlot-N]\n+    *    Case - 1A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        8                   12                ... 8n                  8n+4\n+    *    Case - 1B: 64 Bit Non Compressedrefs\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        16                  24                ... 16n                 16n+8\n+    * Case - 2 : Cast Class is resolved\n+    *    Case - 2A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         4                   8                   ... 4n\n+    *    Case - 2B: 64 Bit Non Compressedrefs\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         8                   16                   ... 8n\n+    *\n     * If there is only one cache slot, we will not have header.\n     * Last bit of cached objectClass will set to 1 indicating false cast\n+    *\n+    * We can request the snippet size of power 2. Following Table summarizes bytes needed for corresponding number of cache slots.\n+    * \n+    * Following is the table for the number of bytes in snippet needed by each of the Cases mentioned above\n+    *\n+    * Number Of Slots | Case 1A | Case 1B | Case 2A | Case 2B |\n+    *       1         |    8    |   16    |    4    |    8    |\n+    *       2         |    16   |   64    |    16   |    32   |\n+    *       3         |    32   |   64    |    16   |    32   |\n+    *       4         |    64   |   128   |    32   |    64   |\n+    *       5         |    64   |   128   |    32   |    64   |\n+    *       6         |    64   |   128   |    32   |    64   |\n+    *\n     */\n-   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * addressSize) + (addressSize * (maxOnsiteCacheSlots != 1));\n+   \n+   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * fieldSize) + (fieldSize * (maxOnsiteCacheSlots != 1) * (cacheCastClass ? 2 : 1));\n+   TR::Register *dynamicCacheReg = NULL;\n+   \n    if (generateDynamicCache)\n       {\n       TR::S390WritableDataSnippet *dynamicCacheSnippet = NULL;\n-      /* We can only request the snippet size of power 2, following table summarizes bytes needed for corresponding number of cache slots\n-       * Case 1 : Cast class is runtime variable\n-       * Case 2 : Cast class is interface / unresolved\n-       * Number Of Slots |  Bytes needed for Case 1 | Bytes needed for Case 2\n-       *        1        |              16          |           8\n-       *        2        |              64          |           32\n-       *        3        |              64          |           32\n-       *        4        |              128         |           64\n-       *        5        |              128         |           64\n-       *        6        |              128         |           64\n-       */\n       int32_t requestedBytes = 1 << (int) (log2(snippetSizeInBytes-1)+1);\n-      traceMsg(comp, \"Requested Bytes = %d\\n\",requestedBytes);\n-      // NOTE: For single slot cache, we initialize snippet with addressSize (4/8) assuming which can not be objectClass\n-      // In all cases, we use first addressSize bytes to store offset of the circular buffer and rest of buffer will be initialized with 0xf.\n+      traceMsg(comp, \"Number Of Dynamic Cache Slots = %d, Caching CastClass: %s\\n\"\n+                     \"Bytes needed for Snippet = %d, requested Bytes = %d\\n\",maxOnsiteCacheSlots, cacheCastClass ? \"true\" : \"false\", snippetSizeInBytes, requestedBytes);\n+\n       TR_ASSERT_FATAL(maxOnsiteCacheSlots <= 7, \"Maximum 7 slots per site allowed because we use a fixed stack allocated buffer to construct the snippet\\n\");\n-      UDATA initialSnippet[16] = { static_cast<UDATA>(addressSize) };\n+      j9objectclass_t initialSnippet[16] = { 0 };\n+\n+      if (cacheCastClass)\n+         initialSnippet[isTarget64Bit && !isCompressedRef ? 0 : 1] = static_cast<j9objectclass_t>(fieldSize * 2);\n+      else\n+         initialSnippet[0] = static_cast<j9objectclass_t>(fieldSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a4703eaf139c681caf30931dfc1308949d43e15"}, "originalPosition": 95}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "836d4b19681641d3c250d756ce09c06719a3f5f7", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/836d4b19681641d3c250d756ce09c06719a3f5f7", "committedDate": "2020-05-27T16:57:46Z", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadward\ninstruction from snippet, snippet address should be aligned to\nquadward boundary. In JIT compilation this works as when emitting\nsnippet, we align the snippets according to its size. But in AOT\nload, there was a possibility that it mess up with the alignment for\nstart of snippet address. By setting the code cache memory alignment to\n16, we make sure, that in AOT load, the snippet from where it is loading or\nstoring, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "d93900d74563f5c215cc5b25dfcf7155c2df20a6", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/d93900d74563f5c215cc5b25dfcf7155c2df20a6", "committedDate": "2020-05-27T18:36:31Z", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadword instruction from\nsnippet, snippet address should be aligned to quadword boundary. In JIT\ncompilation this works as when emitting snippet, we align the snippets\naccording to its size. But in AOT load, there was a possibility that it\nmess up with the alignment for start of snippet address. By setting the\ncode cache memory alignment to 16, we make sure, that in AOT load, the\nsnippet from where it is loading or storing, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjEzMDAx", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#pullrequestreview-419613001", "createdAt": "2020-05-27T21:13:27Z", "commit": {"oid": "eacc941c50cd958900914c934e54ebeeac8a0e6a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMToxMzoyN1rOGbdW2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMToxMzoyN1rOGbdW2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0NTcyMw==", "bodyText": "This seems needlessly complicated. Why not just store the index at [0] always and use LLGF always to load and ST to store? Then all bytes from offset 4 until ObjectClassSlot-0 is just alignment bytes in all cases.", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#discussion_r431445723", "createdAt": "2020-05-27T21:13:27Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/z/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -6327,83 +6327,153 @@ static bool graDepsConflictWithInstanceOfDeps(TR::Node * depNode, TR::Node * nod\n  *     This function generates a sequence to check per site cache for object class and cast class before calling out to jitInstanceOf helper\n  */\n static\n-void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n+void genInstanceOfDynamicCacheAndHelperCall(TR::Node *node, TR::CodeGenerator *cg, TR::Register *castClassReg, TR::Register *objClassReg, TR::Register *resultReg, TR::RegisterDependencyConditions *deps, TR_S390ScratchRegisterManager *srm, TR::LabelSymbol *doneLabel, TR::LabelSymbol *helperCallLabel, TR::LabelSymbol *dynamicCacheTestLabel, TR::LabelSymbol *branchLabel, TR::LabelSymbol *trueLabel, TR::LabelSymbol *falseLabel, bool dynamicCastClass, bool generateDynamicCache, bool cacheCastClass, bool ifInstanceOf, bool trueFallThrough )\n    {\n    TR::Compilation                *comp = cg->comp();\n    bool needResult = resultReg != NULL;\n    if (!castClassReg)\n-      castClassReg = cg->evaluate(node->getSecondChild());\n+      castClassReg = cg->gprClobberEvaluate(node->getSecondChild());\n+\n    int32_t maxOnsiteCacheSlots = comp->getOptions()->getMaxOnsiteCacheSlotForInstanceOf();\n-   TR::Register *dynamicCacheReg = NULL;\n-   int32_t addressSize = TR::Compiler->om.sizeofReferenceAddress();\n+   int32_t sizeofJ9ClassFieldWithinReference = TR::Compiler->om.sizeofReferenceField();\n+   bool isTarget64Bit = comp->target().is64Bit();\n+   bool isCompressedRef = comp->useCompressedPointers();\n    /* Layout of the writable data snippet\n     * Case - 1 : Cast class is runtime variable\n-    * [UpdateIndex][ObjClassSlot-0][CastClassSlot-0]...[ObjClassSlot-N][CastClassSlot-N]\n-    * Case - 2 : Cast Class is interface / unresolved\n-    * [UpdateIndex][ObjClassSlot-0]...[ObjClassSlot-N]\n+    *    Case - 1A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        8                   12                ... 8n                  8n+4\n+    *    Case - 1B: 64 Bit Non Compressedrefs\n+    *       -----------------------------------------------------------------------------------------\n+    *       |Header | ObjectClassSlot-0 | CastClassSlot-0 |...| ObjectClassSlot-N | CastClassSlot-N |\n+    *       -----------------------------------------------------------------------------------------\n+    *       0        16                  24                ... 16n                 16n+8\n+    * Case - 2 : Cast Class is resolved\n+    *    Case - 2A: 64 Bit Compressedrefs / 31-Bit JVM\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         4                   8                   ... 4n\n+    *    Case - 2B: 64 Bit Non Compressedrefs\n+    *       --------------------------------------------------------------------------\n+    *       | Header | ObjectClassSlot-0 | ObjectClassSlot-1 |...| ObjectClassSlot-N |\n+    *       --------------------------------------------------------------------------\n+    *       0         8                   16                   ... 8n\n+    *\n     * If there is only one cache slot, we will not have header.\n     * Last bit of cached objectClass will set to 1 indicating false cast\n+    *\n+    * We can request the snippet size of power 2. Following Table summarizes bytes needed for corresponding number of cache slots.\n+    * \n+    * Following is the table for the number of bytes in snippet needed by each of the Cases mentioned above\n+    *\n+    * Number Of Slots | Case 1A | Case 1B | Case 2A | Case 2B |\n+    *       1         |    8    |   16    |    4    |    8    |\n+    *       2         |    16   |   64    |    16   |    32   |\n+    *       3         |    32   |   64    |    16   |    32   |\n+    *       4         |    64   |   128   |    32   |    64   |\n+    *       5         |    64   |   128   |    32   |    64   |\n+    *       6         |    64   |   128   |    32   |    64   |\n+    *\n     */\n-   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * addressSize) + (addressSize * (maxOnsiteCacheSlots != 1));\n+   \n+   int32_t snippetSizeInBytes = ((cacheCastClass ? 2 : 1) * maxOnsiteCacheSlots * sizeofJ9ClassFieldWithinReference) + (sizeofJ9ClassFieldWithinReference * (maxOnsiteCacheSlots != 1) * (cacheCastClass ? 2 : 1));\n+   TR::Register *dynamicCacheReg = NULL;\n+   \n    if (generateDynamicCache)\n       {\n       TR::S390WritableDataSnippet *dynamicCacheSnippet = NULL;\n-      /* We can only request the snippet size of power 2, following table summarizes bytes needed for corresponding number of cache slots\n-       * Case 1 : Cast class is runtime variable\n-       * Case 2 : Cast class is interface / unresolved\n-       * Number Of Slots |  Bytes needed for Case 1 | Bytes needed for Case 2\n-       *        1        |              16          |           8\n-       *        2        |              64          |           32\n-       *        3        |              64          |           32\n-       *        4        |              128         |           64\n-       *        5        |              128         |           64\n-       *        6        |              128         |           64\n-       */\n       int32_t requestedBytes = 1 << (int) (log2(snippetSizeInBytes-1)+1);\n-      traceMsg(comp, \"Requested Bytes = %d\\n\",requestedBytes);\n-      // NOTE: For single slot cache, we initialize snippet with addressSize (4/8) assuming which can not be objectClass\n-      // In all cases, we use first addressSize bytes to store offset of the circular buffer and rest of buffer will be initialized with 0xf.\n+      if (comp->getOption(TR_TraceCG))\n+         {\n+         traceMsg(comp, \"Number Of Dynamic Cache Slots = %d, Caching CastClass: %s\\n\"\n+                        \"Bytes needed for Snippet = %d, requested Bytes = %d\\n\",maxOnsiteCacheSlots, cacheCastClass ? \"true\" : \"false\", snippetSizeInBytes, requestedBytes);\n+         }\n+\n       TR_ASSERT_FATAL(maxOnsiteCacheSlots <= 7, \"Maximum 7 slots per site allowed because we use a fixed stack allocated buffer to construct the snippet\\n\");\n-      UDATA initialSnippet[16] = { static_cast<UDATA>(addressSize) };\n+      U_32 initialSnippet[32] = { 0 };\n+\n+      if (cacheCastClass)\n+         initialSnippet[1] = static_cast<U_32>(sizeofJ9ClassFieldWithinReference * 2);\n+      else\n+         initialSnippet[isTarget64Bit && !isCompressedRef ? 1 : 0] = static_cast<U_32>(sizeofJ9ClassFieldWithinReference);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eacc941c50cd958900914c934e54ebeeac8a0e6a"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cdc5948b514751443da1fc93d1dc78f686b3c81", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2cdc5948b514751443da1fc93d1dc78f686b3c81", "committedDate": "2020-05-28T04:17:19Z", "message": "Fix instanceOf's dynamicCache sequence on IBM Z\n\nOn IBM Z, for instanceOf node, we have a codegen optimization which\ncaches the encountered classes for which it failed all the inline tests\nand has to call JIT helper to get the result. This cache is first\ntested to avoid a call to JIT helper. There was a bug in case we have to\ncache class of child when cast class child of the node is runtime\nvariable. We were loading and storing associated fields using two load\nand store instructions. This causes a potential data race condition\nwhich was exploited by highly parallel application where more than 500\nthreads were running same method and all were trying to update the\ncache, leaving with the classes in the cache which were not related and\nin the code it can later cause an incorrect result for instanceof.\n\nFixes: #9457\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2430d97387cbde73cf795f75a6d84927a67ee15", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a2430d97387cbde73cf795f75a6d84927a67ee15", "committedDate": "2020-05-28T04:17:42Z", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadword instruction from\nsnippet, snippet address should be aligned to quadword boundary. In JIT\ncompilation this works as when emitting snippet, we align the snippets\naccording to its size. But in AOT load, there was a possibility that it\nmess up with the alignment for start of snippet address. By setting the\ncode cache memory alignment to 16, we make sure, that in AOT load, the\nsnippet from where it is loading or storing, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eacc941c50cd958900914c934e54ebeeac8a0e6a", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/eacc941c50cd958900914c934e54ebeeac8a0e6a", "committedDate": "2020-05-27T19:25:47Z", "message": "Use U_32 instead of j9objectclass_t in initialization of cache snippet\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}, "afterCommit": {"oid": "a2430d97387cbde73cf795f75a6d84927a67ee15", "author": {"user": {"login": "r30shah", "name": "Rahil Shah"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a2430d97387cbde73cf795f75a6d84927a67ee15", "committedDate": "2020-05-28T04:17:42Z", "message": "Set Code Cache alignment to 16 bits on IBM Z\n\nOn IBM Z platform, to support load and store quadword instruction from\nsnippet, snippet address should be aligned to quadword boundary. In JIT\ncompilation this works as when emitting snippet, we align the snippets\naccording to its size. But in AOT load, there was a possibility that it\nmess up with the alignment for start of snippet address. By setting the\ncode cache memory alignment to 16, we make sure, that in AOT load, the\nsnippet from where it is loading or storing, will be aligned.\n\nSigned-off-by: Rahil Shah <rahil@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjY0NjI4", "url": "https://github.com/eclipse-openj9/openj9/pull/9517#pullrequestreview-420264628", "createdAt": "2020-05-28T16:02:43Z", "commit": {"oid": "a2430d97387cbde73cf795f75a6d84927a67ee15"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 898, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}