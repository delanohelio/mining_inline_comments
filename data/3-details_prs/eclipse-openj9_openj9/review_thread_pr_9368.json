{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4ODA4MzUz", "number": 9368, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwMDo0NTozNFrOD2AiHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxODoyMzoyM1rOD2KQKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3OTU4NDI4OnYy", "diffSide": "RIGHT", "path": "runtime/codert_vm/decomp.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwMDo0NTozNFrOGLtwmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxODo0NjozMFrOGL46vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkzNzI0Mg==", "bodyText": "I think this works to zero the structs and makes it easier to reason about the code below.  Same deal for walkState\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tJ9JITDecompileState decompileState;\n          \n          \n            \n            \tJ9JITDecompileState decompileState = {0};", "url": "https://github.com/eclipse-openj9/openj9/pull/9368#discussion_r414937242", "createdAt": "2020-04-25T00:45:34Z", "author": {"login": "DanHeidinga"}, "path": "runtime/codert_vm/decomp.cpp", "diffHunk": "@@ -1200,12 +1200,45 @@ c_jitDecompileAtExceptionCatch(J9VMThread * currentThread)\n \tU_8 *jitPC = decompRecord->pc;\n \t/* Simulate a call to a resolve helper to make the stack walkable */\n \tbuildBranchJITResolveFrame(currentThread, jitPC, J9_STACK_FLAGS_JIT_EXCEPTION_CATCH_RESOLVE);\n-\t/* Discard the existing decompilation in favour of a new one at the exception catch point */\n+\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9JITDecompileState decompileState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95e0bd8988a67472bb2f58b69a13792cdfa1e3e0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExODQ3MQ==", "bodyText": "This (and the code below) are both from the revert of the previous attempt. Not sure it's worth changing anything.", "url": "https://github.com/eclipse-openj9/openj9/pull/9368#discussion_r415118471", "createdAt": "2020-04-25T18:37:43Z", "author": {"login": "gacholio"}, "path": "runtime/codert_vm/decomp.cpp", "diffHunk": "@@ -1200,12 +1200,45 @@ c_jitDecompileAtExceptionCatch(J9VMThread * currentThread)\n \tU_8 *jitPC = decompRecord->pc;\n \t/* Simulate a call to a resolve helper to make the stack walkable */\n \tbuildBranchJITResolveFrame(currentThread, jitPC, J9_STACK_FLAGS_JIT_EXCEPTION_CATCH_RESOLVE);\n-\t/* Discard the existing decompilation in favour of a new one at the exception catch point */\n+\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9JITDecompileState decompileState;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkzNzI0Mg=="}, "originalCommit": {"oid": "95e0bd8988a67472bb2f58b69a13792cdfa1e3e0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExODg0Nw==", "bodyText": "This certainly isn't a performance critical path, so if you really want the zeroing, I'll do it (I'm just never sure I trust the compiler to optimize this when most/all of the fields get stored anyway).", "url": "https://github.com/eclipse-openj9/openj9/pull/9368#discussion_r415118847", "createdAt": "2020-04-25T18:39:52Z", "author": {"login": "gacholio"}, "path": "runtime/codert_vm/decomp.cpp", "diffHunk": "@@ -1200,12 +1200,45 @@ c_jitDecompileAtExceptionCatch(J9VMThread * currentThread)\n \tU_8 *jitPC = decompRecord->pc;\n \t/* Simulate a call to a resolve helper to make the stack walkable */\n \tbuildBranchJITResolveFrame(currentThread, jitPC, J9_STACK_FLAGS_JIT_EXCEPTION_CATCH_RESOLVE);\n-\t/* Discard the existing decompilation in favour of a new one at the exception catch point */\n+\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9JITDecompileState decompileState;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkzNzI0Mg=="}, "originalCommit": {"oid": "95e0bd8988a67472bb2f58b69a13792cdfa1e3e0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEyMDA2MQ==", "bodyText": "Gac pointed out that this is just code being moved, not new code.", "url": "https://github.com/eclipse-openj9/openj9/pull/9368#discussion_r415120061", "createdAt": "2020-04-25T18:46:30Z", "author": {"login": "DanHeidinga"}, "path": "runtime/codert_vm/decomp.cpp", "diffHunk": "@@ -1200,12 +1200,45 @@ c_jitDecompileAtExceptionCatch(J9VMThread * currentThread)\n \tU_8 *jitPC = decompRecord->pc;\n \t/* Simulate a call to a resolve helper to make the stack walkable */\n \tbuildBranchJITResolveFrame(currentThread, jitPC, J9_STACK_FLAGS_JIT_EXCEPTION_CATCH_RESOLVE);\n-\t/* Discard the existing decompilation in favour of a new one at the exception catch point */\n+\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9JITDecompileState decompileState;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkzNzI0Mg=="}, "originalCommit": {"oid": "95e0bd8988a67472bb2f58b69a13792cdfa1e3e0"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MTE3Njc1OnYy", "diffSide": "RIGHT", "path": "runtime/codert_vm/decomp.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxODoyMzoyM1rOGL4q9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxODo1NzoxNVrOGL5Cog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNjAyMg==", "bodyText": "Are we guaranteed to have an inlineMap even if nothing was inlined here?  Should this assert be moved inside the if?", "url": "https://github.com/eclipse-openj9/openj9/pull/9368#discussion_r415116022", "createdAt": "2020-04-25T18:23:23Z", "author": {"login": "DanHeidinga"}, "path": "runtime/codert_vm/decomp.cpp", "diffHunk": "@@ -1200,12 +1200,45 @@ c_jitDecompileAtExceptionCatch(J9VMThread * currentThread)\n \tU_8 *jitPC = decompRecord->pc;\n \t/* Simulate a call to a resolve helper to make the stack walkable */\n \tbuildBranchJITResolveFrame(currentThread, jitPC, J9_STACK_FLAGS_JIT_EXCEPTION_CATCH_RESOLVE);\n-\t/* Discard the existing decompilation in favour of a new one at the exception catch point */\n+\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9JITDecompileState decompileState;\n+\tJ9StackWalkState walkState;\n \tJ9OSRBuffer *osrBuffer = &decompRecord->osrBuffer;\n \tUDATA numberOfFrames = osrBuffer->numberOfFrames;\n \tJ9OSRFrame *osrFrame = (J9OSRFrame*)(osrBuffer + 1);\n+\tJ9JITExceptionTable *metaData = NULL;\n+\n+\t/* Collect the required information from the stack - top visible frame is the decompile frame */\n+\twalkState.flags = J9_STACKWALK_ITERATE_FRAMES | J9_STACKWALK_SKIP_INLINES | J9_STACKWALK_VISIBLE_ONLY | J9_STACKWALK_MAINTAIN_REGISTER_MAP | J9_STACKWALK_ITERATE_HIDDEN_JIT_FRAMES | J9_STACKWALK_SAVE_STACKED_REGISTERS;\n+\twalkState.skipCount = 0;\n+\twalkState.frameWalkFunction = decompileMethodFrameIterator;\n+\twalkState.walkThread = currentThread;\n+\twalkState.userData1 = &decompileState;\n+\twalkState.userData2 = NULL;\n+\tvm->walkStackFrames(currentThread, &walkState);\n+\tmetaData = decompileState.metaData;\n+\n+\t/* Determine in which inlined frame the exception is being caught */\n+\tUDATA newNumberOfFrames = 1;\n+\tvoid *stackMap = NULL;\n+\tvoid *inlineMap = NULL;\n+\tvoid *inlinedCallSite = NULL;\n+\t/* Note we need to add 1 to the JIT PC here in order to get the correct map at the exception handler\n+\t * because jitGetMapsFromPC is expecting a return address, so it subtracts 1.  The value stored in the\n+\t * decomp record is the start address of the compiled exception handler.\n+\t */\n+\tjitGetMapsFromPC(vm, metaData, (UDATA)jitPC + 1, &stackMap, &inlineMap);\n+\tAssert_CodertVM_false(NULL == inlineMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1a9c0f33ba905187f66efaea70ab4f01079aa1"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExODM4OQ==", "bodyText": "This assert has never fired, in testing or production, so I'll say it's correct.", "url": "https://github.com/eclipse-openj9/openj9/pull/9368#discussion_r415118389", "createdAt": "2020-04-25T18:37:08Z", "author": {"login": "gacholio"}, "path": "runtime/codert_vm/decomp.cpp", "diffHunk": "@@ -1200,12 +1200,45 @@ c_jitDecompileAtExceptionCatch(J9VMThread * currentThread)\n \tU_8 *jitPC = decompRecord->pc;\n \t/* Simulate a call to a resolve helper to make the stack walkable */\n \tbuildBranchJITResolveFrame(currentThread, jitPC, J9_STACK_FLAGS_JIT_EXCEPTION_CATCH_RESOLVE);\n-\t/* Discard the existing decompilation in favour of a new one at the exception catch point */\n+\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9JITDecompileState decompileState;\n+\tJ9StackWalkState walkState;\n \tJ9OSRBuffer *osrBuffer = &decompRecord->osrBuffer;\n \tUDATA numberOfFrames = osrBuffer->numberOfFrames;\n \tJ9OSRFrame *osrFrame = (J9OSRFrame*)(osrBuffer + 1);\n+\tJ9JITExceptionTable *metaData = NULL;\n+\n+\t/* Collect the required information from the stack - top visible frame is the decompile frame */\n+\twalkState.flags = J9_STACKWALK_ITERATE_FRAMES | J9_STACKWALK_SKIP_INLINES | J9_STACKWALK_VISIBLE_ONLY | J9_STACKWALK_MAINTAIN_REGISTER_MAP | J9_STACKWALK_ITERATE_HIDDEN_JIT_FRAMES | J9_STACKWALK_SAVE_STACKED_REGISTERS;\n+\twalkState.skipCount = 0;\n+\twalkState.frameWalkFunction = decompileMethodFrameIterator;\n+\twalkState.walkThread = currentThread;\n+\twalkState.userData1 = &decompileState;\n+\twalkState.userData2 = NULL;\n+\tvm->walkStackFrames(currentThread, &walkState);\n+\tmetaData = decompileState.metaData;\n+\n+\t/* Determine in which inlined frame the exception is being caught */\n+\tUDATA newNumberOfFrames = 1;\n+\tvoid *stackMap = NULL;\n+\tvoid *inlineMap = NULL;\n+\tvoid *inlinedCallSite = NULL;\n+\t/* Note we need to add 1 to the JIT PC here in order to get the correct map at the exception handler\n+\t * because jitGetMapsFromPC is expecting a return address, so it subtracts 1.  The value stored in the\n+\t * decomp record is the start address of the compiled exception handler.\n+\t */\n+\tjitGetMapsFromPC(vm, metaData, (UDATA)jitPC + 1, &stackMap, &inlineMap);\n+\tAssert_CodertVM_false(NULL == inlineMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNjAyMg=="}, "originalCommit": {"oid": "5f1a9c0f33ba905187f66efaea70ab4f01079aa1"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEyMjA4Mg==", "bodyText": "And GAC pointed out above (and I missed):\n\nThe changes in c_jitDecompileAtExceptionCatch are entirely the revert of the previous attempt.", "url": "https://github.com/eclipse-openj9/openj9/pull/9368#discussion_r415122082", "createdAt": "2020-04-25T18:57:15Z", "author": {"login": "DanHeidinga"}, "path": "runtime/codert_vm/decomp.cpp", "diffHunk": "@@ -1200,12 +1200,45 @@ c_jitDecompileAtExceptionCatch(J9VMThread * currentThread)\n \tU_8 *jitPC = decompRecord->pc;\n \t/* Simulate a call to a resolve helper to make the stack walkable */\n \tbuildBranchJITResolveFrame(currentThread, jitPC, J9_STACK_FLAGS_JIT_EXCEPTION_CATCH_RESOLVE);\n-\t/* Discard the existing decompilation in favour of a new one at the exception catch point */\n+\n+\tJ9JavaVM *vm = currentThread->javaVM;\n+\tJ9JITDecompileState decompileState;\n+\tJ9StackWalkState walkState;\n \tJ9OSRBuffer *osrBuffer = &decompRecord->osrBuffer;\n \tUDATA numberOfFrames = osrBuffer->numberOfFrames;\n \tJ9OSRFrame *osrFrame = (J9OSRFrame*)(osrBuffer + 1);\n+\tJ9JITExceptionTable *metaData = NULL;\n+\n+\t/* Collect the required information from the stack - top visible frame is the decompile frame */\n+\twalkState.flags = J9_STACKWALK_ITERATE_FRAMES | J9_STACKWALK_SKIP_INLINES | J9_STACKWALK_VISIBLE_ONLY | J9_STACKWALK_MAINTAIN_REGISTER_MAP | J9_STACKWALK_ITERATE_HIDDEN_JIT_FRAMES | J9_STACKWALK_SAVE_STACKED_REGISTERS;\n+\twalkState.skipCount = 0;\n+\twalkState.frameWalkFunction = decompileMethodFrameIterator;\n+\twalkState.walkThread = currentThread;\n+\twalkState.userData1 = &decompileState;\n+\twalkState.userData2 = NULL;\n+\tvm->walkStackFrames(currentThread, &walkState);\n+\tmetaData = decompileState.metaData;\n+\n+\t/* Determine in which inlined frame the exception is being caught */\n+\tUDATA newNumberOfFrames = 1;\n+\tvoid *stackMap = NULL;\n+\tvoid *inlineMap = NULL;\n+\tvoid *inlinedCallSite = NULL;\n+\t/* Note we need to add 1 to the JIT PC here in order to get the correct map at the exception handler\n+\t * because jitGetMapsFromPC is expecting a return address, so it subtracts 1.  The value stored in the\n+\t * decomp record is the start address of the compiled exception handler.\n+\t */\n+\tjitGetMapsFromPC(vm, metaData, (UDATA)jitPC + 1, &stackMap, &inlineMap);\n+\tAssert_CodertVM_false(NULL == inlineMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNjAyMg=="}, "originalCommit": {"oid": "5f1a9c0f33ba905187f66efaea70ab4f01079aa1"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 263, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}