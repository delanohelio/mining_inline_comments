{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwODUxMDUy", "number": 9404, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMzoxMTowMVrOD4XOrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMzoxMTowMVrOD4XOrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDI3NDM4OnYy", "diffSide": "RIGHT", "path": "runtime/codert_vm/cnathelp.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMzoxMTowMlrOGPJTJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMzoxNToxOFrOGPJY8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzNDE4Mg==", "bodyText": "I see the code to check the decomp stack in jswalk[1] but shouldn't this be modifying the PC here and was having trouble finding the code that treated the returnAddress as the walkState->pc.  Found it now [2].\nDo we use this pattern elsewhere as well?  Or is this the first time we're taking advantage of the way jswalk works in this way?\n[1] https://github.com/eclipse/openj9/blob/957a07826573fa58672a2e5a6735f7051b91be63/runtime/codert_vm/jswalk.c#L1418-L1424\n[2] https://github.com/eclipse/openj9/blob/957a07826573fa58672a2e5a6735f7051b91be63/runtime/codert_vm/jswalk.c#L341", "url": "https://github.com/eclipse-openj9/openj9/pull/9404#discussion_r418534182", "createdAt": "2020-05-01T13:11:02Z", "author": {"login": "DanHeidinga"}, "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -59,6 +59,37 @@ samePCs(void *pc1, void *pc2)\n #define samePCs(pc1, pc2) (MASK_PC(pc1) == MASK_PC(pc2))\n #endif /* J9ZOS390 && !J9VM_ENV_DATA64 */\n \n+/**\n+ * Fix the java and decompilation stacks for cases where exceptions can be\n+ * thrown from insde a JIT synthetic exception handler. There must be a\n+ * resolve frame on the top of the java stack with a valid JIT PC.\n+ *\n+ * @param currentThread[in] the current J9VMThread\n+ */\n+static void\n+fixStackForSyntheticHandler(J9VMThread *currentThread)\n+{\n+\t/* If the top decompilation record is for the current compiled frame, re-link the resolve frame\n+\t * and decompilation record to keep the stack walkable.\n+\t */\n+\tJ9JITDecompilationInfo *decomp = currentThread->decompilationStack;\n+\tif (NULL != decomp) {\n+\t\tJ9SFJITResolveFrame *resolveFrame = (J9SFJITResolveFrame*)currentThread->sp;\n+\t\tvoid *jitPC = resolveFrame->returnAddress;\n+\t\tJ9JITExceptionTable *metaData = jitGetExceptionTableFromPC(currentThread, (UDATA)jitPC);\n+\t\tAssert_CodertVM_false(NULL == metaData);\n+\t\tUDATA *oldSP = (UDATA*)(resolveFrame + 1);\n+\t\tUDATA *bp = oldSP + getJitTotalFrameSize(metaData);\n+\t\tif (bp == decomp->bp) {\n+\t\t\t/* Use a value which is guaranteed to fail metadata lookup. This makes\n+\t\t\t * the stack walker get the PC from the decompilation stack.\n+\t\t\t */\n+\t\t\tresolveFrame->returnAddress = NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb96baacd366bf23a56a25137e781c519be77712"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzNTY2Nw==", "bodyText": "The code for reporting exception catch does a similarly nasty fixup:\nhttps://github.com/eclipse/openj9/blob/957a07826573fa58672a2e5a6735f7051b91be63/runtime/codert_vm/decomp.cpp#L2459-L2466", "url": "https://github.com/eclipse-openj9/openj9/pull/9404#discussion_r418535667", "createdAt": "2020-05-01T13:15:18Z", "author": {"login": "gacholio"}, "path": "runtime/codert_vm/cnathelp.cpp", "diffHunk": "@@ -59,6 +59,37 @@ samePCs(void *pc1, void *pc2)\n #define samePCs(pc1, pc2) (MASK_PC(pc1) == MASK_PC(pc2))\n #endif /* J9ZOS390 && !J9VM_ENV_DATA64 */\n \n+/**\n+ * Fix the java and decompilation stacks for cases where exceptions can be\n+ * thrown from insde a JIT synthetic exception handler. There must be a\n+ * resolve frame on the top of the java stack with a valid JIT PC.\n+ *\n+ * @param currentThread[in] the current J9VMThread\n+ */\n+static void\n+fixStackForSyntheticHandler(J9VMThread *currentThread)\n+{\n+\t/* If the top decompilation record is for the current compiled frame, re-link the resolve frame\n+\t * and decompilation record to keep the stack walkable.\n+\t */\n+\tJ9JITDecompilationInfo *decomp = currentThread->decompilationStack;\n+\tif (NULL != decomp) {\n+\t\tJ9SFJITResolveFrame *resolveFrame = (J9SFJITResolveFrame*)currentThread->sp;\n+\t\tvoid *jitPC = resolveFrame->returnAddress;\n+\t\tJ9JITExceptionTable *metaData = jitGetExceptionTableFromPC(currentThread, (UDATA)jitPC);\n+\t\tAssert_CodertVM_false(NULL == metaData);\n+\t\tUDATA *oldSP = (UDATA*)(resolveFrame + 1);\n+\t\tUDATA *bp = oldSP + getJitTotalFrameSize(metaData);\n+\t\tif (bp == decomp->bp) {\n+\t\t\t/* Use a value which is guaranteed to fail metadata lookup. This makes\n+\t\t\t * the stack walker get the PC from the decompilation stack.\n+\t\t\t */\n+\t\t\tresolveFrame->returnAddress = NULL;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzNDE4Mg=="}, "originalCommit": {"oid": "eb96baacd366bf23a56a25137e781c519be77712"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 288, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}