{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMjE1MjQ3", "number": 10054, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDo0NTozNlrOEOSqww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDo1Njo1MVrOEOTA8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDIxMzc5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDo0NTozNlrOGxXE0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMDozOTo0OVrOGxkdyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQxMTQ3NQ==", "bodyText": "Considering that it looks like the post-P10 and pre-P10 versions of the inlined arraycopy code aren't actually sharing much code at all, perhaps they should be split into two separate functions?", "url": "https://github.com/eclipse-openj9/openj9/pull/10054#discussion_r454411475", "createdAt": "2020-07-14T14:45:36Z", "author": {"login": "aviansie-ben"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -11685,573 +11685,241 @@ static void inlineArrayCopy_ICF(TR::Node *node, int64_t byteLen, TR::Register *s\n    if (byteLen == 0)\n       return;\n \n-   TR::Compilation *comp = cg->comp();\n-   TR::Register *regs[4] = {tmp1Reg, tmp2Reg, tmp3Reg, tmp4Reg};\n-   TR::Register *fpRegs[4] = {fp1Reg, fp2Reg, fp3Reg, fp4Reg};\n-   int32_t groups, residual;\n-\n-   static bool disableLEArrayCopyInline = (feGetEnv(\"TR_disableLEArrayCopyInline\") != NULL);\n-   bool supportsLEArrayCopyInline = (comp->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8)) && !disableLEArrayCopyInline && comp->target().cpu.isLittleEndian() && comp->target().cpu.hasFPU() && comp->target().is64Bit();\n+   bool postP10CopyInline = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P10) &&\n+                            cg->comp()->target().cpu.getPPCSupportsVSX();\n \n-   if (comp->target().is64Bit())\n+   if (postP10CopyInline)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2866a5714506bad176a6e161d92c3c9ed43eb326"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYzMDg1OQ==", "bodyText": "before it gets too complicated, i prefer to consolidating the different evaluators in one place.", "url": "https://github.com/eclipse-openj9/openj9/pull/10054#discussion_r454630859", "createdAt": "2020-07-14T20:39:49Z", "author": {"login": "zl-wang"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -11685,573 +11685,241 @@ static void inlineArrayCopy_ICF(TR::Node *node, int64_t byteLen, TR::Register *s\n    if (byteLen == 0)\n       return;\n \n-   TR::Compilation *comp = cg->comp();\n-   TR::Register *regs[4] = {tmp1Reg, tmp2Reg, tmp3Reg, tmp4Reg};\n-   TR::Register *fpRegs[4] = {fp1Reg, fp2Reg, fp3Reg, fp4Reg};\n-   int32_t groups, residual;\n-\n-   static bool disableLEArrayCopyInline = (feGetEnv(\"TR_disableLEArrayCopyInline\") != NULL);\n-   bool supportsLEArrayCopyInline = (comp->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8)) && !disableLEArrayCopyInline && comp->target().cpu.isLittleEndian() && comp->target().cpu.hasFPU() && comp->target().is64Bit();\n+   bool postP10CopyInline = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P10) &&\n+                            cg->comp()->target().cpu.getPPCSupportsVSX();\n \n-   if (comp->target().is64Bit())\n+   if (postP10CopyInline)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQxMTQ3NQ=="}, "originalCommit": {"oid": "2866a5714506bad176a6e161d92c3c9ed43eb326"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDI1OTU1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDo1NDo0NlrOGxXgjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMDo0MDoxNFrOGxkezQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQxODU3Mw==", "bodyText": "Minor typo:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               //    POWER8 potentially micor-coded unaligned integer accesses in LE mode,\n          \n          \n            \n               //    POWER8 potentially micro-coded unaligned integer accesses in LE mode,", "url": "https://github.com/eclipse-openj9/openj9/pull/10054#discussion_r454418573", "createdAt": "2020-07-14T14:54:46Z", "author": {"login": "aviansie-ben"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -13458,12 +13148,18 @@ TR::Register *J9::Power::TreeEvaluator::arraycopyEvaluator(TR::Node *node, TR::C\n    TR::Register *metaReg = cg->getMethodMetaDataRegister();\n \n    // This section calculates the number of dependencies needed by the assembly helpers path.\n+   bool postP10Copy = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P10) &&\n+                      cg->comp()->target().cpu.getPPCSupportsVSX();\n+\n    static bool disableVSXArrayCopy = (feGetEnv(\"TR_disableVSXArrayCopy\") != NULL);\n-   static bool disableLEArrayCopyHelper = (feGetEnv(\"TR_disableLEArrayCopyHelper\") != NULL);\n-   static bool disableVSXArrayCopyInlining = (feGetEnv(\"TR_enableVSXArrayCopyInlining\") == NULL); // Disabling due to a performance regression\n+   bool useVSXForCopy  = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8) &&\n+                         !disableVSXArrayCopy && cg->comp()->target().cpu.getPPCSupportsVSX();\n \n-   bool supportsVSX = (comp->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8)) && !disableVSXArrayCopy && comp->target().cpu.supportsFeature(OMR_FEATURE_PPC_HAS_VSX);\n-   bool supportsLEArrayCopy = !disableLEArrayCopyHelper && comp->target().cpu.isLittleEndian() && comp->target().cpu.hasFPU();\n+   // VSX supercedes FPU.  No reason to offering disable option on this.\n+   //    POWER8 potentially micor-coded unaligned integer accesses in LE mode,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2866a5714506bad176a6e161d92c3c9ed43eb326"}, "originalPosition": 878}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYzMTExNw==", "bodyText": "will fix that typo.", "url": "https://github.com/eclipse-openj9/openj9/pull/10054#discussion_r454631117", "createdAt": "2020-07-14T20:40:14Z", "author": {"login": "zl-wang"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -13458,12 +13148,18 @@ TR::Register *J9::Power::TreeEvaluator::arraycopyEvaluator(TR::Node *node, TR::C\n    TR::Register *metaReg = cg->getMethodMetaDataRegister();\n \n    // This section calculates the number of dependencies needed by the assembly helpers path.\n+   bool postP10Copy = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P10) &&\n+                      cg->comp()->target().cpu.getPPCSupportsVSX();\n+\n    static bool disableVSXArrayCopy = (feGetEnv(\"TR_disableVSXArrayCopy\") != NULL);\n-   static bool disableLEArrayCopyHelper = (feGetEnv(\"TR_disableLEArrayCopyHelper\") != NULL);\n-   static bool disableVSXArrayCopyInlining = (feGetEnv(\"TR_enableVSXArrayCopyInlining\") == NULL); // Disabling due to a performance regression\n+   bool useVSXForCopy  = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8) &&\n+                         !disableVSXArrayCopy && cg->comp()->target().cpu.getPPCSupportsVSX();\n \n-   bool supportsVSX = (comp->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8)) && !disableVSXArrayCopy && comp->target().cpu.supportsFeature(OMR_FEATURE_PPC_HAS_VSX);\n-   bool supportsLEArrayCopy = !disableLEArrayCopyHelper && comp->target().cpu.isLittleEndian() && comp->target().cpu.hasFPU();\n+   // VSX supercedes FPU.  No reason to offering disable option on this.\n+   //    POWER8 potentially micor-coded unaligned integer accesses in LE mode,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQxODU3Mw=="}, "originalCommit": {"oid": "2866a5714506bad176a6e161d92c3c9ed43eb326"}, "originalPosition": 878}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDI3MDU5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDo1Njo1MVrOGxXnBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMDo0MzoyOVrOGxklhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQyMDIyOQ==", "bodyText": "If I'm reading this correctly, this comment seems to be referring to the removal of the env var checks above? Can you please clarify what this is saying?", "url": "https://github.com/eclipse-openj9/openj9/pull/10054#discussion_r454420229", "createdAt": "2020-07-14T14:56:51Z", "author": {"login": "aviansie-ben"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -13458,12 +13148,18 @@ TR::Register *J9::Power::TreeEvaluator::arraycopyEvaluator(TR::Node *node, TR::C\n    TR::Register *metaReg = cg->getMethodMetaDataRegister();\n \n    // This section calculates the number of dependencies needed by the assembly helpers path.\n+   bool postP10Copy = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P10) &&\n+                      cg->comp()->target().cpu.getPPCSupportsVSX();\n+\n    static bool disableVSXArrayCopy = (feGetEnv(\"TR_disableVSXArrayCopy\") != NULL);\n-   static bool disableLEArrayCopyHelper = (feGetEnv(\"TR_disableLEArrayCopyHelper\") != NULL);\n-   static bool disableVSXArrayCopyInlining = (feGetEnv(\"TR_enableVSXArrayCopyInlining\") == NULL); // Disabling due to a performance regression\n+   bool useVSXForCopy  = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8) &&\n+                         !disableVSXArrayCopy && cg->comp()->target().cpu.getPPCSupportsVSX();\n \n-   bool supportsVSX = (comp->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8)) && !disableVSXArrayCopy && comp->target().cpu.supportsFeature(OMR_FEATURE_PPC_HAS_VSX);\n-   bool supportsLEArrayCopy = !disableLEArrayCopyHelper && comp->target().cpu.isLittleEndian() && comp->target().cpu.hasFPU();\n+   // VSX supercedes FPU.  No reason to offering disable option on this.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2866a5714506bad176a6e161d92c3c9ed43eb326"}, "originalPosition": 877}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYzMjgzNg==", "bodyText": "Potentially micro-coded is always present on P8 LE mode. i.e.  arraycopy might lose datum atomicity if you don't use floating point load/store to do the copy, such that it doesn't make sense to offer an option for that choice.", "url": "https://github.com/eclipse-openj9/openj9/pull/10054#discussion_r454632836", "createdAt": "2020-07-14T20:43:29Z", "author": {"login": "zl-wang"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -13458,12 +13148,18 @@ TR::Register *J9::Power::TreeEvaluator::arraycopyEvaluator(TR::Node *node, TR::C\n    TR::Register *metaReg = cg->getMethodMetaDataRegister();\n \n    // This section calculates the number of dependencies needed by the assembly helpers path.\n+   bool postP10Copy = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P10) &&\n+                      cg->comp()->target().cpu.getPPCSupportsVSX();\n+\n    static bool disableVSXArrayCopy = (feGetEnv(\"TR_disableVSXArrayCopy\") != NULL);\n-   static bool disableLEArrayCopyHelper = (feGetEnv(\"TR_disableLEArrayCopyHelper\") != NULL);\n-   static bool disableVSXArrayCopyInlining = (feGetEnv(\"TR_enableVSXArrayCopyInlining\") == NULL); // Disabling due to a performance regression\n+   bool useVSXForCopy  = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8) &&\n+                         !disableVSXArrayCopy && cg->comp()->target().cpu.getPPCSupportsVSX();\n \n-   bool supportsVSX = (comp->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8)) && !disableVSXArrayCopy && comp->target().cpu.supportsFeature(OMR_FEATURE_PPC_HAS_VSX);\n-   bool supportsLEArrayCopy = !disableLEArrayCopyHelper && comp->target().cpu.isLittleEndian() && comp->target().cpu.hasFPU();\n+   // VSX supercedes FPU.  No reason to offering disable option on this.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQyMDIyOQ=="}, "originalCommit": {"oid": "2866a5714506bad176a6e161d92c3c9ed43eb326"}, "originalPosition": 877}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4886, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}