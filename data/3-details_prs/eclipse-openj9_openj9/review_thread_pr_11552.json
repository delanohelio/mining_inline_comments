{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ3MDkxODA1", "number": 11552, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQyMjoyMjowM1rOFQKuDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjozNzowMVrOFRHD9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNDk3MTY1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/RelocationRecord.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQyMjoyMjowM1rOIV4kOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNTozNToxM1rOIXEV0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgxNzc4Nw==", "bodyText": "This looks weird. Why do you need to explicitly call the base class for a virtual method?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559817787", "createdAt": "2021-01-18T22:22:03Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -2907,6 +2916,32 @@ TR_RelocationRecordInlinedStaticMethodWithNopGuard::updateSucceededStats(TR_AOTS\n    aotStats->staticMethods.numSucceededValidations++;\n    }\n \n+\n+// TR_RelocationRecordInlinedStaticMethod\n+char *\n+TR_RelocationRecordInlinedStaticMethod::name()\n+   {\n+   return \"TR_InlinedStaticMethod\";\n+   }\n+\n+void\n+TR_RelocationRecordInlinedStaticMethod::print(TR_RelocationRuntime *reloRuntime)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d39cf64d5bf1e9b2ed600f47283f6019541ce19"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA1OTI4MA==", "bodyText": "To keep it consistent with the way existing relo record did this heh (see TR_RelocationRecordInlinedVirtualMethod::print).  I can go clean it all up.", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561059280", "createdAt": "2021-01-20T15:35:13Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -2907,6 +2916,32 @@ TR_RelocationRecordInlinedStaticMethodWithNopGuard::updateSucceededStats(TR_AOTS\n    aotStats->staticMethods.numSucceededValidations++;\n    }\n \n+\n+// TR_RelocationRecordInlinedStaticMethod\n+char *\n+TR_RelocationRecordInlinedStaticMethod::name()\n+   {\n+   return \"TR_InlinedStaticMethod\";\n+   }\n+\n+void\n+TR_RelocationRecordInlinedStaticMethod::print(TR_RelocationRuntime *reloRuntime)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgxNzc4Nw=="}, "originalCommit": {"oid": "2d39cf64d5bf1e9b2ed600f47283f6019541ce19"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNDk3OTcyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/RelocationRecord.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQyMjoyNjoxNFrOIV4orA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQyMjoyNjoxNFrOIV4orA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgxODkyNA==", "bodyText": "same here...", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559818924", "createdAt": "2021-01-18T22:26:14Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -2907,6 +2916,32 @@ TR_RelocationRecordInlinedStaticMethodWithNopGuard::updateSucceededStats(TR_AOTS\n    aotStats->staticMethods.numSucceededValidations++;\n    }\n \n+\n+// TR_RelocationRecordInlinedStaticMethod\n+char *\n+TR_RelocationRecordInlinedStaticMethod::name()\n+   {\n+   return \"TR_InlinedStaticMethod\";\n+   }\n+\n+void\n+TR_RelocationRecordInlinedStaticMethod::print(TR_RelocationRuntime *reloRuntime)\n+   {\n+   Base::print(reloRuntime);\n+   }\n+\n+void\n+TR_RelocationRecordInlinedStaticMethod::preparePrivateData(TR_RelocationRuntime *reloRuntime, TR_RelocationTarget *reloTarget)\n+   {\n+   Base::preparePrivateData(reloRuntime, reloTarget);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d39cf64d5bf1e9b2ed600f47283f6019541ce19"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNDk4OTg0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/compile/J9Compilation.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQyMjozMToyOVrOIV4uYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNTozNjo0OFrOIXEaxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMDM4Nw==", "bodyText": "Shouldn't the default reloKind be that returned by OMR's version of this function (i.e. not inlining the current implementation of it) ?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559820387", "createdAt": "2021-01-18T22:31:29Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/compile/J9Compilation.cpp", "diffHunk": "@@ -1135,6 +1136,61 @@ J9::Compilation::isGeneratedReflectionMethod(TR_ResolvedMethod * method)\n    return false;\n    }\n \n+TR_ExternalRelocationTargetKind\n+J9::Compilation::getReloTypeForMethodToBeInlined(TR_VirtualGuardSelection *guard, TR::Node *callNode, TR_OpaqueClassBlock *receiverClass)\n+   {\n+   TR_ExternalRelocationTargetKind reloKind = TR_NoRelocation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce295be52b10fa8dad12eecea41b556947d2edb"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2MDU1MA==", "bodyText": "Yeah I can make a call to the OMR one.", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561060550", "createdAt": "2021-01-20T15:36:48Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/compile/J9Compilation.cpp", "diffHunk": "@@ -1135,6 +1136,61 @@ J9::Compilation::isGeneratedReflectionMethod(TR_ResolvedMethod * method)\n    return false;\n    }\n \n+TR_ExternalRelocationTargetKind\n+J9::Compilation::getReloTypeForMethodToBeInlined(TR_VirtualGuardSelection *guard, TR::Node *callNode, TR_OpaqueClassBlock *receiverClass)\n+   {\n+   TR_ExternalRelocationTargetKind reloKind = TR_NoRelocation;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMDM4Nw=="}, "originalCommit": {"oid": "8ce295be52b10fa8dad12eecea41b556947d2edb"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNDk5NjE5OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQyMjozNToxNVrOIV4x-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjoyMzozOVrOIXV4CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg==", "bodyText": "Please augment the comment to summarize the refactoring and reason why it's being refactored?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559821306", "createdAt": "2021-01-18T22:35:15Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91508c2995a9eb775220cafdee46b72c0e8e8d72"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMzc3Ng==", "bodyText": "Is there a reason you wanted all these functions to be static and not functions of J9::CodeGenerator?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559823776", "createdAt": "2021-01-18T22:44:10Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg=="}, "originalCommit": {"oid": "91508c2995a9eb775220cafdee46b72c0e8e8d72"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNDE1MA==", "bodyText": "Should this version only be in use if the SVM is not being used?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559824150", "createdAt": "2021-01-18T22:45:33Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg=="}, "originalCommit": {"oid": "91508c2995a9eb775220cafdee46b72c0e8e8d72"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2MjAzOQ==", "bodyText": "Is there a reason you wanted all these functions to be static and not functions of J9::CodeGenerator?\n\nConceptually they don't have anything to do with the CodeGenerator, they're just helpers for processRelocations.", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561062039", "createdAt": "2021-01-20T15:38:35Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg=="}, "originalCommit": {"oid": "91508c2995a9eb775220cafdee46b72c0e8e8d72"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2MjcwNw==", "bodyText": "Should this version only be in use if the SVM is not being used?\n\nIf the SVM is being used, then addValidationRecords will just be a NOP as the list will be empty.", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561062707", "createdAt": "2021-01-20T15:39:25Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg=="}, "originalCommit": {"oid": "91508c2995a9eb775220cafdee46b72c0e8e8d72"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0NjU2OA==", "bodyText": "helpers that read and then update state in the code generator object. But ok, I don't feel that strongly about it.", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561346568", "createdAt": "2021-01-20T22:23:39Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyMTMwNg=="}, "originalCommit": {"oid": "91508c2995a9eb775220cafdee46b72c0e8e8d72"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTAyNTQxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQyMjo0OToyN1rOIV5Bow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNTo0MjozN1rOIXEtGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNTMxNQ==", "bodyText": "Just to confirm: you're mapping all relocations to the earliest and outermost inlined site index with the same method?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559825315", "createdAt": "2021-01-18T22:49:27Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n \n-   //Project neutral non-AOT processRelocation\n-   OMR::CodeGeneratorConnector::processRelocations();\n+   TR::list<TR::AOTClassInfo*>* classInfo = cg->comp()->_aotClassInfo;\n+   if (!classInfo->empty())\n+      {\n+      for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         {\n+         traceMsg(cg->comp(), \"processing AOT class info: %p in %s\\n\", *info, cg->comp()->signature());\n+         traceMsg(cg->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n+         traceMsg(cg->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n \n-   int32_t missedSite = -1;\n+         TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n \n-   if (self()->comp()->compileRelocatableCode())\n-      {\n-      uint32_t inlinedCallSize = self()->comp()->getNumInlinedCallSites();\n+         int32_t siteIndex = -1;\n \n-      // Create temporary hashtable for ordering AOT guard relocations\n-      int32_t counter = inlinedCallSize;\n-      TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable;\n-      if (inlinedCallSize > 0)\n-         {\n-         orderedInlinedSiteListTable= (TR_InlinedSiteHastTableEntry*)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteHastTableEntry) * inlinedCallSize, heapAlloc);\n-         memset(orderedInlinedSiteListTable, 0, sizeof(TR_InlinedSiteHastTableEntry)*inlinedCallSize);\n+         if (ramMethod != cg->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            {\n+            int32_t i;\n+            for (i = 0; i < cg->comp()->getNumInlinedCallSites(); i++)\n+               {\n+               TR_InlinedCallSite &ics = cg->comp()->getInlinedCallSite(i);\n+               TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n+\n+               traceMsg(cg->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n+               if (ramMethod == inlinedMethod)\n+                  {\n+                  traceMsg(cg->comp(), \"\\t\\tmatch!\\n\");\n+                  siteIndex = i;\n+                  break;\n+                  }\n+               }\n+\n+            if (i >= (int32_t) cg->comp()->getNumInlinedCallSites())\n+               {\n+               // this assumption isn't associated with a method directly in the compilation\n+               // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n+               // kind of overkill for TR_ValidateStaticField, but still correct\n+               (*info)->_reloKind = TR_ValidateArbitraryClass;\n+               siteIndex = -1;   // invalidate main compiled method\n+               traceMsg(cg->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n+               }\n+            }\n+\n+         traceMsg(cg->comp(), \"Found inlined site %d\\n\", siteIndex);\n+\n+         TR_ASSERT(siteIndex < (int32_t) cg->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(intptr_t)siteIndex,\n+                                                                          (uint8_t *)(*info),\n+                                                                          (*info)->_reloKind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n          }\n-      else\n-         orderedInlinedSiteListTable = NULL;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91508c2995a9eb775220cafdee46b72c0e8e8d72"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2NTI0Mw==", "bodyText": "I haven't changed any of the logic that happens in here; I just moved it to its own function so that it's just easier to read the code. However, I believe something like that happens when writing the header in J9AheadOfTimeCompile.cpp; I think it's called findCorrectInlinedSiteIndex.", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561065243", "createdAt": "2021-01-20T15:42:37Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n \n-   //Project neutral non-AOT processRelocation\n-   OMR::CodeGeneratorConnector::processRelocations();\n+   TR::list<TR::AOTClassInfo*>* classInfo = cg->comp()->_aotClassInfo;\n+   if (!classInfo->empty())\n+      {\n+      for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         {\n+         traceMsg(cg->comp(), \"processing AOT class info: %p in %s\\n\", *info, cg->comp()->signature());\n+         traceMsg(cg->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n+         traceMsg(cg->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n \n-   int32_t missedSite = -1;\n+         TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n \n-   if (self()->comp()->compileRelocatableCode())\n-      {\n-      uint32_t inlinedCallSize = self()->comp()->getNumInlinedCallSites();\n+         int32_t siteIndex = -1;\n \n-      // Create temporary hashtable for ordering AOT guard relocations\n-      int32_t counter = inlinedCallSize;\n-      TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable;\n-      if (inlinedCallSize > 0)\n-         {\n-         orderedInlinedSiteListTable= (TR_InlinedSiteHastTableEntry*)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteHastTableEntry) * inlinedCallSize, heapAlloc);\n-         memset(orderedInlinedSiteListTable, 0, sizeof(TR_InlinedSiteHastTableEntry)*inlinedCallSize);\n+         if (ramMethod != cg->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            {\n+            int32_t i;\n+            for (i = 0; i < cg->comp()->getNumInlinedCallSites(); i++)\n+               {\n+               TR_InlinedCallSite &ics = cg->comp()->getInlinedCallSite(i);\n+               TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n+\n+               traceMsg(cg->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n+               if (ramMethod == inlinedMethod)\n+                  {\n+                  traceMsg(cg->comp(), \"\\t\\tmatch!\\n\");\n+                  siteIndex = i;\n+                  break;\n+                  }\n+               }\n+\n+            if (i >= (int32_t) cg->comp()->getNumInlinedCallSites())\n+               {\n+               // this assumption isn't associated with a method directly in the compilation\n+               // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n+               // kind of overkill for TR_ValidateStaticField, but still correct\n+               (*info)->_reloKind = TR_ValidateArbitraryClass;\n+               siteIndex = -1;   // invalidate main compiled method\n+               traceMsg(cg->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n+               }\n+            }\n+\n+         traceMsg(cg->comp(), \"Found inlined site %d\\n\", siteIndex);\n+\n+         TR_ASSERT(siteIndex < (int32_t) cg->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(intptr_t)siteIndex,\n+                                                                          (uint8_t *)(*info),\n+                                                                          (*info)->_reloKind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n          }\n-      else\n-         orderedInlinedSiteListTable = NULL;\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNTMxNQ=="}, "originalCommit": {"oid": "91508c2995a9eb775220cafdee46b72c0e8e8d72"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTA0MjM3OnYy", "diffSide": "LEFT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQyMjo1ODoxNlrOIV5LAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNTo0Mjo1MFrOIXEtpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNzcxMw==", "bodyText": "why remove the comment which explains a relatively subtle ordering point?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559827713", "createdAt": "2021-01-18T22:58:16Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n \n-   //Project neutral non-AOT processRelocation\n-   OMR::CodeGeneratorConnector::processRelocations();\n+   TR::list<TR::AOTClassInfo*>* classInfo = cg->comp()->_aotClassInfo;\n+   if (!classInfo->empty())\n+      {\n+      for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         {\n+         traceMsg(cg->comp(), \"processing AOT class info: %p in %s\\n\", *info, cg->comp()->signature());\n+         traceMsg(cg->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n+         traceMsg(cg->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n \n-   int32_t missedSite = -1;\n+         TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n \n-   if (self()->comp()->compileRelocatableCode())\n-      {\n-      uint32_t inlinedCallSize = self()->comp()->getNumInlinedCallSites();\n+         int32_t siteIndex = -1;\n \n-      // Create temporary hashtable for ordering AOT guard relocations\n-      int32_t counter = inlinedCallSize;\n-      TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable;\n-      if (inlinedCallSize > 0)\n-         {\n-         orderedInlinedSiteListTable= (TR_InlinedSiteHastTableEntry*)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteHastTableEntry) * inlinedCallSize, heapAlloc);\n-         memset(orderedInlinedSiteListTable, 0, sizeof(TR_InlinedSiteHastTableEntry)*inlinedCallSize);\n+         if (ramMethod != cg->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            {\n+            int32_t i;\n+            for (i = 0; i < cg->comp()->getNumInlinedCallSites(); i++)\n+               {\n+               TR_InlinedCallSite &ics = cg->comp()->getInlinedCallSite(i);\n+               TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n+\n+               traceMsg(cg->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n+               if (ramMethod == inlinedMethod)\n+                  {\n+                  traceMsg(cg->comp(), \"\\t\\tmatch!\\n\");\n+                  siteIndex = i;\n+                  break;\n+                  }\n+               }\n+\n+            if (i >= (int32_t) cg->comp()->getNumInlinedCallSites())\n+               {\n+               // this assumption isn't associated with a method directly in the compilation\n+               // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n+               // kind of overkill for TR_ValidateStaticField, but still correct\n+               (*info)->_reloKind = TR_ValidateArbitraryClass;\n+               siteIndex = -1;   // invalidate main compiled method\n+               traceMsg(cg->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n+               }\n+            }\n+\n+         traceMsg(cg->comp(), \"Found inlined site %d\\n\", siteIndex);\n+\n+         TR_ASSERT(siteIndex < (int32_t) cg->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(intptr_t)siteIndex,\n+                                                                          (uint8_t *)(*info),\n+                                                                          (*info)->_reloKind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n          }\n-      else\n-         orderedInlinedSiteListTable = NULL;\n+      }\n+   }\n \n-      TR_InlinedSiteLinkedListEntry *entry = NULL;\n+static void addSVMValidationRecords(TR::CodeGenerator *cg)\n+   {\n+   TR::SymbolValidationManager::SymbolValidationRecordList &validationRecords = cg->comp()->getSymbolValidationManager()->getValidationRecordList();\n+   if (cg->comp()->getOption(TR_UseSymbolValidationManager))\n+      {\n+      // Add the flags in TR_AOTMethodHeader on the compile run\n+      J9JITDataCacheHeader *aotMethodHeader = (J9JITDataCacheHeader *)cg->comp()->getAotMethodDataStart();\n+      TR_AOTMethodHeader *aotMethodHeaderEntry = (TR_AOTMethodHeader *)(aotMethodHeader + 1);\n+      aotMethodHeaderEntry->flags |= TR_AOTMethodHeader_UsesSymbolValidationManager;\n \n-      // Traverse list of AOT-specific guards and create relocation records\n-      TR::list<TR_AOTGuardSite*> *aotGuardSites = self()->comp()->getAOTGuardPatchSites();\n-      for(auto it = aotGuardSites->begin(); it != aotGuardSites->end(); ++it)\n+      for (auto it = validationRecords.begin(); it != validationRecords.end(); it++)\n          {\n-         intptr_t inlinedSiteIndex = -1;\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(*it),\n+                                                                          (*it)->_kind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n+         }\n+      }\n+   }\n \n-         // first, figure out the appropriate relocation record type from the guard type and symbol\n-         TR_ExternalRelocationTargetKind type;\n-         switch ((*it)->getType())\n-            {\n-            case TR_DirectMethodGuard:\n-               if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isStatic())\n-                  type = TR_InlinedStaticMethodWithNopGuard;\n-               else if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isSpecial())\n-                  type = TR_InlinedSpecialMethodWithNopGuard;\n-               else if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isVirtual())\n-                  type = TR_InlinedVirtualMethodWithNopGuard;\n-               else\n-                  TR_ASSERT(0, \"unexpected AOTDirectMethodGuard method symbol\");\n-               break;\n+static TR_ExternalRelocationTargetKind getReloKindFromGuardSite(TR::CodeGenerator *cg, TR_AOTGuardSite *site)\n+   {\n+   TR_ExternalRelocationTargetKind type;\n \n-            case TR_NonoverriddenGuard:\n-               type = TR_InlinedVirtualMethodWithNopGuard;\n-               break;\n-            case TR_RemovedNonoverriddenGuard:\n-               type = TR_InlinedVirtualMethod;\n-               break;\n+   switch (site->getType())\n+      {\n+      case TR_DirectMethodGuard:\n+         if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isStatic())\n+            type = TR_InlinedStaticMethodWithNopGuard;\n+         else if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isSpecial())\n+            type = TR_InlinedSpecialMethodWithNopGuard;\n+         else if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isVirtual())\n+            type = TR_InlinedVirtualMethodWithNopGuard;\n+         else\n+            TR_ASSERT(0, \"unexpected AOTDirectMethodGuard method symbol\");\n+         break;\n \n-            case TR_InterfaceGuard:\n-               type = TR_InlinedInterfaceMethodWithNopGuard;\n-               break;\n-            case TR_RemovedInterfaceGuard:\n-               traceMsg(self()->comp(), \"TR_RemovedInterfaceMethod\\n\");\n-               type = TR_InlinedInterfaceMethod;\n-               break;\n+      case TR_NonoverriddenGuard:\n+         type = TR_InlinedVirtualMethodWithNopGuard;\n+         break;\n+      case TR_RemovedNonoverriddenGuard:\n+         type = TR_InlinedVirtualMethod;\n+         break;\n \n-            case TR_AbstractGuard:\n-               type = TR_InlinedAbstractMethodWithNopGuard;\n-               break;\n+      case TR_InterfaceGuard:\n+         type = TR_InlinedInterfaceMethodWithNopGuard;\n+         break;\n+      case TR_RemovedInterfaceGuard:\n+         traceMsg(cg->comp(), \"TR_RemovedInterfaceMethod\\n\");\n+         type = TR_InlinedInterfaceMethod;\n+         break;\n \n-            case TR_HCRGuard:\n-               // devinmp: TODO/FIXME this should arrange to create an AOT\n-               // relocation which, when loaded, creates a\n-               // TR_PatchNOPedGuardSiteOnClassRedefinition or similar.\n-               // Here we would previously create a TR_HCR relocation,\n-               // which is for replacing J9Class or J9Method pointers.\n-               // These would be the 'unresolved' variant\n-               // (TR_RedefinedClassUPicSite), which would (hopefully) never\n-               // get patched. If it were patched, it seems like it would\n-               // replace code with a J9Method pointer.\n-               if (!self()->comp()->getOption(TR_UseOldHCRGuardAOTRelocations))\n-                  continue;\n-               type = TR_HCR;\n-               break;\n+      case TR_AbstractGuard:\n+         type = TR_InlinedAbstractMethodWithNopGuard;\n+         break;\n \n-            case TR_MethodEnterExitGuard:\n-               if ((*it)->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodEnterHook)\n-                  type = TR_CheckMethodEnter;\n-               else if ((*it)->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodExitHook)\n-                  type = TR_CheckMethodExit;\n-               else\n-                  TR_ASSERT(0,\"Unexpected TR_MethodEnterExitGuard at site %p guard %p node %p\\n\",\n-                                    *it, (*it)->getGuard(), (*it)->getGuard()->getCallNode());\n-               break;\n+      case TR_HCRGuard:\n+         // devinmp: TODO/FIXME this should arrange to create an AOT\n+         // relocation which, when loaded, creates a\n+         // TR_PatchNOPedGuardSiteOnClassRedefinition or similar.\n+         // Here we would previously create a TR_HCR relocation,\n+         // which is for replacing J9Class or J9Method pointers.\n+         // These would be the 'unresolved' variant\n+         // (TR_RedefinedClassUPicSite), which would (hopefully) never\n+         // get patched. If it were patched, it seems like it would\n+         // replace code with a J9Method pointer.\n+         if (!cg->comp()->getOption(TR_UseOldHCRGuardAOTRelocations))\n+            type = TR_NoRelocation;\n+         else\n+            type = TR_HCR;\n+         break;\n \n-            case TR_RemovedProfiledGuard:\n-               traceMsg(self()->comp(), \"TR_ProfiledInlinedMethodRelocation\\n\");\n-               type = TR_ProfiledInlinedMethodRelocation;\n-               break;\n+      case TR_MethodEnterExitGuard:\n+         if (site->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodEnterHook)\n+            type = TR_CheckMethodEnter;\n+         else if (site->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodExitHook)\n+            type = TR_CheckMethodExit;\n+         else\n+            TR_ASSERT(0,\"Unexpected TR_MethodEnterExitGuard at site %p guard %p node %p\\n\",\n+                              *it, site->getGuard(), site->getGuard()->getCallNode());\n+         break;\n \n-            case TR_ProfiledGuard:\n-               if ((*it)->getGuard()->getTestType() == TR_MethodTest)\n-                  {\n-                  type = TR_ProfiledMethodGuardRelocation;\n-                  traceMsg(self()->comp(), \"TR_ProfiledMethodGuardRelocation\\n\");\n-                  }\n-               else if ((*it)->getGuard()->getTestType() == TR_VftTest)\n-                  {\n-                  type = TR_ProfiledClassGuardRelocation;\n-                  traceMsg(self()->comp(), \"TR_ProfiledClassGuardRelocation\\n\");\n-                  }\n-               else\n-                  TR_ASSERT(false, \"unexpected profiled guard test type\");\n-               break;\n+      case TR_RemovedProfiledGuard:\n+         traceMsg(cg->comp(), \"TR_ProfiledInlinedMethodRelocation\\n\");\n+         type = TR_ProfiledInlinedMethodRelocation;\n+         break;\n \n-            default:\n-               TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n-               break;\n+      case TR_ProfiledGuard:\n+         if (site->getGuard()->getTestType() == TR_MethodTest)\n+            {\n+            type = TR_ProfiledMethodGuardRelocation;\n+            traceMsg(cg->comp(), \"TR_ProfiledMethodGuardRelocation\\n\");\n             }\n-\n-         switch (type)  // relocation record type\n+         else if (site->getGuard()->getTestType() == TR_VftTest)\n             {\n-            case TR_InlinedStaticMethodWithNopGuard:\n-            case TR_InlinedSpecialMethodWithNopGuard:\n-            case TR_InlinedVirtualMethodWithNopGuard:\n-            case TR_InlinedInterfaceMethodWithNopGuard:\n-            case TR_InlinedAbstractMethodWithNopGuard:\n-            case TR_ProfiledClassGuardRelocation:\n-            case TR_ProfiledMethodGuardRelocation:\n-            case TR_ProfiledInlinedMethodRelocation:\n-            case TR_InlinedVirtualMethod:\n-            case TR_InlinedInterfaceMethod:\n-               TR_ASSERT(inlinedCallSize, \"TR_AOT expect inlinedCallSize to be larger than 0\\n\");\n-               inlinedSiteIndex = (intptr_t)(*it)->getGuard()->getCurrentInlinedSiteIndex();\n-               entry = (TR_InlinedSiteLinkedListEntry *)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteLinkedListEntry), heapAlloc);\n-\n-               entry->reloType = type;\n-               entry->location = (uint8_t *)(*it)->getLocation();\n-               entry->destination = (uint8_t *)(*it)->getDestination();\n-               entry->guard = (uint8_t *)(*it)->getGuard();\n-               entry->next = NULL;\n-\n-               if (orderedInlinedSiteListTable[inlinedSiteIndex].first)\n-                  {\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last->next = entry;\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n-                  }\n-               else\n-                  {\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].first = entry;\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n-                  }\n-               break;\n+            type = TR_ProfiledClassGuardRelocation;\n+            traceMsg(cg->comp(), \"TR_ProfiledClassGuardRelocation\\n\");\n+            }\n+         else\n+            TR_ASSERT(false, \"unexpected profiled guard test type\");\n+         break;\n \n-            case TR_CheckMethodEnter:\n-            case TR_CheckMethodExit:\n-            case TR_HCR:\n-               self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation((uint8_t *)(*it)->getLocation(),\n-                                                                                (uint8_t *)(*it)->getDestination(),\n-                                                                                type, self()),\n-                                __FILE__, __LINE__, NULL);\n-               break;\n+      default:\n+         TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n+         cg->comp()->failCompilation<J9::AOTRelocationRecordGenerationFailure>(\"Unknown/non-AOT guard at AOT site\");\n+         break;\n+      }\n \n-            default:\n-               TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n-               break;\n-            }\n-         }\n+   return type;\n+   }\n \n-      TR::list<TR::AOTClassInfo*>* classInfo = self()->comp()->_aotClassInfo;\n-      if (!classInfo->empty())\n+static void processAOTGuardSites(TR::CodeGenerator *cg, uint32_t inlinedCallSize, TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable)\n+   {\n+   TR::list<TR_AOTGuardSite*> *aotGuardSites = cg->comp()->getAOTGuardPatchSites();\n+   for(auto it = aotGuardSites->begin(); it != aotGuardSites->end(); ++it)\n+      {\n+      // first, figure out the appropriate relocation record type from the guard type and symbol\n+      TR_ExternalRelocationTargetKind type = getReloKindFromGuardSite(cg, (*it));\n+\n+      switch (type)  // relocation record type\n          {\n-         for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         case TR_InlinedStaticMethodWithNopGuard:\n+         case TR_InlinedSpecialMethodWithNopGuard:\n+         case TR_InlinedVirtualMethodWithNopGuard:\n+         case TR_InlinedInterfaceMethodWithNopGuard:\n+         case TR_InlinedAbstractMethodWithNopGuard:\n+         case TR_ProfiledClassGuardRelocation:\n+         case TR_ProfiledMethodGuardRelocation:\n+         case TR_ProfiledInlinedMethodRelocation:\n+         case TR_InlinedVirtualMethod:\n+         case TR_InlinedInterfaceMethod:\n             {\n-            traceMsg(self()->comp(), \"processing AOT class info: %p in %s\\n\", *info, self()->comp()->signature());\n-            traceMsg(self()->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n-            traceMsg(self()->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n+            TR_ASSERT(inlinedCallSize, \"TR_AOT expect inlinedCallSize to be larger than 0\\n\");\n+            intptr_t inlinedSiteIndex = (intptr_t)(*it)->getGuard()->getCurrentInlinedSiteIndex();\n+            TR_InlinedSiteLinkedListEntry *entry = (TR_InlinedSiteLinkedListEntry *)cg->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteLinkedListEntry), heapAlloc);\n \n-            TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n+            entry->reloType = type;\n+            entry->location = (uint8_t *)(*it)->getLocation();\n+            entry->destination = (uint8_t *)(*it)->getDestination();\n+            entry->guard = (uint8_t *)(*it)->getGuard();\n+            entry->next = NULL;\n \n-            int32_t siteIndex = -1;\n-\n-            if (ramMethod != self()->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            if (orderedInlinedSiteListTable[inlinedSiteIndex].first)\n                {\n-               int32_t i;\n-               for (i = 0; i < self()->comp()->getNumInlinedCallSites(); i++)\n-                  {\n-                  TR_InlinedCallSite &ics = self()->comp()->getInlinedCallSite(i);\n-                  TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n-\n-                  traceMsg(self()->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n-                  if (ramMethod == inlinedMethod)\n-                     {\n-                     traceMsg(self()->comp(), \"\\t\\tmatch!\\n\");\n-                     siteIndex = i;\n-                     break;\n-                     }\n-                  }\n-\n-               if (i >= (int32_t) self()->comp()->getNumInlinedCallSites())\n-                  {\n-                  // this assumption isn't associated with a method directly in the compilation\n-                  // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n-                  // kind of overkill for TR_ValidateStaticField, but still correct\n-                  (*info)->_reloKind = TR_ValidateArbitraryClass;\n-                  siteIndex = -1;   // invalidate main compiled method\n-                  traceMsg(self()->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n-                  }\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last->next = entry;\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n                }\n+            else\n+               {\n+               orderedInlinedSiteListTable[inlinedSiteIndex].first = entry;\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n+               }\n+            }\n+            break;\n \n-            traceMsg(self()->comp(), \"Found inlined site %d\\n\", siteIndex);\n+         case TR_CheckMethodEnter:\n+         case TR_CheckMethodExit:\n+         case TR_HCR:\n+            cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation((uint8_t *)(*it)->getLocation(),\n+                                                                             (uint8_t *)(*it)->getDestination(),\n+                                                                             type, cg),\n+                             __FILE__, __LINE__, NULL);\n+            break;\n \n-            TR_ASSERT(siteIndex < (int32_t) self()->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+         case TR_NoRelocation:\n+            break;\n \n-            self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation(NULL,\n-                                                                             (uint8_t *)(intptr_t)siteIndex,\n-                                                                             (uint8_t *)(*info),\n-                                                                             (*info)->_reloKind, self()),\n-                                                                             __FILE__, __LINE__, NULL);\n-            }\n+         default:\n+            TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n+            cg->comp()->failCompilation<J9::AOTRelocationRecordGenerationFailure>(\"Unknown/non-AOT guard at AOT site\");\n+            break;\n          }\n+      }\n+   }\n \n-      // If have inlined calls, now add the relocation records in descending order of inlined site index (at relocation time, the order is reverse)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91508c2995a9eb775220cafdee46b72c0e8e8d72"}, "originalPosition": 423}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2NTM4Mw==", "bodyText": "Not really sure, will add back.", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561065383", "createdAt": "2021-01-20T15:42:50Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n \n-   //Project neutral non-AOT processRelocation\n-   OMR::CodeGeneratorConnector::processRelocations();\n+   TR::list<TR::AOTClassInfo*>* classInfo = cg->comp()->_aotClassInfo;\n+   if (!classInfo->empty())\n+      {\n+      for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         {\n+         traceMsg(cg->comp(), \"processing AOT class info: %p in %s\\n\", *info, cg->comp()->signature());\n+         traceMsg(cg->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n+         traceMsg(cg->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n \n-   int32_t missedSite = -1;\n+         TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n \n-   if (self()->comp()->compileRelocatableCode())\n-      {\n-      uint32_t inlinedCallSize = self()->comp()->getNumInlinedCallSites();\n+         int32_t siteIndex = -1;\n \n-      // Create temporary hashtable for ordering AOT guard relocations\n-      int32_t counter = inlinedCallSize;\n-      TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable;\n-      if (inlinedCallSize > 0)\n-         {\n-         orderedInlinedSiteListTable= (TR_InlinedSiteHastTableEntry*)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteHastTableEntry) * inlinedCallSize, heapAlloc);\n-         memset(orderedInlinedSiteListTable, 0, sizeof(TR_InlinedSiteHastTableEntry)*inlinedCallSize);\n+         if (ramMethod != cg->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            {\n+            int32_t i;\n+            for (i = 0; i < cg->comp()->getNumInlinedCallSites(); i++)\n+               {\n+               TR_InlinedCallSite &ics = cg->comp()->getInlinedCallSite(i);\n+               TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n+\n+               traceMsg(cg->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n+               if (ramMethod == inlinedMethod)\n+                  {\n+                  traceMsg(cg->comp(), \"\\t\\tmatch!\\n\");\n+                  siteIndex = i;\n+                  break;\n+                  }\n+               }\n+\n+            if (i >= (int32_t) cg->comp()->getNumInlinedCallSites())\n+               {\n+               // this assumption isn't associated with a method directly in the compilation\n+               // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n+               // kind of overkill for TR_ValidateStaticField, but still correct\n+               (*info)->_reloKind = TR_ValidateArbitraryClass;\n+               siteIndex = -1;   // invalidate main compiled method\n+               traceMsg(cg->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n+               }\n+            }\n+\n+         traceMsg(cg->comp(), \"Found inlined site %d\\n\", siteIndex);\n+\n+         TR_ASSERT(siteIndex < (int32_t) cg->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(intptr_t)siteIndex,\n+                                                                          (uint8_t *)(*info),\n+                                                                          (*info)->_reloKind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n          }\n-      else\n-         orderedInlinedSiteListTable = NULL;\n+      }\n+   }\n \n-      TR_InlinedSiteLinkedListEntry *entry = NULL;\n+static void addSVMValidationRecords(TR::CodeGenerator *cg)\n+   {\n+   TR::SymbolValidationManager::SymbolValidationRecordList &validationRecords = cg->comp()->getSymbolValidationManager()->getValidationRecordList();\n+   if (cg->comp()->getOption(TR_UseSymbolValidationManager))\n+      {\n+      // Add the flags in TR_AOTMethodHeader on the compile run\n+      J9JITDataCacheHeader *aotMethodHeader = (J9JITDataCacheHeader *)cg->comp()->getAotMethodDataStart();\n+      TR_AOTMethodHeader *aotMethodHeaderEntry = (TR_AOTMethodHeader *)(aotMethodHeader + 1);\n+      aotMethodHeaderEntry->flags |= TR_AOTMethodHeader_UsesSymbolValidationManager;\n \n-      // Traverse list of AOT-specific guards and create relocation records\n-      TR::list<TR_AOTGuardSite*> *aotGuardSites = self()->comp()->getAOTGuardPatchSites();\n-      for(auto it = aotGuardSites->begin(); it != aotGuardSites->end(); ++it)\n+      for (auto it = validationRecords.begin(); it != validationRecords.end(); it++)\n          {\n-         intptr_t inlinedSiteIndex = -1;\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(*it),\n+                                                                          (*it)->_kind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n+         }\n+      }\n+   }\n \n-         // first, figure out the appropriate relocation record type from the guard type and symbol\n-         TR_ExternalRelocationTargetKind type;\n-         switch ((*it)->getType())\n-            {\n-            case TR_DirectMethodGuard:\n-               if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isStatic())\n-                  type = TR_InlinedStaticMethodWithNopGuard;\n-               else if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isSpecial())\n-                  type = TR_InlinedSpecialMethodWithNopGuard;\n-               else if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isVirtual())\n-                  type = TR_InlinedVirtualMethodWithNopGuard;\n-               else\n-                  TR_ASSERT(0, \"unexpected AOTDirectMethodGuard method symbol\");\n-               break;\n+static TR_ExternalRelocationTargetKind getReloKindFromGuardSite(TR::CodeGenerator *cg, TR_AOTGuardSite *site)\n+   {\n+   TR_ExternalRelocationTargetKind type;\n \n-            case TR_NonoverriddenGuard:\n-               type = TR_InlinedVirtualMethodWithNopGuard;\n-               break;\n-            case TR_RemovedNonoverriddenGuard:\n-               type = TR_InlinedVirtualMethod;\n-               break;\n+   switch (site->getType())\n+      {\n+      case TR_DirectMethodGuard:\n+         if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isStatic())\n+            type = TR_InlinedStaticMethodWithNopGuard;\n+         else if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isSpecial())\n+            type = TR_InlinedSpecialMethodWithNopGuard;\n+         else if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isVirtual())\n+            type = TR_InlinedVirtualMethodWithNopGuard;\n+         else\n+            TR_ASSERT(0, \"unexpected AOTDirectMethodGuard method symbol\");\n+         break;\n \n-            case TR_InterfaceGuard:\n-               type = TR_InlinedInterfaceMethodWithNopGuard;\n-               break;\n-            case TR_RemovedInterfaceGuard:\n-               traceMsg(self()->comp(), \"TR_RemovedInterfaceMethod\\n\");\n-               type = TR_InlinedInterfaceMethod;\n-               break;\n+      case TR_NonoverriddenGuard:\n+         type = TR_InlinedVirtualMethodWithNopGuard;\n+         break;\n+      case TR_RemovedNonoverriddenGuard:\n+         type = TR_InlinedVirtualMethod;\n+         break;\n \n-            case TR_AbstractGuard:\n-               type = TR_InlinedAbstractMethodWithNopGuard;\n-               break;\n+      case TR_InterfaceGuard:\n+         type = TR_InlinedInterfaceMethodWithNopGuard;\n+         break;\n+      case TR_RemovedInterfaceGuard:\n+         traceMsg(cg->comp(), \"TR_RemovedInterfaceMethod\\n\");\n+         type = TR_InlinedInterfaceMethod;\n+         break;\n \n-            case TR_HCRGuard:\n-               // devinmp: TODO/FIXME this should arrange to create an AOT\n-               // relocation which, when loaded, creates a\n-               // TR_PatchNOPedGuardSiteOnClassRedefinition or similar.\n-               // Here we would previously create a TR_HCR relocation,\n-               // which is for replacing J9Class or J9Method pointers.\n-               // These would be the 'unresolved' variant\n-               // (TR_RedefinedClassUPicSite), which would (hopefully) never\n-               // get patched. If it were patched, it seems like it would\n-               // replace code with a J9Method pointer.\n-               if (!self()->comp()->getOption(TR_UseOldHCRGuardAOTRelocations))\n-                  continue;\n-               type = TR_HCR;\n-               break;\n+      case TR_AbstractGuard:\n+         type = TR_InlinedAbstractMethodWithNopGuard;\n+         break;\n \n-            case TR_MethodEnterExitGuard:\n-               if ((*it)->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodEnterHook)\n-                  type = TR_CheckMethodEnter;\n-               else if ((*it)->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodExitHook)\n-                  type = TR_CheckMethodExit;\n-               else\n-                  TR_ASSERT(0,\"Unexpected TR_MethodEnterExitGuard at site %p guard %p node %p\\n\",\n-                                    *it, (*it)->getGuard(), (*it)->getGuard()->getCallNode());\n-               break;\n+      case TR_HCRGuard:\n+         // devinmp: TODO/FIXME this should arrange to create an AOT\n+         // relocation which, when loaded, creates a\n+         // TR_PatchNOPedGuardSiteOnClassRedefinition or similar.\n+         // Here we would previously create a TR_HCR relocation,\n+         // which is for replacing J9Class or J9Method pointers.\n+         // These would be the 'unresolved' variant\n+         // (TR_RedefinedClassUPicSite), which would (hopefully) never\n+         // get patched. If it were patched, it seems like it would\n+         // replace code with a J9Method pointer.\n+         if (!cg->comp()->getOption(TR_UseOldHCRGuardAOTRelocations))\n+            type = TR_NoRelocation;\n+         else\n+            type = TR_HCR;\n+         break;\n \n-            case TR_RemovedProfiledGuard:\n-               traceMsg(self()->comp(), \"TR_ProfiledInlinedMethodRelocation\\n\");\n-               type = TR_ProfiledInlinedMethodRelocation;\n-               break;\n+      case TR_MethodEnterExitGuard:\n+         if (site->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodEnterHook)\n+            type = TR_CheckMethodEnter;\n+         else if (site->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodExitHook)\n+            type = TR_CheckMethodExit;\n+         else\n+            TR_ASSERT(0,\"Unexpected TR_MethodEnterExitGuard at site %p guard %p node %p\\n\",\n+                              *it, site->getGuard(), site->getGuard()->getCallNode());\n+         break;\n \n-            case TR_ProfiledGuard:\n-               if ((*it)->getGuard()->getTestType() == TR_MethodTest)\n-                  {\n-                  type = TR_ProfiledMethodGuardRelocation;\n-                  traceMsg(self()->comp(), \"TR_ProfiledMethodGuardRelocation\\n\");\n-                  }\n-               else if ((*it)->getGuard()->getTestType() == TR_VftTest)\n-                  {\n-                  type = TR_ProfiledClassGuardRelocation;\n-                  traceMsg(self()->comp(), \"TR_ProfiledClassGuardRelocation\\n\");\n-                  }\n-               else\n-                  TR_ASSERT(false, \"unexpected profiled guard test type\");\n-               break;\n+      case TR_RemovedProfiledGuard:\n+         traceMsg(cg->comp(), \"TR_ProfiledInlinedMethodRelocation\\n\");\n+         type = TR_ProfiledInlinedMethodRelocation;\n+         break;\n \n-            default:\n-               TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n-               break;\n+      case TR_ProfiledGuard:\n+         if (site->getGuard()->getTestType() == TR_MethodTest)\n+            {\n+            type = TR_ProfiledMethodGuardRelocation;\n+            traceMsg(cg->comp(), \"TR_ProfiledMethodGuardRelocation\\n\");\n             }\n-\n-         switch (type)  // relocation record type\n+         else if (site->getGuard()->getTestType() == TR_VftTest)\n             {\n-            case TR_InlinedStaticMethodWithNopGuard:\n-            case TR_InlinedSpecialMethodWithNopGuard:\n-            case TR_InlinedVirtualMethodWithNopGuard:\n-            case TR_InlinedInterfaceMethodWithNopGuard:\n-            case TR_InlinedAbstractMethodWithNopGuard:\n-            case TR_ProfiledClassGuardRelocation:\n-            case TR_ProfiledMethodGuardRelocation:\n-            case TR_ProfiledInlinedMethodRelocation:\n-            case TR_InlinedVirtualMethod:\n-            case TR_InlinedInterfaceMethod:\n-               TR_ASSERT(inlinedCallSize, \"TR_AOT expect inlinedCallSize to be larger than 0\\n\");\n-               inlinedSiteIndex = (intptr_t)(*it)->getGuard()->getCurrentInlinedSiteIndex();\n-               entry = (TR_InlinedSiteLinkedListEntry *)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteLinkedListEntry), heapAlloc);\n-\n-               entry->reloType = type;\n-               entry->location = (uint8_t *)(*it)->getLocation();\n-               entry->destination = (uint8_t *)(*it)->getDestination();\n-               entry->guard = (uint8_t *)(*it)->getGuard();\n-               entry->next = NULL;\n-\n-               if (orderedInlinedSiteListTable[inlinedSiteIndex].first)\n-                  {\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last->next = entry;\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n-                  }\n-               else\n-                  {\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].first = entry;\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n-                  }\n-               break;\n+            type = TR_ProfiledClassGuardRelocation;\n+            traceMsg(cg->comp(), \"TR_ProfiledClassGuardRelocation\\n\");\n+            }\n+         else\n+            TR_ASSERT(false, \"unexpected profiled guard test type\");\n+         break;\n \n-            case TR_CheckMethodEnter:\n-            case TR_CheckMethodExit:\n-            case TR_HCR:\n-               self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation((uint8_t *)(*it)->getLocation(),\n-                                                                                (uint8_t *)(*it)->getDestination(),\n-                                                                                type, self()),\n-                                __FILE__, __LINE__, NULL);\n-               break;\n+      default:\n+         TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n+         cg->comp()->failCompilation<J9::AOTRelocationRecordGenerationFailure>(\"Unknown/non-AOT guard at AOT site\");\n+         break;\n+      }\n \n-            default:\n-               TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n-               break;\n-            }\n-         }\n+   return type;\n+   }\n \n-      TR::list<TR::AOTClassInfo*>* classInfo = self()->comp()->_aotClassInfo;\n-      if (!classInfo->empty())\n+static void processAOTGuardSites(TR::CodeGenerator *cg, uint32_t inlinedCallSize, TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable)\n+   {\n+   TR::list<TR_AOTGuardSite*> *aotGuardSites = cg->comp()->getAOTGuardPatchSites();\n+   for(auto it = aotGuardSites->begin(); it != aotGuardSites->end(); ++it)\n+      {\n+      // first, figure out the appropriate relocation record type from the guard type and symbol\n+      TR_ExternalRelocationTargetKind type = getReloKindFromGuardSite(cg, (*it));\n+\n+      switch (type)  // relocation record type\n          {\n-         for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         case TR_InlinedStaticMethodWithNopGuard:\n+         case TR_InlinedSpecialMethodWithNopGuard:\n+         case TR_InlinedVirtualMethodWithNopGuard:\n+         case TR_InlinedInterfaceMethodWithNopGuard:\n+         case TR_InlinedAbstractMethodWithNopGuard:\n+         case TR_ProfiledClassGuardRelocation:\n+         case TR_ProfiledMethodGuardRelocation:\n+         case TR_ProfiledInlinedMethodRelocation:\n+         case TR_InlinedVirtualMethod:\n+         case TR_InlinedInterfaceMethod:\n             {\n-            traceMsg(self()->comp(), \"processing AOT class info: %p in %s\\n\", *info, self()->comp()->signature());\n-            traceMsg(self()->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n-            traceMsg(self()->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n+            TR_ASSERT(inlinedCallSize, \"TR_AOT expect inlinedCallSize to be larger than 0\\n\");\n+            intptr_t inlinedSiteIndex = (intptr_t)(*it)->getGuard()->getCurrentInlinedSiteIndex();\n+            TR_InlinedSiteLinkedListEntry *entry = (TR_InlinedSiteLinkedListEntry *)cg->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteLinkedListEntry), heapAlloc);\n \n-            TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n+            entry->reloType = type;\n+            entry->location = (uint8_t *)(*it)->getLocation();\n+            entry->destination = (uint8_t *)(*it)->getDestination();\n+            entry->guard = (uint8_t *)(*it)->getGuard();\n+            entry->next = NULL;\n \n-            int32_t siteIndex = -1;\n-\n-            if (ramMethod != self()->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            if (orderedInlinedSiteListTable[inlinedSiteIndex].first)\n                {\n-               int32_t i;\n-               for (i = 0; i < self()->comp()->getNumInlinedCallSites(); i++)\n-                  {\n-                  TR_InlinedCallSite &ics = self()->comp()->getInlinedCallSite(i);\n-                  TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n-\n-                  traceMsg(self()->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n-                  if (ramMethod == inlinedMethod)\n-                     {\n-                     traceMsg(self()->comp(), \"\\t\\tmatch!\\n\");\n-                     siteIndex = i;\n-                     break;\n-                     }\n-                  }\n-\n-               if (i >= (int32_t) self()->comp()->getNumInlinedCallSites())\n-                  {\n-                  // this assumption isn't associated with a method directly in the compilation\n-                  // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n-                  // kind of overkill for TR_ValidateStaticField, but still correct\n-                  (*info)->_reloKind = TR_ValidateArbitraryClass;\n-                  siteIndex = -1;   // invalidate main compiled method\n-                  traceMsg(self()->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n-                  }\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last->next = entry;\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n                }\n+            else\n+               {\n+               orderedInlinedSiteListTable[inlinedSiteIndex].first = entry;\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n+               }\n+            }\n+            break;\n \n-            traceMsg(self()->comp(), \"Found inlined site %d\\n\", siteIndex);\n+         case TR_CheckMethodEnter:\n+         case TR_CheckMethodExit:\n+         case TR_HCR:\n+            cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation((uint8_t *)(*it)->getLocation(),\n+                                                                             (uint8_t *)(*it)->getDestination(),\n+                                                                             type, cg),\n+                             __FILE__, __LINE__, NULL);\n+            break;\n \n-            TR_ASSERT(siteIndex < (int32_t) self()->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+         case TR_NoRelocation:\n+            break;\n \n-            self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation(NULL,\n-                                                                             (uint8_t *)(intptr_t)siteIndex,\n-                                                                             (uint8_t *)(*info),\n-                                                                             (*info)->_reloKind, self()),\n-                                                                             __FILE__, __LINE__, NULL);\n-            }\n+         default:\n+            TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n+            cg->comp()->failCompilation<J9::AOTRelocationRecordGenerationFailure>(\"Unknown/non-AOT guard at AOT site\");\n+            break;\n          }\n+      }\n+   }\n \n-      // If have inlined calls, now add the relocation records in descending order of inlined site index (at relocation time, the order is reverse)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNzcxMw=="}, "originalCommit": {"oid": "91508c2995a9eb775220cafdee46b72c0e8e8d72"}, "originalPosition": 423}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTA0NTY2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQyMzowMDoxMFrOIV5M6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQyMzowMDoxMFrOIV5M6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyODIwMg==", "bodyText": "Maybe add a \"should be done first\" to this comment, and explain why?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559828202", "createdAt": "2021-01-18T23:00:10Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,303 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n \n-   //Project neutral non-AOT processRelocation\n-   OMR::CodeGeneratorConnector::processRelocations();\n+   TR::list<TR::AOTClassInfo*>* classInfo = cg->comp()->_aotClassInfo;\n+   if (!classInfo->empty())\n+      {\n+      for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         {\n+         traceMsg(cg->comp(), \"processing AOT class info: %p in %s\\n\", *info, cg->comp()->signature());\n+         traceMsg(cg->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n+         traceMsg(cg->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n \n-   int32_t missedSite = -1;\n+         TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n \n-   if (self()->comp()->compileRelocatableCode())\n-      {\n-      uint32_t inlinedCallSize = self()->comp()->getNumInlinedCallSites();\n+         int32_t siteIndex = -1;\n \n-      // Create temporary hashtable for ordering AOT guard relocations\n-      int32_t counter = inlinedCallSize;\n-      TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable;\n-      if (inlinedCallSize > 0)\n-         {\n-         orderedInlinedSiteListTable= (TR_InlinedSiteHastTableEntry*)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteHastTableEntry) * inlinedCallSize, heapAlloc);\n-         memset(orderedInlinedSiteListTable, 0, sizeof(TR_InlinedSiteHastTableEntry)*inlinedCallSize);\n+         if (ramMethod != cg->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            {\n+            int32_t i;\n+            for (i = 0; i < cg->comp()->getNumInlinedCallSites(); i++)\n+               {\n+               TR_InlinedCallSite &ics = cg->comp()->getInlinedCallSite(i);\n+               TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n+\n+               traceMsg(cg->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n+               if (ramMethod == inlinedMethod)\n+                  {\n+                  traceMsg(cg->comp(), \"\\t\\tmatch!\\n\");\n+                  siteIndex = i;\n+                  break;\n+                  }\n+               }\n+\n+            if (i >= (int32_t) cg->comp()->getNumInlinedCallSites())\n+               {\n+               // this assumption isn't associated with a method directly in the compilation\n+               // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n+               // kind of overkill for TR_ValidateStaticField, but still correct\n+               (*info)->_reloKind = TR_ValidateArbitraryClass;\n+               siteIndex = -1;   // invalidate main compiled method\n+               traceMsg(cg->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n+               }\n+            }\n+\n+         traceMsg(cg->comp(), \"Found inlined site %d\\n\", siteIndex);\n+\n+         TR_ASSERT(siteIndex < (int32_t) cg->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(intptr_t)siteIndex,\n+                                                                          (uint8_t *)(*info),\n+                                                                          (*info)->_reloKind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n          }\n-      else\n-         orderedInlinedSiteListTable = NULL;\n+      }\n+   }\n \n-      TR_InlinedSiteLinkedListEntry *entry = NULL;\n+static void addSVMValidationRecords(TR::CodeGenerator *cg)\n+   {\n+   TR::SymbolValidationManager::SymbolValidationRecordList &validationRecords = cg->comp()->getSymbolValidationManager()->getValidationRecordList();\n+   if (cg->comp()->getOption(TR_UseSymbolValidationManager))\n+      {\n+      // Add the flags in TR_AOTMethodHeader on the compile run\n+      J9JITDataCacheHeader *aotMethodHeader = (J9JITDataCacheHeader *)cg->comp()->getAotMethodDataStart();\n+      TR_AOTMethodHeader *aotMethodHeaderEntry = (TR_AOTMethodHeader *)(aotMethodHeader + 1);\n+      aotMethodHeaderEntry->flags |= TR_AOTMethodHeader_UsesSymbolValidationManager;\n \n-      // Traverse list of AOT-specific guards and create relocation records\n-      TR::list<TR_AOTGuardSite*> *aotGuardSites = self()->comp()->getAOTGuardPatchSites();\n-      for(auto it = aotGuardSites->begin(); it != aotGuardSites->end(); ++it)\n+      for (auto it = validationRecords.begin(); it != validationRecords.end(); it++)\n          {\n-         intptr_t inlinedSiteIndex = -1;\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(*it),\n+                                                                          (*it)->_kind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n+         }\n+      }\n+   }\n \n-         // first, figure out the appropriate relocation record type from the guard type and symbol\n-         TR_ExternalRelocationTargetKind type;\n-         switch ((*it)->getType())\n-            {\n-            case TR_DirectMethodGuard:\n-               if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isStatic())\n-                  type = TR_InlinedStaticMethodWithNopGuard;\n-               else if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isSpecial())\n-                  type = TR_InlinedSpecialMethodWithNopGuard;\n-               else if ((*it)->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isVirtual())\n-                  type = TR_InlinedVirtualMethodWithNopGuard;\n-               else\n-                  TR_ASSERT(0, \"unexpected AOTDirectMethodGuard method symbol\");\n-               break;\n+static TR_ExternalRelocationTargetKind getReloKindFromGuardSite(TR::CodeGenerator *cg, TR_AOTGuardSite *site)\n+   {\n+   TR_ExternalRelocationTargetKind type;\n \n-            case TR_NonoverriddenGuard:\n-               type = TR_InlinedVirtualMethodWithNopGuard;\n-               break;\n-            case TR_RemovedNonoverriddenGuard:\n-               type = TR_InlinedVirtualMethod;\n-               break;\n+   switch (site->getType())\n+      {\n+      case TR_DirectMethodGuard:\n+         if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isStatic())\n+            type = TR_InlinedStaticMethodWithNopGuard;\n+         else if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isSpecial())\n+            type = TR_InlinedSpecialMethodWithNopGuard;\n+         else if (site->getGuard()->getSymbolReference()->getSymbol()->getMethodSymbol()->isVirtual())\n+            type = TR_InlinedVirtualMethodWithNopGuard;\n+         else\n+            TR_ASSERT(0, \"unexpected AOTDirectMethodGuard method symbol\");\n+         break;\n \n-            case TR_InterfaceGuard:\n-               type = TR_InlinedInterfaceMethodWithNopGuard;\n-               break;\n-            case TR_RemovedInterfaceGuard:\n-               traceMsg(self()->comp(), \"TR_RemovedInterfaceMethod\\n\");\n-               type = TR_InlinedInterfaceMethod;\n-               break;\n+      case TR_NonoverriddenGuard:\n+         type = TR_InlinedVirtualMethodWithNopGuard;\n+         break;\n+      case TR_RemovedNonoverriddenGuard:\n+         type = TR_InlinedVirtualMethod;\n+         break;\n \n-            case TR_AbstractGuard:\n-               type = TR_InlinedAbstractMethodWithNopGuard;\n-               break;\n+      case TR_InterfaceGuard:\n+         type = TR_InlinedInterfaceMethodWithNopGuard;\n+         break;\n+      case TR_RemovedInterfaceGuard:\n+         traceMsg(cg->comp(), \"TR_RemovedInterfaceMethod\\n\");\n+         type = TR_InlinedInterfaceMethod;\n+         break;\n \n-            case TR_HCRGuard:\n-               // devinmp: TODO/FIXME this should arrange to create an AOT\n-               // relocation which, when loaded, creates a\n-               // TR_PatchNOPedGuardSiteOnClassRedefinition or similar.\n-               // Here we would previously create a TR_HCR relocation,\n-               // which is for replacing J9Class or J9Method pointers.\n-               // These would be the 'unresolved' variant\n-               // (TR_RedefinedClassUPicSite), which would (hopefully) never\n-               // get patched. If it were patched, it seems like it would\n-               // replace code with a J9Method pointer.\n-               if (!self()->comp()->getOption(TR_UseOldHCRGuardAOTRelocations))\n-                  continue;\n-               type = TR_HCR;\n-               break;\n+      case TR_AbstractGuard:\n+         type = TR_InlinedAbstractMethodWithNopGuard;\n+         break;\n \n-            case TR_MethodEnterExitGuard:\n-               if ((*it)->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodEnterHook)\n-                  type = TR_CheckMethodEnter;\n-               else if ((*it)->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodExitHook)\n-                  type = TR_CheckMethodExit;\n-               else\n-                  TR_ASSERT(0,\"Unexpected TR_MethodEnterExitGuard at site %p guard %p node %p\\n\",\n-                                    *it, (*it)->getGuard(), (*it)->getGuard()->getCallNode());\n-               break;\n+      case TR_HCRGuard:\n+         // devinmp: TODO/FIXME this should arrange to create an AOT\n+         // relocation which, when loaded, creates a\n+         // TR_PatchNOPedGuardSiteOnClassRedefinition or similar.\n+         // Here we would previously create a TR_HCR relocation,\n+         // which is for replacing J9Class or J9Method pointers.\n+         // These would be the 'unresolved' variant\n+         // (TR_RedefinedClassUPicSite), which would (hopefully) never\n+         // get patched. If it were patched, it seems like it would\n+         // replace code with a J9Method pointer.\n+         if (!cg->comp()->getOption(TR_UseOldHCRGuardAOTRelocations))\n+            type = TR_NoRelocation;\n+         else\n+            type = TR_HCR;\n+         break;\n \n-            case TR_RemovedProfiledGuard:\n-               traceMsg(self()->comp(), \"TR_ProfiledInlinedMethodRelocation\\n\");\n-               type = TR_ProfiledInlinedMethodRelocation;\n-               break;\n+      case TR_MethodEnterExitGuard:\n+         if (site->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodEnterHook)\n+            type = TR_CheckMethodEnter;\n+         else if (site->getGuard()->getCallNode()->getOpCodeValue() == TR::MethodExitHook)\n+            type = TR_CheckMethodExit;\n+         else\n+            TR_ASSERT(0,\"Unexpected TR_MethodEnterExitGuard at site %p guard %p node %p\\n\",\n+                              *it, site->getGuard(), site->getGuard()->getCallNode());\n+         break;\n \n-            case TR_ProfiledGuard:\n-               if ((*it)->getGuard()->getTestType() == TR_MethodTest)\n-                  {\n-                  type = TR_ProfiledMethodGuardRelocation;\n-                  traceMsg(self()->comp(), \"TR_ProfiledMethodGuardRelocation\\n\");\n-                  }\n-               else if ((*it)->getGuard()->getTestType() == TR_VftTest)\n-                  {\n-                  type = TR_ProfiledClassGuardRelocation;\n-                  traceMsg(self()->comp(), \"TR_ProfiledClassGuardRelocation\\n\");\n-                  }\n-               else\n-                  TR_ASSERT(false, \"unexpected profiled guard test type\");\n-               break;\n+      case TR_RemovedProfiledGuard:\n+         traceMsg(cg->comp(), \"TR_ProfiledInlinedMethodRelocation\\n\");\n+         type = TR_ProfiledInlinedMethodRelocation;\n+         break;\n \n-            default:\n-               TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n-               break;\n+      case TR_ProfiledGuard:\n+         if (site->getGuard()->getTestType() == TR_MethodTest)\n+            {\n+            type = TR_ProfiledMethodGuardRelocation;\n+            traceMsg(cg->comp(), \"TR_ProfiledMethodGuardRelocation\\n\");\n             }\n-\n-         switch (type)  // relocation record type\n+         else if (site->getGuard()->getTestType() == TR_VftTest)\n             {\n-            case TR_InlinedStaticMethodWithNopGuard:\n-            case TR_InlinedSpecialMethodWithNopGuard:\n-            case TR_InlinedVirtualMethodWithNopGuard:\n-            case TR_InlinedInterfaceMethodWithNopGuard:\n-            case TR_InlinedAbstractMethodWithNopGuard:\n-            case TR_ProfiledClassGuardRelocation:\n-            case TR_ProfiledMethodGuardRelocation:\n-            case TR_ProfiledInlinedMethodRelocation:\n-            case TR_InlinedVirtualMethod:\n-            case TR_InlinedInterfaceMethod:\n-               TR_ASSERT(inlinedCallSize, \"TR_AOT expect inlinedCallSize to be larger than 0\\n\");\n-               inlinedSiteIndex = (intptr_t)(*it)->getGuard()->getCurrentInlinedSiteIndex();\n-               entry = (TR_InlinedSiteLinkedListEntry *)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteLinkedListEntry), heapAlloc);\n-\n-               entry->reloType = type;\n-               entry->location = (uint8_t *)(*it)->getLocation();\n-               entry->destination = (uint8_t *)(*it)->getDestination();\n-               entry->guard = (uint8_t *)(*it)->getGuard();\n-               entry->next = NULL;\n-\n-               if (orderedInlinedSiteListTable[inlinedSiteIndex].first)\n-                  {\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last->next = entry;\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n-                  }\n-               else\n-                  {\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].first = entry;\n-                  orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n-                  }\n-               break;\n+            type = TR_ProfiledClassGuardRelocation;\n+            traceMsg(cg->comp(), \"TR_ProfiledClassGuardRelocation\\n\");\n+            }\n+         else\n+            TR_ASSERT(false, \"unexpected profiled guard test type\");\n+         break;\n \n-            case TR_CheckMethodEnter:\n-            case TR_CheckMethodExit:\n-            case TR_HCR:\n-               self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation((uint8_t *)(*it)->getLocation(),\n-                                                                                (uint8_t *)(*it)->getDestination(),\n-                                                                                type, self()),\n-                                __FILE__, __LINE__, NULL);\n-               break;\n+      default:\n+         TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n+         cg->comp()->failCompilation<J9::AOTRelocationRecordGenerationFailure>(\"Unknown/non-AOT guard at AOT site\");\n+         break;\n+      }\n \n-            default:\n-               TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n-               break;\n-            }\n-         }\n+   return type;\n+   }\n \n-      TR::list<TR::AOTClassInfo*>* classInfo = self()->comp()->_aotClassInfo;\n-      if (!classInfo->empty())\n+static void processAOTGuardSites(TR::CodeGenerator *cg, uint32_t inlinedCallSize, TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable)\n+   {\n+   TR::list<TR_AOTGuardSite*> *aotGuardSites = cg->comp()->getAOTGuardPatchSites();\n+   for(auto it = aotGuardSites->begin(); it != aotGuardSites->end(); ++it)\n+      {\n+      // first, figure out the appropriate relocation record type from the guard type and symbol\n+      TR_ExternalRelocationTargetKind type = getReloKindFromGuardSite(cg, (*it));\n+\n+      switch (type)  // relocation record type\n          {\n-         for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         case TR_InlinedStaticMethodWithNopGuard:\n+         case TR_InlinedSpecialMethodWithNopGuard:\n+         case TR_InlinedVirtualMethodWithNopGuard:\n+         case TR_InlinedInterfaceMethodWithNopGuard:\n+         case TR_InlinedAbstractMethodWithNopGuard:\n+         case TR_ProfiledClassGuardRelocation:\n+         case TR_ProfiledMethodGuardRelocation:\n+         case TR_ProfiledInlinedMethodRelocation:\n+         case TR_InlinedVirtualMethod:\n+         case TR_InlinedInterfaceMethod:\n             {\n-            traceMsg(self()->comp(), \"processing AOT class info: %p in %s\\n\", *info, self()->comp()->signature());\n-            traceMsg(self()->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n-            traceMsg(self()->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n+            TR_ASSERT(inlinedCallSize, \"TR_AOT expect inlinedCallSize to be larger than 0\\n\");\n+            intptr_t inlinedSiteIndex = (intptr_t)(*it)->getGuard()->getCurrentInlinedSiteIndex();\n+            TR_InlinedSiteLinkedListEntry *entry = (TR_InlinedSiteLinkedListEntry *)cg->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteLinkedListEntry), heapAlloc);\n \n-            TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n+            entry->reloType = type;\n+            entry->location = (uint8_t *)(*it)->getLocation();\n+            entry->destination = (uint8_t *)(*it)->getDestination();\n+            entry->guard = (uint8_t *)(*it)->getGuard();\n+            entry->next = NULL;\n \n-            int32_t siteIndex = -1;\n-\n-            if (ramMethod != self()->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            if (orderedInlinedSiteListTable[inlinedSiteIndex].first)\n                {\n-               int32_t i;\n-               for (i = 0; i < self()->comp()->getNumInlinedCallSites(); i++)\n-                  {\n-                  TR_InlinedCallSite &ics = self()->comp()->getInlinedCallSite(i);\n-                  TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n-\n-                  traceMsg(self()->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n-                  if (ramMethod == inlinedMethod)\n-                     {\n-                     traceMsg(self()->comp(), \"\\t\\tmatch!\\n\");\n-                     siteIndex = i;\n-                     break;\n-                     }\n-                  }\n-\n-               if (i >= (int32_t) self()->comp()->getNumInlinedCallSites())\n-                  {\n-                  // this assumption isn't associated with a method directly in the compilation\n-                  // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n-                  // kind of overkill for TR_ValidateStaticField, but still correct\n-                  (*info)->_reloKind = TR_ValidateArbitraryClass;\n-                  siteIndex = -1;   // invalidate main compiled method\n-                  traceMsg(self()->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n-                  }\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last->next = entry;\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n                }\n+            else\n+               {\n+               orderedInlinedSiteListTable[inlinedSiteIndex].first = entry;\n+               orderedInlinedSiteListTable[inlinedSiteIndex].last = entry;\n+               }\n+            }\n+            break;\n \n-            traceMsg(self()->comp(), \"Found inlined site %d\\n\", siteIndex);\n+         case TR_CheckMethodEnter:\n+         case TR_CheckMethodExit:\n+         case TR_HCR:\n+            cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation((uint8_t *)(*it)->getLocation(),\n+                                                                             (uint8_t *)(*it)->getDestination(),\n+                                                                             type, cg),\n+                             __FILE__, __LINE__, NULL);\n+            break;\n \n-            TR_ASSERT(siteIndex < (int32_t) self()->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+         case TR_NoRelocation:\n+            break;\n \n-            self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation(NULL,\n-                                                                             (uint8_t *)(intptr_t)siteIndex,\n-                                                                             (uint8_t *)(*info),\n-                                                                             (*info)->_reloKind, self()),\n-                                                                             __FILE__, __LINE__, NULL);\n-            }\n+         default:\n+            TR_ASSERT(false, \"got a unknown/non-AOT guard at AOT site\");\n+            cg->comp()->failCompilation<J9::AOTRelocationRecordGenerationFailure>(\"Unknown/non-AOT guard at AOT site\");\n+            break;\n          }\n+      }\n+   }\n \n-      // If have inlined calls, now add the relocation records in descending order of inlined site index (at relocation time, the order is reverse)\n-      if (inlinedCallSize > 0)\n+static void addInliningTableRelocations(TR::CodeGenerator *cg, uint32_t inlinedCallSize, TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable)\n+   {\n+   if (inlinedCallSize > 0)\n+      {\n+      for (int32_t counter = inlinedCallSize - 1; counter >= 0 ; counter--)\n          {\n-         counter= inlinedCallSize - 1;\n-         int numSitesAdded = 0;\n-         for (; counter >= 0 ; counter--)\n+         TR_InlinedSiteLinkedListEntry *currentSite = orderedInlinedSiteListTable[counter].first;\n+         while (currentSite)\n             {\n-            TR_InlinedSiteLinkedListEntry *currentSite = orderedInlinedSiteListTable[counter].first;\n-            if (!currentSite)\n-               missedSite = counter;\n-\n-            while (currentSite)\n-               {\n-               self()->addExternalRelocation(new (self()->trHeapMemory()) TR::ExternalRelocation(currentSite->location,\n-                                                                                currentSite->destination,\n-                                                                                currentSite->guard,\n-                                                                                currentSite->reloType, self()),\n-                               __FILE__,__LINE__, NULL);\n-               currentSite = currentSite->next;\n-               numSitesAdded++;\n-               }\n+            cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(currentSite->location,\n+                                                                             currentSite->destination,\n+                                                                             currentSite->guard,\n+                                                                             currentSite->reloType, cg),\n+                            __FILE__,__LINE__, NULL);\n+            currentSite = currentSite->next;\n             }\n          }\n       }\n+   }\n+\n+void\n+J9::CodeGenerator::processRelocations()\n+   {\n+   //Project neutral non-AOT processRelocation\n+   OMR::CodeGeneratorConnector::processRelocations();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91508c2995a9eb775220cafdee46b72c0e8e8d72"}, "originalPosition": 466}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNTA1MjUzOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQyMzowNDo1OFrOIV5Q7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjozNjozN1rOIXWRUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyOTIyOA==", "bodyText": "better not have virtual methods (i'm sure it doesn't, but...)", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r559829228", "createdAt": "2021-01-18T23:04:58Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -3137,21 +3137,53 @@ static void processAOTGuardSites(TR::CodeGenerator *cg, uint32_t inlinedCallSize\n       }\n    }\n \n+static void addInlinedSiteRelocation(TR::CodeGenerator *cg,\n+                                     TR_ExternalRelocationTargetKind reloType,\n+                                     uint8_t *reloLocation,\n+                                     int32_t inlinedSiteIndex,\n+                                     TR::SymbolReference *callSymref,\n+                                     TR_OpaqueClassBlock *receiver,\n+                                     uint8_t *destinationAddress)\n+   {\n+   TR_ASSERT_FATAL(reloType != TR_NoRelocation, \"TR_NoRelocation specified as reloType for inlinedSiteIndex=%d, reloLocation=%p, callSymref=%p, receiver=%p\",\n+                   inlinedSiteIndex, reloLocation, callSymref, receiver);\n+\n+   TR_RelocationRecordInformation *info = (TR_RelocationRecordInformation *)cg->comp()->region().allocate(sizeof(TR_RelocationRecordInformation));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daddd669abc7c68f64cd9108f4a62e68239df4ec"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2NjIwOQ==", "bodyText": "you mean allocate()? It doesn't, but if it did, would it be a problem? All other parts of the code would also be using the same allocate() right?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561066209", "createdAt": "2021-01-20T15:43:51Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -3137,21 +3137,53 @@ static void processAOTGuardSites(TR::CodeGenerator *cg, uint32_t inlinedCallSize\n       }\n    }\n \n+static void addInlinedSiteRelocation(TR::CodeGenerator *cg,\n+                                     TR_ExternalRelocationTargetKind reloType,\n+                                     uint8_t *reloLocation,\n+                                     int32_t inlinedSiteIndex,\n+                                     TR::SymbolReference *callSymref,\n+                                     TR_OpaqueClassBlock *receiver,\n+                                     uint8_t *destinationAddress)\n+   {\n+   TR_ASSERT_FATAL(reloType != TR_NoRelocation, \"TR_NoRelocation specified as reloType for inlinedSiteIndex=%d, reloLocation=%p, callSymref=%p, receiver=%p\",\n+                   inlinedSiteIndex, reloLocation, callSymref, receiver);\n+\n+   TR_RelocationRecordInformation *info = (TR_RelocationRecordInformation *)cg->comp()->region().allocate(sizeof(TR_RelocationRecordInformation));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyOTIyOA=="}, "originalCommit": {"oid": "daddd669abc7c68f64cd9108f4a62e68239df4ec"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM1MzA0MA==", "bodyText": "i meant TR_RelocationRecordInformation. Wouldn't it be better to initialize this structure with a placement new, which would also have the benefit of initializing any vft needed? I'm not that concerned about it, but it's not a completely outrageous evolution someone could dream up :) .", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561353040", "createdAt": "2021-01-20T22:36:37Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -3137,21 +3137,53 @@ static void processAOTGuardSites(TR::CodeGenerator *cg, uint32_t inlinedCallSize\n       }\n    }\n \n+static void addInlinedSiteRelocation(TR::CodeGenerator *cg,\n+                                     TR_ExternalRelocationTargetKind reloType,\n+                                     uint8_t *reloLocation,\n+                                     int32_t inlinedSiteIndex,\n+                                     TR::SymbolReference *callSymref,\n+                                     TR_OpaqueClassBlock *receiver,\n+                                     uint8_t *destinationAddress)\n+   {\n+   TR_ASSERT_FATAL(reloType != TR_NoRelocation, \"TR_NoRelocation specified as reloType for inlinedSiteIndex=%d, reloLocation=%p, callSymref=%p, receiver=%p\",\n+                   inlinedSiteIndex, reloLocation, callSymref, receiver);\n+\n+   TR_RelocationRecordInformation *info = (TR_RelocationRecordInformation *)cg->comp()->region().allocate(sizeof(TR_RelocationRecordInformation));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyOTIyOA=="}, "originalCommit": {"oid": "daddd669abc7c68f64cd9108f4a62e68239df4ec"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzMzQ1NjMyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/RelocationRecord.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNzowMzoyOVrOIXIkfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNzowMzoyOVrOIXIkfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTEyODU3Mg==", "bodyText": "We were never calling TR_RelocationRecordInlinedVirtualMethod::getMethodFromCP when the relo kind was TR_InlinedVirtualMethod because this virtual method was missing the TR_OpaqueMethodBlock *callerMethod param; TR_RelocationRecordInlinedMethod::getMethodFromCP ended up getting called, which would just cause a load failure...", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561128572", "createdAt": "2021-01-20T17:03:29Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/runtime/RelocationRecord.cpp", "diffHunk": "@@ -2973,20 +3009,8 @@ TR_RelocationRecordInlinedVirtualMethod::name()\n    return \"TR_InlinedVirtualMethod\";\n    }\n \n-void\n-TR_RelocationRecordInlinedVirtualMethod::print(TR_RelocationRuntime *reloRuntime)\n-   {\n-   Base::print(reloRuntime);\n-   }\n-\n-void\n-TR_RelocationRecordInlinedVirtualMethod::preparePrivateData(TR_RelocationRuntime *reloRuntime, TR_RelocationTarget *reloTarget)\n-   {\n-   Base::preparePrivateData(reloRuntime, reloTarget);\n-   }\n-\n TR_OpaqueMethodBlock *\n-TR_RelocationRecordInlinedVirtualMethod::getMethodFromCP(TR_RelocationRuntime *reloRuntime, void *void_cp, int32_t cpIndex)\n+TR_RelocationRecordInlinedVirtualMethod::getMethodFromCP(TR_RelocationRuntime *reloRuntime, void *void_cp, int32_t cpIndex, TR_OpaqueMethodBlock *callerMethod)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb5edf98728d6f7bac9013810e2efc2711969cc9"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzNDc5MTk4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/RelocationRecord.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjoxNjo0MFrOIXVrew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjoxNjo0MFrOIXVrew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0MzM1NQ==", "bodyText": "do you still need this typedef?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561343355", "createdAt": "2021-01-20T22:16:40Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/runtime/RelocationRecord.hpp", "diffHunk": "@@ -808,6 +808,17 @@ class TR_RelocationRecordInlinedStaticMethodWithNopGuard : public TR_RelocationR\n       virtual void updateSucceededStats(TR_AOTStats *aotStats);\n    };\n \n+class TR_RelocationRecordInlinedStaticMethod: public TR_RelocationRecordInlinedMethod\n+   {\n+   typedef TR_RelocationRecordInlinedMethod Base;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6133fe4ea478b87b12b485ba2e1e204be566a5c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzNDc5MzkyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/RelocationRecord.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjoxNzoxMlrOIXVsmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjoxNzoxMlrOIXVsmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0MzY0MA==", "bodyText": "do you still need this typedef?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561343640", "createdAt": "2021-01-20T22:17:12Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/runtime/RelocationRecord.hpp", "diffHunk": "@@ -890,6 +908,17 @@ class TR_RelocationRecordInlinedAbstractMethodWithNopGuard : public TR_Relocatio\n       virtual void createAssumptions(TR_RelocationRuntime *reloRuntime, uint8_t *reloLocation);\n    };\n \n+class TR_RelocationRecordInlinedAbstractMethod: public TR_RelocationRecordInlinedMethod\n+   {\n+   typedef TR_RelocationRecordInlinedMethod Base;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6133fe4ea478b87b12b485ba2e1e204be566a5c"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzNDgyMDM2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjoyNTo1MVrOIXV8SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxNTo0NzozM1rOIX89Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0NzY1Ng==", "bodyText": "by your earlier logic, wouldn't this list be empty if not using SVM?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561347656", "createdAt": "2021-01-20T22:25:51Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,308 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n \n-   //Project neutral non-AOT processRelocation\n-   OMR::CodeGeneratorConnector::processRelocations();\n+   TR::list<TR::AOTClassInfo*>* classInfo = cg->comp()->_aotClassInfo;\n+   if (!classInfo->empty())\n+      {\n+      for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         {\n+         traceMsg(cg->comp(), \"processing AOT class info: %p in %s\\n\", *info, cg->comp()->signature());\n+         traceMsg(cg->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n+         traceMsg(cg->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n \n-   int32_t missedSite = -1;\n+         TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n \n-   if (self()->comp()->compileRelocatableCode())\n-      {\n-      uint32_t inlinedCallSize = self()->comp()->getNumInlinedCallSites();\n+         int32_t siteIndex = -1;\n \n-      // Create temporary hashtable for ordering AOT guard relocations\n-      int32_t counter = inlinedCallSize;\n-      TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable;\n-      if (inlinedCallSize > 0)\n-         {\n-         orderedInlinedSiteListTable= (TR_InlinedSiteHastTableEntry*)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteHastTableEntry) * inlinedCallSize, heapAlloc);\n-         memset(orderedInlinedSiteListTable, 0, sizeof(TR_InlinedSiteHastTableEntry)*inlinedCallSize);\n+         if (ramMethod != cg->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            {\n+            int32_t i;\n+            for (i = 0; i < cg->comp()->getNumInlinedCallSites(); i++)\n+               {\n+               TR_InlinedCallSite &ics = cg->comp()->getInlinedCallSite(i);\n+               TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n+\n+               traceMsg(cg->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n+               if (ramMethod == inlinedMethod)\n+                  {\n+                  traceMsg(cg->comp(), \"\\t\\tmatch!\\n\");\n+                  siteIndex = i;\n+                  break;\n+                  }\n+               }\n+\n+            if (i >= (int32_t) cg->comp()->getNumInlinedCallSites())\n+               {\n+               // this assumption isn't associated with a method directly in the compilation\n+               // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n+               // kind of overkill for TR_ValidateStaticField, but still correct\n+               (*info)->_reloKind = TR_ValidateArbitraryClass;\n+               siteIndex = -1;   // invalidate main compiled method\n+               traceMsg(cg->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n+               }\n+            }\n+\n+         traceMsg(cg->comp(), \"Found inlined site %d\\n\", siteIndex);\n+\n+         TR_ASSERT(siteIndex < (int32_t) cg->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(intptr_t)siteIndex,\n+                                                                          (uint8_t *)(*info),\n+                                                                          (*info)->_reloKind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n          }\n-      else\n-         orderedInlinedSiteListTable = NULL;\n+      }\n+   }\n \n-      TR_InlinedSiteLinkedListEntry *entry = NULL;\n+static void addSVMValidationRecords(TR::CodeGenerator *cg)\n+   {\n+   TR::SymbolValidationManager::SymbolValidationRecordList &validationRecords = cg->comp()->getSymbolValidationManager()->getValidationRecordList();\n+   if (cg->comp()->getOption(TR_UseSymbolValidationManager))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78dd9660c0fb96f73cb7707c0472c914eb839753"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTk4NjgzMA==", "bodyText": "Yeah, same idea. However, the reason why they're two different functions is because the traditional validation records are added after relo records but before the inlining table records, whereas the SVM records are added after the inlining table records.", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561986830", "createdAt": "2021-01-21T15:47:33Z", "author": {"login": "dsouzai"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -2904,281 +2904,308 @@ J9::CodeGenerator::populateOSRBuffer()\n    self()->comp()->getOSRCompilationData()->setMaxScratchBufferSize(maxScratchBufferSize);\n    }\n \n-\n-void\n-J9::CodeGenerator::processRelocations()\n+static void addValidationRecords(TR::CodeGenerator *cg)\n    {\n-   TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n+   TR_J9VMBase *fej9 = (TR_J9VMBase *)(cg->comp()->fe());\n \n-   //Project neutral non-AOT processRelocation\n-   OMR::CodeGeneratorConnector::processRelocations();\n+   TR::list<TR::AOTClassInfo*>* classInfo = cg->comp()->_aotClassInfo;\n+   if (!classInfo->empty())\n+      {\n+      for (auto info = classInfo->begin(); info != classInfo->end(); ++info)\n+         {\n+         traceMsg(cg->comp(), \"processing AOT class info: %p in %s\\n\", *info, cg->comp()->signature());\n+         traceMsg(cg->comp(), \"ramMethod: %p cp: %p cpIndex: %x relo %d\\n\", (*info)->_method, (*info)->_constantPool, (*info)->_cpIndex, (*info)->_reloKind);\n+         traceMsg(cg->comp(), \"clazz: %p classChain: %p\\n\", (*info)->_clazz, (*info)->_classChain);\n \n-   int32_t missedSite = -1;\n+         TR_OpaqueMethodBlock *ramMethod = (*info)->_method;\n \n-   if (self()->comp()->compileRelocatableCode())\n-      {\n-      uint32_t inlinedCallSize = self()->comp()->getNumInlinedCallSites();\n+         int32_t siteIndex = -1;\n \n-      // Create temporary hashtable for ordering AOT guard relocations\n-      int32_t counter = inlinedCallSize;\n-      TR_InlinedSiteHastTableEntry *orderedInlinedSiteListTable;\n-      if (inlinedCallSize > 0)\n-         {\n-         orderedInlinedSiteListTable= (TR_InlinedSiteHastTableEntry*)self()->comp()->trMemory()->allocateMemory(sizeof(TR_InlinedSiteHastTableEntry) * inlinedCallSize, heapAlloc);\n-         memset(orderedInlinedSiteListTable, 0, sizeof(TR_InlinedSiteHastTableEntry)*inlinedCallSize);\n+         if (ramMethod != cg->comp()->getCurrentMethod()->getPersistentIdentifier()) // && info->_reloKind != TR_ValidateArbitraryClass)\n+            {\n+            int32_t i;\n+            for (i = 0; i < cg->comp()->getNumInlinedCallSites(); i++)\n+               {\n+               TR_InlinedCallSite &ics = cg->comp()->getInlinedCallSite(i);\n+               TR_OpaqueMethodBlock *inlinedMethod = fej9->getInlinedCallSiteMethod(&ics);\n+\n+               traceMsg(cg->comp(), \"\\tinline site %d inlined method %p\\n\", i, inlinedMethod);\n+               if (ramMethod == inlinedMethod)\n+                  {\n+                  traceMsg(cg->comp(), \"\\t\\tmatch!\\n\");\n+                  siteIndex = i;\n+                  break;\n+                  }\n+               }\n+\n+            if (i >= (int32_t) cg->comp()->getNumInlinedCallSites())\n+               {\n+               // this assumption isn't associated with a method directly in the compilation\n+               // so we can't use a constant pool approach to validate: transform into TR_ValidateArbitraryClass\n+               // kind of overkill for TR_ValidateStaticField, but still correct\n+               (*info)->_reloKind = TR_ValidateArbitraryClass;\n+               siteIndex = -1;   // invalidate main compiled method\n+               traceMsg(cg->comp(), \"\\ttransformed into TR_ValidateArbitraryClass\\n\");\n+               }\n+            }\n+\n+         traceMsg(cg->comp(), \"Found inlined site %d\\n\", siteIndex);\n+\n+         TR_ASSERT(siteIndex < (int32_t) cg->comp()->getNumInlinedCallSites(), \"did not find AOTClassInfo %p method in inlined site table\", *info);\n+\n+         cg->addExternalRelocation(new (cg->trHeapMemory()) TR::ExternalRelocation(NULL,\n+                                                                          (uint8_t *)(intptr_t)siteIndex,\n+                                                                          (uint8_t *)(*info),\n+                                                                          (*info)->_reloKind, cg),\n+                                                                          __FILE__, __LINE__, NULL);\n          }\n-      else\n-         orderedInlinedSiteListTable = NULL;\n+      }\n+   }\n \n-      TR_InlinedSiteLinkedListEntry *entry = NULL;\n+static void addSVMValidationRecords(TR::CodeGenerator *cg)\n+   {\n+   TR::SymbolValidationManager::SymbolValidationRecordList &validationRecords = cg->comp()->getSymbolValidationManager()->getValidationRecordList();\n+   if (cg->comp()->getOption(TR_UseSymbolValidationManager))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0NzY1Ng=="}, "originalCommit": {"oid": "78dd9660c0fb96f73cb7707c0472c914eb839753"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzNDg1ODE0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/runtime/RelocationRecord.hpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjozNzowMVrOIXWR5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjozNzowMVrOIXWR5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM1MzE4OQ==", "bodyText": "do you still need this typedef?", "url": "https://github.com/eclipse-openj9/openj9/pull/11552#discussion_r561353189", "createdAt": "2021-01-20T22:37:01Z", "author": {"login": "mstoodle"}, "path": "runtime/compiler/runtime/RelocationRecord.hpp", "diffHunk": "@@ -822,6 +833,17 @@ class TR_RelocationRecordInlinedSpecialMethodWithNopGuard : public TR_Relocation\n       virtual void updateSucceededStats(TR_AOTStats *aotStats);\n    };\n \n+class TR_RelocationRecordInlinedSpecialMethod: public TR_RelocationRecordInlinedMethod\n+   {\n+   typedef TR_RelocationRecordInlinedMethod Base;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6133fe4ea478b87b12b485ba2e1e204be566a5c"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 814, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}