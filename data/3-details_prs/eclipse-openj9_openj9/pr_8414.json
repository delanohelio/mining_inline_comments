{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3MzIyOTU2", "number": 8414, "title": "JEP-370 Implementation (Part 2)", "bodyText": "Related: #8292.\nThis pull request has commits from and is dependent on #8330 and #8369.\nThe top seven commits are new, and they are described below. Files changed will show all the commits. So, individually refer to the new commits in order to review the changes specific to this pull request.\n1. Implement LambdaForm.BasicType.basicType(Class<?> cls)\nBasicType.basicType takes a class as input and outputs the corresponding\nBasicType enum value depending on the class's basic type char. The\nclass's basic type char is derived using the sun.invoke.util.Wrapper\nclass.\n2. Implement the constructor MemberName(Method method)\nThe method passed in the constructor, MemberName(Method method), is\ncached in the MemberName instance.\n3. Initialize AccessMode.methodNameToAccessMode (HashMap)\nAccessMode.methodNameToAccessMode is a HashMap<String, AccessMode>,\nwhere the key is the method name and the value is the AccessMode enum\nvalue. This hashmap is used in AccessMode.valueFromMethodName to\nretrieve the AccessMode enum value for the corresponding method name. It\nis also directly accessed from VarForm.linkFromStatic. It is needed so\nthat OpenJ9 can consume OpenJDK's VarForm class.\n4. Implement constructor VarHandle(VarForm varForm)\nIn this constructor, fieldType, coordinateTypes, handleTable and\nmodifiers are initialized using the VarForm class. This should allow us\nto consume OpenJDK's VarHandles with OpenJ9's VarHandle class as the\nbase class. Currently, it will only be used for OpenJDK's MemoryAddress\nVarHandles.\n5. Handle conversion from OpenJDK to OpenJ9 VarHandle operation methods\nOpenJDK VarHandle operation methods have the following parameter\nsequence: {VarHandle, Receiver, Intermediate ..., Value}.\nDuring invocation, OpenJ9 uses the following parameter sequence for the\nVarHandle operations: {Receiver, Intermediate ..., Value, VarHandle}.\nThe location of the VarHandle argument is different in the above two\ncases. MethodHandles.permuteArguments is used to translate from the\nOpenJ9 to OpenJDK invocation.\n6. Implement VarHandle.AccessType.accessModeType\nAccessType.accessModeType is implemented to retrieve the receiver class\nfrom the derived VarHandle class since VarForm does not provide the\nexact receiver class. In VarForm, the receiver class is always\njava.lang.Object.\n7. Initialize VarHandle.handleTable with exact method types\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\nSigned-off-by: Babneet Singh sbabneet@ca.ibm.com", "createdAt": "2020-01-27T05:50:21Z", "url": "https://github.com/eclipse-openj9/openj9/pull/8414", "merged": true, "mergeCommit": {"oid": "feecd8ca83dd8a65754739c4930e9f5574caceff"}, "closed": true, "closedAt": "2020-02-13T20:00:19Z", "author": {"login": "babsingh"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-W38XgBqjI5ODA2NTAzNjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcD7-jrgFqTM1ODI2NzQ5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb67385de0ba4c6f86ede9070431b1a0fdd7451a", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/fb67385de0ba4c6f86ede9070431b1a0fdd7451a", "committedDate": "2020-01-27T05:39:10Z", "message": "Handle the difference in MemoryAddress VarHandles operations class\n\nVarHandle operations class:\nOpenJ9 - AccessMode.method(Receiver, args ..., VarHandle)\nOpenJDK - AccessMode.method(VarHandle, Receiver, args ...)\n\nThe location of VarHandle varies in the two implementations. OpenJ9 has\nVarHandle as the last argument whereas OpenJDK has VarHandle as the\nfirst argument.\n\nMethods accessModeType and toMethodHandle are updated to handle both\nscenarios.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "7252558ffcea34df62dbfb45294fa86c68e2b211", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7252558ffcea34df62dbfb45294fa86c68e2b211", "committedDate": "2020-01-27T06:36:55Z", "message": "Handle the difference in MemoryAddress VarHandles operations class\n\nVarHandle operations class:\nOpenJ9 - AccessMode.method(Receiver, args ..., VarHandle)\nOpenJDK - AccessMode.method(VarHandle, Receiver, args ...)\n\nThe location of VarHandle varies in the two implementations. OpenJ9 has\nVarHandle as the last argument whereas OpenJDK has VarHandle as the\nfirst argument.\n\nMethods accessModeType and toMethodHandle are updated to handle both\nscenarios.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7252558ffcea34df62dbfb45294fa86c68e2b211", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7252558ffcea34df62dbfb45294fa86c68e2b211", "committedDate": "2020-01-27T06:36:55Z", "message": "Handle the difference in MemoryAddress VarHandles operations class\n\nVarHandle operations class:\nOpenJ9 - AccessMode.method(Receiver, args ..., VarHandle)\nOpenJDK - AccessMode.method(VarHandle, Receiver, args ...)\n\nThe location of VarHandle varies in the two implementations. OpenJ9 has\nVarHandle as the last argument whereas OpenJDK has VarHandle as the\nfirst argument.\n\nMethods accessModeType and toMethodHandle are updated to handle both\nscenarios.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "19f5fe28aa7d31cd4bfa5262b5447f407380d6e6", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/19f5fe28aa7d31cd4bfa5262b5447f407380d6e6", "committedDate": "2020-01-28T14:52:47Z", "message": "Handle conversion from OpenJDK to OpenJ9 VarHandle operation methods\n\nOpenJDK VarHandle operation methods have the following parameter\nsequence: {VarHandle, Receiver, Intermediate ..., Value}.\n\nDuring invocation, OpenJ9 uses the following parameter sequence for the\nVarHandle operations: {Receiver, Intermediate ..., Value, VarHandle}.\n\nThe location of the VarHandle argument is different in the above two\ncases. MethodHandles.permuteArguments is used to translate from the\nOpenJ9 to OpenJDK invocation.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "19f5fe28aa7d31cd4bfa5262b5447f407380d6e6", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/19f5fe28aa7d31cd4bfa5262b5447f407380d6e6", "committedDate": "2020-01-28T14:52:47Z", "message": "Handle conversion from OpenJDK to OpenJ9 VarHandle operation methods\n\nOpenJDK VarHandle operation methods have the following parameter\nsequence: {VarHandle, Receiver, Intermediate ..., Value}.\n\nDuring invocation, OpenJ9 uses the following parameter sequence for the\nVarHandle operations: {Receiver, Intermediate ..., Value, VarHandle}.\n\nThe location of the VarHandle argument is different in the above two\ncases. MethodHandles.permuteArguments is used to translate from the\nOpenJ9 to OpenJDK invocation.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "8f4d3ac23deee5a56fe66c25559168cb6c21ec39", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8f4d3ac23deee5a56fe66c25559168cb6c21ec39", "committedDate": "2020-01-28T15:17:11Z", "message": "Handle conversion from OpenJDK to OpenJ9 VarHandle operation methods\n\nOpenJDK VarHandle operation methods have the following parameter\nsequence: {VarHandle, Receiver, Intermediate ..., Value}.\n\nDuring invocation, OpenJ9 uses the following parameter sequence for the\nVarHandle operations: {Receiver, Intermediate ..., Value, VarHandle}.\n\nThe location of the VarHandle argument is different in the above two\ncases. MethodHandles.permuteArguments is used to translate from the\nOpenJ9 to OpenJDK invocation.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f4d3ac23deee5a56fe66c25559168cb6c21ec39", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8f4d3ac23deee5a56fe66c25559168cb6c21ec39", "committedDate": "2020-01-28T15:17:11Z", "message": "Handle conversion from OpenJDK to OpenJ9 VarHandle operation methods\n\nOpenJDK VarHandle operation methods have the following parameter\nsequence: {VarHandle, Receiver, Intermediate ..., Value}.\n\nDuring invocation, OpenJ9 uses the following parameter sequence for the\nVarHandle operations: {Receiver, Intermediate ..., Value, VarHandle}.\n\nThe location of the VarHandle argument is different in the above two\ncases. MethodHandles.permuteArguments is used to translate from the\nOpenJ9 to OpenJDK invocation.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "78a8f153c29d459723805e32a24675b834f10d32", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/78a8f153c29d459723805e32a24675b834f10d32", "committedDate": "2020-01-30T14:27:28Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "78a8f153c29d459723805e32a24675b834f10d32", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/78a8f153c29d459723805e32a24675b834f10d32", "committedDate": "2020-01-30T14:27:28Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "fe3507ecef6e9b968ee9d2ed5c4d20d0d3e03c6f", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/fe3507ecef6e9b968ee9d2ed5c4d20d0d3e03c6f", "committedDate": "2020-01-30T14:34:32Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fe3507ecef6e9b968ee9d2ed5c4d20d0d3e03c6f", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/fe3507ecef6e9b968ee9d2ed5c4d20d0d3e03c6f", "committedDate": "2020-01-30T14:34:32Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f5978d5d20bedb88ca150558722bbb4556f59909", "committedDate": "2020-02-05T01:01:52Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMDQ5MzUx", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#pullrequestreview-353049351", "createdAt": "2020-02-04T15:07:29Z", "commit": {"oid": "fe3507ecef6e9b968ee9d2ed5c4d20d0d3e03c6f"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNTowNzoyOVrOFlXeQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzowMDoxMVrOFl_nyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyNjIwOQ==", "bodyText": "This feels like it's missing some cases.  The basicType() api should be total for all types - Either one of the primitive ones or L_TYPE", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r374726209", "createdAt": "2020-02-04T15:07:29Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java", "diffHunk": "@@ -108,10 +109,36 @@ MethodHandle resolve() {\n \t}\n \t\n \tenum BasicType {\n-\t\tL_TYPE;\n-\t\t\n+\t\tL_TYPE,\n+\t\tI_TYPE,\n+\t\tJ_TYPE,\n+\t\tF_TYPE,\n+\t\tD_TYPE,\n+\t\tV_TYPE;\n+\n \t\tstatic BasicType basicType(Class<?> cls) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t\tWrapper wrapper = Wrapper.forPrimitiveType(cls);\n+\t\t\tBasicType basicType = null;\n+\t\t\tif (wrapper != null) {\n+\t\t\t\tchar basicTypeChar = wrapper.basicTypeChar();\n+\t\t\t\tif (basicTypeChar == 'L') {\n+\t\t\t\t\tbasicType = L_TYPE;\n+\t\t\t\t} else if ((basicTypeChar == 'C') || (basicTypeChar == 'B') || (basicTypeChar == 'Z')\n+\t\t\t\t\t\t|| (basicTypeChar == 'I') || (basicTypeChar == 'S')) {\n+\t\t\t\t\tbasicType = I_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'J') {\n+\t\t\t\t\tbasicType = J_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'F') {\n+\t\t\t\t\tbasicType = F_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'D') {\n+\t\t\t\t\tbasicType = D_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'V') {\n+\t\t\t\t\tbasicType = V_TYPE;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown basic type char: \" + basicTypeChar);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn basicType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe3507ecef6e9b968ee9d2ed5c4d20d0d3e03c6f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3MjkyOQ==", "bodyText": "Having called Wrapper.forPrimitiveType(cls), it should never be possible to get L_Type here", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375372929", "createdAt": "2020-02-05T16:41:40Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java", "diffHunk": "@@ -108,10 +109,36 @@ MethodHandle resolve() {\n \t}\n \t\n \tenum BasicType {\n-\t\tL_TYPE;\n-\t\t\n+\t\tL_TYPE,\n+\t\tI_TYPE,\n+\t\tJ_TYPE,\n+\t\tF_TYPE,\n+\t\tD_TYPE,\n+\t\tV_TYPE;\n+\n \t\tstatic BasicType basicType(Class<?> cls) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t\tWrapper wrapper = Wrapper.forPrimitiveType(cls);\n+\t\t\tBasicType basicType = null;\n+\t\t\tif (wrapper != null) {\n+\t\t\t\tchar basicTypeChar = wrapper.basicTypeChar();\n+\t\t\t\tif (basicTypeChar == 'L') {\n+\t\t\t\t\tbasicType = L_TYPE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3Mzg0MQ==", "bodyText": "Can you move these closer to their first use?", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375373841", "createdAt": "2020-02-05T16:43:13Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3NDg5Nw==", "bodyText": "Can you move the declarations of operationMTs & operationMTsExact closer to this code?", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375374897", "createdAt": "2020-02-05T16:45:01Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;\n+\t\t\n+\t\tClass<?> operationsClass = null;\n+\t\t\n+\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n+\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n+\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n+\t\t\n+\t\t/* Specify the exact operation method types if the actual receiver doesn't match the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MDQ1NQ==", "bodyText": "Is any of this data already available on the VarForm?", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375380455", "createdAt": "2020-02-05T16:54:22Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;\n+\t\t\n+\t\tClass<?> operationsClass = null;\n+\t\t\n+\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n+\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n+\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n+\t\t\n+\t\t/* Specify the exact operation method types if the actual receiver doesn't match the\n+\t\t * receiver derived from VarForm.\n+\t\t */\n+\t\tif (receiverActual != receiverVarForm) {\n+\t\t\toperationMTsExact = new MethodType[numAccessModes];\n+\t\t}\n+\t\t\n+\t\tfor (int i = 0; i < numAccessModes; i++) {\n+\t\t\tMemberName memberName = varForm.memberName_table[i];\n+\t\t\tif (memberName != null) {\n+\t\t\t\tMethod method = memberName.method;\n+\t\t\t\tif (method != null) {\n+\t\t\t\t\toperationMTs[i] = MethodType.methodType(method.getReturnType(), method.getParameterTypes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MjE3OQ==", "bodyText": "Needs a null check to ensure the memory is successfully allocated", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375382179", "createdAt": "2020-02-05T16:57:13Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4Mjc1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\titem = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);\n          \n          \n            \n            \t\t\tj9object_t item = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);\n          \n      \n    \n    \n  \n\nMove the declaration to here", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375382758", "createdAt": "2020-02-05T16:58:09Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);\n+\t\t}\n+\t}\n+\n \tvmFuncs->internalExitVMToJNI(currentThread);\n \n \tjsize length = env->GetArrayLength(bytecodes);\n \n \t/* acquires access internally */\n-\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz);\n+\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz, &cpPatchMap);\n \tif (env->ExceptionCheck()) {\n \t\treturn NULL;\n \t} else if (NULL == anonClass) {\n \t\tthrowNewInternalError(env, NULL);\n \t\treturn NULL;\n \t}\n \n+\tif (constPatches != NULL) {\n+\t\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\t\tJ9Class *clazz = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, J9_JNI_UNWRAP_REFERENCE(anonClass));\n+\n+\t\tj9object_t item = NULL;\n+\t\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(clazz->romClass);\n+\t\tJ9ConstantPool *ramCP = J9_CP_FROM_CLASS(clazz);\n+\t\tJ9ROMConstantPoolItem *romCP = ramCP->romConstantPool;\n+\n+\t\tfor (U_16 i = 0; i < cpPatchMap.size; i++) {\n+\t\t\titem = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MzYyMg==", "bodyText": "Can you add a comment explaining why this is walking the whole CP?  I know the reason now but won't remember by the next time I look at the code...", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375383622", "createdAt": "2020-02-05T16:59:29Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);\n+\t\t}\n+\t}\n+\n \tvmFuncs->internalExitVMToJNI(currentThread);\n \n \tjsize length = env->GetArrayLength(bytecodes);\n \n \t/* acquires access internally */\n-\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz);\n+\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz, &cpPatchMap);\n \tif (env->ExceptionCheck()) {\n \t\treturn NULL;\n \t} else if (NULL == anonClass) {\n \t\tthrowNewInternalError(env, NULL);\n \t\treturn NULL;\n \t}\n \n+\tif (constPatches != NULL) {\n+\t\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\t\tJ9Class *clazz = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, J9_JNI_UNWRAP_REFERENCE(anonClass));\n+\n+\t\tj9object_t item = NULL;\n+\t\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(clazz->romClass);\n+\t\tJ9ConstantPool *ramCP = J9_CP_FROM_CLASS(clazz);\n+\t\tJ9ROMConstantPoolItem *romCP = ramCP->romConstantPool;\n+\n+\t\tfor (U_16 i = 0; i < cpPatchMap.size; i++) {\n+\t\t\titem = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);\n+\t\t\tif ((item != NULL) && (J9_CP_TYPE(cpShapeDescription, cpPatchMap.indexMap[i]) == J9CPTYPE_STRING)) {\n+\t\t\t\tJ9UTF8 *romString = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&romCP[cpPatchMap.indexMap[i]]);\n+\n+\t\t\t\tfor (U_16 j = 1; j < clazz->romClass->ramConstantPoolCount; j++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4NDAwOQ==", "bodyText": "Good practice to immediately cpPatchMap.indexMap = NULL here", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375384009", "createdAt": "2020-02-05T17:00:11Z", "author": {"login": "DanHeidinga"}, "path": "runtime/jcl/common/sun_misc_Unsafe.cpp", "diffHunk": "@@ -96,19 +95,66 @@ Java_sun_misc_Unsafe_defineAnonymousClass(JNIEnv *env, jobject receiver, jclass\n \t\thostClassLoader = vm->systemClassLoader->classLoaderObject;\n \t}\n \tjobject hostClassLoaderLocalRef = vmFuncs->j9jni_createLocalRef(env, hostClassLoader);\n+\n+\tJ9ClassPatchMap cpPatchMap = {0, NULL};\n+\tj9array_t patchArray = NULL;\n+\tPORT_ACCESS_FROM_ENV(env);\n+\n+\tU_16 indexMap[BUFFER_SIZE];\n+\tif (constPatches != NULL) {\n+\t\tpatchArray = (j9array_t)J9_JNI_UNWRAP_REFERENCE(constPatches);\n+\t\tcpPatchMap.size = (U_16)J9INDEXABLEOBJECT_SIZE(currentThread, patchArray);\n+\t\tif (cpPatchMap.size <= BUFFER_SIZE) {\n+\t\t\tcpPatchMap.indexMap = indexMap;\n+\t\t} else {\n+\t\t\tcpPatchMap.indexMap = (U_16 *)j9mem_allocate_memory(cpPatchMap.size * sizeof(U_16), J9MEM_CATEGORY_VM);\n+\t\t}\n+\t}\n+\n \tvmFuncs->internalExitVMToJNI(currentThread);\n \n \tjsize length = env->GetArrayLength(bytecodes);\n \n \t/* acquires access internally */\n-\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz);\n+\tjclass anonClass = defineClassCommon(env, hostClassLoaderLocalRef, NULL,bytecodes, 0, length, protectionDomainLocalRef, J9_FINDCLASS_FLAG_UNSAFE | J9_FINDCLASS_FLAG_ANON, hostClazz, &cpPatchMap);\n \tif (env->ExceptionCheck()) {\n \t\treturn NULL;\n \t} else if (NULL == anonClass) {\n \t\tthrowNewInternalError(env, NULL);\n \t\treturn NULL;\n \t}\n \n+\tif (constPatches != NULL) {\n+\t\tvmFuncs->internalEnterVMFromJNI(currentThread);\n+\t\tJ9Class *clazz = J9VM_J9CLASS_FROM_HEAPCLASS(currentThread, J9_JNI_UNWRAP_REFERENCE(anonClass));\n+\n+\t\tj9object_t item = NULL;\n+\t\tU_32 *cpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(clazz->romClass);\n+\t\tJ9ConstantPool *ramCP = J9_CP_FROM_CLASS(clazz);\n+\t\tJ9ROMConstantPoolItem *romCP = ramCP->romConstantPool;\n+\n+\t\tfor (U_16 i = 0; i < cpPatchMap.size; i++) {\n+\t\t\titem = J9JAVAARRAYOFOBJECT_LOAD(currentThread, patchArray, i);\n+\t\t\tif ((item != NULL) && (J9_CP_TYPE(cpShapeDescription, cpPatchMap.indexMap[i]) == J9CPTYPE_STRING)) {\n+\t\t\t\tJ9UTF8 *romString = J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&romCP[cpPatchMap.indexMap[i]]);\n+\n+\t\t\t\tfor (U_16 j = 1; j < clazz->romClass->ramConstantPoolCount; j++) {\n+\t\t\t\t\tif ((J9_CP_TYPE(cpShapeDescription, j) == J9CPTYPE_STRING)\n+\t\t\t\t\t\t&& J9UTF8_EQUALS(romString, J9ROMSTRINGREF_UTF8DATA((J9ROMStringRef *)&romCP[j]))\n+\t\t\t\t\t) {\n+\t\t\t\t\t\tJ9RAMStringRef *ramStringRef = ((J9RAMStringRef *)ramCP) + j;\n+\t\t\t\t\t\tJ9STATIC_OBJECT_STORE(currentThread, clazz, &ramStringRef->stringObject, item);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (cpPatchMap.size > BUFFER_SIZE) {\n+\t\t\tj9mem_free_memory(cpPatchMap.indexMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909"}, "originalPosition": 95}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f5978d5d20bedb88ca150558722bbb4556f59909", "committedDate": "2020-02-05T01:01:52Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "8084315b21ce2eec06c4ec8228a9bc5a806e97e2", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8084315b21ce2eec06c4ec8228a9bc5a806e97e2", "committedDate": "2020-02-05T20:08:22Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8084315b21ce2eec06c4ec8228a9bc5a806e97e2", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8084315b21ce2eec06c4ec8228a9bc5a806e97e2", "committedDate": "2020-02-05T20:08:22Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "75a8afbb05b6932055230d2592baf0f98c58c025", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/75a8afbb05b6932055230d2592baf0f98c58c025", "committedDate": "2020-02-05T20:13:00Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c40670fdbac6e3753c33258f4c283554637d36d7", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/c40670fdbac6e3753c33258f4c283554637d36d7", "committedDate": "2020-02-09T03:08:45Z", "message": "Implement LambdaForm.BasicType.basicType(Class<?> cls)\n\nBasicType.basicType takes a class as input and outputs the corresponding\nBasicType enum value depending on the class's basic type char. The\nclass's basic type char is derived using the sun.invoke.util.Wrapper\nclass.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9279dab3189d2d46d5333edaf0499cf13450691", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/f9279dab3189d2d46d5333edaf0499cf13450691", "committedDate": "2020-02-09T03:08:45Z", "message": "Implement the constructor MemberName(Method method)\n\nThe method passed in the constructor, MemberName(Method method), is\ncached in the MemberName instance.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e93a03359c07bfe1f41caab2e8db5bce7de614c", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/8e93a03359c07bfe1f41caab2e8db5bce7de614c", "committedDate": "2020-02-09T03:08:45Z", "message": "Initialize AccessMode.methodNameToAccessMode (HashMap)\n\nAccessMode.methodNameToAccessMode is a HashMap<String, AccessMode>,\nwhere the key is the method name and the value is the AccessMode enum\nvalue. This hashmap is used in AccessMode.valueFromMethodName to\nretrieve the AccessMode enum value for the corresponding method name. It\nis also directly accessed from VarForm.linkFromStatic. It is needed so\nthat OpenJ9 can consume OpenJDK's VarForm class.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "75a8afbb05b6932055230d2592baf0f98c58c025", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/75a8afbb05b6932055230d2592baf0f98c58c025", "committedDate": "2020-02-05T20:13:00Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "2635bb540f6db2b30c906bb71bc826d766785261", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2635bb540f6db2b30c906bb71bc826d766785261", "committedDate": "2020-02-09T03:08:45Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37039483a3723441371bc6b881b3112e7e9cd11c", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/37039483a3723441371bc6b881b3112e7e9cd11c", "committedDate": "2020-02-09T03:14:59Z", "message": "Implement constructor VarHandle(VarForm varForm)\n\nIn this constructor, fieldType, coordinateTypes, handleTable and\nmodifiers are initialized using the VarForm class. This should allow us\nto consume OpenJDK's VarHandles with OpenJ9's VarHandle class as the\nbase class. Currently, it will only be used for OpenJDK's MemoryAddress\nVarHandles.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2635bb540f6db2b30c906bb71bc826d766785261", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2635bb540f6db2b30c906bb71bc826d766785261", "committedDate": "2020-02-09T03:08:45Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "28cbd710153191df11896c3f6c044b607db2051a", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/28cbd710153191df11896c3f6c044b607db2051a", "committedDate": "2020-02-09T03:15:17Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04b7a7a5d1e82f99fe7e5f29c3341b55a7289465", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/04b7a7a5d1e82f99fe7e5f29c3341b55a7289465", "committedDate": "2020-02-09T03:23:22Z", "message": "Handle conversion from OpenJDK to OpenJ9 VarHandle operation methods\n\nOpenJDK VarHandle operation methods have the following parameter\nsequence: {VarHandle, Receiver, Intermediate ..., Value}.\n\nDuring invocation, OpenJ9 uses the following parameter sequence for the\nVarHandle operations: {Receiver, Intermediate ..., Value, VarHandle}.\n\nThe location of the VarHandle argument is different in the above two\ncases. MethodHandles.permuteArguments is used to translate from the\nOpenJ9 to OpenJDK invocation.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>\nCo-Authored-By: Tobi Ajila <atobia@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7739caba8955f54d8cc10c46a35c266bda3ebc1c", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7739caba8955f54d8cc10c46a35c266bda3ebc1c", "committedDate": "2020-02-09T03:23:35Z", "message": "Implement VarHandle.AccessType.accessModeType\n\nAccessType.accessModeType is implemented to retrieve the receiver class\nfrom the derived VarHandle class since VarForm does not provide the\nexact receiver class. In VarForm, the receiver class is always\njava.lang.Object.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "28cbd710153191df11896c3f6c044b607db2051a", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/28cbd710153191df11896c3f6c044b607db2051a", "committedDate": "2020-02-09T03:15:17Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "a90fba7d80cb348faa73bd8ebbfd1bd58f586c42", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a90fba7d80cb348faa73bd8ebbfd1bd58f586c42", "committedDate": "2020-02-09T03:23:35Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a90fba7d80cb348faa73bd8ebbfd1bd58f586c42", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/a90fba7d80cb348faa73bd8ebbfd1bd58f586c42", "committedDate": "2020-02-09T03:23:35Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "cc6d0faffa2c775715f4f9fe9d5f61617fbd9ab6", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/cc6d0faffa2c775715f4f9fe9d5f61617fbd9ab6", "committedDate": "2020-02-09T03:27:03Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e", "committedDate": "2020-02-09T03:28:08Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cc6d0faffa2c775715f4f9fe9d5f61617fbd9ab6", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/cc6d0faffa2c775715f4f9fe9d5f61617fbd9ab6", "committedDate": "2020-02-09T03:27:03Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}, "afterCommit": {"oid": "604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e", "author": {"user": {"login": "babsingh", "name": "Babneet Singh"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e", "committedDate": "2020-02-09T03:28:08Z", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MjY3NDk4", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#pullrequestreview-358267498", "createdAt": "2020-02-13T14:39:10Z", "commit": {"oid": "604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozOToxMFrOFpWPnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNDozOToxMFrOFpWPnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkwMDM4MQ==", "bodyText": "Is this used?", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r378900381", "createdAt": "2020-02-13T14:39:10Z", "author": {"login": "DanHeidinga"}, "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -269,13 +276,65 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tCOMPARE_AND_EXCHANGE,\n \t\tGET_AND_UPDATE;\n \n-\t\tMethodType accessModeType(Class<?> param1, Class<?> param2, Class<?>... params) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t/**\n+\t\t * Gets the MethodType associated with the AccessType.\n+\t\t * \n+\t\t * This method gets invoked by the derived VarHandle classes through accessModeTypeUncached.\n+\t\t * \n+\t\t * OpenJ9 only uses it to retrieve the receiver class, which is not available from VarForm.\n+\t\t * \n+\t\t * @param receiver class of the derived VarHandle.\n+\t\t * @param type is the field type or value type.\n+\t\t * @param args is the list of intermediate argument classes in the derived VarHandle's\n+\t\t * AccessMode methods.\n+\t\t * @return the MethodType for the corresponding AccessType.\n+\t\t */\n+\t\tMethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n+\t\t\tList<Class<?>> paramList = new ArrayList<>();\n+\t\t\tClass<?> returnType = null;\n+\t\t\tswitch (this) {\n+\t\t\tcase GET:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tbreak;\n+\t\t\tcase SET:\n+\t\t\t\treturnType = void.class;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tparamList.add(type);\n+\t\t\t\tbreak;\n+\t\t\tcase COMPARE_AND_SET:\n+\t\t\t\treturnType = boolean.class;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tCollections.addAll(paramList, type, type);\n+\t\t\t\tbreak;\n+\t\t\tcase COMPARE_AND_EXCHANGE:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tCollections.addAll(paramList, type, type);\n+\t\t\t\tbreak;\n+\t\t\tcase GET_AND_UPDATE:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tparamList.add(type);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new InternalError(\"Invalid AccessType.\");\n+\t\t\t}\n+\t\t\treturn MethodType.methodType(returnType, paramList);\n \t\t}\n \t}\n \t\n \tstatic final Unsafe _unsafe = Unsafe.getUnsafe();\n \tstatic final Lookup _lookup = Lookup.internalPrivilegedLookup;\n+\n+/*[IF Java14]*/\n+\tstatic final BiFunction<String, List<Integer>, ArrayIndexOutOfBoundsException> AIOOBE_SUPPLIER = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 673, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}