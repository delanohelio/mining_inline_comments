{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MTYyMzMw", "number": 9542, "title": "AArch64: Implement read barrier evaluators", "bodyText": "This commit implements read barrier evaluators for AArch64.\nSigned-off-by: KONNO Kazuhiro konno@jp.ibm.com", "createdAt": "2020-05-13T07:07:57Z", "url": "https://github.com/eclipse-openj9/openj9/pull/9542", "merged": true, "mergeCommit": {"oid": "505be676b12c697baf9235f61fabea59b17dd47f"}, "closed": true, "closedAt": "2020-06-03T18:12:25Z", "author": {"login": "knn-k"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchGtsBgBqjMzMzQ5MTQ5NzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcntiDTgFqTQyMzgwOTA4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "22c664c2113eac3064de63f116dee5846a64306e", "author": {"user": {"login": "knn-k", "name": "KONNO Kazuhiro"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/22c664c2113eac3064de63f116dee5846a64306e", "committedDate": "2020-05-13T06:00:49Z", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>"}, "afterCommit": {"oid": "2e82c6a51f5fb3137c5567c5961cbb50f285c14b", "author": {"user": {"login": "knn-k", "name": "KONNO Kazuhiro"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2e82c6a51f5fb3137c5567c5961cbb50f285c14b", "committedDate": "2020-05-14T05:32:34Z", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2e82c6a51f5fb3137c5567c5961cbb50f285c14b", "author": {"user": {"login": "knn-k", "name": "KONNO Kazuhiro"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2e82c6a51f5fb3137c5567c5961cbb50f285c14b", "committedDate": "2020-05-14T05:32:34Z", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>"}, "afterCommit": {"oid": "476ffeefa7f350a6ce3edc31abd11f1ffaaf1319", "author": {"user": {"login": "knn-k", "name": "KONNO Kazuhiro"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/476ffeefa7f350a6ce3edc31abd11f1ffaaf1319", "committedDate": "2020-05-21T07:53:16Z", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "476ffeefa7f350a6ce3edc31abd11f1ffaaf1319", "author": {"user": {"login": "knn-k", "name": "KONNO Kazuhiro"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/476ffeefa7f350a6ce3edc31abd11f1ffaaf1319", "committedDate": "2020-05-21T07:53:16Z", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>"}, "afterCommit": {"oid": "04c59540b1c98fbb9c16b444570779ed64effd5d", "author": {"user": {"login": "knn-k", "name": "KONNO Kazuhiro"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/04c59540b1c98fbb9c16b444570779ed64effd5d", "committedDate": "2020-05-26T12:34:39Z", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "04c59540b1c98fbb9c16b444570779ed64effd5d", "author": {"user": {"login": "knn-k", "name": "KONNO Kazuhiro"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/04c59540b1c98fbb9c16b444570779ed64effd5d", "committedDate": "2020-05-26T12:34:39Z", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>"}, "afterCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130", "author": {"user": {"login": "knn-k", "name": "KONNO Kazuhiro"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/66530baea9c53565a6741132b003b59d4f810130", "committedDate": "2020-05-28T08:55:47Z", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzU3MjY2", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#pullrequestreview-420357266", "createdAt": "2020-05-28T17:56:54Z", "commit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzo1Njo1NFrOGcAZtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMzowMzozNVrOGcJm7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxOTg5NA==", "bodyText": "What does the offset \"4\" represent?  Perhaps use a more descriptive constant name.", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432019894", "createdAt": "2020-05-28T17:56:54Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4MTk4Mg==", "bodyText": "Use the comp variable that you cached earlier.", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432081982", "createdAt": "2020-05-28T19:50:22Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4OTY4MA==", "bodyText": "What does it mean to assign metaReg to a NoReg dependence (i.e., any available real register)?  Shouldn't this be the actual real register representing the vmThread?", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432089680", "createdAt": "2020-05-28T20:00:07Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDU1Mw==", "bodyText": "Can you call this metaDataReg or more conventionally vmThreadReg ?", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432164553", "createdAt": "2020-05-28T22:45:15Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NTIxMg==", "bodyText": "Use comp here instead of cg->comp().", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432165212", "createdAt": "2020-05-28T22:47:15Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NTM4NQ==", "bodyText": "Use comp here", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432165385", "createdAt": "2020-05-28T22:47:46Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NjkyNA==", "bodyText": "Is this necessary?  What are you prefetching here and why?", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432166924", "createdAt": "2020-05-28T22:52:21Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());\n+\n+   if (needSync)\n+      {\n+      generateSynchronizationInstruction(cg, TR::InstOpCode::dsb, node, 0xF); // dsb SY\n+      }\n+\n+   cg->insertPrefetchIfNecessary(node, objReg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDQ5NA==", "bodyText": "The DNA of this method is about 80-90% identical to the iGenerateSoftwareReadBarrier method.  Is there any way you could combine them to save some code space?", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432170494", "createdAt": "2020-05-28T23:02:51Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());\n+\n+   if (needSync)\n+      {\n+      generateSynchronizationInstruction(cg, TR::InstOpCode::dsb, node, 0xF); // dsb SY\n+      }\n+\n+   cg->insertPrefetchIfNecessary(node, objReg);\n+\n+   tempMR->decNodeReferenceCounts(cg);\n+\n+   cg->stopUsingRegister(evacuateReg);\n+   cg->stopUsingRegister(locationReg);\n+   cg->stopUsingRegister(x0Reg);\n+\n+   cg->machine()->setLinkRegisterKilled(true);\n+\n+   return objReg;\n+#endif // OMR_GC_CONCURRENT_SCAVENGER\n+   }\n+\n+static TR::Register *\n+aGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDczMw==", "bodyText": "Most of my comments in iGenerateSoftwareReadBarrier apply to this function as well so I'm not going to repeat them.", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#discussion_r432170733", "createdAt": "2020-05-28T23:03:35Z", "author": {"login": "0xdaryl"}, "path": "runtime/compiler/aarch64/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -110,6 +111,286 @@ J9::ARM64::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::\n    TR_ASSERT_FATAL(false, \"This helper implements platform specific code for Fieldwatch, which is currently not supported on ARM64 platforms.\\n\");\n    }\n \n+static TR::Register *\n+iGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)\n+   {\n+#ifndef OMR_GC_CONCURRENT_SCAVENGER\n+   TR_ASSERT_FATAL(false, \"Concurrent Scavenger not supported.\");\n+#else\n+   TR::Compilation *comp = cg->comp();\n+   TR::MemoryReference *tempMR = NULL;\n+\n+   TR::Register *objReg = cg->allocateRegister();\n+   TR::Register *locationReg = cg->allocateRegister();\n+   TR::Register *evacuateReg = cg->allocateRegister();\n+   TR::Register *x0Reg = cg->allocateRegister();\n+   TR::Register *metaReg = cg->getMethodMetaDataRegister();\n+\n+   if (node->getSymbolReference()->getSymbol()->isInternalPointer())\n+      {\n+      objReg->setPinningArrayPointer(node->getSymbolReference()->getSymbol()->castToInternalPointerAutoSymbol()->getPinningArrayPointer());\n+      objReg->setContainsInternalPointer();\n+      }\n+\n+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);\n+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);\n+   startLabel->setStartInternalControlFlow();\n+   endLabel->setEndInternalControlFlow();\n+\n+   TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 5, cg->trMemory());\n+   deps->addPostCondition(objReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(locationReg, TR::RealRegister::x1); // TR_softwareReadBarrier helper needs this in x1.\n+   deps->addPostCondition(evacuateReg, TR::RealRegister::NoReg);\n+   deps->addPostCondition(x0Reg, TR::RealRegister::x0);\n+   deps->addPostCondition(metaReg, TR::RealRegister::NoReg);\n+\n+   tempMR = new (cg->trHeapMemory()) TR::MemoryReference(node, 4, cg);\n+\n+   node->setRegister(objReg);\n+\n+   if (tempMR->getUnresolvedSnippet() != NULL)\n+      {\n+      generateTrg1MemInstruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR);\n+      }\n+   else\n+      {\n+      if (tempMR->useIndexedForm())\n+         generateTrg1Src2Instruction(cg, TR::InstOpCode::addx, node, locationReg, tempMR->getBaseRegister(), tempMR->getIndexRegister());\n+      else\n+         generateTrg1MemInstruction(cg, TR::InstOpCode::addimmx, node, locationReg, tempMR);\n+      }\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateBaseAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_LT);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, evacuateReg,\n+         new (cg->trHeapMemory()) TR::MemoryReference(metaReg, cg->comp()->fej9()->thisThreadGetEvacuateTopAddressOffset(), cg));\n+   generateCompareInstruction(cg, node, objReg, evacuateReg, false); // false for 32-bit comparison\n+   generateConditionalBranchInstruction(cg, TR::InstOpCode::b_cond, node, endLabel, TR::CC_GT);\n+\n+   // TR_softwareReadBarrier helper expects the vmThread in x0.\n+   generateMovInstruction(cg, node, x0Reg, metaReg);\n+\n+   TR::SymbolReference *helperSym = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_softwareReadBarrier, false, false, false);\n+   generateImmSymInstruction(cg, TR::InstOpCode::bl, node, (uintptr_t)helperSym->getMethodAddress(), deps, helperSym, NULL);\n+\n+   generateTrg1MemInstruction(cg, TR::InstOpCode::ldrimmw, node, objReg, new (cg->trHeapMemory()) TR::MemoryReference(locationReg, 0, cg));\n+\n+   generateLabelInstruction(cg, TR::InstOpCode::label, node, endLabel, deps);\n+\n+   bool needSync = (node->getSymbolReference()->getSymbol()->isSyncVolatile() && cg->comp()->target().isSMP());\n+\n+   if (needSync)\n+      {\n+      generateSynchronizationInstruction(cg, TR::InstOpCode::dsb, node, 0xF); // dsb SY\n+      }\n+\n+   cg->insertPrefetchIfNecessary(node, objReg);\n+\n+   tempMR->decNodeReferenceCounts(cg);\n+\n+   cg->stopUsingRegister(evacuateReg);\n+   cg->stopUsingRegister(locationReg);\n+   cg->stopUsingRegister(x0Reg);\n+\n+   cg->machine()->setLinkRegisterKilled(true);\n+\n+   return objReg;\n+#endif // OMR_GC_CONCURRENT_SCAVENGER\n+   }\n+\n+static TR::Register *\n+aGenerateSoftwareReadBarrier(TR::Node *node, TR::CodeGenerator *cg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MDQ5NA=="}, "originalCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20bf33d0a05ea2ed6dc6dde3981375ee20e9a79a", "author": {"user": {"login": "knn-k", "name": "KONNO Kazuhiro"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/20bf33d0a05ea2ed6dc6dde3981375ee20e9a79a", "committedDate": "2020-05-29T06:18:41Z", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "66530baea9c53565a6741132b003b59d4f810130", "author": {"user": {"login": "knn-k", "name": "KONNO Kazuhiro"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/66530baea9c53565a6741132b003b59d4f810130", "committedDate": "2020-05-28T08:55:47Z", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>"}, "afterCommit": {"oid": "20bf33d0a05ea2ed6dc6dde3981375ee20e9a79a", "author": {"user": {"login": "knn-k", "name": "KONNO Kazuhiro"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/20bf33d0a05ea2ed6dc6dde3981375ee20e9a79a", "committedDate": "2020-05-29T06:18:41Z", "message": "AArch64: Implement read barrier evaluators\n\nThis commit implements read barrier evaluators for AArch64.\n\nSigned-off-by: KONNO Kazuhiro <konno@jp.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODA5MDg5", "url": "https://github.com/eclipse-openj9/openj9/pull/9542#pullrequestreview-423809089", "createdAt": "2020-06-03T18:12:03Z", "commit": {"oid": "20bf33d0a05ea2ed6dc6dde3981375ee20e9a79a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 913, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}