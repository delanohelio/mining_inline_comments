{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMjA2NTYy", "number": 8922, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzo0NDoyMlrODp9dRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNjo1NFrOEEtmJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzI1MTI2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzo0NDoyMlrOF5ddug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMDoxMzowMFrOF7BTHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5NTg5OA==", "bodyText": "I'd appreciate reviews of this code from @r30shah @andrewcraik @hzongaro and @aviansie-ben. I'm not really happy with this code, but I haven't settled on a good way to clean it up yet. In particular, I don't like the way GlRegDeps are handled right now. I'm open any suggestions people might have.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r395795898", "createdAt": "2020-03-20T17:44:22Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   traceMsg(comp, \"<LEO> Detected call to substitutabilityComparisonSymbol in n%dn\\n\", node->getGlobalIndex());\n+\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   traceMsg(comp, \"<LEO> Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));\n+   traceMsg(comp, \"<LEO> Anchoring call argument n%dn and n%dn under treetops n%dn and n%dn\\n\",\n+      node->getFirstChild()->getGlobalIndex(), node->getSecondChild()->getGlobalIndex(), anchoredCallArg1TT->getNode()->getGlobalIndex(), anchoredCallArg2TT->getNode()->getGlobalIndex());\n+\n+   // put non-helper call in its own block by block splitting at the\n+   // next treetop and then at the current one\n+   TR::Block* prevBlock = tt->getEnclosingBlock();\n+   comp->dumpMethodTrees(\"Initial trees\");\n+   TR::Block* targetBlock = prevBlock->splitPostGRA(tt->getPrevTreeTop(), cfg, true, NULL);\n+   TR::Block* callBlock = prevBlock->split(tt, cfg, true, NULL);\n+   callBlock->setIsExtensionOfPreviousBlock(true);\n+   comp->dumpMethodTrees(\"Trees after splitting blocks to isolate call\");\n+\n+   // insert store of constant 1\n+   // the value must go wherever the value returned by the helper call goes\n+   // so that the code in the target block picks up the constant if we fast-path\n+   // (i.e. jump around) the call\n+   auto* anchoredNode = anchoredCallTT->getNode()->getFirstChild(); // call node is under a treetop node\n+   traceMsg(comp, \"<LEO> Anchored call has been transformed into %s node n%dn\\n\",\n+            anchoredNode->getOpCode().getName(), anchoredNode->getGlobalIndex());\n+   auto* const1Node = TR::Node::iconst(1);\n+   TR::Node* storeNode = NULL;\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      traceMsg(comp, \"<LEO> Storing constant 1 in register %s\\n\",\n+               comp->getDebug()->getGlobalRegisterName(anchoredNode->getGlobalRegisterNumber()));\n+      storeNode = TR::Node::create(TR::iRegStore, 1, const1Node);\n+      storeNode->setGlobalRegisterNumber(anchoredNode->getGlobalRegisterNumber());\n+      }\n+   else if (anchoredNode->getOpCodeValue() == TR::iload)\n+      {\n+      traceMsg(comp, \"<LEO> Storing constant 1 to symref %d (%s)\\n\",\n+               anchoredNode->getSymbolReference()->getReferenceNumber(), anchoredNode->getSymbolReference()->getName(comp->getDebug()));\n+      storeNode = TR::Node::create(TR::istore, 1, const1Node);\n+      storeNode->setSymbolReference(anchoredNode->getSymbolReference());\n+      }\n+   else\n+      TR_ASSERT_FATAL(false, \"Anchord call has been turned into unexpected opcode %s\\n\", anchoredNode->getOpCode().getName());\n+   prevBlock->append(TR::TreeTop::create(comp, storeNode));\n+   comp->dumpMethodTrees(\"Trees after inserting store of constant 1\");\n+\n+   // instert acmpeq for fastpath, taking care to set the proper register dependencies\n+   auto* ifacmpeqNode = TR::Node::createif(TR::ifacmpeq, anchoredCallArg1TT->getNode()->getFirstChild(), anchoredCallArg2TT->getNode()->getFirstChild(), targetBlock->getEntry());\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      auto* depNode = TR::Node::create(TR::PassThrough, 1, storeNode->getChild(0));\n+      depNode->setGlobalRegisterNumber(storeNode->getGlobalRegisterNumber());\n+\n+      TR::Node* glRegDeps = TR::Node::create(TR::GlRegDeps);\n+      glRegDeps->addChildren(&depNode, 1);\n+      ifacmpeqNode->addChildren(&glRegDeps, 1);\n+\n+      if (callBlock->getExit()->getNode()->getNumChildren() > 0)\n+         {\n+         auto* expectedDeps = callBlock->getExit()->getNode()->getFirstChild();\n+         for (int i = 0; i < expectedDeps->getNumChildren(); ++i)\n+            {\n+            TR::Node* temp = expectedDeps->getChild(i);\n+            if (temp->getGlobalRegisterNumber() == depNode->getGlobalRegisterNumber())\n+               continue;\n+            glRegDeps->addChildren(&temp, 1);\n+            }\n+         }\n+      }\n+   prevBlock->append(TR::TreeTop::create(comp, ifacmpeqNode));\n+\n+   comp->dumpMethodTrees(\"Trees after inserting acmpeq fast path\");\n+   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33c5a9dab9359abf96b9e83b5277aecf142eabc5"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQzMTU4MA==", "bodyText": "I've discovered and resolved a bug in this code so the above listing is now out of date.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r397431580", "createdAt": "2020-03-24T20:13:00Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   traceMsg(comp, \"<LEO> Detected call to substitutabilityComparisonSymbol in n%dn\\n\", node->getGlobalIndex());\n+\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   traceMsg(comp, \"<LEO> Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));\n+   traceMsg(comp, \"<LEO> Anchoring call argument n%dn and n%dn under treetops n%dn and n%dn\\n\",\n+      node->getFirstChild()->getGlobalIndex(), node->getSecondChild()->getGlobalIndex(), anchoredCallArg1TT->getNode()->getGlobalIndex(), anchoredCallArg2TT->getNode()->getGlobalIndex());\n+\n+   // put non-helper call in its own block by block splitting at the\n+   // next treetop and then at the current one\n+   TR::Block* prevBlock = tt->getEnclosingBlock();\n+   comp->dumpMethodTrees(\"Initial trees\");\n+   TR::Block* targetBlock = prevBlock->splitPostGRA(tt->getPrevTreeTop(), cfg, true, NULL);\n+   TR::Block* callBlock = prevBlock->split(tt, cfg, true, NULL);\n+   callBlock->setIsExtensionOfPreviousBlock(true);\n+   comp->dumpMethodTrees(\"Trees after splitting blocks to isolate call\");\n+\n+   // insert store of constant 1\n+   // the value must go wherever the value returned by the helper call goes\n+   // so that the code in the target block picks up the constant if we fast-path\n+   // (i.e. jump around) the call\n+   auto* anchoredNode = anchoredCallTT->getNode()->getFirstChild(); // call node is under a treetop node\n+   traceMsg(comp, \"<LEO> Anchored call has been transformed into %s node n%dn\\n\",\n+            anchoredNode->getOpCode().getName(), anchoredNode->getGlobalIndex());\n+   auto* const1Node = TR::Node::iconst(1);\n+   TR::Node* storeNode = NULL;\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      traceMsg(comp, \"<LEO> Storing constant 1 in register %s\\n\",\n+               comp->getDebug()->getGlobalRegisterName(anchoredNode->getGlobalRegisterNumber()));\n+      storeNode = TR::Node::create(TR::iRegStore, 1, const1Node);\n+      storeNode->setGlobalRegisterNumber(anchoredNode->getGlobalRegisterNumber());\n+      }\n+   else if (anchoredNode->getOpCodeValue() == TR::iload)\n+      {\n+      traceMsg(comp, \"<LEO> Storing constant 1 to symref %d (%s)\\n\",\n+               anchoredNode->getSymbolReference()->getReferenceNumber(), anchoredNode->getSymbolReference()->getName(comp->getDebug()));\n+      storeNode = TR::Node::create(TR::istore, 1, const1Node);\n+      storeNode->setSymbolReference(anchoredNode->getSymbolReference());\n+      }\n+   else\n+      TR_ASSERT_FATAL(false, \"Anchord call has been turned into unexpected opcode %s\\n\", anchoredNode->getOpCode().getName());\n+   prevBlock->append(TR::TreeTop::create(comp, storeNode));\n+   comp->dumpMethodTrees(\"Trees after inserting store of constant 1\");\n+\n+   // instert acmpeq for fastpath, taking care to set the proper register dependencies\n+   auto* ifacmpeqNode = TR::Node::createif(TR::ifacmpeq, anchoredCallArg1TT->getNode()->getFirstChild(), anchoredCallArg2TT->getNode()->getFirstChild(), targetBlock->getEntry());\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      auto* depNode = TR::Node::create(TR::PassThrough, 1, storeNode->getChild(0));\n+      depNode->setGlobalRegisterNumber(storeNode->getGlobalRegisterNumber());\n+\n+      TR::Node* glRegDeps = TR::Node::create(TR::GlRegDeps);\n+      glRegDeps->addChildren(&depNode, 1);\n+      ifacmpeqNode->addChildren(&glRegDeps, 1);\n+\n+      if (callBlock->getExit()->getNode()->getNumChildren() > 0)\n+         {\n+         auto* expectedDeps = callBlock->getExit()->getNode()->getFirstChild();\n+         for (int i = 0; i < expectedDeps->getNumChildren(); ++i)\n+            {\n+            TR::Node* temp = expectedDeps->getChild(i);\n+            if (temp->getGlobalRegisterNumber() == depNode->getGlobalRegisterNumber())\n+               continue;\n+            glRegDeps->addChildren(&temp, 1);\n+            }\n+         }\n+      }\n+   prevBlock->append(TR::TreeTop::create(comp, ifacmpeqNode));\n+\n+   comp->dumpMethodTrees(\"Trees after inserting acmpeq fast path\");\n+   }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5NTg5OA=="}, "originalCommit": {"oid": "33c5a9dab9359abf96b9e83b5277aecf142eabc5"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjQ0MDc3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0MDowN1rOF_Rwpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzozNzowOFrOGinuaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTU5MA==", "bodyText": "Why does this need to be set to 1 to go to an if test it for equality to 0? Why not just branch directly to the block targetted by the ificmpqeq in the block you are going to...", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r401895590", "createdAt": "2020-04-01T20:40:07Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0OTA1Nw==", "bodyText": "I'm not actually sure that ificmpeq/ificmpne will be there. That's the shape of the trees I'm currently expecting to come out of IlGen. But, I'm not sure I can rely on that shape persisting through to the code generator. I wrote the code so it assumes nothing about how the result of the comparison is used.\nIf we can guarantee that the comparison will be there, then I agree it would be better to just jump to its target block, as appropriate.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r402449057", "createdAt": "2020-04-02T16:31:52Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTU5MA=="}, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyMTQ4OQ==", "bodyText": "We likely need to handle both cases - similar to arraycmp and ifarraycmp", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r407521489", "createdAt": "2020-04-13T14:56:54Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTU5MA=="}, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2NDA1Mw==", "bodyText": "What arraycmp and ifarraycmp code are you referring to? I can't seem to find it.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r411664053", "createdAt": "2020-04-20T20:19:14Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTU5MA=="}, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMDczOQ==", "bodyText": "The reason you can't find it seems to be it was removed as part of code clean up in OMR. That removal seems to be incorrect so I'm going to create an item to restore it but VMifArrayCmpEvaluator is what it was. The basic point of this was that because arraycmp returns 1/0/2 and the default compare sequences on x86 generate -1/0/1 we could save instructions if we knew we were just going to branch on the result by not generating the correct 1/0/2 but rather just directly testing the CPU flags at the end of the compare sequence.\nMy point is that generating a register for the result is going to be wasteful if we are just going to test and branch - the sequence should, ideally, either a) result in the flags naturally being set correctly to allow the branch to happen without additional tests or b) we need a pattern match for an if against one of these helpers so that we do set the flags and can jump directly without another test/compare instruction.\nIf you could create a backlog item for this that would be great. If you won't get to it in the short term you could mark it help wanted to see if anyone else would like to pick it up before you get back to it.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r438830739", "createdAt": "2020-06-11T14:31:37Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTU5MA=="}, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTYyNQ==", "bodyText": "I've opened #9856 to track this work.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r438955625", "createdAt": "2020-06-11T17:37:08Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5NTU5MA=="}, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjQ0ODEyOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0MjoxOVrOF_R1Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzo0NDo0OFrOGioDoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Njc1MQ==", "bodyText": "Whether this should be an extension and whether this should have the same frequency as the original block depends on how likely we think the we are to run the helper (if it is unlikely having this code down the bottom of the method might be more performant?)", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r401896751", "createdAt": "2020-04-01T20:42:19Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MDkwMg==", "bodyText": "Agreed.\nI was having trouble setting things up so the call could be in its own block, let alone putting towards the end of the function. Making it an extension was the easiest way I found of splitting the block without getting lost in the details of setting the proper global register dependencies everywhere.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r402450902", "createdAt": "2020-04-02T16:34:48Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Njc1MQ=="}, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMTA3Nw==", "bodyText": "I'm fine with this for a first implementation but there should be an issue to track going back to fix this since it will become a performance problem in the long run.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r438831077", "createdAt": "2020-06-11T14:32:08Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Njc1MQ=="}, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk2MTA1Ng==", "bodyText": "Opened #9857.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r438961056", "createdAt": "2020-06-11T17:44:48Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Njc1MQ=="}, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTg5ODE0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNTowMDoxOFrOGEpQTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDozOTowOVrOGFR5Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyMzQwNA==", "bodyText": "This looks like https://github.com/eclipse/omr/blob/87bb94e10fc847bc89d1a55b866d6952e31bcea8/compiler/optimizer/OMROptimization.cpp#L214\nPerhaps this pass would make more sense as a late MustBeDone optimization pass rather than in the CG itself since it is going to be doing some serious surgery that the optimizer might be able to help with? Just a thought...", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r407523404", "createdAt": "2020-04-13T15:00:18Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   traceMsg(comp, \"<LEO> Detected call to substitutabilityComparisonSymbol in n%dn\\n\", node->getGlobalIndex());\n+\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   traceMsg(comp, \"<LEO> Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE2NDk0Nw==", "bodyText": "Not sure. When I discussed this with others, the suggestion was to do it in lower trees.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r408164947", "createdAt": "2020-04-14T14:07:42Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   traceMsg(comp, \"<LEO> Detected call to substitutabilityComparisonSymbol in n%dn\\n\", node->getGlobalIndex());\n+\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   traceMsg(comp, \"<LEO> Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyMzQwNA=="}, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4OTIyMg==", "bodyText": "Thinking on it a little more, it would make it easier to work around the strange interaction between regDepCopyRemoval and the post GRA block splitter.\nThen again, this code is really more \"lowering\" than \"optimizing\", so it makes sense for it to be in lower trees.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r408189222", "createdAt": "2020-04-14T14:39:09Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   traceMsg(comp, \"<LEO> Detected call to substitutabilityComparisonSymbol in n%dn\\n\", node->getGlobalIndex());\n+\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   traceMsg(comp, \"<LEO> Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyMzQwNA=="}, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDI1MTc4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDo1NjoxNFrOGFSwAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDo1NjoxNFrOGFSwAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIwMzI2Nw==", "bodyText": "@Leonardo2718  I have just looked into the part where you are splitting blocks. When you create a callBlock, you do not need to set fixupCommoning to true, this will cause it to walk the tree-top before the split point (Although, there might not be anything to common). Another reason for not to set up fixupCommoning to true if you are setting the callBlock as extension of previous block.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r408203267", "createdAt": "2020-04-14T14:56:14Z", "author": {"login": "r30shah"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ * \n+ * @details\n+ * \n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   traceMsg(comp, \"<LEO> Detected call to substitutabilityComparisonSymbol in n%dn\\n\", node->getGlobalIndex());\n+\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   traceMsg(comp, \"<LEO> Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));\n+   traceMsg(comp, \"<LEO> Anchoring call argument n%dn and n%dn under treetops n%dn and n%dn\\n\",\n+      node->getFirstChild()->getGlobalIndex(), node->getSecondChild()->getGlobalIndex(), anchoredCallArg1TT->getNode()->getGlobalIndex(), anchoredCallArg2TT->getNode()->getGlobalIndex());\n+\n+   // put non-helper call in its own block by block splitting at the\n+   // next treetop and then at the current one\n+   TR::Block* prevBlock = tt->getEnclosingBlock();\n+   comp->dumpMethodTrees(\"Initial trees\");\n+   TR::Block* targetBlock = prevBlock->splitPostGRA(tt->getNextTreeTop(), cfg, true, NULL);\n+   TR::Block* callBlock = prevBlock->split(tt, cfg, true, NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8e14ce2eaff320a43ab194548e61819c5e9beb"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzYyNTI3OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzowODoyN1rOGKBYOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoxOTo0MFrOGKB4Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2MTUyOA==", "bodyText": "According to Travis CI this seems to be missing a self()->", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r413161528", "createdAt": "2020-04-22T17:08:27Z", "author": {"login": "fjeremic"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -809,6 +973,11 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n    OMR::CodeGeneratorConnector::lowerTreeIfNeeded(node, childNumberOfNode, parent, tt);\n \n+   if (node->getOpCode().isCall())\n+      {\n+      lowerNonhelperCallIfNeeded(node, tt);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f8467387b4e308777886788ff5152268271fa81"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2OTY5NQ==", "bodyText": "Yes! It most certainly does.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r413169695", "createdAt": "2020-04-22T17:19:40Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -809,6 +973,11 @@ J9::CodeGenerator::lowerTreeIfNeeded(\n    TR_J9VMBase *fej9 = (TR_J9VMBase *)(self()->comp()->fe());\n    OMR::CodeGeneratorConnector::lowerTreeIfNeeded(node, childNumberOfNode, parent, tt);\n \n+   if (node->getOpCode().isCall())\n+      {\n+      lowerNonhelperCallIfNeeded(node, tt);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2MTUyOA=="}, "originalCommit": {"oid": "7f8467387b4e308777886788ff5152268271fa81"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzc2MjA1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNTozNFrOGigQrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODowNDoyN1rOGio9HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMzMyNg==", "bodyText": "I think this should use invalidateStructure rather than setStructure(0). That being the new API to invalidate structure.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r438833326", "createdAt": "2020-06-11T14:35:34Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ *\n+ * @details\n+ *\n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt, const bool trace)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk3NTc3Mg==", "bodyText": "Fixed in force push.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r438975772", "createdAt": "2020-06-11T18:04:27Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ *\n+ * @details\n+ *\n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt, const bool trace)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMzMyNg=="}, "originalCommit": {"oid": "572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzc2ODA0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNjo1NFrOGigUaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODowNDozMlrOGio9Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNDI4Mw==", "bodyText": "should this trace turn on under traceCG for convenience?", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r438834283", "createdAt": "2020-06-11T14:36:54Z", "author": {"login": "andrewcraik"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ *\n+ * @details\n+ *\n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt, const bool trace)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   if (trace)\n+      traceMsg(comp, \"Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));\n+   if (trace)\n+      {\n+      traceMsg(comp, \"Anchoring call arguments n%dn and n%dn under treetops n%dn and n%dn\\n\",\n+         node->getFirstChild()->getGlobalIndex(), node->getSecondChild()->getGlobalIndex(), anchoredCallArg1TT->getNode()->getGlobalIndex(), anchoredCallArg2TT->getNode()->getGlobalIndex());\n+      }\n+\n+   // put non-helper call in its own block by block splitting at the\n+   // next treetop and then at the current one\n+   TR::Block* prevBlock = tt->getEnclosingBlock();\n+   TR::Block* targetBlock = prevBlock->splitPostGRA(tt->getNextTreeTop(), cfg, true, NULL);\n+   TR::Block* callBlock = prevBlock->split(tt, cfg);\n+   callBlock->setIsExtensionOfPreviousBlock(true);\n+   if (trace)\n+      traceMsg(comp, \"Isolated call node n%dn in block_%d\\n\", node->getGlobalIndex(), callBlock->getNumber());\n+\n+   // insert store of constant 1\n+   // the value must go wherever the value returned by the helper call goes\n+   // so that the code in the target block picks up the constant if we fast-path\n+   // (i.e. jump around) the call\n+   TR::Node* anchoredNode = anchoredCallTT->getNode()->getFirstChild(); // call node is under a treetop node\n+   if (trace)\n+      traceMsg(comp, \"Anchored call has been transformed into %s node n%dn\\n\", anchoredNode->getOpCode().getName(), anchoredNode->getGlobalIndex());\n+   auto* const1Node = TR::Node::iconst(1);\n+   TR::Node* storeNode = NULL;\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      if (trace)\n+         traceMsg(comp, \"Storing constant 1 in register %s\\n\", comp->getDebug()->getGlobalRegisterName(anchoredNode->getGlobalRegisterNumber()));\n+      storeNode = TR::Node::create(TR::iRegStore, 1, const1Node);\n+      storeNode->setGlobalRegisterNumber(anchoredNode->getGlobalRegisterNumber());\n+      }\n+   else if (anchoredNode->getOpCodeValue() == TR::iload)\n+      {\n+      if (trace)\n+         traceMsg(comp, \"Storing constant 1 to symref %d (%s)\\n\", anchoredNode->getSymbolReference()->getReferenceNumber(), anchoredNode->getSymbolReference()->getName(comp->getDebug()));\n+      storeNode = TR::Node::create(TR::istore, 1, const1Node);\n+      storeNode->setSymbolReference(anchoredNode->getSymbolReference());\n+      }\n+   else\n+      TR_ASSERT_FATAL(false, \"Anchord call has been turned into unexpected opcode %s\\n\", anchoredNode->getOpCode().getName());\n+   prevBlock->append(TR::TreeTop::create(comp, storeNode));\n+\n+   // instert acmpeq for fastpath, taking care to set the proper register dependencies\n+   auto* ifacmpeqNode = TR::Node::createif(TR::ifacmpeq, anchoredCallArg1TT->getNode()->getFirstChild(), anchoredCallArg2TT->getNode()->getFirstChild(), targetBlock->getEntry());\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      auto* depNode = TR::Node::create(TR::PassThrough, 1, storeNode->getChild(0));\n+      depNode->setGlobalRegisterNumber(storeNode->getGlobalRegisterNumber());\n+\n+      TR::Node* glRegDeps = TR::Node::create(TR::GlRegDeps);\n+      glRegDeps->addChildren(&depNode, 1);\n+      ifacmpeqNode->addChildren(&glRegDeps, 1);\n+\n+      if (callBlock->getExit()->getNode()->getNumChildren() > 0)\n+         {\n+         TR::Node* expectedDeps = callBlock->getExit()->getNode()->getFirstChild();\n+         for (int i = 0; i < expectedDeps->getNumChildren(); ++i)\n+            {\n+            TR::Node* temp = expectedDeps->getChild(i);\n+            if (temp->getGlobalRegisterNumber() == depNode->getGlobalRegisterNumber())\n+               continue;\n+            glRegDeps->addChildren(&temp, 1);\n+            }\n+         }\n+      }\n+   prevBlock->append(TR::TreeTop::create(comp, ifacmpeqNode));\n+   }\n+\n+void\n+J9::CodeGenerator::lowerNonhelperCallIfNeeded(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       comp->getSymRefTab()->isNonHelper(\n+       node->getSymbolReference(),\n+       TR::SymbolReferenceTable::objectEqualityComparisonSymbol))\n+      {\n+      // turn the non-helper call into a VM helper call\n+      node->setSymbolReference(comp->getSymRefTab()->findOrCreateAcmpHelperSymbolRef());\n+      static const bool disableAcmpFastPath =  NULL != feGetEnv(\"TR_DisableAcmpFastpath\");\n+      static const bool traceFastPath = NULL != feGetEnv(\"TR_TraceAcmpFastPath\");\n+      if (!disableAcmpFastPath)\n+         {\n+         self()->fastpathAcmpHelper(node, tt, traceFastPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk3NTgxOQ==", "bodyText": "Fixed in force push.", "url": "https://github.com/eclipse-openj9/openj9/pull/8922#discussion_r438975819", "createdAt": "2020-06-11T18:04:32Z", "author": {"login": "Leonardo2718"}, "path": "runtime/compiler/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -156,6 +154,172 @@ static TR::Node *lowerCASValues(\n    }\n \n \n+/**\n+ * @brief Add checks to skip (fast-path) acmpHelper call\n+ *\n+ * @details\n+ *\n+ * This transformation adds checks for the cases where the acmp can be performed\n+ * without calling the VM helper. The trasformed Trees represen the following operation:\n+ *\n+ * 1. If the address of lhs and rhs are the same, produce an eq (true) result\n+ *    and skip the call (note the two objects must be the same regardless of\n+ *    whether they are value types are reference types)\n+ * 2. Otherwise, do VM helper call\n+ *\n+ * The transformation looks as follows:\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |treetop               |\n+ *  |  icall acmpHelper    |\n+ *  |    aload lhs         |\n+ *  |    aload rhs         |\n+ *  |ificmpeq --> ...      |\n+ *  |  ==> icall           |\n+ *  |  iconst 0            |\n+ *  |BBEnd                 |\n+ *  +----------------------+\n+ *\n+ *  ...becomes...\n+ *\n+ *  +----------------------+\n+ *  |ttprev                |\n+ *  |iRegStore x           |\n+ *  |  iconst 1            |\n+ *  |ifacmpeq  -->---------*---------+\n+ *  |  aload lhs           |         |\n+ *  |  aload rhs           |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *  |BBStart (extension)   |         |\n+ *  |iRegStore x           |         |\n+ *  |  icall acmpHelper    |         |\n+ *  |    aload lhs         |         |\n+ *  |    aload rhs         |         |\n+ *  |BBEnd                 |         |\n+ *  +----------------------+         |\n+ *        |                          |\n+ *        +--------------------------+\n+ *        |\n+ *        v\n+ *  +-----------------+\n+ *  |BBStart\n+ *  |ificmpeq --> ... |\n+ *  |  iRegLoad x     |\n+ *  |  iconst 0       |\n+ *  |BBEnd            |\n+ *  +-----------------+\n+ *\n+ */\n+void\n+J9::CodeGenerator::fastpathAcmpHelper(TR::Node *node, TR::TreeTop *tt, const bool trace)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+   TR::CFG* cfg = comp->getFlowGraph();\n+   cfg->setStructure(0);\n+\n+   // anchor call node after split point to ensure the returned value goes into\n+   // either a temp or a global register\n+   auto* anchoredCallTT = TR::TreeTop::create(comp, tt, TR::Node::create(TR::treetop, 1, node));\n+   if (trace)\n+      traceMsg(comp, \"Anchoring call node under treetop n%dn (0x%p)\\n\", anchoredCallTT->getNode()->getGlobalIndex(), anchoredCallTT->getNode());\n+\n+   // anchor the call arguments just before the call\n+   // this ensures the values are live before the call so that we can\n+   // propagate their values in global registers if needed\n+   auto* anchoredCallArg1TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getFirstChild()));\n+   auto* anchoredCallArg2TT = TR::TreeTop::create(comp, tt->getPrevTreeTop(), TR::Node::create(TR::treetop, 1, node->getSecondChild()));\n+   if (trace)\n+      {\n+      traceMsg(comp, \"Anchoring call arguments n%dn and n%dn under treetops n%dn and n%dn\\n\",\n+         node->getFirstChild()->getGlobalIndex(), node->getSecondChild()->getGlobalIndex(), anchoredCallArg1TT->getNode()->getGlobalIndex(), anchoredCallArg2TT->getNode()->getGlobalIndex());\n+      }\n+\n+   // put non-helper call in its own block by block splitting at the\n+   // next treetop and then at the current one\n+   TR::Block* prevBlock = tt->getEnclosingBlock();\n+   TR::Block* targetBlock = prevBlock->splitPostGRA(tt->getNextTreeTop(), cfg, true, NULL);\n+   TR::Block* callBlock = prevBlock->split(tt, cfg);\n+   callBlock->setIsExtensionOfPreviousBlock(true);\n+   if (trace)\n+      traceMsg(comp, \"Isolated call node n%dn in block_%d\\n\", node->getGlobalIndex(), callBlock->getNumber());\n+\n+   // insert store of constant 1\n+   // the value must go wherever the value returned by the helper call goes\n+   // so that the code in the target block picks up the constant if we fast-path\n+   // (i.e. jump around) the call\n+   TR::Node* anchoredNode = anchoredCallTT->getNode()->getFirstChild(); // call node is under a treetop node\n+   if (trace)\n+      traceMsg(comp, \"Anchored call has been transformed into %s node n%dn\\n\", anchoredNode->getOpCode().getName(), anchoredNode->getGlobalIndex());\n+   auto* const1Node = TR::Node::iconst(1);\n+   TR::Node* storeNode = NULL;\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      if (trace)\n+         traceMsg(comp, \"Storing constant 1 in register %s\\n\", comp->getDebug()->getGlobalRegisterName(anchoredNode->getGlobalRegisterNumber()));\n+      storeNode = TR::Node::create(TR::iRegStore, 1, const1Node);\n+      storeNode->setGlobalRegisterNumber(anchoredNode->getGlobalRegisterNumber());\n+      }\n+   else if (anchoredNode->getOpCodeValue() == TR::iload)\n+      {\n+      if (trace)\n+         traceMsg(comp, \"Storing constant 1 to symref %d (%s)\\n\", anchoredNode->getSymbolReference()->getReferenceNumber(), anchoredNode->getSymbolReference()->getName(comp->getDebug()));\n+      storeNode = TR::Node::create(TR::istore, 1, const1Node);\n+      storeNode->setSymbolReference(anchoredNode->getSymbolReference());\n+      }\n+   else\n+      TR_ASSERT_FATAL(false, \"Anchord call has been turned into unexpected opcode %s\\n\", anchoredNode->getOpCode().getName());\n+   prevBlock->append(TR::TreeTop::create(comp, storeNode));\n+\n+   // instert acmpeq for fastpath, taking care to set the proper register dependencies\n+   auto* ifacmpeqNode = TR::Node::createif(TR::ifacmpeq, anchoredCallArg1TT->getNode()->getFirstChild(), anchoredCallArg2TT->getNode()->getFirstChild(), targetBlock->getEntry());\n+   if (anchoredNode->getOpCodeValue() == TR::iRegLoad)\n+      {\n+      auto* depNode = TR::Node::create(TR::PassThrough, 1, storeNode->getChild(0));\n+      depNode->setGlobalRegisterNumber(storeNode->getGlobalRegisterNumber());\n+\n+      TR::Node* glRegDeps = TR::Node::create(TR::GlRegDeps);\n+      glRegDeps->addChildren(&depNode, 1);\n+      ifacmpeqNode->addChildren(&glRegDeps, 1);\n+\n+      if (callBlock->getExit()->getNode()->getNumChildren() > 0)\n+         {\n+         TR::Node* expectedDeps = callBlock->getExit()->getNode()->getFirstChild();\n+         for (int i = 0; i < expectedDeps->getNumChildren(); ++i)\n+            {\n+            TR::Node* temp = expectedDeps->getChild(i);\n+            if (temp->getGlobalRegisterNumber() == depNode->getGlobalRegisterNumber())\n+               continue;\n+            glRegDeps->addChildren(&temp, 1);\n+            }\n+         }\n+      }\n+   prevBlock->append(TR::TreeTop::create(comp, ifacmpeqNode));\n+   }\n+\n+void\n+J9::CodeGenerator::lowerNonhelperCallIfNeeded(TR::Node *node, TR::TreeTop *tt)\n+   {\n+   TR::Compilation* comp = self()->comp();\n+\n+   if (TR::Compiler->om.areValueTypesEnabled() &&\n+       comp->getSymRefTab()->isNonHelper(\n+       node->getSymbolReference(),\n+       TR::SymbolReferenceTable::objectEqualityComparisonSymbol))\n+      {\n+      // turn the non-helper call into a VM helper call\n+      node->setSymbolReference(comp->getSymRefTab()->findOrCreateAcmpHelperSymbolRef());\n+      static const bool disableAcmpFastPath =  NULL != feGetEnv(\"TR_DisableAcmpFastpath\");\n+      static const bool traceFastPath = NULL != feGetEnv(\"TR_TraceAcmpFastPath\");\n+      if (!disableAcmpFastPath)\n+         {\n+         self()->fastpathAcmpHelper(node, tt, traceFastPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNDI4Mw=="}, "originalCommit": {"oid": "572e8a1ad9d5abc9f3cff5ce68a784a5c04fa65c"}, "originalPosition": 173}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 571, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}