{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1MzM1NDI4", "number": 9902, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozMjo0MlrOEGD6DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTozNjo1NFrOEHtDIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzkwOTI1OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozMjo0MlrOGkoN8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozMjo0MlrOGkoN8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2MDg0OQ==", "bodyText": "To avoid bugs, let's change the test to if (methodCacheEntry.ttlForUnresolved <= 0)", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r441060849", "createdAt": "2020-06-16T18:32:42Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -1024,8 +1028,16 @@ TR::CompilationInfoPerThreadRemote::getCachedResolvedMethod(TR_ResolvedMethodKey\n       auto comp = getCompilation();\n       TR_OpaqueMethodBlock *method = methodCacheEntry.method;\n \n+      // if method == NULL, cached unresolved method\n       if (!method)\n+         {\n+         // decrement time-to-live of this unresolved entry\n+         methodCacheEntry.ttlForUnresolved--;\n+\n+         if (methodCacheEntry.ttlForUnresolved == 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49d74cbaa25cb4b3b0fc43a499ed22abd39270a"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzkyMTg0OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozNjowM1rOGkoVsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo1MjoxNVrOGlMPPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2MjgzMw==", "bodyText": "Maybe expand the comment to something like: \"method==NULL means we have cached an unresolved method; purge the cache entry if the time-to-live for this entry has expired\"", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r441062833", "createdAt": "2020-06-16T18:36:03Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -1024,8 +1028,16 @@ TR::CompilationInfoPerThreadRemote::getCachedResolvedMethod(TR_ResolvedMethodKey\n       auto comp = getCompilation();\n       TR_OpaqueMethodBlock *method = methodCacheEntry.method;\n \n+      // if method == NULL, cached unresolved method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49d74cbaa25cb4b3b0fc43a499ed22abd39270a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2NDI1MQ==", "bodyText": "The original code seems to allow unresolved entries into the cache (method==NULL). This new implementation seems to be deleting from the cache such entries that were are added with a default ttl=-1.\nIt's true that we add more entries in walker and J9EstimateCodeSize, but is there room for improvement? Should the default value of TTL be larger?", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r441064251", "createdAt": "2020-06-16T18:38:29Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -1024,8 +1028,16 @@ TR::CompilationInfoPerThreadRemote::getCachedResolvedMethod(TR_ResolvedMethodKey\n       auto comp = getCompilation();\n       TR_OpaqueMethodBlock *method = methodCacheEntry.method;\n \n+      // if method == NULL, cached unresolved method", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2MjgzMw=="}, "originalCommit": {"oid": "b49d74cbaa25cb4b3b0fc43a499ed22abd39270a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1MTAwNg==", "bodyText": "This implementation will not purge entries with ttl=-1 at all, but I talk about this problem in the comment below.", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r441651006", "createdAt": "2020-06-17T15:52:15Z", "author": {"login": "dmitry-ten"}, "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -1024,8 +1028,16 @@ TR::CompilationInfoPerThreadRemote::getCachedResolvedMethod(TR_ResolvedMethodKey\n       auto comp = getCompilation();\n       TR_OpaqueMethodBlock *method = methodCacheEntry.method;\n \n+      // if method == NULL, cached unresolved method", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2MjgzMw=="}, "originalCommit": {"oid": "b49d74cbaa25cb4b3b0fc43a499ed22abd39270a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzk5MjM4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/env/j9methodServer.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODo1NzoxNVrOGkpDTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo1OTozN1rOGlMi2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NDUxMA==", "bodyText": "Above, at step 3. maybe we should add & to those 3 local vectors to make them references. Don't know if it's make a difference, but it doesn't hurt.", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r441074510", "createdAt": "2020-06-16T18:57:15Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/env/j9methodServer.cpp", "diffHunk": "@@ -1871,8 +1876,7 @@ TR_ResolvedJ9JITServerMethod::cacheResolvedMethodsCallees()\n       TR_ResolvedMethodType type = methodTypes[i];\n       TR_ResolvedMethod *resolvedMethod;\n       TR_ResolvedMethodKey key = compInfoPT->getResolvedMethodKey(type, (TR_OpaqueClassBlock *) _ramClass, cpIndices[i]);\n-      if (std::get<0>(methodInfos[i]).remoteMirror &&\n-         !compInfoPT->getCachedResolvedMethod(\n+      if (!compInfoPT->getCachedResolvedMethod(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49d74cbaa25cb4b3b0fc43a499ed22abd39270a"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NjAyNw==", "bodyText": "I thought that auto deduces references, but apparently it doesn't. Added it.", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r441656027", "createdAt": "2020-06-17T15:59:37Z", "author": {"login": "dmitry-ten"}, "path": "runtime/compiler/env/j9methodServer.cpp", "diffHunk": "@@ -1871,8 +1876,7 @@ TR_ResolvedJ9JITServerMethod::cacheResolvedMethodsCallees()\n       TR_ResolvedMethodType type = methodTypes[i];\n       TR_ResolvedMethod *resolvedMethod;\n       TR_ResolvedMethodKey key = compInfoPT->getResolvedMethodKey(type, (TR_OpaqueClassBlock *) _ramClass, cpIndices[i]);\n-      if (std::get<0>(methodInfos[i]).remoteMirror &&\n-         !compInfoPT->getCachedResolvedMethod(\n+      if (!compInfoPT->getCachedResolvedMethod(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NDUxMA=="}, "originalCommit": {"oid": "b49d74cbaa25cb4b3b0fc43a499ed22abd39270a"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjgxOTYxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMTo1MDowNFrOGlYoUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzo0MDowMlrOGnKsTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg1NDAzMg==", "bodyText": "Typo: putge --> purge", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r441854032", "createdAt": "2020-06-17T21:50:04Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -1024,8 +1028,17 @@ TR::CompilationInfoPerThreadRemote::getCachedResolvedMethod(TR_ResolvedMethodKey\n       auto comp = getCompilation();\n       TR_OpaqueMethodBlock *method = methodCacheEntry.method;\n \n+      // if method == NULL means we have cached an unresolved method;\n+      // putge the cached entry if time-to-live has expired.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8ff98f9a1714622b58a18fb1b9bae27cc6a6fc3"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcyMjgyOQ==", "bodyText": "Fixed", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r443722829", "createdAt": "2020-06-22T17:40:02Z", "author": {"login": "dmitry-ten"}, "path": "runtime/compiler/control/JITServerCompilationThread.cpp", "diffHunk": "@@ -1024,8 +1028,17 @@ TR::CompilationInfoPerThreadRemote::getCachedResolvedMethod(TR_ResolvedMethodKey\n       auto comp = getCompilation();\n       TR_OpaqueMethodBlock *method = methodCacheEntry.method;\n \n+      // if method == NULL means we have cached an unresolved method;\n+      // putge the cached entry if time-to-live has expired.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg1NDAzMg=="}, "originalCommit": {"oid": "e8ff98f9a1714622b58a18fb1b9bae27cc6a6fc3"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDcwNjM2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/ilgen/Walker.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzoyMDoxN1rOGnKDVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzozOTo1NFrOGnKsBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMjM0MQ==", "bodyText": "This needs to be protected by #if defined(J9VM_OPT_JITSERVER)", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r443712341", "createdAt": "2020-06-22T17:20:17Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -48,6 +48,7 @@\n #include \"ilgen/J9ByteCodeIlGenerator.hpp\"\n #include \"infra/Bit.hpp\"               //for trailingZeroes\n #include \"env/JSR292Methods.h\"\n+#include \"env/j9methodServer.hpp\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c2b4d40551cb5729d6463fb7b2443f81ec068db"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcyMjc1Ng==", "bodyText": "Added it.", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r443722756", "createdAt": "2020-06-22T17:39:54Z", "author": {"login": "dmitry-ten"}, "path": "runtime/compiler/ilgen/Walker.cpp", "diffHunk": "@@ -48,6 +48,7 @@\n #include \"ilgen/J9ByteCodeIlGenerator.hpp\"\n #include \"infra/Bit.hpp\"               //for trailingZeroes\n #include \"env/JSR292Methods.h\"\n+#include \"env/j9methodServer.hpp\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMjM0MQ=="}, "originalCommit": {"oid": "7c2b4d40551cb5729d6463fb7b2443f81ec068db"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTEzNTY4OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTozNjo1NFrOGnOT1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNTo1NzowNVrOGnv78w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc4MjEwMA==", "bodyText": "jitGetImproperInterfaceMethodFromCP takes vTableOffset as a pointer to UDATA, but the local above is declared to be uint32_t vTableOffset = 0;\nI think this is dangerous in that jitGetImproperInterfaceMethodFromCP may copy a 64-bit entity and silently corrupt the stack around  vTableOffset local.\nWe need to declare vTableOffset as UDATA and if we really have to, cast that into a uint32_t when storing into vTableOffsets vector (assuming the offset is never exceeding 32-bit)", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r443782100", "createdAt": "2020-06-22T19:36:54Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -1806,6 +1806,17 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n                   if (ramMethod) createMethod = true;\n                   break;\n                   }\n+               case TR_ResolvedMethodType::ImproperInterface:\n+                  {\n+                  TR::VMAccessCriticalSection getResolvedHandleMethod(fe);\n+                  ramMethod = jitGetImproperInterfaceMethodFromCP(\n+                     fe->vmThread(),\n+                     owningMethod->cp(),\n+                     cpIndex,\n+                     reinterpret_cast<UDATA *>(&vTableOffset));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be088bc76a3629692227a8e3e73f03ff6d1886b1"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxNjcwNw==", "bodyText": "I implemented what you said above. On my machine it compiles without casting to uint32_t but I'm not certain that it will work on all platforms.\nIn the below example it's simply cast to uint32_t:\nhttps://github.com/eclipse/openj9/blob/e006f8232bb7f1273c776a451ea8330bd7f224bb/runtime/compiler/env/j9method.cpp#L6491", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r443816707", "createdAt": "2020-06-22T20:47:08Z", "author": {"login": "dmitry-ten"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -1806,6 +1806,17 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n                   if (ramMethod) createMethod = true;\n                   break;\n                   }\n+               case TR_ResolvedMethodType::ImproperInterface:\n+                  {\n+                  TR::VMAccessCriticalSection getResolvedHandleMethod(fe);\n+                  ramMethod = jitGetImproperInterfaceMethodFromCP(\n+                     fe->vmThread(),\n+                     owningMethod->cp(),\n+                     cpIndex,\n+                     reinterpret_cast<UDATA *>(&vTableOffset));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc4MjEwMA=="}, "originalCommit": {"oid": "be088bc76a3629692227a8e3e73f03ff6d1886b1"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNzE5NQ==", "bodyText": "Could you please repeat the same trick for TR_ResolvedJ9Method::getVirtualMethod above?", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r443917195", "createdAt": "2020-06-23T01:54:43Z", "author": {"login": "mpirvu"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -1806,6 +1806,17 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n                   if (ramMethod) createMethod = true;\n                   break;\n                   }\n+               case TR_ResolvedMethodType::ImproperInterface:\n+                  {\n+                  TR::VMAccessCriticalSection getResolvedHandleMethod(fe);\n+                  ramMethod = jitGetImproperInterfaceMethodFromCP(\n+                     fe->vmThread(),\n+                     owningMethod->cp(),\n+                     cpIndex,\n+                     reinterpret_cast<UDATA *>(&vTableOffset));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc4MjEwMA=="}, "originalCommit": {"oid": "be088bc76a3629692227a8e3e73f03ff6d1886b1"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMzMzA0Mw==", "bodyText": "Done.", "url": "https://github.com/eclipse-openj9/openj9/pull/9902#discussion_r444333043", "createdAt": "2020-06-23T15:57:05Z", "author": {"login": "dmitry-ten"}, "path": "runtime/compiler/control/JITClientCompilationThread.cpp", "diffHunk": "@@ -1806,6 +1806,17 @@ handleServerMessage(JITServer::ClientStream *client, TR_J9VM *fe, JITServer::Mes\n                   if (ramMethod) createMethod = true;\n                   break;\n                   }\n+               case TR_ResolvedMethodType::ImproperInterface:\n+                  {\n+                  TR::VMAccessCriticalSection getResolvedHandleMethod(fe);\n+                  ramMethod = jitGetImproperInterfaceMethodFromCP(\n+                     fe->vmThread(),\n+                     owningMethod->cp(),\n+                     cpIndex,\n+                     reinterpret_cast<UDATA *>(&vTableOffset));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc4MjEwMA=="}, "originalCommit": {"oid": "be088bc76a3629692227a8e3e73f03ff6d1886b1"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 23, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}