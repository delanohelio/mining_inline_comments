{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NTI5Mjk1", "number": 9811, "title": "Minimize contention between \"finders\" using SCC JCL helper", "bodyText": "There are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\nA. For classLoader with isParallelCapable = true, the parallel\nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting\nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go\nthrough the synchronized method appClassloader.findSharedClass()\none by one, which becomes a bottleneck.\nThe changes here are:\n\n\nChange findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n\nUse a readWriteLock in SharedClassURLClasspathHelperImpl\ninstead.\n\n\nDo not enter classTableMutex and class segmentMutex in the\nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n\nEnter class segmentMutex only when necessary in\nhookFindSharedClass() and cacheMap::findROMClass().\n\n\nDo not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\n\nChange SharedClassURLHelperImpl.jarFileNameCache from a regular\nSet to a concurrent Set.\n\n\n_identifiedClasspaths should be used inside _identifiedMutex.\n\n\nSigned-off-by: Hang Shao hangshao@ca.ibm.com", "createdAt": "2020-06-05T15:27:54Z", "url": "https://github.com/eclipse-openj9/openj9/pull/9811", "merged": true, "mergeCommit": {"oid": "873d7fbbdf1c5caeaace46f0d0d2c48ab11b7ff6"}, "closed": true, "closedAt": "2020-06-14T15:29:52Z", "author": {"login": "hangshao0"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoUbjbgBqjM0MTE4ODA2MzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcrNzPzAFqTQzMDIyODk4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "017176f2eab2044765bc52864c3724e0cd3af7f5", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/017176f2eab2044765bc52864c3724e0cd3af7f5", "committedDate": "2020-06-04T16:09:31Z", "message": "Minimize contention between \"finders\" using SCC JCL helper.\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}, "afterCommit": {"oid": "46efbacf5e5d8e43a994d6ec92ef6b60c3e53e3d", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/46efbacf5e5d8e43a994d6ec92ef6b60c3e53e3d", "committedDate": "2020-06-05T15:30:53Z", "message": "Minimize contention between \"finders\" using SCC JCL helper.\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "46efbacf5e5d8e43a994d6ec92ef6b60c3e53e3d", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/46efbacf5e5d8e43a994d6ec92ef6b60c3e53e3d", "committedDate": "2020-06-05T15:30:53Z", "message": "Minimize contention between \"finders\" using SCC JCL helper.\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}, "afterCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "committedDate": "2020-06-05T16:10:46Z", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTM1NTI0", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#pullrequestreview-425535524", "createdAt": "2020-06-05T18:34:13Z", "commit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODozNjozMFrOGf5U1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowNToyNlrOGf726w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5ODI2MQ==", "bodyText": "The function comment \"If VM class segment is held, hasClassSegmentMutex must be true\" seems obsolete even before this change.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436098261", "createdAt": "2020-06-05T18:36:30Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -1735,9 +1736,10 @@ SH_CacheMap::addClasspathToCache(J9VMThread* currentThread, ClasspathItem* obj)\n  * @return the number of items read, or -1 on error\n  */\n IDATA \n-SH_CacheMap::runEntryPointChecks(J9VMThread* currentThread, void* address, const char** p_subcstr)\n+SH_CacheMap::runEntryPointChecks(J9VMThread* currentThread, void* address, const char** p_subcstr, bool acquireClassSegmentMutex)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTE0MA==", "bodyText": "Pls fix the function comment, \"findROMClass and storeROMClass prereq that the class segment mutex is held\"", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436099140", "createdAt": "2020-06-05T18:38:16Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -932,6 +932,7 @@ SH_CacheMap::updateROMSegmentList(J9VMThread* currentThread, bool hasClassSegmen\n #if defined(J9VM_THR_PREEMPTIVE)\n \tif (!hasClassSegmentMutex) {\n \t\tTrc_SHR_Assert_ShouldNotHaveLocalMutex(classSegmentMutex);\n+\t\tTrc_SHR_Assert_False(_ccHead->hasWriteMutex(currentThread));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTYwOA==", "bodyText": "Pls fix the function comment \"Caller must have VM class segment mutex.\"", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436099608", "createdAt": "2020-06-05T18:39:21Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2692,8 +2707,6 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \tUDATA hash = 0;\n \tbool useWriteHash = _ccHead->isUsingWriteHash();\n \n-\tTrc_SHR_Assert_ShouldHaveLocalMutex(currentThread->javaVM->classMemorySegments->segmentMutex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjE3MA==", "bodyText": "The call to markStale() above needs to have the segmentMutex.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436106170", "createdAt": "2020-06-05T18:53:07Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2913,7 +2935,7 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \n \tif (returnVal) {\n \t\t/* Call updateROMSegmentList() to ensure that heapAlloc of the romClass segment is always updated to include the returned romClass */\n-\t\tupdateROMSegmentList(currentThread, true);\n+\t\tupdateROMSegmentList(currentThread, omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) != 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNzk2MQ==", "bodyText": "The calls to getBootstrapClasspathItem() above needs to have the segmentMutex as well.\nI think technically we don't need the segmentMutex for these calls, but it was protecting them in the past. Another mutex could be used to reduce contention on the segmentMutex, although this also affects storing classes. Suggest sticking with segmentMutex in this PR, and consider future optimization. Similarly for registerStoreFilter().", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436107961", "createdAt": "2020-06-05T18:57:02Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1515,7 +1517,15 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \tif (!classpath) {\n \t\t/* No cached classpath found. Need to create a new one. */\n \t\tif ((NULL != eventData->classPathEntries) || (eventData->classloader == vm->systemClassLoader)) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjkxOA==", "bodyText": "Pls fix the function comment \"The caller must hold the VM class segment mutex\".", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436112918", "createdAt": "2020-06-05T19:08:04Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1427,6 +1427,8 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \tUDATA localVerboseFlags;\n \tJ9SharedClassConfig* sharedClassConfig = vm->sharedClassConfig;\n \tbool isBootLoader = false;\n+\tbool releaseSegmentMutex = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDEwNA==", "bodyText": "This needs to move back before if (confirmedCount <= foundAtIndex)", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436124104", "createdAt": "2020-06-05T19:34:50Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +175,62 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n-\t\t}\n-\t\treturn storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tconfirmedCount = foundAtIndex+1;\n+\t\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw==", "bodyText": "readLock() should be sufficient.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436136673", "createdAt": "2020-06-05T19:57:55Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -228,137 +246,160 @@ private synchronized void growURLs(int toMinSize) {\n \t}\n \n \t@Override\n-\tpublic synchronized void addClasspathEntry(URL cpe) {\n+\tpublic void addClasspathEntry(URL cpe) {\n \t\tClassLoader loader = getClassLoader();\n \t\tif (loader != null) {\n \t\t\tif (cpe==null) {\n \t\t\t\t/*[MSG \"K05ac\", \"URL is null for addClasspathEntry.\"]*/\n \t\t\t\tprintVerboseError(Msg.getString(\"K05ac\")); //$NON-NLS-1$\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\t/* If array is not big enough, grow it */\n-\t\t\tif (urls.length < (urlCount+1)) {\n-\t\t\t\tgrowURLs(urlCount+1);\n-\t\t\t}\n-\t\t\torigurls[urlCount] = cpe;\n-\t\t\turls[urlCount] = convertJarURL(cpe);\n-\t\t\tif (!validateURL(urls[urlCount], false)) {\n-\t\t\t\tinvalidURLExists = true;\n+\t\t\tURL convertedurl = convertJarURL(cpe);\n+\t\t\tboolean invalidUrl = false;\n+\t\t\tif (!validateURL(convertedurl, false)) {\n+\t\t\t\tinvalidUrl = true;\n \t\t\t}\n-\t\t\tnotifyClasspathChange2(loader);\n-\t\t\tif (!invalidURLExists) {\n-\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\turlcpReadWriteLock.writeLock().lock();\n+\t\t\ttry {\n+\t\t\t\t/* If array is not big enough, grow it */\n+\t\t\t\tif (urls.length < (urlCount+1)) {\n+\t\t\t\t\tgrowURLs(urlCount+1);\n+\t\t\t\t}\n+\t\t\t\torigurls[urlCount] = cpe;\n+\t\t\t\turls[urlCount] = convertedurl;\n+\t\t\t\tinvalidURLExists = invalidUrl;\n+\t\t\t\tnotifyClasspathChange2(loader);\n+\t\t\t\tif (!invalidURLExists) {\n+\t\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\t\t}\n+\t\t\t\t++urlCount;\n+\t\t\t} finally {\n+\t\t\t\turlcpReadWriteLock.writeLock().unlock();\n \t\t\t}\n-\t\t\t++urlCount;\n \t\t}\n \t}\n \n \t/* Function required by the factory */\n-\tsynchronized URL[] getClasspath() {\n+\tURL[] getClasspath() {\n \t\tURL[] correctLengthArray = new URL[urlCount];\n-\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n \t\treturn correctLengthArray;\n \t}\n \n \t@Override\n-\tpublic synchronized void confirmAllEntries() {\n-\t\tconfirmedCount = urlCount;\n+\tpublic void confirmAllEntries() {\n+\t\turlcpReadWriteLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ==", "bodyText": "newJarFileCheck() needs internal synchronization. Also the SharedClassFilter doesn't mention synchronization, but removing synchronized changes the behavior for calling acceptFind() and acceptStore(), these calls should remain protected.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436139755", "createdAt": "2020-06-05T20:05:26Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -103,7 +103,7 @@ public boolean setMinimizeUpdateChecks() {\n \t}\n \n \t@Override\n-\tpublic synchronized byte[] findSharedClass(String partition, URL path, String className) {\n+\tpublic byte[] findSharedClass(String partition, URL path, String className) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NTkwMTA2", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#pullrequestreview-426590106", "createdAt": "2020-06-08T20:21:07Z", "commit": {"oid": "7849dead8a04a198c372dc35dcfc218aa5db8cd0"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMDoyMTowN1rOGgu8Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMDozMzoyMVrOGgvXVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3NjcyNg==", "bodyText": "Better to keep the old behavior and synchronize on the instance of SharedClassURLHelperImpl than to start synchronizing on the user supplied object, which could have unexpected side effects. Or best is to synchronize on an internal Object.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436976726", "createdAt": "2020-06-08T20:21:07Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -126,12 +125,14 @@ public boolean setMinimizeUpdateChecks() {\n \t\tSharedClassFilter theFilter = getSharingFilter();\n \t\tboolean doFind, doStore;\n \t\tif (theFilter!=null) {\n-\t\t\tdoFind = theFilter.acceptFind(className);\n-\t\t\t/* Don't invoke the store filter if the cache is full */\n-\t\t\tif (nativeFlags[CACHE_FULL_FLAG] == 0) {\n-\t\t\t\tdoStore = theFilter.acceptStore(className);\n-\t\t\t} else {\n-\t\t\t\tdoStore = true;\n+\t\t\tsynchronized(theFilter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7849dead8a04a198c372dc35dcfc218aa5db8cd0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3OTMwOA==", "bodyText": "Note the same synchronization changes are also needed in SharedClassURLClasspathHelperImpl and SharedClassTokenHelperImpl.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436979308", "createdAt": "2020-06-08T20:26:02Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -126,12 +125,14 @@ public boolean setMinimizeUpdateChecks() {\n \t\tSharedClassFilter theFilter = getSharingFilter();\n \t\tboolean doFind, doStore;\n \t\tif (theFilter!=null) {\n-\t\t\tdoFind = theFilter.acceptFind(className);\n-\t\t\t/* Don't invoke the store filter if the cache is full */\n-\t\t\tif (nativeFlags[CACHE_FULL_FLAG] == 0) {\n-\t\t\t\tdoStore = theFilter.acceptStore(className);\n-\t\t\t} else {\n-\t\t\t\tdoStore = true;\n+\t\t\tsynchronized(theFilter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3NjcyNg=="}, "originalCommit": {"oid": "7849dead8a04a198c372dc35dcfc218aa5db8cd0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4MzYzOA==", "bodyText": "This is another writer.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436983638", "createdAt": "2020-06-08T20:33:21Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +175,66 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvalidated[foundAtIndex]=true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7849dead8a04a198c372dc35dcfc218aa5db8cd0"}, "originalPosition": 197}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7849dead8a04a198c372dc35dcfc218aa5db8cd0", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/7849dead8a04a198c372dc35dcfc218aa5db8cd0", "committedDate": "2020-06-08T19:39:18Z", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\n1. Delete obsolete comments on functions requiring class segment\nmutex.\n2. Wrap getBootstrapClasspathItem() inside class segment mutex.\n3. Add a new API to increase\nSharedClassURLClasspathHelperImpl.confirmedCount.\n4. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n5. Wrap acceptFind() and acceptStore() in a synchronized block.\n6. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}, "afterCommit": {"oid": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/cf41616c6fd61ef9d10289c8261bcfda7f53c33f", "committedDate": "2020-06-08T21:08:46Z", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\n1. Delete obsolete comments on functions requiring class segment\nmutex.\n2. Wrap getBootstrapClasspathItem() inside class segment mutex.\n3. Add a new API to increase\nSharedClassURLClasspathHelperImpl.confirmedCount.\n4. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n5. Wrap acceptFind() and acceptStore() in a synchronized block.\n6. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NjMxODE4", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#pullrequestreview-426631818", "createdAt": "2020-06-08T21:23:14Z", "commit": {"oid": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMToyMzoxNVrOGgw8Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMToyMzoxNVrOGgw8Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA==", "bodyText": "Might as well combine updating validated and confirmedCount to use a single writeLock().lock().", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437009438", "createdAt": "2020-06-08T21:23:15Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,70 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\tClassLoader actualLoader = getClassLoader();\n+\t\tif (!validateClassLoader(actualLoader, clazz)) {\n+\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\tboolean urlValidated = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} \n+\t\t\t\turlValidated = true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n \t\t}\n-\t\tClassLoader actualLoader = getClassLoader();\n-\t\tif (!validateClassLoader(actualLoader, clazz)) {\n-\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n-\t\t\treturn false;\n+\t\tif (urlValidated) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f"}, "originalPosition": 218}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/cf41616c6fd61ef9d10289c8261bcfda7f53c33f", "committedDate": "2020-06-08T21:08:46Z", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\n1. Delete obsolete comments on functions requiring class segment\nmutex.\n2. Wrap getBootstrapClasspathItem() inside class segment mutex.\n3. Add a new API to increase\nSharedClassURLClasspathHelperImpl.confirmedCount.\n4. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n5. Wrap acceptFind() and acceptStore() in a synchronized block.\n6. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}, "afterCommit": {"oid": "2446d4de57f5c06cfc09bff1620630a893755df9", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/2446d4de57f5c06cfc09bff1620630a893755df9", "committedDate": "2020-06-08T21:59:03Z", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\n1. Delete obsolete comments on functions requiring class segment\nmutex.\n2. Wrap getBootstrapClasspathItem() inside class segment mutex.\n3. Add a new API to increase\nSharedClassURLClasspathHelperImpl.confirmedCount.\n4. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n5. Wrap acceptFind() and acceptStore() in a synchronized block.\n6. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e6d86862a14ce3b550098fa97b44ac1c741d38a", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/3e6d86862a14ce3b550098fa97b44ac1c741d38a", "committedDate": "2020-06-10T18:56:04Z", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}, "afterCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/b37b5ef92cf08713207384362e796f99a46aa5bd", "committedDate": "2020-06-10T21:01:29Z", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NTIyNDY2", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#pullrequestreview-428522466", "createdAt": "2020-06-11T00:53:59Z", "commit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDo1Mzo1OVrOGiK-9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowOTozMlrOGiLN8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NDcyNA==", "bodyText": "Pls add a newline.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438484724", "createdAt": "2020-06-11T00:53:59Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/j9shr.tdf", "diffHunk": "@@ -2987,3 +2987,6 @@ TraceEvent=Trc_SHR_CC_startup_getCacheUniqueID_after Overhead=1 Level=7 Template\n \n TraceEvent=Trc_SHR_API_j9shr_classStoreTransaction_start_cacheFull_Event Overhead=1 Level=3 Template=\"API j9shr_classStoreTransaction_start : J9SHR_RUNTIMEFLAG_BLOCK_SPACE_FULL is set. The shared cache is full\"\n TraceEvent=Trc_SHR_API_j9shr_classStoreTransaction_start_cacheSoftFull_Event Overhead=1 Level=3 Template=\"API j9shr_classStoreTransaction_start : J9SHR_RUNTIMEFLAG_AVAILABLE_SPACE_FULL is set. The shared cache is soft full\"\n+\n+TraceExit-Exception=Trc_SHR_CMI_Update_Exit5 Overhead=1 Level=2 Template=\"CMI Update: StoreIdentified failed to acquire _identifiedMutex. Returning -1.\"\n+TraceExit-Exception=Trc_SHR_CMI_validate_Exit_IdentifiedMutex_Failed Overhead=1 Level=2 Template=\"CMI validate: Failed to acquire _identifiedMutex. Returning -1\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODE1MQ==", "bodyText": "Since the condition tested to get here isn't the same as the condition where identifiedMutex is entered further above, it seems possible for the assertion in local_StoreIdentified() to occur. Shouldn't identifiedMutex be entered if it's not already?", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438488151", "createdAt": "2020-06-11T01:07:46Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1114,26 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODI1Mg==", "bodyText": "I don't see why releaseIdentifiedMutex is needed here.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438488252", "createdAt": "2020-06-11T01:08:12Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1065,29 +1072,37 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \t\tIDATA prevMatch = ID_NOT_FOUND;\n \n \t\tfoundIdentified = -1;\n-\n-\t\t/* Multiple ClassLoaders could have the same classpath, so search until the matching helperID is found */\n-\t\tdo {\n-\t\t\tif ((foundIdentified = localValidate_FindIdentified(currentThread, testCP, foundIdentified+1)) != ID_NOT_FOUND) {\n-\t\t\t\tprevMatch = foundIdentified;\n-\t\t\t}\n-\t\t} while ((foundIdentified != ID_NOT_FOUND) && (foundIdentified != compareToID));\n-\n-\t\t/* This means we have a positive match - testCP is the same classpath as that of the caller classloader */\n-\t\tif (foundIdentified==compareToID) {\n-\t\t\tlocalFoundAtIndex = testCPIndex;\n-\t\t} else {\n-\t\t\t/* At this point, foundIdentified will always be ID_NOT_FOUND. This means that testCP is not exactly the same classpath as the caller\n-\t\t\t * classloader's, but we have identified it and it could still be a valid match. Test to see if we have tried this match before and failed it. */\n-\t\t\tfoundIdentified = prevMatch;\n-\t\t\tif (foundIdentified != ID_NOT_FOUND) {\n-\t\t\t\tif (hasMatchFailedBefore(currentThread, _identifiedClasspaths, compareToID, foundIdentified, testCPIndex, NULL, 0)) {\n-\t\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683 */\n-\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n-\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore(currentThread);\n-\t\t\t\t\tgoto _done;\n+\t\tif (0 == _cache->enterLocalMutex(currentThread, _identifiedMutex, \"identifiedMutex\", \"validate\")) {\n+\t\t\treleaseIdentifiedMutex = true;\n+\t\t\t/* Multiple ClassLoaders could have the same classpath, so search until the matching helperID is found */\n+\t\t\tdo {\n+\t\t\t\tif ((foundIdentified = localValidate_FindIdentified(currentThread, testCP, foundIdentified+1)) != ID_NOT_FOUND) {\n+\t\t\t\t\tprevMatch = foundIdentified;\n+\t\t\t\t}\n+\t\t\t} while ((foundIdentified != ID_NOT_FOUND) && (foundIdentified != compareToID));\n+\t\n+\t\t\t/* This means we have a positive match - testCP is the same classpath as that of the caller classloader */\n+\t\t\tif (foundIdentified==compareToID) {\n+\t\t\t\tlocalFoundAtIndex = testCPIndex;\n+\t\t\t} else {\n+\t\t\t\t/* At this point, foundIdentified will always be ID_NOT_FOUND. This means that testCP is not exactly the same classpath as the caller\n+\t\t\t\t * classloader's, but we have identified it and it could still be a valid match. Test to see if we have tried this match before and failed it. */\n+\t\t\t\tfoundIdentified = prevMatch;\n+\t\t\t\tif (foundIdentified != ID_NOT_FOUND) {\n+\t\t\t\t\tif (hasMatchFailedBefore(currentThread, _identifiedClasspaths, compareToID, foundIdentified, testCPIndex, NULL, 0)) {\n+\t\t\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683 */\n+\t\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n+\t\t\t\t\t\tTrc_SHR_CMI_validate_ExitFailedBefore(currentThread);\n+\t\t\t\t\t\tif (releaseIdentifiedMutex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODU2Mg==", "bodyText": "Seems if releaseIdentifiedMutex is false, the assert in local_StoreIdentified() would occur before getting here.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438488562", "createdAt": "2020-06-11T01:09:32Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1114,26 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {\n+\t\t\t\t/* trace event is at level 1 and trace exit message is at level 2 as per CMVC 155318/157683  */\n+\t\t\t\tTrc_SHR_CMI_validate_ExitError_Event(currentThread, foundROMClass, compareTo, confirmedEntries);\n+\t\t\t\tTrc_SHR_CMI_validate_ExitError(currentThread);\n+\t\t\t\tif (releaseIdentifiedMutex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd"}, "originalPosition": 178}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/b37b5ef92cf08713207384362e796f99a46aa5bd", "committedDate": "2020-06-10T21:01:29Z", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}, "afterCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/979d5b7c97340f72db2d679e287235a889eb808b", "committedDate": "2020-06-11T16:08:49Z", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MTA5MjQ3", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#pullrequestreview-429109247", "createdAt": "2020-06-11T17:00:11Z", "commit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowMDoxMVrOGimeXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNzowNlrOGimtMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTEzMw==", "bodyText": "Pls use ! instead of false ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438935133", "createdAt": "2020-06-11T17:00:11Z", "author": {"login": "pshipton"}, "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,66 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n+\t\tif (incConfirmedCount) {\n+\t\t\tincreaseConfirmedCount(foundAtIndex + 1);\n \t\t}\n-\t\treturn storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\treturn storeRet;\n \t}\n \n-\tprivate synchronized void growURLs(int toMinSize) {\n+\tprivate void growURLs(int toMinSize) {\n+\t\tif (false == urlcpReadWriteLock.writeLock().isHeldByCurrentThread()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTg4Mg==", "bodyText": "Constant on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438935882", "createdAt": "2020-06-11T17:01:29Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2810,7 +2821,16 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \t\t\t\t\t\t\tTrc_SHR_CM_findROMClass_FailedMutex(currentThread, path, cp->getHelperID());\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tIDATA rv = refreshHashtables(currentThread, true);\t\t/* We do have the class segment mutex - this is a prereq of findROMClass */\n+\t\t\t\t\t\tbool segmentMutexEntered = false;\n+\t\t\t\t\t\tif (omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNjA2Ng==", "bodyText": "Pls add a space.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438936066", "createdAt": "2020-06-11T17:01:49Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/CacheMap.cpp", "diffHunk": "@@ -2810,7 +2821,16 @@ SH_CacheMap::findROMClass(J9VMThread* currentThread, const char* path, Classpath\n \t\t\t\t\t\t\tTrc_SHR_CM_findROMClass_FailedMutex(currentThread, path, cp->getHelperID());\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tIDATA rv = refreshHashtables(currentThread, true);\t\t/* We do have the class segment mutex - this is a prereq of findROMClass */\n+\t\t\t\t\t\tbool segmentMutexEntered = false;\n+\t\t\t\t\t\tif (omrthread_monitor_owned_by_self(currentThread->javaVM->classMemorySegments->segmentMutex) == 0) {\n+\t\t\t\t\t\t\tTrc_SHR_Assert_False(_ccHead->hasWriteMutex(currentThread));\n+\t\t\t\t\t\t\tenterLocalMutex(currentThread, currentThread->javaVM->classMemorySegments->segmentMutex, \"class segment mutex\", \"CM findROMClass\");\n+\t\t\t\t\t\t\tsegmentMutexEntered= true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNzY2NA==", "bodyText": "Pls add spaces and put constants on the left. The (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING) should use OMR_ARE_ANY_BITS_SET", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438937664", "createdAt": "2020-06-11T17:04:51Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1112,31 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODAxOQ==", "bodyText": "Pls add spaces and put constants on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938019", "createdAt": "2020-06-11T17:05:30Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/ClasspathManagerImpl2.cpp", "diffHunk": "@@ -1099,7 +1112,31 @@ SH_ClasspathManagerImpl2::validate(J9VMThread* currentThread, ROMClassWrapper* f\n \tif (localFoundAtIndex == -1) {\n \t\t/* We didn't find an exact classpath match. Walk the classpaths and check for validity. Note that the timestamp check is incorporated for efficiency. */\n \t\tlocalFoundAtIndex = localValidate_CheckAndTimestampManually(currentThread, testCP, testCPIndex, compareTo, foundIdentified, &addToIdentified, staleItem);\n+\t\t/* If the classpath has just been identified by localValidate_CheckAndTimestampManually, store it in the identified array */\n+\t\tif (addToIdentified && (compareTo->getType()==CP_TYPE_CLASSPATH) && (*_runtimeFlagsPtr & J9SHR_RUNTIMEFLAG_ENABLE_LOCAL_CACHEING)) {\n+\t\t\tif (!releaseIdentifiedMutex) {\n+\t\t\t\tif (0 == _cache->enterLocalMutex(currentThread, _identifiedMutex, \"identifiedMutex\", \"validate\")) {\n+\t\t\t\t\treleaseIdentifiedMutex = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t/* Identification succeeded. Store identified classpath. */\n+\t\t\tif (releaseIdentifiedMutex) {\n+\t\t\t\tif (local_StoreIdentified(currentThread, compareTo, testCP)==-1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODI4NQ==", "bodyText": "Constant on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938285", "createdAt": "2020-06-11T17:05:57Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODQ5Ng==", "bodyText": "Constant on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938496", "createdAt": "2020-06-11T17:06:17Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t\t}\n \t\t\t\tclasspath = getBootstrapClasspathItem(currentThread, vm->modulesPathEntry, pathEntryCount);\n+\t\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODY2Nw==", "bodyText": "Constant on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938667", "createdAt": "2020-06-11T17:06:35Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1505,17 +1506,41 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t\t\tif (eventData->classloader == vm->systemClassLoader) {\n \t\t\t\tisBootLoader = true;\n \t\t\t\tpathEntryCount += 1;\n+\t\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t\t}\n \t\t\t\tclasspath = getBootstrapClasspathItem(currentThread, vm->modulesPathEntry, pathEntryCount);\n+\t\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {\n+\t\t\t\tomrthread_monitor_enter(classSegmentMutex);\n+\t\t\t\treleaseSegmentMutex = true;\n+\t\t\t}\n \t\t\tclasspath = getBootstrapClasspathItem(currentThread, eventData->classPathEntries, pathEntryCount);\n+\t\t\tif (releaseSegmentMutex) {\n+\t\t\t\tomrthread_monitor_exit(classSegmentMutex);\n+\t\t\t\treleaseSegmentMutex = false;\n+\t\t\t}\n \t\t}\n \t}\n \n \tif (!classpath) {\n \t\t/* No cached classpath found. Need to create a new one. */\n \t\tif ((NULL != eventData->classPathEntries) || (eventData->classloader == vm->systemClassLoader)) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODc4OA==", "bodyText": "Constants on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938788", "createdAt": "2020-06-11T17:06:50Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1537,7 +1562,15 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \n \tif (eventData->doPreventFind) {\n \t\tif (eventData->doPreventStore) {\n+\t\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODkzMA==", "bodyText": "Constant on the left.", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438938930", "createdAt": "2020-06-11T17:07:06Z", "author": {"login": "pshipton"}, "path": "runtime/shared_common/shrinit.cpp", "diffHunk": "@@ -1564,7 +1597,14 @@ hookFindSharedClass(J9HookInterface** hookInterface, UDATA eventNum, void* voidD\n \t}\n \n \tif (eventData->doPreventStore && (NULL == eventData->result)) {\n+\t\tif (omrthread_monitor_owned_by_self(classSegmentMutex) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b"}, "originalPosition": 88}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "979d5b7c97340f72db2d679e287235a889eb808b", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/979d5b7c97340f72db2d679e287235a889eb808b", "committedDate": "2020-06-11T16:08:49Z", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}, "afterCommit": {"oid": "d33af83f4ae4240ff1b32b87b4632a4b5501c501", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/d33af83f4ae4240ff1b32b87b4632a4b5501c501", "committedDate": "2020-06-11T18:46:03Z", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77b14cc5395285f662f8394988726fbb3cf1be4f", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/77b14cc5395285f662f8394988726fbb3cf1be4f", "committedDate": "2020-06-11T20:31:22Z", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\n5. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\n6. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n\n7. _identifiedClasspaths should be used inside _identifiedMutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d33af83f4ae4240ff1b32b87b4632a4b5501c501", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/d33af83f4ae4240ff1b32b87b4632a4b5501c501", "committedDate": "2020-06-11T18:46:03Z", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}, "afterCommit": {"oid": "77b14cc5395285f662f8394988726fbb3cf1be4f", "author": {"user": {"login": "hangshao0", "name": "Hang Shao"}}, "url": "https://github.com/eclipse-openj9/openj9/commit/77b14cc5395285f662f8394988726fbb3cf1be4f", "committedDate": "2020-06-11T20:31:22Z", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\n5. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\n6. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n\n7. _identifiedClasspaths should be used inside _identifiedMutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMjI4OTgz", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#pullrequestreview-430228983", "createdAt": "2020-06-14T15:29:34Z", "commit": {"oid": "77b14cc5395285f662f8394988726fbb3cf1be4f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 616, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}