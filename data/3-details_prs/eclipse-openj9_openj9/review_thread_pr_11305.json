{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NzYxNDc2", "number": 11305, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNTowNzoyNFrOFHdgzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNTo0OTo1NlrOFQENKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzY3ODg2OnYy", "diffSide": "RIGHT", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNTowNzoyNFrOII8WDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNTozNDo1N1rOIJcXIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI0ODIwNw==", "bodyText": "I think this will cause some register shuffling since before dependencies were shared between the array check store and write barrier helpers.", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r546248207", "createdAt": "2020-12-19T15:07:24Z", "author": {"login": "gita-omr"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -3585,105 +3407,46 @@ TR::Register *J9::Power::TreeEvaluator::ArrayStoreCHKEvaluator(TR::Node *node, T\n       }\n \n    TR::Register *srcReg, *dstReg;\n-   TR::Register *condReg, *temp1Reg, *temp2Reg, *temp3Reg, *temp4Reg, *baseReg, *indexReg;\n-   TR::MemoryReference *tempMR1, *tempMR2;\n-   TR::LabelSymbol *wbLabel, *doneLabel, *startLabel, *storeLabel, *wrtBarEndLabel;\n+   TR::Register *condReg, *temp1Reg, *temp2Reg, *temp3Reg, *temp4Reg;\n+   TR::LabelSymbol *wbLabel, *startLabel;\n    TR::RegisterDependencyConditions *conditions;\n-   J9::Power::PrivateLinkage *linkage = (J9::Power::PrivateLinkage *) cg->getLinkage();\n-   const TR::PPCLinkageProperties &properties = linkage->getProperties();\n-   TR::Instruction *gcPoint;\n-   bool stopUsingSrc = false;\n \n    wbLabel = generateLabelSymbol(cg);\n-   doneLabel = generateLabelSymbol(cg);\n-   storeLabel = (doWrtBar) ? (generateLabelSymbol(cg)) : NULL;\n \n-   tempMR1 = TR::MemoryReference::createWithRootLoadOrStore(cg, firstChild, TR::Compiler->om.sizeofReferenceAddress());\n    dstReg = cg->evaluate(destinationChild);\n-   TR::Register *compressedReg;\n-   if (sourceChild->getReferenceCount() > 1 && (srcReg = sourceChild->getRegister()) != NULL)\n-      {\n-      TR::Register *tempReg = cg->allocateCollectedReferenceRegister();\n-\n-      // Source must be an object.\n-      TR_ASSERT(!srcReg->containsInternalPointer(), \"Stored value is an internal pointer\");\n+   srcReg = cg->evaluate(sourceChild);\n \n-      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, tempReg, srcReg);\n-      srcReg = tempReg;\n-      stopUsingSrc = true;\n-      compressedReg = srcReg;\n-      if (usingCompressedPointers)\n-         compressedReg = cg->evaluate(firstChild->getSecondChild());\n-      }\n-   else\n-      {\n-      srcReg = cg->evaluate(sourceChild);\n-      compressedReg = srcReg;\n-      if (usingCompressedPointers)\n-         compressedReg = cg->evaluate(firstChild->getSecondChild());\n-      }\n-\n-   int32_t numDeps = 11;\n-   if (usingCompressedPointers)\n-      numDeps++;\n-   if ((gcMode == gc_modron_wrtbar_satb) || (comp->getOptions()->realTimeGC()))\n-      numDeps++;\n-   if (!firstChild->skipWrtBar())\n-      numDeps += 2;\n-\n-   conditions = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(numDeps, numDeps, cg->trMemory());\n+   conditions = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(7, 7, cg->trMemory());\n    temp1Reg = cg->allocateRegister();\n    temp2Reg = cg->allocateRegister();\n    temp3Reg = cg->allocateRegister();\n    temp4Reg = cg->allocateRegister();\n    condReg = cg->allocateRegister(TR_CCR);\n \n-   // !!! Adding any dependency before the baseReg, you have to be careful with the excludeGPR0 order\n-   TR::addDependency(conditions, dstReg, TR::RealRegister::gr3, TR_GPR, cg);\n-\n-   if (comp->getOptions()->realTimeGC())\n-      TR::addDependency(conditions, srcReg, TR::RealRegister::gr5, TR_GPR, cg);\n-   else\n-      TR::addDependency(conditions, srcReg, TR::RealRegister::gr4, TR_GPR, cg);\n-\n-   TR::addDependency(conditions, temp1Reg, TR::RealRegister::gr11, TR_GPR, cg);\n+   TR::addDependency(conditions, dstReg, TR::RealRegister::NoReg, TR_GPR, cg);\n+   conditions->getPreConditions()->getRegisterDependency(conditions->getAddCursorForPre() - 1)->setExcludeGPR0();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "825ae5151f1c3710237427f8b898eae5bbae9ff6"}, "originalPosition": 514}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc3Mjc2OQ==", "bodyText": "I don't think removing these explicit dependencies should cause any additional register shuffles. The code generated for the write barrier comes after the label with these dependencies, meaning that the more specific dependencies from the write barrier would be encountered by the local register allocator before these ones.", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r546772769", "createdAt": "2020-12-21T15:34:57Z", "author": {"login": "aviansie-ben"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -3585,105 +3407,46 @@ TR::Register *J9::Power::TreeEvaluator::ArrayStoreCHKEvaluator(TR::Node *node, T\n       }\n \n    TR::Register *srcReg, *dstReg;\n-   TR::Register *condReg, *temp1Reg, *temp2Reg, *temp3Reg, *temp4Reg, *baseReg, *indexReg;\n-   TR::MemoryReference *tempMR1, *tempMR2;\n-   TR::LabelSymbol *wbLabel, *doneLabel, *startLabel, *storeLabel, *wrtBarEndLabel;\n+   TR::Register *condReg, *temp1Reg, *temp2Reg, *temp3Reg, *temp4Reg;\n+   TR::LabelSymbol *wbLabel, *startLabel;\n    TR::RegisterDependencyConditions *conditions;\n-   J9::Power::PrivateLinkage *linkage = (J9::Power::PrivateLinkage *) cg->getLinkage();\n-   const TR::PPCLinkageProperties &properties = linkage->getProperties();\n-   TR::Instruction *gcPoint;\n-   bool stopUsingSrc = false;\n \n    wbLabel = generateLabelSymbol(cg);\n-   doneLabel = generateLabelSymbol(cg);\n-   storeLabel = (doWrtBar) ? (generateLabelSymbol(cg)) : NULL;\n \n-   tempMR1 = TR::MemoryReference::createWithRootLoadOrStore(cg, firstChild, TR::Compiler->om.sizeofReferenceAddress());\n    dstReg = cg->evaluate(destinationChild);\n-   TR::Register *compressedReg;\n-   if (sourceChild->getReferenceCount() > 1 && (srcReg = sourceChild->getRegister()) != NULL)\n-      {\n-      TR::Register *tempReg = cg->allocateCollectedReferenceRegister();\n-\n-      // Source must be an object.\n-      TR_ASSERT(!srcReg->containsInternalPointer(), \"Stored value is an internal pointer\");\n+   srcReg = cg->evaluate(sourceChild);\n \n-      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, tempReg, srcReg);\n-      srcReg = tempReg;\n-      stopUsingSrc = true;\n-      compressedReg = srcReg;\n-      if (usingCompressedPointers)\n-         compressedReg = cg->evaluate(firstChild->getSecondChild());\n-      }\n-   else\n-      {\n-      srcReg = cg->evaluate(sourceChild);\n-      compressedReg = srcReg;\n-      if (usingCompressedPointers)\n-         compressedReg = cg->evaluate(firstChild->getSecondChild());\n-      }\n-\n-   int32_t numDeps = 11;\n-   if (usingCompressedPointers)\n-      numDeps++;\n-   if ((gcMode == gc_modron_wrtbar_satb) || (comp->getOptions()->realTimeGC()))\n-      numDeps++;\n-   if (!firstChild->skipWrtBar())\n-      numDeps += 2;\n-\n-   conditions = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(numDeps, numDeps, cg->trMemory());\n+   conditions = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(7, 7, cg->trMemory());\n    temp1Reg = cg->allocateRegister();\n    temp2Reg = cg->allocateRegister();\n    temp3Reg = cg->allocateRegister();\n    temp4Reg = cg->allocateRegister();\n    condReg = cg->allocateRegister(TR_CCR);\n \n-   // !!! Adding any dependency before the baseReg, you have to be careful with the excludeGPR0 order\n-   TR::addDependency(conditions, dstReg, TR::RealRegister::gr3, TR_GPR, cg);\n-\n-   if (comp->getOptions()->realTimeGC())\n-      TR::addDependency(conditions, srcReg, TR::RealRegister::gr5, TR_GPR, cg);\n-   else\n-      TR::addDependency(conditions, srcReg, TR::RealRegister::gr4, TR_GPR, cg);\n-\n-   TR::addDependency(conditions, temp1Reg, TR::RealRegister::gr11, TR_GPR, cg);\n+   TR::addDependency(conditions, dstReg, TR::RealRegister::NoReg, TR_GPR, cg);\n+   conditions->getPreConditions()->getRegisterDependency(conditions->getAddCursorForPre() - 1)->setExcludeGPR0();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI0ODIwNw=="}, "originalCommit": {"oid": "825ae5151f1c3710237427f8b898eae5bbae9ff6"}, "originalPosition": 514}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTAxNjczOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/p/codegen/J9CodeGenerator.cpp", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxOTowNjoxNFrOIOjmAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxOTo0ODo0NVrOIbYzRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzNDE0NA==", "bodyText": "This looks like conditions being misplaced originally.  This current fix certainly is not in line with the intention of prefetch optimization.  Prefetch surely is beneficial performance-wise to 64bit non-compressed.\nThe conditions should read something like:   if  (is-objectReference-load  &&  hotness-testing && CPU-testing)\nApplies to the next change too.", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r552134144", "createdAt": "2021-01-05T19:06:14Z", "author": {"login": "zl-wang"}, "path": "runtime/compiler/p/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -403,7 +403,7 @@ J9::Power::CodeGenerator::insertPrefetchIfNecessary(TR::Node *node, TR::Register\n    static bool disableStringObjPrefetch = (feGetEnv(\"TR_DisableStringObjPrefetch\") != NULL);\n    bool optDisabled = false;\n \n-   if (node->getOpCodeValue() == TR::aloadi ||\n+   if ((node->getOpCodeValue() == TR::aloadi && !comp->target().is64Bit()) ||\n         (comp->target().is64Bit() &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "825ae5151f1c3710237427f8b898eae5bbae9ff6"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1MzI3OQ==", "bodyText": "While I agree that prefetching certainly could be applied in these circumstances, extending the prefetching optimization to handle this case correctly is out-of-scope for this PR. As the commit message clarifies, the previous implementation was not performing prefetching for such nodes either, but the way this was being achieved was slightly different. This change does not make prefetching not occur where it previously would, but simply makes insertPrefetchIfNecessary safe to call on aloadi nodes under 64-bit, as it would otherwise segfault.\nPreviously, we were simply failing to call insertPrefetchIfNecessary at all under the problematic conditions, thus sidestepping the problem. In commoning up code between the load evaluators into LoadStoreHandler, all of these evaluators need to behave uniformly and thus now call insertPrefetchIfNecessary unconditionally, with it being up to that method alone to make the decision as to whether to perform prefetching. This also avoids leaking implementation details of OpenJ9's prefetching into OMR.\nIf you'd like, I can open an issue for extending this support in the future, though.", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r552153279", "createdAt": "2021-01-05T19:42:32Z", "author": {"login": "aviansie-ben"}, "path": "runtime/compiler/p/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -403,7 +403,7 @@ J9::Power::CodeGenerator::insertPrefetchIfNecessary(TR::Node *node, TR::Register\n    static bool disableStringObjPrefetch = (feGetEnv(\"TR_DisableStringObjPrefetch\") != NULL);\n    bool optDisabled = false;\n \n-   if (node->getOpCodeValue() == TR::aloadi ||\n+   if ((node->getOpCodeValue() == TR::aloadi && !comp->target().is64Bit()) ||\n         (comp->target().is64Bit() &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzNDE0NA=="}, "originalCommit": {"oid": "825ae5151f1c3710237427f8b898eae5bbae9ff6"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjYzMDE0MQ==", "bodyText": "certainly need a follow-up item", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r552630141", "createdAt": "2021-01-06T13:50:33Z", "author": {"login": "zl-wang"}, "path": "runtime/compiler/p/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -403,7 +403,7 @@ J9::Power::CodeGenerator::insertPrefetchIfNecessary(TR::Node *node, TR::Register\n    static bool disableStringObjPrefetch = (feGetEnv(\"TR_DisableStringObjPrefetch\") != NULL);\n    bool optDisabled = false;\n \n-   if (node->getOpCodeValue() == TR::aloadi ||\n+   if ((node->getOpCodeValue() == TR::aloadi && !comp->target().is64Bit()) ||\n         (comp->target().is64Bit() &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzNDE0NA=="}, "originalCommit": {"oid": "825ae5151f1c3710237427f8b898eae5bbae9ff6"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU4ODgwNg==", "bodyText": "Opened #11803", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r565588806", "createdAt": "2021-01-27T19:48:45Z", "author": {"login": "aviansie-ben"}, "path": "runtime/compiler/p/codegen/J9CodeGenerator.cpp", "diffHunk": "@@ -403,7 +403,7 @@ J9::Power::CodeGenerator::insertPrefetchIfNecessary(TR::Node *node, TR::Register\n    static bool disableStringObjPrefetch = (feGetEnv(\"TR_DisableStringObjPrefetch\") != NULL);\n    bool optDisabled = false;\n \n-   if (node->getOpCodeValue() == TR::aloadi ||\n+   if ((node->getOpCodeValue() == TR::aloadi && !comp->target().is64Bit()) ||\n         (comp->target().is64Bit() &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzNDE0NA=="}, "originalCommit": {"oid": "825ae5151f1c3710237427f8b898eae5bbae9ff6"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMzkwNDQxOnYy", "diffSide": "RIGHT", "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNTo0OTo1NlrOIVu1Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQwNToyMzowNVrOIjp4JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw==", "bodyText": "@zl-wang is there any chance this assert can get triggered?", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r559658267", "createdAt": "2021-01-18T15:49:56Z", "author": {"login": "gita-omr"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7439,26 +7274,27 @@ static bool simpleReadMonitor(TR::Node *node, TR::CodeGenerator *cg, TR::Node *o\n       {\n       if (TR::Compiler->om.compressObjectReferences() && nextTopNode->getSymbol()->isClassObject())\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n          loadOpCode = TR::InstOpCode::lwz;\n          }\n       else\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 8);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 8);\n          loadOpCode = TR::InstOpCode::ld;\n          }\n       }\n    else\n       {\n-      tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+      tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n       loadOpCode = TR::InstOpCode::lwz;\n       }\n+   TR_ASSERT_FATAL_WITH_NODE(nextTopNode, !tempMR.getMemoryReference()->getIndexRegister(), \"Simple read monitors do not currently support indexed loads\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "688a9f3246c328e8d0e6368f913fa29d01cc69d1"}, "originalPosition": 449}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzEyMTY0OQ==", "bodyText": "since TR::LoadStoreHandler::generateSimpleLoadMemoryReference doesn't guarantee immediate-form addressing, it looks like potentially this assert can trigger.  On the other hand, the existing code didn't handle the indexRegister anyway (if it were present), so that it could be wrong already but not caught with assert. I would suggest removing this assert and staying the previous assumption for the time being, and open a follow-up item to handle the indexRegsiter if it becomes present.  as it is,  it likely works even if indexRegister is present. But this newly added assert will be a flare-up regression in the field (as the ConstantDataSnippet assert was). @aviansie-ben", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r567121649", "createdAt": "2021-01-29T22:11:32Z", "author": {"login": "zl-wang"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7439,26 +7274,27 @@ static bool simpleReadMonitor(TR::Node *node, TR::CodeGenerator *cg, TR::Node *o\n       {\n       if (TR::Compiler->om.compressObjectReferences() && nextTopNode->getSymbol()->isClassObject())\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n          loadOpCode = TR::InstOpCode::lwz;\n          }\n       else\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 8);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 8);\n          loadOpCode = TR::InstOpCode::ld;\n          }\n       }\n    else\n       {\n-      tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+      tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n       loadOpCode = TR::InstOpCode::lwz;\n       }\n+   TR_ASSERT_FATAL_WITH_NODE(nextTopNode, !tempMR.getMemoryReference()->getIndexRegister(), \"Simple read monitors do not currently support indexed loads\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}, "originalCommit": {"oid": "688a9f3246c328e8d0e6368f913fa29d01cc69d1"}, "originalPosition": 449}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTcxMDE4MQ==", "bodyText": "since TR::LoadStoreHandler::generateSimpleLoadMemoryReference doesn't guarantee immediate-form addressing, it looks like potentially this assert can trigger\n\nIn practice, this assert should never fire since the code above already checks that nextTopNode->getFirstChild() has been previously evaluated and generateSimpleLoadMemoryReference will never generate an index-form memory reference under these conditions unless one is explicitly requested. This assert is being added to document this assumption and to guard against any future changes that might violate it.\n\nas it is, it likely works even if indexRegister is present\n\nThe consequences of reaching this code with an index-form memory reference could be severe and result in very difficult-to-diagnose issues and possible security vulnerabilities. Firstly, the ICF register dependencies would not include the index register, so we'd potentially get spills in ICF. Secondly and much more worryingly, PPCReadMonitorSnippet (which is used as a fallback if the lock is already held when this code is entered) will always generate an immediate-form load and so would load at an offset of 0 from the base register, which will predictably load the J9Class of the object. If an attacker could cause a race condition to occur, they could reliably force a non-zero result from such a load, which could be a big problem if the value being loaded is a security-critical boolean.", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r569710181", "createdAt": "2021-02-03T20:02:43Z", "author": {"login": "aviansie-ben"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7439,26 +7274,27 @@ static bool simpleReadMonitor(TR::Node *node, TR::CodeGenerator *cg, TR::Node *o\n       {\n       if (TR::Compiler->om.compressObjectReferences() && nextTopNode->getSymbol()->isClassObject())\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n          loadOpCode = TR::InstOpCode::lwz;\n          }\n       else\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 8);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 8);\n          loadOpCode = TR::InstOpCode::ld;\n          }\n       }\n    else\n       {\n-      tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+      tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n       loadOpCode = TR::InstOpCode::lwz;\n       }\n+   TR_ASSERT_FATAL_WITH_NODE(nextTopNode, !tempMR.getMemoryReference()->getIndexRegister(), \"Simple read monitors do not currently support indexed loads\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}, "originalCommit": {"oid": "688a9f3246c328e8d0e6368f913fa29d01cc69d1"}, "originalPosition": 449}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTc0MDQwMQ==", "bodyText": "so, we agree the assert has no much value in catching a problematic case, but more for future-proof which i suggested opening a new PR to be addressed instead. for this merge in particular, it is just better off to get rid of this assert.", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r569740401", "createdAt": "2021-02-03T20:53:27Z", "author": {"login": "zl-wang"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7439,26 +7274,27 @@ static bool simpleReadMonitor(TR::Node *node, TR::CodeGenerator *cg, TR::Node *o\n       {\n       if (TR::Compiler->om.compressObjectReferences() && nextTopNode->getSymbol()->isClassObject())\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n          loadOpCode = TR::InstOpCode::lwz;\n          }\n       else\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 8);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 8);\n          loadOpCode = TR::InstOpCode::ld;\n          }\n       }\n    else\n       {\n-      tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+      tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n       loadOpCode = TR::InstOpCode::lwz;\n       }\n+   TR_ASSERT_FATAL_WITH_NODE(nextTopNode, !tempMR.getMemoryReference()->getIndexRegister(), \"Simple read monitors do not currently support indexed loads\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}, "originalCommit": {"oid": "688a9f3246c328e8d0e6368f913fa29d01cc69d1"}, "originalPosition": 449}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTc0NjM2NQ==", "bodyText": "No, we clearly do not agree. The whole point of an assert is to assert that the stated condition should not happen and to make sure that the compiler fails in a predictable manner if it ever does rather than simply generating garbage code that could wreak havoc on the running application. There is no need to open a new issue or PR here because this is a case that shouldn't happen and thus does not need to be handled.", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r569746365", "createdAt": "2021-02-03T21:03:28Z", "author": {"login": "aviansie-ben"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7439,26 +7274,27 @@ static bool simpleReadMonitor(TR::Node *node, TR::CodeGenerator *cg, TR::Node *o\n       {\n       if (TR::Compiler->om.compressObjectReferences() && nextTopNode->getSymbol()->isClassObject())\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n          loadOpCode = TR::InstOpCode::lwz;\n          }\n       else\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 8);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 8);\n          loadOpCode = TR::InstOpCode::ld;\n          }\n       }\n    else\n       {\n-      tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+      tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n       loadOpCode = TR::InstOpCode::lwz;\n       }\n+   TR_ASSERT_FATAL_WITH_NODE(nextTopNode, !tempMR.getMemoryReference()->getIndexRegister(), \"Simple read monitors do not currently support indexed loads\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}, "originalCommit": {"oid": "688a9f3246c328e8d0e6368f913fa29d01cc69d1"}, "originalPosition": 449}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTc3MTE4MQ==", "bodyText": "the problem is:  it is predictably fatal if it triggers.  we are very assert-wary ... high cost of service. as a matter of fact as of today, there are still outstanding assert PMRs for newly added assert to be addressed (iFix delivery) in some branches.\nit is not a regression without this assert (existing bug if indexed form), and it is a new regression with the assert.  better way moving forward: either you make it work for all cases, or we will fix the existing bug in the near future. we just don't want to deal with the potentially new regression.", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r569771181", "createdAt": "2021-02-03T21:44:33Z", "author": {"login": "zl-wang"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7439,26 +7274,27 @@ static bool simpleReadMonitor(TR::Node *node, TR::CodeGenerator *cg, TR::Node *o\n       {\n       if (TR::Compiler->om.compressObjectReferences() && nextTopNode->getSymbol()->isClassObject())\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n          loadOpCode = TR::InstOpCode::lwz;\n          }\n       else\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 8);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 8);\n          loadOpCode = TR::InstOpCode::ld;\n          }\n       }\n    else\n       {\n-      tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+      tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n       loadOpCode = TR::InstOpCode::lwz;\n       }\n+   TR_ASSERT_FATAL_WITH_NODE(nextTopNode, !tempMR.getMemoryReference()->getIndexRegister(), \"Simple read monitors do not currently support indexed loads\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}, "originalCommit": {"oid": "688a9f3246c328e8d0e6368f913fa29d01cc69d1"}, "originalPosition": 449}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDI1NzE4OQ==", "bodyText": "Frankly, I find your reasoning here to be misguided. IMO it is much better to crash in a predictable manner than to potentially exhibit wrong behaviour much later on and it being \"not a regression\" to exhibit wrong behaviour is a poor excuse. However, in the interests of moving this PR forward, I have removed the assert in this particular case. Do note that I don't intend on letting excuses of this nature fly in OMR, though, and I will continue to ensure that asserts are added as appropriate there.", "url": "https://github.com/eclipse-openj9/openj9/pull/11305#discussion_r574257189", "createdAt": "2021-02-11T05:23:05Z", "author": {"login": "aviansie-ben"}, "path": "runtime/compiler/p/codegen/J9TreeEvaluator.cpp", "diffHunk": "@@ -7439,26 +7274,27 @@ static bool simpleReadMonitor(TR::Node *node, TR::CodeGenerator *cg, TR::Node *o\n       {\n       if (TR::Compiler->om.compressObjectReferences() && nextTopNode->getSymbol()->isClassObject())\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n          loadOpCode = TR::InstOpCode::lwz;\n          }\n       else\n          {\n-         tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 8);\n+         tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 8);\n          loadOpCode = TR::InstOpCode::ld;\n          }\n       }\n    else\n       {\n-      tempMR = TR::MemoryReference::createWithRootLoadOrStore(cg, nextTopNode, 4);\n+      tempMR = TR::LoadStoreHandler::generateSimpleLoadMemoryReference(cg, nextTopNode, 4);\n       loadOpCode = TR::InstOpCode::lwz;\n       }\n+   TR_ASSERT_FATAL_WITH_NODE(nextTopNode, !tempMR.getMemoryReference()->getIndexRegister(), \"Simple read monitors do not currently support indexed loads\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1ODI2Nw=="}, "originalCommit": {"oid": "688a9f3246c328e8d0e6368f913fa29d01cc69d1"}, "originalPosition": 449}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 977, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}