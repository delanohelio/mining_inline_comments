{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5OTcxODI2", "number": 10651, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTowMTowNVrOEltD3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzoyNjo1MlrOEp5FCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTcxMDM2OnYy", "diffSide": "RIGHT", "path": "runtime/oti/j9nonbuilder.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTowMTowNVrOHVUrLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTowMTowNVrOHVUrLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEyMDg3Nw==", "bodyText": "I think this would be better without the ClassClass", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492120877", "createdAt": "2020-09-21T15:01:05Z", "author": {"login": "gacholio"}, "path": "runtime/oti/j9nonbuilder.h", "diffHunk": "@@ -81,6 +81,7 @@\n #define J9ClassIsExemptFromValidation 0x2000\n #define J9ClassContainsUnflattenedFlattenables 0x4000\n #define J9ClassCanSupportFastSubstitutability 0x8000\n+#define J9ClassClassHasReferences 0x10000", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec4387b4521eb91fa1c904311aab431765d8a8ca"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTcyMjY5OnYy", "diffSide": "RIGHT", "path": "runtime/vm/createramclass.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTowMjo1NVrOHVUzSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTowMjo1NVrOHVUzSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEyMjk1Mg==", "bodyText": "Should this not set the alignment constraint flag from above?", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492122952", "createdAt": "2020-09-21T15:02:55Z", "author": {"login": "gacholio"}, "path": "runtime/vm/createramclass.cpp", "diffHunk": "@@ -1868,12 +1868,15 @@ loadFlattenableFieldValueClasses(J9VMThread *currentThread, J9ClassLoader *class\n \t\t\t\t*valueTypeFlags |= J9ClassLargestAlignmentConstraintDouble;\n \t\t\t\tbreak;\n \t\t\tcase 'L':\n-\t\t\t\t*valueTypeFlags |= J9ClassLargestAlignmentConstraintReference;\n+\t\t\t\t*valueTypeFlags |= (J9ClassLargestAlignmentConstraintReference | J9ClassClassHasReferences);\n \t\t\t\teligibleForFastSubstitutability = false;\n \t\t\t\tbreak;\n \t\t\tcase 'F':\n \t\t\t\teligibleForFastSubstitutability = false;\n \t\t\t\tbreak;\n+\t\t\tcase '[':\n+\t\t\t\t*valueTypeFlags |= J9ClassClassHasReferences;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec4387b4521eb91fa1c904311aab431765d8a8ca"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA3OTcyOnYy", "diffSide": "RIGHT", "path": "runtime/vm/description.c", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjoxMDoyNlrOHVYWiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjoxMDoyNlrOHVYWiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4MTEzMQ==", "bodyText": "Comment.", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492181131", "createdAt": "2020-09-21T16:10:26Z", "author": {"login": "gacholio"}, "path": "runtime/vm/description.c", "diffHunk": "@@ -100,198 +104,208 @@ calculateInstanceDescription( J9VMThread *vmThread, J9Class *ramClass, J9Class *\n \t\tramClass->lockOffset =\twalkState->lockOffset;\n \t\tramClass->finalizeLinkOffset = walkState->finalizeLinkOffset;\n \t}\n-\t\n-\t/* convert all sizes from bytes to object slots */\n-\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n-\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n-\n-\t/* calculate number of slots required to store description bits */\n-\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n-\tshapeSlots = shapeSlots / slotsPerShapeElement;\n-\n-\t/* pick the space to store the description into */\n-\tif (totalSize < slotsPerShapeElement) {\n-\t\ttemp = 0;\n-\t\tshape = &temp;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp = 0;\n-\t\tleafShape = &leafTemp;\n-#endif\n-\t} else {\n-\t\t/* this storage will be in the ram class, which is zeroed for us */\n-\t\tshape = storage;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafShape = storage + shapeSlots;\n-#endif\n-\t}\n-\n-\t/* Copy superclass description */\n-\tif (ramSuperClass) {\n-\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n-\t\t\t/* superclass description is tagged and fits in one slot */\n-\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n-#endif\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\tif (hasReferences)\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t{\n+\t\t/* convert all sizes from bytes to object slots */\n+\t\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n+\t\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n+\n+\t\t/* calculate number of slots required to store description bits */\n+\t\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n+\t\tshapeSlots = shapeSlots / slotsPerShapeElement;\n+\n+\t\t/* pick the space to store the description into */\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\ttemp = 0;\n+\t\t\tshape = &temp;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafTemp = 0;\n+\t\t\tleafShape = &leafTemp;\n+\t#endif\n \t\t} else {\n-\t\t\t/* superclass description is stored indirect */\n-\t\t\tUDATA i, superSlots;\n-\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n-\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\t\t\t/* this storage will be in the ram class, which is zeroed for us */\n+\t\t\tshape = storage;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafShape = storage + shapeSlots;\n+\t#endif\n+\t\t}\n \n-\t\t\tfor (i = 0; i < superSlots; i++) {\n-\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n-#endif\n+\t\t/* Copy superclass description */\n+\t\tif (ramSuperClass) {\n+\t\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n+\t\t\t\t/* superclass description is tagged and fits in one slot */\n+\t\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n+\t#endif\n+\t\t\t} else {\n+\t\t\t\t/* superclass description is stored indirect */\n+\t\t\t\tUDATA i, superSlots;\n+\t\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n+\t\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\n+\t\t\t\tfor (i = 0; i < superSlots; i++) {\n+\t\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n+\t#endif\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n \n-\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n-\t\tif (shouldSaveSelfReferencingFields) {\n-\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n+\t\t\tif (shouldSaveSelfReferencingFields) {\n+\t\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\t/* calculate the description for this class - walk object instance fields and \n-\t * set the corresponding description bit for each \n-\t */\n-\t{\n-\t\twhile (walkResult->field) {\n-\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n-\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n-\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n-\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n-\n-\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n-\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n-\t\t\t */\n-\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n-\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n-\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n-\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t/* calculate the description for this class - walk object instance fields and\n+\t\t * set the corresponding description bit for each\n+\t\t */\n+\t\t{\n+\t\t\twhile (walkResult->field) {\n+\t\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n+\t\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n+\t\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n+\t\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n+\n+\t\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n+\t\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n+\t\t\t\t */\n+\t\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n+\t\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n+\t\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n+\t\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n \n #ifdef J9VM_OPT_VALHALLA_VALUE_TYPES\n-\t\t\tif ('Q' == *fieldSigBytes) {\n-\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n-\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n-\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n-\n-\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n-\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n-\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\t\tif (0 >= spillAmount) {\n-\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n-\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tUDATA bits = 0;\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\t/* remove low tag bit */\n-\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\tbits = (UDATA) description << shift;\n-\t\t\t\t\t\tshape[slotOffset] |= bits;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n-\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n-\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n-\t\t\t\t\t\t\tUDATA nextDescription = 0;\n-\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\t\t\t\tif ('Q' == *fieldSigBytes) {\n+\t\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n+\t\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n+\t\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n+\n+\t\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n+\t\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n+\t\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tif (0 >= spillAmount) {\n+\t\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n+\t\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n+\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\tUDATA bits = 0;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n \t\t\t\t\t\t\t/* remove low tag bit */\n \t\t\t\t\t\t\tdescription >>= 1;\n-\n-\t\t\t\t\t\t\tnextDescription = description;\n-\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n-\t\t\t\t\t\t\tdescription <<= shift;\n-\t\t\t\t\t\t\tshape[slotOffset] |= description;\n-\t\t\t\t\t\t\tslotOffset += 1;\n-\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\tbits = (UDATA) description << shift;\n+\t\t\t\t\t\t\tshape[slotOffset] |= bits;\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n-\t\t\t\t\t\t\t * one at a time. */\n-\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n-\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n-\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n-\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n-\n-\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\n-\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n-\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n-\t\t\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n-\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n-\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n+\t\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n+\t\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n+\t\t\t\t\t\t\t\tUDATA nextDescription = 0;\n+\t\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\n+\t\t\t\t\t\t\t\t/* remove low tag bit */\n+\t\t\t\t\t\t\t\tdescription >>= 1;\n \n-\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n-\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n-\t\t\t\t\t\t\t\t\tslotOffset++;\n-\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\tnextDescription = description;\n+\t\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n+\t\t\t\t\t\t\t\tdescription <<= shift;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= description;\n+\t\t\t\t\t\t\t\tslotOffset += 1;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n+\t\t\t\t\t\t\t\t * one at a time. */\n+\t\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n+\t\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n+\t\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n+\n+\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\n+\t\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n+\t\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n+\t\t\t\t\t\t\t\t\tdescription >>= 1;\n+\t\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\n+\t\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n+\t\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\t\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n+\t\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n+\t\t\t\t\t\t\t\t\t\tslotOffset++;\n+\t\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tshape[slotOffset] |= bit;\n \t\t\t\t\t}\n-\t\t\t\t} else {\n+\t\t\t\t} else\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t\t\t\t{\n \t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n \t\t\t\t\tshape[slotOffset] |= bit;\n-\t\t\t\t}\n-\t\t\t} else\n-#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n-\t\t\t{\n-\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\tshape[slotOffset] |= bit;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tif (isLeafField(walkResult->field)) {\n-\t\t\t\t\tleafShape[slotOffset] |= bit;\n-\t\t\t\t} else if (isString) {\n-\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n-\n-\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\tif (isLeafField(walkResult->field)) {\n \t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t} else if (isString) {\n+\t\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n+\n+\t\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t}\n #endif\n-\t\t\t}\n+\t\t\t\t}\n \n-\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\tif (totalSize < slotsPerShapeElement) {\n-\t\t/* tag low bit, store in place */\n-\t\ttemp <<= 1;\n-\t\ttemp |= 1;\n-\t\tramClass->instanceDescription = (UDATA *)temp;\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\t/* tag low bit, store in place */\n+\t\t\ttemp <<= 1;\n+\t\t\ttemp |= 1;\n+\t\t\tramClass->instanceDescription = (UDATA *)temp;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp <<= 1;\n-\t\tleafTemp |= 1;\n-\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n+\t\t\tleafTemp <<= 1;\n+\t\t\tleafTemp |= 1;\n+\t\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n #endif\n-\n-\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n-\t} else {\n-\t\t/* used extra space, store the address */\n-\t\tramClass->instanceDescription = storage;\n+\t\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n+\t\t} else {\n+\t\t\t/* used extra space, store the address */\n+\t\t\tramClass->instanceDescription = storage;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n-\n-\t\tTrc_VM_calculateInstanceDescription_indirectResult(NULL, storage[0]);\n+\t\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n+#endif", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec4387b4521eb91fa1c904311aab431765d8a8ca"}, "originalPosition": 371}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA4MTExOnYy", "diffSide": "RIGHT", "path": "runtime/vm/description.c", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjoxMDo0NFrOHVYXcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjoxMDo0NFrOHVYXcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4MTM2Mg==", "bodyText": "Comment.", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492181362", "createdAt": "2020-09-21T16:10:44Z", "author": {"login": "gacholio"}, "path": "runtime/vm/description.c", "diffHunk": "@@ -100,198 +104,208 @@ calculateInstanceDescription( J9VMThread *vmThread, J9Class *ramClass, J9Class *\n \t\tramClass->lockOffset =\twalkState->lockOffset;\n \t\tramClass->finalizeLinkOffset = walkState->finalizeLinkOffset;\n \t}\n-\t\n-\t/* convert all sizes from bytes to object slots */\n-\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n-\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n-\n-\t/* calculate number of slots required to store description bits */\n-\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n-\tshapeSlots = shapeSlots / slotsPerShapeElement;\n-\n-\t/* pick the space to store the description into */\n-\tif (totalSize < slotsPerShapeElement) {\n-\t\ttemp = 0;\n-\t\tshape = &temp;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp = 0;\n-\t\tleafShape = &leafTemp;\n-#endif\n-\t} else {\n-\t\t/* this storage will be in the ram class, which is zeroed for us */\n-\t\tshape = storage;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafShape = storage + shapeSlots;\n-#endif\n-\t}\n-\n-\t/* Copy superclass description */\n-\tif (ramSuperClass) {\n-\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n-\t\t\t/* superclass description is tagged and fits in one slot */\n-\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n-#endif\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\tif (hasReferences)\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t{\n+\t\t/* convert all sizes from bytes to object slots */\n+\t\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n+\t\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n+\n+\t\t/* calculate number of slots required to store description bits */\n+\t\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n+\t\tshapeSlots = shapeSlots / slotsPerShapeElement;\n+\n+\t\t/* pick the space to store the description into */\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\ttemp = 0;\n+\t\t\tshape = &temp;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafTemp = 0;\n+\t\t\tleafShape = &leafTemp;\n+\t#endif\n \t\t} else {\n-\t\t\t/* superclass description is stored indirect */\n-\t\t\tUDATA i, superSlots;\n-\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n-\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\t\t\t/* this storage will be in the ram class, which is zeroed for us */\n+\t\t\tshape = storage;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafShape = storage + shapeSlots;\n+\t#endif\n+\t\t}\n \n-\t\t\tfor (i = 0; i < superSlots; i++) {\n-\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n-#endif\n+\t\t/* Copy superclass description */\n+\t\tif (ramSuperClass) {\n+\t\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n+\t\t\t\t/* superclass description is tagged and fits in one slot */\n+\t\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n+\t#endif\n+\t\t\t} else {\n+\t\t\t\t/* superclass description is stored indirect */\n+\t\t\t\tUDATA i, superSlots;\n+\t\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n+\t\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\n+\t\t\t\tfor (i = 0; i < superSlots; i++) {\n+\t\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n+\t#endif\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n \n-\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n-\t\tif (shouldSaveSelfReferencingFields) {\n-\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n+\t\t\tif (shouldSaveSelfReferencingFields) {\n+\t\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\t/* calculate the description for this class - walk object instance fields and \n-\t * set the corresponding description bit for each \n-\t */\n-\t{\n-\t\twhile (walkResult->field) {\n-\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n-\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n-\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n-\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n-\n-\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n-\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n-\t\t\t */\n-\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n-\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n-\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n-\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t/* calculate the description for this class - walk object instance fields and\n+\t\t * set the corresponding description bit for each\n+\t\t */\n+\t\t{\n+\t\t\twhile (walkResult->field) {\n+\t\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n+\t\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n+\t\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n+\t\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n+\n+\t\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n+\t\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n+\t\t\t\t */\n+\t\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n+\t\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n+\t\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n+\t\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n \n #ifdef J9VM_OPT_VALHALLA_VALUE_TYPES\n-\t\t\tif ('Q' == *fieldSigBytes) {\n-\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n-\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n-\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n-\n-\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n-\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n-\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\t\tif (0 >= spillAmount) {\n-\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n-\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tUDATA bits = 0;\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\t/* remove low tag bit */\n-\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\tbits = (UDATA) description << shift;\n-\t\t\t\t\t\tshape[slotOffset] |= bits;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n-\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n-\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n-\t\t\t\t\t\t\tUDATA nextDescription = 0;\n-\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\t\t\t\tif ('Q' == *fieldSigBytes) {\n+\t\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n+\t\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n+\t\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n+\n+\t\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n+\t\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n+\t\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tif (0 >= spillAmount) {\n+\t\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n+\t\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n+\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\tUDATA bits = 0;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n \t\t\t\t\t\t\t/* remove low tag bit */\n \t\t\t\t\t\t\tdescription >>= 1;\n-\n-\t\t\t\t\t\t\tnextDescription = description;\n-\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n-\t\t\t\t\t\t\tdescription <<= shift;\n-\t\t\t\t\t\t\tshape[slotOffset] |= description;\n-\t\t\t\t\t\t\tslotOffset += 1;\n-\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\tbits = (UDATA) description << shift;\n+\t\t\t\t\t\t\tshape[slotOffset] |= bits;\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n-\t\t\t\t\t\t\t * one at a time. */\n-\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n-\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n-\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n-\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n-\n-\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\n-\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n-\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n-\t\t\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n-\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n-\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n+\t\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n+\t\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n+\t\t\t\t\t\t\t\tUDATA nextDescription = 0;\n+\t\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\n+\t\t\t\t\t\t\t\t/* remove low tag bit */\n+\t\t\t\t\t\t\t\tdescription >>= 1;\n \n-\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n-\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n-\t\t\t\t\t\t\t\t\tslotOffset++;\n-\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\tnextDescription = description;\n+\t\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n+\t\t\t\t\t\t\t\tdescription <<= shift;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= description;\n+\t\t\t\t\t\t\t\tslotOffset += 1;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n+\t\t\t\t\t\t\t\t * one at a time. */\n+\t\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n+\t\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n+\t\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n+\n+\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\n+\t\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n+\t\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n+\t\t\t\t\t\t\t\t\tdescription >>= 1;\n+\t\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\n+\t\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n+\t\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\t\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n+\t\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n+\t\t\t\t\t\t\t\t\t\tslotOffset++;\n+\t\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tshape[slotOffset] |= bit;\n \t\t\t\t\t}\n-\t\t\t\t} else {\n+\t\t\t\t} else\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t\t\t\t{\n \t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n \t\t\t\t\tshape[slotOffset] |= bit;\n-\t\t\t\t}\n-\t\t\t} else\n-#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n-\t\t\t{\n-\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\tshape[slotOffset] |= bit;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tif (isLeafField(walkResult->field)) {\n-\t\t\t\t\tleafShape[slotOffset] |= bit;\n-\t\t\t\t} else if (isString) {\n-\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n-\n-\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\tif (isLeafField(walkResult->field)) {\n \t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t} else if (isString) {\n+\t\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n+\n+\t\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t}\n #endif\n-\t\t\t}\n+\t\t\t\t}\n \n-\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\tif (totalSize < slotsPerShapeElement) {\n-\t\t/* tag low bit, store in place */\n-\t\ttemp <<= 1;\n-\t\ttemp |= 1;\n-\t\tramClass->instanceDescription = (UDATA *)temp;\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\t/* tag low bit, store in place */\n+\t\t\ttemp <<= 1;\n+\t\t\ttemp |= 1;\n+\t\t\tramClass->instanceDescription = (UDATA *)temp;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp <<= 1;\n-\t\tleafTemp |= 1;\n-\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n+\t\t\tleafTemp <<= 1;\n+\t\t\tleafTemp |= 1;\n+\t\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n #endif\n-\n-\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n-\t} else {\n-\t\t/* used extra space, store the address */\n-\t\tramClass->instanceDescription = storage;\n+\t\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n+\t\t} else {\n+\t\t\t/* used extra space, store the address */\n+\t\t\tramClass->instanceDescription = storage;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n-\n-\t\tTrc_VM_calculateInstanceDescription_indirectResult(NULL, storage[0]);\n+\t\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n+#endif\n+\t\t\tTrc_VM_calculateInstanceDescription_indirectResult(NULL, storage[0]);\n+\t\t}\n+\t}\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\telse {\n+\t\tramClass->instanceDescription = (UDATA *)(UDATA)1;\n+#ifdef J9VM_GC_LEAF_BITS\n+\t\tramClass->instanceLeafDescription = (UDATA *)(UDATA)1;\n #endif", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec4387b4521eb91fa1c904311aab431765d8a8ca"}, "originalPosition": 380}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA4MTc0OnYy", "diffSide": "RIGHT", "path": "runtime/vm/description.c", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjoxMDo1NlrOHVYX8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjoxMDo1NlrOHVYX8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4MTQ5MQ==", "bodyText": "Should be if defined", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492181491", "createdAt": "2020-09-21T16:10:56Z", "author": {"login": "gacholio"}, "path": "runtime/vm/description.c", "diffHunk": "@@ -100,198 +104,208 @@ calculateInstanceDescription( J9VMThread *vmThread, J9Class *ramClass, J9Class *\n \t\tramClass->lockOffset =\twalkState->lockOffset;\n \t\tramClass->finalizeLinkOffset = walkState->finalizeLinkOffset;\n \t}\n-\t\n-\t/* convert all sizes from bytes to object slots */\n-\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n-\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n-\n-\t/* calculate number of slots required to store description bits */\n-\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n-\tshapeSlots = shapeSlots / slotsPerShapeElement;\n-\n-\t/* pick the space to store the description into */\n-\tif (totalSize < slotsPerShapeElement) {\n-\t\ttemp = 0;\n-\t\tshape = &temp;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp = 0;\n-\t\tleafShape = &leafTemp;\n-#endif\n-\t} else {\n-\t\t/* this storage will be in the ram class, which is zeroed for us */\n-\t\tshape = storage;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\tleafShape = storage + shapeSlots;\n-#endif\n-\t}\n-\n-\t/* Copy superclass description */\n-\tif (ramSuperClass) {\n-\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n-\t\t\t/* superclass description is tagged and fits in one slot */\n-\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n-#endif\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\tif (hasReferences)\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t{\n+\t\t/* convert all sizes from bytes to object slots */\n+\t\tsuperClassSize = walkResult->superTotalInstanceSize / referenceSize;\n+\t\ttotalSize = walkResult->totalInstanceSize / referenceSize;\n+\n+\t\t/* calculate number of slots required to store description bits */\n+\t\tshapeSlots = ROUND_UP_TO_POWEROF2(totalSize, slotsPerShapeElement);\n+\t\tshapeSlots = shapeSlots / slotsPerShapeElement;\n+\n+\t\t/* pick the space to store the description into */\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\ttemp = 0;\n+\t\t\tshape = &temp;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafTemp = 0;\n+\t\t\tleafShape = &leafTemp;\n+\t#endif\n \t\t} else {\n-\t\t\t/* superclass description is stored indirect */\n-\t\t\tUDATA i, superSlots;\n-\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n-\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\t\t\t/* this storage will be in the ram class, which is zeroed for us */\n+\t\t\tshape = storage;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\tleafShape = storage + shapeSlots;\n+\t#endif\n+\t\t}\n \n-\t\t\tfor (i = 0; i < superSlots; i++) {\n-\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n-#ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n-#endif\n+\t\t/* Copy superclass description */\n+\t\tif (ramSuperClass) {\n+\t\t\tif ((UDATA)ramSuperClass->instanceDescription & 1) {\n+\t\t\t\t/* superclass description is tagged and fits in one slot */\n+\t\t\t\t*shape = (UDATA)ramSuperClass->instanceDescription >> 1;\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t*leafShape = (UDATA)ramSuperClass->instanceLeafDescription >> 1;\n+\t#endif\n+\t\t\t} else {\n+\t\t\t\t/* superclass description is stored indirect */\n+\t\t\t\tUDATA i, superSlots;\n+\t\t\t\tsuperSlots = ROUND_UP_TO_POWEROF2(superClassSize, slotsPerShapeElement);\n+\t\t\t\tsuperSlots = superSlots / slotsPerShapeElement;\n+\n+\t\t\t\tfor (i = 0; i < superSlots; i++) {\n+\t\t\t\t\tshape[i] = ramSuperClass->instanceDescription[i];\n+\t#ifdef J9VM_GC_LEAF_BITS\n+\t\t\t\t\tleafShape[i] = ramSuperClass->instanceLeafDescription[i];\n+\t#endif\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n \n-\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n-\t\tif (shouldSaveSelfReferencingFields) {\n-\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t/* If there are self referencing field offsets being inherited then self referencing fields of this class should be ignored.*/\n+\t\t\tif (shouldSaveSelfReferencingFields) {\n+\t\t\t\tshouldSaveSelfReferencingFields = (ramSuperClass->selfReferencingField1 == 0);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\t/* calculate the description for this class - walk object instance fields and \n-\t * set the corresponding description bit for each \n-\t */\n-\t{\n-\t\twhile (walkResult->field) {\n-\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n-\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n-\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n-\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n-\n-\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n-\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n-\t\t\t */\n-\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n-\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n-\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n-\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t/* calculate the description for this class - walk object instance fields and\n+\t\t * set the corresponding description bit for each\n+\t\t */\n+\t\t{\n+\t\t\twhile (walkResult->field) {\n+\t\t\t\tUDATA slotOffset = walkResult->offset / (referenceSize * slotsPerShapeElement);\n+\t\t\t\tJ9UTF8 *fieldSig = J9ROMFIELDSHAPE_SIGNATURE(walkResult->field);\n+\t\t\t\tU_8 *fieldSigBytes = J9UTF8_DATA(fieldSig);\n+\t\t\t\tU_16 fieldSigLength = J9UTF8_LENGTH(fieldSig);\n+\n+\t\t\t\t/* If the field is self referencing then store the offset to it (at most 2). Self referencing fields\n+\t\t\t\t * are to be scanned with priority during GC. Both self referencing fields must be from the same class.\n+\t\t\t\t */\n+\t\t\t\tif (shouldSaveSelfReferencingFields && ((ramClass->selfReferencingField1 == 0) || (ramClass->selfReferencingField2 == 0))) {\n+\t\t\t\t\tif (J9UTF8_DATA_EQUALS(J9UTF8_DATA(className), J9UTF8_LENGTH(className), fieldSigBytes + 1, fieldSigLength - 2)) {\n+\t\t\t\t\t\tif (ramClass->selfReferencingField1 == 0) {\n+\t\t\t\t\t\t\tramClass->selfReferencingField1 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tramClass->selfReferencingField2 = walkResult->offset + objectHeaderSize;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n \n #ifdef J9VM_OPT_VALHALLA_VALUE_TYPES\n-\t\t\tif ('Q' == *fieldSigBytes) {\n-\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n-\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n-\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n-\n-\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n-\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n-\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\t\tif (0 >= spillAmount) {\n-\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n-\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tUDATA bits = 0;\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\t/* remove low tag bit */\n-\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\tbits = (UDATA) description << shift;\n-\t\t\t\t\t\tshape[slotOffset] |= bits;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n-\n-\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n-\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n-\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n-\t\t\t\t\t\t\tUDATA nextDescription = 0;\n-\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\t\t\t\tif ('Q' == *fieldSigBytes) {\n+\t\t\t\t\tJ9Class *fieldClass = walkResult->flattenedClass;\n+\t\t\t\t\tif ((NULL != fieldClass) && J9_ARE_ALL_BITS_SET(fieldClass->classFlags, J9ClassIsFlattened)) {\n+\t\t\t\t\t\tUDATA size = fieldClass->totalInstanceSize;\n+\n+\t\t\t\t\t\t/* positive means the field will spill over to the next slot in the shape array */\n+\t\t\t\t\t\tIDATA spillAmount = ((walkResult->offset + size) - (slotOffset * (referenceSize * slotsPerShapeElement))) - (referenceSize * slotsPerShapeElement);\n+\t\t\t\t\t\tUDATA shift = ((walkResult->offset  % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tif (0 >= spillAmount) {\n+\t\t\t\t\t\t\t/* If we are here this means the description bits for the field fits within the current\n+\t\t\t\t\t\t\t * slot shape word. This also means they are all low tagged.\n+\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\tUDATA bits = 0;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n \t\t\t\t\t\t\t/* remove low tag bit */\n \t\t\t\t\t\t\tdescription >>= 1;\n-\n-\t\t\t\t\t\t\tnextDescription = description;\n-\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n-\t\t\t\t\t\t\tdescription <<= shift;\n-\t\t\t\t\t\t\tshape[slotOffset] |= description;\n-\t\t\t\t\t\t\tslotOffset += 1;\n-\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\tbits = (UDATA) description << shift;\n+\t\t\t\t\t\t\tshape[slotOffset] |= bits;\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n-\t\t\t\t\t\t\t * one at a time. */\n-\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n-\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n-\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n-\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n-\n-\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\n-\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n-\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n-\t\t\t\t\t\t\t\tdescription >>= 1;\n-\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\t\t\t\t\t\t\tUDATA description = (UDATA) fieldClass->instanceDescription;\n \n-\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n-\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n-\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n-\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(description, 1)) {\n+\t\t\t\t\t\t\t\t/* simple case where the field has less than 64 (or 32 slots if in 32bit mode) slots. Split the instance\n+\t\t\t\t\t\t\t\t * bits into two parts, put the first part at the current slot offset put the last part in the next one */\n+\t\t\t\t\t\t\t\tUDATA nextDescription = 0;\n+\t\t\t\t\t\t\t\tUDATA spillBits = spillAmount/referenceSize;\n+\n+\t\t\t\t\t\t\t\t/* remove low tag bit */\n+\t\t\t\t\t\t\t\tdescription >>= 1;\n \n-\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n-\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n-\t\t\t\t\t\t\t\t\tslotOffset++;\n-\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\tnextDescription = description;\n+\t\t\t\t\t\t\t\tnextDescription >>= ((size/referenceSize) - spillBits);\n+\t\t\t\t\t\t\t\tdescription <<= shift;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= description;\n+\t\t\t\t\t\t\t\tslotOffset += 1;\n+\t\t\t\t\t\t\t\tshape[slotOffset] |= nextDescription;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t/* complex case were field is larger than 64 slots. Just add the bits\n+\t\t\t\t\t\t\t\t * one at a time. */\n+\t\t\t\t\t\t\t\tUDATA *descriptionPtr = (UDATA *)description;\n+\t\t\t\t\t\t\t\tUDATA totalAmountLeft = size/referenceSize;\n+\t\t\t\t\t\t\t\tUDATA positionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\tUDATA bitsLeftInShapeSlot = slotsPerShapeElement - shift;\n+\n+\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\n+\t\t\t\t\t\t\t\twhile (totalAmountLeft > 0) {\n+\t\t\t\t\t\t\t\t\tshape[slotOffset] |= (1 & description) << (slotsPerShapeElement - bitsLeftInShapeSlot);\n+\t\t\t\t\t\t\t\t\tdescription >>= 1;\n+\t\t\t\t\t\t\t\t\tpositionInDescriptionWord++;\n+\n+\t\t\t\t\t\t\t\t\tif (slotsPerShapeElement == positionInDescriptionWord) {\n+\t\t\t\t\t\t\t\t\t\tdescription = *descriptionPtr;\n+\t\t\t\t\t\t\t\t\t\tdescriptionPtr += 1;\n+\t\t\t\t\t\t\t\t\t\tpositionInDescriptionWord = 0;\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot--;\n+\t\t\t\t\t\t\t\t\tif (0 == bitsLeftInShapeSlot) {\n+\t\t\t\t\t\t\t\t\t\tslotOffset++;\n+\t\t\t\t\t\t\t\t\t\tbitsLeftInShapeSlot = 64;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\ttotalAmountLeft--;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n+\t\t\t\t\t\tshape[slotOffset] |= bit;\n \t\t\t\t\t}\n-\t\t\t\t} else {\n+\t\t\t\t} else\n+#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n+\t\t\t\t{\n \t\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n \t\t\t\t\tshape[slotOffset] |= bit;\n-\t\t\t\t}\n-\t\t\t} else\n-#endif /* J9VM_OPT_VALHALLA_VALUE_TYPES */\n-\t\t\t{\n-\t\t\t\tUDATA bit = (UDATA)1 << ((walkResult->offset % (referenceSize * slotsPerShapeElement)) / referenceSize);\n-\t\t\t\tshape[slotOffset] |= bit;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\t\t\tif (isLeafField(walkResult->field)) {\n-\t\t\t\t\tleafShape[slotOffset] |= bit;\n-\t\t\t\t} else if (isString) {\n-\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n-\n-\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\tif (isLeafField(walkResult->field)) {\n \t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t} else if (isString) {\n+\t\t\t\t\t\tJ9UTF8 *fieldName = J9ROMFIELDSHAPE_NAME(walkResult->field);\n+\n+\t\t\t\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(fieldName), J9UTF8_LENGTH(fieldName), \"value\")) {\n+\t\t\t\t\t\t\tleafShape[slotOffset] |= bit;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t}\n #endif\n-\t\t\t}\n+\t\t\t\t}\n \n-\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t\twalkResult = fieldOffsetsNextDo(walkState);\n+\t\t\t}\n \t\t}\n-\t}\n \n-\tif (totalSize < slotsPerShapeElement) {\n-\t\t/* tag low bit, store in place */\n-\t\ttemp <<= 1;\n-\t\ttemp |= 1;\n-\t\tramClass->instanceDescription = (UDATA *)temp;\n+\t\tif (totalSize < slotsPerShapeElement) {\n+\t\t\t/* tag low bit, store in place */\n+\t\t\ttemp <<= 1;\n+\t\t\ttemp |= 1;\n+\t\t\tramClass->instanceDescription = (UDATA *)temp;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tleafTemp <<= 1;\n-\t\tleafTemp |= 1;\n-\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n+\t\t\tleafTemp <<= 1;\n+\t\t\tleafTemp |= 1;\n+\t\t\tramClass->instanceLeafDescription = (UDATA *)leafTemp;\n #endif\n-\n-\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n-\t} else {\n-\t\t/* used extra space, store the address */\n-\t\tramClass->instanceDescription = storage;\n+\t\t\tTrc_VM_calculateInstanceDescription_taggedResult(NULL, temp);\n+\t\t} else {\n+\t\t\t/* used extra space, store the address */\n+\t\t\tramClass->instanceDescription = storage;\n #ifdef J9VM_GC_LEAF_BITS\n-\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n-\n-\t\tTrc_VM_calculateInstanceDescription_indirectResult(NULL, storage[0]);\n+\t\t\tramClass->instanceLeafDescription = storage + shapeSlots;\n+#endif\n+\t\t\tTrc_VM_calculateInstanceDescription_indirectResult(NULL, storage[0]);\n+\t\t}\n+\t}\n+#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n+\telse {\n+\t\tramClass->instanceDescription = (UDATA *)(UDATA)1;\n+#ifdef J9VM_GC_LEAF_BITS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec4387b4521eb91fa1c904311aab431765d8a8ca"}, "originalPosition": 378}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDIxNzEzOnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToxMTo1NlrOHV_HQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToxMTo1NlrOHV_HQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgxNjE5NA==", "bodyText": "This check is not needed here, and in fact is more future proof to not have it. Also we may for example have a (non-GC functional) barrier that profiles accesses for primitive types.", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492816194", "createdAt": "2020-09-22T15:11:56Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -436,10 +436,13 @@ class MM_ObjectAccessBarrierAPI\n \tVMINLINE void\n \tcopyObjectFields(J9VMThread *vmThread, J9Class *objectClass, j9object_t srcObject, UDATA srcOffset, j9object_t destObject, UDATA destOffset)\n \t{\n+\t\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n #if defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER)\n-\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n-#else /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n-\t\tif (j9gc_modron_readbar_none != _readBarrierType) {\t\n+\t\tif (hasReferences) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec4387b4521eb91fa1c904311aab431765d8a8ca"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDI2NzkyOnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToyMDo0OFrOHV_muw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjoyNzo0OVrOHWCmxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNDI1MQ==", "bodyText": "@RSalman This needs to be fixed eventually. This path should not be allowed if WB type is SATB.", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492824251", "createdAt": "2020-09-22T15:20:48Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -436,10 +436,13 @@ class MM_ObjectAccessBarrierAPI\n \tVMINLINE void\n \tcopyObjectFields(J9VMThread *vmThread, J9Class *objectClass, j9object_t srcObject, UDATA srcOffset, j9object_t destObject, UDATA destOffset)\n \t{\n+\t\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n #if defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER)\n-\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n-#else /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n-\t\tif (j9gc_modron_readbar_none != _readBarrierType) {\t\n+\t\tif (hasReferences) {\n+\t\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n+\t\t} else\n+#endif /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n+\t\tif (hasReferences && (j9gc_modron_readbar_none != _readBarrierType)) {\n \t\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n \t\t} else {\n \t\t\tUDATA offset = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec4387b4521eb91fa1c904311aab431765d8a8ca"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg3MzQxMw==", "bodyText": "Noted to address this as part of SATB work", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492873413", "createdAt": "2020-09-22T16:27:49Z", "author": {"login": "RSalman"}, "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -436,10 +436,13 @@ class MM_ObjectAccessBarrierAPI\n \tVMINLINE void\n \tcopyObjectFields(J9VMThread *vmThread, J9Class *objectClass, j9object_t srcObject, UDATA srcOffset, j9object_t destObject, UDATA destOffset)\n \t{\n+\t\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n #if defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER)\n-\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n-#else /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n-\t\tif (j9gc_modron_readbar_none != _readBarrierType) {\t\n+\t\tif (hasReferences) {\n+\t\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n+\t\t} else\n+#endif /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n+\t\tif (hasReferences && (j9gc_modron_readbar_none != _readBarrierType)) {\n \t\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n \t\t} else {\n \t\t\tUDATA offset = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNDI1MQ=="}, "originalCommit": {"oid": "ec4387b4521eb91fa1c904311aab431765d8a8ca"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDM1ODEzOnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTozODoyMlrOHWAdjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTozODoyMlrOHWAdjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzODI4Ng==", "bodyText": "I'm on a fence even if hasReferences is needed here, but let's leave it.\nHowever, the check was not quite complete. It was missing  '.... || (j9gc_modron_wrtbar_always == _writeBarrierType)' (see how we treat stores)\nPlease, fix it while here.", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r492838286", "createdAt": "2020-09-22T15:38:22Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -436,10 +436,13 @@ class MM_ObjectAccessBarrierAPI\n \tVMINLINE void\n \tcopyObjectFields(J9VMThread *vmThread, J9Class *objectClass, j9object_t srcObject, UDATA srcOffset, j9object_t destObject, UDATA destOffset)\n \t{\n+\t\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n #if defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER)\n-\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n-#else /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n-\t\tif (j9gc_modron_readbar_none != _readBarrierType) {\t\n+\t\tif (hasReferences) {\n+\t\t\tvmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_copyObjectFields(vmThread, objectClass, srcObject, srcOffset, destObject, destOffset);\n+\t\t} else\n+#endif /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n+\t\tif (hasReferences && (j9gc_modron_readbar_none != _readBarrierType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec4387b4521eb91fa1c904311aab431765d8a8ca"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTA1NDU5OnYy", "diffSide": "RIGHT", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTowNDoxOVrOHaiHnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTowNjoxNFrOHaiNag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NDAyOQ==", "bodyText": "Space after if.", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r497584029", "createdAt": "2020-09-30T15:04:19Z", "author": {"login": "gacholio"}, "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1393,52 +1393,72 @@ BOOLEAN\n MM_ObjectAccessBarrier::structuralCompareFlattenedObjects(J9VMThread *vmThread, J9Class *valueClass, j9object_t lhsObject, j9object_t rhsObject, UDATA startOffset)\n {\n \tbool result = true;\n-\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n \tbool const compressed = J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(vmThread);\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\tUDATA limit = valueClass->totalInstanceSize;\n+\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n+\tUDATA offset = 0;\n \n \tAssert_MM_true(J9_IS_J9CLASS_VALUETYPE(valueClass));\n \n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n+\tif (hasReferences) {\n+\t\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\t\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n \n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n-\tUDATA offset = 0;\n-\tUDATA limit = valueClass->totalInstanceSize;\n+\t\tif (0 != firstFieldOffset) {\n+\t\t\t/* subtract padding */\n+\t\t\toffset += firstFieldOffset;\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tdescriptionIndex -= 1;\n+\t\t}\n \n-\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n-\tif (0 != firstFieldOffset) {\n-\t\t/* subtract padding */\n-\t\toffset += firstFieldOffset;\n-\t\tdescriptionBits >>= 1;\n-\t\tdescriptionIndex -= 1;\n-\t}\n+\t\tif(((UDATA)descriptionPtr) & 1) {\n+\t\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n+\t\t} else {\n+\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t}\n \n-\twhile (offset < limit) {\n-\t\t/* Determine if the slot contains an object pointer or not */\n-\t\tif(descriptionBits & 1) {\n-\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n-\t\t\t\tresult = false;\n-\t\t\t\tbreak;\n+\n+\t\twhile (offset < limit) {\n+\t\t\t/* Determine if the slot contains an object pointer or not */\n+\t\t\tif(descriptionBits & 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0058787a43610bbe517af08c305f72f8206e9f49"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NTUxNA==", "bodyText": "I'll withdraw these as they appeared in the original code.", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r497585514", "createdAt": "2020-09-30T15:06:14Z", "author": {"login": "gacholio"}, "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1393,52 +1393,72 @@ BOOLEAN\n MM_ObjectAccessBarrier::structuralCompareFlattenedObjects(J9VMThread *vmThread, J9Class *valueClass, j9object_t lhsObject, j9object_t rhsObject, UDATA startOffset)\n {\n \tbool result = true;\n-\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n \tbool const compressed = J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(vmThread);\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\tUDATA limit = valueClass->totalInstanceSize;\n+\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n+\tUDATA offset = 0;\n \n \tAssert_MM_true(J9_IS_J9CLASS_VALUETYPE(valueClass));\n \n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n+\tif (hasReferences) {\n+\t\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\t\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n \n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n-\tUDATA offset = 0;\n-\tUDATA limit = valueClass->totalInstanceSize;\n+\t\tif (0 != firstFieldOffset) {\n+\t\t\t/* subtract padding */\n+\t\t\toffset += firstFieldOffset;\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tdescriptionIndex -= 1;\n+\t\t}\n \n-\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n-\tif (0 != firstFieldOffset) {\n-\t\t/* subtract padding */\n-\t\toffset += firstFieldOffset;\n-\t\tdescriptionBits >>= 1;\n-\t\tdescriptionIndex -= 1;\n-\t}\n+\t\tif(((UDATA)descriptionPtr) & 1) {\n+\t\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n+\t\t} else {\n+\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t}\n \n-\twhile (offset < limit) {\n-\t\t/* Determine if the slot contains an object pointer or not */\n-\t\tif(descriptionBits & 1) {\n-\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n-\t\t\t\tresult = false;\n-\t\t\t\tbreak;\n+\n+\t\twhile (offset < limit) {\n+\t\t\t/* Determine if the slot contains an object pointer or not */\n+\t\t\tif(descriptionBits & 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NDAyOQ=="}, "originalCommit": {"oid": "0058787a43610bbe517af08c305f72f8206e9f49"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTA1NTU0OnYy", "diffSide": "RIGHT", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTowNDoyOVrOHaiILA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTowNDoyOVrOHaiILA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NDE3Mg==", "bodyText": "Space after if", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r497584172", "createdAt": "2020-09-30T15:04:29Z", "author": {"login": "gacholio"}, "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1393,52 +1393,72 @@ BOOLEAN\n MM_ObjectAccessBarrier::structuralCompareFlattenedObjects(J9VMThread *vmThread, J9Class *valueClass, j9object_t lhsObject, j9object_t rhsObject, UDATA startOffset)\n {\n \tbool result = true;\n-\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n \tbool const compressed = J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(vmThread);\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\tUDATA limit = valueClass->totalInstanceSize;\n+\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n+\tUDATA offset = 0;\n \n \tAssert_MM_true(J9_IS_J9CLASS_VALUETYPE(valueClass));\n \n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n+\tif (hasReferences) {\n+\t\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\t\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n \n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n-\tUDATA offset = 0;\n-\tUDATA limit = valueClass->totalInstanceSize;\n+\t\tif (0 != firstFieldOffset) {\n+\t\t\t/* subtract padding */\n+\t\t\toffset += firstFieldOffset;\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tdescriptionIndex -= 1;\n+\t\t}\n \n-\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n-\tif (0 != firstFieldOffset) {\n-\t\t/* subtract padding */\n-\t\toffset += firstFieldOffset;\n-\t\tdescriptionBits >>= 1;\n-\t\tdescriptionIndex -= 1;\n-\t}\n+\t\tif(((UDATA)descriptionPtr) & 1) {\n+\t\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n+\t\t} else {\n+\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t}\n \n-\twhile (offset < limit) {\n-\t\t/* Determine if the slot contains an object pointer or not */\n-\t\tif(descriptionBits & 1) {\n-\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n-\t\t\t\tresult = false;\n-\t\t\t\tbreak;\n+\n+\t\twhile (offset < limit) {\n+\t\t\t/* Determine if the slot contains an object pointer or not */\n+\t\t\tif(descriptionBits & 1) {\n+\t\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n+\t\t\t\t\tresult = false;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfomrobject_t lhsValue = GC_SlotObject::readSlot((fomrobject_t*)((UDATA)lhsObject + startOffset + offset), compressed);\n+\t\t\t\tfomrobject_t rhsValue = GC_SlotObject::readSlot((fomrobject_t*)((UDATA)rhsObject + startOffset + offset), compressed);\n+\t\t\t\tif (lhsValue != rhsValue) {\n+\t\t\t\t\tresult = false;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t}\n-\t\t} else {\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tif(descriptionIndex-- == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0058787a43610bbe517af08c305f72f8206e9f49"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTA1NzQxOnYy", "diffSide": "RIGHT", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTowNDo1MVrOHaiJUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTowNDo1MVrOHaiJUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NDQ2Ng==", "bodyText": "Space after if", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r497584466", "createdAt": "2020-09-30T15:04:51Z", "author": {"login": "gacholio"}, "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1481,49 +1501,70 @@ MM_ObjectAccessBarrier::copyObjectFields(J9VMThread *vmThread, J9Class *objectCl\n \t\t}\n \t}\n \n-\tconst UDATA *descriptionPtr = (UDATA *) objectClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n-\n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n \tUDATA offset = 0;\n \tUDATA limit = objectClass->totalInstanceSize;\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n+\tU_32 firstFieldOffset = (U_32) objectClass->backfillOffset;\n+\n+\tif (hasReferences) {\n+\t\tconst UDATA *descriptionPtr = (UDATA *) objectClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n+\t\tif(((UDATA)descriptionPtr) & 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0058787a43610bbe517af08c305f72f8206e9f49"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTExNDE5OnYy", "diffSide": "RIGHT", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNToxNjoyM1rOHaisNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDowODo1MVrOHbvFig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5MzM5OA==", "bodyText": "There's no need for the zero check here (and elsewhere this pattern appears).", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r497593398", "createdAt": "2020-09-30T15:16:23Z", "author": {"login": "gacholio"}, "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1481,49 +1501,70 @@ MM_ObjectAccessBarrier::copyObjectFields(J9VMThread *vmThread, J9Class *objectCl\n \t\t}\n \t}\n \n-\tconst UDATA *descriptionPtr = (UDATA *) objectClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n-\n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n \tUDATA offset = 0;\n \tUDATA limit = objectClass->totalInstanceSize;\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n+\tU_32 firstFieldOffset = (U_32) objectClass->backfillOffset;\n+\n+\tif (hasReferences) {\n+\t\tconst UDATA *descriptionPtr = (UDATA *) objectClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n+\t\tif(((UDATA)descriptionPtr) & 1) {\n+\t\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n+\t\t} else {\n+\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t}\n \n-\tif (isValueType) {\n-\t\tU_32 firstFieldOffset = (U_32) objectClass->backfillOffset;\n-\t\tif (0 != firstFieldOffset) {\n-\t\t\t/* subtract padding */\n-\t\t\toffset += firstFieldOffset;\n-\t\t\tdescriptionBits >>= 1;\n-\t\t\tdescriptionIndex -= 1;\n+\t\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\n+\t\tif (isValueType) {\n+\t\t\tif (0 != firstFieldOffset) {\n+\t\t\t\t/* subtract padding */\n+\t\t\t\toffset += firstFieldOffset;\n+\t\t\t\tdescriptionBits >>= 1;\n+\t\t\t\tdescriptionIndex -= 1;\n+\t\t\t}\n \t\t}\n-\t}\n \n-\twhile (offset < limit) {\n-\t\t/* Determine if the slot contains an object pointer or not */\n-\t\tif(descriptionBits & 1) {\n-\t\t\tJ9Object *objectPtr = mixedObjectReadObject(vmThread, srcObject, srcOffset + offset, false);\n-\t\t\tmixedObjectStoreObject(vmThread, destObject, destOffset + offset, objectPtr, false);\n-\t\t} else {\n+\t\twhile (offset < limit) {\n+\t\t\t/* Determine if the slot contains an object pointer or not */\n+\t\t\tif(descriptionBits & 1) {\n+\t\t\t\tJ9Object *objectPtr = mixedObjectReadObject(vmThread, srcObject, srcOffset + offset, false);\n+\t\t\t\tmixedObjectStoreObject(vmThread, destObject, destOffset + offset, objectPtr, false);\n+\t\t\t} else {\n+\t\t\t\tUDATA srcAddress = (UDATA)srcObject + srcOffset + offset;\n+\t\t\t\tUDATA destAddress = (UDATA)destObject + destOffset + offset;\n+\t\t\t\tif (sizeof(uint32_t) == referenceSize) {\n+\t\t\t\t\t*(uint32_t *)destAddress = *(uint32_t *)srcAddress;\n+\t\t\t\t} else {\n+\t\t\t\t\t*(uintptr_t *)destAddress = *(uintptr_t *)srcAddress;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tif(descriptionIndex-- == 0) {\n+\t\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t\t\tdescriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\t\t\t}\n+\t\t\toffset += referenceSize;\n+\t\t}\n+\t} else {\n+\t\t/* no instanceDescription bits needed on this path */\n+\t\tif (isValueType) {\n+\t\t\tif (0 != firstFieldOffset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0058787a43610bbe517af08c305f72f8206e9f49"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NTA2Ng==", "bodyText": "We are currently using firstFieldOffset to indicate the presence of pre-padding in valuetypes. If this check is skipped then the instance description bits will be misalligned in the flattened representation (since pre-padding is removed in these cases).\nI plan to address this in the next PR.", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498845066", "createdAt": "2020-10-02T14:08:51Z", "author": {"login": "tajila"}, "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1481,49 +1501,70 @@ MM_ObjectAccessBarrier::copyObjectFields(J9VMThread *vmThread, J9Class *objectCl\n \t\t}\n \t}\n \n-\tconst UDATA *descriptionPtr = (UDATA *) objectClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n-\n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n \tUDATA offset = 0;\n \tUDATA limit = objectClass->totalInstanceSize;\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(objectClass);\n+\tU_32 firstFieldOffset = (U_32) objectClass->backfillOffset;\n+\n+\tif (hasReferences) {\n+\t\tconst UDATA *descriptionPtr = (UDATA *) objectClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n+\t\tif(((UDATA)descriptionPtr) & 1) {\n+\t\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n+\t\t} else {\n+\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t}\n \n-\tif (isValueType) {\n-\t\tU_32 firstFieldOffset = (U_32) objectClass->backfillOffset;\n-\t\tif (0 != firstFieldOffset) {\n-\t\t\t/* subtract padding */\n-\t\t\toffset += firstFieldOffset;\n-\t\t\tdescriptionBits >>= 1;\n-\t\t\tdescriptionIndex -= 1;\n+\t\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\n+\t\tif (isValueType) {\n+\t\t\tif (0 != firstFieldOffset) {\n+\t\t\t\t/* subtract padding */\n+\t\t\t\toffset += firstFieldOffset;\n+\t\t\t\tdescriptionBits >>= 1;\n+\t\t\t\tdescriptionIndex -= 1;\n+\t\t\t}\n \t\t}\n-\t}\n \n-\twhile (offset < limit) {\n-\t\t/* Determine if the slot contains an object pointer or not */\n-\t\tif(descriptionBits & 1) {\n-\t\t\tJ9Object *objectPtr = mixedObjectReadObject(vmThread, srcObject, srcOffset + offset, false);\n-\t\t\tmixedObjectStoreObject(vmThread, destObject, destOffset + offset, objectPtr, false);\n-\t\t} else {\n+\t\twhile (offset < limit) {\n+\t\t\t/* Determine if the slot contains an object pointer or not */\n+\t\t\tif(descriptionBits & 1) {\n+\t\t\t\tJ9Object *objectPtr = mixedObjectReadObject(vmThread, srcObject, srcOffset + offset, false);\n+\t\t\t\tmixedObjectStoreObject(vmThread, destObject, destOffset + offset, objectPtr, false);\n+\t\t\t} else {\n+\t\t\t\tUDATA srcAddress = (UDATA)srcObject + srcOffset + offset;\n+\t\t\t\tUDATA destAddress = (UDATA)destObject + destOffset + offset;\n+\t\t\t\tif (sizeof(uint32_t) == referenceSize) {\n+\t\t\t\t\t*(uint32_t *)destAddress = *(uint32_t *)srcAddress;\n+\t\t\t\t} else {\n+\t\t\t\t\t*(uintptr_t *)destAddress = *(uintptr_t *)srcAddress;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tif(descriptionIndex-- == 0) {\n+\t\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t\t\tdescriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\t\t\t}\n+\t\t\toffset += referenceSize;\n+\t\t}\n+\t} else {\n+\t\t/* no instanceDescription bits needed on this path */\n+\t\tif (isValueType) {\n+\t\t\tif (0 != firstFieldOffset) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5MzM5OA=="}, "originalCommit": {"oid": "0058787a43610bbe517af08c305f72f8206e9f49"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzYwMTI2OnYy", "diffSide": "RIGHT", "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzoxOTozNlrOHb1f8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzozMzoyMFrOHb15wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MDEzMQ==", "bodyText": "expand this with '|| (j9gc_modron_wrtbar_always == _writeBarrierType))' similarly to the other site", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498950131", "createdAt": "2020-10-02T17:19:36Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -411,7 +411,8 @@ class MM_ObjectAccessBarrierAPI\n #if defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER)\n \t\treturn vmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_structuralCompareFlattenedObjects(vmThread, valueClass, lhsObject, rhsObject, startOffset);\n #else /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n-\t\tif (j9gc_modron_readbar_none != _readBarrierType) {\n+\t\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\t\tif (hasReferences && (j9gc_modron_readbar_none != _readBarrierType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "812ac569da026ea40bfac1d901c4fb907bb443f5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MzU0OA==", "bodyText": "even though this is a readonly operation?", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498953548", "createdAt": "2020-10-02T17:26:48Z", "author": {"login": "tajila"}, "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -411,7 +411,8 @@ class MM_ObjectAccessBarrierAPI\n #if defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER)\n \t\treturn vmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_structuralCompareFlattenedObjects(vmThread, valueClass, lhsObject, rhsObject, startOffset);\n #else /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n-\t\tif (j9gc_modron_readbar_none != _readBarrierType) {\n+\t\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\t\tif (hasReferences && (j9gc_modron_readbar_none != _readBarrierType)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MDEzMQ=="}, "originalCommit": {"oid": "812ac569da026ea40bfac1d901c4fb907bb443f5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NjczNw==", "bodyText": "ah, good point. then, no.\nthe other one was a mix of both reads and writes, so I was hasty to assume this was the same case.", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498956737", "createdAt": "2020-10-02T17:33:20Z", "author": {"login": "amicic"}, "path": "runtime/gc_include/ObjectAccessBarrierAPI.hpp", "diffHunk": "@@ -411,7 +411,8 @@ class MM_ObjectAccessBarrierAPI\n #if defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER)\n \t\treturn vmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_structuralCompareFlattenedObjects(vmThread, valueClass, lhsObject, rhsObject, startOffset);\n #else /* defined(J9VM_GC_ALWAYS_CALL_OBJECT_ACCESS_BARRIER) */\n-\t\tif (j9gc_modron_readbar_none != _readBarrierType) {\n+\t\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\t\tif (hasReferences && (j9gc_modron_readbar_none != _readBarrierType)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MDEzMQ=="}, "originalCommit": {"oid": "812ac569da026ea40bfac1d901c4fb907bb443f5"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzYyMjUwOnYy", "diffSide": "RIGHT", "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzoyNjo1MlrOHb1tcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzozMjowMFrOHb13RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MzU4Ng==", "bodyText": "this is more a question for my benefit: if these are not object pointers, what are they (and still care if it's compressed or not)?", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498953586", "createdAt": "2020-10-02T17:26:52Z", "author": {"login": "amicic"}, "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1393,52 +1393,72 @@ BOOLEAN\n MM_ObjectAccessBarrier::structuralCompareFlattenedObjects(J9VMThread *vmThread, J9Class *valueClass, j9object_t lhsObject, j9object_t rhsObject, UDATA startOffset)\n {\n \tbool result = true;\n-\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n \tbool const compressed = J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(vmThread);\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\tUDATA limit = valueClass->totalInstanceSize;\n+\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n+\tUDATA offset = 0;\n \n \tAssert_MM_true(J9_IS_J9CLASS_VALUETYPE(valueClass));\n \n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n+\tif (hasReferences) {\n+\t\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\t\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n \n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n-\tUDATA offset = 0;\n-\tUDATA limit = valueClass->totalInstanceSize;\n+\t\tif (0 != firstFieldOffset) {\n+\t\t\t/* subtract padding */\n+\t\t\toffset += firstFieldOffset;\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tdescriptionIndex -= 1;\n+\t\t}\n \n-\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n-\tif (0 != firstFieldOffset) {\n-\t\t/* subtract padding */\n-\t\toffset += firstFieldOffset;\n-\t\tdescriptionBits >>= 1;\n-\t\tdescriptionIndex -= 1;\n-\t}\n+\t\tif (((UDATA)descriptionPtr) & 1) {\n+\t\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n+\t\t} else {\n+\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t}\n \n-\twhile (offset < limit) {\n-\t\t/* Determine if the slot contains an object pointer or not */\n-\t\tif(descriptionBits & 1) {\n-\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n-\t\t\t\tresult = false;\n-\t\t\t\tbreak;\n+\n+\t\twhile (offset < limit) {\n+\t\t\t/* Determine if the slot contains an object pointer or not */\n+\t\t\tif (descriptionBits & 1) {\n+\t\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n+\t\t\t\t\tresult = false;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfomrobject_t lhsValue = GC_SlotObject::readSlot((fomrobject_t*)((UDATA)lhsObject + startOffset + offset), compressed);\n+\t\t\t\tfomrobject_t rhsValue = GC_SlotObject::readSlot((fomrobject_t*)((UDATA)rhsObject + startOffset + offset), compressed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "812ac569da026ea40bfac1d901c4fb907bb443f5"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NjEwMQ==", "bodyText": "These are primitive fields. We still need slot sized loads because each iteration needs to match with the instance description bits. Whether we are compressed or not will determine how bytes each description bit represents.", "url": "https://github.com/eclipse-openj9/openj9/pull/10651#discussion_r498956101", "createdAt": "2020-10-02T17:32:00Z", "author": {"login": "tajila"}, "path": "runtime/gc_base/ObjectAccessBarrier.cpp", "diffHunk": "@@ -1393,52 +1393,72 @@ BOOLEAN\n MM_ObjectAccessBarrier::structuralCompareFlattenedObjects(J9VMThread *vmThread, J9Class *valueClass, j9object_t lhsObject, j9object_t rhsObject, UDATA startOffset)\n {\n \tbool result = true;\n-\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n-\tUDATA descriptionBits = 0;\n \tbool const compressed = J9VMTHREAD_COMPRESS_OBJECT_REFERENCES(vmThread);\n \tUDATA const referenceSize = J9VMTHREAD_REFERENCE_SIZE(vmThread);\n+\tbool hasReferences = J9CLASS_HAS_REFERENCES(valueClass);\n+\tUDATA limit = valueClass->totalInstanceSize;\n+\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n+\tUDATA offset = 0;\n \n \tAssert_MM_true(J9_IS_J9CLASS_VALUETYPE(valueClass));\n \n-\tif(((UDATA)descriptionPtr) & 1) {\n-\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n-\t} else {\n-\t\tdescriptionBits = *descriptionPtr++;\n-\t}\n+\tif (hasReferences) {\n+\t\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n+\t\tconst UDATA *descriptionPtr = (UDATA *) valueClass->instanceDescription;\n+\t\tUDATA descriptionBits = 0;\n \n-\tUDATA descriptionIndex = J9_OBJECT_DESCRIPTION_SIZE - 1;\n-\tUDATA offset = 0;\n-\tUDATA limit = valueClass->totalInstanceSize;\n+\t\tif (0 != firstFieldOffset) {\n+\t\t\t/* subtract padding */\n+\t\t\toffset += firstFieldOffset;\n+\t\t\tdescriptionBits >>= 1;\n+\t\t\tdescriptionIndex -= 1;\n+\t\t}\n \n-\tU_32 firstFieldOffset = (U_32) valueClass->backfillOffset;\n-\tif (0 != firstFieldOffset) {\n-\t\t/* subtract padding */\n-\t\toffset += firstFieldOffset;\n-\t\tdescriptionBits >>= 1;\n-\t\tdescriptionIndex -= 1;\n-\t}\n+\t\tif (((UDATA)descriptionPtr) & 1) {\n+\t\t\tdescriptionBits = ((UDATA)descriptionPtr) >> 1;\n+\t\t} else {\n+\t\t\tdescriptionBits = *descriptionPtr++;\n+\t\t}\n \n-\twhile (offset < limit) {\n-\t\t/* Determine if the slot contains an object pointer or not */\n-\t\tif(descriptionBits & 1) {\n-\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n-\t\t\t\tresult = false;\n-\t\t\t\tbreak;\n+\n+\t\twhile (offset < limit) {\n+\t\t\t/* Determine if the slot contains an object pointer or not */\n+\t\t\tif (descriptionBits & 1) {\n+\t\t\t\tif (mixedObjectReadObject(vmThread, lhsObject, startOffset + offset, false) != mixedObjectReadObject(vmThread, rhsObject, startOffset + offset, false)) {\n+\t\t\t\t\tresult = false;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfomrobject_t lhsValue = GC_SlotObject::readSlot((fomrobject_t*)((UDATA)lhsObject + startOffset + offset), compressed);\n+\t\t\t\tfomrobject_t rhsValue = GC_SlotObject::readSlot((fomrobject_t*)((UDATA)rhsObject + startOffset + offset), compressed);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MzU4Ng=="}, "originalCommit": {"oid": "812ac569da026ea40bfac1d901c4fb907bb443f5"}, "originalPosition": 64}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4632, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}